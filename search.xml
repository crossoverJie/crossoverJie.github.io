<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一致性 Hash 算法分析</title>
    <url>/2018/01/08/Consistent-Hash/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/04/29/5cc656bda3f66.jpg"></p>
<p>当我们在做数据库分库分表或者是分布式缓存时，不可避免的都会遇到一个问题:</p>
<p>如何将数据均匀的分散到各个节点中，并且尽量的在加减节点时能使受影响的数据最少。</p>
<h2 id="Hash-取模"><a href="#Hash-取模" class="headerlink" title="Hash 取模"></a>Hash 取模</h2><p>随机放置就不说了，会带来很多问题。通常最容易想到的方案就是 <code>hash 取模</code>了。</p>
<p>可以将传入的 Key 按照 <code>index = hash(key) % N</code> 这样来计算出需要存放的节点。其中 hash 函数是一个将字符串转换为正整数的哈希映射方法，N 就是节点的数量。</p>
<p>这样可以满足数据的均匀分配，但是这个算法的容错性和扩展性都较差。</p>
<p>比如增加或删除了一个节点时，所有的 Key 都需要重新计算，显然这样成本较高，为此需要一个算法满足分布均匀同时也要有良好的容错性和拓展性。</p>
<span id="more"></span>

<h2 id="一致-Hash-算法"><a href="#一致-Hash-算法" class="headerlink" title="一致 Hash 算法"></a>一致 Hash 算法</h2><p>一致 Hash 算法是将所有的哈希值构成了一个环，其范围在 <code>0 ~ 2^32-1</code>。如下图：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1b9fe31560.jpg"></p>
<p>之后将各个节点散列到这个环上，可以用节点的 IP、hostname 这样的唯一性字段作为 Key 进行 <code>hash(key)</code>，散列之后如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba01ebc22.jpg"></p>
<p>之后需要将数据定位到对应的节点上，使用同样的 <code>hash 函数</code> 将 Key 也映射到这个环上。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba05955b9.jpg"></p>
<p>这样按照顺时针方向就可以把 k1 定位到 <code>N1节点</code>，k2 定位到 <code>N3节点</code>，k3 定位到 <code>N2节点</code>。</p>
<h3 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h3><p>这时假设 N1 宕机了：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba07908f0.jpg"></p>
<p>依然根据顺时针方向，k2 和 k3 保持不变，只有 k1 被重新映射到了 N3。这样就很好的保证了容错性，当一个节点宕机时只会影响到少少部分的数据。</p>
<h3 id="拓展性"><a href="#拓展性" class="headerlink" title="拓展性"></a>拓展性</h3><p>当新增一个节点时:</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba0c7519c.jpg"></p>
<p>在 N2 和 N3 之间新增了一个节点 N4 ，这时会发现受印象的数据只有 k3，其余数据也是保持不变，所以这样也很好的保证了拓展性。</p>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>到目前为止该算法依然也有点问题:</p>
<p>当节点较少时会出现数据分布不均匀的情况：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba12a3b62.jpg"></p>
<p>这样会导致大部分数据都在 N1 节点，只有少量的数据在 N2 节点。</p>
<p>为了解决这个问题，一致哈希算法引入了虚拟节点。将每一个节点都进行多次 hash，生成多个节点放置在环上称为虚拟节点:</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba1490a67.jpg"></p>
<p>计算时可以在 IP 后加上编号来生成哈希值。</p>
<p>这样只需要在原有的基础上多一步由虚拟节点映射到实际节点的步骤即可让少量节点也能满足均匀性。</p>
<h2 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h2><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>LinkedHashMap 底层分析</title>
    <url>/2018/02/06/LinkedHashMap/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1ba27b00e4.jpg"></p>
<p>众所周知 <a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/HashMap.md">HashMap</a> 是一个无序的 <code>Map</code>，因为每次根据 <code>key</code> 的 <code>hashcode</code> 映射到 <code>Entry</code> 数组上，所以遍历出来的顺序并不是写入的顺序。</p>
<p>因此 JDK 推出一个基于 <code>HashMap</code> 但具有顺序的 <code>LinkedHashMap</code> 来解决有排序需求的场景。</p>
<p>它的底层是继承于 <code>HashMap</code> 实现的，由一个双向链表所构成。</p>
<p><code>LinkedHashMap</code> 的排序方式有两种：</p>
<ul>
<li>根据写入顺序排序。</li>
<li>根据访问顺序排序。</li>
</ul>
<p>其中根据访问顺序排序时，每次 <code>get</code> 都会将访问的值移动到链表末尾，这样重复操作就能的到一个按照访问顺序排序的链表。</p>
<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">	map.put(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>) ;</span><br><span class="line">	map.put(<span class="string">&quot;2&quot;</span>,<span class="number">2</span>) ;</span><br><span class="line">	map.put(<span class="string">&quot;3&quot;</span>,<span class="number">3</span>) ;</span><br><span class="line">	map.put(<span class="string">&quot;4&quot;</span>,<span class="number">4</span>) ;</span><br><span class="line">	map.put(<span class="string">&quot;5&quot;</span>,<span class="number">5</span>) ;</span><br><span class="line">	System.out.println(map.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试可以看到 <code>map</code> 的组成：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba2adf7c0.jpg"></p>
<p>打开源码可以看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// These fields comprise the doubly linked list used for iteration.</span></span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>其中 <code>Entry</code> 继承于 <code>HashMap</code> 的 <code>Entry</code>，并新增了上下节点的指针，也就形成了双向链表。</p>
<p>还有一个 <code>header</code> 的成员变量，是这个双向链表的头结点。 </p>
<p>上边的 demo 总结成一张图如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba2d418b6.jpg"></p>
<p>第一个类似于 <code>HashMap</code> 的结构，利用 <code>Entry</code> 中的 <code>next</code> 指针进行关联。</p>
<p>下边则是 <code>LinkedHashMap</code> 如何达到有序的关键。</p>
<p>就是利用了头节点和其余的各个节点之间通过 <code>Entry</code> 中的 <code>after</code> 和 <code>before</code> 指针进行关联。</p>
<p>其中还有一个 <code>accessOrder</code> 成员变量，默认是 <code>false</code>，默认按照插入顺序排序，为 <code>true</code> 时按照访问顺序排序，也可以调用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public LinkedHashMap(int initialCapacity,</span><br><span class="line">                     float loadFactor,</span><br><span class="line">                     boolean accessOrder) &#123;</span><br><span class="line">    super(initialCapacity, loadFactor);</span><br><span class="line">    this.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个构造方法可以显示的传入 <code>accessOrder </code>。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>LinkedHashMap</code> 的构造方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是调用的 <code>HashMap</code> 的构造方法:</p>
<p><code>HashMap</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">//HashMap 只是定义了改方法，具体实现交给了 LinkedHashMap</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到里面有一个空的 <code>init()</code>，具体是由 <code>LinkedHashMap</code> 来实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    header = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(-<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实也就是对 <code>header</code> 进行了初始化。</p>
<h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h2><p>看 <code>LinkedHashMap</code> 的 <code>put()</code> 方法之前先看看 <code>HashMap</code> 的 <code>put</code> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            //空实现，交给 LinkedHashMap 自己实现</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    // LinkedHashMap 对其重写</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// LinkedHashMap 对其重写</span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">        resize(2 * table.length);</span><br><span class="line">        hash = (null != key) ? hash(key) : 0;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// LinkedHashMap 对其重写</span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>

<p>主体的实现都是借助于 <code>HashMap</code> 来完成的，只是对其中的 <code>recordAccess(), addEntry(), createEntry()</code> 进行了重写。</p>
<p><code>LinkedHashMap</code> 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//就是判断是否是根据访问顺序排序，如果是则需要将当前这个 Entry 移动到链表的末尾</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> &#123;</span><br><span class="line">        LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">        <span class="keyword">if</span> (lm.accessOrder) &#123;</span><br><span class="line">            lm.modCount++;</span><br><span class="line">            remove();</span><br><span class="line">            addBefore(lm.header);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//调用了 HashMap 的实现，并判断是否需要删除最少使用的 Entry(默认不删除)    </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.addEntry(hash, key, value, bucketIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove eldest entry if instructed</span></span><br><span class="line">    Entry&lt;K,V&gt; eldest = header.after;</span><br><span class="line">    <span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;</span><br><span class="line">        removeEntryForKey(eldest.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, old);</span><br><span class="line">    <span class="comment">//就多了这一步，将新增的 Entry 加入到 header 双向链表中</span></span><br><span class="line">    table[bucketIndex] = e;</span><br><span class="line">    e.addBefore(header);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入到双向链表中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> &#123;</span><br><span class="line">        after  = existingEntry;</span><br><span class="line">        before = existingEntry.before;</span><br><span class="line">        before.after = <span class="built_in">this</span>;</span><br><span class="line">        after.before = <span class="built_in">this</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><p>LinkedHashMap 的 <code>get()</code> 方法也重写了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//多了一个判断是否是按照访问顺序排序，是则将当前的 Entry 移动到链表头部。</span></span><br><span class="line">    e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> &#123;</span><br><span class="line">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">    <span class="keyword">if</span> (lm.accessOrder) &#123;</span><br><span class="line">        lm.modCount++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        remove();</span><br><span class="line">        <span class="comment">//添加到头部</span></span><br><span class="line">        addBefore(lm.header);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><code>clear()</code> 清空就要比较简单了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只需要把指针都指向自己即可，原本那些 Entry 没有引用之后就会被 JVM 自动回收。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.clear();</span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说 <code>LinkedHashMap</code> 其实就是对 <code>HashMap</code> 进行了拓展，使用了双向链表来保证了顺序性。</p>
<p>因为是继承与 <code>HashMap</code> 的，所以一些 <code>HashMap</code> 存在的问题 <code>LinkedHashMap</code> 也会存在，比如不支持并发等。</p>
<h2 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h2><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LinkedHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux（一）常用命令</title>
    <url>/2016/04/10/Linux-normal/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>由于现在JAVA开发的很多应用都是部署到Linux系统上的，因此了解和掌握一些Linux的常用命令是非常有必要的，以下就是在Java开发过程中一些常用的命令。</p>
</blockquote>
<hr>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ol>
<li>查找文件<br><code>find / -name log.txt</code><br>根据名称查找在 &#x2F;目录下的 log.txt文件。</li>
</ol>
<p><code>find .-name &quot;*.xml&quot;</code><br>递归查找所有的xml文件。</p>
<p><code>find .-name &quot;*.xml&quot;|xargs grep &quot;hello&quot;</code><br>递归查找所有包含hello的xml文件。</p>
<p><code>ls -l grep &#39;jar&#39;</code><br>查找当前目录中的所有jar文件。 </p>
<span id="more"></span>
<ol start="2">
<li><p>检查一个文件是否运行<br><code>ps –ef|grep tomecate</code><br>检查所有有关tomcat的进程。</p>
</li>
<li><p>终止线程<br><code>kill -9 19979 </code><br>终止线程号为19979的线程</p>
</li>
<li><p>查看文件，包括隐藏文件。<br><code>ls -al</code></p>
</li>
<li><p>查看当前工作目录。<br><code>pwd</code></p>
</li>
<li><p>复制文件包括其子文件到指定目录<br><code>cp -r source target</code><br>复制source文件到target目录中。</p>
</li>
<li><p>创建一个目录<br><code>mkdir new</code><br>创建一个new的目录</p>
</li>
<li><p>删除目录(前提是此目录是空目录)<br><code>rmdir source</code><br>删除source目录。</p>
</li>
<li><p>删除文件 包括其子文件<br><code>rm -rf file</code><br>删除file文件和其中的子文件。<br><code>-r</code>表示向下递归，不管有多少目录一律删除<br><code>-f</code>表示强制删除，不做任何提示。</p>
</li>
<li><p>移动文件<br><code>mv /temp/movefile  /target</code></p>
</li>
<li><p>切换用户<br><code>su -username</code></p>
</li>
<li><p>查看ip<br><code>ifconfig</code><br>注意是 <code>ifconfig</code> 不是windows中的<code>ipconfig</code></p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是在Linux下开发Java应用常用的Linux命令，如有遗漏请在评论处补充，我将不定期添加。</p>
]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux（二）服务器运行环境配置</title>
    <url>/2016/09/20/Linux-normal2/</url>
    <content><![CDATA[<p><img src="https://ooo.0o0.ooo/2017/05/07/590ea8312b227.jpg" alt="linux2.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux相信对大多数程序员来说都不陌生，毕竟在服务器端依然还是霸主地位而且丝毫没有退居二线的意思，以至于现在几乎每一个软件开发的相关人员都得或多或少的知道一些Linux的相关内容，本文将介绍如何在刚拿到一台云服务器(采用<code>centos</code>)来进行运行环境的搭建，包括<code>JDK</code>、<code>Mysql</code>、<code>Tomcat</code>以及<code>nginx</code>。相信对于小白来说很有必要的，也是我个人的一个记录。</p>
<blockquote>
<p>该服务器的用途是用于部署JavaEE项目。<br>部署之后的效果图如下:<br><img src="https://ooo.0o0.ooo/2017/05/07/590ea878f1a8b.jpg" alt="mac背景.jpg"></p>
</blockquote>
<span id="more"></span>

<h1 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h1><p>由于我们之后需要部署的是<code>JavaEE</code>项目，所以首先第一步就是安装JDK了。</p>
<h2 id="卸载自带的openJDK"><a href="#卸载自带的openJDK" class="headerlink" title="卸载自带的openJDK"></a>卸载自带的openJDK</h2><p>现在的服务器拿来之后一般都是默认给我们安装一个<code>openJDK</code>，首先我们需要卸载掉。</p>
<ol>
<li>使用<code>rpm -qa | grep java</code>命令查看系统中是否存在有Java。</li>
<li>使用<code>rpm -e --nodeps 相关应用名称</code>来进行卸载。(相关应用名称就是上一个命令中显示出来的名称复制到这里卸载即可)。</li>
</ol>
<h2 id="下载并安装JDK"><a href="#下载并安装JDK" class="headerlink" title="下载并安装JDK"></a>下载并安装JDK</h2><ol>
<li>之后是下载<code>ORACLE</code>所提供的JDK，<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">传送门</a>根据自己系统的情况下载对应版本即可。笔者使用的是<code>jdk-8u101-linux-x64.rpm</code>版本。</li>
<li>然后使用FTP工具上传到<code>/usr/java</code>目录下即可，没有<code>java</code>目录新建一个即可。</li>
<li>然后使用<code>rpm -ivh jdk-8u101-linux-x64.rpm</code>命令进行解压安装。</li>
</ol>
<h2 id="profile文件配置"><a href="#profile文件配置" class="headerlink" title="profile文件配置"></a>profile文件配置</h2><p>安装完成之后使用<code>vi /etc/profile</code>命令编辑<code>profile</code>文件(注意该文件路径是指根目录下的etc文件夹不要找错了)。<br>在该文件中加入以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk-8u101-linux-x64</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>
<p>保存之后运行<code>source /etc/profile</code>使配置生效。</p>
<h2 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h2><p>之后我们使用在<code>windows</code>平台也有的命令<code>java -version</code>，如果输出如图：<br><img src="http://img.blog.csdn.net/20160920000008974" alt="2"><br>表示安装成功。</p>
<h1 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h1><h2 id="卸载自带的Mysql"><a href="#卸载自带的Mysql" class="headerlink" title="卸载自带的Mysql"></a>卸载自带的Mysql</h2><p>首先第一步还是要卸载掉自带的mysql。<br><code>rpm -e --nodeps mysql</code>命令和之前一样只是把应用名称换成mysql了而已。</p>
<h2 id="使用yum来安装mysql"><a href="#使用yum来安装mysql" class="headerlink" title="使用yum来安装mysql"></a>使用<code>yum</code>来安装mysql</h2><p>之后我们采用<code>yum</code>来安装mysql。这样的方式最简单便捷。<br><code>yum install -y mysql-server mysql mysql-deve</code>执行该命令直到出现<code>Complete!</code>提示之后表示安装成功。<br><code>rpm -qi mysql-server</code>之后使用该命令可以查看我们安装的mysql信息。</p>
<h2 id="mysql相关配置"><a href="#mysql相关配置" class="headerlink" title="mysql相关配置"></a>mysql相关配置</h2><p>使用<code>service mysqld start</code>来启动mysql服务(第一次会输出很多信息)，之后就不会了。<br>然后我们可以使用<code>chkconfig mysqld on</code>命令将mysql设置为开机启动。<br>输入<code>chkconfig --list | grep mysql</code>命令显示如下图：<br><img src="http://img.blog.csdn.net/20160920120817031" alt="3"><br>表示设置成功。<br>使用<code>mysqladmin -u root password &#39;root&#39;</code>为<code>root</code>账户设置密码。</p>
<h2 id="设置远程使用"><a href="#设置远程使用" class="headerlink" title="设置远程使用"></a>设置远程使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27; with grant option;</span><br><span class="line"># root是用户名，%代表任意主机，&#x27;123456&#x27;指定的登录密码（这个和本地的root密码可以设置不同的，互不影响）</span><br><span class="line">flush privileges; # 重载系统权限</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure>

<h2 id="验证使用"><a href="#验证使用" class="headerlink" title="验证使用"></a>验证使用</h2><p>使用<code>mysql -u root -proot</code>来登录mysql。如果出现以下界面表示设置成功。<br><img src="http://img.blog.csdn.net/20160920121542492" alt="4"></p>
<h1 id="Tomcat安装"><a href="#Tomcat安装" class="headerlink" title="Tomcat安装"></a>Tomcat安装</h1><p><code>Tomcat</code>也是我们运行<code>JavaEE</code>项目必备的一个中间件。</p>
<ol>
<li>第一步需要下载linux的Tomcat，<a href="http://tomcat.apache.org/download-80.cgi">传送门</a>。根据自己系统版本进行下载即可。之后将<code>apache-tomcat-8.5.5.tar.gz</code>上传到<code>/usr/local</code>目录中。</li>
<li>解压该压缩包<code>tar -zxv -f apache-tomcat-8.5.5.tar.gz</code>,再使用<code>mv apache-tomcat-8.5.5  tomcat</code>将解压的Tomcat移动到外层的<code>Tomcat</code>目录中。</li>
<li>进入<code>/usr/local/tomcat/apache-tomcat-8.5.5/bin</code>目录使用<code>./startup.bat</code>命令启动tomcat。</li>
<li>因为tomcat使用的默认端口是<code>8080</code>，linux防火墙默认是不能访问的，需要手动将其打开。使用<code>vi + /etc/sysconfig/iptables</code>编辑<code>iptables</code>(注意etc目录是根目录下的)，加入以下代码:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT</span><br><span class="line">-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure>
这里我们开放了8080和80端口，之后安装nginx就不用在开放了。<blockquote>
<p>ps:这里用到了简单的vim命令。按<code>i</code>进入插入模式，输入上面两段代码。之后按<code>esc</code>退出插入模式。再按<code>:wq</code>保存关闭即可。<br>之后使用<code>service iptables restart</code>命令重启防火墙即可。在浏览器输入服务器的<code>ip+8080</code>如果出现Tomcat的欢迎页即表明<code>Tomcat</code>安装成功。</p>
</blockquote>
</li>
</ol>
<h1 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h1><p>最后是安装<code>nginx</code>，这里我们还是使用最简单的<code>yum</code>的方式来进行安装。</p>
<ul>
<li>首先使用以下几个命令安装必备的几个库：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install pcre*</span><br><span class="line">yum -y install openssl*</span><br><span class="line">yum -y install gcc</span><br></pre></td></tr></table></figure></li>
<li>之后安装nginx。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">wget http://nginx.org/download/nginx-1.4.2.tar.gz</span><br><span class="line">tar -zxvf nginx-1.4.2.tar.gz</span><br><span class="line">cd nginx-1.4.2  </span><br><span class="line">./configure --prefix=/usr/local/nginx --with-http_stub_status_module</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li>
<li>之后就可以使用<code>/usr/local/nginx/sbin/nginx</code>命令来启动nginx了。输入服务器的IP地址，如果出现nginx的欢迎界面表示安装成功了。</li>
</ul>
<h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><p>这里我就简单贴以下我的配置，主要就是配置一个<code>upstream,</code>之后在<code>server</code>中引用配置的那个<code>upstream</code>即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    upstream crossover_main &#123;</span><br><span class="line">        server 127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.crossoverjie.top;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location  / &#123;</span><br><span class="line">             proxy_pass http://crossover_main/examples/;</span><br><span class="line">             proxy_set_header Host $http_host;</span><br><span class="line">             proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">             index  index.jsp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">        # concurs with nginx&#x27;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl                  on;</span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_protocols  SSLv2 SSLv3 TLSv1;</span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers   on;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后我们在地址栏输入服务器的IP地址(如果有域名解析了服务器的IP可以直接输入域名)就会进入我们在<code>upstream</code>中配置的地址加上在<code>server</code>中的地址。根据我这里的配置最后解析地址就是<code>http://127.0.0.1:8080/examples</code>应该是很好理解的。最终的结果是我在片头放的那张截图一样。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是一个简单的基于centOS的运行环境配置，对于小白练手应该是够了，有不清楚和错误的地方欢迎指出反正我也不会回复。<br><img src="http://i.imgur.com/wQmHabT.gif" alt="4"></p>
<blockquote>
<p>个人博客地址：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
<blockquote>
<p>GitHub地址：<a href="https://github.com/crossoverJie">https://github.com/crossoverJie</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>centos</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown小计</title>
    <url>/2016/05/06/Markdown%E5%B0%8F%E8%AE%A1/</url>
    <content><![CDATA[<p><code># 标题</code> </p>
<h1 id="表示标题-一个-号代表一级标题，以此类推。"><a href="#表示标题-一个-号代表一级标题，以此类推。" class="headerlink" title="表示标题 一个#号代表一级标题，以此类推。"></a>表示标题 一个#号代表一级标题，以此类推。</h1><p> <code>* 无序列表</code></p>
<ul>
<li>无序列表</li>
</ul>
<p><code>&gt; 引用</code>  </p>
<blockquote>
<p>引用</p>
</blockquote>
<p><code>[http://www.baidu.com](http://www.baidu.com &quot;百度&quot;)</code></p>
<p><a href="http://www.baidu.com/" title="百度">百度</a></p>
<span id="more"></span>

<p><code>![艾弗森](http://i.imgur.com/TLnZ2S6.jpg)插入图片</code></p>
<p><img src="http://i.imgur.com/TLnZ2S6.jpg" alt="艾弗森">
    </p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock 实现原理</title>
    <url>/2018/01/25/ReentrantLock/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1ba3295dda.jpg"></p>
<p>使用 <code>synchronize</code> 来做同步处理时，锁的获取和释放都是隐式的，实现的原理是通过编译后加上不同的机器指令来实现。</p>
<p>而 <code>ReentrantLock</code> 就是一个普通的类，它是基于 <code>AQS(AbstractQueuedSynchronizer)</code>来实现的。</p>
<p>是一个<strong>重入锁</strong>：一个线程获得了锁之后仍然可以<strong>反复</strong>的加锁，不会出现自己阻塞自己的情况。</p>
<blockquote>
<p><code>AQS</code> 是 <code>Java</code> 并发包里实现锁、同步的一个重要的基础框架。</p>
</blockquote>
<h2 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h2><p>ReentrantLock 分为<strong>公平锁</strong>和<strong>非公平锁</strong>，可以通过构造方法来指定具体类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认一般使用<strong>非公平锁</strong>，它的效率和吞吐量都比公平锁高的多(后面会分析具体原因)。</p>
<span id="more"></span>

<h2 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h2><p>通常的使用方式如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do bussiness</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="公平锁获取锁"><a href="#公平锁获取锁" class="headerlink" title="公平锁获取锁"></a>公平锁获取锁</h3><p>首先看下获取锁的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是使用 <code>sync</code>的方法，而这个方法是一个抽象方法，具体是由其子类(<code>FairSync</code>)来实现的，以下是公平锁的实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">       acquire(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//AbstractQueuedSynchronizer 中的 acquire()</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">       acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">       selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步是尝试获取锁(<code>tryAcquire(arg)</code>),这个也是由其子类实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会判断 <code>AQS</code> 中的 <code>state</code> 是否等于 0，0 表示目前没有其他线程获得锁，当前线程就可以尝试获取锁。</p>
<p><strong>注意</strong>:尝试之前会利用 <code>hasQueuedPredecessors()</code> 方法来判断 AQS 的队列中中是否有其他线程，如果有则不会尝试获取锁(<strong>这是公平锁特有的情况</strong>)。</p>
<p>如果队列中没有线程就利用 CAS 来将 AQS 中的 state 修改为1，也就是获取锁，获取成功则将当前线程置为获得锁的独占线程(<code>setExclusiveOwnerThread(current)</code>)。</p>
<p>如果 <code>state</code> 大于 0 时，说明锁已经被获取了，则需要判断获取锁的线程是否为当前线程(<code>ReentrantLock</code> 支持重入)，是则需要将 <code>state + 1</code>，并将值更新。</p>
<h4 id="写入队列"><a href="#写入队列" class="headerlink" title="写入队列"></a>写入队列</h4><p>如果 <code>tryAcquire(arg)</code> 获取锁失败，则需要用 <code>addWaiter(Node.EXCLUSIVE)</code> 将当前线程写入队列中。</p>
<p>写入之前需要将当前线程包装为一个 <code>Node</code> 对象(<code>addWaiter(Node.EXCLUSIVE)</code>)。</p>
<blockquote>
<p>AQS 中的队列是由 Node 节点组成的双向链表实现的。</p>
</blockquote>
<p>包装代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先判断队列是否为空，不为空时则将封装好的 <code>Node</code> 利用 <code>CAS</code> 写入队尾，如果出现并发写入失败就需要调用 <code>enq(node);</code> 来写入了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个处理逻辑就相当于<code>自旋</code>加上 <code>CAS</code> 保证一定能写入队列。</p>
<h4 id="挂起等待线程"><a href="#挂起等待线程" class="headerlink" title="挂起等待线程"></a>挂起等待线程</h4><p>写入队列之后需要将当前线程挂起(利用<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会根据 <code>node.predecessor()</code> 获取到上一个节点是否为头节点，如果是则尝试获取一次锁，获取成功就万事大吉了。</p>
<p>如果不是头节点，或者获取锁失败，则会根据上一个节点的 <code>waitStatus</code> 状态来处理(<code>shouldParkAfterFailedAcquire(p, node)</code>)。</p>
<p><code>waitStatus</code> 用于记录当前节点的状态，如节点取消、节点等待等。</p>
<p><code>shouldParkAfterFailedAcquire(p, node)</code> 返回当前线程是否需要挂起，如果需要则调用 <code>parkAndCheckInterrupt()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他是利用 <code>LockSupport</code> 的 <code>part</code> 方法来挂起当前线程的，直到被唤醒。</p>
<h3 id="非公平锁获取锁"><a href="#非公平锁获取锁" class="headerlink" title="非公平锁获取锁"></a>非公平锁获取锁</h3><p>公平锁与非公平锁的差异主要在获取锁：</p>
<p>公平锁就相当于买票，后来的人需要排到队尾依次买票，<strong>不能插队</strong>。</p>
<p>而非公平锁则没有这些规则，是<strong>抢占模式</strong>，每来一个人不会去管队列如何，直接尝试获取锁。</p>
<p>非公平锁:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//直接尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平锁:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还要一个重要的区别是在尝试获取锁时<code>tryAcquire(arg)</code>，非公平锁是不需要判断队列中是否还有其他线程，也是直接尝试获取锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//没有 !hasQueuedPredecessors() 判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>公平锁和非公平锁的释放流程都是一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        	   <span class="comment">//唤醒被挂起的线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试释放锁</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p>首先会判断当前线程是否为获得锁的线程，由于是重入锁所以需要将 <code>state</code> 减到 0 才认为完全释放锁。</p>
<p>释放之后需要调用 <code>unparkSuccessor(h)</code> 来唤醒被挂起的线程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于公平锁需要关心队列的情况，得按照队列里的先后顺序来获取锁(会造成大量的线程上下文切换)，而非公平锁则没有这个限制。</p>
<p>所以也就能解释非公平锁的效率会被公平锁更高。</p>
<h2 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h2><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ReentrantLock</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(一)框架的整合</title>
    <url>/2016/06/28/SSM1/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/07/26/5977859dadb97.jpeg" alt="ssmo1.jpeg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近这几年<code>JetBrains</code>公司开发的<code>IDEA</code>是越来越流行了，甚至Google的官方IDE都是<code>IDEA</code>来定制的，可见IDEA的发展趋势是越来越好，由于博主接触IDEA的时间也不长，所以有关<code>IDEA</code>和<code>Eclipse</code>的区别和优劣势请自行百度了。<br>借此机会我就使用IDEA来整合一下SSM，针对于初学者(初次使用IDEA和JAVAEE初学者)还是有帮助的。</p>
<hr>
<h1 id="新建SSM项目"><a href="#新建SSM项目" class="headerlink" title="新建SSM项目"></a>新建SSM项目</h1><p>哦对了，关于IDEA的版本问题强烈建议使用旗舰版，有条件的就购买，没条件的嘛。。天朝你懂的。<br>在欢迎界面点击<code>Create New Project</code>。<br><img src="http://i.imgur.com/St7JEw7.png"></p>
<span id="more"></span>
<p>之后选择<code>Maven</code>(新建JAVAEE项目是需要安装JDK的，这个就不在这里讲解了。)选好之后点击下一步。<br><img src="http://i.imgur.com/5kSWIla.png"><br>之后填入<code>GroupID</code>和<code>ArtifactID</code>这里尽量按照Maven的命名规范来即可。<br><img src="http://i.imgur.com/DiiEJ4h.png"><br>之后点击下一步，填入项目名称，这里我建议和之前填写的<code>ArtifactID</code>名称一样即可。<br><img src="http://i.imgur.com/aOJC4Ic.png"><br>点击Finish完成项目的创建。<br>之后尽量不要做其他操作，让IDEA完成索引创建。<br><img src="http://i.imgur.com/rWOtgha.png"></p>
<h1 id="完善目录结构"><a href="#完善目录结构" class="headerlink" title="完善目录结构"></a>完善目录结构</h1><p>首先观察一下IDEA给我们生成的目录结构，这是一个标准的Maven目录。但是其中少了一个<code>webapp</code>目录用于存放<code>jsp</code>、<code>css</code>、<code>js</code>、图片之类的文件。之后还需要完善我们的目录结构，如下图：<br><img src="http://i.imgur.com/u2xPqCS.png"><br>以上的命名都是我们开发过程中常用的命名规则，不一定按照我这样来，但是最好是有一定的规范。</p>
<hr>
<h1 id="POM-xml"><a href="#POM-xml" class="headerlink" title="POM.xml"></a>POM.xml</h1><p><code>pom.xml</code>是整个maven的核心配置文件，里面有对项目的描述和项目所需要的依赖。哦对了，在修改<code>pom.xml</code>文件之前我们最好先设置一下该项目的Maven设置(IDEA对每个项目的maven设置和Eclipse不一样，不是设置一次就可了，如果今后还要新建项目那就还需要设置，同时按住<code>ctrl</code>,<code>alt</code>,<code>s</code>是打开设置的快捷键，更多有关IDEA的操作今后会更新相关博文。)<br><img src="http://i.imgur.com/fCaXCDT.png"></p>
<h2 id="IDEA的Maven设置"><a href="#IDEA的Maven设置" class="headerlink" title="IDEA的Maven设置"></a>IDEA的Maven设置</h2><p>在<code>Eclipse</code>中用过Maven的都应该知道，这里是将项目的Maven换成我们自己安装的Maven，下面两个目录是选择Maven配置文件，不知道是什么原因在<code>Eclipse</code>中选择了配置文件之后会自动的将Maven本地厂库的路径更改为你<code>settings.xml</code>中配置的路径。既然这里没有自动选中那我们就手动修改即可，尽量不要放在C盘，一是用久之后本地厂库占用的空间会比较大，二是万一系统崩溃的话还有可能找回来。</p>
<h2 id="修改pom-xml"><a href="#修改pom-xml" class="headerlink" title="修改pom.xml"></a>修改pom.xml</h2><p>以下是我的<code>pom.xml</code>文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--suppress MavenModelInspection --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crossoverJie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SSM<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.1.4.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jackson.version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">jackson.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- spring --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 使用SpringMVC需配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 关系型数据库整合时需配置 如hibernate jpa等 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- log4j --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mysql连接 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.34<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- json --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- aop --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- servlet --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0-alpha-1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 上传文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于<code>maven</code>的知识点我就不细讲了，毕竟这是一个整合教程。</p>
<hr>
<h1 id="spring-mvc-xml"><a href="#spring-mvc-xml" class="headerlink" title="spring-mvc.xml"></a>spring-mvc.xml</h1><p>这个配置文件是springMVC的配置文件：<br>里面的我都写有注释，应该都能看懂。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/context/spring-context-3.1.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.crossoverJie.controller&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot;</span></span><br><span class="line"><span class="comment">          class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;supportedMediaTypes&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;list&gt;</span></span><br><span class="line"><span class="comment">                &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;</span></span><br><span class="line"><span class="comment">            &lt;/list&gt;</span></span><br><span class="line"><span class="comment">        &lt;/property&gt;</span></span><br><span class="line"><span class="comment">    &lt;/bean&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 默认编码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 文件大小最大值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10485760000&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 内存中的最大值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;40960&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;mvc:interceptors&gt;</span></span><br><span class="line"><span class="comment">        &lt;mvc:interceptor&gt;</span></span><br><span class="line"><span class="comment">            &amp;lt;!&amp;ndash; &lt;mvc:mapping path=&quot;/**&quot;/&gt;拦截所有 &amp;ndash;&amp;gt;</span></span><br><span class="line"><span class="comment">            &lt;mvc:mapping path=&quot;/user/**&quot;/&gt;</span></span><br><span class="line"><span class="comment">            &lt;mvc:mapping path=&quot;/role/**&quot;/&gt;</span></span><br><span class="line"><span class="comment">            &lt;mvc:mapping path=&quot;/function/**&quot;/&gt;</span></span><br><span class="line"><span class="comment">            &lt;mvc:mapping path=&quot;/news/**&quot;/&gt;</span></span><br><span class="line"><span class="comment">            &lt;mvc:mapping path=&quot;/img/**&quot;/&gt;</span></span><br><span class="line"><span class="comment">            &lt;bean class=&quot;com.crossoverJie.intercept.Intercept&quot;&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="comment">        &lt;/mvc:interceptor&gt;</span></span><br><span class="line"><span class="comment">    &lt;/mvc:interceptors&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于上面拦截器注释掉的那里，配置是没有问题的，因为这是一个整合项目，所以里边也没有用到拦截器，为了防止运行报错所以就先注释掉了。如果后续需要增加拦截器，可以参考这里的配置。</p>
<hr>
<h1 id="spring-mybatis-xml"><a href="#spring-mybatis-xml" class="headerlink" title="spring-mybatis.xml"></a>spring-mybatis.xml</h1><p>这个是spring和mybatis的整合配置文件，其中还有<code>Druid</code>连接池的配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/context/spring-context-3.1.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.crossoverJie&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;propertyConfigurer&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库的驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.user&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置初始化大小、最小、最大 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置获取连接等待超时的时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWait&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;300000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validationQuery&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SELECT &#x27;x&#x27;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnReturn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolPreparedStatementPerConnectionSize&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filters&quot;</span> <span class="attr">value</span>=<span class="string">&quot;stat&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自动扫描mapping.xml文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapping/*.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.crossoverJie.dao&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上两个就是最重要的配置文件了，只要其中的包名和配置文件中的名字一样就不会出问题。<br>关于<code>xxMpper.xml</code>以及实体类的生成，我们可以借助<code>mybatis-generator</code>自动生成工具来生成，方便快捷。</p>
<hr>
<h1 id="IDEA配置Tomcat"><a href="#IDEA配置Tomcat" class="headerlink" title="IDEA配置Tomcat"></a>IDEA配置Tomcat</h1><p>关于Tomcat的下载与安装我这里就不多介绍了。<br><img src="http://i.imgur.com/vJPS2Yh.png"><br>按照下图选择：<br><img src="http://i.imgur.com/FH695fj.png"><br>在<code>name</code>中为这个Tomcat输入一个名字。之后选择你本地Tomcat的目录点击<code>Ok</code>即可。<br><img src="http://i.imgur.com/f1RS3LJ.png"><br><img src="http://i.imgur.com/gKKK6YG.png"><br><img src="http://i.imgur.com/7jjk7JF.png"><br>点击<code>apply</code>和保存之后就返回首页即可看到Tomcat的标识。<br><img src="http://i.imgur.com/9Zw2ngh.png"><br>根据需要点击<code>Run</code>和<code>Debug</code>即可运行。</p>
<p>运行结果如下：<br><img src="http://i.imgur.com/zJgW4za.png"><br><img src="http://i.imgur.com/q8zyEJk.png"><br>点击上图的2,3,4可看到不同用户的结果，如果你走到这一步，那么恭喜你整合成功。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上源码都在github上。<br>项目地址：<a href="https://github.com/crossoverJie/SSM.git">SSM</a><br>欢迎拍砖。</p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>Mybatis</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(十) 项目重构-互联网项目的Maven结构</title>
    <url>/2017/03/04/SSM10/</url>
    <content><![CDATA[<p><img src="https://ooo.0o0.ooo/2017/03/03/58b992d46fd02.jpg" alt="互联网项目的maven.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很久没有更新博客了，之前定下周更逐渐成了月更。怎么感觉像我追过的一部动漫。<br>这个博文其实很早就想写了。<br>之前所有的代码都是在一个模块里面进行开发，这和maven的理念是完全不相符的，最近硬是抽了一个时间来对项目的结构进行了一次重构。</p>
<blockquote>
<p>先来看看这次重构之后的目录结构</p>
</blockquote>
<p><img src="https://ooo.0o0.ooo/2017/03/04/58b99366edad6.jpg" alt="1.jpg"></p>
<span id="more"></span>

<h1 id="为什么需要分模块"><a href="#为什么需要分模块" class="headerlink" title="为什么需要分模块"></a>为什么需要分模块</h1><blockquote>
<p>至于为什么要分模块呢？</p>
</blockquote>
<p>我们设想一个这样的场景：<br>在现在的互联网开发中，会把一个很大的系统拆分成各个子系统用于降低他们之间的耦合度。</p>
<p>在一个子项目中通常都会为<code>API</code>、<code>WEB</code>、<code>Service</code>等模块。<br>而且当项目够大时，这些通常都不是一个人能完成的工作，需要一个团队来各司其职。</p>
<p>想象一下：当之前所有的项目都在一个模块的时候，A改动了API，需要<code>Deploy</code>代码。而B也改动了<code>service</code>的代码，但并没有完全做完。所以A在提交<code>build</code>的时候就会报错</p>
<p>而且在整个项目足够大的时候，这个<code>build</code>的时间也是很影响效率的。</p>
<p>但让我将各个模块之间分开之后效果就不一样了。我修改了<code>API</code>我就只需要管我的就行，不需要整个项目进行<code>build</code>。</p>
<p>而且当有其他项目需要依赖我这个<code>API</code>的时候也只需要依赖<code>API</code>即可，不用整个项目都依赖过去。</p>
<h1 id="各个模块的作用"><a href="#各个模块的作用" class="headerlink" title="各个模块的作用"></a>各个模块的作用</h1><p>来看下这次我所分的模块。</p>
<h2 id="ROOT"><a href="#ROOT" class="headerlink" title="ROOT"></a>ROOT</h2><p>这是整个项目的根节点。<br>先看一下其中的<code>pom.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crossoverJie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SSM<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>SSM-API<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>SSM-BOOT<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>SSM-SERVICE<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>SSM-WEB<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.1.4.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jackson.version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">jackson.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lucene.version</span>&gt;</span>6.0.1<span class="tag">&lt;/<span class="name">lucene.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crossoverJie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SSM-API<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我截取了其中比较重点的配置。</p>
<p>由于这是父节点，所以我的<code>packag</code>类型使用的是<code>pom</code>。<br>其中分别有着四个子模块。</p>
<p>其中重点看下<code>&lt;dependencyManagement&gt;</code>这个标签。<br>如果使用的是<code>IDEA</code>这个开发工具的话是可以看到如下图：<br><img src="https://ooo.0o0.ooo/2017/03/04/58b997c0232ea.jpg" alt="2.jpg"></p>
<p>标红的有一个向下的箭头，点一下就可以进入子模块中相同的依赖。<br>这样子模块就不需要配置具体的版本了，统一由父模块来进行维护，对之后的版本升级也带来了好处。</p>
<h2 id="SSM-API"><a href="#SSM-API" class="headerlink" title="SSM-API"></a>SSM-API</h2><p>接下来看下<code>API</code>这个模块：</p>
<p>通常这个模块都是用于定义外部接口的，以及改接口所依赖的一些<code>DTO类</code>。<br>一般这个模块都是拿来给其他项目进行依赖，并和本项目进行数据交互的。</p>
<h2 id="SSM-BOOT"><a href="#SSM-BOOT" class="headerlink" title="SSM-BOOT"></a>SSM-BOOT</h2><p><code>BOOT</code>这个模块比较特殊。<br>可以看到这里没有任何代码，只有一个<code>rpc</code>的配置文件。<br>通常这个模块是用于给我们内部项目进行依赖的，并不像上面的<code>API</code>模块一样给其他部门或者是项目进行依赖的。</p>
<p>因为在我们的<code>RPC</code>调用的时候，用<code>dubbo</code>来举例，是需要配置所依赖的<code>consumer</code>。</p>
<p>但如果是我们自己内部调用的话我们就可以把需要调用自己的<code>dubbo</code>服务提供者配置在这里，这样的话我们自己调用就只需要依赖这个<code>BOOT</code>就可以进行调用了。</p>
<p>哦对了，<code>BOOT</code>同时还会依赖<code>API</code>，这样才实现了只依赖<code>BOOT</code>就可以调用自己内部的<code>dubbo</code>服务了。<br>如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crossoverJie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SSM-API<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="SSM-SERVICE"><a href="#SSM-SERVICE" class="headerlink" title="SSM-SERVICE"></a>SSM-SERVICE</h2><p><code>SERVICE</code>模块就比较好理解了。<br>是处理具体业务逻辑的地方，也是对之前的API的实现。</p>
<p>通常这也是一个<code>web</code>模块，所以我的<code>pom</code>类型是<code>WAR</code>。</p>
<h2 id="SSM-WEB"><a href="#SSM-WEB" class="headerlink" title="SSM-WEB"></a>SSM-WEB</h2><p>其实<code>WEB</code>模块和<code>SERVICE</code>模块有点重合了。通常来说这个模块一般在一个对外提供<code>http</code>访问接口的项目中。</p>
<p>这里只是为了展示项目结构，所以也写在了这里。</p>
<p>他的作用和<code>service</code>差不多，都是<code>WAR</code>的类型。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次没有实现什么特别的功能，只是对一些还没有接触过这种项目结构开发的童鞋能起到一些引导作用。</p>
<p>具体源码还请关注我的<code>github</code>。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/crossoverJie/SSM.git">https://github.com/crossoverJie/SSM.git</a></p>
</blockquote>
<blockquote>
<p>个人博客地址：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
<blockquote>
<p>GitHub地址：<a href="https://github.com/crossoverJie">https://github.com/crossoverJie</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(十一) 基于dubbo的分布式架构</title>
    <url>/2017/04/07/SSM11/</url>
    <content><![CDATA[<p><img src="https://ooo.0o0.ooo/2017/04/06/58e649d664665.jpg" alt="dubbo.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在越来越多的互联网公司还是将自己公司的项目进行服务化，这确实是今后项目开发的一个趋势，就这个点再凭借之前的<code>SSM</code>项目来让第一次接触的同学能快速上手。</p>
<h1 id="浅谈分布式架构"><a href="#浅谈分布式架构" class="headerlink" title="浅谈分布式架构"></a>浅谈分布式架构</h1><p><code>分布式架构</code>单看这个名字给人的感觉就是高逼格，但其实从历史的角度来分析一下就比较明了了。</p>
<blockquote>
<p>我们拿一个电商系统来说：</p>
</blockquote>
<h2 id="单系统"><a href="#单系统" class="headerlink" title="单系统"></a>单系统</h2><p><img src="https://ooo.0o0.ooo/2017/04/06/58e651937130f.png" alt="E65B5547-AF84-4D31-836D-72892C7AC7EA.png"><br>对于一个刚起步的创业公司项目肯定是追求越快完成功能越好，并且用户量也不大。</p>
<span id="more"></span>

<p>这时候所有的业务逻辑都是在一个项目中就可以满足。</p>
<h2 id="垂直拆分-多应用"><a href="#垂直拆分-多应用" class="headerlink" title="垂直拆分-多应用"></a>垂直拆分-多应用</h2><p><img src="https://ooo.0o0.ooo/2017/04/06/58e65856cf18a.jpg" alt="QQ20170406-230056@2x.jpg"><br>当业务量和用户量发展到一定地步的时候，这时一般会将应用同时部署到几台服务器上，在用户访问的时候使用<code>Nginx</code>进行反向代理和简单的负载均衡。</p>
<h2 id="SOA服务化"><a href="#SOA服务化" class="headerlink" title="SOA服务化"></a>SOA服务化</h2><p>当整个系统以及发展的足够大的时候，比如一个电商系统中存在有：</p>
<ul>
<li>用户系统</li>
<li>订单系统</li>
<li>支付系统</li>
<li>物流系统</li>
</ul>
<p>等系统。<br>如果每次修改了其中一个系统就要重新发布上线的话那么耦合就太严重了。</p>
<blockquote>
<p>所以需要将整个项目拆分成若干个独立的应用，可以进行独立的开发上线实现快速迭代。</p>
</blockquote>
<p><img src="https://ooo.0o0.ooo/2017/04/06/58e660509c5f5.png" alt="dubbo.png"></p>
<blockquote>
<p>如上图所示每个应用之间相互独立,每个应用可以消费其他应用暴露出来的服务，同时也对外提供服务。</p>
</blockquote>
<p>从架构的层面简单的理解了，接下来看看如何编码实现。</p>
<h1 id="基于dubbo的实现"><a href="#基于dubbo的实现" class="headerlink" title="基于dubbo的实现"></a>基于dubbo的实现</h1><p><code>dubbo</code>应该算是国内使用最多的分布式服务框架，基于此来实现对新入门的同学应该很有帮助。</p>
<blockquote>
<p>其中有涉及到安装dubbo服务的注册中心zookeeper等相关知识点可以自行查看<a href="http://dubbo.io/">官方文档</a>，这里就不单独讲了。</p>
</blockquote>
<h2 id="对外提供服务"><a href="#对外提供服务" class="headerlink" title="对外提供服务"></a>对外提供服务</h2><p>首先第一步需要在<code>SSM-API</code>模块中定义一个接口，这里就搞了一个用户查询的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function:用户API</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenjiec</span></span><br><span class="line"><span class="comment"> * Date: 2017/4/4 下午9:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserInfoApi</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> UserInfoRsp <span class="title function_">getUserInfo</span><span class="params">(<span class="type">int</span> userId)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在<code>SSM-SERVICE</code>模块中进行实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenjiec</span></span><br><span class="line"><span class="comment"> * Date: 2017/4/4 下午9:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoApiImpl</span> <span class="keyword">implements</span> <span class="title class_">UserInfoApi</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(UserInfoApiImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> T_userService t_userService ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserInfoRsp <span class="title function_">getUserInfo</span><span class="params">(<span class="type">int</span> userId)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;用户查询Id=&quot;</span>+userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回对象</span></span><br><span class="line">        <span class="type">UserInfoRsp</span> <span class="variable">userInfoRsp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfoRsp</span>() ;</span><br><span class="line">        <span class="type">T_user</span> <span class="variable">t_user</span> <span class="operator">=</span> t_userService.selectByPrimaryKey(userId) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建</span></span><br><span class="line">        buildUserInfoRsp(userInfoRsp,t_user) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userInfoRsp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userInfoRsp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t_user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildUserInfoRsp</span><span class="params">(UserInfoRsp userInfoRsp, T_user t_user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t_user ==  <span class="literal">null</span>)&#123;</span><br><span class="line">            t_user = <span class="keyword">new</span> <span class="title class_">T_user</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">        CommonUtil.setLogValueModelToModel(t_user,userInfoRsp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些都是通用的代码，但值得注意的一点是这里使用的<code>dubbo</code>框架所提供的<code>@service</code>注解。作用是声明需要暴露的服务接口。</p>
<p>再之后就是几个dubbo相关的配置文件了。</p>
<h3 id="spring-dubbo-config-xml"><a href="#spring-dubbo-config-xml" class="headerlink" title="spring-dubbo-config.xml"></a>spring-dubbo-config.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;ssm-service&quot;</span> <span class="attr">owner</span>=<span class="string">&quot;crossoverJie&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">organization</span>=<span class="string">&quot;ssm-crossoverJie&quot;</span> <span class="attr">logger</span>=<span class="string">&quot;slf4j&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;dubbo-registry&quot;</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://192.168.0.188:2181&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">file</span>=<span class="string">&quot;/tmp/dubbo.cachr&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">&quot;registry&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">timeout</span>=<span class="string">&quot;15000&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span> <span class="attr">delay</span>=<span class="string">&quot;-1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;15000&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>其实就是配置我们服务注册的zk地址，以及服务名称、超时时间等配置。</p>
<h3 id="spring-dubbo-provider-xml"><a href="#spring-dubbo-provider-xml" class="headerlink" title="spring-dubbo-provider.xml"></a>spring-dubbo-provider.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">&quot;com.crossoverJie.api.impl&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个配置扫描注解包的位置，一般配置到接口实现包即可。</p>
<h3 id="spring-dubbo-consumer-xml"><a href="#spring-dubbo-consumer-xml" class="headerlink" title="spring-dubbo-consumer.xml"></a>spring-dubbo-consumer.xml</h3><p>这个是消费者配置项，表明我们需要依赖的其他应用。<br>这里我们在<code>SSM-BOOT</code>项目中进行配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;userInfoApi&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">interface</span>=<span class="string">&quot;com.crossoverJie.api.UserInfoApi&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>直接就是配置的刚才我们提供的那个用户查询的接口，这样当我们自己的内部项目需要使用到这个服务只需要依赖<code>SSM-BOOT</code>即可，不需要单独的再去配置<code>consumer</code>。这个我有在上一篇<a href="http://crossoverjie.top/2017/03/04/SSM10/#SSM-BOOT">SSM(十) 项目重构-互联网项目的Maven结构</a>中也有提到。</p>
<h2 id="安装管理控制台"><a href="#安装管理控制台" class="headerlink" title="安装管理控制台"></a>安装管理控制台</h2><p>还有一个需要做的就是安装管理控制台，这里可以看到我们有多少服务、调用情况是怎么样等作用。</p>
<p>这里我们可以将dubbo的官方源码下载下来，对其中的<code>dubbo-admin</code>模块进行打包，将生成的<code>WAR包</code>放到<code>Tomcat</code>中运行起来即可。</p>
<p>但是需要注意一点的是：<br>需要将其中的<code>dubbo.properties</code>的zk地址修改为自己的即可。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.admin.root.password</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">dubbo.admin.guest.password</span>=<span class="string">guest</span></span><br></pre></td></tr></table></figure>
<p>到时候登陆的话使用root，密码也是root。<br>使用guest，密码也是guest。</p>
<p>登陆界面如下图：<br><img src="https://ooo.0o0.ooo/2017/04/07/58e66a9fba27d.jpg" alt="QQ20170407-001924@2x.jpg"></p>
<p>其中我们可以看到有两个服务以及注册上去了，但是没有消费者。</p>
<h2 id="消费服务"><a href="#消费服务" class="headerlink" title="消费服务"></a>消费服务</h2><p>为了能够更直观的体验到消费服务，我新建了一个项目：<br><a href="https://github.com/crossoverJie/SSM-CONSUMER">https://github.com/crossoverJie/SSM-CONSUMER</a>。</p>
<p>其中在<code>SSM-CONSUMER-API</code>中我也定义了一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function:薪资API</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenjiec</span></span><br><span class="line"><span class="comment"> * Date: 2017/4/4 下午9:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SalaryInfoApi</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取薪资</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> SalaryInfoRsp <span class="title function_">getSalaryInfo</span><span class="params">(<span class="type">int</span> userId)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为作为消费者的同时我们也对外提供了一个获取薪资的一个服务。</p>
<p>在<code>SSM-CONSUMER-SERVICE</code>模块中进行了实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenjiec</span></span><br><span class="line"><span class="comment"> * Date: 2017/4/4 下午9:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalaryInfoApiImpl</span> <span class="keyword">implements</span> <span class="title class_">SalaryInfoApi</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SalaryInfoApiImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserInfoApi userInfoApi ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SalaryInfoRsp <span class="title function_">getSalaryInfo</span><span class="params">(<span class="type">int</span> userId)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;薪资查询Id=&quot;</span>+userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回对象</span></span><br><span class="line">        <span class="type">SalaryInfoRsp</span> <span class="variable">salaryInfoRsp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SalaryInfoRsp</span>() ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用远程服务</span></span><br><span class="line">        <span class="type">UserInfoRsp</span> <span class="variable">userInfo</span> <span class="operator">=</span> userInfoApi.getUserInfo(userId);</span><br><span class="line">        </span><br><span class="line">        salaryInfoRsp.setUsername(userInfo.getUserName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> salaryInfoRsp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中就可以直接使用<code>userInfoApi</code>调用之前的个人信息服务。</p>
<p>再调用之前需要注意的有点是，我们只需要依赖<code>SSM-BOOT</code>这个模块即可进行调用，因为<code>SSM-BOOT</code>模块已经为我们配置了消费者之类的操作了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crossoverJie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SSM-BOOT<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有一点是在配置<code>SSM-BOOT</code>中的<code>spring-dubbo-cosumer.xml</code>配置文件的时候，路径要和我们初始化spring配置文件时的路径一致：<br><img src="https://ooo.0o0.ooo/2017/04/07/58e67422cd592.jpg" alt="QQ20170407-005850@2x.jpg"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring和mybatis的配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:spring/*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来跑个单测试一下能否调通：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenjiec</span></span><br><span class="line"><span class="comment"> *         Date: 2017/4/5 下午10:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &#123; &quot;classpath*:/spring/*.xml&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalaryInfoApiImplTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SalaryInfoApi salaryInfoApi ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSalaryInfo</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SalaryInfoRsp</span> <span class="variable">salaryInfo</span> <span class="operator">=</span> salaryInfoApi.getSalaryInfo(<span class="number">1</span>);</span><br><span class="line">        System.out.println(JSON.toJSONString(salaryInfo));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ooo.0o0.ooo/2017/04/07/58e66d2f65757.jpg" alt="消费者.jpg"><br>消费者</p>
<p><img src="https://ooo.0o0.ooo/2017/04/07/58e66d318a4c5.jpg" alt="提供者.jpg"><br>提供者<br>可以看到确实是调用成功了的。</p>
<p>接下来将消费者项目也同时启动在来观察管理控制台有什么不一样：<br><img src="https://ooo.0o0.ooo/2017/04/07/58e66e4917dd1.jpg" alt="QQ20170407-003413@2x.jpg"><br>会看到多了一个消费者所提供的服务<code>com.crossoverjie.consumer.api.SalaryInfoApi</code>,同时<br><code>com.crossoverJie.api.UserInfoApi</code>服务已经正常，说明已经有消费者了。</p>
<p><img src="https://ooo.0o0.ooo/2017/04/07/58e66e4904d89.jpg" alt="QQ20170407-003456@2x.jpg"><br>点进去便可查看具体的消费者。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这样一个基于dubbo的分布式服务已经讲的差不多了，在实际的开发中我们便会开发一个大系统中的某一个子应用，这样就算一个子应用出问题了也不会影响到整个大的项目。</p>
<p>再提一点：<br>在实际的生产环境一般同一个服务我们都会有一个<code>master</code>,<code>slave</code>的主从服务，这样在上线的过程中不至于整个应用出现无法使用的尴尬情况。</p>
<p>谈到了<code>SOA</code>的好处，那么自然也有相对于传统模式的不方便之处：</p>
<ul>
<li>拆分一个大的项目为成百上千的子应用就不可能手动上线了，即需要自动化的部署上线，如<code>Jenkins</code>。</li>
<li>还有一个需要做到的就是监控，需要一个单独的监控平台来帮我们实时查看各个服务的运行情况以便于及时定位和解决问题。</li>
<li>日志查看分析，拆分之后不可能再去每台服务器上查看日志，需要一个单独的日志查看分析工具如<code>elk</code>。</li>
</ul>
<p>以上就是我理解的，如有差错欢迎指正。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/crossoverJie/SSM.git">https://github.com/crossoverJie/SSM.git</a></p>
</blockquote>
<blockquote>
<p>个人博客地址：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
<blockquote>
<p>GitHub地址：<a href="https://github.com/crossoverJie">https://github.com/crossoverJie</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(十二) dubbo日志插件</title>
    <url>/2017/04/25/SSM12/</url>
    <content><![CDATA[<p><img src="https://ooo.0o0.ooo/2017/04/25/58ff0b1b40d27.jpg" alt="dubbo-filter.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在之前<a href="http://crossoverjie.top/2017/04/07/SSM11/">dubbo分布式框架中</a>讲到了如何利用dubbo来搭建一个微服务项目。其中还有一些值得优化提高开发效率的地方，比如日志：</p>
<blockquote>
<p>当我们一个项目拆分为N多个微服务之后，当其中一个调用另一个服务出现了问题，首先第一步自然是查看日志。 </p>
</blockquote>
<blockquote>
<p>出现问题的有很多情况，如提供方自身代码的问题，调用方的姿势不对等。</p>
</blockquote>
<blockquote>
<p>自身的问题这个管不了，但是我们可以对每一个入参、返回都加上日志，这样首先就可以判断调用方是否姿势不对了。</p>
</blockquote>
<blockquote>
<p>为了规范日志已经后续的可扩展，我们可以单独提供一个插件给每个项目使用即可。</p>
</blockquote>
<p>效果如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">2017-04-25</span> <span class="string">15:15:38,968 DEBUG [com.alibaba.dubbo.remoting.transport.DecodeHandler] -  [DUBBO] Decode decodeable message com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcInvocation, dubbo version: 2.5.3, current host: 127.0.0.1</span></span><br><span class="line"><span class="attr">2017-04-25</span> <span class="string">15:15:39,484 DEBUG [com.crossoverJie.dubbo.filter.DubboTraceFilter] - dubbo请求数据:&#123;&quot;args&quot;:[1],&quot;interfaceName&quot;:&quot;com.crossoverJie.api.UserInfoApi&quot;,&quot;methodName&quot;:&quot;getUserInfo&quot;&#125;</span></span><br><span class="line"><span class="attr">2017-04-25</span> <span class="string">15:15:39,484 INFO [com.crossoverJie.api.impl.UserInfoApiImpl] - 用户查询Id=1</span></span><br><span class="line"><span class="attr">2017-04-25</span> <span class="string">15:15:39,505 DEBUG [org.mybatis.spring.SqlSessionUtils] - Creating a new SqlSession</span></span><br><span class="line"><span class="attr">2017-04-25</span> <span class="string">15:15:39,525 DEBUG [org.mybatis.spring.SqlSessionUtils] - SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6f56b29] was not registered for synchronization because synchronization is not active</span></span><br><span class="line"><span class="attr">2017-04-25</span> <span class="string">15:15:39,549 DEBUG [org.mybatis.spring.transaction.SpringManagedTransaction] - JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@778b3121] will not be managed by Spring</span></span><br><span class="line"><span class="attr">2017-04-25</span> <span class="string">15:15:39,555 DEBUG [com.crossoverJie.api.dubbo.dao.T_userDao.selectByPrimaryKey] - ==&gt;  Preparing: select id, username, password,roleId from t_user where id = ? </span></span><br><span class="line"><span class="attr">2017-04-25</span> <span class="string">15:15:39,591 DEBUG [com.crossoverJie.api.dubbo.dao.T_userDao.selectByPrimaryKey] - ==&gt; Parameters: 1(Integer)</span></span><br><span class="line"><span class="attr">2017-04-25</span> <span class="string">15:15:39,616 DEBUG [com.crossoverJie.api.dubbo.dao.T_userDao.selectByPrimaryKey] - &lt;==      Total: 1</span></span><br><span class="line"><span class="attr">2017-04-25</span> <span class="string">15:15:39,616 DEBUG [com.alibaba.druid.pool.PreparedStatementPool] - &#123;conn-10003, pstmt-20000&#125; enter cache</span></span><br><span class="line"><span class="attr">2017-04-25</span> <span class="string">15:15:39,617 DEBUG [org.mybatis.spring.SqlSessionUtils] - Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6f56b29]</span></span><br><span class="line"><span class="attr">2017-04-25</span> <span class="string">15:15:45,473 INFO [com.crossoverJie.dubbo.filter.DubboTraceFilter] - dubbo执行成功</span></span><br><span class="line"><span class="attr">2017-04-25</span> <span class="string">15:15:45,476 DEBUG [com.crossoverJie.dubbo.filter.DubboTraceFilter] - dubbo返回数据&#123;&quot;args&quot;:[&#123;&quot;id&quot;:1,&quot;password&quot;:&quot;123456&quot;,&quot;roleId&quot;:1,&quot;userName&quot;:&quot;crossoverJie&quot;&#125;],&quot;interfaceName&quot;:&quot;com.crossoverJie.api.UserInfoApi&quot;,&quot;methodName&quot;:&quot;getUserInfo&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="dubbo-filter拓展"><a href="#dubbo-filter拓展" class="headerlink" title="dubbo filter拓展"></a>dubbo filter拓展</h1><p>参考<a href="http://dubbo.io/Developer+Guide-zh.htm#DeveloperGuide-zh-%E8%B0%83%E7%94%A8%E6%8B%A6%E6%88%AA%E6%89%A9%E5%B1%95">官方文档</a>，我们可以通过<code>com.alibaba.dubbo.rpc.Filter</code>进行拓展。</p>
<h2 id="定义实体"><a href="#定义实体" class="headerlink" title="定义实体"></a>定义实体</h2><p>首先定义一个实体类用于保存调用过程中的一些数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDesc</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String interfaceName ;<span class="comment">//接口名</span></span><br><span class="line">    <span class="keyword">private</span> String methodName ;<span class="comment">//方法名</span></span><br><span class="line">    <span class="keyword">private</span> Object[] args ;<span class="comment">//参数</span></span><br><span class="line">    <span class="comment">//省略getter setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="DubboTraceFilter具体拦截逻辑"><a href="#DubboTraceFilter具体拦截逻辑" class="headerlink" title="DubboTraceFilter具体拦截逻辑"></a>DubboTraceFilter具体拦截逻辑</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Activate(group = Constants.PROVIDER, order = -999)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboTraceFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(DubboTraceFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FilterDesc</span> <span class="variable">filterReq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDesc</span>() ;</span><br><span class="line">            filterReq.setInterfaceName(invocation.getInvoker().getInterface().getName());</span><br><span class="line">            filterReq.setMethodName(invocation.getMethodName()) ;</span><br><span class="line">            filterReq.setArgs(invocation.getArguments());</span><br><span class="line"></span><br><span class="line">            logger.debug(<span class="string">&quot;dubbo请求数据:&quot;</span>+JSON.toJSONString(filterReq));</span><br><span class="line"></span><br><span class="line">            <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> invoker.invoke(invocation);</span><br><span class="line">            <span class="keyword">if</span> (result.hasException() &amp;&amp; invoker.getInterface() != GenericService.class)&#123;</span><br><span class="line">                logger.error(<span class="string">&quot;dubbo执行异常&quot;</span>,result.getException());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;dubbo执行成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">FilterDesc</span> <span class="variable">filterRsp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDesc</span>() ;</span><br><span class="line">                filterRsp.setMethodName(invocation.getMethodName());</span><br><span class="line">                filterRsp.setInterfaceName(invocation.getInvoker().getInterface().getName());</span><br><span class="line">                filterRsp.setArgs(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;result.getValue()&#125;);</span><br><span class="line">                logger.debug(<span class="string">&quot;dubbo返回数据&quot;</span>+JSON.toJSONString(filterRsp));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result ;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">            logger.error(<span class="string">&quot;dubbo未知异常&quot;</span> + RpcContext.getContext().getRemoteHost()</span><br><span class="line">                    + <span class="string">&quot;. service: &quot;</span> + invoker.getInterface().getName() + <span class="string">&quot;, method: &quot;</span> + invocation.getMethodName()</span><br><span class="line">                    + <span class="string">&quot;, exception: &quot;</span> + e.getClass().getName() + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">            <span class="keyword">throw</span> e ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑非常简单，只是对调用过程、异常、成功之后打印相应的日志而已。</p>
<p>但是有个地方要注意一下：<br>需要在<code>resource</code>目录下加上<code>META-INF.dubbo/com.alibaba.dubbo.rpc.Filter</code>文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dubboTraceFilter=com.crossoverJie.dubbo.filter.DubboTraceFilter</span><br></pre></td></tr></table></figure>
<p>目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line"> |-main</span><br><span class="line">    |-java</span><br><span class="line">        |-com</span><br><span class="line">            |-xxx</span><br><span class="line">                |-XxxFilter.java (实现Filter接口)</span><br><span class="line">    |-resources</span><br><span class="line">        |-META-INF</span><br><span class="line">            |-dubbo</span><br><span class="line">                |-com.alibaba.dubbo.rpc.Filter (纯文本文件，内容为：xxx=com.xxx.XxxFilter)</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该项目已经托管到GitHub：<br><a href="https://github.com/crossoverJie/SSM-DUBBO-FILTER">https://github.com/crossoverJie/SSM-DUBBO-FILTER</a></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /SSM-DUBBO-FILTER</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在服务提供的项目中加上依赖，这样每次调用都会打上日志。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crossoverJie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SSM-TRACE-FILTER<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>在拦截器中最好不要加上一些耗时任务，需要考虑到性能问题。</strong></p>
<blockquote>
<p>项目地址：<a href="https://github.com/crossoverJie/SSM.git">https://github.com/crossoverJie/SSM.git</a></p>
</blockquote>
<blockquote>
<p>个人博客地址：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
<blockquote>
<p>GitHub地址：<a href="https://github.com/crossoverJie">https://github.com/crossoverJie</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(十三) 将dubbo暴露出HTTP服务</title>
    <url>/2017/05/07/SSM13/</url>
    <content><![CDATA[<p><img src="https://ooo.0o0.ooo/2017/05/20/591fd69dab028.jpg" alt="dubbo暴露为http服务.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常来说一个<code>dubbo</code>服务都是对内给内部调用的，但也有可能一个服务就是需要提供给外部使用，并且还不能有使用语言的局限性。</p>
<p>比较标准的做法是对外的服务我们统一提供一个<code>openAPI</code>，这样的调用方需要按照标准提供相应的<code>appID</code>以及密钥来进行验签才能使用。这样固然是比较规范和安全，但复杂度也不亚于开发一个单独的系统了。</p>
<p>这里所讲到的没有那么复杂，就只是把一个不需要各种权限检验的<code>dubbo</code>服务对外提供为<code>HTTP</code>服务。</p>
<p>调用示例:<br><img src="https://ooo.0o0.ooo/2017/05/20/591fd6d022182.jpg" alt="dubbo-http封面.jpg"></p>
<span id="more"></span>

<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>以下是本文所涉及到的一些知识点：</p>
<ul>
<li>Spring相关知识。</li>
<li>Java反射相关知识。</li>
<li>SpringMVC相关知识。</li>
</ul>
<blockquote>
<p>其实思路很简单，就是利用<code>SpringMVC</code>提供一个<code>HTTP</code>接口。<br>在该接口中通过入参进行反射找到具体的<code>dubbo</code>服务实现进行调用。</p>
</blockquote>
<h2 id="HttpProviderConf配置类"><a href="#HttpProviderConf配置类" class="headerlink" title="HttpProviderConf配置类"></a>HttpProviderConf配置类</h2><p>首先需要定义一个<code>HttpProviderConf</code>类用于保存声明需要对外提供服务的包名，毕竟我们反射时需要用到一个类的全限定名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpProviderConf</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供http访问的包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; usePackage ;</span><br><span class="line">    <span class="comment">//省略getter setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就只有一个<code>usePackage</code>成员变量，用于存放需要包名。<br>至于用<code>List</code>的原因是允许有多个。</p>
<h2 id="请求响应入参、出参"><a href="#请求响应入参、出参" class="headerlink" title="请求响应入参、出参"></a>请求响应入参、出参</h2><h3 id="HttpRequest入参"><a href="#HttpRequest入参" class="headerlink" title="HttpRequest入参"></a>HttpRequest入参</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String param ;<span class="comment">//入参</span></span><br><span class="line">    <span class="keyword">private</span> String service ;<span class="comment">//请求service</span></span><br><span class="line">    <span class="keyword">private</span> String method ;<span class="comment">//请求方法</span></span><br><span class="line">    <span class="comment">//省略getter setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>param</code>是用于存放真正调用<code>dubbo</code>服务时的入参，传入<code>json</code>在调用的时候解析成具体的参数对象。</p>
<p><code>service</code>存放<code>dubbo</code>服务声明的<code>interface API</code>的包名。</p>
<p><code>method</code>则是真正调用的方法名称。</p>
<h3 id="HttpResponse-响应"><a href="#HttpResponse-响应" class="headerlink" title="HttpResponse 响应"></a>HttpResponse 响应</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpResponse</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">552828440320737814L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> success;<span class="comment">//成功标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;<span class="comment">//信息码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;<span class="comment">//描述</span></span><br><span class="line">    <span class="comment">//省略getter setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是封装了常用的<code>HTTP</code>服务的响应数据。</p>
<h2 id="暴露服务controller"><a href="#暴露服务controller" class="headerlink" title="暴露服务controller"></a>暴露服务controller</h2><p>最重要的则是controller里的实现代码了。</p>
<p>先贴代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/dubboAPI&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboController</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(DubboController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HttpProviderConf httpProviderConf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存作用的map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; cacheMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;service&#125;/&#123;method&#125;&quot;,method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">api</span><span class="params">(HttpRequest httpRequest, HttpServletRequest request,</span></span><br><span class="line"><span class="params">                      <span class="meta">@PathVariable</span> String service,</span></span><br><span class="line"><span class="params">                      <span class="meta">@PathVariable</span> String method)</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;ip:&#123;&#125;-httpRequest:&#123;&#125;&quot;</span>,getIP(request), JSON.toJSONString(httpRequest));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">invoke</span> <span class="operator">=</span> invoke(httpRequest, service, method);</span><br><span class="line">        logger.debug(<span class="string">&quot;callback :&quot;</span>+invoke) ;</span><br><span class="line">        <span class="keyword">return</span> invoke ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">invoke</span><span class="params">(HttpRequest httpRequest,String service,String method)</span>&#123;</span><br><span class="line">        httpRequest.setService(service);</span><br><span class="line">        httpRequest.setMethod(method);</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpResponse</span>() ;</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">&quot;input param:&quot;</span>+JSON.toJSONString(httpRequest));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(httpProviderConf.getUsePackage()))&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isPac</span> <span class="operator">=</span> <span class="literal">false</span> ;</span><br><span class="line">            <span class="keyword">for</span> (String pac : httpProviderConf.getUsePackage()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (service.startsWith(pac))&#123;</span><br><span class="line">                    isPac = <span class="literal">true</span> ;</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isPac)&#123;</span><br><span class="line">                <span class="comment">//调用的是未经配置的包</span></span><br><span class="line">                logger.error(<span class="string">&quot;service is not correct,service=&quot;</span>+service);</span><br><span class="line">                response.setCode(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                response.setSuccess(<span class="literal">false</span>);</span><br><span class="line">                response.setDescription(<span class="string">&quot;service is not correct,service=&quot;</span>+service);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; serviceCla = cacheMap.get(service);</span><br><span class="line">            <span class="keyword">if</span> (serviceCla == <span class="literal">null</span>)&#123;</span><br><span class="line">                serviceCla = Class.forName(service) ;</span><br><span class="line">                logger.debug(<span class="string">&quot;serviceCla:&quot;</span>+JSON.toJSONString(serviceCla));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//设置缓存</span></span><br><span class="line">                cacheMap.put(service,serviceCla) ;</span><br><span class="line">            &#125;</span><br><span class="line">            Method[] methods = serviceCla.getMethods();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">targetMethod</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">            <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m.getName().equals(method))&#123;</span><br><span class="line">                    targetMethod = m ;</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (method == <span class="literal">null</span>)&#123;</span><br><span class="line">                logger.error(<span class="string">&quot;method is not correct,method=&quot;</span>+method);</span><br><span class="line">                response.setCode(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                response.setSuccess(<span class="literal">false</span>);</span><br><span class="line">                response.setDescription(<span class="string">&quot;method is not correct,method=&quot;</span>+method);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationContext.getBean(serviceCla);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = targetMethod.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (parameterTypes.length == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//没有参数</span></span><br><span class="line">                result = targetMethod.invoke(bean);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">json</span> <span class="operator">=</span> JSON.parseObject(httpRequest.getParam(), parameterTypes[<span class="number">0</span>]);</span><br><span class="line">                result = targetMethod.invoke(bean,json) ;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Can only have one parameter&quot;</span>);</span><br><span class="line">                response.setSuccess(<span class="literal">false</span>);</span><br><span class="line">                response.setCode(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                response.setDescription(<span class="string">&quot;Can only have one parameter&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJSONString(result) ;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            logger.error(<span class="string">&quot;class not found&quot;</span>,e);</span><br><span class="line">            response.setSuccess(<span class="literal">false</span>);</span><br><span class="line">            response.setCode(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            response.setDescription(<span class="string">&quot;class not found&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;InvocationTargetException&quot;</span>,e);</span><br><span class="line">            response.setSuccess(<span class="literal">false</span>);</span><br><span class="line">            response.setCode(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            response.setDescription(<span class="string">&quot;InvocationTargetException&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;IllegalAccessException&quot;</span>,e);</span><br><span class="line">            response.setSuccess(<span class="literal">false</span>);</span><br><span class="line">            response.setCode(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            response.setDescription(<span class="string">&quot;IllegalAccessException&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(response) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取IP</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getIP</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;X-Forwarded-For&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(s)) &#123;</span><br><span class="line"></span><br><span class="line">            s = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(s)) &#123;</span><br><span class="line"></span><br><span class="line">            s = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(s)) &#123;</span><br><span class="line">            s = request.getHeader(<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(s)) &#123;</span><br><span class="line"></span><br><span class="line">            s = request.getHeader(<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(s)) &#123;</span><br><span class="line"></span><br><span class="line">            s = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;127.0.0.1&quot;</span>.equals(s) || <span class="string">&quot;0:0:0:0:0:0:0:1&quot;</span>.equals(s))</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException unknownhostexception) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>先一步一步的看：</p>
<ul>
<li><p>首先是定义了一个<code>DubboController</code>,并使用了<code>SpringMVC</code>的注解对外暴露<code>HTTP</code>服务。</p>
</li>
<li><p>实现了<code>org.springframework.context.ApplicationContextAware</code>类，<br>实现了<code>setApplicationContext()</code>方法用于初始化<code>Spring</code>上下文对象，在之后可以获取到容器里的相应对象。</p>
</li>
<li><p>核心的<code>invoke()</code>方法。</p>
</li>
<li><p>调用时：<code>http://127.0.0.1:8080/SSM-SERVICE/dubboAPI/com.crossoverJie.api.UserInfoApi/getUserInfo</code>。</p>
</li>
<li><p>具体如上文的调用实例。先将<code>com.crossoverJie.api.UserInfoApi</code>、<code>getUserInfo</code>赋值到<code>httpRequest</code>入参中。</p>
</li>
<li><p>判断传入的包是否是对外提供的。如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--dubbo服务暴露为http服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.crossoverJie.dubbo.http.conf.HttpProviderConf&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;usePackage&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        	   <span class="comment">&lt;!--需要暴露服务的接口包名，可多个--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.crossoverJie.api<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--扫描暴露包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.crossoverJie.dubbo.http&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中的<code>com.crossoverJie.api</code>就是自己需要暴露的包名，可以多个。</p>
</li>
<li><p>接着在缓存<code>map</code>中取出反射获取到的接口类类型，如果获取不到则通过反射获取，并将值设置到缓存<code>map</code>中，这样不用每次都反射获取，可以节省系统开销(<code>反射很耗系统资源</code>)。</p>
</li>
<li><p>接着也是判断该接口中是否有传入的<code>getUserInfo</code>方法。</p>
</li>
<li><p>取出该方法的参数列表，如果没有参数则直接调用。</p>
</li>
<li><p>如果有参数，判断个数。这里最多只运行一个参数。也就是说在真正的<code>dubbo</code>调用的时候只能传递一个<code>BO</code>类型，具体的参数列表可以写到<code>BO</code>中。因为如果有多个在进行<code>json</code>解析的时候是无法赋值到两个参数对象中去的。</p>
</li>
<li><p>之后进行调用，将调用返回的数据进行返回即可。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通常来说这样提供的<code>HTTP</code>接口再实际中用的不多，但是很方便调试。</p>
<p>比如写了一个<code>dubbo</code>的查询接口，在测试环境或者是预发布环境中就可以直接通过<code>HTTP</code>请求的方式进行简单的测试，或者就是查询数据。比在<code>Java</code>中写单测来测试或查询快的很多。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/crossoverJie/SSM-DUBBO-HTTP.git</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd SSM-DUBBO-HTTP</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure>


<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crossoverJie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SSM-HTTP-PROVIDER<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="spring配置"><a href="#spring配置" class="headerlink" title="spring配置"></a>spring配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--dubbo服务暴露为http服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.crossoverJie.dubbo.http.conf.HttpProviderConf&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;usePackage&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        	   <span class="comment">&lt;!--需要暴露服务的接口包名，可多个--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.crossoverJie.api<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--扫描暴露包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.crossoverJie.dubbo.http&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 插件地址：<a href="https://github.com/crossoverJie/SSM-DUBBO-HTTP">https://github.com/crossoverJie/SSM-DUBBO-HTTP</a></p>
</blockquote>
<blockquote>
<p>项目地址：<a href="https://github.com/crossoverJie/SSM.git">https://github.com/crossoverJie/SSM.git</a></p>
</blockquote>
<blockquote>
<p>个人博客地址：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
<blockquote>
<p>GitHub地址：<a href="https://github.com/crossoverJie">https://github.com/crossoverJie</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>dubbo</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(十四) 基于annotation的http防重插件</title>
    <url>/2017/05/24/SSM14/</url>
    <content><![CDATA[<p><img src="https://ooo.0o0.ooo/2017/05/24/5924effab7d36.jpg" alt="防重插件封面.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>针对于我们现在常用的<code>RESTful API</code>通常我们需要对请求进行唯一标识，也就是每次都要带上一个请求号,如<code>reqNO</code>。</p>
<p>对于入库这种操作数据库的请求我们一般要保证他的唯一性，一个请求号通常只能用一次，所以需要我们对这种请求加上校验机制。</p>
<blockquote>
<p>该需求的实现思路是通过自定义<code>annotation</code>，只给需要进行校验的接口加上注解。然后通过切面使用了注解的接口将每次请求号存进<code>Redis</code>，每次都进行判断是否存在这个请求号即可。</p>
</blockquote>
<p>来看下加上本次插件的实际效果：<br><img src="https://ooo.0o0.ooo/2017/05/24/59253bc021bf3.jpg" alt="重复请求号01.jpg"><br><img src="https://ooo.0o0.ooo/2017/05/24/59253bc0291c1.jpg" alt="重复请求号02.jpg"><br><img src="https://ooo.0o0.ooo/2017/05/24/59253bc04016d.jpg" alt="重复请求号03.jpg"></p>
<span id="more"></span>

<h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p>首先我们要自定义一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CheckReqNo &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">desc</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>(ps:这里并不过多的讲解注解相关的知识)。</em></p>
<p>首先使用<code>@interface</code>来声明一个注解。接着利用<code>Java</code>为我们提供的三个元注解来定义<code>CheckReqNo</code>注解。</p>
<p>其中<code>@Target</code>表明这个注解被用于什么地方，使用<code>ElementType.METHOD</code>表明被应用到方法上，还有一些其他值可以查看<code>java.lang.annotation.ElementType</code>这个枚举类型。</p>
<p><code>@Retention</code>注解表明我们的注解在什么范围内有效，这里配置的<code>RetentionPolicy.RUNTIME</code>表明在运行时可以通过反射来获取。</p>
<p><code>@Documented</code>看字面意思应该也能猜到是用于生成<code>JavaDoc</code>文档的。</p>
<p>其中定义了一个<code>desc()</code>的方法其实并没有用到，但如果需要在使用注解的时候需要自定义一些<code>filed(域)</code>的需求可以按照这样的方式写到这里，通过反射都可以获取到具体的值。<br>如：<code> @CheckReqNo(desc = &quot;abc&quot;)</code>就可以获取到<code>&quot;abc&quot;</code>的值。</p>
<h1 id="切面注解"><a href="#切面注解" class="headerlink" title="切面注解"></a>切面注解</h1><p>按照之前的想法是在对所有使用了该注解的方法进行切面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReqNoDrcAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ReqNoDrcAspect.class);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;redis.prefixReq:reqNo&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String prefixReq ;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;redis.day:1&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> day ;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@PostConstruct</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		logger.info(<span class="string">&quot;SSM-REQUEST-CHECK init......&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Pointcut(&quot;@annotation(com.crossoverJie.request.anotation.CheckReqNo)&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkRepeat</span><span class="params">()</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Before(&quot;checkRepeat()&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		BaseRequest request;</span><br><span class="line">		request = getBaseRequest(joinPoint);</span><br><span class="line">		<span class="keyword">if</span>(request != <span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="type">String</span> <span class="variable">reqNo</span> <span class="operator">=</span> request.getReqNo();</span><br><span class="line">			<span class="keyword">if</span>(StringUtil.isEmpty(reqNo))&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;reqNo不能为空&quot;</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="type">String</span> <span class="variable">tempReqNo</span> <span class="operator">=</span> redisTemplate.opsForValue().get(prefixReq +reqNo);</span><br><span class="line">					logger.debug(<span class="string">&quot;tempReqNo=&quot;</span>+tempReqNo);</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span>((StringUtil.isEmpty(tempReqNo)))&#123;</span><br><span class="line">						redisTemplate.opsForValue().set(prefixReq + reqNo, reqNo, day, TimeUnit.DAYS);</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;请求号重复,reqNo=&quot;</span>+reqNo);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125; <span class="keyword">catch</span> (RedisConnectionFailureException e)&#123;</span><br><span class="line">					logger.error(<span class="string">&quot;redis操作异常&quot;</span>,e);</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;need redisService&quot;</span>) ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">public</span> <span class="keyword">static</span> BaseRequest <span class="title function_">getBaseRequest</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		 <span class="type">BaseRequest</span> <span class="variable">returnRequest</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		 Object[] arguments = joinPoint.getArgs();</span><br><span class="line">		 <span class="keyword">if</span>(arguments != <span class="literal">null</span> &amp;&amp; arguments.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			 returnRequest = (BaseRequest) arguments[<span class="number">0</span>];</span><br><span class="line">		 &#125;</span><br><span class="line">	     <span class="keyword">return</span> returnRequest;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>@Aspect</code>来定义了一个切面。<br>其中<code>prefixReq,day</code>域可以自定义缓存请求号时的<code>key</code>前缀以及缓存的时间。</p>
<p>最关键的一点是用<br><code>@Pointcut(&quot;@annotation(com.crossoverJie.request.anotation.CheckReqNo)&quot;)</code><br>定义了一个切入点，这样所有使用<code>@CheckReqNo</code>的注解都会被拦截。</p>
<p>接下来的逻辑就比较简单了，在每次请求之前进行拦截。</p>
<p>先去<code>Redis</code>中查看这个请求号(<code>ps:反射获取</code>)是否存在，如果不存在则通过并将本次的请求号缓存起来。如果存在则抛出异常。</p>
<h1 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h1><p>可以在<code>jdbc.properties</code>配置文件中自定义前缀和缓存时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#redis前缀</span><br><span class="line">redis.prefixReq=reqNo</span><br><span class="line">#redis缓存时间 默认单位为天</span><br><span class="line">redis.day=1</span><br></pre></td></tr></table></figure>
<p>不定义也可以，会使用默认值。</p>
<p>由于该注解是需要加到<code>controller</code>层,因此我们得使用<code>CGLIB</code>代理。<br>这里有一个坑，需要将开启<code>CGLIB </code>的配置配置到我们<code>web.xml</code>中的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring MVC servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里所定义的<code>spring-mvc.xml</code>文件中，不然<code>springMVC</code>所在的子容器是无法被父容器所加载的。</p>
<p>使用实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CheckReqNo</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/createRedisContent&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;NULLBody&gt; <span class="title function_">createRedisContent</span><span class="params">(<span class="meta">@RequestBody</span> RedisContentReq redisContentReq)</span>&#123;</span><br><span class="line">    BaseResponse&lt;NULLBody&gt; response = <span class="keyword">new</span> <span class="title class_">BaseResponse</span>&lt;NULLBody&gt;() ;</span><br><span class="line"></span><br><span class="line">    <span class="type">Rediscontent</span> <span class="variable">rediscontent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rediscontent</span>() ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        CommonUtil.setLogValueModelToModel(redisContentReq,rediscontent);</span><br><span class="line">        rediscontentMapper.insertSelective(rediscontent) ;</span><br><span class="line">        response.setReqNo(redisContentReq.getReqNo());</span><br><span class="line">        response.setCode(StatusEnum.SUCCESS.getCode());</span><br><span class="line">        response.setMessage(StatusEnum.SUCCESS.getMessage());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;system error&quot;</span>,e);</span><br><span class="line">        response.setReqNo(response.getReqNo());</span><br><span class="line">        response.setCode(StatusEnum.FAIL.getCode());</span><br><span class="line">        response.setMessage(StatusEnum.FAIL.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="统一异常controller"><a href="#统一异常controller" class="headerlink" title="统一异常controller"></a>统一异常controller</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ClassName: ErrorController &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * Function: 错误异常统一处理. &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> crossoverJie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">processUnauthenticatedException</span><span class="params">(NativeWebRequest request, Exception e)</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;请求出现异常:&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">        BaseResponse&lt;NULLBody&gt; response = <span class="keyword">new</span> <span class="title class_">BaseResponse</span>&lt;NULLBody&gt;();</span><br><span class="line">        response.setCode(StatusEnum.FAIL.getCode());</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RuntimeException)&#123;</span><br><span class="line">            response.setMessage(e.getMessage());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.setMessage(StatusEnum.FAIL.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样当controller层出现异常之后都会进入这里进行统一的返回。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此整个插件的流程已经全部OK，从中可以看出<code>Spring AOP</code>在实际开发中的各种好处。<br>之前的几篇文章也有应用到：</p>
<ul>
<li><a href="https://crossoverjie.top/2016/12/18/SSM7/">在JavaWeb应用中使用Redis</a></li>
<li><a href="https://crossoverjie.top/2017/01/05/SSM8/">动态切换数据源</a></li>
</ul>
<p>不知不觉这个小白入门的<code>SSM</code>系列已经更新了14篇了，在<code>GitHub</code>也有了500多颗星了，期间也和不少朋友有过交流、探讨，感谢大家的支持。</p>
<p><strong>接下来可能不太会更新这个系列了，由于博主现在所在的项目组采用的是目前比较流行的<code>SpringBoot+SpringCloud</code>和<code>Docker</code>的方式来进行架构的，所以之后的重心肯定会移到这方面，用过<code>SpringBoot</code>之后相信大家肯定也回不去了。</strong></p>
<p><strong>所以之后我会继续更新<code>SpringBoot+SpringCloud</code>相关的文章，欢迎持续关注，持续拍砖(<code>ps:这个插件也会用springBoot重写一遍</code>)</strong></p>
<blockquote>
<p>插件地址：<a href="https://github.com/crossoverJie/SSM-REQUEST-CHECK.git">https://github.com/crossoverJie/SSM-REQUEST-CHECK.git</a></p>
</blockquote>
<blockquote>
<p>项目地址：<a href="https://github.com/crossoverJie/SSM.git">https://github.com/crossoverJie/SSM.git</a></p>
</blockquote>
<blockquote>
<p>个人博客地址：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>annotation</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(十五) 乐观锁与悲观锁的实际应用</title>
    <url>/2017/07/09/SSM15/</url>
    <content><![CDATA[<p><img src="https://ooo.0o0.ooo/2017/07/09/5961d7fb41cf0.jpeg" alt="00.jpeg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着互联网的兴起，现在三高(<code>高可用、高性能、高并发</code>)项目是越来越流行。</p>
<p>本次来谈谈高并发。首先假设一个业务场景：数据库中有一条数据，需要获取到当前的值，在当前值的基础上<code>+10</code>，然后再更新回去。<br>如果此时有两个线程同时并发处理，第一个线程拿到数据是10，+10&#x3D;20更新回去。第二个线程原本是要在第一个线程的基础上再<code>+20=40</code>,结果由于并发访问取到更新前的数据为10，<code>+20=30</code>。</p>
<p>这就是典型的存在中间状态，导致数据不正确。来看以下的例子：</p>
<h1 id="并发所带来的问题"><a href="#并发所带来的问题" class="headerlink" title="并发所带来的问题"></a>并发所带来的问题</h1><p>和上文提到的类似，这里有一张<code>price</code>表，表结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `price` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">  `total` decimal(12,2) DEFAULT &#x27;0.00&#x27; COMMENT &#x27;总值&#x27;,</span><br><span class="line">  `front` decimal(12,2) DEFAULT &#x27;0.00&#x27; COMMENT &#x27;消费前&#x27;,</span><br><span class="line">  `end` decimal(12,2) DEFAULT &#x27;0.00&#x27; COMMENT &#x27;消费后&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1268 DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>我这里写了一个单测：就一个主线程，循环100次，每次把<code>front</code>的值减去10，再写入一次流水记录，正常情况是写入的每条记录都会每次减去10。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单线程消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">singleCounsumerTest1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">100</span> ;i++)&#123;</span><br><span class="line">        <span class="type">Price</span> <span class="variable">price</span> <span class="operator">=</span> priceMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ron</span> <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line">        price.setFront(price.getFront().subtract(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(ron)));</span><br><span class="line">        price.setEnd(price.getEnd().add(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(ron)));</span><br><span class="line">        price.setTotal(price.getFront().add(price.getEnd()));</span><br><span class="line"></span><br><span class="line">        priceMapper.updateByPrimaryKey(price) ;</span><br><span class="line"></span><br><span class="line">        price.setId(<span class="literal">null</span>);</span><br><span class="line">        priceMapper.insertSelective(price) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="https://ooo.0o0.ooo/2017/07/10/59626281d53ef.png" alt="01.png"><br>可以看到确实是每次都递减10。</p>
<p>但是如果是多线程的情况下会是如何呢：</p>
<blockquote>
<p>我这里新建了一个<code>PriceController</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池 无锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> redisContentReq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/threadPrice&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;NULLBody&gt; <span class="title function_">threadPrice</span><span class="params">(<span class="meta">@RequestBody</span> RedisContentReq redisContentReq)</span>&#123;</span><br><span class="line">    BaseResponse&lt;NULLBody&gt; response = <span class="keyword">new</span> <span class="title class_">BaseResponse</span>&lt;NULLBody&gt;() ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">10</span> ;i++)&#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">Price</span> <span class="variable">price</span> <span class="operator">=</span> priceMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">ron</span> <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line">                    price.setFront(price.getFront().subtract(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(ron)));</span><br><span class="line">                    price.setEnd(price.getEnd().add(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(ron)));</span><br><span class="line">                    priceMapper.updateByPrimaryKey(price) ;</span><br><span class="line"></span><br><span class="line">                    price.setId(<span class="literal">null</span>);</span><br><span class="line">                    priceMapper.insertSelective(price) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            config.submit(t);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response.setReqNo(redisContentReq.getReqNo());</span><br><span class="line">        response.setCode(StatusEnum.SUCCESS.getCode());</span><br><span class="line">        response.setMessage(StatusEnum.SUCCESS.getMessage());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;system error&quot;</span>,e);</span><br><span class="line">        response.setReqNo(response.getReqNo());</span><br><span class="line">        response.setCode(StatusEnum.FAIL.getCode());</span><br><span class="line">        response.setMessage(StatusEnum.FAIL.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中为了节省资源使用了一个线程池:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SECOND</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor executor ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(CORE_SIZE,MAX_SIZE,SECOND, TimeUnit.MICROSECONDS,<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(Thread thread)</span>&#123;</span><br><span class="line">        executor.submit(thread) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于线程池的使用今后会仔细探讨。这里就简单理解为有10个线程并发去处理上面单线程的逻辑，来看看结果怎么样：</p>
<p><img src="https://ooo.0o0.ooo/2017/07/10/596262815c9d6.png" alt="02.png"></p>
<p>会看到明显的数据错误，导致错误的原因自然就是有线程读取到了中间状态进行了错误的更新。</p>
<p>进而有了以下两种解决方案：悲观锁和乐观锁。</p>
<h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><p>简单理解下悲观锁：当一个事务锁定了一些数据之后，只有当当前锁提交了事务，释放了锁，其他事务才能获得锁并执行操作。</p>
<p>使用方式如下：<br>首先要关闭MySQL的自动提交：<code>set autocommit = 0;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">bigen <span class="comment">--开启事务</span></span><br><span class="line"><span class="keyword">select</span> id, total, front, <span class="keyword">end</span> <span class="keyword">from</span> price <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> price <span class="keyword">values</span>(?,?,?,?,?)</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> <span class="comment">--提交事务</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里使用<code>select for update</code>的方式利用数据库开启了悲观锁，锁定了id&#x3D;1的这条数据(<code>注意:这里除非是使用了索引会启用行级锁，不然是会使用表锁，将整张表都锁住。</code>)。之后使用<code>commit</code>提交事务并释放锁，这样下一个线程过来拿到的就是正确的数据。</p>
<p>悲观锁一般是用于并发不是很高，并且不允许脏读等情况。但是对数据库资源消耗较大。</p>
<h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>那么有没有性能好，支持的并发也更多的方式呢？</p>
<p>那就是乐观锁。</p>
<p>乐观锁是首先假设数据冲突很少，只有在数据提交修改的时候才进行校验，如果冲突了则不会进行更新。</p>
<p>通常的实现方式增加一个<code>version</code>字段，为每一条数据加上版本。每次更新的时候<code>version+1</code>，并且更新时候带上版本号。实现方式如下：</p>
<p>新建了一张<code>price_version</code>表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `price_version` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">  `total` decimal(12,2) DEFAULT &#x27;0.00&#x27; COMMENT &#x27;总值&#x27;,</span><br><span class="line">  `front` decimal(12,2) DEFAULT &#x27;0.00&#x27; COMMENT &#x27;消费前&#x27;,</span><br><span class="line">  `end` decimal(12,2) DEFAULT &#x27;0.00&#x27; COMMENT &#x27;消费后&#x27;,</span><br><span class="line">  `version` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;并发版本控制&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1268 DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>

<p>更新数据的SQL：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByVersion&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.crossoverJie.pojo.PriceVersion&quot;</span>&gt;</span></span><br><span class="line">    UPDATE price_version</span><br><span class="line">    SET front = #&#123;front,jdbcType=DECIMAL&#125;,</span><br><span class="line">        version= version + 1</span><br><span class="line">    WHERE id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">    AND version = #&#123;version,jdbcType=INTEGER&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池，乐观锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> redisContentReq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/threadPriceVersion&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;NULLBody&gt; <span class="title function_">threadPriceVersion</span><span class="params">(<span class="meta">@RequestBody</span> RedisContentReq redisContentReq)</span>&#123;</span><br><span class="line">    BaseResponse&lt;NULLBody&gt; response = <span class="keyword">new</span> <span class="title class_">BaseResponse</span>&lt;NULLBody&gt;() ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">3</span> ;i++)&#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">PriceVersion</span> <span class="variable">priceVersion</span> <span class="operator">=</span> priceVersionMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">ron</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">20</span>);</span><br><span class="line">                    logger.info(<span class="string">&quot;本次消费=&quot;</span>+ron);</span><br><span class="line">                    priceVersion.setFront(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(ron));</span><br><span class="line">                    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> priceVersionMapper.updateByVersion(priceVersion);</span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">                        logger.error(<span class="string">&quot;更新失败&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;更新成功&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            config.submit(t);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response.setReqNo(redisContentReq.getReqNo());</span><br><span class="line">        response.setCode(StatusEnum.SUCCESS.getCode());</span><br><span class="line">        response.setMessage(StatusEnum.SUCCESS.getMessage());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;system error&quot;</span>,e);</span><br><span class="line">        response.setReqNo(response.getReqNo());</span><br><span class="line">        response.setCode(StatusEnum.FAIL.getCode());</span><br><span class="line">        response.setMessage(StatusEnum.FAIL.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理逻辑：开了三个线程生成了20以内的随机数更新到<code>front</code>字段。</p>
<p>当调用该接口时日志如下：</p>
<p><img src="https://ooo.0o0.ooo/2017/07/10/59626fb3a3814.jpg" alt="03.jpg"></p>
<p>可以看到线程1、4、5分别生成了15，2，11三个随机数。最后线程4、5都更新失败了，只有线程1更新成功了。</p>
<p>查看数据库：</p>
<p><img src="https://ooo.0o0.ooo/2017/07/10/596270520bd6b.jpg" alt="04.jpg"></p>
<p>发现也确实是更新的15。</p>
<p>乐观锁在实际应用相对较多，它可以提供更好的并发访问，并且数据库开销较少，但是有可能存在脏读的情况。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上两种各有优劣，大家可以根据具体的业务场景来判断具体使用哪种方式来保证数据的一致性。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/crossoverJie/SSM.git">https://github.com/crossoverJie/SSM.git</a></p>
</blockquote>
<blockquote>
<p>个人博客：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>lock</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(十七) MQ应用</title>
    <url>/2017/10/20/SSM17/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1ba77119c6.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这篇文章的起因是由于之前的一篇关于<code>Kafka</code><a href="http://crossoverjie.top/2017/09/05/SSM16/">异常消费</a>，当时为了解决问题不得不使用临时的方案。</p>
<p>总结起来归根结底还是对Kafka不熟悉导致的，加上平时工作的需要，之后就花些时间看了<code>Kafka</code>相关的资料。</p>
<h1 id="何时使用MQ"><a href="#何时使用MQ" class="headerlink" title="何时使用MQ"></a>何时使用MQ</h1><p>谈到<code>Kafka</code>就不得不提到MQ，是属于消息队列的一种。作为一种基础中间件在互联网项目中有着大量的使用。</p>
<p>一种技术的产生自然是为了解决某种需求，通常来说是以下场景：</p>
<blockquote>
<ul>
<li>需要跨进程通信：B系统需要A系统的输出作为输入参数。</li>
<li>当A系统的输出能力远远大于B系统的处理能力。</li>
</ul>
</blockquote>
<p>针对于第一种情况有两种方案:</p>
<ul>
<li>使用<code>RPC</code>远程调用,A直接调用B。</li>
<li>使用<code>MQ</code>,A发布消息到<code>MQ</code>,B订阅该消息。</li>
</ul>
<p>当我们的需求是:A调用B实时响应，并且实时关心响应结果则使用<code>RPC</code>，这种情况就得使用同步调用。</p>
<span id="more"></span>

<p>反之当我们并不关心调用之后的执行结果，并且有可能被调用方的执行非常耗时，这种情况就非常适合用<code>MQ</code>来达到异步调用目的。</p>
<p>比如常见的登录场景就只能用同步调用的方式，因为这个过程需要实时的响应结果，总不能在用户点了登录之后排除网络原因之外再额外的等几秒吧。</p>
<p>但类似于用户登录需要奖励积分的情况则使用<code>MQ</code>会更好，因为登录并不关系积分的情况，只需要发个消息到<code>MQ</code>,处理积分的服务订阅处理即可，这样还可以解决积分系统故障带来的雪崩效应。</p>
<p><code>MQ</code>还有一个基础功能则是<strong>限流削峰</strong>，这对于大流量的场景如果将请求直接调用到B系统则非常有可能使B系统出现不可用的情况。这种场景就非常适合将请求放入<code>MQ</code>，不但可以利用<code>MQ</code>削峰还尽可能的保证系统的高可用。</p>
<h1 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h1><p>本次重点讨论下<code>Kafka</code>。<br>简单来说<code>Kafka</code>是一个支持水平扩展，高吞吐率的分布式消息系统。</p>
<p><code>Kafka</code>的常用知识:</p>
<ul>
<li><p><code>Topic</code>:生产者和消费者的交互都是围绕着一个<code>Topic</code>进行的，通常来说是由业务来进行区分，由生产消费者协商之后进行创建。</p>
</li>
<li><p><code>Partition</code>(分区):是<code>Topic</code>下的组成，通常一个<code>Topic</code>下有一个或多个分区，消息生产之后会按照一定的算法负载到每个分区，所以分区也是<code>Kafka</code>性能的关键。当发现性能不高时便可考虑新增分区。</p>
</li>
</ul>
<p>结构图如下:<br><img src="https://i.loli.net/2019/05/08/5cd1ba7910bc2.jpg"></p>
<h1 id="创建Topic"><a href="#创建Topic" class="headerlink" title="创建Topic"></a>创建<code>Topic</code></h1><p><code>Kafka</code>的安装官网有非常详细的讲解。这里谈一下在日常开发中常见的一些操作，比如创建<code>Topic</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 3 --topic `test`</span><br></pre></td></tr></table></figure>
<p>创建了三个分区的<code>test</code>主题。</p>
<p>使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure>
<p>可以列出所有的<code>Topic</code>。</p>
<h1 id="Kafka生产者"><a href="#Kafka生产者" class="headerlink" title="Kafka生产者"></a>Kafka生产者</h1><p>使用<code>kafka</code>官方所提供的<code>Java API</code>来进行消息生产，实际使用中编码实现更为常用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Kafka生产者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> crossoverJie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(Producer.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费配置文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String consumerProPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// set up the producer</span></span><br><span class="line">        consumerProPath = System.getProperty(<span class="string">&quot;product_path&quot;</span>);</span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(consumerProPath));</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(inputStream);</span><br><span class="line">            producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;String, String&gt;(properties);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;load config error&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// send lots of messages</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">                producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;String, String&gt;(</span><br><span class="line">                        <span class="string">&quot;topic_optimization&quot;</span>, i+<span class="string">&quot;&quot;</span>, i+<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s&quot;</span>, throwable.getStackTrace());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            producer.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再配合以下启动参数即可发送消息:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dproduct_path=/xxx/producer.properties</span><br></pre></td></tr></table></figure>
<p>以及生产者的配置文件:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#集群地址，可以多个</span></span><br><span class="line"><span class="attr">bootstrap.servers</span>=<span class="string">10.19.13.51:9094</span></span><br><span class="line"><span class="attr">acks</span>=<span class="string">all</span></span><br><span class="line"><span class="attr">retries</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">batch.size</span>=<span class="string">16384</span></span><br><span class="line"><span class="attr">auto.commit.interval.ms</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">linger.ms</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">key.serializer</span>=<span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line"><span class="attr">value.serializer</span>=<span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line"><span class="attr">block.on.buffer.full</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<p>具体的配置说明详见此处:<a href="https://kafka.apache.org/0100/documentation.html#theproducer">https://kafka.apache.org/0100/documentation.html#theproducer</a></p>
<p>流程非常简单，其实就是一些<code>API</code>的调用。</p>
<p>消息发完之后可以通过以下命令查看队列内的情况:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh kafka-consumer-groups.sh --bootstrap-server localhost:9094 --describe --group group1 </span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba7c8876f.jpg"><br>其中的<code>lag</code>便是队列里的消息数量。</p>
<h1 id="Kafka消费者"><a href="#Kafka消费者" class="headerlink" title="Kafka消费者"></a>Kafka消费者</h1><p>有了生产者自然也少不了消费者，这里首先针对单线程消费:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function:kafka官方消费</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> crossoverJie</span></span><br><span class="line"><span class="comment"> *         Date: 2017/10/19 01:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaOfficialConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(KafkaOfficialConsumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志文件地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String logPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主题名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String topic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费配置文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String consumerProPath ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数校验</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">initCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        topic = System.getProperty(<span class="string">&quot;topic&quot;</span>) ;</span><br><span class="line">        logPath = System.getProperty(<span class="string">&quot;log_path&quot;</span>) ;</span><br><span class="line">        consumerProPath = System.getProperty(<span class="string">&quot;consumer_pro_path&quot;</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isEmpty(topic) || logPath.isEmpty()) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;system property topic ,consumer_pro_path, log_path is required !&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化kafka配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> KafkaConsumer&lt;String, String&gt; <span class="title function_">initKafkaConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(consumerProPath)) ;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(inputStream);</span><br><span class="line">            consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;String, String&gt;(properties);</span><br><span class="line">            consumer.subscribe(Arrays.asList(topic));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;加载consumer.props文件出错&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> consumer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initCheck())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalCount</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">long</span> <span class="variable">totalMin</span> <span class="operator">=</span> <span class="number">0L</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = initKafkaConsumer();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis() ;</span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">if</span> (records.count() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.debug(<span class="string">&quot;本次获取:&quot;</span>+records.count());</span><br><span class="line">            count += records.count() ;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis() ;</span><br><span class="line">            LOGGER.debug(<span class="string">&quot;count=&quot;</span> +count) ;</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= <span class="number">10000</span> )&#123;</span><br><span class="line">                totalCount += count ;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;this consumer &#123;&#125; record，use &#123;&#125; milliseconds&quot;</span>,count,endTime-startTime);</span><br><span class="line">                totalMin += (endTime-startTime) ;</span><br><span class="line">                startTime = System.currentTimeMillis() ;</span><br><span class="line">                count = <span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.debug(<span class="string">&quot;end totalCount=&#123;&#125;,min=&#123;&#125;&quot;</span>,totalCount,totalMin);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*for (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span></span><br><span class="line"><span class="comment">                record.value() ;</span></span><br><span class="line"><span class="comment">                JsonNode msg = null;</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    msg = mapper.readTree(record.value());</span></span><br><span class="line"><span class="comment">                &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">                    LOGGER.error(&quot;消费消息出错&quot;, e);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                LOGGER.info(&quot;kafka receive = &quot;+msg.toString());</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配合以下启动参数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dlog_path=/log/consumer.log -Dtopic=test -Dconsumer_pro_path=consumer.properties</span><br></pre></td></tr></table></figure>
<p>其中采用了轮询的方式获取消息，并且记录了消费过程中的数据。</p>
<p>消费者采用的配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bootstrap.servers=192.168.1.2:9094</span><br><span class="line">group.id=group1</span><br><span class="line"></span><br><span class="line"># 自动提交</span><br><span class="line">enable.auto.commit=true</span><br><span class="line">key.deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">value.deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line"></span><br><span class="line"># fast session timeout makes it more fun to play with failover</span><br><span class="line">session.timeout.ms=10000</span><br><span class="line"></span><br><span class="line"># These buffer sizes seem to be needed to avoid consumer switching to</span><br><span class="line"># a mode where it processes one bufferful every 5 seconds with multiple</span><br><span class="line"># timeouts along the way.  No idea why this happens.</span><br><span class="line">fetch.min.bytes=50000</span><br><span class="line">receive.buffer.bytes=262144</span><br><span class="line">max.partition.fetch.bytes=2097152</span><br></pre></td></tr></table></figure>
<p>为了简便我采用的是自动提交<code>offset</code>。</p>
<h2 id="消息存放机制"><a href="#消息存放机制" class="headerlink" title="消息存放机制"></a>消息存放机制</h2><p>谈到<code>offset</code>就必须得谈谈Kafka的消息存放机制.</p>
<p><code>Kafka</code>的消息不会因为消费了就会立即删除，所有的消息都会持久化到日志文件，并配置有过期时间，到了时间会自动删除过期数据，<em>并且不会管其中的数据是否被消费过。</em></p>
<p>由于这样的机制就必须的有一个标志来表明哪些数据已经被消费过了，<code>offset(偏移量)</code>就是这样的作用，它类似于指针指向某个数据，当消费之后<code>offset</code>就会线性的向前移动，这样一来的话消息是可以被任意消费的，只要我们修改<code>offset</code>的值即可。</p>
<p>消费过程中还有一个值得注意的是:</p>
<blockquote>
<p>同一个consumer group(group.id相等)下只能有一个消费者可以消费，这个刚开始确实会让很多人踩坑。</p>
</blockquote>
<h1 id="多线程消费"><a href="#多线程消费" class="headerlink" title="多线程消费"></a>多线程消费</h1><p>针对于单线程消费实现起来自然是比较简单，但是效率也是要大打折扣的。</p>
<p>为此我做了一个测试，使用之前的单线程消费120009条数据的结果如下:</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba8705aac.jpg"><br>总共花了12450毫秒。</p>
<p>那么换成多线程消费怎么实现呢？</p>
<p>我们可以利用<code>partition</code>的分区特性来提高消费能力，单线程的时候等于是一个线程要把所有分区里的数据都消费一遍，如果换成多线程就可以让一个线程只消费一个分区,这样效率自然就提高了，所以线程数<code>coreSize&lt;=partition</code>。</p>
<p>首先来看下入口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConsumerThreadMain &#123;</span><br><span class="line">    private static String brokerList = &quot;localhost:9094&quot;;</span><br><span class="line">    private static String groupId = &quot;group1&quot;;</span><br><span class="line">    private static String topic = &quot;test&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 线程数量</span><br><span class="line">     */</span><br><span class="line">    private static int threadNum = 3;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ConsumerGroup consumerGroup = new ConsumerGroup(threadNum, groupId, topic, brokerList);</span><br><span class="line">        consumerGroup.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>ConsumerGroup</code>类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConsumerGroup &#123;</span><br><span class="line">    private static Logger LOGGER = LoggerFactory.getLogger(ConsumerGroup.class);</span><br><span class="line">    /**</span><br><span class="line">     * 线程池</span><br><span class="line">     */</span><br><span class="line">    private ExecutorService threadPool;</span><br><span class="line"></span><br><span class="line">    private List&lt;ConsumerCallable&gt; consumers ;</span><br><span class="line"></span><br><span class="line">    public ConsumerGroup(int threadNum, String groupId, String topic, String brokerList) &#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(&quot;consumer-pool-%d&quot;).build();</span><br><span class="line"></span><br><span class="line">        threadPool = new ThreadPoolExecutor(threadNum, threadNum,</span><br><span class="line">                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        consumers = new ArrayList&lt;ConsumerCallable&gt;(threadNum);</span><br><span class="line">        for (int i = 0; i &lt; threadNum; i++) &#123;</span><br><span class="line">            ConsumerCallable consumerThread = new ConsumerCallable(brokerList, groupId, topic);</span><br><span class="line">            consumers.add(consumerThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行任务</span><br><span class="line">     */</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis() ;</span><br><span class="line">        for (ConsumerCallable runnable : consumers) &#123;</span><br><span class="line">            Future&lt;ConsumerFuture&gt; future = threadPool.submit(runnable) ;</span><br><span class="line">        &#125;</span><br><span class="line">        if (threadPool.isShutdown())&#123;</span><br><span class="line">            long endTime = System.currentTimeMillis() ;</span><br><span class="line">            LOGGER.info(&quot;main thread use &#123;&#125; Millis&quot; ,endTime -startTime) ;</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后真正的执行逻辑<code>ConsumerCallable</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConsumerCallable implements Callable&lt;ConsumerFuture&gt; &#123;</span><br><span class="line">    private static Logger LOGGER = LoggerFactory.getLogger(ConsumerCallable.class);</span><br><span class="line"></span><br><span class="line">    private AtomicInteger totalCount = new AtomicInteger() ;</span><br><span class="line">    private AtomicLong totalTime = new AtomicLong() ;</span><br><span class="line"></span><br><span class="line">    private AtomicInteger count = new AtomicInteger() ;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每个线程维护KafkaConsumer实例</span><br><span class="line">     */</span><br><span class="line">    private final KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class="line"></span><br><span class="line">    public ConsumerCallable(String brokerList, String groupId, String topic) &#123;</span><br><span class="line">        Properties props = new Properties();</span><br><span class="line">        props.put(&quot;bootstrap.servers&quot;, brokerList);</span><br><span class="line">        props.put(&quot;group.id&quot;, groupId);</span><br><span class="line">        //自动提交位移</span><br><span class="line">        props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);</span><br><span class="line">        props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);</span><br><span class="line">        props.put(&quot;session.timeout.ms&quot;, &quot;30000&quot;);</span><br><span class="line">        props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">        props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">        this.consumer = new KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(topic));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public ConsumerFuture call() throws Exception &#123;</span><br><span class="line">        boolean flag = true;</span><br><span class="line">        int failPollTimes = 0 ;</span><br><span class="line">        long startTime = System.currentTimeMillis() ;</span><br><span class="line">        while (flag) &#123;</span><br><span class="line">            // 使用200ms作为获取超时时间</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(200);</span><br><span class="line">            if (records.count() &lt;= 0)&#123;</span><br><span class="line">                failPollTimes ++ ;</span><br><span class="line"></span><br><span class="line">                if (failPollTimes &gt;= 20)&#123;</span><br><span class="line">                    LOGGER.debug(&quot;达到&#123;&#125;次数，退出 &quot;,failPollTimes);</span><br><span class="line">                    flag = false ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                continue ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //获取到之后则清零</span><br><span class="line">            failPollTimes = 0 ;</span><br><span class="line"></span><br><span class="line">            LOGGER.debug(&quot;本次获取:&quot;+records.count());</span><br><span class="line">            count.addAndGet(records.count()) ;</span><br><span class="line">            totalCount.addAndGet(count.get()) ;</span><br><span class="line">            long endTime = System.currentTimeMillis() ;</span><br><span class="line">            if (count.get() &gt;= 10000 )&#123;</span><br><span class="line">                LOGGER.info(&quot;this consumer &#123;&#125; record，use &#123;&#125; milliseconds&quot;,count,endTime-startTime);</span><br><span class="line">                totalTime.addAndGet(endTime-startTime) ;</span><br><span class="line">                startTime = System.currentTimeMillis() ;</span><br><span class="line">                count = new AtomicInteger();</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.debug(&quot;end totalCount=&#123;&#125;,min=&#123;&#125;&quot;,totalCount,totalTime);</span><br><span class="line"></span><br><span class="line">            /*for (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                // 简单地打印消息</span><br><span class="line">                LOGGER.debug(record.value() + &quot; consumed &quot; + record.partition() +</span><br><span class="line">                        &quot; message with offset: &quot; + record.offset());</span><br><span class="line">            &#125;*/</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ConsumerFuture consumerFuture = new ConsumerFuture(totalCount.get(),totalTime.get()) ;</span><br><span class="line">        return consumerFuture ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>理一下逻辑:</p>
<blockquote>
<p>其实就是初始化出三个消费者实例，用于三个线程消费。其中加入了一些统计，最后也是消费120009条数据结果如下。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba8b41500.jpg"></p>
<p>由于是并行运行，可见消费120009条数据可以提高2秒左右，当数据以更高的数量级提升后效果会更加明显。</p>
<p>但这也有一些弊端:</p>
<ul>
<li>灵活度不高，当分区数量变更之后不能自适应调整。</li>
<li>消费逻辑和处理逻辑在同一个线程，如果处理逻辑较为复杂会影响效率，耦合也较高。当然这个处理逻辑可以再通过一个内部队列发出去由另外的程序来处理也是可以的。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Kafka</code>的知识点还是较多，<code>Kafka</code>的使用也远不这些。之后会继续分享一些关于<code>Kafka</code>监控等相关内容。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/crossoverJie/SSM.git">https://github.com/crossoverJie/SSM.git</a></p>
</blockquote>
<blockquote>
<p>个人博客：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(十六) 曲线救国-Kafka消费异常</title>
    <url>/2017/09/05/SSM16/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1bad139575.jpg" alt="封面"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近线上遇到一个问题:在消费<code>kafka</code>消息的时候如果长时间(<code>大概半天到一天的时间</code>)队列里没有消息就可能再也消费不了。针对这个问题我们反复调试多次。线下模拟，调整代码，但貌似还是没有找到原因。<strong>但是只要重启消费进程就又可以继续消费。</strong></p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>由于线上业务非常依赖<code>kafka</code>的消费，但一时半会也没有找到原因，所以最后只能想一个临时的替换方案：</p>
<blockquote>
<p>基于重启就可以消费这个特点，我们在每次消费的时候都记下当前的时间点，当这个时间点在十分钟之内都没有更新我们就认为当前队列中没有消息了，就需要重启下消费进程。</p>
</blockquote>
<p>既然是需要重启，<code>由于目前还没有上分布式调度中心</code>所以需要<code>crontab</code>来配合调度：每隔一分钟会调用一个<code>shell脚本</code>，该脚本会判断当前进程是否存在，如果存在则什么都不作，不存在则启动消费进程。</p>
<span id="more"></span>

<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>消费程序:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kafka消费</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> crossoverJie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017年6月19日 下午3:15:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaMsgConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(KafkaMsgConsumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_POOL_SIZE</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BLOCKING_QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">4000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KAFKA_CONFIG</span> <span class="operator">=</span> <span class="string">&quot;kafkaConfig&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(BLOCKING_QUEUE_CAPACITY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后更新时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicLong</span> <span class="variable">LAST_MESSAGE_TIME</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(DateUtil.getLongTime());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">MsgIterator</span> <span class="variable">iter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String topic;<span class="comment">//主题名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> System.getProperty(KAFKA_CONFIG);</span><br><span class="line">        checkArguments(!StringUtils.isBlank(path), <span class="string">&quot;启动参数中没有配置kafka_easyframe_msg参数来指定kafka启动参数，请使用-DkafkaConfig=/path/fileName/easyframe-msg.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(path)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;IOException&quot;</span> ,e);</span><br><span class="line">        &#125;</span><br><span class="line">        EasyMsgConfig.setProperties(properties);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">iteratorTopic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter == <span class="literal">null</span>) &#123;</span><br><span class="line">            iter = MsgUtil.consume(topic);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">10000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;consume i:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isEmpty(message)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                LAST_MESSAGE_TIME = <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(DateUtil.getLongTime());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//处理消息</span></span><br><span class="line">                LOGGER.debug(<span class="string">&quot;msg = &quot;</span> + JSON.toJSONString(message));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;KafkaMsgConsumer err:&quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                    LOGGER.error(<span class="string">&quot;Thread InterruptedException&quot;</span>, e1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        topic = System.getProperty(<span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        checkArguments(!StringUtils.isBlank(topic), <span class="string">&quot;system property topic or log_path is must!&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                iteratorTopic();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                MsgUtil.shutdownConsummer();</span><br><span class="line">                iter = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                LOGGER.error(<span class="string">&quot;KafkaMsgConsumer err:&quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                    LOGGER.error(<span class="string">&quot;Thread InterruptedException&quot;</span>, e1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//此处关闭之后，由crontab每分钟检查一次，挂掉的话会重新拉起来</span></span><br><span class="line">                <span class="keyword">if</span> (DateUtil.getLongTime() - LAST_MESSAGE_TIME.get() &gt; <span class="number">10</span> * <span class="number">60</span>) &#123; <span class="comment">//10分钟</span></span><br><span class="line">                    fixedThreadPool.shutdown();</span><br><span class="line">                    LOGGER.info(<span class="string">&quot;线程池是否关闭：&quot;</span> + fixedThreadPool.isShutdown());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//当前线程阻塞10ms后，去检测线程池是否终止，终止则返回true</span></span><br><span class="line">                        <span class="keyword">while</span> (!fixedThreadPool.awaitTermination(<span class="number">10</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                            LOGGER.info(<span class="string">&quot;检测线程池是否终止：&quot;</span> + fixedThreadPool.isTerminated());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        LOGGER.error(<span class="string">&quot;等待线程池关闭错误&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    LOGGER.info(<span class="string">&quot;线程池是否终止：&quot;</span> + fixedThreadPool.isTerminated());</span><br><span class="line">                    LOGGER.info(<span class="string">&quot;in 10 min dont have data break&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;app shutdown&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/crossoverJie/SSM/blob/master/SSM-WEB/src/main/java/com/crossoverJie/kafka/KafkaMsgConsumer.java#L31-L128">在线代码</a></p>
<p>需要配合以下这个<code>shell脚本运行</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">crontab</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">* * * * * sh /data/schedule/kafka/run-kafka-consumer.sh &gt;&gt;/data/schedule/kafka/run-sms-log.log</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果进程存在就不启动</span></span><br><span class="line">a1=`ps -ef|grep &#x27;KafkaMsgConsumer&#x27;|grep -v grep|wc -l`</span><br><span class="line">if [ $a1 -gt 0  ];then</span><br><span class="line">        echo &quot;=======     `date +&#x27;%Y-%m-%d %H:%M:%S&#x27;` KafkaMsgConsumer  is EXIT...=======     &quot;</span><br><span class="line">        exit</span><br><span class="line">fi</span><br><span class="line">LANG=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">nohup /opt/java/jdk1.7.0_80/bin/java -d64 -Djava.security.egd=file:/dev/./urandom</span><br><span class="line">-Djava.ext.dirs=/opt/tomcat/webapps/ROOT/WEB-INF/lib</span><br><span class="line">-Dtopic=TOPIC_A</span><br><span class="line">-Dlogback.configurationFile=/data/schedule/kafka/logback.xml</span><br><span class="line">-DkafkaConfig=/opt/tomcat/iopconf/easyframe-msg.properties</span><br><span class="line">-classpath /opt/tomcat/webapps/ROOT/WEB-INF/classes com.crossoverJie.kafka.SMSMsgConsumer &gt;&gt; /data/schedule/kafka/smslog/kafka.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">echo &quot;`date +&#x27;%Y-%m-%d %H:%M:%S&#x27;`  KafkaMsgConsumer running....&quot;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/crossoverJie/SSM/blob/master/SSM-WEB/src/main/resources/script/run-kafka-consumer.sh">在线代码</a></p>
<p>再配合<code>crontab</code>的调度:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* * * * * sh /data/schedule/kafka/run-kafka-consumer.sh &gt;&gt;/data/schedule/kafka/run-sms-log.log</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽说处理起来很简单，但依然是治标不治本，依赖的东西比较多(<code>shell脚本，调度</code>)。<br>所以也问问各位有没有什么思路：</p>
<ul>
<li>消费程序用的:<a href="https://github.com/linzhaoming/easyframe-msg">https://github.com/linzhaoming/easyframe-msg</a></li>
</ul>
<p>生产配置:</p>
<ul>
<li>三台<code>kafka、ZK</code>组成的集群。</li>
</ul>
<p>其中也有其他团队的消费程序在正常运行，应该和<code>kafka</code>的配置没有关系。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/crossoverJie/SSM.git">https://github.com/crossoverJie/SSM.git</a></p>
</blockquote>
<blockquote>
<p>个人博客：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Kafka</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(二)Lucene全文检索</title>
    <url>/2016/07/06/SSM2/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/07/29/597c7694a0f58.jpeg" alt="pexels-photo-257875.jpeg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>大家平时肯定都有用过全文检索工具，最常用的百度谷歌就是其中的典型。如果自己能够做一个那是不是想想就逼格满满呢。<a href="http://lucene.apache.org/">Apache</a>就为我们提供了这样一个框架，以下就是在实际开发中加入Lucene的一个小Demo。</p>
</blockquote>
<hr>
<h1 id="获取Maven依赖"><a href="#获取Maven依赖" class="headerlink" title="获取Maven依赖"></a>获取Maven依赖</h1><p>首先看一下实际运行的效果图：<br><img src="http://i.imgur.com/pTTnv3R.png"><br><img src="http://i.imgur.com/nRcHFQg.png"></p>
<span id="more"></span>
<p>这个项目是基于之前使用IDEA搭建的SSM的基础上进行增加的，建议小白先看下一我。<a href="http://crossoverjie.top/2016/06/28/SSM1/">上一篇博客</a>，以及共享在Github上的<a href="https://github.com/crossoverJie/SSM">源码</a>。<br>以下是Lucene所需要的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加入lucene--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.lucene/lucene-core --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lucene.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.lucene/lucene-queryparser --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-queryparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lucene.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.lucene/lucene-analyzers-common --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-analyzers-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lucene.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--lucene中文分词--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.lucene/lucene-analyzers-smartcn --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-analyzers-smartcn<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lucene.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--lucene高亮--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.lucene/lucene-highlighter --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-highlighter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lucene.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>具体的用途我都写有注释。<br>在IDEA中修改了Pom.xml文件之后只需要点击如图所示的按钮即可重新获取依赖：<br><img src="http://i.imgur.com/0XU7DjK.png"></p>
<hr>
<h1 id="编写Lucene工具类"><a href="#编写Lucene工具类" class="headerlink" title="编写Lucene工具类"></a>编写Lucene工具类</h1><p>这个工具类中的具体代码我就不单独提出来说了，每个关键的地方我都写有注释，不清楚的再讨论。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crossoverJie.lucene;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.crossoverJie.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.analysis.TokenStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.analysis.cn.smart.SmartChineseAnalyzer;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.document.StringField;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.document.TextField;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.queryparser.classic.QueryParser;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.search.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.search.highlight.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.store.Directory;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.store.FSDirectory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.StringReader;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.crossoverJie.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 博客索引类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LuceneIndex</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Directory dir=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取IndexWriter实例</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> IndexWriter <span class="title function_">getWriter</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 生成的索引我放在了C盘，可以根据自己的需要放在具体位置</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dir= FSDirectory.open(Paths.get(<span class="string">&quot;C://lucene&quot;</span>));</span><br><span class="line">		SmartChineseAnalyzer analyzer=<span class="keyword">new</span> <span class="title class_">SmartChineseAnalyzer</span>();</span><br><span class="line">		IndexWriterConfig iwc=<span class="keyword">new</span> <span class="title class_">IndexWriterConfig</span>(analyzer);</span><br><span class="line">		IndexWriter writer=<span class="keyword">new</span> <span class="title class_">IndexWriter</span>(dir, iwc);</span><br><span class="line">		<span class="keyword">return</span> writer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 添加博客索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addIndex</span><span class="params">(User user)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		IndexWriter writer=getWriter();</span><br><span class="line">		Document doc=<span class="keyword">new</span> <span class="title class_">Document</span>();</span><br><span class="line">		doc.add(<span class="keyword">new</span> <span class="title class_">StringField</span>(<span class="string">&quot;id&quot;</span>,String.valueOf(user.getUserId()), Field.Store.YES));</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * yes是会将数据存进索引，如果查询结果中需要将记录显示出来就要存进去，如果查询结果</span></span><br><span class="line"><span class="comment">		 * 只是显示标题之类的就可以不用存，而且内容过长不建议存进去</span></span><br><span class="line"><span class="comment">		 * 使用TextField类是可以用于查询的。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		doc.add(<span class="keyword">new</span> <span class="title class_">TextField</span>(<span class="string">&quot;username&quot;</span>, user.getUsername(), Field.Store.YES));</span><br><span class="line">		doc.add(<span class="keyword">new</span> <span class="title class_">TextField</span>(<span class="string">&quot;description&quot;</span>,user.getDescription(), Field.Store.YES));</span><br><span class="line">		writer.addDocument(doc);</span><br><span class="line">		writer.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 更新博客索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateIndex</span><span class="params">(User user)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		IndexWriter writer=getWriter();</span><br><span class="line">		Document doc=<span class="keyword">new</span> <span class="title class_">Document</span>();</span><br><span class="line">		doc.add(<span class="keyword">new</span> <span class="title class_">StringField</span>(<span class="string">&quot;id&quot;</span>,String.valueOf(user.getUserId()), Field.Store.YES));</span><br><span class="line">		doc.add(<span class="keyword">new</span> <span class="title class_">TextField</span>(<span class="string">&quot;username&quot;</span>, user.getUsername(), Field.Store.YES));</span><br><span class="line">		doc.add(<span class="keyword">new</span> <span class="title class_">TextField</span>(<span class="string">&quot;description&quot;</span>,user.getDescription(), Field.Store.YES));</span><br><span class="line">		writer.updateDocument(<span class="keyword">new</span> <span class="title class_">Term</span>(<span class="string">&quot;id&quot;</span>, String.valueOf(user.getUserId())), doc);</span><br><span class="line">		writer.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 删除指定博客的索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteIndex</span><span class="params">(String userId)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		IndexWriter writer=getWriter();</span><br><span class="line">		writer.deleteDocuments(<span class="keyword">new</span> <span class="title class_">Term</span>(<span class="string">&quot;id&quot;</span>, userId));</span><br><span class="line">		writer.forceMergeDeletes(); <span class="comment">// 强制删除</span></span><br><span class="line">		writer.commit();</span><br><span class="line">		writer.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询用户</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> q 查询关键字</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;User&gt; <span class="title function_">searchBlog</span><span class="params">(String q)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 注意的是查询索引的位置得是存放索引的位置，不然会找不到。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dir= FSDirectory.open(Paths.get(<span class="string">&quot;C://lucene&quot;</span>));</span><br><span class="line">		<span class="type">IndexReader</span> <span class="variable">reader</span> <span class="operator">=</span> DirectoryReader.open(dir);</span><br><span class="line">		IndexSearcher is=<span class="keyword">new</span> <span class="title class_">IndexSearcher</span>(reader);</span><br><span class="line">		BooleanQuery.<span class="type">Builder</span> <span class="variable">booleanQuery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BooleanQuery</span>.Builder();</span><br><span class="line">		SmartChineseAnalyzer analyzer=<span class="keyword">new</span> <span class="title class_">SmartChineseAnalyzer</span>();</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * username和description就是我们需要进行查找的两个字段</span></span><br><span class="line"><span class="comment">		 * 同时在存放索引的时候要使用TextField类进行存放。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		QueryParser parser=<span class="keyword">new</span> <span class="title class_">QueryParser</span>(<span class="string">&quot;username&quot;</span>,analyzer);</span><br><span class="line">		Query query=parser.parse(q);</span><br><span class="line">		QueryParser parser2=<span class="keyword">new</span> <span class="title class_">QueryParser</span>(<span class="string">&quot;description&quot;</span>,analyzer);</span><br><span class="line">		Query query2=parser2.parse(q);</span><br><span class="line">		booleanQuery.add(query, BooleanClause.Occur.SHOULD);</span><br><span class="line">		booleanQuery.add(query2, BooleanClause.Occur.SHOULD);</span><br><span class="line">		TopDocs hits=is.search(booleanQuery.build(), <span class="number">100</span>);</span><br><span class="line">		QueryScorer scorer=<span class="keyword">new</span> <span class="title class_">QueryScorer</span>(query);</span><br><span class="line">		<span class="type">Fragmenter</span> <span class="variable">fragmenter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleSpanFragmenter</span>(scorer);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这里可以根据自己的需要来自定义查找关键字高亮时的样式。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		SimpleHTMLFormatter simpleHTMLFormatter=<span class="keyword">new</span> <span class="title class_">SimpleHTMLFormatter</span>(<span class="string">&quot;&lt;b&gt;&lt;font color=&#x27;red&#x27;&gt;&quot;</span>,<span class="string">&quot;&lt;/font&gt;&lt;/b&gt;&quot;</span>);</span><br><span class="line">		Highlighter highlighter=<span class="keyword">new</span> <span class="title class_">Highlighter</span>(simpleHTMLFormatter, scorer);</span><br><span class="line">		highlighter.setTextFragmenter(fragmenter);</span><br><span class="line">		List&lt;User&gt; userList=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;User&gt;();</span><br><span class="line">		<span class="keyword">for</span>(ScoreDoc scoreDoc:hits.scoreDocs)&#123;</span><br><span class="line">			Document doc=is.doc(scoreDoc.doc);</span><br><span class="line">			User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">			user.setUserId(Integer.parseInt(doc.get((<span class="string">&quot;id&quot;</span>))));</span><br><span class="line">			user.setDescription(doc.get((<span class="string">&quot;description&quot;</span>)));</span><br><span class="line">			String username=doc.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">			String description=doc.get(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(username!=<span class="literal">null</span>)&#123;</span><br><span class="line">				<span class="type">TokenStream</span> <span class="variable">tokenStream</span> <span class="operator">=</span> analyzer.tokenStream(<span class="string">&quot;username&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringReader</span>(username));</span><br><span class="line">				String husername=highlighter.getBestFragment(tokenStream, username);</span><br><span class="line">				<span class="keyword">if</span>(StringUtil.isEmpty(husername))&#123;</span><br><span class="line">					user.setUsername(username);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					user.setUsername(husername);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(description!=<span class="literal">null</span>)&#123;</span><br><span class="line">				<span class="type">TokenStream</span> <span class="variable">tokenStream</span> <span class="operator">=</span> analyzer.tokenStream(<span class="string">&quot;description&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringReader</span>(description));</span><br><span class="line">				String hContent=highlighter.getBestFragment(tokenStream, description);</span><br><span class="line">				<span class="keyword">if</span>(StringUtil.isEmpty(hContent))&#123;</span><br><span class="line">					<span class="keyword">if</span>(description.length()&lt;=<span class="number">200</span>)&#123;</span><br><span class="line">						user.setDescription(description);</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						user.setDescription(description.substring(<span class="number">0</span>, <span class="number">200</span>));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					user.setDescription(hContent);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			userList.add(user);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> userList;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="查询Controller的编写"><a href="#查询Controller的编写" class="headerlink" title="查询Controller的编写"></a>查询Controller的编写</h1><p>接下来是查询Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/q&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">search</span><span class="params">(<span class="meta">@RequestParam(value = &quot;q&quot;, required = false,defaultValue = &quot;&quot;)</span> String q,</span></span><br><span class="line"><span class="params">                     <span class="meta">@RequestParam(value = &quot;page&quot;, required = false, defaultValue = &quot;1&quot;)</span> String page,</span></span><br><span class="line"><span class="params">                     Model model,</span></span><br><span class="line"><span class="params">                     HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">LuceneIndex</span> <span class="variable">luceneIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LuceneIndex</span>() ;</span><br><span class="line">    List&lt;User&gt; userList = luceneIndex.searchBlog(q);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关于查询之后的分页我采用的是每次分页发起的请求都是将所有的数据查询出来，</span></span><br><span class="line"><span class="comment">     * 具体是第几页再截取对应页数的数据，典型的拿空间换时间的做法，如果各位有什么</span></span><br><span class="line"><span class="comment">     * 高招欢迎受教。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">toIndex</span> <span class="operator">=</span> userList.size() &gt;= Integer.parseInt(page) * <span class="number">5</span> ? Integer.parseInt(page) * <span class="number">5</span> : userList.size();</span><br><span class="line">    List&lt;User&gt; newList = userList.subList((Integer.parseInt(page) - <span class="number">1</span>) * <span class="number">5</span>, toIndex);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;userList&quot;</span>,newList) ;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="built_in">this</span>.genUpAndDownPageCode(Integer.parseInt(page), userList.size(), q, <span class="number">5</span>, request.getServletContext().</span><br><span class="line">            getContextPath());</span><br><span class="line">    model.addAttribute(<span class="string">&quot;pageHtml&quot;</span>,s) ;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;q&quot;</span>,q) ;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;resultTotal&quot;</span>,userList.size()) ;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;pageTitle&quot;</span>,<span class="string">&quot;搜索关键字&#x27;&quot;</span> + q + <span class="string">&quot;&#x27;结果页面&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;queryResult&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有用到一个<code>genUpAndDownPageCode()</code>方法来生成分页的Html代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询之后的分页</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> totalNum</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> q</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSize</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> projectContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">genUpAndDownPageCode</span><span class="params">(<span class="type">int</span> page,Integer totalNum,String q,Integer pageSize,String projectContext)</span>&#123;</span><br><span class="line">    <span class="type">long</span> totalPage=totalNum%pageSize==<span class="number">0</span>?totalNum/pageSize:totalNum/pageSize+<span class="number">1</span>;</span><br><span class="line">    StringBuffer pageCode=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">if</span>(totalPage==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pageCode.append(<span class="string">&quot;&lt;nav&gt;&quot;</span>);</span><br><span class="line">        pageCode.append(<span class="string">&quot;&lt;ul class=&#x27;pager&#x27; &gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(page&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            pageCode.append(<span class="string">&quot;&lt;li&gt;&lt;a href=&#x27;&quot;</span>+projectContext+<span class="string">&quot;/q?page=&quot;</span>+(page-<span class="number">1</span>)+<span class="string">&quot;&amp;q=&quot;</span>+q+<span class="string">&quot;&#x27;&gt;上一页&lt;/a&gt;&lt;/li&gt;&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pageCode.append(<span class="string">&quot;&lt;li class=&#x27;disabled&#x27;&gt;&lt;a href=&#x27;#&#x27;&gt;上一页&lt;/a&gt;&lt;/li&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(page&lt;totalPage)&#123;</span><br><span class="line">            pageCode.append(<span class="string">&quot;&lt;li&gt;&lt;a href=&#x27;&quot;</span>+projectContext+<span class="string">&quot;/q?page=&quot;</span>+(page+<span class="number">1</span>)+<span class="string">&quot;&amp;q=&quot;</span>+q+<span class="string">&quot;&#x27;&gt;下一页&lt;/a&gt;&lt;/li&gt;&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pageCode.append(<span class="string">&quot;&lt;li class=&#x27;disabled&#x27;&gt;&lt;a href=&#x27;#&#x27;&gt;下一页&lt;/a&gt;&lt;/li&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pageCode.append(<span class="string">&quot;&lt;/ul&gt;&quot;</span>);</span><br><span class="line">        pageCode.append(<span class="string">&quot;&lt;/nav&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pageCode.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，就是根据的页数、总页数来生成分页代码，对了我前端采用的是现在流行的Bootstrap，这个有不会的可以去他<a href="http://www.bootcss.com/">官网</a>看看，比较简单易上手。接下来只需要编写显示界面就大功告成了。<br><img src="http://i.imgur.com/NUZM7Bc.png"></p>
<hr>
<h1 id="显示界面"><a href="#显示界面" class="headerlink" title="显示界面"></a>显示界面</h1><p>我只贴关键代码，具体的可以去Github上查看。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c:choose</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">c:when</span> <span class="attr">test</span>=<span class="string">&quot;$&#123;userList.size()==0 &#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">style</span>=<span class="string">&quot;padding-top: 20px&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span>$&#123;q&#125;<span class="tag">&lt;/<span class="name">font</span>&gt;</span>未查询到结果，请换个关键字试试！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">c:when</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">c:otherwise</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">style</span>=<span class="string">&quot;padding-top: 20px&quot;</span>&gt;</span></span><br><span class="line">                            查询<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span>$&#123;q&#125;<span class="tag">&lt;/<span class="name">font</span>&gt;</span>关键字，约$&#123;resultTotal&#125;条记录！</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">var</span>=<span class="string">&quot;u&quot;</span> <span class="attr">items</span>=<span class="string">&quot;$&#123;userList &#125;&quot;</span> <span class="attr">varStatus</span>=<span class="string">&quot;status&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-heading &quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-6&quot;</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-12&quot;</span>&gt;</span></span><br><span class="line">                                                <span class="tag">&lt;<span class="name">b</span>&gt;</span></span><br><span class="line">                                                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%=path %&gt;/user/showUser/$&#123;u.userId&#125;&quot;</span>&gt;</span>$&#123;u.username&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                                                <span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">                                                <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                                                    $&#123;u.description&#125;</span><br><span class="line">                                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4 col-md-offset-2&quot;</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text-muted text-right&quot;</span>&gt;</span></span><br><span class="line">                                                $&#123;u.password&#125;</span><br><span class="line">                                        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-footer&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text-right&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;label label-default&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;glyphicon glyphicon-comment&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">							 $&#123;u.password&#125;</span><br><span class="line">							<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">c:otherwise</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">c:choose</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>利用<code>JSTL</code>标签即可将数据循环展示出来，关键字就不需要单独做处理了，在后台查询的时候已经做了修改了。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于全文检索的框架不止<code>Lucene</code>还有<code>solr</code>，具体谁好有什么区别我也不太清楚，准备下来花点时间研究下。哦对了，最近又有点想做<code>Android</code>开发了，感觉做点东西能够实实在在的摸得到逼格确实要高些(现在主要在做后端开发)，感兴趣的朋友可以关注下。哦对了，直接运行我代码的朋友要下注意：</p>
<ul>
<li>首先要将数据库倒到自己的MySQL上<img src="http://i.imgur.com/rSodBB5.png"></li>
<li>之后在首次运行的时候需要点击<img src="http://i.imgur.com/jQySeaf.png">重新生成索引按钮生成一遍索引之后才能进行搜索，因为现在的数据是直接存到数据库中的，并没有在新增的时候就增加索引，在实际开发的时候需要在新增数据那里再生成一份索引，就直接调用<code>LuceneIndex</code>类中的<code>addIndex</code>方法传入实体即可，再做更新、删除操作的时候也同样需要对索引做操作。</li>
</ul>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IDEA</tag>
        <tag>Lucene</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(三)Shiro使用详解</title>
    <url>/2016/07/15/SSM3/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/08/02/598158574d7a3.jpg" alt="0.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相比有做过企业级开发的童鞋应该都有做过权限安全之类的功能吧，最先开始我采用的是建<code>用户表</code>,<code>角色表</code>,<code>权限表</code>，之后在拦截器中对每一个请求进行拦截，再到数据库中进行查询看当前用户是否有该权限，这样的设计能满足大多数中小型系统的需求。不过这篇所介绍的Shiro能满足之前的所有需求，并且使用简单，安全性高，而且现在越来越的多企业都在使用Shiro，这应该是一个收入的你的技能库。</p>
<hr>
<h1 id="创建自定义MyRealm类"><a href="#创建自定义MyRealm类" class="headerlink" title="创建自定义MyRealm类"></a>创建自定义<code>MyRealm</code>类</h1><p>有关Shiro的基础知识我这里就不过多介绍了，直接来干货，到最后会整合Spring来进行权限验证。<br>首先在使用Shiro的时候我们要考虑在什么样的环境下使用：</p>
<ul>
<li>登录的验证</li>
<li>对指定角色的验证</li>
<li>对URL的验证</li>
</ul>
<span id="more"></span>


<p>基本上我们也就这三个需求，所以同时我们也需要三个方法：</p>
<ol>
<li><code>findUserByUserName(String username)</code>根据username查询用户，之后Shiro会根据查询出来的User的密码来和提交上来的密码进行比对。</li>
<li><code>findRoles(String username)</code>根据username查询该用户的所有角色，用于角色验证。</li>
<li><code>findPermissions(String username)</code>根据username查询他所拥有的权限信息，用于权限判断。</li>
</ol>
<p>下面我贴一下我的mapper代码(PS:该项目依然是基于之前的SSM，不太清楚整合的请看<a href="http://crossoverjie.top/2016/06/28/SSM1/">SSM一</a>)。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.crossoverJie.dao.T_userDao&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.crossoverJie.pojo.T_user&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;roleId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;roleId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span> &gt;</span></span><br><span class="line">        id, username, password,roleId</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByUsername&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span>/&gt;</span></span><br><span class="line">        from t_user where userName=#&#123;userName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findRoles&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;String&quot;</span>&gt;</span></span><br><span class="line">        select r.roleName from t_user u,t_role r where u.roleId=r.id and u.userName=#&#123;userName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findPermissions&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;String&quot;</span>&gt;</span></span><br><span class="line">        select p.permissionName from t_user u,t_role r,t_permission p</span><br><span class="line">        where u.roleId=r.id and p.roleId=r.id and u.userName=#&#123;userName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>很简单只有三个方法，分别对应上面所说的三个方法。对<code>sql</code>稍微熟悉点的童鞋应该都能看懂，不太清楚就拷到数据库中执行一下就行了，数据库的<code>Sql</code>也在我的<code>github</code>上。实体类就比较简单了，就只有四个字段以及get,set方法。我就这里就不贴了，具体可以去<code>github</code>上<code>fork</code>我的源码。</p>
<p>现在就需要创建自定义的<code>MyRealm</code>类，这个还是比较重要的。继承至<code>Shiro</code>的<code>AuthorizingRealm</code>类，用于处理自己的验证逻辑，下面贴一下我的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crossoverJie.shiro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.crossoverJie.pojo.T_user;</span><br><span class="line"><span class="keyword">import</span> com.crossoverJie.service.T_userService;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * Created by $&#123;jie.chen&#125; on 2016/7/14.</span></span><br><span class="line"><span class="comment"> * Shiro自定义域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> T_userService t_userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于的权限的认证。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principalCollection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> principalCollection.getPrimaryPrincipal().toString() ;</span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>() ;</span><br><span class="line">        Set&lt;String&gt; roleName = t_userService.findRoles(username) ;</span><br><span class="line">        Set&lt;String&gt; permissions = t_userService.findPermissions(username) ;</span><br><span class="line">        info.setRoles(roleName);</span><br><span class="line">        info.setStringPermissions(permissions);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首先执行这个登录验证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span></span><br><span class="line">            <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="comment">//获取用户账号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> token.getPrincipal().toString() ;</span><br><span class="line">        <span class="type">T_user</span> <span class="variable">user</span> <span class="operator">=</span> t_userService.findUserByUsername(username) ;</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将查询到的用户账号和密码存放到 authenticationInfo用于后面的权限判断。第三个参数随便放一个就行了。</span></span><br><span class="line">            <span class="type">AuthenticationInfo</span> <span class="variable">authenticationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(user.getUserName(),user.getPassword(),</span><br><span class="line">                    <span class="string">&quot;a&quot;</span>) ;</span><br><span class="line">            <span class="keyword">return</span> authenticationInfo ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">null</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承<code>AuthorizingRealm</code>类之后就需要覆写它的两个方法，<code>doGetAuthorizationInfo</code>,<code>doGetAuthenticationInfo</code>，这两个方法的作用我都有写注释，逻辑也比较简单。<br><code>doGetAuthenticationInfo</code>是用于登录验证的，在登录的时候需要将数据封装到<code>Shiro</code>的一个<code>token</code>中，执行shiro的<code>login()</code>方法，之后只要我们将<code>MyRealm</code>这个类配置到Spring中，登录的时候<code>Shiro</code>就会自动的调用<code>doGetAuthenticationInfo()</code>方法进行验证。<br>哦对了，忘了贴下登录的<code>Controller</code>了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crossoverJie.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.crossoverJie.pojo.T_user;</span><br><span class="line"><span class="keyword">import</span> com.crossoverJie.service.T_userService;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * Created by $&#123;jie.chen&#125; on 2016/7/14.</span></span><br><span class="line"><span class="comment"> * 后台Controller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T_userController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> T_userService t_userService ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/loginAdmin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(T_user user, Model model)</span>&#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject() ;</span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(user.getUserName(),user.getPassword()) ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span> ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">//这里将异常打印关闭是因为如果登录失败的话会自动抛异常</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">            model.addAttribute(<span class="string">&quot;error&quot;</span>,<span class="string">&quot;用户名或密码错误&quot;</span>) ;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;../../login&quot;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/admin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">admin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/student&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">student</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/teacher&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">teacher</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是<code>login()</code>方法。逻辑比较简单，只是登录验证的时候不是像之前那样直接查询数据库然后返回是否有用户了，而是调用<code>subject</code>的<code>login()</code>方法,就是我上面提到的，调用<code>login()</code>方法时<code>Shiro</code>会自动调用我们自定义的<code>MyRealm</code>类中的<code>doGetAuthenticationInfo()</code>方法进行验证的，验证逻辑是先根据用户名查询用户，如果查询到的话再将查询到的用户名和密码放到<code>SimpleAuthenticationInfo</code>对象中，Shiro会自动根据用户输入的密码和查询到的密码进行匹配，如果匹配不上就会抛出异常，匹配上之后就会执行<code>doGetAuthorizationInfo()</code>进行相应的权限验证。<br><code>doGetAuthorizationInfo()</code>方法的处理逻辑也比较简单，根据用户名获取到他所拥有的角色以及权限，然后赋值到<code>SimpleAuthorizationInfo</code>对象中即可，Shiro就会按照我们配置的XX角色对应XX权限来进行判断，这个配置在下面的整合中会讲到。</p>
<hr>
<h1 id="整合Spring"><a href="#整合Spring" class="headerlink" title="整合Spring"></a>整合Spring</h1><p>接下来应该是大家比较关系的一步：整合<code>Spring</code>。<br>我是在之前的<code>Spring SpringMVC Mybatis</code>的基础上进行整合的。</p>
<h2 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h2><p>首先我们需要在<code>web.xml</code>进行配置Shiro的过滤器。<br>我只贴Shiro部分的，其余的和之前配置是一样的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- shiro过滤器定义 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetFilterLifecycle<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置还是比较简单的，这样会过滤所有的请求。<br>之后我们还需要在Spring中配置一个<code>shiroFilter</code>的bean。</p>
<h2 id="spring-mybatis-xml配置"><a href="#spring-mybatis-xml配置" class="headerlink" title="spring-mybatis.xml配置"></a>spring-mybatis.xml配置</h2><p>由于这里配置较多，我就全部贴一下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/context/spring-context-3.1.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.crossoverJie&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;propertyConfigurer&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库的驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.user&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置初始化大小、最小、最大 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置获取连接等待超时的时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWait&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;300000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validationQuery&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SELECT &#x27;x&#x27;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnReturn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolPreparedStatementPerConnectionSize&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filters&quot;</span> <span class="attr">value</span>=<span class="string">&quot;stat&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自动扫描mapping.xml文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapping/*.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.crossoverJie.dao&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置自定义Realm --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myRealm&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crossoverJie.shiro.MyRealm&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;securityManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;realm&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myRealm&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Shiro过滤器 核心--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;shiroFilter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Shiro的核心安全接口,这个属性是必须的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;securityManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;securityManager&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 身份认证失败，则跳转到登录页面的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;loginUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/login.jsp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 权限认证失败，则跳转到指定页面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;unauthorizedUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/nopower.jsp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Shiro连接约束配置,即过滤链的定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filterChainDefinitions&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--anon 表示匿名访问，不需要认证以及授权--&gt;</span></span><br><span class="line">                /loginAdmin=anon</span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!--authc表示需要认证 没有进行身份认证是不能进行访问的--&gt;</span></span><br><span class="line">                /admin*=authc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                /student=roles[teacher]</span><br><span class="line">                /teacher=perms[&quot;user:create&quot;]</span><br><span class="line">            <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lifecycleBeanPostProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启Shiro注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">depends-on</span>=<span class="string">&quot;lifecycleBeanPostProcessor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;securityManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;securityManager&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这里我们配置了上文中所提到的自定义<code>myRealm</code>,这样Shiro就可以按照我们自定义的逻辑来进行权限验证了。其余的都比较简单，看注释应该都能明白。<br>着重讲解一下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filterChainDefinitions&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--anon 表示匿名访问，不需要认证以及授权--&gt;</span></span><br><span class="line">        /loginAdmin=anon</span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--authc表示需要认证 没有进行身份认证是不能进行访问的--&gt;</span></span><br><span class="line">        /admin*=authc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /student=roles[teacher]</span><br><span class="line">        /teacher=perms[&quot;user:create&quot;]</span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>&#x2F;loginAdmin&#x3D;anon的意思的意思是，发起&#x2F;loginAdmin这个请求是不需要进行身份认证的，这个请求在这次项目中是一个登录请求，一般对于这样的请求都是不需要身份认证的。</li>
<li>&#x2F;admin*&#x3D;authc表示 &#x2F;admin,&#x2F;admin1,&#x2F;admin2这样的请求都是需要进行身份认证的，不然是不能访问的。</li>
<li>&#x2F;student&#x3D;roles[teacher]表示访问&#x2F;student请求的用户必须是<code>teacher</code>角色，不然是不能进行访问的。</li>
<li>&#x2F;teacher&#x3D;perms[“user:create”]表示访问&#x2F;teacher请求是需要当前用户具有<code>user:create</code>权限才能进行访问的。<br>更多相关权限过滤的资料可以访问shiro的官方介绍：<a href="http://shiro.apache.org/spring.html">传送门</a></li>
</ul>
<hr>
<h1 id="使用Shiro标签库"><a href="#使用Shiro标签库" class="headerlink" title="使用Shiro标签库"></a>使用Shiro标签库</h1><p>Shiro还有着强大标签库，可以在前端帮我获取信息和做判断。<br>我贴一下我这里登录完成之后显示的界面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Administrator</span><br><span class="line">  Date: 2016/7/14</span><br><span class="line">  Time: 13:17</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>后台<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">&quot;admin&quot;</span>&gt;</span></span><br><span class="line">    这是admin角色登录：<span class="tag">&lt;<span class="name">shiro:principal</span>&gt;</span><span class="tag">&lt;/<span class="name">shiro:principal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">&quot;user:create&quot;</span>&gt;</span></span><br><span class="line">    有user:create权限信息</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">登录成功</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要想使用Shiro标签，只需要引入一下标签即可：<br><code>&lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;</code><br>其实英语稍微好点的童鞋应该都能看懂。下面我大概介绍下一些标签的用法：</p>
<ul>
<li>&lt;shiro:hasRole name&#x3D;”admin”&gt;具有<code>admin</code>角色才会显示标签内的信息。</li>
<li><a href="shiro:principal">shiro:principal</a></shiro:principal>获取用户信息。默认调用<code> Subject.getPrincipal()</code>获取，即 Primary Principal。</li>
<li>&lt;shiro:hasPermission name&#x3D;”user:create”&gt; 用户拥有<code>user:create</code>这个权限才回显示标签内的信息。<br>更多的标签可以查看官网：<a href="http://shiro.apache.org/webapp-tutorial.html">传送门</a></li>
</ul>
<hr>
<h1 id="整体测试"><a href="#整体测试" class="headerlink" title="整体测试"></a>整体测试</h1><p><img src="https://i.loli.net/2017/08/02/5981597b8d1eb.png" alt="1.png"></p>
<p>这是我的测试数据。<br>首先来验证一下登录：<br>先输入一个错误的账号和密码：<br><img src="https://i.loli.net/2017/08/02/5981597c9b8a2.gif" alt="2.gif"></p>
<p>接下来输入一个正确的：<br><img src="https://i.loli.net/2017/08/02/5981597d3cfde.gif" alt="3.gif"></p>
<p>可以看到我登录的用户是<code>crossoverJie</code>他是有<code>admin</code>的角色，并且拥有<code>user:*</code>(ps:系统数据详见上面的数据库截图)的权限，所以在这里：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">&quot;admin&quot;</span>&gt;</span>   </span><br><span class="line">    这是admin角色登录：<span class="tag">&lt;<span class="name">shiro:principal</span>&gt;</span><span class="tag">&lt;/<span class="name">shiro:principal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">&quot;user:create&quot;</span>&gt;</span></span><br><span class="line">    有user:create权限信息</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>是能显示出标签内的信息，并把用户信息也显示出来了。<br>接着我们来访问一下<code>/student</code>这个请求，因为在Spring的配置文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filterChainDefinitions&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--anon 表示匿名访问，不需要认证以及授权--&gt;</span></span><br><span class="line">        /loginAdmin=anon</span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--authc表示需要认证 没有进行身份认证是不能进行访问的--&gt;</span></span><br><span class="line">        /admin*=authc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /student=roles[teacher]</span><br><span class="line">        /teacher=perms[&quot;user:create&quot;]</span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只有<code>teacher</code>角色才能访问<code>/student</code>这个请求的：<br><img src="https://i.loli.net/2017/08/02/5981597c201da.gif" alt="4.gif"></p>
<p>果然，Shiro做了安全控制是不能进行访问的。<br>然后我们换<code>aaa</code>用户登录，他正好是<code>teacher</code>角色，看能不能访问<code>/student</code>。</p>
<p><img src="https://i.loli.net/2017/08/02/5981597d46ed2.gif" alt="5.gif"></p>
<p>果然是能访问的。<br>因为我在控制器里访问<code>/student</code>返回的是同一个界面所以看到的还是这个界面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/teacher&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">teacher</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且没有显示之前Shiro标签内的内容。<br>其他的我就不测了，大家可以自己在数据库里加一些数据，或者是改下拦截的权限多试试，这样对Shiro的理解就会更加深刻。</p>
<hr>
<h1 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h1><p>Shiro还封装了一个我认为非常不错的功能，那就是MD5加密，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crossoverJie.shiro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.hash.Md5Hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * 基于Shiro的MD5加密</span></span><br><span class="line"><span class="comment"> * Created by $&#123;jie.chen&#125; on 2016/7/13.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MD5Util</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">md5</span><span class="params">(String str,String salt)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Md5Hash</span>(str,salt).toString() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">md5</span> <span class="operator">=</span> md5(<span class="string">&quot;abc123&quot;</span>,<span class="string">&quot;crossoverjie&quot;</span>) ;</span><br><span class="line">        System.out.println(md5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码非常简单，只需要调用<code>Md5Hash(str,salt)</code>方法即可，这里多了一个参数，第一个参数不用多解释，是需要加密的字符串。第二个参数<code>salt</code>中文翻译叫盐，加密的时候我们传一个字符串进去，只要这个salt不被泄露出去，那原则上加密之后是无法被解密的，在存用户密码的时候可以使用，感觉还是非常屌的。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是Shiro实际使用的案例，将的比较初略，但是关于Shiro的核心东西都在里面了。大家可以去我的github上下载源码，只要按照我给的数据库就没有问题，项目跑起来之后试着改下里面的东西可以加深对Shiro的理解。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/crossoverJie/SSM.git">https://github.com/crossoverJie/SSM.git</a><br>个人博客地址：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。<br>GitHub地址：<a href="https://github.com/crossoverJie">https://github.com/crossoverJie</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IDEA</tag>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(四)WebService入门详解</title>
    <url>/2016/08/02/SSM4/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1ba1be78e8.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>webservice这个不知道大家首次接触的时候是怎么理解的，反正我记得我当时第一次接触这个东西的时候以为又是一个XX框架，觉得还挺高大上。然而这一切在之后我使用过后才发现这些全都是YY。<br>那么webservice到底是什么呢，根据我自己的理解：简单来说就像是一个公开的接口，其他系统不管你是用什么语言来编写的都可以调用这个接口，并可以返回相应的数据给你。就像是现在很多的天气应用，他们肯定不会自己去搞一个气象局之类的部门去监测天气，大多都是直接调用一个天气接口，然后返回天气数据，相关应用就可以将这些信息展示给用户了。<br>通常来说发布这类接口的应用都是用一两种语言来编写即可，但是调用这个接口应用可能会是各种语言来编写的，为了满足这样的需求webservice出现了。</p>
<blockquote>
<p>简单来说webservice就是为了满足以上需求而定义出来的规范。</p>
</blockquote>
<hr>
<h1 id="Spring整合CXF"><a href="#Spring整合CXF" class="headerlink" title="Spring整合CXF"></a>Spring整合CXF</h1><p>在Java中实现webservice有多种方法，java本身在jdk1.7之后也对webservice有了默认的实现，但是在我们实际开发中一般还是会使用框架来，比如这里所提到的CXF就有着广泛的应用。<br>废话我就不多说了，直接讲Spring整合CXF，毕竟现在的JavaEE开发是离不开Spring了。<br>该项目还是基于之前的<a href="https://github.com/crossoverjie/SSM">SSM</a>进行开发的。</p>
<h2 id="加入maven依赖"><a href="#加入maven依赖" class="headerlink" title="加入maven依赖"></a>加入maven依赖</h2><p>第一步肯定是要加入maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--cxf--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.cxf/cxf-rt-frontend-jaxws --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.cxf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cxf-rt-frontend-jaxws<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.cxf/cxf-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.cxf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cxf-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.cxf/cxf-rt-transports-http --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.cxf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cxf-rt-transports-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h2><p>接着我们需要配置一个CXF的servlet：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义一个cxf的servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>CXFServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.cxf.transport.servlet.CXFServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>CXFServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/webservice/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后只要我们访问webservice&#x2F;*这个地址就会进入CXF的servlet中。</p>
<h2 id="整合Spring配置"><a href="#整合Spring配置" class="headerlink" title="整合Spring配置"></a>整合Spring配置</h2><p>接下来是最重要的一部，用Spring整合CXF：<br>在这之前我有新建一个CXF的包，如下图：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba1e3ca45.jpg"></p>
<p>这里有两个主要类</p>
<ul>
<li>HelloWorld接口。</li>
<li>实现HelloWorld接口的HelloWorldImpl类。<br>代码如下：<br>HelloWorld.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crossoverJie.cxf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jws.WebService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">say</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中就只定义了一个简单的<code>say()</code>方法。<br>HelloWorldImpl.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crossoverJie.cxf.impl;</span><br><span class="line"><span class="keyword">import</span> com.crossoverJie.cxf.HelloWorld;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.jws.WebService;</span><br><span class="line"><span class="meta">@Component(&quot;helloWorld&quot;)</span></span><br><span class="line"><span class="meta">@WebService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">say</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>+str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里就是对<code>say()</code>方法的简单实现。<br>接下来就是整合Spring了，由于需要使用到CXF的标签，所以我们需要添加额外的命名路径如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:jee</span>=<span class="string">&quot;http://www.springframework.org/schema/jee&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:jaxws</span>=<span class="string">&quot;http://cxf.apache.org/jaxws&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:META-INF/cxf/cxf.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:META-INF/cxf/cxf-servlet.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描webService --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.crossoverJie.cxf&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义webservice的发布接口  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jaxws:endpoint</span></span></span><br><span class="line"><span class="tag">            <span class="attr">implementor</span>=<span class="string">&quot;#helloWorld&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">address</span>=<span class="string">&quot;/HelloWorld&quot;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="attr">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>更加具体的配置可以查看官方给出的文档:<a href="http://cxf.apache.org/docs/how-do-i-develop-a-service.html">http://cxf.apache.org/docs/how-do-i-develop-a-service.html</a>。<br><code>#helloWorld</code>指的是我们在<code>HelloWorldImpl</code>类中所自定义的名字，<code>/HelloWorld</code>则是我们需要访问的地址。<br>之后我们运行项目输入该地址：<a href="http://127.0.0.1:8080/ssm/webservice/HelloWorld?wsdl">http://127.0.0.1:8080/ssm/webservice/HelloWorld?wsdl</a>如果出现如下界面：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba23ed4e7.jpg"></p>
<p>则说明我们的webservice发布成功了。<br>接下来只需要通过客户端调用这个接口即可获得返回结果了。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是一个简单的webservice入门实例，更多的关于CXF拦截器，客户端调用就没有做过多介绍，后续有时间的话再接着更新。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/crossoverJie/SSM.git">https://github.com/crossoverJie/SSM.git</a><br>个人博客地址：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。<br>GitHub地址：<a href="https://github.com/crossoverJie">https://github.com/crossoverJie</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IDEA</tag>
        <tag>CXF</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(六)跨域传输</title>
    <url>/2016/10/18/SSM6/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1ba153e527.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不知大家在平时的开发过程中有没有遇到过跨域访问资源的问题，我不巧在上周就碰到一个这样的问题，幸运的是在公司前端同学的帮忙下解决了该问题。</p>
<h2 id="什么是跨域问题？"><a href="#什么是跨域问题？" class="headerlink" title="什么是跨域问题？"></a>什么是跨域问题？</h2><ol>
<li>只要协议、域名、端口有任何一个不同，都被当作是不同的域</li>
<li>只要是在不同域中是无法进行通信的。</li>
</ol>
<span id="more"></span>

<p>基于以上的的出发点，我们又有跨域共享资源的需求(<code>譬如现在流行的前后端分离之后分别部署的情况</code>)，本文所采用的解决办法是<code>JSONP</code>，说到<code>JSONP</code>就会首先想到<code>JSON</code>。虽然只有一字之差但意义却完全不一样，首先科普一下<code>JSON</code>。</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><blockquote>
<p>其实现在<code>JSON</code>已经是相当流行了，只要涉及到前后端的数据交互大都都是采用的JSON(不管是web还是android和IOS)，所以我这里就举一个例子，就算是没有用过的同学也能很快明白其中的意思。</p>
</blockquote>
<h2 id="PostMan"><a href="#PostMan" class="headerlink" title="PostMan"></a>PostMan</h2><p>首先给大家安利一款后端开发的利器<code>PostMan</code>,可以用于模拟几乎所有的<code>HTTP</code>请求，在开发阶段调试后端接口非常有用。<br>这是一个Chrome插件，可以直接在google商店搜索直接下载(当然前提你懂得)。<br>之后界面就如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba18947ba.jpg"></p>
<p>界面非常简洁，有点开发经验的童鞋应该都会使用，不太会用的直接google下就可以了比较简单。<br>接着我们就可以利用<code>PostMan</code>来发起一次请求获取<code>JSON</code>了。这里以我<code>SSM</code>项目为例,也正好有暴露一个JSON的接口。地址如下:<br><a href="http://www.crossoverjie.top/SSM/content_load">http://www.crossoverjie.top/SSM/content_load</a>。<br>直接在<code>POSTMAN</code>中的地址栏输入该地址，采用<code>GET</code>的方式请求，之后所返回的就是JSON格式的字符串。<br>由于<code>Javascript</code>原生的就支持JSON，所以解析起来非常方便。</p>
<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>好了，终于可以谈谈<code>JSONP</code>了。之前说道<code>JSONP</code>是用来解决跨域问题的，那么他是如何解决的呢。<br>经过我们开发界的前辈们发现，HTML中拥有<code>SRC</code>属性的标签都不受跨域的影响，比如：<code>&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;</code>标签。<br>由于JS原生支持JSON的解析，于是我们采用<code>&lt;script&gt;</code>的方式来处理跨域解析，代码如下一看就明白。<br>web端:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">async</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">url</span>: <span class="string">&quot;http://www.crossoverjie.top/SSM/jsonpInfo?callback=getUser&amp;userId=3&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">dataType</span>: <span class="string">&quot;jsonp&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">jsonp</span>: <span class="string">&quot;callback&quot;</span>,<span class="comment">//一般默认为:callback</span></span></span><br><span class="line"><span class="language-javascript">                <span class="attr">jsonpCallback</span>:<span class="string">&quot;getUser&quot;</span>,<span class="comment">//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据</span></span></span><br><span class="line"><span class="language-javascript">                <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">json</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                     * 获得服务器返回的信息。</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                     * 可以做具体的业务处理。</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                     */</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(<span class="string">&#x27;用户信息：ID： &#x27;</span> + json.<span class="property">userId</span> + <span class="string">&#x27; ，姓名： &#x27;</span> + json.<span class="property">username</span> + <span class="string">&#x27;。&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(<span class="string">&#x27;fail&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">oncontextmenu</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中我们采用了JQuery给我封装好的函数，这样就可以自动帮我们解析了。<br>首先我们来看下代码中的<a href="http://www.crossoverjie.top/SSM/jsonpInfo?callback=getUser&userId=3">http://www.crossoverjie.top/SSM/jsonpInfo?callback=getUser&userId=3</a>这个地址返回的是什么内容，还是放到<code>POSTMAN</code>中执行如下：<br><img src="http://img.blog.csdn.net/20161018005211291" alt="3">。<br>可以看到我们所传递的<code>callback</code>参数带着查询的数据又原封不动的返回给我们了，这样的话即使我们不使用<code>JQuery</code>给我封装好的函数，我们自定义一个和<code>callback</code>名称一样的函数一样是可以解析其中的数据的，只是<code>Jquery</code>帮我们做了而已。</p>
<p>前端没问题了，那么后端又是如何实现的呢？也很简单，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/jsonpInfo&quot;,method = &#123; RequestMethod.GET &#125;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">jsonpInfo</span><span class="params">(String callback,Integer userId)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getUserById(userId);</span><br><span class="line">    <span class="type">JSONPObject</span> <span class="variable">jsonpObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONPObject</span>(callback,user) ;</span><br><span class="line">    <span class="keyword">return</span> jsonpObject ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后端采用了<code>jackson</code>中的<code>JSONPObject</code>这个类的一个构造方法，只需要将<code>callback</code>字段和需要转成<code>JSON</code>字符串的对象放进去即可。<br>需要主要的是需要使用<code>@ResponseBody</code>注解才能成功返回。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实网上还有其他的方法来处理跨域问题，不过我觉得这样的方式最为简单。同样JSONP也是有缺点的，比如：只支持<code>GET</code>方式的HTTP请求。<br>以上代码依然在博主的<a href="https://github.com/crossoverJie/SSM">SSM</a>项目中，如有需要可以直接<code>FORK</code>。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/crossoverJie/SSM.git">https://github.com/crossoverJie/SSM.git</a></p>
</blockquote>
<blockquote>
<p>个人博客地址：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
<blockquote>
<p>GitHub地址：<a href="https://github.com/crossoverJie">https://github.com/crossoverJie</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JSONP</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(五)基于webSocket的聊天室</title>
    <url>/2016/09/04/SSM5/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1ba1710d06.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不知大家在平时的需求中有没有遇到需要实时处理信息的情况，如站内信，订阅，聊天之类的。在这之前我们通常想到的方法一般都是采用轮训的方式每隔一定的时间向服务器发送请求从而获得最新的数据，但这样会浪费掉很多的资源并且也不是实时的，于是随着<code>HTML5</code>的推出带来了<code>websocket</code>可以根本的解决以上问题实现真正的实时传输。</p>
<h2 id="websocket是什么？"><a href="#websocket是什么？" class="headerlink" title="websocket是什么？"></a>websocket是什么？</h2><p>至于<code>websocket</code>是什么、有什么用这样的问题一Google一大把，这里我就简要的说些<code>websocket</code>再本次实例中的作用吧。<br>由于在本次实例中需要实现的是一个聊天室，一个实时的聊天室。如下图：</p>
<p><img src="http://i.imgur.com/6of3Z5K.gif" alt="1.gif"></p>
<span id="more"></span>

<p>采用<code>websocket</code>之后可以让前端和和后端像C&#x2F;S模式一样实时通信，不再需要每次单独发送请求。由于是基于H5的所以对于老的浏览器如IE7、IE8之类的就没办法了，不过H5是大势所趋这点不用担心。</p>
<h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><p>既然推出了<code>websocket</code>，作为现在主流的Java肯定也有相应的支持，所以在<code>JavaEE7</code>之后也对<code>websocket</code>做出了规范，所以本次的代码理论上是要运行在<code>Java1.7</code>+和<code>Tomcat7.0+</code>之上的。<br>看过我前面几篇文章的朋友应该都知道本次实例也是运行在之前的<a href="https://github.com/crossoverjie/ssm">SSM</a>之上的，所以这里就不再赘述了。<br>首先第一步需要加入<code>websocket</code>的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.websocket/javax.websocket-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上就是使用<code>websocket</code>所需要用到的包。<code>spring-websocket</code>这个主要是在之后需要在<code>websocket</code>的后端注入<code>service</code>所需要的。<br>之后再看一下后端的核心代码<code>MyWebSocket.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crossoverJie.controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2016/8/7.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> com.crossoverJie.pojo.Content;</span><br><span class="line"><span class="keyword">import</span> com.crossoverJie.service.ContentService;</span><br><span class="line"><span class="keyword">import</span> org.apache.camel.BeanInject;</span><br><span class="line"><span class="keyword">import</span> org.apache.camel.EndpointInject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.support.SpringBeanAutowiringSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.standard.SpringConfigurator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnClose;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnError;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnMessage;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnOpen;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该注解用来指定一个URI，客户端可以通过这个URI来连接到WebSocket。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  类似Servlet的注解mapping。无需在web.xml中配置。</span></span><br><span class="line"><span class="comment"> * configurator = SpringConfigurator.class是为了使该类可以通过Spring注入。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ServerEndpoint(value = &quot;/websocket&quot;,configurator = SpringConfigurator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebSocket</span> &#123;</span><br><span class="line">    <span class="comment">//静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">onlineCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyWebSocket</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ContentService contentService ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。</span></span><br><span class="line">    <span class="comment">// 若要实现服务端与单一客户端通信的话，可以使用Map来存放，其中Key可以为用户标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;MyWebSocket&gt; webSocketSet = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;MyWebSocket&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session  可选的参数。session为与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.session = session;</span><br><span class="line">        webSocketSet.add(<span class="built_in">this</span>);     <span class="comment">//加入set中</span></span><br><span class="line">        addOnlineCount();           <span class="comment">//在线数加1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;有新连接加入！当前在线人数为&quot;</span> + getOnlineCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span>&#123;</span><br><span class="line">        webSocketSet.remove(<span class="built_in">this</span>);  <span class="comment">//从set中删除</span></span><br><span class="line">        subOnlineCount();           <span class="comment">//在线数减1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;有一连接关闭！当前在线人数为&quot;</span> + getOnlineCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 可选的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来自客户端的消息:&quot;</span> + message);</span><br><span class="line">        <span class="comment">//群发消息</span></span><br><span class="line">        <span class="keyword">for</span>(MyWebSocket item: webSocketSet)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                item.sendMessage(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生错误时调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable error)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发生错误&quot;</span>);</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法与上面几个方法不一样。没有用注解，是根据自己需要添加的方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">//保存数据到数据库</span></span><br><span class="line">        <span class="type">Content</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Content</span>() ;</span><br><span class="line">        content.setContent(message);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:dd&quot;</span>) ;</span><br><span class="line">        content.setCreateDate(sm.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        contentService.insertSelective(content) ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">        <span class="comment">//this.session.getAsyncRemote().sendText(message);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getOnlineCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> onlineCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addOnlineCount</span><span class="params">()</span> &#123;</span><br><span class="line">        MyWebSocket.onlineCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">subOnlineCount</span><span class="params">()</span> &#123;</span><br><span class="line">        MyWebSocket.onlineCount--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是整个<code>websocket</code>的后端代码。看起来也比较简单主要就是使用那几个注解。每当有一个客户端连入、关闭、发送消息都会调用各自注解的方法。这里我讲一下<code>sendMessage()</code>这个方法。</p>
<h2 id="websocket绕坑"><a href="#websocket绕坑" class="headerlink" title="websocket绕坑"></a>websocket绕坑</h2><p>在<code>sendMessage()</code>方法中我只想实现一个简单的功能，就是将每次的聊天记录都存到数据库中。看似一个简单的功能硬是花了我半天的时间。<br>我先是按照以前的惯性思维只需要在这个类中注入<code>service</code>即可。但是无论怎么弄每次都注入不进来都是<code>null</code>。<br>最后没办法只有google了，最后终于在神级社区<code>StackOverFlow</code>中找到了答案，就是前边所说的需要添加的第二个	<code>maven</code>依赖，然后加入<code>@ServerEndpoint(value = &quot;/websocket&quot;,configurator = SpringConfigurator.class)</code>这个注解即可利用<code>Spring</code>注入了。接着就可以做消息的保存了。</p>
<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>前端我采用了Bootstrap做的，不太清楚Bootstrap的童鞋建议先看下<a href="http://www.bootcss.com/">官方文档</a>也比较简单。还是先贴一下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot; %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String path = request.getContextPath();</span><br><span class="line">    String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%=basePath%&gt;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">href</span>=<span class="string">&quot;http://cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- WARNING: Respond.js doesn&#x27;t work if you view the page via file:// --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src=&quot;//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src=&quot;//cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&lt;%=path%&gt;/ueditor/ueditor.config.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&lt;%=path%&gt;/ueditor/ueditor.all.min.js&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--建议手动加在语言，避免在ie下有时因为加载语言失败导致编辑器加载失败--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里加载的语言文件会覆盖你在配置项目里添加的语言类型，比如你在配置项目里配置的是英文，这里加载的中文，那最后就是中文--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&lt;%=path%&gt;/ueditor/lang/zh-cn/zh-cn.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>聊天室<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">data</span>=<span class="string">&quot;/ssm&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;send()&quot;</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;closeWebSocket()&quot;</span>&gt;</span>关闭连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-12&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel panel-primary&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span>聊天室<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-footer&quot;</span>&gt;</span></span><br><span class="line">                    在线人数<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;onlineCount&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span>人</span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-12&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">&quot;editor&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/plain&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:1024px;height:200px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-12&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text-right&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;sendMsg();&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> ue = <span class="variable constant_">UE</span>.<span class="title function_">getEditor</span>(<span class="string">&#x27;editor&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> websocket = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//判断当前浏览器是否支持WebSocket</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (<span class="string">&#x27;WebSocket&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        websocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://192.168.0.102:8080/ssm/websocket&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;对不起！你的浏览器不支持webSocket&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//连接发生错误的回调方法</span></span></span><br><span class="line"><span class="language-javascript">    websocket.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setMessageInnerHTML</span>(<span class="string">&quot;error&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//连接成功建立的回调方法</span></span></span><br><span class="line"><span class="language-javascript">    websocket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setMessageInnerHTML</span>(<span class="string">&quot;加入连接&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//接收到消息的回调方法</span></span></span><br><span class="line"><span class="language-javascript">    websocket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setMessageInnerHTML</span>(event.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//连接关闭的回调方法</span></span></span><br><span class="line"><span class="language-javascript">    websocket.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setMessageInnerHTML</span>(<span class="string">&quot;断开连接&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 防止连接还没断开就关闭窗口，server端会抛异常。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onbeforeunload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> is = <span class="title function_">confirm</span>(<span class="string">&quot;确定关闭窗口？&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (is)&#123;</span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//将消息显示在网页上</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">setMessageInnerHTML</span>(<span class="params">innerHTML</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#msg&quot;</span>).<span class="title function_">append</span>(innerHTML+<span class="string">&quot;&lt;br/&gt;&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//关闭连接</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">closeWebSocket</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        websocket.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//发送消息</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">send</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> message = $(<span class="string">&quot;#text&quot;</span>).<span class="title function_">val</span>() ;</span></span><br><span class="line"><span class="language-javascript">        websocket.<span class="title function_">send</span>(message);</span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#text&quot;</span>).<span class="title function_">val</span>(<span class="string">&quot;&quot;</span>) ;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sendMsg</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> msg = ue.<span class="title function_">getContent</span>();</span></span><br><span class="line"><span class="language-javascript">        websocket.<span class="title function_">send</span>(msg);</span></span><br><span class="line"><span class="language-javascript">        ue.<span class="title function_">setContent</span>(<span class="string">&#x27;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- jQuery (necessary for Bootstrap&#x27;s JavaScript plugins) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://cdn.bootcss.com/jquery/1.11.3/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&lt;%=path%&gt;/js/Globals.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&lt;%=path%&gt;/js/websocket.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其实其中重要的就是那几个JS方法，都写有注释。需要注意的是这里</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断当前浏览器是否支持WebSocket</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;WebSocket&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span><br><span class="line">    websocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://192.168.0.102:8080/ssm/websocket&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;对不起！你的浏览器不支持webSocket&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当项目跑起来之后需要将这里的地址改为你项目的地址即可。<br>哦对了，我在这里采用了百度的一个<code>Ueditor</code>的富文本编辑器(虽然百度搜索我现在很少用了，但是这个编辑器确实还不错)，这个编辑器也比较简单只需要个性化的配置一下个人的需求即可。</p>
<h2 id="Ueditor相关配置"><a href="#Ueditor相关配置" class="headerlink" title="Ueditor相关配置"></a>Ueditor相关配置</h2><p>直接使用我项目运行的童鞋就不需要重新下载了，我将资源放在了webapp目录下的ueditor文件夹下面的。<br>值得注意的是我们首先需要将<code>jsp--&gt;lib</code>下的jar包加入到项目中。加好之后会出现一个想下的箭头表示已经引入成功。<br><img src="http://i.imgur.com/ZtHInpF.png">，之后修改该目录下的<code>config.json</code>文件，主要修改以下内容即可：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;imageAllowFiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;.png&quot;</span><span class="punctuation">,</span> <span class="string">&quot;.jpg&quot;</span><span class="punctuation">,</span> <span class="string">&quot;.jpeg&quot;</span><span class="punctuation">,</span> <span class="string">&quot;.gif&quot;</span><span class="punctuation">,</span> <span class="string">&quot;.bmp&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">/* 上传图片格式显示 */</span></span><br><span class="line"><span class="attr">&quot;imageCompressEnable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">/* 是否压缩图片,默认是true */</span></span><br><span class="line"><span class="attr">&quot;imageCompressBorder&quot;</span><span class="punctuation">:</span> <span class="number">1600</span><span class="punctuation">,</span> <span class="comment">/* 图片压缩最长边限制 */</span></span><br><span class="line"><span class="attr">&quot;imageInsertAlign&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none&quot;</span><span class="punctuation">,</span> <span class="comment">/* 插入的图片浮动方式 */</span></span><br><span class="line"><span class="attr">&quot;imageUrlPrefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://192.168.0.102:8080/ssm&quot;</span><span class="punctuation">,</span> <span class="comment">/* 图片访问路径前缀 */</span></span><br><span class="line"><span class="attr">&quot;imagePathFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/ueditor/jsp/upload/image/&#123;yyyy&#125;&#123;mm&#125;&#123;dd&#125;/&#123;time&#125;&#123;rand:6&#125;&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>这里主要是要修改<code>imageUrlPrefix</code>为你自己的项目地址就可以了。<code>ueditor</code>一个我认为很不错的就是他支持图片、多图、截图上传，而且都不需要手动编写后端接口，所有上传的文件、图片都会保存到项目发布出去的<code>jsp--&gt;upload</code>文件夹下一看就明白了。更多关于<code>ueditor</code>的配置可以查看<a href="http://ueditor.baidu.com/website/">官网</a>。</p>
<blockquote>
<p>其中值得注意一点的是，由于项目采用了<code>Spring MVC</code>并拦截了所有的请求，导致静态资源不能访问，如果是需要用到上传<code>txt</code>文件之类的需求可以参照<code>web.xml</code>中修改，如下:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.txt<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就可以访问txt文件了，如果还需要上传PPT之类的就以此类推。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这样一个简单的基于<code>websocket</code>的聊天室就算完成了，感兴趣的朋友可以将项目部署到外网服务器上这样好基友之间就可以愉快的聊(zhuang)天(bi)了。<br>当然这只是一个简单的项目，感兴趣的朋友再这基础之上加入实时在线人数，用户名和IP之类的。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/crossoverJie/SSM.git">https://github.com/crossoverJie/SSM.git</a><br>个人博客地址：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。<br>GitHub地址：<a href="https://github.com/crossoverJie">https://github.com/crossoverJie</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>websocket</tag>
        <tag>HTML5</tag>
        <tag>ueditor</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(七)在JavaWeb应用中使用Redis</title>
    <url>/2016/12/18/SSM7/</url>
    <content><![CDATA[<p><img src="https://ooo.0o0.ooo/2017/05/07/590ea75de0d84.jpg" alt="redis封面.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于最近换(mang)了(de)家(yi)公(bi)司接触了新的东西所以很久没有更新了。<br>这次谈谈Redis，关于<code>Redis</code>应该很多朋友就算没有用过也听过，算是这几年最流行的<code>NoSql</code>之一了。<br><code>Redis</code>的应用场景非常多这里就不一一列举了，这次就以一个最简单的也最常用的 <strong>缓存数据</strong> 来举例。<br>先来看一张效果图：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba0ab8f76.jpg"></p>
<span id="more"></span>
<p>作用就是在每次查询接口的时候首先判断<code>Redis</code>中是否有缓存，有的话就读取，没有就查询数据库并保存到<code>Redis</code>中，下次再查询的话就会直接从缓存中读取了。<br><code>Redis</code>中的结果：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba0d7badf.jpg"></p>
<p>之后查询redis发现确实是存进来了。</p>
<h1 id="Redis安装与使用"><a href="#Redis安装与使用" class="headerlink" title="Redis安装与使用"></a>Redis安装与使用</h1><p>首先第一步自然是安装<code>Redis</code>。我是在我<code>VPS</code>上进行安装的，操作系统是<code>CentOS6.5</code>。</p>
<ul>
<li><p>下载Redis<a href="https://redis.io/download">https://redis.io/download</a>，我机器上安装的是<code>3.2.5</code></p>
</li>
<li><p>将下载下来的’reidis-3.2.5-tar.gz’上传到<code>usr/local</code>这个目录进行解压。</p>
</li>
<li><p>进入该目录。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba12c0bb0.jpg"></p>
<ul>
<li><p>编译安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>redis.conf</code>配置文件。</p>
</li>
</ul>
<p>这里我只是简单的加上密码而已。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi redis.conf</span><br><span class="line">requirepass 你的密码</span><br></pre></td></tr></table></figure>
<ul>
<li>启动Redis</li>
</ul>
<p>启动时候要选择我们之前修改的配置文件才能使配置文件生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入src目录</span><br><span class="line">cd /usr/local/redis-3.2.5/src</span><br><span class="line">启动服务</span><br><span class="line">./redis-server ../redis.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>登陆redis<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./redis-cli -a 你的密码</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Spring整合Redis"><a href="#Spring整合Redis" class="headerlink" title="Spring整合Redis"></a>Spring整合Redis</h1><p>这里我就直接开始用Spring整合毕竟在实际使用中都是和<code>Spring</code>一起使用的。</p>
<ul>
<li>修改<code>Spring</code>配置文件<br>加入以下内容：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jedis 配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;poolConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.maxIdle&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.maxWait&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.testOnBorrow&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- redis服务器中心 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolConfig&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;poolConfig&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.port&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hostName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.host&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.timeout&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.core.RedisTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;keySerializer&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;valueSerializer&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- cache配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;methodCacheInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crossoverJie.intercept.MethodCacheInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;redisUtil&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;redisUtil&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisUtil&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crossoverJie.util.RedisUtil&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;redisTemplate&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;redisTemplate&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置切面拦截方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将com.crossoverJie.service包下的所有select开头的方法加入拦截</span></span><br><span class="line"><span class="comment">        去掉select则加入所有方法w</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;controllerMethodPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        execution(* com.crossoverJie.service.*.select*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;selectMethodPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        execution(* com.crossoverJie.dao..*Mapper.select*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;methodCacheInterceptor&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;controllerMethodPointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
更多的配置可以直接在源码里面查看：<a href="https://github.com/crossoverJie/SSM/blob/master/src/main/resources/spring-mybatis.xml">https://github.com/crossoverJie/SSM/blob/master/src/main/resources/spring-mybatis.xml</a>。<br>以上都写有注释，也都是一些简单的配置相信都能看懂。<br>下面我会着重说下如何配置缓存的。</li>
</ul>
<h1 id="Spring切面使用缓存"><a href="#Spring切面使用缓存" class="headerlink" title="Spring切面使用缓存"></a>Spring切面使用缓存</h1><p>Spring的<code>AOP</code>真是是一个好东西，还不太清楚是什么的同学建议先自行<code>Google</code>下吧。<br>在不使用切面的时候如果我们想给某个方法加入缓存的话肯定是在方法返回之前就要加入相应的逻辑判断，只有一个或几个倒还好，如果有几十上百个的话那GG了，而且维护起来也特别麻烦。</p>
<blockquote>
<p>好在Spring的AOP可以帮我们解决这个问题。<br>这次就在我们需要加入缓存方法的切面加入这个逻辑，并且只需要一个配置即可搞定，就是上文中所提到的配置文件，如下：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置切面拦截方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--将com.crossoverJie.service包下的所有select开头的方法加入拦截</span></span><br><span class="line"><span class="comment">    去掉select则加入所有方法w</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;controllerMethodPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">    execution(* com.crossoverJie.service.*.select*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;selectMethodPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">    execution(* com.crossoverJie.dao..*Mapper.select*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;methodCacheInterceptor&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;controllerMethodPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里我们使用表达式<code>execution(* com.crossoverJie.service.*.select*(..))</code>来拦截<code>service</code>中所有以<code>select</code>开头的方法。这样只要我们要将加入的缓存的方法以select命名开头的话每次进入方法之前都会进入我们自定义的<code>MethodCacheInterceptor</code>拦截器。<br>这里贴一下<code>MethodCacheInterceptor</code>中处理逻辑的核心方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">targetName</span> <span class="operator">=</span> invocation.getThis().getClass().getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> invocation.getMethod().getName();</span><br><span class="line">        <span class="comment">// 不需要缓存的内容</span></span><br><span class="line">        <span class="comment">//if (!isAddCache(StringUtil.subStrForLastDot(targetName), methodName)) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (!isAddCache(targetName, methodName)) &#123;</span><br><span class="line">            <span class="comment">// 执行方法返回结果</span></span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] arguments = invocation.getArguments();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getCacheKey(targetName, methodName, arguments);</span><br><span class="line">        logger.debug(<span class="string">&quot;redisKey: &quot;</span> + key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断是否有缓存</span></span><br><span class="line">            <span class="keyword">if</span> (redisUtil.exists(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> redisUtil.get(key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写入缓存</span></span><br><span class="line">            value = invocation.proceed();</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">tkey</span> <span class="operator">=</span> key;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">tvalue</span> <span class="operator">=</span> value;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (tkey.startsWith(<span class="string">&quot;com.service.impl.xxxRecordManager&quot;</span>)) &#123;</span><br><span class="line">                            redisUtil.set(tkey, tvalue, xxxRecordManagerTime);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tkey.startsWith(<span class="string">&quot;com.service.impl.xxxSetRecordManager&quot;</span>)) &#123;</span><br><span class="line">                            redisUtil.set(tkey, tvalue, xxxSetRecordManagerTime);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            redisUtil.set(tkey, tvalue, defaultCacheExpireTime);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先是查看了当前方法是否在我们自定义的方法中，如果不是的话就直接返回，不进入拦截器。</li>
<li>之后利用反射获取的类名、方法名、参数生成<code>redis</code>的<code>key</code>。</li>
<li>用key在redis中查询是否已经有缓存。</li>
<li>有缓存就直接返回缓存内容，不再继续查询数据库。</li>
<li>如果没有缓存就查询数据库并将返回信息加入到redis中。</li>
</ul>
<h2 id="使用PageHelper"><a href="#使用PageHelper" class="headerlink" title="使用PageHelper"></a>使用PageHelper</h2><p>这次为了分页方便使用了比较流行的<code>PageHelper</code>来帮我们更简单的进行分页。<br>首先是新增一个mybatis的配置文件<code>mybatis-config</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;multipleResultSetsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultStatementTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;safeRowBoundsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTypeForNull&quot;</span> <span class="attr">value</span>=<span class="string">&quot;OTHER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="attr">value</span>=<span class="string">&quot;equals,clone,hashCode,toString&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该参数默认为false --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 和startPage中的pageNum效果一样 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;offsetAsPageNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该参数默认为false --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置为true时，使用RowBounds分页会进行count查询 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;rowBoundsWithCount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型） &lt;property name=&quot;pageSizeZero&quot; value=&quot;true&quot;/&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;reasonable&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射的用默认值 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 不理解该含义的前提下，不要随便复制该配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;params&quot;</span> <span class="attr">value</span>=<span class="string">&quot;pageNum=start;pageSize=limit;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接着在mybatis的配置文件中引入次配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描mapping.xml文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapping/*.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加入PageHelper--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接着在service方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageEntity&lt;Rediscontent&gt; <span class="title function_">selectByPage</span><span class="params">(Integer pageNum, Integer pageSize)</span> &#123;</span><br><span class="line">    PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">    <span class="comment">//因为是demo，所以这里默认没有查询条件。</span></span><br><span class="line">    List&lt;Rediscontent&gt; rediscontents = rediscontentMapper.selectByExample(<span class="keyword">new</span> <span class="title class_">RediscontentExample</span>());</span><br><span class="line">    PageEntity&lt;Rediscontent&gt; rediscontentPageEntity = <span class="keyword">new</span> <span class="title class_">PageEntity</span>&lt;Rediscontent&gt;();</span><br><span class="line">    rediscontentPageEntity.setList(rediscontents);</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> rediscontentMapper.selectByExample(<span class="keyword">new</span> <span class="title class_">RediscontentExample</span>()).size();</span><br><span class="line">    rediscontentPageEntity.setCount(size);</span><br><span class="line">    <span class="keyword">return</span> rediscontentPageEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要使用<code>PageHelper.startPage(pageNum, pageSize);</code>方法就可以帮我们简单的分页了。<br>这里我自定义了一个分页工具类<code>PageEntity</code>来更方便的帮我们在之后生成<code>JSON</code>数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crossoverJie.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页实体</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageEntity</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list;<span class="comment">// 分页后的数据</span></span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(Integer count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多<code>PageHelper</code>的使用请查看一下链接：<br><a href="https://github.com/pagehelper/Mybatis-PageHelper">https://github.com/pagehelper/Mybatis-PageHelper</a></p>
<h1 id="前端联调"><a href="#前端联调" class="headerlink" title="前端联调"></a>前端联调</h1><p>接下来看下控制层<code>RedisController</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crossoverJie.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.crossoverJie.pojo.Rediscontent;</span><br><span class="line"><span class="keyword">import</span> com.crossoverJie.service.RediscontentService;</span><br><span class="line"><span class="keyword">import</span> com.crossoverJie.util.CommonUtil;</span><br><span class="line"><span class="keyword">import</span> com.crossoverJie.util.PageEntity;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONArray;</span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(RedisController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RediscontentService rediscontentService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/redis_list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">club_list</span><span class="params">(HttpServletResponse response,</span></span><br><span class="line"><span class="params">                          <span class="meta">@RequestParam(value = &quot;page&quot;, defaultValue = &quot;0&quot;)</span> <span class="type">int</span> page,</span></span><br><span class="line"><span class="params">                          <span class="meta">@RequestParam(value = &quot;pageSize&quot;, defaultValue = &quot;0&quot;)</span> <span class="type">int</span> pageSize)</span> &#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">JSONArray</span> <span class="variable">ja</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONArray</span>();</span><br><span class="line">            PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">            PageEntity&lt;Rediscontent&gt; rediscontentPageEntity = rediscontentService.selectByPage(page, pageSize);</span><br><span class="line">            <span class="keyword">for</span> (Rediscontent rediscontent : rediscontentPageEntity.getList()) &#123;</span><br><span class="line">                <span class="type">JSONObject</span> <span class="variable">jo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">                jo1.put(<span class="string">&quot;rediscontent&quot;</span>, rediscontent);</span><br><span class="line">                ja.add(jo1);</span><br><span class="line">            &#125;</span><br><span class="line">            jo.put(<span class="string">&quot;redisContents&quot;</span>, ja);</span><br><span class="line">            jo.put(<span class="string">&quot;count&quot;</span>, rediscontentPageEntity.getCount());</span><br><span class="line">            jsonObject = CommonUtil.parseJson(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;成功&quot;</span>, jo);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            jsonObject = CommonUtil.parseJson(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;操作异常&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建返回</span></span><br><span class="line">        CommonUtil.responseBuildJson(response, jsonObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不做过多解释了，就是从redis或者是service中查询出数据并返回。</p>
<p>前端的显示界面在<a href="https://github.com/crossoverJie/SSM/blob/master/src/main/webapp/redis/showRedis.jsp">https://github.com/crossoverJie/SSM/blob/master/src/main/webapp/redis/showRedis.jsp</a>中(并不是前端，将就看)。<br>其中核心的<code>redis_list.js</code>的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> page = <span class="number">1</span>,</span><br><span class="line">    rows = <span class="number">10</span>;</span><br><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">initJqPaginator</span>();</span><br><span class="line">    <span class="comment">//加载</span></span><br><span class="line">    <span class="title function_">load_redis_list</span>();</span><br><span class="line">    $(<span class="string">&quot;.query_but&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//查询按钮</span></span><br><span class="line">        page = <span class="number">1</span>;</span><br><span class="line">        <span class="title function_">load_redis_list</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//初始化分页</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initJqPaginator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    $.<span class="title function_">jqPaginator</span>(<span class="string">&#x27;#pagination&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">totalPages</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">visiblePages</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">currentPage</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">first</span>: <span class="string">&#x27;&lt;li class=&quot;prev&quot;&gt;&lt;a href=&quot;javascript:;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;&#x27;</span>,</span><br><span class="line">        <span class="attr">last</span>: <span class="string">&#x27;&lt;li class=&quot;prev&quot;&gt;&lt;a href=&quot;javascript:;&quot;&gt;末页&lt;/a&gt;&lt;/li&gt;&#x27;</span>,</span><br><span class="line">        <span class="attr">prev</span>: <span class="string">&#x27;&lt;li class=&quot;prev&quot;&gt;&lt;a href=&quot;javascript:;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&#x27;</span>,</span><br><span class="line">        <span class="attr">next</span>: <span class="string">&#x27;&lt;li class=&quot;next&quot;&gt;&lt;a href=&quot;javascript:;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&#x27;</span>,</span><br><span class="line">        <span class="attr">page</span>: <span class="string">&#x27;&lt;li class=&quot;page&quot;&gt;&lt;a href=&quot;javascript:;&quot;&gt;&#123;&#123;page&#125;&#125;&lt;/a&gt;&lt;/li&gt;&#x27;</span>,</span><br><span class="line">        <span class="attr">onPageChange</span>: <span class="keyword">function</span> (<span class="params">num, type</span>) &#123;</span><br><span class="line">            page = num;</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="string">&quot;change&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_">load_redis_list</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//列表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">create_club_list</span>(<span class="params">redisContens</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> phone = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> html = <span class="string">&#x27;&lt;div class=&quot;product_box&quot;&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;div class=&quot;br&quot;&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;div class=&quot;product_link&quot;&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;div class=&quot;product_phc&quot;&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;img class=&quot;phc&quot; src=&quot;&quot; &gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;/div&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;span class=&quot;product_name&quot;&gt;&#x27;</span> + redisContens.<span class="property">id</span> + <span class="string">&#x27;&lt;/span&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;div class=&quot;product_link toto&quot;&gt;&#x27;</span> + redisContens.<span class="property">content</span> + <span class="string">&#x27;&lt;/div&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;div class=&quot;product_link toto&quot;&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;span&gt;&#x27;</span> + <span class="string">&quot;&quot;</span> + <span class="string">&#x27;&lt;/span&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;/div&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;div class=&quot;product_link toto&quot;&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;span&gt;&#x27;</span> + phone + <span class="string">&#x27;&lt;/span&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;div class=&quot;product_link toto&quot;&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;span&gt;&#x27;</span> + <span class="number">0</span> + <span class="string">&#x27;&lt;/span&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;div class=&quot;product_link toto product_operation&quot;&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;span onclick=&quot;edit_club(&#x27;</span> + <span class="number">0</span> + <span class="string">&#x27;)&quot;&gt;编辑&lt;/span&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;span onclick=&quot;edit_del(&#x27;</span> + <span class="number">0</span> + <span class="string">&#x27;)&quot;&gt;删除&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;/div&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加载列表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">load_redis_list</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = $(<span class="string">&quot;#name&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="title function_">getPath</span>() + <span class="string">&#x27;/redis/redis_list&#x27;</span>,</span><br><span class="line">        <span class="attr">async</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">data</span>: &#123;<span class="attr">name</span>: name, <span class="attr">page</span>: page, <span class="attr">pageSize</span>: rows&#125;,</span><br><span class="line">        <span class="attr">datatype</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.<span class="property">result</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                $(<span class="string">&quot;.product_length_number&quot;</span>).<span class="title function_">html</span>(data.<span class="property">data</span>.<span class="property">count</span>);</span><br><span class="line">                <span class="keyword">var</span> html = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">var</span> count = data.<span class="property">data</span>.<span class="property">count</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.<span class="property">data</span>.<span class="property">redisContents</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> redisContent = data.<span class="property">data</span>.<span class="property">redisContents</span>[i];</span><br><span class="line">                    html += <span class="title function_">create_club_list</span>(redisContent.<span class="property">rediscontent</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                $(<span class="string">&quot;.product_content&quot;</span>).<span class="title function_">html</span>(html);</span><br><span class="line">                <span class="comment">//这里是分页的插件</span></span><br><span class="line">                $(<span class="string">&#x27;#pagination&#x27;</span>).<span class="title function_">jqPaginator</span>(<span class="string">&#x27;option&#x27;</span>, &#123;</span><br><span class="line">                    <span class="attr">totalPages</span>: (<span class="title class_">Math</span>.<span class="title function_">ceil</span>(count / rows) &lt; <span class="number">1</span> ? <span class="number">1</span> : <span class="title class_">Math</span>.<span class="title function_">ceil</span>(count / rows)),</span><br><span class="line">                    <span class="attr">currentPage</span>: page</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">alert</span>(data.<span class="property">msg</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">&quot;.product_box:even&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;#e6e6e6&quot;</span>);<span class="comment">//隔行变色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是一个简单的请求接口，并根据返回数据动态生成<code>Dom</code>而已。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是一个简单的<code>redis</code>的应用。<br>redis的应用场景还非常的多，比如现在我所在做的一个项目就有用来处理短信验证码的业务场景，之后有时间可以写一个demo。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/crossoverJie/SSM.git">https://github.com/crossoverJie/SSM.git</a><br>GitHub地址：<a href="https://github.com/crossoverJie">https://github.com/crossoverJie</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(八)动态切换数据源</title>
    <url>/2017/01/05/SSM8/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1ba038a14a.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>在现在开发的过程中应该大多数朋友都有遇到过切换数据源的需求。比如现在常用的数据库读写分离，或者就是有两个数据库的情况，这些都需要用到切换数据源。</p>
</blockquote>
<h1 id="手动切换数据源"><a href="#手动切换数据源" class="headerlink" title="手动切换数据源"></a>手动切换数据源</h1><p>使用<code>Spring</code>的<code>AbstractRoutingDataSource</code>类来进行拓展多数据源。</p>
<p>该类就相当于一个<code>dataSource</code>的路由，用于根据<code>key</code>值来进行切换对应的<code>dataSource</code>。</p>
<p>下面简单来看下<code>AbstractRoutingDataSource</code>类的几段关键源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">	<span class="keyword">return</span> determineTargetDataSource().getConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">	<span class="keyword">return</span> determineTargetDataSource().getConnection(username, password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieve the current target DataSource. Determines the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #determineCurrentLookupKey() current lookup key&#125;, performs</span></span><br><span class="line"><span class="comment"> * a lookup in the &#123;<span class="doctag">@link</span> #setTargetDataSources targetDataSources&#125; map,</span></span><br><span class="line"><span class="comment"> * falls back to the specified</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #setDefaultTargetDataSource default target DataSource&#125; if necessary.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #determineCurrentLookupKey()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> DataSource <span class="title function_">determineTargetDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">	Assert.notNull(<span class="built_in">this</span>.resolvedDataSources, <span class="string">&quot;DataSource router not initialized&quot;</span>);</span><br><span class="line">	<span class="type">Object</span> <span class="variable">lookupKey</span> <span class="operator">=</span> determineCurrentLookupKey();</span><br><span class="line">	<span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="built_in">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line">	<span class="keyword">if</span> (dataSource == <span class="literal">null</span> &amp;&amp; (<span class="built_in">this</span>.lenientFallback || lookupKey == <span class="literal">null</span>)) &#123;</span><br><span class="line">		dataSource = <span class="built_in">this</span>.resolvedDefaultDataSource;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dataSource == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot determine target DataSource for lookup key [&quot;</span> + lookupKey + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine the current lookup key. This will typically be</span></span><br><span class="line"><span class="comment"> * implemented to check a thread-bound transaction context.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Allows for arbitrary keys. The returned key needs</span></span><br><span class="line"><span class="comment"> * to match the stored lookup key type, as resolved by the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #resolveSpecifiedLookupKey&#125; method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到其中获取链接的方法<code>getConnection()</code>调用的<code>determineTargetDataSource</code>则是关键方法。该方法用于返回我们使用的数据源。</p>
<span id="more"></span>

<p>其中呢又是<code>determineCurrentLookupKey()</code>方法来返回当前数据源的<code>key</code>值。<br>之后通过该key值在<code>resolvedDataSources</code>这个map中找到对应的<code>value</code>(该value就是数据源)。</p>
<p><code>resolvedDataSources</code>这个map则是在：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.targetDataSources == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Property &#x27;targetDataSources&#x27; is required&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">this</span>.resolvedDataSources = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object, DataSource&gt;(<span class="built_in">this</span>.targetDataSources.size());</span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : <span class="built_in">this</span>.targetDataSources.entrySet()) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">lookupKey</span> <span class="operator">=</span> resolveSpecifiedLookupKey(entry.getKey());</span><br><span class="line">		<span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> resolveSpecifiedDataSource(entry.getValue());</span><br><span class="line">		<span class="built_in">this</span>.resolvedDataSources.put(lookupKey, dataSource);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.defaultTargetDataSource != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="built_in">this</span>.resolvedDefaultDataSource = resolveSpecifiedDataSource(<span class="built_in">this</span>.defaultTargetDataSource);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法通过<code>targetDataSources</code>这个map来进行赋值的。<code>targetDataSources</code>则是我们在配置文件中进行赋值的，下面会讲到。</p>
<p>再来看看<code>determineCurrentLookupKey()</code>方法，从<code>protected</code>来修饰就可以看出是需要我们来进行重写的。</p>
<h2 id="DynamicDataSource-和-DataSourceHolder"><a href="#DynamicDataSource-和-DataSourceHolder" class="headerlink" title="DynamicDataSource 和 DataSourceHolder"></a>DynamicDataSource 和 DataSourceHolder</h2><p>于是我新增了<code>DynamicDataSource</code>类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crossoverJie.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenjiec</span></span><br><span class="line"><span class="comment"> *         Date: 2017/1/2 上午12:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceHolder.getDataSources();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，继承了<code>AbstractRoutingDataSource</code>类并重写了其中的<code>determineCurrentLookupKey()</code>方法。</p>
<p>这里直接用<code>DataSourceHolder</code>返回了一个数据源。</p>
<p><code>DataSourceHolder</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crossoverJie.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function:动态数据源</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenjiec</span></span><br><span class="line"><span class="comment"> *         Date: 2017/1/2 上午12:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; dataSources = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setDataSources</span><span class="params">(String dataSource)</span> &#123;</span><br><span class="line">        dataSources.set(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDataSources</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSources.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我使用了<code>ThreadLocal</code>来保存了数据源，关于<code>ThreadLocal</code>的知识点可以查看以下这篇文章：<br><a href="http://qifuguang.me/2015/09/02/%5BJava%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83%5D%E8%A7%A3%E5%AF%86ThreadLocal/">解密ThreadLocal</a></p>
<p>之后在<code>Spring</code>的配置文件中配置我们的数据源，就是上文讲到的<code>为targetDataSources赋值</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ssm1DataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库的驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.user&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置初始化大小、最小、最大 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置获取连接等待超时的时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWait&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;300000&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validationQuery&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SELECT &#x27;x&#x27;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnReturn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolPreparedStatementPerConnectionSize&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filters&quot;</span> <span class="attr">value</span>=<span class="string">&quot;stat&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ssm2DataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库的驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url2&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.user2&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password2&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置获取连接等待超时的时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWait&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;300000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validationQuery&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SELECT &#x27;x&#x27;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnReturn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolPreparedStatementPerConnectionSize&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filters&quot;</span> <span class="attr">value</span>=<span class="string">&quot;stat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crossoverJie.util.DynamicDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetDataSources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span> <span class="attr">key-type</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ssm1DataSource&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;ssm1DataSource&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ssm2DataSource&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;ssm2DataSource&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--默认数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultTargetDataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ssm1DataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里分别配置了两个数据源：<code>ssm1DataSource</code>和<code>ssm2DataSource</code>。<br>之后再通过<code>Spring</code>的依赖注入方式将两个数据源设置进<code>targetDataSources</code>。</p>
<p>接下来的用法相比大家也应该猜到了。</p>
<blockquote>
<p>就是在每次调用数据库之前我们都要先通过<code>DataSourceHolder</code>来设置当前的数据源。看下demo：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectByPrimaryKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    DataSourceHolder.setDataSources(Constants.DATASOURCE_TWO);</span><br><span class="line">    <span class="type">Datasource</span> <span class="variable">datasource</span> <span class="operator">=</span> dataSourceService.selectByPrimaryKey(<span class="number">7</span>);</span><br><span class="line">    System.out.println(JSON.toJSONString(datasource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详见我的单测。</p>
<p>使用起来也是非常简单。但是不知道大家注意到没有，这样的做法槽点很多：</p>
<ol>
<li>每次使用需要手动切换，总有一些人会忘记写(比如我)。</li>
<li>如果是后期需求变了，查询其他的表了还得一个个改回来。</li>
</ol>
<p>那有没有什么方法可以自动的帮我们切换呢？</p>
<p>肯定是有的，大家应该也想得到。就是利用<code>Spring</code>的<code>AOP</code>了。</p>
<h1 id="自动切换数据源"><a href="#自动切换数据源" class="headerlink" title="自动切换数据源"></a>自动切换数据源</h1><p>首先要定义好我们的切面类<code>DataSourceExchange</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crossoverJie.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function:拦截器方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenjiec</span></span><br><span class="line"><span class="comment"> *         Date: 2017/1/3 上午12:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceExchange</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint point)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取目标对象的类类型</span></span><br><span class="line">        Class&lt;?&gt; aClass = point.getTarget().getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取包名用于区分不同数据源</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">whichDataSource</span> <span class="operator">=</span> aClass.getName().substring(<span class="number">25</span>, aClass.getName().lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;ssmone&quot;</span>.equals(whichDataSource)) &#123;</span><br><span class="line">            DataSourceHolder.setDataSources(Constants.DATASOURCE_ONE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DataSourceHolder.setDataSources(Constants.DATASOURCE_TWO);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行后将数据源置为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        DataSourceHolder.setDataSources(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>逻辑也比较简单，就是在执行数据库操作之前做一个切面。</p>
<ul>
<li>通过<code>JoinPoint</code>对象获取目标对象。</li>
<li>在目标对象中获取包名来区分不同的数据源。</li>
<li>根据不同数据源来进行赋值。</li>
<li>执行完毕之后将数据源清空。</li>
</ul>
<p>关于一些<code>JoinPoint</code>的API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.aspectj.lang;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.SourceLocation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JoinPoint</span> &#123;</span><br><span class="line">    String <span class="title function_">toString</span><span class="params">()</span>;         <span class="comment">//连接点所在位置的相关信息</span></span><br><span class="line">    String <span class="title function_">toShortString</span><span class="params">()</span>;     <span class="comment">//连接点所在位置的简短相关信息</span></span><br><span class="line">    String <span class="title function_">toLongString</span><span class="params">()</span>;     <span class="comment">//连接点所在位置的全部相关信息</span></span><br><span class="line">    Object <span class="title function_">getThis</span><span class="params">()</span>;         <span class="comment">//返回AOP代理对象</span></span><br><span class="line">    Object <span class="title function_">getTarget</span><span class="params">()</span>;       <span class="comment">//返回目标对象</span></span><br><span class="line">    Object[] getArgs();       <span class="comment">//返回被通知方法参数列表</span></span><br><span class="line">    Signature <span class="title function_">getSignature</span><span class="params">()</span>;  <span class="comment">//返回当前连接点签名</span></span><br><span class="line">    SourceLocation <span class="title function_">getSourceLocation</span><span class="params">()</span>;<span class="comment">//返回连接点方法所在类文件中的位置</span></span><br><span class="line">    String <span class="title function_">getKind</span><span class="params">()</span>;        <span class="comment">//连接点类型</span></span><br><span class="line">    StaticPart <span class="title function_">getStaticPart</span><span class="params">()</span>; <span class="comment">//返回连接点静态部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了通过<code>包名</code>来区分不同数据源，我将目录结构稍微调整了下：<br><img src="http://img.blog.csdn.net/20170105010819866?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTg2NjE3OTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="2"></p>
<p>将两个不同的数据源的实现类放到不同的包中，这样今后如果还需要新增其他数据源也可以灵活的切换。</p>
<p>看下<code>Spring</code>的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSourceExchange&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crossoverJie.util.DataSourceExchange&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置切面拦截方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--将com.crossoverJie.service包下的所有select开头的方法加入拦截</span></span><br><span class="line"><span class="comment">    去掉select则加入所有方法</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;controllerMethodPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">    execution(* com.crossoverJie.service.*.select*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;selectMethodPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">    execution(* com.crossoverJie.dao..*Mapper.select*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;methodCacheInterceptor&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;controllerMethodPointcut&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--所有数据库操作的方法加入切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;dataSourceExchange&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;dataSourcePointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.crossoverJie.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;dataSourcePointcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;dataSourcePointcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是在我们上一篇整合<a href="http://crossoverjie.top/2016/12/18/SSM7/">redis缓存</a>的基础上进行修改的。<br>这样缓存和多数据源都满足了。</p>
<p>实际使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectByPrimaryKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Rediscontent</span> <span class="variable">rediscontent</span> <span class="operator">=</span> rediscontentService.selectByPrimaryKey(<span class="number">30</span>);</span><br><span class="line">    System.out.println(JSON.toJSONString(rediscontent));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/05/08/5cd1ba0707e96.jpg"></p>
<p>这样看起来就和使用一个数据源这样简单，再也不用关心切换的问题了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不过按照这样的写法是无法做到在一个事务里控制两个数据源的。这个我还在学习中，有相关经验的大牛不妨指点一下。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/crossoverJie/SSM.git">https://github.com/crossoverJie/SSM.git</a></p>
</blockquote>
<blockquote>
<p>个人博客地址：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
<blockquote>
<p>GitHub地址：<a href="https://github.com/crossoverJie">https://github.com/crossoverJie</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(九) 反射的实际应用 - 构建日志对象</title>
    <url>/2017/01/19/SSM9/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1b9ff04695.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相信做Java的童鞋或多或少都听过反射，这也应该是Java从入门到进阶的必经之路。</p>
<p>但是在我们的实际开发中直接使用它们的几率貌似还是比较少的，（<code>除了造轮子或者是Spring Mybatis这些框架外</code>）。</p>
<p>所以这里介绍一个在实际开发中还是小有用处的反射实例。</p>
<h1 id="传统日志"><a href="#传统日志" class="headerlink" title="传统日志"></a>传统日志</h1><p>有关反射的一些基本知识就不说了，可以自行<code>Google</code>，也可以看下<a href="http://crossoverjie.top/2016/05/10/java-reflect/">反射入门</a>。</p>
<p>日志相信大家都不陌生，在实际开发中一些比较敏感的数据表我们需要对它的每一次操作都记录下来。</p>
<p>先来看看传统的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertSelective</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Content</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Content</span>() ;</span><br><span class="line">    content.setContent(<span class="string">&quot;asdsf&quot;</span>);</span><br><span class="line">    content.setCreatedate(<span class="string">&quot;2016-12-09&quot;</span>);</span><br><span class="line">    contentService.insertSelective(content) ;</span><br><span class="line"></span><br><span class="line">    <span class="type">ContentLog</span> <span class="variable">log</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentLog</span>();</span><br><span class="line">    log.setContentid(content.getContentid());</span><br><span class="line">    log.setContent(<span class="string">&quot;asdsf&quot;</span>);</span><br><span class="line">    log.setCreatedate(<span class="string">&quot;2016-12-09&quot;</span>);</span><br><span class="line">    contentLogService.insertSelective(log);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常简单，就是在保存完数据表之后再把相同的数据保存到日志表中。</p>
<span id="more"></span>
<p>但是这样有以下几个问题：</p>
<ul>
<li>如果数据表的字段较多的话，比如几百个。那么日志表的<code>setter()</code>方法就得写几百次，还得是都写对的情况下。</li>
<li>如果哪天数据表的字段发生了增加，那么每个写日志的地方都得增加该字段，提高了维护的成本。</li>
</ul>
<p>针对以上的情况就得需要反射这个主角来解决了。</p>
<h1 id="利用反射构建日志"><a href="#利用反射构建日志" class="headerlink" title="利用反射构建日志"></a>利用反射构建日志</h1><p>我们先来先来看下使用反射之后对代码所带来的改变：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertSelective2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Content</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Content</span>();</span><br><span class="line">    content.setContent(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    content.setContentname(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    content.setCreatedate(<span class="string">&quot;2016-09-23&quot;</span>);</span><br><span class="line"></span><br><span class="line">    contentService.insertSelective(content);</span><br><span class="line"></span><br><span class="line">    <span class="type">ContentLog</span> <span class="variable">log</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentLog</span>();</span><br><span class="line">    CommonUtil.setLogValueModelToModel(content, log);</span><br><span class="line">    contentLogService.insertSelective(log);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的保存日志，不管多少字段，只需要三行代码即可解决。<br>而且就算之后字段发生改变写日志这段代码仍然不需要改动。</p>
<p>其实这里最主要的一个方法就是<code>CommonUtil.setLogValueModelToModel(content, log);</code></p>
<p>来看下是如何实现的;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成日志实体工具</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectFrom</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectTo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setLogValueModelToModel</span><span class="params">(Object objectFrom, Object objectTo)</span> &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; clazzFrom = objectFrom.getClass();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; clazzTo = objectTo.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method toSetMethod : clazzTo.getMethods()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">mName</span> <span class="operator">=</span> toSetMethod.getName();</span><br><span class="line">            <span class="keyword">if</span> (mName.startsWith(<span class="string">&quot;set&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//字段名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> mName.substring(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取from 值</span></span><br><span class="line">                Object value;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;LogId&quot;</span>.equals(field)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">Method</span> <span class="variable">fromGetMethod</span> <span class="operator">=</span> clazzFrom.getMethod(<span class="string">&quot;get&quot;</span> + field);</span><br><span class="line">                    value = fromGetMethod.invoke(objectFrom);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//设置值</span></span><br><span class="line">                    toSetMethod.invoke(objectTo, value);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>再使用之前我们首先需要构建好主的数据表，然后<code>new</code>一个日志表的对象。</p>
<p>在<code>setLogValueModelToModel()</code>方法中：</p>
<ul>
<li>分别获得数据表和日志表对象的类类型。</li>
<li>获取到日志对象的所有方法集合。</li>
<li>遍历该集合，并拿到该方法的名称。</li>
<li>只取其中set开头的方法，也就是set方法。因为我们需要在循环中为日志对象的每一个字段赋值。 </li>
<li>之后截取方法名称获得具体的字段名称。</li>
<li>用之前截取的字段名称，通过<code>getMethod()</code>方法返回数据表中的该字段的<code>getter</code>方法。</li>
<li>相当于执行了<code>String content = content.getContent();</code></li>
<li>执行该方法获得该字段具体的值。</li>
<li>利用当前循环的<code>setter</code>方法为日志对象的每一个字段赋值。</li>
<li>相当于执行了<code>log.setContent(&quot;asdsf&quot;);</code></li>
</ul>
<p>其中字段名称为<code>LogId</code>时跳出了当前循环，因为LogId是日志表的主键，是不需要赋值的。</p>
<p>当循环结束时，日志对象也就构建完成了。之后只需要保存到数据库中即可。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>反射其实是非常耗资源的，再使用过程中还是要慎用。<br>其中对method、field、constructor等对象做缓存也是很有必要的。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/crossoverJie/SSM.git">https://github.com/crossoverJie/SSM.git</a></p>
</blockquote>
<blockquote>
<p>个人博客地址：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
<blockquote>
<p>GitHub地址：<a href="https://github.com/crossoverJie">https://github.com/crossoverJie</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>让百度和google收录我们的网站</title>
    <url>/2016/05/19/baidu-google/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>花了几天时间终于把这个看似高大上的博客搞好了，但是发现只能通过在地址栏输入地址进行访问，这很明显和我装X装到底的性格，于是乎在查阅了嘟爷的博客，和我各种百度终于搞出来了。</p>
<hr>
<h1 id="让谷歌收录"><a href="#让谷歌收录" class="headerlink" title="让谷歌收录"></a>让谷歌收录</h1><p>让谷歌收录还是比较简单，首先我们肯定是要翻墙的(这个就不仔细说了，具体百度。)<br>由于我这里突然登不上google账号了，所以下次补充截图。同体来说就是以下步骤：</p>
<blockquote>
<ul>
<li>下载google的html验证文件放到网站的根目录，使google能够访问得到。</li>
<li>在谷歌站长工具里加上自己的站点地图。</li>
</ul>
</blockquote>
<span id="more"></span>

<hr>
<h1 id="创建站点地图"><a href="#创建站点地图" class="headerlink" title="创建站点地图"></a>创建站点地图</h1><p>站点地图是一种文件，可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎，以便更加智能的抓取你的网站信息。<br>首先我们要为Hexo安装谷歌和百度的插件(博主是用Hexo来搭建的博客)，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<p>在博客的根目录中的<code>_config.yml</code>文件中加入以下内容：<br><img src="http://i.imgur.com/CUrNUtM.png"><br>之后部署上去之后如果在地址栏后面加上站点地图如下的话表示部署成功：<br><img src="http://i.imgur.com/AAujKdL.png"><br><img src="http://i.imgur.com/4K6JvJ4.png"></p>
<hr>
<h1 id="让百度收录"><a href="#让百度收录" class="headerlink" title="让百度收录"></a>让百度收录</h1><p>有三种方式可以让百度收录我们的网站。<br>第一种：主动推送<br>我用Java写了一个小程序，可以手工的自己推送地址给百度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.crossoverjie.post;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLConnection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Post</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">					  </span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://data.zz.baidu.com/urls?site=crossoverjie.top&amp;token=1002EzhDReuy34dq&quot;</span>;<span class="comment">// 网站的服务器连接</span></span><br><span class="line">		String[] param = &#123; </span><br><span class="line">			<span class="comment">// 需要推送的网址</span></span><br><span class="line"><span class="comment">//			&quot;http://crossoverjie.top/tags&quot;,</span></span><br><span class="line"><span class="comment">//			&quot;http://crossoverjie.top/categories&quot;,</span></span><br><span class="line">			<span class="comment">//&quot;http://crossoverjie.top/about/&quot;</span></span><br><span class="line">			<span class="string">&quot;http://crossoverjie.top/2016/05/14/java-thread1&quot;</span></span><br><span class="line">			</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> Post(url, param);<span class="comment">// 执行推送方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;结果是&quot;</span> + json); <span class="comment">// 打印推送结果</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 百度链接实时推送</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> PostUrl</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> Parameters</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">Post</span><span class="params">(String PostUrl, String[] Parameters)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">null</span> == PostUrl || <span class="literal">null</span> == Parameters || Parameters.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 建立URL之间的连接</span></span><br><span class="line">			<span class="type">URLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(PostUrl).openConnection();</span><br><span class="line">			<span class="comment">// 设置通用的请求属性</span></span><br><span class="line">			conn.setRequestProperty(<span class="string">&quot;Host&quot;</span>, <span class="string">&quot;data.zz.baidu.com&quot;</span>);</span><br><span class="line">			conn.setRequestProperty(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;curl/7.12.1&quot;</span>);</span><br><span class="line">			conn.setRequestProperty(<span class="string">&quot;Content-Length&quot;</span>, <span class="string">&quot;83&quot;</span>);</span><br><span class="line">			conn.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 发送POST请求必须设置如下两行</span></span><br><span class="line">			conn.setDoInput(<span class="literal">true</span>);</span><br><span class="line">			conn.setDoOutput(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取conn对应的输出流</span></span><br><span class="line">			out = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(conn.getOutputStream());</span><br><span class="line">			<span class="comment">// 发送请求参数</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="keyword">for</span> (String s : Parameters) &#123;</span><br><span class="line">				param += s + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			out.print(param.trim());</span><br><span class="line">			<span class="comment">// 进行输出流的缓冲</span></span><br><span class="line">			out.flush();</span><br><span class="line">			<span class="comment">// 通过BufferedReader输入流来读取Url的响应</span></span><br><span class="line">			in = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(conn.getInputStream()));</span><br><span class="line">			String line;</span><br><span class="line">			<span class="keyword">while</span> ( (line = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">				result += line;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;发送post请求出现异常！&quot;</span> + e);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">					out.close();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">					in.close();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">				ex.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">结果是&#123;<span class="string">&quot;remain&quot;</span>:<span class="number">499</span>,<span class="string">&quot;success&quot;</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>remain</code>表示还有多少可以推送，我这里表示还有499条。<code>success</code>表示成功推送了多少条链接，我这里表示成功推送了一条链接。</p>
<p>第二种是主动推送，可以按照百度的教程进行配置：<br><img src="http://i.imgur.com/hDU8NPb.png"></p>
<p>第三种就是配置站点地图了，按照之前将的将站点地图安装到项目中，参照我的配置即可：<br><img src="http://i.imgur.com/20Sh5GR.png"><br>如果能像我这个一样状态正常，能获取到URL数量就表示成功了。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在整个过程中不是我黑百度，百度的效率真是太低了。我头一天在google提交上去第二天就能收到了，百度是我提交了大概一周多才给我收录进去，这当然肯定也和我的内容有关系。<br><img src="http://i.imgur.com/41EH6bE.png"><br><img src="http://i.imgur.com/cyVNJTg.png"><br><img src="http://i.imgur.com/L4q7lq1.png"><br><img src="http://i.imgur.com/mVnjUDa.png"></p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>baidu</tag>
        <tag>google</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized 关键字原理</title>
    <url>/2018/01/14/Synchronize/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1ba276f063.jpg"></p>
<p>众所周知 <code>synchronized</code> 关键字是解决并发问题常用解决方案，有以下三种使用方式:</p>
<ul>
<li>同步普通方法，锁的是当前对象。</li>
<li>同步静态方法，锁的是当前 <code>Class</code> 对象。</li>
<li>同步块，锁的是 <code>()</code> 中的对象。</li>
</ul>
<p>实现原理：<br><code>JVM</code> 是通过进入、退出对象监视器( <code>Monitor</code> )来实现对方法、同步块的同步的。</p>
<p>具体实现是在编译之后在同步方法调用前加入一个 <code>monitor.enter</code> 指令，在退出方法和异常处插入 <code>monitor.exit</code> 的指令。</p>
<p>其本质就是对一个对象监视器( <code>Monitor</code> )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。</p>
<p>而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 <code>monitor.exit</code> 之后才能尝试继续获取锁。</p>
<p>流程图如下:</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba2bbda92.jpg"></p>
<span id="more"></span>
<p>通过一段代码来演示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Synchronize.class)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Synchronize&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>javap -c Synchronize</code> 可以查看编译之后的具体信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class com.crossoverjie.synchronize.Synchronize &#123;</span><br><span class="line">  public com.crossoverjie.synchronize.Synchronize();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // class com/crossoverjie/synchronize/Synchronize</span><br><span class="line">       2: dup</span><br><span class="line">       3: astore_1</span><br><span class="line">       **4: monitorenter**</span><br><span class="line">       5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       8: ldc           #4                  // String Synchronize</span><br><span class="line">      10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      13: aload_1</span><br><span class="line">      **14: monitorexit**</span><br><span class="line">      15: goto          23</span><br><span class="line">      18: astore_2</span><br><span class="line">      19: aload_1</span><br><span class="line">      20: monitorexit</span><br><span class="line">      21: aload_2</span><br><span class="line">      22: athrow</span><br><span class="line">      23: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           5    15    18   any</span><br><span class="line">          18    21    18   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在同步块的入口和出口分别有 <code>monitorenter,monitorexit</code><br>指令。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p><code>synchronized</code>  很多都称之为重量锁，<code>JDK1.6</code> 中对 <code>synchronized</code> 进行了各种优化，为了能减少获取和释放锁带来的消耗引入了<code>偏向锁</code>和<code>轻量锁</code>。</p>
<h3 id="轻量锁"><a href="#轻量锁" class="headerlink" title="轻量锁"></a>轻量锁</h3><p>当代码进入同步块时，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(<code>Lock Record</code>)区域，同时将锁对象的对象头中 <code>Mark Word</code> 拷贝到锁记录中，再尝试使用 <code>CAS</code> 将 <code>Mark Word</code> 更新为指向锁记录的指针。</p>
<p>如果更新<strong>成功</strong>，当前线程就获得了锁。</p>
<p>如果更新<strong>失败</strong> <code>JVM</code> 会先检查锁对象的 <code>Mark Word</code> 是否指向当前线程的锁记录。</p>
<p>如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。</p>
<p>不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，<strong>轻量锁就会膨胀为重量锁</strong>。</p>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>轻量锁的解锁过程也是利用 <code>CAS</code> 来实现的，会尝试锁记录替换回锁对象的 <code>Mark Word</code> 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为<code>重量锁</code>)</p>
<p>轻量锁能提升性能的原因：</p>
<p>认为大多数锁在整个同步周期都不存在竞争，所以使用 <code>CAS</code> 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 <code>CAS</code> 的开销，甚至比重量锁更慢。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>为了进一步的降低获取锁的代价，<code>JDK1.6</code> 之后还引入了偏向锁。</p>
<p>偏向锁的特征是:锁不存在多线程竞争，并且应由一个线程多次获得锁。</p>
<p>当线程访问同步块时，会使用 <code>CAS</code> 将线程 ID 更新到锁对象的 <code>Mark Word</code> 中，如果更新成功则获得偏向锁，并且之后每次进入这个对象锁相关的同步块时都不需要再次获取锁了。</p>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 <code>Mark Word</code> 设置为无锁或者是轻量锁状态。</p>
<p>偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。可以使用 <code>-XX:-userBiasedLocking=false</code> 来关闭偏向锁，并默认进入轻量锁。</p>
<h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><h4 id="适应性自旋"><a href="#适应性自旋" class="headerlink" title="适应性自旋"></a>适应性自旋</h4><p>在使用 <code>CAS</code> 时，如果操作失败，<code>CAS</code> 会自旋再次尝试。由于自旋是需要消耗 <code>CPU</code> 资源的，所以如果长期自旋就白白浪费了 <code>CPU</code>。<code>JDK1.6</code>加入了适应性自旋:</p>
<blockquote>
<p>如果某个锁自旋很少成功获得，那么下一次就会减少自旋。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>synchronized 现在已经不像以前那么重了，拿 1.8 中的 ConcurrentHashMap 就可以看出，里面大量的使用了 synchronized 来进行同步。</p>
<h2 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h2><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>synchronize</tag>
      </tags>
  </entry>
  <entry>
    <title>科普-为自己的博客免费加上小绿锁</title>
    <url>/2017/05/07/https/</url>
    <content><![CDATA[<p><img src="https://ooo.0o0.ooo/2017/05/07/590edced5545e.jpg" alt="https.jpg"></p>
<p>在如今的<code>HTTPS</code>大当其道的情况下自己的博客要是还没有用上。作为互联网的螺丝钉(<code>码农</code>)岂不是很没面子。</p>
<h1 id="使用CLOUDFLARE"><a href="#使用CLOUDFLARE" class="headerlink" title="使用CLOUDFLARE"></a>使用CLOUDFLARE</h1><p>这里使用<a href="http://www.cloudflare.com/">CLOUDFLARE</a>来提供<code>HTTPS</code>服务。</p>
<ul>
<li>在其官网进行注册，按照提示添加好自己的域名即可。</li>
<li>之后需要在自己域名的提供商处修改<code>DNS服务器</code>，我是在万网购买的修改后如下图：<br><img src="https://ooo.0o0.ooo/2017/05/07/590edd1a4cfd0.jpg" alt="1.jpg"><br>其中的<code>DNS服务器地址</code>由<code>CLOUDFLARE</code>是提供的。<br>修改完成之后通常需要等待一段时间才能生效。</li>
<li>接着在<code>CLOUDFLARE</code>配置<code>DNS</code>解析：<br><img src="https://ooo.0o0.ooo/2017/05/07/590edd4913c2b.jpg" alt="DNS解析.jpg"><br>点击<code>CLOUDFLARE</code>顶部的<code>DNS</code>进行如我上图中的配置，和之前的配置没有什么区别。</li>
</ul>
<p>等待一段时间之后发现使用<code>HTTP</code>,<code>HTTPS</code>都能访问，但是最好还是能在访问<code>HTTP</code>的时候能强制跳转到<code>HTTPS</code>.</p>
<ul>
<li>在<code>CLOUDFLARE</code>菜单栏点击<code>page-rules</code>之后新建一个<code>page rule</code>：<br><img src="https://ooo.0o0.ooo/2017/05/07/590edd73a9f9d.jpg" alt="强制https.jpg"><br>这样整个网站的请求都会强制到请求到<code>HTTPS</code>.</li>
</ul>
<span id="more"></span>

<h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><p>由于我才用的是<code>Hexo</code>中的<code>Next</code>主题，其中配置了<code>CNZZ</code>站长统计。其中配置的<code>CNZZ</code>统计JS是才用的<code>HTTP</code>。导致在首页的时候<code>chrome</code>一直提示感叹号。<br>修改站点<code>themes/next/layout/_scripts/third-party/analytics</code>目录下的<code>cnzz-analytics.swig</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.cnzz_siteid %&#125;</span><br><span class="line"></span><br><span class="line">  &lt;div style=&quot;display: none;&quot;&gt;</span><br><span class="line">    &lt;script src=&quot;https://s6.cnzz.com/stat.php?id=&#123;&#123; theme.cnzz_siteid &#125;&#125;&amp;web_id=&#123;&#123; theme.cnzz_siteid &#125;&#125;&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>之后再进行构建的时候就会使用<code>HTTPS</code>.</p>
<blockquote>
<p>值得注意一点的是之后文章中所使用的图片都要用<code>HTTPS</code>的地址了，不然<code>chrome</code>会提示感叹号。</p>
</blockquote>
<blockquote>
<p>个人博客地址：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
<blockquote>
<p>GitHub地址：<a href="https://github.com/crossoverJie">https://github.com/crossoverJie</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>科普</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java笔记（一）Java的反射机制</title>
    <url>/2016/05/10/java-reflect/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java反射机制指的是在java运行过程中，对于任意的类都可以知道他的所有属性以及方法，对于任意一个对象都可以任意的调用他的属性和方法，这种动态获取对象信息和动态调用对象方法的功能称为java反射机制，但是反射使用不当会造成很高的成本。</p>
<h1 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h1><hr>
<h2 id="反射获取类名称"><a href="#反射获取类名称" class="headerlink" title="反射获取类名称"></a>反射获取类名称</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.crosssoverjie.study;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;Reflect&gt; c1 = Reflect.class;</span><br><span class="line">        System.out.println(c1.getName());</span><br><span class="line">        </span><br><span class="line">        <span class="type">Reflect</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reflect</span>() ;</span><br><span class="line">        Class&lt;Reflect&gt; c2 = (Class&lt;Reflect&gt;) r1.getClass() ;</span><br><span class="line">        System.out.println(c2.getName());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;Reflect&gt; c3 = (Class&lt;Reflect&gt;) Class.forName(<span class="string">&quot;top.crosssoverjie.study.Reflect&quot;</span>);</span><br><span class="line">            System.out.println(c3.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">top.crosssoverjie.study.Reflect</span><br><span class="line">top.crosssoverjie.study.Reflect</span><br><span class="line">top.crosssoverjie.study.Reflect  </span><br></pre></td></tr></table></figure>

<p>以上的 c1,c2,c3是完全一样的，他们都有一个统一的名称：叫做Reflect类的类类型。</p>
<hr>
<h1 id="反射的用处"><a href="#反射的用处" class="headerlink" title="反射的用处"></a>反射的用处</h1><h2 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Method <span class="title function_">getDeclaredMethod</span><span class="params">(String name,Class&lt;?&gt;...parameterTypes)</span><span class="comment">//得到该类的所有方法，但是不包括父类的方法。</span></span><br><span class="line"><span class="keyword">public</span> Method <span class="title function_">getMethod</span><span class="params">(String name,Class&lt;?&gt;...parameterTypes)</span><span class="comment">//获得该类的所有public方法，包括父类的。</span></span><br></pre></td></tr></table></figure>

<p>通过反射获取成员方法调用的实例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.crosssoverjie.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name=<span class="string">&quot;crossover&quot;</span> ;</span><br><span class="line">	<span class="keyword">private</span> String msg ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, String msg)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.msg = msg;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;的描述是&quot;</span>+msg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String name ,String msg)</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;说：&quot;</span>+msg);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> msg;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.msg = msg;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//首先获取类类型</span></span><br><span class="line">			<span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;top.crosssoverjie.study.Person&quot;</span>) ;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//通过newInstance()方法生成一个实例</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> c1.newInstance() ;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//获取该类的say方法</span></span><br><span class="line">			<span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> c1.getMethod(<span class="string">&quot;say&quot;</span>, String.class,String.class) ;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//通过invoke方法调用该方法</span></span><br><span class="line"><span class="comment">//			m1.invoke(o1, &quot;张三&quot;,&quot;你好啊&quot;) ;</span></span><br><span class="line">			</span><br><span class="line">			Method[] methods = c1.getDeclaredMethods() ;</span><br><span class="line"><span class="comment">//			for(Method m : methods)&#123;</span></span><br><span class="line"><span class="comment">//				System.out.println(m.getName());</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line">			</span><br><span class="line">			Method[] methods2 = c1.getMethods() ;</span><br><span class="line">			<span class="keyword">for</span> (Method method : methods2) &#123;</span><br><span class="line">				System.out.println(method.getName());</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">张三说：你好啊</span><br></pre></td></tr></table></figure>

<p>所以我们只要知道类的全限定名就可以任意的调用里面的方法。</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] methods = c1.getDeclaredMethods() ;</span><br><span class="line"><span class="keyword">for</span>(Method m : methods)&#123;</span><br><span class="line">	System.out.println(m.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">getName</span><br><span class="line">setName</span><br><span class="line">say</span><br><span class="line">getMsg</span><br><span class="line">setMsg</span><br></pre></td></tr></table></figure>

<p>使用的还是之前那个Person类，所以这里只写了关键代码。这里输出的是Person的所有public方法。</p>
<p>如果我们调用<code>getMethods()</code>方法会是什么结果呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] methods2 = c1.getMethods() ;</span><br><span class="line"><span class="keyword">for</span> (Method method : methods2) &#123;</span><br><span class="line">	System.out.println(method.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">getName</span><br><span class="line">setName</span><br><span class="line">say</span><br><span class="line">getMsg</span><br><span class="line">setMsg</span><br><span class="line">wait</span><br><span class="line">wait</span><br><span class="line">wait</span><br><span class="line">hashCode</span><br><span class="line">getClass</span><br><span class="line">equals</span><br><span class="line">toString</span><br><span class="line">notify</span><br><span class="line">notifyAll</span><br></pre></td></tr></table></figure>

<p>这时我们会发现这里输出的结果会比刚才多得多，这时因为<code>getMethods()</code>方法返回的是包括父类的所有方法。</p>
<hr>
<h2 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h2><p>我们还可以通过反射来获取类包括父类的成员变量，主要方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Field <span class="title function_">getDeclaredFiled</span><span class="params">(String name)</span><span class="comment">//获得该类所有的成员变量，但不包括父类的。</span></span><br><span class="line"><span class="keyword">public</span> Filed <span class="title function_">getFiled</span><span class="params">(String name)</span><span class="comment">//获得该类的所有的public变量，包括其父类的。</span></span><br></pre></td></tr></table></figure>

<p>还是按照之前例子中的Person类举例，他具有两个成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String name=<span class="string">&quot;crossover&quot;</span> ;</span><br><span class="line"><span class="keyword">private</span> String msg ;</span><br></pre></td></tr></table></figure>
<p>我们可以通过以下方法来获取其中的成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;top.crosssoverjie.study.Person&quot;</span>) ;</span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);<span class="comment">//获取该类所有的成员属性</span></span><br></pre></td></tr></table></figure>

<p>通过以下例子可以获取指定对象上此field的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.crosssoverjie.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflect</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;top.crosssoverjie.study.Person&quot;</span>);</span><br><span class="line">			<span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> c1.getDeclaredField(<span class="string">&quot;name&quot;</span>) ;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> c1.newInstance() ;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 由于Person类中的name变量是private修饰的，</span></span><br><span class="line"><span class="comment">			 * 所以需要手动开启允许访问，是public修饰的就不需要设置了</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">			<span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> field.get(o1) ;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace() ;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		Class&lt;Reflect&gt; c1 = Reflect.class;</span></span><br><span class="line"><span class="comment">//		System.out.println(c1.getName());</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		Reflect r1 = new Reflect() ;</span></span><br><span class="line"><span class="comment">//		Class&lt;Reflect&gt; c2 = (Class&lt;Reflect&gt;) r1.getClass() ;</span></span><br><span class="line"><span class="comment">//		System.out.println(c2.getName());</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		try &#123;</span></span><br><span class="line"><span class="comment">//			Class&lt;Reflect&gt; c3 = (Class&lt;Reflect&gt;) Class.forName(&quot;top.crosssoverjie.study.Reflect&quot;);</span></span><br><span class="line"><span class="comment">//			System.out.println(c3.getName());</span></span><br><span class="line"><span class="comment">//		&#125; catch (ClassNotFoundException e) &#123;</span></span><br><span class="line"><span class="comment">//			e.printStackTrace();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">crossover</span><br></pre></td></tr></table></figure>

<p>我们也可以通过方法<code>getDeclaredFieds()</code>方法来获取所有的成员变量，返回是是一个<code>Field[]</code>数组，只需要遍历这个数组即可获所有的成员变量。例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] fields = c1.getDeclaredFields() ;</span><br><span class="line"><span class="keyword">for</span>(Field f :fields)&#123;</span><br><span class="line">	System.out.println(f.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name</span><br><span class="line">msg</span><br></pre></td></tr></table></figure>

<h2 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h2><p>可以通过以下两个方法来获取构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor <span class="title function_">getDeclaredConstructor</span><span class="params">(Class&lt;?&gt;...parameterTypes)</span><span class="comment">//获取该类的所有构造方法，不包括父类的。</span></span><br><span class="line"><span class="keyword">public</span> Constructor <span class="title function_">getConstructor</span><span class="params">(Class&lt;?&gt;...parameterTypes)</span><span class="comment">//获取该类的所有public修饰的构造方法，包括父类的。</span></span><br></pre></td></tr></table></figure>
<p>在之前的Person类中有以下的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, String msg)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.msg = msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过以下方法来获取Person类的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">dc1</span> <span class="operator">=</span> c1.getDeclaredConstructor(String.class,String.class) ;</span><br></pre></td></tr></table></figure>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">dc1</span> <span class="operator">=</span> c1.getDeclaredConstructor(String.class,String.class) ;</span><br><span class="line">dc1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">dc1.newInstance(<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;很帅&quot;</span>) ;</span><br></pre></td></tr></table></figure>
<p><code>dc1.newInstance(&quot;小明&quot;,&quot;很帅&quot;);</code>方法调用了Person类中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, String msg)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.msg = msg;</span><br><span class="line">	System.out.println(name+<span class="string">&quot;的描述是&quot;</span>+msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造方法，如果不传参数的话，那么调用的就是无参的构造方法。输出结果为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">小明的描述是很帅</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="通过反射了解集合泛型的本质"><a href="#通过反射了解集合泛型的本质" class="headerlink" title="通过反射了解集合泛型的本质"></a>通过反射了解集合泛型的本质</h2><p>通过以下例子程序可以看出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.crosssoverjie.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericEssence</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//声明两个list，一个有泛型，一个没有泛型</span></span><br><span class="line">		<span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>() ;</span><br><span class="line">		List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() ;</span><br><span class="line">		</span><br><span class="line">		list2.add(<span class="string">&quot;你好&quot;</span>) ;</span><br><span class="line"><span class="comment">//		list2.add(11) ;加上泛型之后在编译期间只能添加String，不然会报错。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;list2的长度是：&quot;</span>+list2.size());</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> list1.getClass();</span><br><span class="line">		<span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> list2.getClass() ;</span><br><span class="line">		System.out.print(<span class="string">&quot;c1,c2是否相等:&quot;</span>);</span><br><span class="line">		System.out.println(c1==c2);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//通过反射绕过编译器动态调用add方法，可能否加入非String类型的元素</span></span><br><span class="line">			<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> c2.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class) ;</span><br><span class="line">			method.invoke(list2, <span class="number">123</span>) ;<span class="comment">//在这里加入int类型，在上面如果加入int会出现编译报错。</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//list2的长度增加了，说明添加成功了</span></span><br><span class="line">			System.out.println(<span class="string">&quot;现在list2的长度是:&quot;</span>+list2.size());</span><br><span class="line">			</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 所以可以看出，泛型只是在编译期间起作用，在经过编译进入运行期间是不起作用的。</span></span><br><span class="line"><span class="comment">			 * 就算是不是泛型要求的类型也是可以插入的。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace() ;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以可以看出，泛型只是在编译期间起作用，在经过编译进入运行期间是不起作用的。就算是不是泛型要求的类型也是可以插入的。</p>
</blockquote>
<h2 id="反射知识点"><a href="#反射知识点" class="headerlink" title="反射知识点"></a>反射知识点</h2><p><img src="http://i.imgur.com/b0yfRh9.png" alt="泛型"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>泛型的应用比较多：</p>
<ul>
<li>spring的IOC&#x2F;DI。 </li>
<li>JDBC中的中的加载驱动</li>
</ul>
</blockquote>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.csdn.net/liujiahan629629/article/details/18013523" title="java中的反射机制">java中的反射机制</a></li>
<li><a href="http://zhidao.baidu.com/question/141970313.html" title="反射机制是什么">反射机制是什么</a></li>
</ul>
]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程（一）多线程基础</title>
    <url>/2016/05/14/java-thread1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要讲解java多线程的基础，以及一些常用方法。关于线程同步、ExecutorService框架我会放到后续的文章进行讲解。</p>
<hr>
<h1 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程简单的来说就是在内存中运行的应用程序，一个进程可以启动多个线程。<br>比如在windows中一个运行EXE文件就是一个进程。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>同一个线程中的进程共用相同的地址空间，同时共享进程所拥有的内存和其他资源。</p>
<span id="more"></span>

<hr>
<h1 id="线程Demo-继承Thread类"><a href="#线程Demo-继承Thread类" class="headerlink" title="线程Demo-继承Thread类"></a>线程Demo-继承Thread类</h1><p>首先我们我们继承<code>java.lang.Thread</code>类来创建线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.crosssoverjie.study.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;主线程ID是：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">		my.start() ;</span><br><span class="line">		</span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">my2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;线程2&quot;</span>) ;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这里直接调用my2的run()方法。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		my2.run() ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;名字：&quot;</span> + name + <span class="string">&quot;的线程ID是=&quot;</span></span><br><span class="line">				+ Thread.currentThread().getId());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">主线程ID是：<span class="number">1</span></span><br><span class="line">名字：线程<span class="number">2</span>的线程ID是=<span class="number">1</span></span><br><span class="line">名字：线程<span class="number">1</span>的线程ID是=<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>由输出结果我们可以得出以下结论：</p>
<blockquote>
<ul>
<li>my和my2的线程ID不相同，my2和主线程ID相同。说明直接调用<code>run()</code>方法不会创建新的线程，而是在主线程中直接调用的<code>run()</code>方法,和普通的方法调用没有区别。</li>
<li>虽然my的<code>start()</code>方法是在my2的<code>run()</code>方法之前调用，但是却是后输出内容，说明新建的线程并不会影响主线程的执行。</li>
</ul>
</blockquote>
<hr>
<h1 id="线程Demo-实现Runnable接口"><a href="#线程Demo-实现Runnable接口" class="headerlink" title="线程Demo-实现Runnable接口"></a>线程Demo-实现Runnable接口</h1><p>除了继承<code>java.lang.Thread</code>类之外，我们还可以实现<code>java.lang.Runnable</code>接口来创建线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.crosssoverjie.study.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRunnable</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;主线程的线程ID是&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">		<span class="type">MyThread2</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>(<span class="string">&quot;线程1&quot;</span>) ;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my) ;</span><br><span class="line">		t.start() ;</span><br><span class="line">		</span><br><span class="line">		<span class="type">MyThread2</span> <span class="variable">my2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>(<span class="string">&quot;线程2&quot;</span>) ;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my2) ;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 方法调用，并不会创建线程，依然是主线程</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		t2.run() ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name ;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyThread2</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;线程&quot;</span>+name+<span class="string">&quot;的线程ID是&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">主线程的线程ID是<span class="number">1</span></span><br><span class="line">线程线程<span class="number">2</span>的线程ID是<span class="number">1</span></span><br><span class="line">线程线程<span class="number">1</span>的线程ID是<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>notes:</p>
<blockquote>
<ul>
<li>实现Runnable的方式需要将实现Runnable接口的类作为参数传递给Thread，然后通过Thread类调用<code>Start()</code>方法来创建线程。</li>
<li>这两种方式都可以来创建线程，至于选择哪一种要看自己的需求。直接继承Thread类的话代码要简洁一些，但是由于java只支持单继承，所以如果要继承其他类的同时需要实现线程那就只能实现Runnable接口了，这里更推荐实现Runnable接口。</li>
</ul>
</blockquote>
<p>实际上如果我们查看Thread类的源码我们会发现Thread是实现了Runnable接口的：<br><img src="http://i.imgur.com/FLsghcS.png" alt="Thread源码"></p>
<hr>
<h1 id="线程中常用的方法"><a href="#线程中常用的方法" class="headerlink" title="线程中常用的方法"></a>线程中常用的方法</h1><table>
<thead>
<tr>
<th>序号</th>
<th align="left">方法</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="left"><code>public void start()</code></td>
<td align="left">使该线程执行，java虚拟机会调用该线程的<code>run()</code>方法。</td>
</tr>
<tr>
<td>2</td>
<td align="left"><code>public final void setName(String name)</code></td>
<td align="left">修改线程名称。</td>
</tr>
<tr>
<td>3</td>
<td align="left"><code>public final void setPriority(int privority)</code></td>
<td align="left">修改线程的优先级。</td>
</tr>
<tr>
<td>4</td>
<td align="left"><code>public final void setDaemon(false on)</code></td>
<td align="left">将该线程标记为守护线程或用户线程，当正在运行线程都是守护线程时，java虚拟机退出，该方法必须在启动线程前调用。</td>
</tr>
<tr>
<td>5</td>
<td align="left"><code>public final void join(long mills)</code></td>
<td align="left">等待该线程的终止时间最长为mills毫秒。</td>
</tr>
<tr>
<td>6</td>
<td align="left"><code>public void interrupt()</code></td>
<td align="left">中断线程。</td>
</tr>
<tr>
<td>7</td>
<td align="left"><code>public static boolean isAlive()</code></td>
<td align="left">测试线程是否处于活动状态。如果该线程已经启动尚未终止，则为活动状态。</td>
</tr>
<tr>
<td>8</td>
<td align="left"><code>public static void yield()</code></td>
<td align="left">暂停当前线程执行的对象，并执行其他线程。</td>
</tr>
<tr>
<td>9</td>
<td align="left"><code>public static void sleep(long mills)</code></td>
<td align="left">在指定毫秒数内，让当前执行的线程休眠(暂停)。</td>
</tr>
<tr>
<td>10</td>
<td align="left"><code>public static Thread currentThread()</code></td>
<td align="left">返回当前线程的引用。</td>
</tr>
</tbody></table>
<h2 id="方法详解-public-static-void-sleep-long-mills"><a href="#方法详解-public-static-void-sleep-long-mills" class="headerlink" title="方法详解- public static void sleep(long mills)"></a>方法详解- <code>public static void sleep(long mills)</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.crosssoverjie.study.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSleep</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Object</span> <span class="variable">ob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>() ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">TestSleep</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestSleep</span>() ;</span><br><span class="line">		<span class="type">MyThread3</span> <span class="variable">thread1</span> <span class="operator">=</span> t.<span class="keyword">new</span> <span class="title class_">MyThread3</span>() ;</span><br><span class="line">		<span class="type">MyThread3</span> <span class="variable">thread2</span> <span class="operator">=</span> t.<span class="keyword">new</span> <span class="title class_">MyThread3</span>() ;</span><br><span class="line">		thread1.start() ;</span><br><span class="line">		thread2.start() ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">MyThread3</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (ob) &#123;</span><br><span class="line">				i++ ;</span><br><span class="line">				System.out.println(<span class="string">&quot;i的值：&quot;</span>+i);</span><br><span class="line">				System.out.println(<span class="string">&quot;线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;进入休眠状态&quot;</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.currentThread().sleep(<span class="number">1000</span>) ;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;休眠结束&quot;</span>);</span><br><span class="line">				i++;</span><br><span class="line">				System.out.println(<span class="string">&quot;i的值&gt;：&quot;</span>+i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i的值：<span class="number">11</span></span><br><span class="line">线程：Thread-<span class="number">0</span>进入休眠状态</span><br><span class="line">线程：Thread-<span class="number">0</span>休眠结束</span><br><span class="line">i的值&gt;：<span class="number">12</span></span><br><span class="line">i的值：<span class="number">13</span></span><br><span class="line">线程：Thread-<span class="number">1</span>进入休眠状态</span><br><span class="line">线程：Thread-<span class="number">1</span>休眠结束</span><br><span class="line">i的值&gt;：<span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>由输出结果我们可以得出：</p>
<blockquote>
<ul>
<li>当Thread0进入休眠状态时，Thread1并没有继续执行，而是等待Thread0休眠结束释放了对象锁，Thread1才继续执行。<br>当调用<code>sleep()</code>方法时，必须捕获异常或者向上层抛出异常。当线程休眠时间满时，并不一定会马上执行，因为此时有可能CPU正在执行其他的任务，所以调用了<code>sleep()</code>方法相当于线程进入了阻塞状态。</li>
</ul>
</blockquote>
<h2 id="方法详解-public-static-void-yield"><a href="#方法详解-public-static-void-yield" class="headerlink" title="方法详解- public static void yield()"></a>方法详解- <code>public static void yield()</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.crosssoverjie.study.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Testyield</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">MyThread4</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread4</span>() ;</span><br><span class="line">		my.start() ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread4</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">long</span> <span class="variable">open</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="type">int</span> count= <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">			count= count+(i+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//			Thread.yield() ;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;用时：&quot;</span>+(end-open)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:<br><code>用时：1毫秒</code><br>如果将 Thread.yield()注释取消掉，输出结果:<br><code>用时：116毫秒</code></p>
<blockquote>
<ul>
<li>调用<code>yield()</code>方法是为了让当前线程交出CPU权限，让CPU去执行其他线程。它和<code>sleep()</code>方法类似同样是不会释放锁。但是<code>yield()</code>不能控制具体的交出CUP的时间。并且它只能让相同优先级的线程获得CPU执行时间的机会。</li>
<li>调用<code>yield()</code>方法不会让线程进入阻塞状态，而是进入就绪状态，它只需要等待重新获取CPU的时间，这一点和<code>sleep()</code>方法是不一样的。</li>
</ul>
</blockquote>
<h2 id="方法详解-public-final-void-join"><a href="#方法详解-public-final-void-join" class="headerlink" title="方法详解- public final void join()"></a>方法详解- <code>public final void join()</code></h2><p>在很多情况下我们需要在子线程中执行大量的耗时任务，但是我们主线程又必须得等待子线程执行完毕之后才能结束，这就需要用到 <code>join()</code>方法了。<code>join()</code>方法的作用是等待线程对象销毁，如果子线程执行了这个方法，那么主线程就要等待子线程执行完毕之后才会销毁，请看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.crosssoverjie.study.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Testjoin</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">MyThread5</span>(<span class="string">&quot;t1&quot;</span>).start() ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">				<span class="type">MyThread5</span> <span class="variable">my</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">MyThread5</span>(<span class="string">&quot;t2&quot;</span>) ;</span><br><span class="line">				my.start() ;</span><br><span class="line">				my.join() ;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;main当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread5</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyThread5</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main当前线程：main <span class="number">0</span></span><br><span class="line">当前线程：t1 <span class="number">0</span></span><br><span class="line">当前线程：t1 <span class="number">1</span></span><br><span class="line">main当前线程：main <span class="number">1</span></span><br><span class="line">当前线程：t1 <span class="number">2</span></span><br><span class="line">main当前线程：main <span class="number">2</span></span><br><span class="line">当前线程：t1 <span class="number">3</span></span><br><span class="line">main当前线程：main <span class="number">3</span></span><br><span class="line">当前线程：t1 <span class="number">4</span></span><br><span class="line">main当前线程：main <span class="number">4</span></span><br><span class="line">当前线程：t2 <span class="number">0</span></span><br><span class="line">当前线程：t2 <span class="number">1</span></span><br><span class="line">当前线程：t2 <span class="number">2</span></span><br><span class="line">当前线程：t2 <span class="number">3</span></span><br><span class="line">当前线程：t2 <span class="number">4</span></span><br><span class="line">main当前线程：main <span class="number">5</span></span><br><span class="line">main当前线程：main <span class="number">6</span></span><br><span class="line">main当前线程：main <span class="number">7</span></span><br><span class="line">main当前线程：main <span class="number">8</span></span><br><span class="line">main当前线程：main <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>如果我们把<code>join()</code>方法注释掉之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main当前线程：main <span class="number">0</span></span><br><span class="line">当前线程：t1 <span class="number">0</span></span><br><span class="line">main当前线程：main <span class="number">1</span></span><br><span class="line">当前线程：t1 <span class="number">1</span></span><br><span class="line">main当前线程：main <span class="number">2</span></span><br><span class="line">当前线程：t1 <span class="number">2</span></span><br><span class="line">main当前线程：main <span class="number">3</span></span><br><span class="line">当前线程：t1 <span class="number">3</span></span><br><span class="line">main当前线程：main <span class="number">4</span></span><br><span class="line">当前线程：t1 <span class="number">4</span></span><br><span class="line">main当前线程：main <span class="number">5</span></span><br><span class="line">main当前线程：main <span class="number">6</span></span><br><span class="line">main当前线程：main <span class="number">7</span></span><br><span class="line">main当前线程：main <span class="number">8</span></span><br><span class="line">main当前线程：main <span class="number">9</span></span><br><span class="line">当前线程：t2 <span class="number">0</span></span><br><span class="line">当前线程：t2 <span class="number">1</span></span><br><span class="line">当前线程：t2 <span class="number">2</span></span><br><span class="line">当前线程：t2 <span class="number">3</span></span><br><span class="line">当前线程：t2 <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>由上我们可以得出以下结论：</p>
<blockquote>
<ul>
<li>在使用了<code>join()</code>方法之后主线程会等待子线程结束之后才会结束。</li>
</ul>
</blockquote>
<h2 id="方法详解-setDaemon-boolean-on-getDaemon"><a href="#方法详解-setDaemon-boolean-on-getDaemon" class="headerlink" title="方法详解- setDaemon(boolean on),getDaemon()"></a>方法详解- <code>setDaemon(boolean on)</code>,<code>getDaemon()</code></h2><p>用来设置是否为守护线程和判断是否为守护线程。<br>notes：</p>
<blockquote>
<ul>
<li>守护线程依赖于创建他的线程，而用户线程则不需要。如果在<code>main()</code>方法中创建了一个守护线程，那么当main方法执行完毕之后守护线程也会关闭。而用户线程则不会，在JVM中垃圾收集器的线程就是守护线程。</li>
</ul>
</blockquote>
<hr>
<h1 id="优雅的终止线程"><a href="#优雅的终止线程" class="headerlink" title="优雅的终止线程"></a>优雅的终止线程</h1><p>有三种方法可以终止线程，如下：</p>
<ol>
<li>使用退出标识，使线程正常的退出，也就是当<code>run()</code>方法完成后线程终止。</li>
<li><em>使用<code>stop()</code>方法强行关闭，这个方法现在已经被废弃，不推荐使用</em></li>
<li>使用<code>interrupt()</code>方法终止线程。</li>
</ol>
<p>具体的实现代码我将在下一篇博文中将到。。</p>
<h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><p>在操作系统中线程是分优先级的，优先级高的线程CPU将会提供更多的资源，在java中我们可以通过<code>setPriority(int newPriority)</code>方法来更改线程的优先级。<br>在java中分为1~10这个十个优先级，设置不在这个范围内的优先级将会抛出<code>IllegalArgumentException</code>异常。<br>java中有三个预设好的优先级：</p>
<blockquote>
<ul>
<li><code>public final static int MIN_PRIORITY = 1;</code></li>
<li><code>public final static int NORM_PRIORITY = 5;</code></li>
<li><code>public final static int MAX_PRIORITY = 10;</code></li>
</ul>
</blockquote>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<ul>
<li><a href="http://blog.csdn.net/anhuidelinger/article/details/11746365">如何终止线程</a></li>
<li><a href="http://www.mamicode.com/info-detail-517008.html">java多线程学习</a></li>
</ul>
</blockquote>
<h1 id="java多线程思维图"><a href="#java多线程思维图" class="headerlink" title="java多线程思维图"></a>java多线程思维图</h1><p><img src="http://i.imgur.com/PCfshMD.png"></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是我总结的java多线程基础知识，后续会补充线程关闭、线程状态、线程同步和有返回结果的多线程。</p>
]]></content>
      <categories>
        <category>java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>Runnable</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程（二）有返回值的多线程</title>
    <url>/2016/05/27/java-thread2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前我们使用多线程要么是继承<code>Thread</code>类，要么是实现<code>Runnable</code>接口，然后重写一下<code>run()</code>方法即可。<br>但是只有的话如果有死锁、对共享资源的访问和随时监控线程状态就不行了，于是在Java5之后就有了Callable接口。</p>
<hr>
<h1 id="简单的实现有返回值的线程"><a href="#简单的实现有返回值的线程" class="headerlink" title="简单的实现有返回值的线程"></a>简单的实现有返回值的线程</h1><p>代码如下：<br><code>CallableFuture</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.crosssoverjie.study.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableFuture</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建一个线程池</span></span><br><span class="line">		<span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>) ;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建三个有返回值的任务</span></span><br><span class="line">		<span class="type">CallableTest2</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableTest2</span>(<span class="string">&quot;线程1&quot;</span>) ;</span><br><span class="line">		<span class="type">CallableTest2</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableTest2</span>(<span class="string">&quot;线程2&quot;</span>) ;</span><br><span class="line">		<span class="type">CallableTest2</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableTest2</span>(<span class="string">&quot;线程3&quot;</span>) ;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Future</span> <span class="variable">f1</span> <span class="operator">=</span> pool.submit(c1) ;</span><br><span class="line">		<span class="type">Future</span> <span class="variable">f2</span> <span class="operator">=</span> pool.submit(c2) ;</span><br><span class="line">		<span class="type">Future</span> <span class="variable">f3</span> <span class="operator">=</span> pool.submit(c3) ;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(f1.get().toString());</span><br><span class="line">			System.out.println(f2.get().toString());</span><br><span class="line">			System.out.println(f3.get().toString());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			pool.shutdown();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>·CallableTest2·类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.crosssoverjie.study.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CallableTest2</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">return</span> name+<span class="string">&quot;返回了东西&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程1返回了东西</span><br><span class="line">线程2返回了东西</span><br><span class="line">线程3返回了东西</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是一个简单的例子，需要了解更多详情可以去看那几个类的API。</p>
]]></content>
      <categories>
        <category>java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Callable</tag>
        <tag>ExecutorService</tag>
        <tag>Future</tag>
        <tag>Executors</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的创建与内存分配</title>
    <url>/2018/01/18/newObject/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1ba311fbe7.jpg"></p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>当 <code>JVM</code> 收到一个 <code>new</code> 指令时，会检查指令中的参数在常量池是否有这个符号的引用，还会检查该类是否已经被<a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/ClassLoad.md">加载</a>过了，如果没有的话则要进行一次类加载。</p>
<p>接着就是分配内存了，通常有两种方式：</p>
<ul>
<li>指针碰撞</li>
<li>空闲列表</li>
</ul>
<p>使用指针碰撞的前提是堆内存是<strong>完全工整</strong>的，用过的内存和没用的内存各在一边每次分配的时候只需要将指针向空闲内存一方移动一段和内存大小相等区域即可。</p>
<p>当堆中已经使用的内存和未使用的内存<strong>互相交错</strong>时，指针碰撞的方式就行不通了，这时就需要采用空闲列表的方式。虚拟机会维护一个空闲的列表，用于记录哪些内存是可以进行分配的，分配时直接从可用内存中直接分配即可。</p>
<p>堆中的内存是否工整是有<strong>垃圾收集器</strong>来决定的，如果带有压缩功能的垃圾收集器就是采用指针碰撞的方式来进行内存分配的。</p>
<span id="more"></span>

<p>分配内存时也会出现并发问题:</p>
<p>这样可以在创建对象的时候使用 <code>CAS</code> 这样的乐观锁来保证。</p>
<p>也可以将内存分配安排在每个线程独有的空间进行，每个线程首先在堆内存中分配一小块内存，称为本地分配缓存(<code>TLAB : Thread Local Allocation Buffer</code>)。</p>
<p>分配内存时，只需要在自己的分配缓存中分配即可，由于这个内存区域是线程私有的，所以不会出现并发问题。</p>
<p>可以使用 <code>-XX:+/-UseTLAB</code> 参数来设定 JVM 是否开启 <code>TLAB</code> 。</p>
<p>内存分配之后需要对该对象进行设置，如对象头。对象头的一些应用可以查看 <a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/Synchronize.md">Synchronize 关键字原理</a>。</p>
<h3 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h3><p>一个对象被创建之后自然是为了使用，在 Java 中是通过栈来引用堆内存中的对象来进行操作的。</p>
<p>对于我们常用的 <code>HotSpot</code> 虚拟机来说，这样引用关系是通过直接指针来关联的。</p>
<p>如图:</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba333efb1.jpg"></p>
<p>这样的好处就是：在 Java 里进行频繁的对象访问可以提升访问速度(相对于使用句柄池来说)。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="Eden-区分配"><a href="#Eden-区分配" class="headerlink" title="Eden 区分配"></a>Eden 区分配</h3><p>简单的来说对象都是在堆内存中分配的，往细一点看则是优先在 <code>Eden</code> 区分配。</p>
<p>这里就涉及到堆内存的划分了，为了方便垃圾回收，JVM 将对内存分为新生代和老年代。</p>
<p>而新生代中又会划分为 <code>Eden</code> 区，<code>from Survivor、to Survivor</code> 区。</p>
<p>其中 <code>Eden</code> 和 <code>Survivor</code> 区的比例默认是 <code>8:1:1</code>，当然也支持参数调整 <code>-XX:SurvivorRatio=8</code>。</p>
<p>当在 <code>Eden</code> 区分配内存不足时，则会发生 <code>minorGC</code> ，由于 <code>Java</code> 对象多数是<strong>朝生夕灭</strong>的特性，所以 <code>minorGC</code> 通常会比较频繁，效率也比较高。</p>
<p>当发生 <code>minorGC</code> 时，JVM 会根据<a href="https://github.com/crossoverJie/Java-Interview/blob/145064ecf867e898ad025f3467b7ada9086fc8dd/MD/GarbageCollection.md#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95">复制算法</a>将存活的对象拷贝到另一个未使用的 <code>Survivor</code> 区，如果 <code>Survivor</code> 区内存不足时，则会使用分配担保策略将对象移动到老年代中。</p>
<p>谈到 <code>minorGC</code> 时，就不得不提到 <code>fullGC(majorGC)</code> ，这是指发生在老年代的 <code>GC</code> ，不论是效率还是速度都比 <code>minorGC </code> 慢的多，回收时还会发生 <code>stop the world</code> 使程序发生停顿，所以应当尽量避免发生 <code>fullGC</code> 。</p>
<h3 id="老年代分配"><a href="#老年代分配" class="headerlink" title="老年代分配"></a>老年代分配</h3><p>也有一些情况会导致对象直接在老年代分配，比如当分配一个大对象时(大的数组，很长的字符串)，由于 <code>Eden</code> 区没有足够大的连续空间来分配时，会导致提前触发一次 <code>GC</code>，所以尽量别频繁的创建大对象。</p>
<p>因此 <code>JVM</code> 会根据一个阈值来判断大于该阈值对象直接分配到老年代，这样可以避免在新生代频繁的发生 <code>GC</code>。</p>
<p>对于一些在新生代的老对象 <code>JVM</code> 也会根据某种机制移动到老年代中。</p>
<p>JVM 是根据记录对象年龄的方式来判断该对象是否应该移动到老年代，根据新生代的复制算法，当一个对象被移动到 <code>Survivor</code> 区之后 JVM 就给该对象的年龄记为1，每当熬过一次 <code>minorGC</code> 后对象的年龄就 +1 ，直到达到阈值(默认为15)就移动到老年代中。</p>
<blockquote>
<p>可以使用 <code>-XX:MaxTenuringThreshold=15</code> 来配置这个阈值。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽说这些内容略显枯燥，但当应用发生不正常的 <code>GC</code> 时，可以方便更快的定位问题。</p>
<h2 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h2><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
  </entry>
  <entry>
    <title>日常记录（一）MySQL被锁解决方案</title>
    <url>/2016/06/05/normal-skill1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>由于前段时间为了让部署在Linux中的项目访问另一台服务器的MySQL，经过各种折腾就把<code>root</code>用户给弄出问题了，导致死活登不上<code>PS:Linux中的项目还是没有连上。。</code>(这是后话了。)。经过各种查阅资料终于找到解决方法了。</p>
</blockquote>
<p>报错如下：<br><code>Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password:YES)</code></p>
<hr>
<h1 id="关闭MySQL服务，修改MySQL初始文件"><a href="#关闭MySQL服务，修改MySQL初始文件" class="headerlink" title="关闭MySQL服务，修改MySQL初始文件"></a>关闭MySQL服务，修改MySQL初始文件</h1><p>打开MySQL目录下的<code>my-default.ini</code>文件，如图：<br><img src="http://i.imgur.com/eUDlxik.png"><br>在最后一行加入<code>skip-grant-tables</code>之后保存。<br>然后重启MySQL服务。</p>
<span id="more"></span>
<hr>
<h1 id="用命令行登录MySQL修改ROOT账号密码"><a href="#用命令行登录MySQL修改ROOT账号密码" class="headerlink" title="用命令行登录MySQL修改ROOT账号密码"></a>用命令行登录MySQL修改ROOT账号密码</h1><p>用命令行登录MySQL输入<code>mysql -uroot -p</code>,不用输入密码，直接敲回车即可进入。如下图：<br><img src="http://i.imgur.com/pENPn4Y.png"><br>之后执行以下语句修改ROOT用户密码：</p>
<ul>
<li><code>use mysql;</code></li>
<li><code>update user set password=PASSWORD(&quot;你的密码&quot;) where user=&#39;root&#39;;</code></li>
</ul>
<h1 id="还原my-default-ini文件"><a href="#还原my-default-ini文件" class="headerlink" title="还原my-default.ini文件"></a>还原<code>my-default.ini</code>文件</h1><p>最后还原配置文件，之后重启MySQL服务即可正常登录了。<br><img src="http://i.imgur.com/rZO0ghR.png"></p>
]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>日常记录（二）SpringMvc导出Excel</title>
    <url>/2016/06/14/normal-skill2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>相信很多朋友在实际工作中都会要将数据导出成Excel的需求，通常这样的做法有两种。<br>一是采用JXL来生成Excel，之后保存到服务器，然后在生成页面之后下载该文件。<br>二是使用POI来生成Excel，之后使用Stream的方式输出到前台直接下载<code>(ps:当然也可以生成到服务器中再下载。)</code>。这里我们讨论第二种。<br>*至于两种方式的优缺点请自行<a href="http://www.baidu.com/">百度</a>*。</p>
</blockquote>
<hr>
<h1 id="Struts2的方式"><a href="#Struts2的方式" class="headerlink" title="Struts2的方式"></a>Struts2的方式</h1><p>通常我会将已经生成好的<code>HSSFWorkbook</code>放到一个<code>InputStream</code>中，然后再到xml配置文件中将返回结果更改为<code>stream</code>的方式。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">responseData</span><span class="params">(HSSFWorkbook wb)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">	wb.write(baos);</span><br><span class="line">	baos.flush();</span><br><span class="line">	<span class="type">byte</span>[] aa = baos.toByteArray();</span><br><span class="line">	excelStream = <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(aa, <span class="number">0</span>, aa.length);</span><br><span class="line">	baos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;action name=<span class="string">&quot;exportXxx&quot;</span> class=<span class="string">&quot;xxxAction&quot;</span> method=<span class="string">&quot;exportXxx&quot;</span>&gt;</span><br><span class="line">	&lt;result name=<span class="string">&quot;exportSuccess&quot;</span> type=<span class="string">&quot;stream&quot;</span>&gt;</span><br><span class="line">		&lt;param name=<span class="string">&quot;inputName&quot;</span>&gt;excelStream&lt;/param&gt;</span><br><span class="line">    	&lt;param name=<span class="string">&quot;contentType&quot;</span>&gt;application/vnd.ms-excel&lt;/param&gt;</span><br><span class="line">    	&lt;param name=<span class="string">&quot;contentDisposition&quot;</span>&gt;attachment;filename=<span class="string">&quot;Undefined.xls&quot;</span>&lt;/param&gt;</span><br><span class="line">	&lt;/result&gt;</span><br><span class="line">&lt;/action&gt;</span><br></pre></td></tr></table></figure>
<p>这样即可达到点击链接即可直接下载文件的目的。</p>
<hr>
<h1 id="SpringMVC的方式"><a href="#SpringMVC的方式" class="headerlink" title="SpringMVC的方式"></a>SpringMVC的方式</h1><p>先贴代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/exportXxx.action&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportXxx</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">		<span class="meta">@RequestParam(value=&quot;scheduleId&quot;, defaultValue=&quot;0&quot;)</span><span class="type">int</span> scheduleId)</span>&#123;</span><br><span class="line">	<span class="type">HSSFWorkbook</span> <span class="variable">wb</span> <span class="operator">=</span> createExcel(scheduleId) ;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=appointmentUser.xls&quot;</span>);</span><br><span class="line">		response.setContentType(<span class="string">&quot;application/vnd.ms-excel; charset=utf-8&quot;</span>) ;</span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> response.getOutputStream() ;</span><br><span class="line">		wb.write(out) ;</span><br><span class="line">		out.flush();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实springMVC和Struts2的原理上是一样的，只是Struts2是才去配置文件的方式。首先是使用<code>createExcel()</code>这个方法来生成Excel并返回，最后利用r<code>response</code>即可向前台输出Excel，这种方法是通用的，也可以试用与<code>Servlet、Struts2等</code>。我们只需要在<code>response</code>的头信息中设置相应的输出信息即可。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不管是使用<code>Struts2</code>，还是使用<code>SpringMVC</code>究其根本都是使用的<code>response</code>，所以只要我们把<code>response</code>理解透了不管是下载图片、world、Excel还是其他什么文件都是一样的。</p>
]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>poi</tag>
      </tags>
  </entry>
  <entry>
    <title>日常记录（三）更换Hexo主题</title>
    <url>/2016/06/18/normal-skill3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>由于博主的喜新厌旧，再经过一段时间对上一个主题的审美疲劳加上我专(zhuang)研(bi)的精神<br>于是就想找一个B格较高的主题。经过一段时间的查找发现NexT这个主题简洁而不失华丽，低调而不失逼格(就不收广告费了)特别适合我，接着就着手开干。</p>
</blockquote>
<hr>
<h1 id="安装NexT主题"><a href="#安装NexT主题" class="headerlink" title="安装NexT主题"></a>安装NexT主题</h1><h2 id="从Git上克隆主题"><a href="#从Git上克隆主题" class="headerlink" title="从Git上克隆主题"></a>从Git上克隆主题</h2><p>这里我就不介绍有关Hexo的东西了，默认是知道如何搭建Hexo博客的。还不太清楚的请自行百度。<br>首先将NexT主题先克隆到自己电脑上：</p>
<ul>
<li><code>cd your-hexo-site</code></li>
<li><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code>。</li>
</ul>
<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>接下来我们只需要将站点下的<code>_config.yml</code>配置文件中的主题配置更换成Next，如下图：<br><img src="http://i.imgur.com/GhhnMDs.png"><br>其实这样主题就配好了，是不是很简单<br><img src="http://i.imgur.com/wQmHabT.gif">。</p>
<span id="more"></span>
<hr>
<h1 id="NexT主题配置"><a href="#NexT主题配置" class="headerlink" title="NexT主题配置"></a>NexT主题配置</h1><h2 id="Hexo配置文件相关配置"><a href="#Hexo配置文件相关配置" class="headerlink" title="Hexo配置文件相关配置"></a>Hexo配置文件相关配置</h2><p>Next主题的个人头像是在Hexo配置文件中的。<br><img src="http://i.imgur.com/Wranuhu.png"><br>NexT同样也支持多说配置，我们只需要将你自己的多说账号也配置到Hexo的配置文件中即可。<br><code>duoshuo_shortname: your name</code></p>
<h2 id="Next配置文件相关配置"><a href="#Next配置文件相关配置" class="headerlink" title="Next配置文件相关配置"></a>Next配置文件相关配置</h2><p>NexT主题非常吸引我的一点就是他支持打赏功能，这让我这种穷逼程序猿又看到了生路(多半也没人会给我打赏)，以下一段配置即可在每篇博文下边开启打赏功能。<br><img src="http://i.imgur.com/EvWY5v0.png"><br>微信也是可以的，但是我找了半天没有找到生成微信支付码的地方。<br>其他的一些配置我觉得都比较简单，看官方的帮助文档也是完全可以的，有问题的我们可以再讨论。</p>
<hr>
<h1 id="一个绕坑指南"><a href="#一个绕坑指南" class="headerlink" title="一个绕坑指南"></a>一个绕坑指南</h1><p>我在换完NexT之后发现在首页<br><img src="http://i.imgur.com/JA451zP.png"><br>这里显示的分类和便签的统计都是对的，但是点进去之后就是空白的。我查看了Hexo和NexT的文档发现我写的没有任何问题，之后就懵逼了。。。<img src="http://i.imgur.com/dQxzrn6.gif">各位有碰到这个问题的可以往下看。</p>
<h2 id="绕坑"><a href="#绕坑" class="headerlink" title="绕坑"></a>绕坑</h2><p>之后我仔细的查阅了NexT的文档，发现他所使用的tags和categories文件夹下的<code>index.md</code>的格式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2016-06-16 02:13:06</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这和我之前使用的<code>JackMan</code>主题是完全不一样的(有关JackMan主题可以自行查阅)。<br>之后我讲categories文件下的<code>index.md</code>文件也换成这样的格式就没有问题了。如果你和我一样眼神不好的话建议配副眼镜。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实以上的很多东西都是在<a href="http://theme-next.iissnan.com/">NexT官方文档</a>里查得到的，接下来我会尝试提一点<code>pull request</code>来更加深入的了解Hexo。</p>
]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>sbc(三)自定义Starter-SpringBoot重构去重插件</title>
    <url>/2017/08/01/sbc3/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/08/01/59800eca06bf0.jpg" alt="pexels-photo-9046.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前看过<a href="http://crossoverjie.top/2017/05/24/SSM14/">SSM(十四) 基于annotation的http防重插件</a>的朋友应该记得我后文说过之后要用<code>SpringBoot</code>来进行重构。</p>
<blockquote>
<p>这次采用自定义的<code>starter</code>的方式来进行重构。 </p>
</blockquote>
<p>关于<code>starter(起步依赖)</code>其实在第一次使用<code>SpringBoot</code>的时候就已经用到了，比如其中的:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们只需要引入这一个依赖<code>SpringBoot</code>就会把相关的依赖都加入进来，自己也不需要再去担心各个版本之间的兼容问题(具体使用哪个版本由使用的<code>spring-boot-starter-parent</code>版本决定)，这些<code>SpringBoot</code>都已经帮我们做好了。</p>
<p><img src="https://i.loli.net/2017/08/01/598028d65b395.jpg" alt="01.jpg"></p>
<hr>
<span id="more"></span>


<h1 id="Spring自动化配置"><a href="#Spring自动化配置" class="headerlink" title="Spring自动化配置"></a>Spring自动化配置</h1><p>先加入需要的一些依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--aop相关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--redis相关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置相关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--通用依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crossoverJie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sbc-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建了<code>CheckReqConf</code>配置类用于在应用启动的时候自动配置。<br>当然前提还得在<code>resources</code>目录下创建<code>META-INF/spring.factories</code>配置文件用于指向当前类，才能在应用启动时进行自动配置。</p>
<p><code>spring.factories</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=</span><br><span class="line">\com.crossoverJie.request.check.conf.CheckReqConf</span><br></pre></td></tr></table></figure>

<h2 id="使用条件化配置"><a href="#使用条件化配置" class="headerlink" title="使用条件化配置"></a>使用条件化配置</h2><p>试着考虑下如下情况:</p>
<blockquote>
<p>因为该插件是使用<code>redis</code>来存储请求信息的，外部就依赖了<code>redis</code>。如果使用了该插件的应用没有配置或者忘了配置<code>redis</code>的一些相关连接，那么在应用使用过程中肯定会出现写入<code>redis</code>异常。</p>
<p>如果异常没有控制好的话还有可能影响项目的正常运行。</p>
</blockquote>
<p>那么怎么解决这个情况呢，可以使用<code>Spring4.0</code>新增的条件化配置来解决。</p>
<p>解决思路是:可以简单的通过判断应用中是否配置有<code>spring.redis.host</code>redis连接，如果没有我们的这个配置就会被忽略掉。</p>
<p>实现代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Conditional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.crossoverJie.request.check.interceptor,com.crossoverJie.request.check.properties&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否有redis配置的校验，如果没有配置则不会加载改配置，也就是当前插件并不会生效</span></span><br><span class="line"><span class="meta">@Conditional(CheckReqCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckReqConf</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体校验的代码<code>CheckReqCondition</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckReqCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(CheckReqCondition.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata annotatedTypeMetadata)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有加入redis配置的就返回false</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> context.getEnvironment().getProperty(<span class="string">&quot;spring.redis.host&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(property))&#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Need to configure redis!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要实现<code>org.springframework.context.annotation.Condition</code>并重写<code>matches()</code>方法,即可实现个人逻辑。</p>
<blockquote>
<p>可以在使用了该依赖的配置文件中配置或者是不配置<code>spring.redis.host</code>这个配置,来看我们的切面类(<code>ReqNoDrcAspect</code>)中53行的日志是否有打印来判断是否生效。</p>
</blockquote>
<p>这样只有在存在该key的情况下才会应用这个配置。</p>
<blockquote>
<p>当然最好的做法是直接尝试读、写redis,看是否连接畅通来进行判断。</p>
</blockquote>
<h1 id="AOP切面"><a href="#AOP切面" class="headerlink" title="AOP切面"></a><code>AOP</code>切面</h1><p>最核心的其实就是这个切面类，里边主要逻辑和之前是一模一样的就不在多说,只是这里应用到了自定义配置。</p>
<p>切面类<code>ReqNoDrcAspect</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//切面注解</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="comment">//扫描</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//开启cglib代理</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReqNoDrcAspect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ReqNoDrcAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CheckReqProperties properties ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefixReq ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> day ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        prefixReq = properties.getRedisKey() == <span class="literal">null</span> ? <span class="string">&quot;reqNo&quot;</span> : properties.getRedisKey() ;</span><br><span class="line">        day = properties.getRedisTimeout() == <span class="literal">null</span> ? <span class="number">1L</span> : properties.getRedisTimeout() ;</span><br><span class="line">        logger.info(<span class="string">&quot;sbc-request-check init......&quot;</span>);</span><br><span class="line">        logger.info(String.format(<span class="string">&quot;redis prefix is [%s],timeout is [%s]&quot;</span>, prefixReq, day));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切面该注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.crossoverJie.request.check.anotation.CheckReqNo)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkRepeat</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;checkRepeat()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BaseRequest</span> <span class="variable">request</span> <span class="operator">=</span> getBaseRequest(joinPoint);</span><br><span class="line">        <span class="keyword">if</span>(request != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">reqNo</span> <span class="operator">=</span> request.getReqNo();</span><br><span class="line">            <span class="keyword">if</span>(StringUtil.isEmpty(reqNo))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SBCException</span>(StatusEnum.REPEAT_REQUEST);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">tempReqNo</span> <span class="operator">=</span> redisTemplate.opsForValue().get(prefixReq +reqNo);</span><br><span class="line">                    logger.debug(<span class="string">&quot;tempReqNo=&quot;</span> + tempReqNo);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>((StringUtil.isEmpty(tempReqNo)))&#123;</span><br><span class="line">                        redisTemplate.opsForValue().set(prefixReq + reqNo, reqNo, day, TimeUnit.DAYS);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SBCException</span>(<span class="string">&quot;请求号重复,&quot;</span>+ prefixReq +<span class="string">&quot;=&quot;</span> + reqNo);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RedisConnectionFailureException e)&#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;redis操作异常&quot;</span>,e);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SBCException</span>(<span class="string">&quot;need redisService&quot;</span>) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BaseRequest <span class="title function_">getBaseRequest</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BaseRequest</span> <span class="variable">returnRequest</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Object[] arguments = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">if</span>(arguments != <span class="literal">null</span> &amp;&amp; arguments.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            returnRequest = (BaseRequest) arguments[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> returnRequest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们的写入<code>redis</code>key的前缀和过期时间改为从<code>CheckReqProperties</code>类中读取:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//定义配置前缀</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;sbc.request.check&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckReqProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String redisKey ;<span class="comment">//写入redis中的前缀</span></span><br><span class="line">    <span class="keyword">private</span> Long redisTimeout ;<span class="comment">//redis的过期时间 默认是天</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRedisKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRedisKey</span><span class="params">(String redisKey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisKey = redisKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getRedisTimeout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRedisTimeout</span><span class="params">(Long redisTimeout)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTimeout = redisTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CheckReqProperties&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;redisKey=&#x27;&quot;</span> + redisKey + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, redisTimeout=&quot;</span> + redisTimeout +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样如果是需要很多配置的情况下就可以将内容封装到该对象中，方便维护和读取。</p>
<p>使用的时候只需要在自己应用的<code>application.properties</code>中加入</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去重配置</span></span><br><span class="line"><span class="attr">sbc.request.check.redis-key</span> = <span class="string">req</span></span><br><span class="line"><span class="attr">sbc.request.check.redis-timeout</span>= <span class="string">2</span></span><br></pre></td></tr></table></figure>

<h1 id="应用插件"><a href="#应用插件" class="headerlink" title="应用插件"></a>应用插件</h1><p>使用方法也和之前差不多(在<a href="https://github.com/crossoverJie/springboot-cloud/tree/master/sbc-order">sbc-order</a>应用)：</p>
<ul>
<li>加入依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--防重插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crossoverJie.request.check<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>request-check<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在接口上加上注解:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(value = &quot;orderApi&quot;, description = &quot;订单API&quot;, tags = &#123;&quot;订单服务&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(OrderController.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CheckReqNo</span></span><br><span class="line">    <span class="keyword">public</span> BaseResponse&lt;OrderNoResVO&gt; <span class="title function_">getOrderNo</span><span class="params">(<span class="meta">@RequestBody</span> OrderNoReqVO orderNoReq)</span> &#123;</span><br><span class="line">        BaseResponse&lt;OrderNoResVO&gt; res = <span class="keyword">new</span> <span class="title class_">BaseResponse</span>();</span><br><span class="line">        res.setReqNo(orderNoReq.getReqNo());</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == orderNoReq.getAppId())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SBCException</span>(StatusEnum.FAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">OrderNoResVO</span> <span class="variable">orderNoRes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderNoResVO</span>() ;</span><br><span class="line">        orderNoRes.setOrderId(DateUtil.getLongTime());</span><br><span class="line">        res.setCode(StatusEnum.SUCCESS.getCode());</span><br><span class="line">        res.setMessage(StatusEnum.SUCCESS.getMessage());</span><br><span class="line">        res.setDataBody(orderNoRes);</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用效果如下:</p>
<p><img src="https://i.loli.net/2017/08/01/59803ca7b9ece.jpg" alt="02.jpg"><br><img src="https://i.loli.net/2017/08/01/59803ca7d603d.jpg" alt="03.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>注意一点是<code>spring.factories</code>的路径不要搞错了,之前就是因为路径写错了，导致自动配置没有加载，AOP也就没有生效，排查了好久。。</p>
<blockquote>
<p>项目：<a href="https://github.com/crossoverJie/springboot-cloud">https://github.com/crossoverJie/springboot-cloud</a></p>
</blockquote>
<blockquote>
<p>博客：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>sbc</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>重构</tag>
        <tag>AOP</tag>
        <tag>SpringBoot</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>sbc(一)SpringBoot+SpringCloud初探</title>
    <url>/2017/06/15/sbc1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://ooo.0o0.ooo/2017/06/15/59417275b1746.jpg" alt="sb1.jpg"></p>
<p>有看过我之前的<a href="https://github.com/crossoverJie/SSM">SSM</a>系列的朋友应该有一点印象是非常深刻的。</p>
<blockquote>
<p>那就是需要配置的配置文件非常多，什么<code>Spring</code>、<code>mybatis</code>、<code>redis</code>、<code>mq</code>之类的配置文件非常多，并且还存在各种版本，甚至有些版本还互不兼容。其中有很多可能就是刚开始整合的时候需要配置，之后压根就不会再动了。</p>
</blockquote>
<p>鉴于此，<code>Spring</code>又推出了又一神器<a href="https://projects.spring.io/spring-boot/">SpringBoot</a>.</p>
<p>它可以让我们更加快速的开发<code>Spring</code>应用，甚至做到了开箱即用。<br>由于在实际开发中我们使用<code>SpringBoot</code>+<code>SpringCloud</code>进行了一段时间的持续交付，并在生产环境得到了验证，其中也有不少踩坑的地方，借此机会和大家分享交流一下。</p>
<p>本篇我们首先会用利用<code>SpringBoot</code>构建出一个简单的<code>REST API</code>.<br>接着会创建另一个<code>SpringBoot</code>项目，基于<code>SpringCloud</code>部署，并在两个应用之间进行调用。</p>
<h1 id="使用SpringBoot构建REST-API"><a href="#使用SpringBoot构建REST-API" class="headerlink" title="使用SpringBoot构建REST API"></a>使用<code>SpringBoot</code>构建<code>REST API</code></h1><p>我们可以使用<code>Spring</code>官方提供的初始化工具帮我们生成一个基础项目：<a href="http://start.spring.io/">http://start.spring.io/</a>,如下图所示：<br><img src="https://ooo.0o0.ooo/2017/06/16/5942bbbb8797e.jpg" alt="sb2.jpg"></p>
<p>填入相应信息即可。由于只是要实现<code>REST API</code>所以这里只需要引用<code>web</code>依赖即可。</p>
<span id="more"></span>

<p>将生成好的项目导入<code>IDE</code>(我使用的是<code>idea</code>)中,目录结构如下;<br><img src="https://ooo.0o0.ooo/2017/06/16/5942bde60ac4c.jpg" alt="sb3.jpg"></p>
<ul>
<li>其中的<code>SbcUserApplication</code>是整个应用的入口。</li>
<li><code>resource/application.properties</code>这里是存放整个应用的配置文件。</li>
<li>其中的<code>static</code>和<code>templates</code>是存放静态资源以及前端模板的地方，由于我们采用了前后端分离，所以这些目录基本上用不上了。</li>
</ul>
<p>通过运行<code>SbcUserApplication</code>类的<code>main</code>方法可以启动<code>SpringBoot</code>项目。</p>
<p>接着在<code>PostMan</code>中进行调用，看到以下结果表明启动成功了：</p>
<p><img src="https://ooo.0o0.ooo/2017/06/26/5950a607afe13.jpg" alt="springBoot01.jpg"></p>
<p>这样一看是不是要比之前用<code>Spring+SpringMVC</code>来整合要方便快捷很多。</p>
<h1 id="创建另一个SpringBoot项目"><a href="#创建另一个SpringBoot项目" class="headerlink" title="创建另一个SpringBoot项目"></a>创建另一个<code>SpringBoot</code>项目</h1><p>当我们的项目采用微服务构建之后自然就会被拆分成N多个独立的应用。比如上文中的<code>sbc-user</code>用于用户管理。这里再创建一个<code>sbc-order</code>用户生成订单。</p>
<blockquote>
<p>为了方便之后的代码复用，我将<code>common</code>包中的一些枚举值、工具类单独提到<code>sbc-common</code>应用中了，这样有其他应用要使用这些基础类直接引入这个依赖即可。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crossoverJie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sbc-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建步骤和上文差不多，这里就不再赘述了。<br>其中有一个<code>order/getOrderNo</code>的服务，调用结果如下：</p>
<p><img src="https://ooo.0o0.ooo/2017/06/26/5950de9914c91.jpg" alt="springBoot02.jpg"></p>
<p>之后会利用<code>SpringCloud</code>来将两个服务关联起来，并可以互相调用。</p>
<h1 id="使用SpringCloud进行分布式调用"><a href="#使用SpringCloud进行分布式调用" class="headerlink" title="使用SpringCloud进行分布式调用"></a>使用<code>SpringCloud</code>进行分布式调用</h1><h2 id="搭建eureka注册中心"><a href="#搭建eureka注册中心" class="headerlink" title="搭建eureka注册中心"></a>搭建<code>eureka</code>注册中心</h2><p>既然是要搭建微服务那自然少不了注册中心了，之前讲的<code>dubbo</code>采用的是<code>zookeeper</code>作为注册中心，<code>SpringCloud</code>则采用的是<code>Netflix Eureka</code>来做服务的注册与发现。</p>
<p>新建一个项目<code>sbc-service</code>,目录结构如下：</p>
<p><img src="https://ooo.0o0.ooo/2017/06/26/59511b85974be.jpg" alt="springBoot03.jpg"></p>
<p>核心的<code>pom.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>Brixton.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>非常easy，只需要引入<code>eureka </code>的依赖即可。<br>然后在入口类加入一个注解<code>@EnableEurekaServer</code>，即可将该项目作为服务注册中心：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.crossoverJie.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(EurekaApplication.class);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">		logger.info(<span class="string">&quot;SpringBoot Start Success&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着修改配置文件<code>application.properties</code>:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8888</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 不向注册中心注册自己</span></span><br><span class="line"><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 不需要检索服务</span></span><br><span class="line"><span class="attr">eureka.client.fetch-registry</span>=<span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure>

<p>配置一下端口以及注册中心的地址即可。<br>然后按照正常启动<code>springBoot</code>项目一样启动即可。</p>
<p>在地址栏输入<a href="http://localhost:8888/">http://localhost:8888</a>看到一下界面：</p>
<p><img src="https://ooo.0o0.ooo/2017/06/26/59511cef59d46.jpg" alt="springBoot04.jpg"></p>
<p>当然现在在注册中心还看不到任何一个应用，下面需要将上文的<code>sbc-user,sbc-order</code>注册进来。</p>
<h2 id="向注册中心注册服务提供者"><a href="#向注册中心注册服务提供者" class="headerlink" title="向注册中心注册服务提供者"></a>向注册中心注册服务提供者</h2><p>只需要在<code>application.properties</code>配置文件中加上注册中心的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eureka.client.serviceUrl.defaultZone=http://localhost:8888/eureka/</span><br></pre></td></tr></table></figure>

<p>并在<code>sbc-order</code>的主类中加入<code>@EnableDiscoveryClient</code>注解即可完成注册服务。</p>
<p>启动注册中心以及应用，在注册中心看到一下界面则成功注册:</p>
<p><img src="https://ooo.0o0.ooo/2017/06/26/595129f117276.jpg" alt="springBoot05.jpg"></p>
<h2 id="消费注册中心的服务"><a href="#消费注册中心的服务" class="headerlink" title="消费注册中心的服务"></a>消费注册中心的服务</h2><p>服务是注册上去了，自然是需要消费了，这里就简单模拟了在调用<code>http://localhost:8080/user/getUser</code>这个接口的时候<code>getUser</code>接口会去调用<code>order</code>的<code>getOrder</code>服务。</p>
<p>这里会用到另一个依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>他可以帮我们做到客户端负载，具体使用如下：</p>
<ul>
<li>加入ribbon依赖。</li>
<li>在主类中开启<code>@LoadBalanced</code>客户端负载。</li>
<li>创建<code>restTemplate</code>类的实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@LoadBalanced</span></span><br><span class="line">	<span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>restTemplate </code>调用远程服务:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/getUser&quot;,method = RequestMethod.POST)</span></span><br><span class="line">  <span class="keyword">public</span> UserRes <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestBody</span> UserReq userReq)</span>&#123;</span><br><span class="line">      <span class="type">OrderNoReq</span> <span class="variable">req</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderNoReq</span>() ;</span><br><span class="line">      req.setReqNo(<span class="string">&quot;1213&quot;</span>);</span><br><span class="line">      <span class="comment">//调用远程服务</span></span><br><span class="line">      ResponseEntity&lt;Object&gt; res = restTemplate.postForEntity(<span class="string">&quot;http://sbc-order/order/getOrderNo&quot;</span>, req, Object.class);</span><br><span class="line">      logger.info(<span class="string">&quot;res=&quot;</span>+JSON.toJSONString(res));</span><br><span class="line"></span><br><span class="line">      logger.debug(<span class="string">&quot;入参=&quot;</span>+ JSON.toJSONString(userReq));</span><br><span class="line">      <span class="type">UserRes</span> <span class="variable">userRes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserRes</span>() ;</span><br><span class="line">      userRes.setUserId(<span class="number">123</span>);</span><br><span class="line">      userRes.setUserName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">      userRes.setReqNo(userReq.getReqNo());</span><br><span class="line">      userRes.setCode(StatusEnum.SUCCESS.getCode());</span><br><span class="line">      userRes.setMessage(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> userRes ;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>由于我的远程接口是<code>post</code>,所以使用了<code>postForEntity()</code>方法，如果是<code>get</code>就换成<code>getForEntity()</code>即可。</p>
<blockquote>
<p>注意这里是使用应用名<code>sbc-order(配置于sbc-order的application.properties中)</code>来进行调用的，并不是一个IP地址。</p>
</blockquote>
<p>启动注册中心、两个应用。<br>用<code>PostMan</code>调用<code>getUser</code>接口时控制台打印:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2017-06-27 00:18:04.534  INFO 63252 --- [nio-8080-exec-3] c.c.sbcuser.controller.UserController    : res=&#123;&quot;body&quot;:&#123;&quot;code&quot;:&quot;4000&quot;,&quot;message&quot;:&quot;appID不能为空&quot;,&quot;reqNo&quot;:&quot;1213&quot;&#125;,&quot;headers&quot;:&#123;&quot;X-Application-Context&quot;:[&quot;sbc-order:8181&quot;],&quot;Content-Type&quot;:[&quot;application/xml;charset=UTF-8&quot;],&quot;Transfer-Encoding&quot;:[&quot;chunked&quot;],&quot;Date&quot;:[&quot;Mon, 26 Jun 2017 16:18:04 GMT&quot;]&#125;,&quot;statusCode&quot;:&quot;OK&quot;,&quot;statusCodeValue&quot;:200&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于并没有传递<code>appId</code>所以<code>order</code>服务返回了一个错误，也正说明是远程调用到了该服务。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>ps:这里只是简单使用了<code>ribbon</code>来进行服务调用，但在实际的开发中还是比较少的使用这种方式来调用远程服务，而是使用<code>Feign</code>进行声明式调用，可以简化客户端代码，具体使用方式请持续关注。</p>
</blockquote>
<p>本次算是<code>springBoot+springCloud</code>的入门，还有很多东西没有讲到，之后我将会根据实际使用的一些经验继续分享<code>SpringCloud</code>这个新兴框架。</p>
<blockquote>
<p>项目：<a href="https://github.com/crossoverJie/springboot-cloud">https://github.com/crossoverJie/springboot-cloud</a></p>
</blockquote>
<blockquote>
<p>博客：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>sbc</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>sbc(二)高可用Eureka+声明式服务调用</title>
    <url>/2017/07/19/sbc2/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/07/20/596f9bc03c484.jpeg" alt="pexels-photo-516961.jpeg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>上一篇简单入门了<a href="http://crossoverjie.top/2017/06/15/sbc1/">SpringBoot+SpringCloud</a> 构建微服务。但只能算是一个<code>demo</code>级别的应用。<br>这次会按照实际生产要求来搭建这套服务。</p>
</blockquote>
<h1 id="Swagger应用"><a href="#Swagger应用" class="headerlink" title="Swagger应用"></a>Swagger应用</h1><p>上次提到我们调用自己的<code>http</code>接口的时候采用的是<code>PostMan</code>来模拟请求，这个在平时调试时自然没有什么问题，但当我们需要和前端联调开发的时候效率就比较低了。</p>
<p><strong>通常来说现在前后端分离的项目一般都是后端接口先行。</strong></p>
<p>后端大大们先把接口定义好(入参和出参),前端大大们来确定是否满足要求，可以了之后后端才开始着手写实现，这样整体效率要高上许多。</p>
<p>但也会带来一个问题:在接口定义阶段频繁变更接口定义而没有一个文档或类似的东西来记录，那么双方的沟通加上前端的调试都是比较困难的。</p>
<p>基于这个需求网上有各种解决方案，比如阿里的<a href="http://rapapi.org/">rap</a>就是一个不错的例子。</p>
<p>但是<code>springCould</code>为我们在提供了一种在开发<code>springCloud</code>项目下更方便的工具<code>swagger</code>。</p>
<p>实际效果如下:</p>
<p><img src="https://i.loli.net/2017/07/20/596fa125406dd.png" alt="01.png"></p>
<span id="more"></span>


<h2 id="配置swagger"><a href="#配置swagger" class="headerlink" title="配置swagger"></a>配置swagger</h2><p>以<code>sbc-order</code>为例我将项目分为了三个模块:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">├── order                                    <span class="comment">// Order服务实现  </span></span><br><span class="line">│   ├── src/main</span><br><span class="line">├── order-api                                <span class="comment">// 对内API</span></span><br><span class="line">│   ├── src/main</span><br><span class="line">├── order-client                             <span class="comment">// 对外的clientAPI</span></span><br><span class="line">│   ├── src/main</span><br><span class="line">├── .gitignore                               </span><br><span class="line">├── LICENSE                </span><br><span class="line">├── README.md               </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为实现都写在<code>order</code>模块中，所以只需要在该模块中配置即可。</p>
<p>首先需要加入依赖，由于我在<code>order</code>模块中依赖了:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crossoverJie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>order-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;target.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>order-api</code>又依赖了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着需要配置一个<code>SwaggerConfig</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">/** 是否打开swagger **/</span><br><span class="line">@ConditionalOnExpression(&quot;&#x27;$&#123;swagger.enable&#125;&#x27; == &#x27;true&#x27;&quot;)</span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">	@Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.crossoverJie.sbcorder.controller&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;sbc order api&quot;)</span><br><span class="line">                .description(&quot;sbc order api&quot;)</span><br><span class="line">                .termsOfServiceUrl(&quot;http://crossoverJie.top&quot;)</span><br><span class="line">                .contact(&quot;crossoverJie&quot;)</span><br><span class="line">                .version(&quot;1.0.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是配置<code>swagger</code>的一些基本信息。<br>之后启动项目，在地址栏输入<code>http://ip:port/swagger-ui.html#/</code>即可进入。<br>可以看到如上图所示的接口列表,点击如下图所示的参数例子即可进行接口调用。</p>
<p><img src="https://ooo.0o0.ooo/2017/07/21/5970d89b629d4.jpg" alt="02.jpg"></p>
<h2 id="自定义开关Swagger"><a href="#自定义开关Swagger" class="headerlink" title="自定义开关Swagger"></a>自定义开关Swagger</h2><blockquote>
<p><code>swagger</code>的便利能给我们带来很多好处，但稍有不慎也可能出现问题。</p>
</blockquote>
<p>比如如果在生产环境还能通过IP访问<code>swagger</code>的话那后果可是不堪设想的。<br>所以我们需要灵活控制<code>swagger</code>的开关。</p>
<p>这点可以利用<code>spring的条件化配置(条件化配置可以配置存在于应用中,一旦满足一些特定的条件时就取消这些配置)</code>来实现这一功能:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnExpression(&quot;&#x27;$&#123;swagger.enable&#125;&#x27; == &#x27;true&#x27;&quot;)</span></span><br></pre></td></tr></table></figure>

<p>该注解的意思是<code>给定的SpEL表达式计算结果为true</code>时才会创建<code>swagger</code>的<code>bean</code>。</p>
<p><code>swagger.enable</code>这个配置则是配置在<code>application.properties</code>中:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 是否打开swagger</span><br><span class="line">swagger.enable = true</span><br></pre></td></tr></table></figure>

<p>这样当我们在生产环境时只需要将该配置改为<code>false</code>即可。</p>
<p>ps:更多<code>spring条件化配置</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConditionalOnBean                 //配置了某个特定Bean</span><br><span class="line">@ConditionalOnMissingBean          //没有配置特定的Bean</span><br><span class="line">@ConditionalOnClass                //Classpath里有指定的类</span><br><span class="line">@ConditionalOnMissingClass         //Classpath里缺少指定的类</span><br><span class="line">@ConditionalOnExpression           //给定的Spring Expression Language(SpEL)表达式计算结果为true</span><br><span class="line">@ConditionalOnJava                 //Java的版本匹配特定值或者一个范围值</span><br><span class="line">@ConditionalOnJndi                 //参数中给定的JNDI位置必须存在一个，如果没有给参数，则要有JNDI InitialContext</span><br><span class="line">@ConditionalOnProperty             //指定的配置属性要有一个明确的值</span><br><span class="line">@ConditionalOnResource             //Classpath里有指定的资源</span><br><span class="line">@ConditionalOnWebApplication       //这是一个Web应用程序</span><br><span class="line">@ConditionalOnNotWebApplication    //这不是一个Web应用程序</span><br><span class="line">(参考SpringBoot实战)</span><br></pre></td></tr></table></figure>

<h1 id="高可用Eureka"><a href="#高可用Eureka" class="headerlink" title="高可用Eureka"></a>高可用Eureka</h1><p>在上一篇中是用<code>Eureka </code>来做了服务注册中心，所有的生产者都往它注册服务，消费者又通过它来获取服务。</p>
<p><em>但是之前讲到的都是单节点，这在生产环境风险巨大，我们必须做到注册中心的高可用，搭建<code>Eureka </code>集群。</em></p>
<p>这里简单起见就搭建两个<code>Eureka </code>,思路则是这两个Eureka都把自己当成应用向对方注册，这样就可以构成一个高可用的服务注册中心。</p>
<p>在实际生产环节中会是每个注册中心一台服务器，为了演示起见，我就在本地启动两个注册中心，但是端口不一样。</p>
<p>首先需要在本地配置一个<code>host</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1 node1 node2</span><br></pre></td></tr></table></figure>

<p>这样不论是访问<code>node1 </code>还是<code>node2</code>都可以在本机调用的到(<code>当然不配置host也可以，只是需要通过IP来访问，这样看起来不是那么明显</code>)。</p>
<p>并给<code>sbc-service</code>新增了两个配置文件:</p>
<p>application-node1.properties:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.application.name=sbc-service</span><br><span class="line">server.port=8888</span><br><span class="line">eureka.instance.hostname=node1</span><br><span class="line"></span><br><span class="line">## 不向注册中心注册自己</span><br><span class="line">#eureka.client.register-with-eureka=false</span><br><span class="line">#</span><br><span class="line">## 不需要检索服务</span><br><span class="line">#eureka.client.fetch-registry=false</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://node2:9999/eureka/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>application-node2.properties:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.application.name=sbc-service</span><br><span class="line">server.port=9999</span><br><span class="line">eureka.instance.hostname=node2</span><br><span class="line"></span><br><span class="line">## 不向注册中心注册自己</span><br><span class="line">#eureka.client.register-with-eureka=false</span><br><span class="line">#</span><br><span class="line">## 不需要检索服务</span><br><span class="line">#eureka.client.fetch-registry=false</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://node1:8888/eureka/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中最重要的就是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eureka.client.serviceUrl.defaultZone=http://node2:9999/eureka/</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://node1:8888/eureka/</span><br></pre></td></tr></table></figure>
<p>两个应用互相注册。</p>
<p>启动的时候我们按照:<br><code>java -jar sbc-service-1.0.0-SNAPSHOT.jar --spring.profiles.active=node1</code>启动，就会按照传入的node1或者是node2去读取<code>application-node1.properties,application-node2.properties</code>这两个配置文件(<code>配置文件必须按照application-&#123;name&#125;.properties的方式命名</code>)。</p>
<p>分别启动两个注册中心可以看到以下:<br><img src="https://ooo.0o0.ooo/2017/07/21/5970dcda3315c.jpg" alt="03.jpg"></p>
<hr>
<p><img src="https://ooo.0o0.ooo/2017/07/21/5970dcda3c724.jpg" alt="04.jpg"></p>
<p>可以看到两个注册中心以及互相注册了。<br>在服务注册的时候只需要将两个地址都加上即可:<br><code>eureka.client.serviceUrl.defaultZone=http://node1:8888/eureka/,http://node2:9999/eureka/ </code></p>
<p>在服务调用的时候可以尝试关闭其中一个，正常情况下依然是可以调用到服务的。</p>
<h1 id="Feign声明式调用"><a href="#Feign声明式调用" class="headerlink" title="Feign声明式调用"></a>Feign声明式调用</h1><p>接下来谈谈服务调用，上次提到可以用<code>ribbon </code>来进行服务调用，但是明显很不方便，不如像之前<code>rpc</code>调用那样简单直接。</p>
<p>为此这次使用<code>Feign</code>来进行声明式调用，就像调用一个普通方法那样简单。</p>
<h2 id="order-client"><a href="#order-client" class="headerlink" title="order-client"></a>order-client</h2><p>片头说到我将应用分成了三个模块<code>order、order-api、order-client</code>，其中的<code>client</code>模块就是关键。</p>
<p>来看看其中的内容,只有一个接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/orderService&quot;)</span></span><br><span class="line"><span class="meta">@FeignClient(name=&quot;sbc-order&quot;)</span></span><br><span class="line"><span class="meta">@RibbonClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderServiceClient</span> <span class="keyword">extends</span> <span class="title class_">OrderService</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;获取订单号&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/getOrderNo&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    BaseResponse&lt;OrderNoResVO&gt; <span class="title function_">getOrderNo</span><span class="params">(<span class="meta">@RequestBody</span> OrderNoReqVO orderNoReq)</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@FeignClient</code>这个注解要注意下，其中的name的是自己应用的应用名称，在<br><code>application.properties中的spring.application.name配置</code>。</p>
<p>其中继承了一个<code>OrderService</code>在<code>order-api</code>模块中，来看看<code>order-api</code>中的内容。</p>
<h2 id="order-api"><a href="#order-api" class="headerlink" title="order-api"></a>order-api</h2><p>其中也只有一个接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(&quot;订单服务API&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/orderService&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;获取订单号&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/getOrderNo&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    BaseResponse&lt;OrderNoResVO&gt; <span class="title function_">getOrderNo</span><span class="params">(<span class="meta">@RequestBody</span> OrderNoReqVO orderNoReq)</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个接口有两个目的。</p>
<ol>
<li>给真正的<code>controller</code>来进行实现。</li>
<li>给<code>client</code>接口进行继承。</li>
</ol>
<p>类关系如下:</p>
<p><img src="https://i.loli.net/2017/07/21/5970ea9544a8c.jpg" alt="05.jpg"></p>
<p>注解这些都没什么好说的，一看就懂。</p>
<h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><p><code>order</code>则是具体接口实现的模块，就和平时写<code>controller</code>一样。<br>来看看如何使用<code>client</code>进行声明式调用:</p>
<p>这次看看<code>sbc-user</code>这个项目，在里边调用了<code>sbc-order</code>的服务。<br>其中的<code>user模块</code>依赖了<code>order-client</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crossoverJie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>order-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OrderServiceClient orderServiceClient ;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;UserResVO&gt; <span class="title function_">getUserByFeign</span><span class="params">(<span class="meta">@RequestBody</span> UserReqVO userReq)</span> &#123;</span><br><span class="line">    <span class="comment">//调用远程服务</span></span><br><span class="line">    <span class="type">OrderNoReqVO</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderNoReqVO</span>() ;</span><br><span class="line">    vo.setReqNo(userReq.getReqNo());</span><br><span class="line">    BaseResponse&lt;OrderNoResVO&gt; orderNo = orderServiceClient.getOrderNo(vo);</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;远程返回:&quot;</span>+JSON.toJSONString(orderNo));</span><br><span class="line"></span><br><span class="line">    <span class="type">UserRes</span> <span class="variable">userRes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserRes</span>() ;</span><br><span class="line">    userRes.setUserId(<span class="number">123</span>);</span><br><span class="line">    userRes.setUserName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">    userRes.setReqNo(userReq.getReqNo());</span><br><span class="line">    userRes.setCode(StatusEnum.SUCCESS.getCode());</span><br><span class="line">    userRes.setMessage(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userRes ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到只需要将<code>order-client</code>包中的Order服务注入进来即可。</p>
<p>在<code>sbc-client</code>的<code>swagger</code>中进行调用:</p>
<p><img src="https://i.loli.net/2017/07/21/5970f0629211c.jpg" alt="06.jpg"></p>
<hr>
<p><img src="https://i.loli.net/2017/07/21/5970f0ae20e1f.jpg" alt="07.jpg"></p>
<p>由于我并没传<code>appId</code>所以<code>order</code>服务返回的错误。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>当一个应用需要对外暴露接口时着需要按照以上方式提供一个<code>client</code>包更消费者使用。</p>
</blockquote>
<p>其实应用本身也是需要做高可用的，和<code>Eureka</code>高可用一样，再不同的服务器上再启一个或多个服务并注册到<code>Eureka</code>集群中即可。</p>
<p>后续还会继续谈到<code>zuul网关，容错，断路器</code>等内容，欢迎拍砖讨论。</p>
<blockquote>
<p>项目：<a href="https://github.com/crossoverJie/springboot-cloud">https://github.com/crossoverJie/springboot-cloud</a></p>
</blockquote>
<blockquote>
<p>博客：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>sbc</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>SpringCloud</tag>
        <tag>swagger</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>sbc(四)应用限流</title>
    <url>/2017/08/11/sbc4/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/08/11/598c8c87529b1.jpeg" alt="pexels-photo-306198.jpeg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>在一个高并发系统中对流量的把控是非常重要的，当巨大的流量直接请求到我们的服务器上没多久就可能造成接口不可用，不处理的话甚至会造成整个应用不可用。</p>
</blockquote>
<p>比如最近就有个这样的需求，我作为客户端要向<code>kafka</code>生产数据，而<code>kafka</code>的消费者则再源源不断的消费数据，并将消费的数据全部请求到<code>web服务器</code>，虽说做了负载(有4台<code>web服务器</code>)但业务数据的量也是巨大的，每秒钟可能有上万条数据产生。如果生产者直接生产数据的话极有可能把<code>web服务器</code>拖垮。</p>
<p>对此就必须要做限流处理，每秒钟生产一定限额的数据到<code>kafka</code>，这样就能极大程度的保证<code>web</code>的正常运转。</p>
<p><strong>其实不管处理何种场景，本质都是降低流量保证应用的高可用。</strong></p>
<h1 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h1><p>对于限流常见有两种算法:</p>
<ul>
<li>漏桶算法</li>
<li>令牌桶算法</li>
</ul>
<p>漏桶算法比较简单，就是将流量放入桶中，漏桶同时也按照一定的速率流出，如果流量过快的话就会溢出(<code>漏桶并不会提高流出速率</code>)。溢出的流量则直接丢弃。</p>
<p>如下图所示:</p>
<p><img src="https://i.loli.net/2017/08/11/598c905caa8cb.png" alt="漏桶算法，来自网络.png"></p>
<span id="more"></span>

<p>这种做法简单粗暴。</p>
<p><code>漏桶算法</code>虽说简单，但却不能应对实际场景，比如突然暴增的流量。</p>
<p>这时就需要用到<code>令牌桶算法</code>:</p>
<p><code>令牌桶</code>会以一个恒定的速率向固定容量大小桶中放入令牌，当有流量来时则取走一个或多个令牌。当桶中没有令牌则将当前请求丢弃或阻塞。</p>
<p><img src="https://i.loli.net/2017/08/11/598c91f2a33af.gif" alt="令牌桶算法-来自网络.gif"></p>
<blockquote>
<p>相比之下令牌桶可以应对一定的突发流量.</p>
</blockquote>
<h1 id="RateLimiter实现"><a href="#RateLimiter实现" class="headerlink" title="RateLimiter实现"></a>RateLimiter实现</h1><p>对于令牌桶的代码实现，可以直接使用<code>Guava</code>包中的<code>RateLimiter</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;UserResVO&gt; <span class="title function_">getUserByFeignBatch</span><span class="params">(<span class="meta">@RequestBody</span> UserReqVO userReqVO)</span> &#123;</span><br><span class="line">    <span class="comment">//调用远程服务</span></span><br><span class="line">    <span class="type">OrderNoReqVO</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderNoReqVO</span>() ;</span><br><span class="line">    vo.setReqNo(userReqVO.getReqNo());</span><br><span class="line"></span><br><span class="line">    <span class="type">RateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">2.0</span>) ;</span><br><span class="line">    <span class="comment">//批量调用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">acquire</span> <span class="operator">=</span> limiter.acquire();</span><br><span class="line">        logger.debug(<span class="string">&quot;获取令牌成功!,消耗=&quot;</span> + acquire);</span><br><span class="line">        BaseResponse&lt;OrderNoResVO&gt; orderNo = orderServiceClient.getOrderNo(vo);</span><br><span class="line">        logger.debug(<span class="string">&quot;远程返回:&quot;</span>+JSON.toJSONString(orderNo));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">UserRes</span> <span class="variable">userRes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserRes</span>() ;</span><br><span class="line">    userRes.setUserId(<span class="number">123</span>);</span><br><span class="line">    userRes.setUserName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">    userRes.setReqNo(userReqVO.getReqNo());</span><br><span class="line">    userRes.setCode(StatusEnum.SUCCESS.getCode());</span><br><span class="line">    userRes.setMessage(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userRes ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/crossoverJie/springboot-cloud/blob/master/sbc-user/user/src/main/java/com/crossoverJie/sbcuser/controller/UserController.java#L82:L105">详见此</a>。</p>
<p>调用结果如下:</p>
<p><img src="https://i.loli.net/2017/08/11/598c960f8983f.jpg" alt="1.jpg"></p>
<p>代码可以看出以每秒向桶中放入两个令牌，请求一次消耗一个令牌。所以每秒钟只能发送两个请求。按照图中的时间来看也确实如此(返回值是获取此令牌所消耗的时间，差不多也是每500ms一个)。</p>
<p>使用<code>RateLimiter </code>有几个值得注意的地方:</p>
<p>允许<code>先消费，后付款</code>，意思就是它可以来一个请求的时候一次性取走几个或者是剩下所有的令牌甚至多取，但是后面的请求就得为上一次请求买单，它需要等待桶中的令牌补齐之后才能继续获取令牌。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>针对于单个应用的限流 <code>RateLimiter</code> 够用了，如果是分布式环境可以借助 <code>Redis</code> 来完成。</p>
<p>最近也怼了一个，可以<a href="https://crossoverjie.top/2018/04/28/sbc/sbc7-Distributed-Limit/">参考</a>。</p>
<blockquote>
<p>项目：<a href="https://github.com/crossoverJie/springboot-cloud">https://github.com/crossoverJie/springboot-cloud</a></p>
</blockquote>
<blockquote>
<p>博客：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>sbc</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>SpringCloud</tag>
        <tag>RateLimiter</tag>
      </tags>
  </entry>
  <entry>
    <title>sbc(六) Zuul GateWay 网关应用</title>
    <url>/2017/11/28/sbc6/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1ba39cdcae.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看过之前<a href="https://crossoverjie.top/categories/sbc/">SBC</a>系列的小伙伴应该都可以搭建一个高可用、分布式的微服务了。 目前的结构图应该如下所示:<br><img src="https://i.loli.net/2019/05/08/5cd1ba3dcabb9.jpg"></p>
<p>各个微服务之间都不存在单点，并且都注册于 <code>Eureka</code> ，基于此进行服务的注册于发现，再通过 <code>Ribbon</code> 进行服务调用，并具有客户端负载功能。</p>
<p>一切看起来都比较美好，但这里却忘了一个重要的细节：</p>
<blockquote>
<p>当我们需要对外提供服务时怎么处理？</p>
</blockquote>
<p>这当然也能实现，无非就是将我们具体的微服务地址加端口暴露出去即可。</p>
<p>那又如何来实现负载呢？</p>
<p>简单！可以通过 <code>Nginx F5</code> 之类的工具进行负载。</p>
<p>但是如果系统庞大，服务拆分的足够多那又有谁来维护这些路由关系呢？</p>
<p>当然这是运维的活，不过这时候运维可能就要发飙了！</p>
<p>并且还有一系列的问题:</p>
<ul>
<li>服务调用之间的一些鉴权、签名校验怎么做？</li>
<li>由于服务端地址较多，客户端请求难以维护。</li>
</ul>
<p>针对于这一些问题 <code>SpringCloud</code> 全家桶自然也有对应的解决方案: <code>Zuul</code>。<br>当我们系统整合 Zuul 网关之后架构图应该如下所示:</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba42d4349.jpg"></p>
<span id="more"></span>

<p>我们在所有的请求进来之前抽出一层网关应用，将服务提供的所有细节都进行了包装，这样所有的客户端都是和网关进行交互，简化了客户端开发。</p>
<p>同时具有如下功能:</p>
<ul>
<li>Zuul 注册于 <code>Eureka</code> 并集成了 <code>Ribbon</code> 所以自然也是可以从注册中心获取到服务列表进行客户端负载。</li>
<li>功能丰富的路由功能，解放运维。</li>
<li>具有过滤器，所以鉴权、验签都可以集成。</li>
</ul>
<p>基于此我们来看看之前的架构中如何集成 <code>Zuul</code> 。</p>
<h1 id="集成-Zuul"><a href="#集成-Zuul" class="headerlink" title="集成 Zuul"></a>集成 Zuul</h1><p>为此我新建了一个项目 <code>sbc-gateway-zuul</code> 就是一个基础的 <code>SpringBoot</code> 结构。其中加入了 Zuul 的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于需要将网关也注册到 <code>Eureka</code> 中，所以自然也需要:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>紧接着配置一些项目基本信息:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 项目配置</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">sbc-gateway-zuul</span></span><br><span class="line"><span class="attr">server.context-path</span>=<span class="string">/</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8383</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># eureka地址</span></span><br><span class="line"><span class="attr">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://node1:8888/eureka/</span></span><br><span class="line"><span class="attr">eureka.instance.prefer-ip-address</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>在启动类中加入开启 <code>Zuul</code> 的注解，一个网关应用就算是搭好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开启zuul代理</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SbcGateWayZuulApplication</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动 <code>Eureka</code> 和网关看到已经注册成功那就大功告成了:</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba46868f3.jpg"></p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>路由是网关的核心功能之一，可以使系统有一个统一的对外接口，下面来看看具体的应用。</p>
<h2 id="传统路由"><a href="#传统路由" class="headerlink" title="传统路由"></a>传统路由</h2><p>传统路由非常简单，和 <code>Nginx</code> 类似，由开发、运维人员来维护请求地址和对应服务的映射关系，类似于:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul.routes.user-service.path</span>=<span class="string">/user-service/**</span></span><br><span class="line"><span class="attr">zuul.routes.user-sercice.url</span>=<span class="string">http://localhost:8080/</span></span><br></pre></td></tr></table></figure>

<p>这样当我们访问 <code>http://localhost:8383/user-service/getUserInfo/1</code> 网关就会自动给我们路由到 <code>http://localhost:8080/getUserInfo/1</code> 上。</p>
<p>可见只要我们维护好这个映射关系即可自由的配置路由信息(<code>user-sercice 可自定义</code>)，但是很明显这种方式不管是对运维还是开发都不友好。由于实际这种方式用的不多就再过多展开。</p>
<h2 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h2><p>对此 <code>Zuul</code> 提供了一种基于服务的路由方式。我们只需要维护请求地址与服务 ID 之间的映射关系即可，并且由于集成了 <code>Ribbon</code> , Zuul 还可以在路由的时候通过 Eureka 实现负载调用。</p>
<p>具体配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul.routes.sbc-user.path</span>=<span class="string">/api/user/**</span></span><br><span class="line"><span class="attr">zuul.routes.sbc-user.serviceId</span>=<span class="string">sbc-user</span></span><br></pre></td></tr></table></figure>

<p>这样当输入 <code>http://localhost:8383/api/user/getUserInfo/1</code> 时就会路由到注册到 <code>Eureka</code> 中服务 ID 为 <code>sbc-user</code> 的服务节点，如果有多节点就会按照 Ribbon 的负载算法路由到其中一台上。</p>
<p>以上配置还可以简写为:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务路由 简化配置</span></span><br><span class="line"><span class="attr">zuul.routes.sbc-user</span>=<span class="string">/api/user/**</span></span><br></pre></td></tr></table></figure>

<p>这样让我们访问 <code>http://127.0.0.1:8383/api/user/userService/getUserByHystrix</code> 时候就会根据负载算法帮我们路由到 sbc-user 应用上，如下图所示:</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba4f53176.jpg"><br>启动了两个 sbc-user 服务。</p>
<p>请求结果:<br><img src="https://i.loli.net/2019/05/08/5cd1ba5622036.jpg"></p>
<p>一次路由就算完成了。</p>
<p>在上面的配置中有看到 <code>/api/user/**</code> 这样的通配符配置，具体有以下三种配置需要了解:</p>
<ul>
<li><code>?</code> 只能匹配任意的单个字符，如 <code>/api/user/?</code> 就只能匹配 <code>/api/user/x  /api/user/y /api/user/z</code> 这样的路径。</li>
<li><code>*</code> 只能匹配任意字符，如 <code>/api/user/*</code> 就只能匹配 <code>/api/user/x /api/user/xy /api/user/xyz</code>。</li>
<li><code>**</code> 可以匹配任意字符、任意层级。结合了以上两种通配符的特点，如 <code>/api/user/**</code> 则可以匹配 <code>/api/user/x /api/user/x/y /api/user/x/y/zzz </code>这样的路径，最简单粗暴！</li>
</ul>
<p>谈到通配符匹配就不得不提到一个问题，如上面的 <code>sbc-user</code> 服务由于后期迭代更新，将 sbc-user 中的一部分逻辑抽成了另一个服务 <code>sbc-user-pro</code>。新应用的路由规则是 <code>/api/user/pro/**</code>,如果我们按照:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul.routes.sbc-user</span>=<span class="string">/api/user/**</span></span><br><span class="line"><span class="attr">zuul.routes.sbc-user-pro</span>=<span class="string">/api/user/pro/**</span></span><br></pre></td></tr></table></figure>

<p>进行配置的话，我们想通过 <code>/api/user/pro/</code> 来访问 <code>sbc-user-pro</code> 应用，却由于满足第一个路由规则，所以会被 Zuul 路由到 <code>sbc-user</code> 这个应用上，这显然是不对的。该怎么解决这个问题呢？</p>
<p>翻看路由源码 <code>org.springframework.cloud.netflix.zuul.filters.SimpleRouteLocator</code> 中的 <code>locateRoutes()</code> 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Compute a map of path pattern to route. The default is just a static map from the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ZuulProperties&#125;, but subclasses can add dynamic calculations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, ZuulRoute&gt; <span class="title function_">locateRoutes</span><span class="params">()</span> &#123;</span><br><span class="line">	LinkedHashMap&lt;String, ZuulRoute&gt; routesMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, ZuulRoute&gt;();</span><br><span class="line">	<span class="keyword">for</span> (ZuulRoute route : <span class="built_in">this</span>.properties.getRoutes().values()) &#123;</span><br><span class="line">		routesMap.put(route.getPath(), route);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> routesMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现路由规则是遍历配置文件并放入 <strong><code>LinkedHashMap</code></strong> 中，由于 <code>LinkedHashMap</code> 是有序的，所以为了达到上文的效果，配置文件的加载顺序非常重要，因此我们只需要将优先匹配的路由规则放前即可解决。</p>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>过滤器可以说是整个 Zuul 最核心的功能，包括上文提到路由功能也是由过滤器来实现的。</p>
<p>摘抄官方的解释: Zuul 的核心就是一系列的过滤器，他能够在整个 <code>HTTP</code> 请求、响应过程中执行各样的操作。</p>
<p>其实总结下来就是四个特征:</p>
<ul>
<li>过滤类型</li>
<li>过滤顺序</li>
<li>执行条件</li>
<li>具体实现</li>
</ul>
<p>其实就是 <code>ZuulFilter</code> 接口中所定义的四个接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String filterType();</span><br><span class="line"></span><br><span class="line">int filterOrder();</span><br><span class="line"></span><br><span class="line">boolean shouldFilter();</span><br><span class="line"></span><br><span class="line">Object run();</span><br></pre></td></tr></table></figure>

<p>官方流程图(生命周期):</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba5d01b56.jpg"></p>
<p>简单理解下就是:</p>
<p>当一个请求进来时，首先是进入 <code>pre</code> 过滤器，可以做一些鉴权，记录调试日志等操作。之后进入 <code>routing</code> 过滤器进行路由转发，转发可以使用 <code>Apache HttpClient</code> 或者是 <code>Ribbon</code> 。<br><code>post</code> 过滤器呢则是处理服务响应之后的数据，可以进行一些包装来返回客户端。 <code>error</code> 则是在有异常发生时才会调用，相当于是全局异常拦截器。</p>
<h2 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h2><p>接下来实现一个文初所提到的鉴权操作:</p>
<p>新建一个 <code>RequestFilter</code> 类继承与 <code>ZuulFilter</code> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function: 请求拦截</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> crossoverJie</span></span><br><span class="line"><span class="comment"> *         Date: 2017/11/20 00:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestFilter</span> <span class="keyword">extends</span> <span class="title class_">ZuulFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(RequestFilter.class) ;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求路由之前被拦截 实现 pre 拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RequestContext</span> <span class="variable">currentContext</span> <span class="operator">=</span> RequestContext.getCurrentContext();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> currentContext.getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isEmpty(token))&#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;need token&quot;</span>);</span><br><span class="line">            <span class="comment">//过滤请求</span></span><br><span class="line">            currentContext.setSendZuulResponse(<span class="literal">false</span>);</span><br><span class="line">            currentContext.setResponseStatusCode(<span class="number">400</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;token =&#123;&#125;&quot;</span>,token) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常 easy，就简单校验下请求中是否包含 <code>token</code>，不包含就返回 401 code。</p>
<p>不但如此，还需要将该类加入到 Spring 进行管理:</p>
<p>新建了 <code>FilterConf</code> 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterConf</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestFilter <span class="title function_">filter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">RequestFilter</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样重启之后就可以看到效果了:</p>
<p>不传 token 时：<br><img src="https://i.loli.net/2019/05/08/5cd1ba6029eb8.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba63013ca.jpg"></p>
<p>传入 token 时：<br><img src="https://i.loli.net/2019/05/08/5cd1ba6549e97.jpg"></p>
<p>可见一些鉴权操作是可以放到这里来进行统一处理的。</p>
<p>其余几个过滤器也是大同小异，可以根据实际场景来自定义。</p>
<h1 id="Zuul-高可用"><a href="#Zuul-高可用" class="headerlink" title="Zuul 高可用"></a>Zuul 高可用</h1><p>Zuul 现在既然作为了对外的第一入口，那肯定不能是单节点，对于 Zuul 的高可用有以下两种方式实现。</p>
<h2 id="Eureka-高可用"><a href="#Eureka-高可用" class="headerlink" title="Eureka 高可用"></a>Eureka 高可用</h2><p>第一种最容易想到和实现:<br>我们可以部署多个 Zuul 节点，并且都注册于 Eureka ，如下图：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba6b04b33.jpg"></p>
<p>这样虽然简单易维护，但是有一个严重的缺点：那就是客户端也得注册到 Eureka 上才能对 Zuul 的调用做到负载，这显然是不现实的。</p>
<p>所以下面这种做法更为常见。</p>
<h2 id="基于-Nginx-高可用"><a href="#基于-Nginx-高可用" class="headerlink" title="基于 Nginx 高可用"></a>基于 Nginx 高可用</h2><p>在调用 Zuul 之前使用 Nginx 之类的负载均衡工具进行负载，这样 Zuul 既能注册到 Eureka ，客户端也能实现对 Zuul 的负载，如下图：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba6f3a9e8.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这样在原有的微服务架构的基础上加上网关之后另整个系统更加完善了，从网关的设计来看：大多数系统架构都有分层的概念，不能解决问题那就多分几层🤓。</p>
<blockquote>
<p>项目：<a href="https://github.com/crossoverJie/springboot-cloud">https://github.com/crossoverJie/springboot-cloud</a></p>
</blockquote>
<blockquote>
<p>博客：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>sbc</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>SpringCloud</tag>
        <tag>Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>sbc(五)Hystrix-服务容错与保护</title>
    <url>/2017/09/20/sbc5/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1ba8f8f39f.jpg" alt="1"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看过 <a href="http://crossoverjie.top/2017/08/11/sbc4/">应用限流</a>的朋友应该知道，限流的根本目的就是为了保障服务的高可用。</p>
<p>本次再借助<code>SpringCloud</code>中的集成的<code>Hystrix</code>组件来谈谈服务容错。</p>
<p>其实产生某项需求的原因都是为了解决某个需求。当我们将应用进行分布式模块部署之后,各个模块之间通过远程调用的方式进行交互(<code>RPC</code>)。拿我们平时最常见的下单买商品来说，点击下单按钮的一瞬间可能会向发送的请求包含：</p>
<ul>
<li>请求订单系统创建订单。</li>
<li>请求库存系统扣除库存。</li>
<li>请求用户系统更新用户交易记录。</li>
</ul>
<p>这其中的每一步都有可能因为网络、资源、服务器等原因造成延迟响应甚至是调用失败。当后面的请求源源不断的过来时延迟的资源也没有的到释放，这样的堆积很有可能把其中一个模块拖垮，其中的依赖关系又有可能把整个调用链中的应用Over最后导致整个系统不可能。这样就会产生一种现象:<code>雪崩效应</code>。</p>
<p>之前讲到的限流也能起到一定的保护作用，但还远远不够。我们需要从各个方面来保障服务的高可用。</p>
<p>比如：</p>
<ul>
<li>超时重试。</li>
<li>断路器模式。</li>
<li>服务降级。<br>等各个方面来保障。</li>
</ul>
<span id="more"></span>

<h1 id="使用Hystrix"><a href="#使用Hystrix" class="headerlink" title="使用Hystrix"></a>使用Hystrix</h1><p><code>SpringCloud</code>中已经为我们集成了<code>Netflix</code>开源的<code>Hystrix</code>框架，使用该框架可以很好的帮我们做到服务容错。</p>
<h2 id="Hystrix简介"><a href="#Hystrix简介" class="headerlink" title="Hystrix简介"></a>Hystrix简介</h2><p>下面是一张官方的流程图:</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba9465427.jpg"></p>
<p>简单介绍下:</p>
<blockquote>
<p>在远程调用时，将请求封装到HystrixCommand进行同步或是异步调用，在调用过程中判断熔断器是否打开、线程池或是信号量是否饱和、执行过程中是否抛出异常，如果是的话就会进入回退逻辑。并且整个过程中都会收集运行状态来控制断路器的状态。</p>
</blockquote>
<p>不但如此该框架还拥有自我恢复功能，当断路器打开后，每次请求都会进入回退逻辑。当我们的应用恢复正常后也不能再进入回退逻辑吧。</p>
<p>所以<code>hystrix</code>会在断路器打开后的一定时间将请求发送到服务提供者，如果正常响应就关闭断路器，反之则继续打开，这样就能很灵活的自我修复了。</p>
<h2 id="Feign整合Hystrix"><a href="#Feign整合Hystrix" class="headerlink" title="Feign整合Hystrix"></a>Feign整合Hystrix</h2><p>在之前的章节中已经使用<code>Feign</code>来进行声明式调用了，并且在实际开发中也是如此，所以这次我们就直接用Feign来整合Hystrix。</p>
<p>使用了项目原有的<code>sbc-user,sbc-order</code>来进行演示，调用关系如下图:</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba961dd9c.jpg"></p>
<p><code>User应用</code>通过<code>Order</code>提供出来的<code>order-client</code>依赖调用了<code>Order</code>中的创建订单服务。</p>
<p>其中主要修改的就是<code>order-client</code>，在之前的<code>OrderServiceClient</code>接口中增加了以下注解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/orderService&quot;)</span></span><br><span class="line"><span class="meta">@FeignClient(name=&quot;sbc-order&quot;,</span></span><br><span class="line"><span class="meta">        // fallbackFactory = OrderServiceFallbackFactory.class,</span></span><br><span class="line"><span class="meta">        // FIXME: 2017/9/4 如果配置了fallback 那么fallbackFactory将会无效</span></span><br><span class="line"><span class="meta">        fallback = OrderServiceFallBack.class,</span></span><br><span class="line"><span class="meta">        configuration = OrderConfig.class)</span></span><br><span class="line"><span class="meta">@RibbonClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderServiceClient</span> <span class="keyword">extends</span> <span class="title class_">OrderService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;获取订单号&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/getOrderNo&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    BaseResponse&lt;OrderNoResVO&gt; <span class="title function_">getOrderNo</span><span class="params">(<span class="meta">@RequestBody</span> OrderNoReqVO orderNoReq)</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Feign已经默认整合了<code>Hystrix</code>所以不需要再额外加入依赖。</p>
<h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>对应的<code>@FeignClient中的fallback属性</code>则是服务容错中很关键的服务降级的具体实现，来看看<code>OrderServiceFallBack</code>类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceFallBack</span> <span class="keyword">implements</span> <span class="title class_">OrderServiceClient</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BaseResponse&lt;OrderNoResVO&gt; <span class="title function_">getOrderNo</span><span class="params">(<span class="meta">@RequestBody</span> OrderNoReqVO orderNoReq)</span> &#123;</span><br><span class="line">        BaseResponse&lt;OrderNoResVO&gt; baseResponse = <span class="keyword">new</span> <span class="title class_">BaseResponse</span>&lt;&gt;() ;</span><br><span class="line">        <span class="type">OrderNoResVO</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderNoResVO</span>() ;</span><br><span class="line">        vo.setOrderId(<span class="number">123456L</span>);</span><br><span class="line">        baseResponse.setDataBody(vo);</span><br><span class="line">        baseResponse.setMessage(StatusEnum.FALLBACK.getMessage());</span><br><span class="line">        baseResponse.setCode(StatusEnum.FALLBACK.getCode());</span><br><span class="line">        <span class="keyword">return</span> baseResponse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类实现了<code>OrderServiceClient</code>接口，可以很明显的看出其中的<code>getOrderNo()</code>方法就是服务降级时所触发的逻辑。</p>
<p>光有实现还不够，我们需要将改类加入到<code>Spring</code>中管理起来。这样上文中<code>@FeignClient</code>的<code>configuration</code>属性就起到作用了，来看看对应的<code>OrderConfig</code>的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OrderServiceFallBack <span class="title function_">fallBack</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderServiceFallBack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OrderServiceFallbackFactory <span class="title function_">factory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderServiceFallbackFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>new OrderServiceFallBack()</code>并用了<code>@Bean</code>注解，等同于:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;orderServiceFallBack&quot; class=&quot;com.crossoverJie.order.feign.config.OrderServiceFallBack&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>这样每当请求失败就会执行回退逻辑，如下图:<br><img src="https://i.loli.net/2019/05/08/5cd1ba9c7c388.jpg"></p>
<p>值得注意的是即便是执行了回退逻辑断路器也不一定打开了，我们可以通过应用的<code>health</code>端点来查看<code>Hystrix</code>的状态。</p>
<p>ps:想要查看该端点需要加入以下依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就拿刚才的例子来说，先关闭<code>Order</code>应用，在<code>Swagger</code>访问下面这个接口，肯定是会进入回退逻辑:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(&quot;用户服务API&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/userService&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;hystrix容错调用&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/getUserByHystrix&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    BaseResponse&lt;OrderNoResVO&gt; <span class="title function_">getUserByHystrix</span><span class="params">(<span class="meta">@RequestBody</span> UserReqVO userReqVO)</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>health</code>端点:</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1baa68a4a0.jpg"><br>发现<code>Hystrix</code>的状态依然是UP状态，表明当前断路器并没有打开。</p>
<p>反复调用多次接口之后再次查看<code>health</code>端点:<br><img src="https://i.loli.net/2019/05/08/5cd1baaba6f4a.jpg"></p>
<p>发现这个时候断路器已经打开了。</p>
<blockquote>
<p>这是因为断路器只有在达到了一定的失败阈值之后才会打开。</p>
</blockquote>
<h2 id="输出异常"><a href="#输出异常" class="headerlink" title="输出异常"></a>输出异常</h2><p>进入回退逻辑之后还不算完，大部分场景我们都需要记录为什么回退，也就是具体的异常。这些信息对我们后续的系统监控，应用调优也有很大帮助。</p>
<p>实现起来也很简单:<br>上文中在<code>@FeignClient</code>注解中加入的<code>fallbackFactory = OrderServiceFallbackFactory.class</code>属性则是用于处理回退逻辑以及包含异常信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function:查看fallback原因</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> crossoverJie</span></span><br><span class="line"><span class="comment"> *         Date: 2017/9/4 00:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;OrderServiceClient&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(OrderServiceFallbackFactory.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OrderServiceClient <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderServiceClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> BaseResponse&lt;OrderNoResVO&gt; <span class="title function_">getOrderNo</span><span class="params">(<span class="meta">@RequestBody</span> OrderNoReqVO orderNoReq)</span> &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;fallback:&quot;</span> + throwable);</span><br><span class="line"></span><br><span class="line">                BaseResponse&lt;OrderNoResVO&gt; baseResponse = <span class="keyword">new</span> <span class="title class_">BaseResponse</span>&lt;&gt;() ;</span><br><span class="line">                <span class="type">OrderNoResVO</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderNoResVO</span>() ;</span><br><span class="line">                vo.setOrderId(<span class="number">123456L</span>);</span><br><span class="line">                baseResponse.setDataBody(vo);</span><br><span class="line">                baseResponse.setMessage(StatusEnum.FALLBACK.getMessage());</span><br><span class="line">                baseResponse.setCode(StatusEnum.FALLBACK.getCode());</span><br><span class="line">                <span class="keyword">return</span> baseResponse;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，实现了<code>FallbackFactory</code>接口中的<code>create()</code>方法，该方法的入参就是异常信息，可以按照我们的需要自行处理，后面则是和之前一样的回退处理。</p>
<p><code>2017-09-21 13:22:30.307 ERROR 27838 --- [rix-sbc-order-1] c.c.o.f.f.OrderServiceFallbackFactory    : fallback:java.lang.RuntimeException: com.netflix.client.ClientException: Load balancer does not have available server for client: sbc-order </code>。</p>
<p><strong>Note</strong>:</p>
<p><code>fallbackFactory</code>和<code>fallback</code>属性不可共用。</p>
<h1 id="Hystrix监控"><a href="#Hystrix监控" class="headerlink" title="Hystrix监控"></a>Hystrix监控</h1><p>Hystrix还自带了一套监控组件，只要依赖了<code>spring-boot-starter-actuator</code>即可通过<code>/hystrix.stream</code>端点来获得监控信息。<br><img src="https://i.loli.net/2019/05/08/5cd1babaa3ad3.jpg"></p>
<p>冰冷的数据肯定没有实时的图表来的直观，所以<code>Hystrix</code>也自带<code>Dashboard</code>。</p>
<h2 id="Hystrix与Turbine聚合监控"><a href="#Hystrix与Turbine聚合监控" class="headerlink" title="Hystrix与Turbine聚合监控"></a>Hystrix与Turbine聚合监控</h2><p>为此我们新建了一个应用<code>sbc-hystrix-turbine</code>来显示<code>hystrix-dashboard</code>。<br>目录结构和普通的<code>springboot</code>应用没有差异，看看主类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启EnableTurbine</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableTurbine</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SbcHystrixTurbineApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(SbcHystrixTurbineApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中使用<code>@EnableHystrixDashboard</code>开启<code>Dashboard</code></li>
<li><code>@EnableTurbine</code>开启<code>Turbine</code>支持。</li>
</ul>
<p>以上这些注解需要以下这些依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际项目中，我们的应用都是多节点部署以达到高可用的目的，单个监控显然不现实，所以需要使用Turbine来进行聚合监控。</p>
</blockquote>
<p>关键的<code>application.properties</code>配置文件:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 项目配置</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">sbc-hystrix-trubine</span></span><br><span class="line"><span class="attr">server.context-path</span>=<span class="string">/</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8282</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># eureka地址</span></span><br><span class="line"><span class="attr">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://node1:8888/eureka/</span></span><br><span class="line"><span class="attr">eureka.instance.prefer-ip-address</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 需要加入的实例</span></span><br><span class="line"><span class="attr">turbine.appConfig</span>=<span class="string">sbc-user,sbc-order</span></span><br><span class="line"><span class="attr">turbine.cluster-name-expression</span>=<span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中<code>turbine.appConfig</code>配置我们需要监控的应用，这样当多节点部署的时候就非常方便了(<code>同一个应用的多个节点spring.application.name值是相同的</code>)。</p>
<p>将该应用启动访问<code>http://ip:port/hystrix.stream</code>：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1babf06bd4.jpg"></p>
<p>由于我们的turbine和Dashboard是一个应用所以输入<code>http://localhost:8282/turbine.stream</code>即可。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bac102a95.jpg"></p>
<p>详细指标如官方描述:<br><img src="https://i.loli.net/2019/05/08/5cd1bacaa0788.jpg"></p>
<p>通过该面板我们就可以及时的了解到应用当前的各个状态，如果再加上一些报警措施就能帮我们及时的响应生产问题。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>服务容错的整个还是比较大的,博主也是摸着石头过河，关于本次的<code>Hystrix</code>只是一个入门版，后面会持续分析它的线程隔离、信号量隔离等原理。</p>
<blockquote>
<p>项目：<a href="https://github.com/crossoverJie/springboot-cloud">https://github.com/crossoverJie/springboot-cloud</a></p>
</blockquote>
<blockquote>
<p>博客：<a href="http://crossoverjie.top/">http://crossoverjie.top</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>sbc</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>SpringCloud</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】你可以用GitHub做的12件 Cool 事情</title>
    <url>/2017/11/05/translation1-12%20cool%20things%20you%20can%20do%20with%20GitHub/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1ba387b5a8.jpg"></p>
<h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://hackernoon.com/12-cool-things-you-can-do-with-github-f3e0424cf2f0">原文链接</a></h3><h2 id="1-在-GitHub-com-编辑代码"><a href="#1-在-GitHub-com-编辑代码" class="headerlink" title="1 在 GitHub.com 编辑代码"></a>1 在 GitHub.com 编辑代码</h2><p>我将从我认为大家都知道的一件事情开始(尽管我是直到一周前才知道)。</p>
<p>当你在 GitHub 查看文件时(任何文本文件，任何仓库中)，右上角会有一个小铅笔图标，点击它就可以编辑文件了。完成之后点击 <strong>Propose file change</strong> 按钮 GitHub 将会自动帮你 fork 该项目并且创建一个 <code>pull request</code> 。</p>
<p>很厉害吧！他自动帮你 <code>fork</code> 了该 repo。</p>
<p>不再需要 <code>fork</code> , <code>pull</code> ,本地编辑再 <code>push</code> 以及创建一个 <code>PR</code> 这样的流程了。<br><img src="https://i.loli.net/2019/05/08/5cd1ba3b3e25e.jpg"></p>
<p>这非常适合修复编写代码中出现的拼写错误和修正一个不太理想的想法。</p>
<h2 id="2-粘贴图片"><a href="#2-粘贴图片" class="headerlink" title="2 粘贴图片"></a>2 粘贴图片</h2><p>你不仅仅受限于输入文本和描述问题，你知道你可以直接从粘贴板中粘贴图片吗？当你粘贴时，你会看到图片已经被上传了(毫无疑问被上传到云端)之后会变成 <code>Markdown</code> 语法来显示图片。</p>
<h2 id="3-格式化代码"><a href="#3-格式化代码" class="headerlink" title="3 格式化代码"></a>3 格式化代码</h2><p>如果你想写一段代码，你可以三个反引号开始 —— 就像你在<a href="https://guides.github.com/features/mastering-markdown/">研究<code>MarkDown</code></a>时所学到的 —— 之后 GitHub 会试着猜测你写的语言。</p>
<p>但如果你写了一些类似于 Vue, Typescript, JSX 这样的语言，你可以明确指定得到正确的高亮。</p>
<p>注意第一行中的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```jsx</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/05/08/5cd1ba3eac6e5.jpg"></p>
<span id="more"></span>

<p>这意味着代码段将会呈现出:</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba43b2edd.jpg"></p>
<p>(这个扩展于 <code>gists</code> 。顺便说一句，如果你使用 <code>.jsx</code> 后缀，就会得到JSX的语法高亮)</p>
<p>这是一个所有受支持的<a href="https://github.com/github/linguist/blob/fc1404985abb95d5bc33a0eba518724f1c3c252e/vendor/README.md">语法列表</a>。</p>
<h2 id="4-在-PR-中用关键词关闭-Issues"><a href="#4-在-PR-中用关键词关闭-Issues" class="headerlink" title="4 在 PR 中用关键词关闭 Issues"></a>4 在 PR 中用关键词关闭 Issues</h2><p>假设你创建了一个用于修复 <code>Issues #234</code> 的 PR ,你可以在你 PR 的描述中填写 <code>fixes #234</code> (或是在你 PR 任意评论中填写都是可以的)。<br>之后合并这个 <code>PR</code> 时将会自动关闭填写的 <code>Issues</code>。怎么样,很 cool 吧。</p>
<p>了解是更多相关的<a href="https://help.github.com/articles/closing-issues-using-keywords/">内容</a>。</p>
<h2 id="5-链接到评论"><a href="#5-链接到评论" class="headerlink" title="5 链接到评论"></a>5 链接到评论</h2><p>你是否有过想要链接到特殊 <code>comment </code> 的想法但却无法实现？那是因为你不知道怎么做。朋友那都是过去式了，现在我就告诉你，点击用户名旁边的日期&#x2F;时间即可链接到该 <code>comment </code> 。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba48b96bc.jpg"></p>
<h2 id="6-链接到代码"><a href="#6-链接到代码" class="headerlink" title="6 链接到代码"></a>6 链接到代码</h2><p>我知道你想链接到具体的代码行上。</p>
<p>尝试:查看文件时，点击代码旁边的行号。</p>
<p>看到了吧，浏览器的 <code>URL</code> 已经被更新为行号了。如果你按住 <code>shift</code>,同时点击其他行号，<code>URL</code> 再次被更新，并且你也高亮显示页面中的一段代码。</p>
<p>分享这个 URL ，访问时将会链接到该文件已经选中的那些代码段。</p>
<p>但等一下，那指向的是当前的分支，如果文件发生了改变呢？也许一个在当前状态连接到文件的永久连接正是你想要的。</p>
<p>我很懒，所以用一张截图展示以上的所有操作。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba54a2c40.jpg"></p>
<p>谈到网址。。。</p>
<h2 id="7-像命令行一样使用-GitHub-链接"><a href="#7-像命令行一样使用-GitHub-链接" class="headerlink" title="7 像命令行一样使用 GitHub 链接"></a>7 像命令行一样使用 GitHub 链接</h2><p>使用 GitHub 自带的 UI 浏览也还不错，但有时直接在 URL 中输入是最快的方法。比如，我想跳转到我正在编辑的分支并和 <code>master</code> 进行对比，就可以在项目名称后面接上 <code>/compare/branch-name</code> 。</p>
<p>与选中分支的对比页将会显示出来:<br><img src="https://i.loli.net/2019/05/08/5cd1ba58ca3f5.jpg"></p>
<p>以上就是和 master 分支的差异，如果想要合并分支的话，只需要输入 <code>/compare/integration-branch...my-branch </code> 即可。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba5c3e3e1.jpg"></p>
<p>你还可以利用快捷键达到同样的效果，使用 <code>ctrl + L</code> 或者 <code>cmd + L</code> 可以将光标移动到 <code>URL</code> 上(至少在 Chrome 中可以)。 加上浏览器的自动补全 —— 你就可以在两个分支之间轻松切换了。</p>
<h2 id="8-在Issues创建列表"><a href="#8-在Issues创建列表" class="headerlink" title="8 在Issues创建列表"></a>8 在Issues创建列表</h2><p>你想在你的 issue 中看到复选框列表吗?</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba5e4f661.jpg"></p>
<p>你想在查看 issue 列表是它们以好看的 <code>2 of 5</code> 进度条呈现吗？</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba612afad.jpg"></p>
<p>太好了！你可以用以下语法来创建一个交互性的复选框:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [ ] Screen width (integer)</span><br><span class="line">- [x] Service worker support</span><br><span class="line">- [x] Fetch support</span><br><span class="line">- [ ] CSS flexbox support</span><br><span class="line">- [ ] Custom elements</span><br></pre></td></tr></table></figure>

<p>是由一个空格、中横线、空格、左括号、空格(或者是 X )、右括号、空格以及一些文本组成。</p>
<p>你甚至可以真正的 选中&#x2F;取消 这些复选框！基于某些原因，对于我来说你看起来像是技术魔力。是真的能够选中这些复选框！甚至它还更新了底层源码。</p>
<blockquote>
<p>ps：以下包括第九点 基于GitHub的项目面板 由于用的不多就没有翻译。</p>
</blockquote>
<h2 id="10-GitHub-wiki"><a href="#10-GitHub-wiki" class="headerlink" title="10 GitHub wiki"></a>10 GitHub wiki</h2><p>作为一个像维基百科那样的非结构化的页面集合， <code>GitHub Wiki</code>的供给(我把它称之为 <code>Gwiki</code> ) 是一个非常棒的功能。</p>
<p>对于结构化的页面来说 —— 例如你的文档：不能说这个页面是其他页面的子页面，或则是有 “下一节”，“上一节” 这样的便捷按钮。并且 <code>Hansel</code> 和 <code>Gretel</code> 也没有，因为结构化页面并没有 <code>breadcrumbs</code> 这样的设计。</p>
<p>我们继续，让 Gwiki 动起来，我从 <code>NodeJS</code> 的文档中复制了几页来作为 wiki 页面。然后创建了一个自定义侧边栏，帮助我更好地模拟一些实际的目录结构。尽管它不会突出显示你当前的页面位置，但侧边栏会一直存在。</p>
<p>这些链接需要你手动维护，但总的来说，我认为它可以做得很好。 如果需要的话可以<a href="https://github.com/davidgilbertson/about-github/wiki">看看</a>。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba6b987b2.jpg"></p>
<p>虽然它与 <code>GitBook</code> ( <a href="http://redux.js.org/">Redux 文档</a>所使用的)或者是定制网站相比仍有差距。但在你的 repo 中它有 80% 完全值得信赖的。</p>
<p>我的建议是: 如果你已经有多个 <code>README.md</code> 文件，并且想要一些关于用户指南或更详细的文档的不同的页面，那么你应该选择 <code>Gwiki</code>。</p>
<p>如果缺乏结构化&#x2F;导航开始让你不爽的话，那就试试其他的吧。</p>
<h2 id="11-GitHub-Pages"><a href="#11-GitHub-Pages" class="headerlink" title="11 GitHub Pages"></a>11 GitHub Pages</h2><p>你可能已经知道使用 <code>GitHub Pages</code> 来托管一个静态网站。如果你不知道，现在就来学习，这一节是专门用于讨论使用 <code>Jekyll</code> 来构建一个站点的。</p>
<p>最简单的就是： <code>GitHub Pages + Jekyll </code>会通过一个漂亮的主题来渲染你的 <code>README.md</code> 文件。例如:通过 <a href="https://github.com/davidgilbertson/about-github">about-github</a>  来查看的我的 <code>README</code> 页面。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1baf4dafe3.jpg"></p>
<p>如果我在 GitHub 中点击了 <code>settings</code>选项，切换到 <code>Github Pages</code> 设置，然后选择一个 <code>Jekyll theme</code>。。。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1baf78ddf9.jpg"></p>
<p>我就可以得到 <a href="https://davidgilbertson.github.io/about-github/">Jekyll-themed 页面</a>。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bafb61827.jpg"></p>
<p>从这点上我可以主要依据易编辑的 <code>Markdown</code> 文件来构建一个完整的静态站点。本质上是把 GitHub 变成了 <code>CMS</code>。</p>
<p>虽然我没有实际使用过，但是 <code>React Bootstrap</code> 的网站都是使用它来构建的。所以它不会糟糕。</p>
<p>注意:它要求 <code>Ruby</code> 运行本地环境( Windows 自行安装， macOS 自带)。</p>
<h2 id="12-把-GitHub-当做-CRM-使用"><a href="#12-把-GitHub-当做-CRM-使用" class="headerlink" title="12 把 GitHub 当做 CRM 使用"></a>12 把 GitHub 当做 CRM 使用</h2><p>假设你有一个存有一些文本内容的网站，你不想将文本内容存储于真正的 <code>HTML</code> 源码中。</p>
<p>相反的，你想要将这些文本块存储于非开发人员能轻松的进行编辑的地方。可能是一个版本控制系统，甚至是一个审核流程。</p>
<p>我的建议是:使用 GitHub 厂库中的 Markdown 文件来存储这些文本内容，然后使用前端组件来拉取这些文本块并展示在页面上。</p>
<p>我是搞 <code>React</code> 的，所以这有一个 解析 <code>Markdown</code> 的组件例子，给定一些 <code>Markdown</code> 文件路径，它将会自动拉取并作为 <code>HTML</code> 显示出来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Markdown extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      </span><br><span class="line">      // replace with your URL, obviously</span><br><span class="line">      this.baseUrl = &#x27;https://raw.githubusercontent.com/davidgilbertson/about-github/master/text-snippets&#x27;;</span><br><span class="line">      </span><br><span class="line">      this.state = &#123;</span><br><span class="line">        markdown: &#x27;&#x27;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      fetch(`$&#123;this.baseUrl&#125;/$&#123;this.props.url&#125;`)</span><br><span class="line">        .then(response =&gt; response.text())</span><br><span class="line">        .then((markdown) =&gt; &#123;</span><br><span class="line">          this.setState(&#123;markdown&#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div dangerouslySetInnerHTML=&#123;&#123;__html: marked(this.state.markdown)&#125;&#125; /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="奖励环节-——-GitHub-工具"><a href="#奖励环节-——-GitHub-工具" class="headerlink" title="奖励环节 —— GitHub 工具"></a>奖励环节 —— GitHub 工具</h3><p>我已经使用了 <a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=en-US">Octotree Chrome extension</a> 有段时间了，现在我向大家推荐它！<br>无论你是在查看哪个 repo 它都会在左侧给你一个树状面板。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bafe8fb45.jpg"></p>
<p>通过这个<a href="https://www.youtube.com/watch?v=NhlzMcSyQek&index=2&list=PLNYkxOF6rcIB3ci6nwNyLYNU6RDOU3YyL">视频</a>我了解到了 octobox，它是用于管理你的 <code>GitHub Issues</code> 收件箱，看起来相当不错！<br>以上就是我针对于<code>octobox</code>的全部想法。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>就是这样了！我希望这里至少有三件事是你还不知道的。</p>
<p>最后: hava a nice day！</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>你应该知道的 volatile 关键字</title>
    <url>/2018/03/09/volatile/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1ba1aae694.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不管是在面试还是实际开发中 <code>volatile</code> 都是一个应该掌握的技能。</p>
<p>首先来看看为什么会出现这个关键字。</p>
<h2 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h2><p>由于 <code>Java</code> 内存模型(<code>JMM</code>)规定，所有的变量都存放在主内存中，而每个线程都有着自己的工作内存(高速缓存)。</p>
<p>线程在工作时，需要将主内存中的数据拷贝到工作内存中。这样对数据的任何操作都是基于工作内存(效率提高)，并且不能直接操作主内存以及其他线程工作内存中的数据，之后再将更新之后的数据刷新到主内存中。</p>
<blockquote>
<p>这里所提到的主内存可以简单认为是<strong>堆内存</strong>，而工作内存则可以认为是<strong>栈内存</strong>。</p>
</blockquote>
<p>如下图所示：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1ba249e161.jpg"></p>
<p>所以在并发运行时可能会出现线程 B 所读取到的数据是线程 A 更新之前的数据。</p>
<p>显然这肯定是会出问题的，因此 <code>volatile</code> 的作用出现了：</p>
<blockquote>
<p>当一个变量被 <code>volatile</code> 修饰时，任何线程对它的写操作都会立即刷新到主内存中，并且会强制让缓存了该变量的线程中的数据清空，必须从主内存重新读取最新数据。</p>
</blockquote>
<span id="more"></span>

<p><em><code>volatile</code> 修饰之后并不是让线程直接从主内存中获取数据，依然需要将变量拷贝到工作内存中</em>。</p>
<h3 id="内存可见性的应用"><a href="#内存可见性的应用" class="headerlink" title="内存可见性的应用"></a>内存可见性的应用</h3><p>当我们需要在两个线程间依据主内存通信时，通信的那个变量就必须的用 <code>volatile</code> 来修饰：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Volatile</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Volatile</span> <span class="variable">aVolatile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Volatile</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(aVolatile,<span class="string">&quot;thread A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程正在运行&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="keyword">if</span>(value.equals(<span class="string">&quot;1&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        aVolatile.stopThread();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程退出了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stopThread</span><span class="params">()</span>&#123;</span><br><span class="line">        flag = <span class="literal">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程在修改了标志位使得线程 A 立即停止，如果没有用 <code>volatile</code> 修饰，就有可能出现延迟。</p>
<p>但这里有个误区，这样的使用方式容易给人的感觉是：</p>
<blockquote>
<p>对 <code>volatile</code> 修饰的变量进行并发操作是线程安全的。</p>
</blockquote>
<p>这里要重点强调，<code>volatile</code> 并<strong>不能</strong>保证线程安全性！</p>
<p>如下程序:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileInc</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span> ; <span class="comment">//使用 volatile 修饰基本数据内存不能保证原子性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//private static AtomicInteger count = new AtomicInteger() ;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span> ;i++)&#123;</span><br><span class="line">            count ++ ;</span><br><span class="line">            <span class="comment">//count.incrementAndGet() ;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">VolatileInc</span> <span class="variable">volatileInc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileInc</span>() ;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(volatileInc,<span class="string">&quot;t1&quot;</span>) ;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(volatileInc,<span class="string">&quot;t2&quot;</span>) ;</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//t1.join();</span></span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//t2.join();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span> ;i++)&#123;</span><br><span class="line">            count ++ ;</span><br><span class="line">            <span class="comment">//count.incrementAndGet();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终Count=&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们三个线程(t1,t2,main)同时对一个 <code>int</code> 进行累加时会发现最终的值都会小于 30000。</p>
<blockquote>
<p>这是因为虽然 <code>volatile</code> 保证了内存可见性，每个线程拿到的值都是最新值，但 <code>count ++</code> 这个操作并不是原子的，这里面涉及到获取值、自增、赋值的操作并不能同时完成。</p>
</blockquote>
<ul>
<li><p>所以想到达到线程安全可以使这三个线程串行执行(其实就是单线程，没有发挥多线程的优势)。</p>
</li>
<li><p>也可以使用 <code>synchronize</code> 或者是锁的方式来保证原子性。</p>
</li>
<li><p>还可以用 <code>Atomic</code> 包中 <code>AtomicInteger</code> 来替换 <code>int</code>，它利用了 <code>CAS</code> 算法来保证了原子性。</p>
</li>
</ul>
<h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><p>内存可见性只是 <code>volatile</code> 的其中一个语义，它还可以防止 <code>JVM</code> 进行指令重排优化。</p>
<p>举一个伪代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span> ;<span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> b=<span class="number">20</span> ;<span class="comment">//2</span></span><br><span class="line"><span class="type">int</span> c= a+b ;<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>一段特别简单的代码，理想情况下它的执行顺序是：<code>1&gt;2&gt;3</code>。但有可能经过 JVM 优化之后的执行顺序变为了 <code>2&gt;1&gt;3</code>。</p>
<p>可以发现不管 JVM 怎么优化，前提都是保证单线程中最终结果不变的情况下进行的。</p>
<p>可能这里还看不出有什么问题，那看下一段伪代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,String&gt; value ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> fasle ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下方法发生在线程 A 中 初始化 Map</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMap</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//耗时操作</span></span><br><span class="line">	value = getMapValue() ;<span class="comment">//1</span></span><br><span class="line">	flag = <span class="literal">true</span> ;<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发生在线程 B中 等到 Map 初始化成功进行其他操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">		sleep() ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//dosomething</span></span><br><span class="line">	doSomeThing(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里就能看出问题了，当 <code>flag</code> 没有被 <code>volatile</code> 修饰时，<code>JVM</code> 对 1 和 2 进行重排，导致 <code>value</code> 都还没有被初始化就有可能被线程 B 使用了。</p>
<p>所以加上 <code>volatile</code> 之后可以防止这样的重排优化，保证业务的正确性。</p>
<h3 id="指令重排的的应用"><a href="#指令重排的的应用" class="headerlink" title="指令重排的的应用"></a>指令重排的的应用</h3><p>一个经典的使用场景就是双重懒加载的单例模式了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//防止指令重排</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>volatile</code> 关键字主要是为了防止指令重排。 </p>
<p>如果不用 ，<code>singleton = new Singleton();</code>，这段代码其实是分为三步：</p>
<ul>
<li>分配内存空间。(1)</li>
<li>初始化对象。(2)</li>
<li>将 <code>singleton</code> 对象指向分配的内存地址。(3)</li>
</ul>
<p>加上 <code>volatile</code> 是为了让以上的三步操作顺序执行，反之有可能第二步在第三步之前被执行就有可能某个线程拿到的单例对象是还没有初始化的，以致于报错。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>volatile</code> 在 <code>Java</code> 并发中用的很多，比如像 <code>Atomic</code> 包中的 <code>value</code>、以及 <code>AbstractQueuedLongSynchronizer</code> 中的 <code>state</code> 都是被定义为 <code>volatile</code> 来用于保证内存可见性。</p>
<p>将这块理解透彻对我们编写并发程序时可以提供很大帮助。</p>
<h2 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h2><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>volatile</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次总结</title>
    <url>/2016/05/07/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<p>昨天到今天一共花了差不多两天的时间终于把博客搭好了。还买了一个域名，现在就迫不及待的想把<br>这段内容写下来。</p>
<hr>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><hr>
<p>首先非常感谢 <a href="http://tengj.top/" title="嘟爷的博客">嘟爷</a>的帮忙，没有这些资料我可能还得自己研究好一段时间。</p>
<span id="more"></span>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><hr>
<p>我是前天无意间在微博上看到嘟爷的一篇博文，就仔细看了下，发现写的非常好，然后就将他所有的博文大致的浏览了一下。</p>
<p>我很早以前就打算搭一个博客，但是百度了一下发现还是挺麻烦的，加上最近也比较忙所有一直也就没有做，直到看到这篇博文才顺利的搭起了这个博客。中途遇到不少问题也都顺利解决了，真是学到了不少的东西。</p>
<ul>
<li>熟练了Markdown语法。</li>
<li>真正使用了编辑神器 <strong>Sublime</strong>。</li>
<li>使用阿里云解析了github和coding里的Pages服务。</li>
<li>hexo和常用的主题配置。</li>
</ul>
<h1 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h1><hr>
<h2 id="Hexo配置"><a href="#Hexo配置" class="headerlink" title="Hexo配置"></a>Hexo配置</h2><hr>
<p><img src="http://i.imgur.com/IqaE8CF.png" alt="Hexo配置"></p>
<hr>
<h2 id="JackMan配置"><a href="#JackMan配置" class="headerlink" title="JackMan配置"></a>JackMan配置</h2><pre><code>imglogo:
  enable: true             ## display image logo true/false.
  src: img/logo.gif        ## `.svg` and `.png` are recommended,please put image into the theme folder `/jacman/source/img`.
favicon: img/favicon.ico   ## size:32px*32px,`.ico` is recommended,please put image into the theme folder `/jacman/source/img`.     
apple_icon: img/jacman.jpg ## size:114px*114px,please put image into the theme folder `/jacman/source/img`.
author_img: img/author.jpg ## size:220px*220px.display author avatar picture.if don&#39;t want to display,please don&#39;t set this.
banner_img: #img/banner.jpg ## size:1920px*200px+. Banner Picture
### Theme Color 
theme_color:
    theme: &#39;#2ca6cb&#39;    ##the defaut theme color is blue

# 代码高亮主题
# available: default | night
highlight_theme: night

#### index post is expanding or not 
index:
  expand: false           ## default is unexpanding,so you can only see the short description of each post.
  excerpt_link: Read More  

close_aside: false  #close sidebar in post page if true
mathjax: false      #enable mathjax if true

### Creative Commons License Support, see http://creativecommons.org/ 
### you can choose: by , by-nc , by-nc-nd , by-nc-sa , by-nd , by-sa , zero
creative_commons: none
</code></pre>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>以上。。我做这个博客的初衷一是为了记录我的整个程序猿生涯的故事，二是希望能有大神能在过程中指出我的错误，能让我的水平更进一步。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>分享几个 SpringBoot 实用的小技巧</title>
    <url>/2018/10/15/SpringBoot/SpringBoot-tips/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1c6c1c0c74.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近分享的一些源码、框架设计的东西。我发现大家热情不是特别高，想想大多数应该还是正儿八经写代码的居多；这次就分享一点接地气的： <code>SpringBoot</code> 使用中的一些小技巧。</p>
<p>算不上多高大上的东西，但都还挺有用。</p>
<span id="more"></span>

<h1 id="屏蔽外部依赖"><a href="#屏蔽外部依赖" class="headerlink" title="屏蔽外部依赖"></a>屏蔽外部依赖</h1><p>第一个是<code>屏蔽外部依赖</code>，什么意思呢？</p>
<p>比如大家日常开发时候有没有这样的烦恼：</p>
<p>项目是基于 <code>SpringCloud</code> 或者是 <code>dubbo</code> 这样的分布式服务，你需要依赖许多基础服务。</p>
<blockquote>
<p>比如说某个订单号的生成、获取用户信息等。</p>
</blockquote>
<p>由于服务拆分，这些功能都是在其他应用中以接口的形式提供，单测还好我还可以利用 <code>Mock</code> 把它屏蔽掉。</p>
<p>但如果自己想把应用启动起来同时把自己相关的代码跑一遍呢？</p>
<p>通常有几种做法：</p>
<ul>
<li>本地把所有的服务都启动起来。</li>
<li>把注册中心换为开发环境，依赖开发环境的服务。</li>
<li>直接把代码推送到开发环境自测。</li>
</ul>
<p>看起来三种都可以，以前我也是这么干的。但还是有几个小问题：</p>
<ul>
<li>本地启动有可能服务很多，全部起来电脑能不能撑住还两说，万一服务有问题就进行不下去了。</li>
<li>依赖开发环境的前提是网络打通，还有一个问题就是开发环境代码很不稳定很大可能会影响你的测试。</li>
<li>推送到开发环境应该是比较靠谱的方案，但如果想调试只有日志大法，没有本地 <code>debug</code> 的效率高效。</li>
</ul>
<p>那如何解决问题呢？既可以在本地调试也不用启动其他服务。</p>
<p>其实也可以利用单测的做法，把其他外部依赖 <code>Mock</code> 掉就行了。</p>
<p>大致的流程分为以下几步：</p>
<ul>
<li><code>SpringBoot</code> 启动之后在 <code>Spring</code> 中找出你需要屏蔽的那个 <code>API</code> 的 <code>bean</code>（通常情况下这个接口都是交给 <code>Spring</code> 管理的）。</li>
<li>手动从 <code>bean</code> 容器中删除该 <code>bean</code>。</li>
<li>重新创建一个该 <code>API</code> 的对象，只不过是通过 <code>Mock</code> 出来的。</li>
<li>再手动注册进 <code>bean</code> 容器中。</li>
</ul>
<p>以下面这段代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;OrderNoResVO&gt; <span class="title function_">getUserByHystrix</span><span class="params">(<span class="meta">@RequestBody</span> UserReqVO userReqVO)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">OrderNoReqVO</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderNoReqVO</span>();</span><br><span class="line">    vo.setAppId(<span class="number">123L</span>);</span><br><span class="line">    vo.setReqNo(userReqVO.getReqNo());</span><br><span class="line">    BaseResponse&lt;OrderNoResVO&gt; orderNo = orderServiceClient.getOrderNo(vo);</span><br><span class="line">    <span class="keyword">return</span> orderNo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>这是一个 SpringCloud 应用。</p>
</blockquote>
<p>它依赖于 <code>orderServiceClient</code> 获取一个订单号。</p>
<p>其中的 <code>orderServiceClient</code> 就是一个外部 API，也是被 Spring 所管理。</p>
<h2 id="替换原有的-Bean"><a href="#替换原有的-Bean" class="headerlink" title="替换原有的 Bean"></a>替换原有的 Bean</h2><p>下一步就是替换原有的 Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderMockServiceConfig</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(OrderMockServiceConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;excute.env&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非本地环境不做处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;dev&quot;</span>.equals(env) || <span class="string">&quot;test&quot;</span>.equals(env) || <span class="string">&quot;pro&quot;</span>.equals(env)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">defaultListableBeanFactory</span> <span class="operator">=</span> (DefaultListableBeanFactory) applicationContext.getAutowireCapableBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="type">OrderServiceClient</span> <span class="variable">orderServiceClient</span> <span class="operator">=</span> defaultListableBeanFactory.getBean(OrderServiceClient.class);</span><br><span class="line">        logger.info(<span class="string">&quot;======orderServiceClient &#123;&#125;=====&quot;</span>, orderServiceClient.getClass());</span><br><span class="line"></span><br><span class="line">        defaultListableBeanFactory.removeBeanDefinition(OrderServiceClient.class.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="type">OrderServiceClient</span> <span class="variable">mockOrderApi</span> <span class="operator">=</span> PowerMockito.mock(OrderServiceClient.class,</span><br><span class="line">                invocationOnMock -&gt; BaseResponse.createSuccess(DateUtil.getLongTime() + <span class="string">&quot;&quot;</span>, <span class="string">&quot;mock orderNo success&quot;</span>));</span><br><span class="line"></span><br><span class="line">        defaultListableBeanFactory.registerSingleton(OrderServiceClient.class.getCanonicalName(), mockOrderApi);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;======mockOrderApi &#123;&#125;=====&quot;</span>, mockOrderApi.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其中实现了 <code>CommandLineRunner</code> 接口，可以在 <code>Spring</code> 容器初始化完成之后调用 <code>run()</code> 方法。</p>
<p>代码非常简单，简单来说首先判断下是什么环境，毕竟除开本地环境其余的都是需要真正调用远程服务的。</p>
<p>之后就是获取 <code>bean</code> 然后手动删除掉。</p>
<p>关键的一步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OrderServiceClient</span> <span class="variable">mockOrderApi</span> <span class="operator">=</span> PowerMockito.mock(OrderServiceClient.class,</span><br><span class="line">                invocationOnMock -&gt; BaseResponse.createSuccess(DateUtil.getLongTime() + <span class="string">&quot;&quot;</span>, <span class="string">&quot;mock orderNo success&quot;</span>));</span><br><span class="line"></span><br><span class="line">defaultListableBeanFactory.registerSingleton(OrderServiceClient.class.getCanonicalName(), mockOrderApi);</span><br></pre></td></tr></table></figure>

<p>创建了一个新的 <code>OrderServiceClient</code> 对象并手动注册进了 <code>Spring</code> 容器中。</p>
<p>第一段代码使用的是 <code>PowerMockito.mock</code> 的 API，他可以创建一个代理对象，让所有调用 <code>OrderServiceClient</code> 的方法都会做默认的返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BaseResponse.createSuccess(DateUtil.getLongTime() + <span class="string">&quot;&quot;</span>, <span class="string">&quot;mock orderNo success&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>测试一下，当我们没有替换时调用刚才那个接口并且本地也没有启动 <code>OrderService</code>：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6c3cc479.jpg"></p>
<p>因为没有配置 fallback 所以会报错，表示找不到这个服务。</p>
<p>替换掉 bean 时：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6c68a740.jpg"></p>
<p>再次请求没有报错，并且获得了我们默认的返回。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6cd7ba1d.jpg"></p>
<p>通过日志也会发现 <code>OrderServiceClient</code> 最后已经被 <code>Mock</code> 代理了，并不会去调用真正的方法。</p>
<h1 id="配置加密"><a href="#配置加密" class="headerlink" title="配置加密"></a>配置加密</h1><p>下一个则是配置加密，这应该算是一个基本功能。</p>
<p>比如我们配置文件中的一些账号和密码，都应该是密文保存的。</p>
<p>因此这次使用了一个开源组件来实现加密与解密，并且对 <code>SpringBoot</code> 非常友好只需要几段代码即可完成。</p>
<ul>
<li>首先根据加密密码将需要加密的配置加密为密文。</li>
<li>替换原本明文保存的配置。</li>
<li>再使用时进行解密。</li>
</ul>
<p>使用该包也只需要引入一个依赖即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ulisesbocchio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jasypt-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时写一个单测根据密码生成密文，密码也可保存在配置文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jasypt.encryptor.password=123456</span><br></pre></td></tr></table></figure>

<p>接着在单测中生成密文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringEncryptor encryptor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPass</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> encryptor.encrypt(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> encryptor.encrypt(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(name + <span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">    System.out.println(password + <span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后只需要使用密文就行。</p>
<p>由于我这里是对数据库用户名和密码加密，所以还得有一个解密的过程。</p>
<p>利用 <code>Spring Bean</code> 的一个增强接口即可实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProcess</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringEncryptor encryptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> DataSourceProperties)&#123;</span><br><span class="line">            <span class="type">DataSourceProperties</span> <span class="variable">dataSourceProperties</span> <span class="operator">=</span> (DataSourceProperties) bean;</span><br><span class="line">            dataSourceProperties.setUsername(encryptor.decrypt(dataSourceProperties.getUsername())) ;</span><br><span class="line">            dataSourceProperties.setPassword(encryptor.decrypt(dataSourceProperties.getPassword()));</span><br><span class="line">            <span class="keyword">return</span> dataSourceProperties ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以在真正使用时还原为明文。</p>
<p>同时也可以在启动命令中配置刚才的密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -Djasypt.encryptor.password=password -jar target/jasypt-spring-boot-demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这样两个小技巧就讲完了，大家有 <code>SpringBoot</code> 的更多使用技巧欢迎留言讨论。</p>
<p>上文的一些实例代码可以在这里找到：</p>
<p><a href="https://github.com/crossoverJie/springboot-cloud">https://github.com/crossoverJie/springboot-cloud</a></p>
<p><strong>欢迎关注公众号一起交流：</strong></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Mock</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性 Hash 算法的实际应用</title>
    <url>/2019/03/01/algorithm/consistent-hash/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1be999402c.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记得一年前分享过一篇<a href="https://crossoverjie.top/2018/01/08/Consistent-Hash/">《一致性 Hash 算法分析》</a>，当时只是分析了这个算法的实现原理、解决了什么问题等。</p>
<p>但没有实际实现一个这样的算法，毕竟要加深印象还得自己撸一遍，于是本次就当前的一个路由需求来着手实现一次。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>看过<a href="https://crossoverjie.top/2019/01/02/netty/cim01-started/">《为自己搭建一个分布式 IM(即时通讯) 系统》</a>的朋友应该对其中的登录逻辑有所印象。</p>
<span id="more"></span>

<blockquote>
<p>先给新来的朋友简单介绍下 <a href="https://github.com/crossoverJie/cim">cim</a> 是干啥的：</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/08/5cd1be99f3bb2.jpg"></p>
<p>其中有一个场景是在客户端登录成功后需要从可用的服务端列表中选择一台服务节点返回给客户端使用。</p>
<p>而这个选择的过程就是一个负载策略的过程；第一版本做的比较简单，默认只支持轮询的方式。</p>
<p>虽然够用，但不够优雅😏。</p>
<p><strong>因此我的规划是内置多种路由策略供使用者根据自己的场景选择，同时提供简单的 API 供用户自定义自己的路由策略。</strong></p>
<p>先来看看一致性 Hash 算法的一些特点：</p>
<ul>
<li>构造一个 <code>0 ~ 2^32-1</code> 大小的环。</li>
<li>服务节点经过 hash 之后将自身存放到环中的下标中。</li>
<li>客户端根据自身的某些数据 hash 之后也定位到这个环中。</li>
<li>通过顺时针找到离他最近的一个节点，也就是这次路由的服务节点。</li>
<li>考虑到服务节点的个数以及 hash 算法的问题导致环中的数据分布不均匀时引入了虚拟节点。</li>
</ul>
<p><img src="https://i.loli.net/2019/05/08/5cd1be9b0e4e3.jpg"></p>
<h1 id="自定义有序-Map"><a href="#自定义有序-Map" class="headerlink" title="自定义有序 Map"></a>自定义有序 Map</h1><p>根据这些客观条件我们很容易想到通过自定义一个<strong>有序</strong>数组来模拟这个环。</p>
<p>这样我们的流程如下：</p>
<ol>
<li>初始化一个长度为 N 的数组。</li>
<li>将服务节点通过 hash 算法得到的正整数，同时将节点自身的数据（hashcode、ip、端口等）存放在这里。</li>
<li>完成节点存放后将整个数组进行排序（排序算法有多种）。</li>
<li>客户端获取路由节点时，将自身进行 hash 也得到一个正整数；</li>
<li>遍历这个数组直到找到一个数据大于等于当前客户端的 hash 值，就将当前节点作为该客户端所路由的节点。</li>
<li>如果没有发现比客户端大的数据就返回第一个节点（满足环的特性）。</li>
</ol>
<p>先不考虑排序所消耗的时间，单看这个路由的时间复杂度：</p>
<ul>
<li>最好是第一次就找到，时间复杂度为<code>O(1)</code>。</li>
<li>最差为遍历完数组后才找到，时间复杂度为<code>O(N)</code>。</li>
</ul>
<p>理论讲完了来看看具体实践。</p>
<p>我自定义了一个类：<code>SortArrayMap</code></p>
<p>他的使用方法及结果如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1be9b8278e.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1be9bb786e.jpg"></p>
<p>可见最终会按照 <code>key</code> 的大小进行排序，同时传入 <code>hashcode = 101</code> 时会按照顺时针找到 <code>hashcode = 1000</code> 这个节点进行返回。</p>
<hr>
<p>下面来看看具体的实现。</p>
<p>成员变量和构造函数如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1be9c182fe.jpg"></p>
<p>其中最核心的就是一个 <code>Node</code> 数组，用它来存放服务节点的 <code>hashcode</code> 以及 <code>value</code> 值。</p>
<p>其中的内部类 <code>Node</code> 结构如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1be9c6be0b.jpg"></p>
<hr>
<p>写入数据的方法如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bea38b4ab.jpg"></p>
<p>相信看过 <code>ArrayList</code> 的源码应该有印象，这里的写入逻辑和它很像。</p>
<ul>
<li>写入之前判断是否需要扩容，如果需要则复制原来大小的 1.5 倍数组来存放数据。</li>
<li>之后就写入数组，同时数组大小 +1。</li>
</ul>
<p>但是存放时是按照写入顺序存放的，遍历时自然不会有序；因此提供了一个 <code>Sort</code> 方法，可以把其中的数据按照 <code>key</code> 其实也就是 <code>hashcode</code> 进行排序。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bea416c01.jpg"></p>
<p>排序也比较简单，使用了 <code>Arrays</code> 这个数组工具进行排序，它其实是使用了一个 <code>TimSort</code> 的排序算法，效率还是比较高的。</p>
<p>最后则需要按照一致性 Hash 的标准顺时针查找对应的节点：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bea459788.jpg"></p>
<p>代码还是比较简单清晰的；遍历数组如果找到比当前 key 大的就返回，没有查到就取第一个。</p>
<p>这样就基本实现了一致性 Hash 的要求。</p>
<blockquote>
<p>ps:这里并不包含具体的 hash 方法以及虚拟节点等功能（具体实现请看下文），这个可以由使用者来定，SortArrayMap 可作为一个底层的数据结构，提供有序 Map 的能力，使用场景也不局限于一致性 Hash 算法中。</p>
</blockquote>
<h1 id="TreeMap-实现"><a href="#TreeMap-实现" class="headerlink" title="TreeMap 实现"></a>TreeMap 实现</h1><p><code>SortArrayMap</code> 虽说是实现了一致性 hash 的功能，但效率还不够高，主要体现在 <code>sort</code> 排序处。</p>
<p>下图是目前主流排序算法的时间复杂度：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bea49b947.jpg"></p>
<p>最好的也就是 <code>O(N)</code> 了。</p>
<p>这里完全可以换一个思路，不用对数据进行排序；而是在写入的时候就排好顺序，只是这样会降低写入的效率。</p>
<p>比如二叉查找树，这样的数据结构 <code>jdk</code> 里有现成的实现；比如 <code>TreeMap</code> 就是使用红黑树来实现的，默认情况下它会对 key 进行自然排序。</p>
<hr>
<p>来看看使用 <code>TreeMap</code> 如何来达到同样的效果。<br><img src="https://i.loli.net/2019/05/08/5cd1bea4e6550.jpg"><br>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1000</span><br></pre></td></tr></table></figure>

<p>效果和上文使用 <code>SortArrayMap</code> 是一致的。</p>
<p>只使用了 TreeMap 的一些 API：</p>
<ul>
<li>写入数据候，<code>TreeMap</code> 可以保证 key 的自然排序。</li>
<li><code>tailMap</code> 可以获取比当前 key 大的部分数据。</li>
<li>当这个方法有数据返回时取第一个就是顺时针中的第一个节点了。</li>
<li>如果没有返回那就直接取整个 <code>Map</code> 的第一个节点，同样也实现了环形结构。</li>
</ul>
<blockquote>
<p>ps:这里同样也没有 hash 方法以及虚拟节点（具体实现请看下文），因为 TreeMap 和 SortArrayMap 一样都是作为基础数据结构来使用的。</p>
</blockquote>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>为了方便大家选择哪一个数据结构，我用 <code>TreeMap</code> 和 <code>SortArrayMap</code> 分别写入了一百万条数据来对比。</p>
<p>先是 <code>SortArrayMap</code>：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bea9f1177.jpg"></p>
<p><strong>耗时 2237 毫秒。</strong></p>
<p>TreeMap：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beaa90503.jpg"></p>
<p><strong>耗时 1316毫秒。</strong></p>
<p>结果是快了将近一倍，所以还是推荐使用 <code>TreeMap</code> 来进行实现，毕竟它不需要额外的排序损耗。</p>
<h1 id="cim-中的实际应用"><a href="#cim-中的实际应用" class="headerlink" title="cim 中的实际应用"></a>cim 中的实际应用</h1><p>下面来看看在 <code>cim</code> 这个应用中是如何具体使用的，其中也包括上文提到的虚拟节点以及 hash 算法。</p>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>在应用的时候考虑到就算是一致性 hash 算法都有多种实现，为了方便其使用者扩展自己的一致性 hash 算法因此我定义了一个抽象类；其中定义了一些模板方法，这样大家只需要在子类中进行不同的实现即可完成自己的算法。</p>
<p>AbstractConsistentHash，这个抽象类的主要方法如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beab41c7a.jpg"></p>
<ul>
<li><code>add</code> 方法自然是写入数据的。</li>
<li><code>sort</code> 方法用于排序，但子类也不一定需要重写，比如 <code>TreeMap</code> 这样自带排序的容器就不用。</li>
<li><code>getFirstNodeValue</code> 获取节点。</li>
<li><code>process</code> 则是面向客户端的，最终只需要调用这个方法即可返回一个节点。</li>
</ul>
<p>下面我们来看看利用 <code>SortArrayMap</code> 以及 <code>AbstractConsistentHash</code> 是如何实现的。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beab9a84f.jpg"></p>
<p>就是实现了几个抽象方法，逻辑和上文是一样的，只是抽取到了不同的方法中。</p>
<p>只是在 add 方法中新增了几个虚拟节点，相信大家也看得明白。</p>
<blockquote>
<p>把虚拟节点的控制放到子类而没有放到抽象类中也是为了灵活性考虑，可能不同的实现对虚拟节点的数量要求也不一样，所以不如自定义的好。</p>
</blockquote>
<p>但是 <code>hash</code> 方法确是放到了抽象类中，子类不用重写；因为这是一个基本功能，只需要有一个公共算法可以保证他散列地足够均匀即可。</p>
<p>因此在 <code>AbstractConsistentHash</code> 中定义了 hash 方法。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beac476c2.jpg"></p>
<blockquote>
<p>这里的算法摘抄自 xxl_job，网上也有其他不同的实现，比如 <code>FNV1_32_HASH</code> 等；实现不同但是目的都一样。</p>
</blockquote>
<hr>
<p>这样对于使用者来说就非常简单了：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beacc8e2c.jpg"></p>
<p>他只需要构建一个服务列表，然后把当前的客户端信息传入 <code>process</code> 方法中即可获得一个一致性 hash 算法的返回。</p>
<hr>
<p>同样的对于想通过 <code>TreeMap</code> 来实现也是一样的套路：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bead5feca.jpg"></p>
<p>他这里不需要重写 sort 方法，因为自身写入时已经排好序了。</p>
<p>而在使用时对于客户端来说只需求修改一个实现类，其他的啥都不用改就可以了。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beb27d748.jpg"></p>
<p>运行的效果也是一样的。</p>
<p>这样大家想自定义自己的算法时只需要继承 <code>AbstractConsistentHash</code> 重写相关方法即可，<strong>客户端代码无须改动。</strong></p>
<h2 id="路由算法扩展性"><a href="#路由算法扩展性" class="headerlink" title="路由算法扩展性"></a>路由算法扩展性</h2><p>但其实对于 <code>cim</code> 来说真正的扩展性是对路由算法来说的，比如它需要支持轮询、hash、一致性hash、随机、LRU等。</p>
<p>只是一致性 hash 也有多种实现，他们的关系就如下图：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beb2d6428.jpg"></p>
<p>应用还需要满足对这一类路由策略的灵活支持，比如我也想自定义一个随机的策略。</p>
<p>因此定义了一个接口：<code>RouteHandle</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RouteHandle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 再一批服务器里进行路由</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">routeServer</span><span class="params">(List&lt;String&gt; values,String key)</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中只有一个方法，也就是路由方法；入参分别是服务列表以及客户端信息即可。</p>
<p>而对于一致性 hash 算法来说也是只需要实现这个接口，同时在这个接口中选择使用 <code>SortArrayMapConsistentHash</code> 还是 <code>TreeMapConsistentHash</code> 即可。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beb35b595.jpg"></p>
<p>这里还有一个 <code>setHash</code> 的方法，入参是 AbstractConsistentHash；这就是用于客户端指定需要使用具体的那种数据结构。</p>
<hr>
<p>而对于之前就存在的轮询策略来说也是同样的实现 <code>RouteHandle</code> 接口。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beb3dbd86.jpg"></p>
<p>这里我只是把之前的代码搬过来了而已。</p>
<p>接下来看看客户端到底是如何使用以及如何选择使用哪种算法。</p>
<blockquote>
<p>为了使客户端代码几乎不动，我将这个选择的过程放入了配置文件。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/08/5cd1beb476ca8.jpg"></p>
<ol>
<li>如果想使用原有的轮询策略，就配置实现了 <code>RouteHandle</code> 接口的轮询策略的全限定名。</li>
<li>如果想使用一致性 hash 的策略，也只需要配置实现了 <code>RouteHandle</code> 接口的一致性 hash 算法的全限定名。</li>
<li>当然目前的一致性 hash 也有多种实现，所以一旦配置为一致性 hash 后就需要再加一个配置用于决定使用 <code>SortArrayMapConsistentHash</code> 还是 <code>TreeMapConsistentHash</code> 或是自定义的其他方案。</li>
<li>同样的也是需要配置继承了 <code>AbstractConsistentHash</code> 的全限定名。</li>
</ol>
<p>不管这里的策略如何改变，在使用处依然保持不变。</p>
<p>只需要注入 <code>RouteHandle</code>，调用它的 <code>routeServer</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RouteHandle routeHandle ;</span><br><span class="line"><span class="type">String</span> <span class="variable">server</span> <span class="operator">=</span> routeHandle.routeServer(serverCache.getAll(),String.valueOf(loginReqVO.getUserId()));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>既然使用了注入，那其实这个策略切换的过程就在创建 <code>RouteHandle bean</code> 的时候完成的。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beb4d7cd2.jpg"></p>
<p>也比较简单，需要读取之前的配置文件来动态生成具体的实现类，主要是利用反射完成的。</p>
<p>这样处理之后就比较灵活了，比如想新建一个随机的路由策略也是同样的套路；到时候只需要修改配置即可。</p>
<blockquote>
<p>感兴趣的朋友也可提交 PR 来新增更多的路由策略。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>希望看到这里的朋友能对这个算法有所理解，同时对一些设计模式在实际的使用也能有所帮助。</p>
<p>相信在金三银四的面试过程中还是能让面试官眼前一亮的，毕竟根据我这段时间的面试过程来看听过这个名词的都在少数😂（可能也是和候选人都在 1~3 年这个层级有关）。</p>
<p>以上所有源码：</p>
<p><a href="https://github.com/crossoverJie/cim">https://github.com/crossoverJie/cim</a></p>
<p>如果本文对你有所帮助还请不吝转发。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>动手实现一个 LRU cache</title>
    <url>/2018/04/07/algorithm/LRU-cache/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d7b5984ac.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LRU 是 <code>Least Recently Used</code> 的简写，字面意思则是<code>最近最少使用</code>。</p>
<p>通常用于缓存的淘汰策略实现，由于缓存的内存非常宝贵，所以需要根据某种规则来剔除数据保证内存不被撑满。</p>
<p>如常用的 Redis 就有以下几种策略：</p>
<table>
<thead>
<tr>
<th align="center">策略</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">volatile-lru</td>
<td align="center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td align="center">volatile-ttl</td>
<td align="center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td align="center">volatile-random</td>
<td align="center">从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td align="center">allkeys-lru</td>
<td align="center">从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td align="center">allkeys-random</td>
<td align="center">从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td align="center">no-envicition</td>
<td align="center">禁止驱逐数据</td>
</tr>
</tbody></table>
<blockquote>
<p>摘抄自:<a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Redis.md#%E5%8D%81%E4%B8%89%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Redis.md#%E5%8D%81%E4%B8%89%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5</a></p>
</blockquote>
<span id="more"></span>


<h2 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h2><p>之前也有接触过一道面试题，大概需求是：</p>
<ul>
<li>实现一个 LRU 缓存，当缓存数据达到 N 之后需要淘汰掉最近最少使用的数据。</li>
<li>N 小时之内没有被访问的数据也需要淘汰掉。</li>
</ul>
<p>以下是我的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUAbstractMap</span> <span class="keyword">extends</span> <span class="title class_">java</span>.util.AbstractMap &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(LRUAbstractMap.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查是否超期线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService checkTimePool ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 最大size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">1024</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Node&gt; QUEUE = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(MAX_SIZE) ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DEFAULT_ARRAY_SIZE</span> <span class="operator">=</span><span class="number">1024</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> arraySize ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] arrays ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否停止 flag</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Long</span> <span class="variable">EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 整个 Map 的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> AtomicInteger size  ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUAbstractMap</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        arraySize = DEFAULT_ARRAY_SIZE;</span><br><span class="line">        arrays = <span class="keyword">new</span> <span class="title class_">Object</span>[arraySize] ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启一个线程检查最先放入队列的值是否超期</span></span><br><span class="line">        executeCheckTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启一个线程检查最先放入队列的值是否超期 设置为守护线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">executeCheckTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadFactory</span> <span class="variable">namedThreadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                .setNameFormat(<span class="string">&quot;check-thread-%d&quot;</span>)</span><br><span class="line">                .setDaemon(<span class="literal">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">        checkTimePool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>),namedThreadFactory,<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        checkTimePool.execute(<span class="keyword">new</span> <span class="title class_">CheckTimeThread</span>()) ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Entry&gt; <span class="title function_">entrySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.keySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">put</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash % arraySize ;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">currentNode</span> <span class="operator">=</span> (Node) arrays[index] ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            arrays[index] = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>,<span class="literal">null</span>, key, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入队列</span></span><br><span class="line">            QUEUE.offer((Node) arrays[index]) ;</span><br><span class="line"></span><br><span class="line">            sizeUp();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cNode</span> <span class="operator">=</span> currentNode ;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">nNode</span> <span class="operator">=</span> cNode ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存在就覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (nNode.key == key)&#123;</span><br><span class="line">                cNode.val = value ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (nNode.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//key 存在 就覆盖 简单判断</span></span><br><span class="line">                <span class="keyword">if</span> (nNode.key == key)&#123;</span><br><span class="line">                    nNode.val = value ;</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//不存在就新增链表</span></span><br><span class="line">                    sizeUp();</span><br><span class="line">                    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(nNode,<span class="literal">null</span>,key,value) ;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//写入队列</span></span><br><span class="line">                    QUEUE.offer(currentNode) ;</span><br><span class="line"></span><br><span class="line">                    cNode.next = node ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nNode = nNode.next ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key) ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash % arraySize ;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">currentNode</span> <span class="operator">=</span> (Node) arrays[index] ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode.next == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新时间</span></span><br><span class="line">            currentNode.setUpdateTime(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//没有冲突</span></span><br><span class="line">            <span class="keyword">return</span> currentNode ;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">nNode</span> <span class="operator">=</span> currentNode ;</span><br><span class="line">        <span class="keyword">while</span> (nNode.next != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nNode.key == key)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新时间</span></span><br><span class="line">                currentNode.setUpdateTime(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> nNode ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nNode = nNode.next ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key) ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash % arraySize ;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">currentNode</span> <span class="operator">=</span> (Node) arrays[index] ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNode.key == key)&#123;</span><br><span class="line">            sizeDown();</span><br><span class="line">            arrays[index] = <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//移除队列</span></span><br><span class="line">            QUEUE.poll();</span><br><span class="line">            <span class="keyword">return</span> currentNode ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">nNode</span> <span class="operator">=</span> currentNode ;</span><br><span class="line">        <span class="keyword">while</span> (nNode.next != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nNode.key == key)&#123;</span><br><span class="line">                sizeDown();</span><br><span class="line">                <span class="comment">//在链表中找到了 把上一个节点的 next 指向当前节点的下一个节点</span></span><br><span class="line">                nNode.pre.next = nNode.next ;</span><br><span class="line">                nNode = <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//移除队列</span></span><br><span class="line">                QUEUE.poll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> nNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nNode = nNode.next ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sizeUp</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在put值时候认为里边已经有数据了</span></span><br><span class="line">        flag = <span class="literal">true</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="literal">null</span>)&#123;</span><br><span class="line">            size = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.size.incrementAndGet();</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= MAX_SIZE) &#123;</span><br><span class="line">            <span class="comment">//找到队列头的数据</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> QUEUE.poll() ;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;data error&quot;</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//移除该 key</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> node.key ;</span><br><span class="line">            remove(key) ;</span><br><span class="line">            lruCallback() ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数量减小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sizeDown</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (QUEUE.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="literal">false</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.size.decrementAndGet() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size.get() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node next ;</span><br><span class="line">        <span class="keyword">private</span> Node pre ;</span><br><span class="line">        <span class="keyword">private</span> Object key ;</span><br><span class="line">        <span class="keyword">private</span> Object val ;</span><br><span class="line">        <span class="keyword">private</span> Long updateTime ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node pre,Node next, Object key, Object val)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.pre = pre ;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.updateTime = System.currentTimeMillis() ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUpdateTime</span><span class="params">(Long updateTime)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.updateTime = updateTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Long <span class="title function_">getUpdateTime</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> updateTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;key=&quot;</span> + key +</span><br><span class="line">                    <span class="string">&quot;, val=&quot;</span> + val +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * copy HashMap 的 hash 实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">lruCallback</span><span class="params">()</span>&#123;</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;lruCallback&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CheckTimeThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> QUEUE.poll();</span><br><span class="line">                    <span class="keyword">if</span> (node == <span class="literal">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">Long</span> <span class="variable">updateTime</span> <span class="operator">=</span> node.getUpdateTime() ;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ((updateTime - System.currentTimeMillis()) &gt;= EXPIRE_TIME)&#123;</span><br><span class="line">                        remove(node.key) ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOGGER.error(<span class="string">&quot;InterruptedException&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感兴趣的朋友可以直接从:</p>
<p><a href="https://github.com/crossoverJie/Java-Interview/blob/master/src/main/java/com/crossoverjie/actual/LRUAbstractMap.java">https://github.com/crossoverJie/Java-Interview/blob/master/src/main/java/com/crossoverjie/actual/LRUAbstractMap.java</a></p>
<p>下载代码本地运行。</p>
<p>代码看着比较多，其实实现的思路还是比较简单：</p>
<ul>
<li>采用了与 HashMap 一样的保存数据方式，只是自己手动实现了一个简易版。</li>
<li>内部采用了一个队列来保存每次写入的数据。</li>
<li>写入的时候判断缓存是否大于了阈值 N，如果满足则根据队列的 FIFO 特性将队列头的数据删除。因为队列头的数据肯定是最先放进去的。</li>
<li>再开启了一个守护线程用于判断最先放进去的数据是否超期（因为就算超期也是最先放进去的数据最有可能满足超期条件。）</li>
<li>设置为守护线程可以更好的表明其目的（最坏的情况下，如果是一个用户线程最终有可能导致程序不能正常退出，因为该线程一直在运行，守护线程则不会有这个情况。）</li>
</ul>
<p>以上代码大体功能满足了，但是有一个致命问题。</p>
<p>就是最近<strong>最少使用</strong>没有满足，删除的数据都是最先放入的数据。</p>
<blockquote>
<p>不过其中的 <code>put get</code> 流程算是一个简易的 HashMap 实现，可以对 HashMap 加深一些理解。</p>
</blockquote>
<h2 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h2><p>因此如何来实现一个完整的 LRU 缓存呢，这次不考虑过期时间的问题。</p>
<p>其实从上一个实现也能想到一些思路：</p>
<ul>
<li>要记录最近最少使用，那至少需要一个有序的集合来保证写入的顺序。</li>
<li>在使用了数据之后能够更新它的顺序。</li>
</ul>
<p>基于以上两点很容易想到一个常用的数据结构：<strong>链表</strong>。</p>
<ol>
<li>每次写入数据时将数据放入链表头结点。</li>
<li>使用数据时候将数据<strong>移动到头结点</strong>。</li>
<li>缓存数量超过阈值时移除链表尾部数据。</li>
</ol>
<p>因此有了以下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; cacheMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大缓存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cacheSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nodeCount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; tailer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUMap</span><span class="params">(<span class="type">int</span> cacheSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cacheSize = cacheSize;</span><br><span class="line">        <span class="comment">//头结点的下一个结点为空</span></span><br><span class="line">        header = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;();</span><br><span class="line">        header.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尾结点的上一个结点为空</span></span><br><span class="line">        tailer = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;();</span><br><span class="line">        tailer.tail = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双向链表 头结点的上结点指向尾结点</span></span><br><span class="line">        header.tail = tailer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尾结点的下结点指向头结点</span></span><br><span class="line">        tailer.next = header;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        cacheMap.put(key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双向链表中添加结点</span></span><br><span class="line">        addNode(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span>&#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;K, V&gt; node = getNode(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移动到头结点</span></span><br><span class="line">        moveToHead(node) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cacheMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(Node&lt;K,V&gt; node)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是最后的一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.tail == <span class="literal">null</span>)&#123;</span><br><span class="line">            node.next.tail = <span class="literal">null</span> ;</span><br><span class="line">            tailer = node.next ;</span><br><span class="line">            nodeCount -- ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是本来就是头节点 不作处理</span></span><br><span class="line">        <span class="keyword">if</span> (node.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果处于中间节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.tail != <span class="literal">null</span> &amp;&amp; node.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//它的上一节点指向它的下一节点 也就删除当前节点</span></span><br><span class="line">            node.tail.next = node.next ;</span><br><span class="line">            nodeCount -- ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后在头部增加当前节点</span></span><br><span class="line">        <span class="comment">//注意这里需要重新 new 一个对象，不然原本的node 还有着下面的引用，会造成内存溢出。</span></span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(node.getKey(),node.getValue()) ;</span><br><span class="line">        addHead(node) ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表查询 效率较低</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(K key)</span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; node = tailer ;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.getKey().equals(key))&#123;</span><br><span class="line">                <span class="keyword">return</span> node ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.next ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入头结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;K, V&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//容量满了删除最后一个</span></span><br><span class="line">        <span class="keyword">if</span> (cacheSize == nodeCount) &#123;</span><br><span class="line">            <span class="comment">//删除尾结点</span></span><br><span class="line">            delTail();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入头结点</span></span><br><span class="line">        addHead(node);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加头结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addHead</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入头结点</span></span><br><span class="line">        header.next = node;</span><br><span class="line">        node.tail = header;</span><br><span class="line">        header = node;</span><br><span class="line">        nodeCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果写入的数据大于2个 就将初始化的头尾结点删除</span></span><br><span class="line">        <span class="keyword">if</span> (nodeCount == <span class="number">2</span>) &#123;</span><br><span class="line">            tailer.next.next.tail = <span class="literal">null</span>;</span><br><span class="line">            tailer = tailer.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">delTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//把尾结点从缓存中删除</span></span><br><span class="line">        cacheMap.remove(tailer.getKey());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除尾结点</span></span><br><span class="line">        tailer.next.tail = <span class="literal">null</span>;</span><br><span class="line">        tailer = tailer.next;</span><br><span class="line"></span><br><span class="line">        nodeCount--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line">        Node&lt;K, V&gt; tail;</span><br><span class="line">        Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(K key)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>() ;</span><br><span class="line">        Node&lt;K,V&gt; node = tailer ;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>)&#123;</span><br><span class="line">            sb.append(node.getKey()).append(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">                    .append(node.getValue())</span><br><span class="line">                    .append(<span class="string">&quot;--&gt;&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">            node = node.next ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码：<br><a href="https://github.com/crossoverJie/Java-Interview/blob/master/src/main/java/com/crossoverjie/actual/LRUMap.java">https://github.com/crossoverJie/Java-Interview/blob/master/src/main/java/com/crossoverjie/actual/LRUMap.java</a></p>
<p>实际效果，写入时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        LRUMap&lt;String,Integer&gt; lruMap = <span class="keyword">new</span> <span class="title class_">LRUMap</span>(<span class="number">3</span>) ;</span><br><span class="line">        lruMap.put(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>) ;</span><br><span class="line">        lruMap.put(<span class="string">&quot;2&quot;</span>,<span class="number">2</span>) ;</span><br><span class="line">        lruMap.put(<span class="string">&quot;3&quot;</span>,<span class="number">3</span>) ;</span><br><span class="line"></span><br><span class="line">        System.out.println(lruMap.toString());</span><br><span class="line"></span><br><span class="line">        lruMap.put(<span class="string">&quot;4&quot;</span>,<span class="number">4</span>) ;</span><br><span class="line">        System.out.println(lruMap.toString());</span><br><span class="line"></span><br><span class="line">        lruMap.put(<span class="string">&quot;5&quot;</span>,<span class="number">5</span>) ;</span><br><span class="line">        System.out.println(lruMap.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="number">1</span>:<span class="number">1</span>--&gt;<span class="number">2</span>:<span class="number">2</span>--&gt;<span class="number">3</span>:<span class="number">3</span>--&gt;</span><br><span class="line"><span class="number">2</span>:<span class="number">2</span>--&gt;<span class="number">3</span>:<span class="number">3</span>--&gt;<span class="number">4</span>:<span class="number">4</span>--&gt;</span><br><span class="line"><span class="number">3</span>:<span class="number">3</span>--&gt;<span class="number">4</span>:<span class="number">4</span>--&gt;<span class="number">5</span>:<span class="number">5</span>--&gt;</span><br></pre></td></tr></table></figure>

<p>使用时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        LRUMap&lt;String,Integer&gt; lruMap = <span class="keyword">new</span> <span class="title class_">LRUMap</span>(<span class="number">3</span>) ;</span><br><span class="line">        lruMap.put(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>) ;</span><br><span class="line">        lruMap.put(<span class="string">&quot;2&quot;</span>,<span class="number">2</span>) ;</span><br><span class="line">        lruMap.put(<span class="string">&quot;3&quot;</span>,<span class="number">3</span>) ;</span><br><span class="line"></span><br><span class="line">        System.out.println(lruMap.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> lruMap.get(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line">        System.out.println(lruMap.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">1</span>:<span class="number">1</span>--&gt;<span class="number">2</span>:<span class="number">2</span>--&gt;<span class="number">3</span>:<span class="number">3</span>--&gt;</span><br><span class="line">==============</span><br><span class="line"><span class="number">1</span></span><br><span class="line">==============</span><br><span class="line"><span class="number">2</span>:<span class="number">2</span>--&gt;<span class="number">3</span>:<span class="number">3</span>--&gt;<span class="number">1</span>:<span class="number">1</span>--&gt;</span><br></pre></td></tr></table></figure>

<p>实现思路和上文提到的一致，说下重点：</p>
<ul>
<li>数据是直接利用 HashMap 来存放的。</li>
<li>内部使用了一个双向链表来存放数据，所以有一个头结点 header，以及尾结点 tailer。</li>
<li>每次写入头结点，删除尾结点时都是依赖于 header tailer，如果看着比较懵建议自己实现一个链表熟悉下，或结合下文的对象关系图一起理解。</li>
<li>使用数据移动到链表头时，第一步是需要在双向链表中找到该节点。这里就体现出链表的问题了。查找效率很低，最差需要 <code>O(N)</code>。之后依赖于当前节点进行移动。</li>
<li>在写入头结点时有判断链表大小等于 2 时需要删除初始化的头尾结点。这是因为初始化时候生成了两个双向节点，没有数据只是为了形成一个数据结构。当真实数据进来之后需要删除以方便后续的操作（这点可以继续优化）。</li>
<li>以上的所有操作都是线程不安全的，需要使用者自行控制。</li>
</ul>
<p>下面是对象关系图：</p>
<h3 id="初始化时"><a href="#初始化时" class="headerlink" title="初始化时"></a>初始化时</h3><p><img src="https://i.loli.net/2019/05/08/5cd1d7b842ebd.jpg"></p>
<h3 id="写入数据时"><a href="#写入数据时" class="headerlink" title="写入数据时"></a>写入数据时</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LRUMap&lt;String,Integer&gt; lruMap = <span class="keyword">new</span> <span class="title class_">LRUMap</span>(<span class="number">3</span>) ;</span><br><span class="line">lruMap.put(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>) ;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/05/08/5cd1d7bace008.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lruMap.put(<span class="string">&quot;2&quot;</span>,<span class="number">2</span>) ;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/05/08/5cd1d7bdae29e.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lruMap.put(<span class="string">&quot;3&quot;</span>,<span class="number">3</span>) ;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/05/08/5cd1d7bf974c6.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lruMap.put(<span class="string">&quot;4&quot;</span>,<span class="number">4</span>) ;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/05/08/5cd1d7c26fee5.jpg"></p>
<h3 id="获取数据时"><a href="#获取数据时" class="headerlink" title="获取数据时"></a>获取数据时</h3><p>数据和上文一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> lruMap.get(<span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/05/08/5cd1d7c54a763.jpg"></p>
<p>通过以上几张图应该是很好理解数据是如何存放的了。</p>
<h2 id="实现三"><a href="#实现三" class="headerlink" title="实现三"></a>实现三</h2><p>其实如果对 Java 的集合比较熟悉的话，会发现上文的结构和 LinkedHashMap 非常类似。</p>
<p>对此不太熟悉的朋友可以先了解下 <a href="http://crossoverjie.top/2018/02/06/LinkedHashMap/">LinkedHashMap 底层分析</a> 。</p>
<p>所以我们完全可以借助于它来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRULinkedMap</span>&lt;K,V&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大缓存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cacheSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;K,V&gt; cacheMap ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRULinkedMap</span><span class="params">(<span class="type">int</span> cacheSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cacheSize = cacheSize;</span><br><span class="line"></span><br><span class="line">        cacheMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>(<span class="number">16</span>,<span class="number">0.75F</span>,<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cacheSize + <span class="number">1</span> == cacheMap.size())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key,V value)</span>&#123;</span><br><span class="line">        cacheMap.put(key,value) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cacheMap.get(key) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Map.Entry&lt;K, V&gt;&gt; getAll() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map.Entry&lt;K, V&gt;&gt;(cacheMap.entrySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码：<br><a href="https://github.com/crossoverJie/Java-Interview/blob/master/src/main/java/com/crossoverjie/actual/LRULinkedMap.java">https://github.com/crossoverJie/Java-Interview/blob/master/src/main/java/com/crossoverjie/actual/LRULinkedMap.java</a></p>
<p>这次就比较简洁了，也就几行代码（具体的逻辑 LinkedHashMap 已经帮我们实现好了）</p>
<p>实际效果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        LRULinkedMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LRULinkedMap</span>(<span class="number">3</span>) ;</span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;2&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;3&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : map.getAll())&#123;</span><br><span class="line">            System.out.print(e.getKey() + <span class="string">&quot; : &quot;</span> + e.getValue() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;4&quot;</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : map.getAll())&#123;</span><br><span class="line">            System.out.print(e.getKey() + <span class="string">&quot; : &quot;</span> + e.getValue() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">1</span> : <span class="number">1</span>	<span class="number">2</span> : <span class="number">2</span>	<span class="number">3</span> : <span class="number">3</span>	</span><br><span class="line"><span class="number">2</span> : <span class="number">2</span>	<span class="number">3</span> : <span class="number">3</span>	<span class="number">4</span> : <span class="number">4</span>	    </span><br></pre></td></tr></table></figure>

<p>使用时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        LRULinkedMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LRULinkedMap</span>(<span class="number">4</span>) ;</span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;2&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;3&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;4&quot;</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : map.getAll())&#123;</span><br><span class="line">            System.out.print(e.getKey() + <span class="string">&quot; : &quot;</span> + e.getValue() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        map.get(<span class="string">&quot;1&quot;</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : map.getAll())&#123;</span><br><span class="line">            System.out.print(e.getKey() + <span class="string">&quot; : &quot;</span> + e.getValue() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">1</span> : <span class="number">1</span>	<span class="number">2</span> : <span class="number">2</span>	<span class="number">3</span> : <span class="number">3</span>	<span class="number">4</span> : <span class="number">4</span>	</span><br><span class="line"><span class="number">2</span> : <span class="number">2</span>	<span class="number">3</span> : <span class="number">3</span>	<span class="number">4</span> : <span class="number">4</span>	<span class="number">1</span> : <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 内部也有维护一个双向队列，在初始化时也会给定一个缓存大小的阈值。初始化时自定义是否需要删除最近不常使用的数据，如果是则会按照实现二中的方式管理数据。</p>
<p>其实主要代码就是重写了 LinkedHashMap 的 removeEldestEntry 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它默认是返回 false，也就是不会管有没有超过阈值。</p>
<p>所以我们自定义大于了阈值时返回 true，这样 LinkedHashMap 就会帮我们删除最近最少使用的数据。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是对 LRU 缓存的实现，了解了这些至少在平时使用时可以知其所以然。</p>
<p>当然业界使用较多的还有 <a href="https://github.com/google/guava">guava</a> 的实现，并且它还支持多种过期策略。</p>
<h2 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h2><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>LRU cache</category>
      </categories>
  </entry>
  <entry>
    <title>延时消息之时间轮</title>
    <url>/2019/09/27/algorithm/time%20wheel/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/09/27/kCPLBb1Rzn3uUtX.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近期在维护公司的调度平台，其中有个关键功能那就是定时任务；定时任务大家平时肯定接触的不少，比如 <code>JDK</code> 中的 <code>Timer</code>、<code>ScheduledExecutorService</code>、调度框架 <code>Quartz</code> 等。</p>
<p>通常用于实现 XX 时间后的延时任务，或周期性任务；</p>
<p>比如一个常见的业务场景：用户下单 N 分钟未能支付便自动取消订单。</p>
<p>实现这类需求通常有两种方式：</p>
<ul>
<li>轮询定时任务：给定周期内扫描所有未支付的订单，查看时间是否到期。</li>
<li>延时消息：订单创建的时候发送一条 N 分钟到期的信息，一旦消息消费后便可判断订单是否可以取消。</li>
</ul>
<span id="more"></span>

<p>先看第一种，这类方式实现较为简单，只需要启动一个定时任务即可；但缺点同样也很明显，这个间隔扫描的时间不好控制。</p>
<p>给短了会造成很多无意义的扫描，增大数据库压力，给长了又会使得误差较大。</p>
<p>当然最大的问题还是效率较低，随着订单增多耗时会呈线性增长，最差的情况甚至会出现上一波轮询还没有扫描完，下一波调度又来了。</p>
<hr>
<p>这时第二种方案就要显得靠谱多了，通过延时消息可以去掉不必要的订单扫描，实时性也比较高。</p>
<h1 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h1><p>这里我们不过多讨论这类需求如何实现；重点聊聊这个延时消息，看它是如何实现的，基于实现延时消息的数据结构还能实现定时任务。</p>
<p>我在之前的开源 <a href="https://github.com/crossoverJie/cim">IM</a> 项目中也加入了此类功能，可以很直观的发送一条延时消息，效果如下：</p>
<p><img src="https://i.loli.net/2019/09/27/qDoORJP4bunY5Na.gif"></p>
<p>使用 <code>:delay hahah 2</code> 发送了一条两秒钟的延时消息，另外一个客户端将会在两秒钟之后收到该消息。</p>
<p>具体的实现步骤会在后文继续分析。</p>
<h1 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h1><p>要实现延时消息就不得不提到一种数据结构【<code>时间轮</code>】，时间轮听这名字可以很直观的抽象出它的数据结构。</p>
<p><img src="https://i.loli.net/2019/09/27/F2KAoSpidyL5IJD.jpg"></p>
<p>其实本质上它就是一个环形的数组，如图所示，假设我们创建了一个长度为 8 的时间轮。</p>
<hr>
<p><code>task0</code> &#x3D; 当我们需要新建一个 5s 延时消息，则只需要将它放到下标为 5 的那个槽中。</p>
<p><code>task1</code> &#x3D; 而如果是一个 10s 的延时消息，则需要将它放到下标为 2 的槽中，<strong>但同时需要记录它所对应的圈数</strong>，不然就和 2 秒的延时消息重复了。</p>
<p><code>task2</code>&#x3D; 当创建一个 21s 的延时消息时，它所在的位置就和 <code>task0</code> 相同了，都在下标为 5 的槽中，所以为了区别需要为他加上圈数为 2。</p>
<p><img src="https://i.loli.net/2019/09/27/kauCzgjDJ93q4Ao.jpg"></p>
<p>通过这张图可以更直观的理解。</p>
<p>当我们需要取出延时消息时，只需要每秒往下移动这个指针，然后取出该位置的所有任务即可。</p>
<p>当然取出任务之前还得判断圈数是否为 0 ，不为 0 时说明该任务还得再轮几圈，同时需要将圈数 -1 。</p>
<p>这样就可避免轮询所有的任务，不过如果时间轮的槽比较少，导致某一个槽上的任务非常多那效率也比较低，这就和 <code>HashMap</code> 的 <code>hash</code> 冲突是一样的。</p>
<h1 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h1><p>理论讲完后我们来看看实际的编码实现，为此我创建了一个 <code>RingBufferWheel</code> 类。</p>
<p>它的主要功能如下：</p>
<ul>
<li>可以添加指定时间的延时任务，在这个任务中可以实现自己的业务逻辑。</li>
<li>停止运行（包含强制停止和所有任务完成后停止）。</li>
<li>查看待执行任务数量。</li>
</ul>
<p>首先直接看看这个类是如何使用的。</p>
<p><img src="https://i.loli.net/2019/09/27/wQHFflauOZkoeiP.jpg"></p>
<p>我在这里创建了 65 个延时任务，每个任务都比前一个延后 1s 执行；同时自定义了一个 <code>Job</code> 类来实现自己的业务逻辑，最后调用 <code>stop(false)</code> 会在所有任务执行完毕后退出。</p>
<p><img src="https://i.loli.net/2019/09/27/iAZTBKW8kjwDRcg.jpg"></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><img src="https://i.loli.net/2019/09/27/GFCNYSoiDlfeR6L.jpg"></p>
<p>先来看看其中的构造函数，这里一共有两个构造函数，用于接收一个线程池及时间轮的大小。</p>
<p>线程池的作用会在后面讲到。</p>
<p>这里的时间轮大小也是有讲究的，它的长度必须得是 <code>2∧n</code>，至于为什么有这个要求后面也会讲到。</p>
<p>默认情况下会初始化一个长度为 64 的数组。</p>
<h2 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h2><p><img src="https://i.loli.net/2019/09/27/kauCzgjDJ93q4Ao.jpg"></p>
<p>下面来看看添加任务的逻辑，根据我们之前的那张抽象图其实很容易实现。</p>
<hr>
<p><img src="https://i.loli.net/2019/09/27/6Wgm85sO3JCVIrz.jpg"></p>
<p>首先我们要定义一个 <code>Task</code> 类，用于抽象任务；它本身也是一个线程，一旦延时到期便会执行其中的 run 函数，所以使用时便可继承该类，将业务逻辑写在 <code>run()</code> 中即可。</p>
<p>它其中还有两个成员变量，也很好理解。</p>
<ul>
<li><code>cycleNum</code> 用于记录该任务所在时间轮的圈数。</li>
<li><code>key</code> 在这里其实就是延时时间。</li>
</ul>
<hr>
<p><img src="https://i.loli.net/2019/09/27/ZAyc6MLFPIaEmxX.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过 key 计算应该存放的位置</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Task&gt; <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> mod(key, bufferSize);</span><br><span class="line">    <span class="keyword">return</span> (Set&lt;Task&gt;) ringBuffer[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">mod</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> mod)</span> &#123;</span><br><span class="line">    <span class="comment">// equals target % mod</span></span><br><span class="line">    target = target + tick.get() ;</span><br><span class="line">    <span class="keyword">return</span> target &amp; (mod - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>首先是根据延时时间 (<code>key</code>) 计算出所在的位置，其实就和 <code>HashMap</code> 一样的取模运算，只不过这里使用了位运算替代了取模，同时效率会高上不少。</p>
<blockquote>
<p>这样也解释了为什么数组长度一定得是 <code>2∧n</code>。</p>
</blockquote>
<p>然后查看该位置上是否存在任务，不存在就新建一个；存在自然就是将任务写入这个集合并更新回去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">cycleNum</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> mod)</span> &#123;</span><br><span class="line">    <span class="comment">//equals target/mod</span></span><br><span class="line">    <span class="keyword">return</span> target &gt;&gt; Integer.bitCount(mod - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中的 <code>cycleNum()</code> 自然是用于计算该任务所处的圈数，也是考虑到效率问题，使用位运算替代了除法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, Set&lt;Task&gt; tasks)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> mod(key, bufferSize);</span><br><span class="line">    ringBuffer[index] = tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>put()</code> 函数就非常简单了，就是将任务写入指定数组下标即可。</p>
<h2 id="启动时间轮"><a href="#启动时间轮" class="headerlink" title="启动时间轮"></a>启动时间轮</h2><p>任务写进去后下一步便是启动这个时间轮了，我这里定义了一个 <code>start()</code> 函数。</p>
<p><img src="https://i.loli.net/2019/09/27/h4xAKnRosTpirEW.jpg"></p>
<p>其实本质上就是开启了一个后台线程来做这个事情：</p>
<p><img src="https://i.loli.net/2019/09/27/fyvUKj3hrwbWRt9.jpg"></p>
<p>它会一直从时间轮中取出任务来运行，而运行这些任务的线程便是我们在初始化时传入的线程池；所以所有的延时任务都是由自定义的线程池调度完成的，这样可以避免时间轮的阻塞。</p>
<p>这里调用的 <code>remove(index)</code> 很容易猜到是用于获取当前数组中的所有任务。</p>
<p><img src="https://i.loli.net/2019/09/27/9Gt4Mh8uHckmenw.jpg"></p>
<p>逻辑很简单就不再赘述，不过其中的 <code>size2Notify()</code> 倒是值得说一下。</p>
<p><img src="https://i.loli.net/2019/09/27/1bJaHKFlpeEyYqI.jpg"></p>
<p>他是用于在停止任务时，主线程等待所有延时任务执行完毕的唤醒条件。这类用法几乎是所有线程间通信的常规套路，值得收入技能包。</p>
<h2 id="停止时间轮"><a href="#停止时间轮" class="headerlink" title="停止时间轮"></a>停止时间轮</h2><p>刚才提到的唤醒主线程得配合这里的停止方法使用：</p>
<p><img src="https://i.loli.net/2019/09/27/kg9taKAOS5bnfHe.jpg"></p>
<p>如果是强制停止那便什么也不管，直接更新停止标志，同时关闭线程池即可。</p>
<p>但如果是软停止（等待所有任务执行完毕）时，那就得通过上文提到的方式阻塞主线程，直到任务执行完毕后被唤醒。</p>
<h1 id="CIM-中的应用"><a href="#CIM-中的应用" class="headerlink" title="CIM 中的应用"></a>CIM 中的应用</h1><p>介绍了核心原理和基本 <code>API</code> 后，我们来看看实际业务场景如何结合使用（背景是一个即时通讯项目）。</p>
<p>我这里所使用的场景在文初也提到了，就是真的发送一条延时消息；</p>
<p><img src="https://i.loli.net/2019/09/27/qDoORJP4bunY5Na.gif"></p>
<p>现有的消息都是实时消息，所以要实现一个延时消息便是在现有的发送客户端处将延时消息放入到这个时间轮中，在任务到期时再执行真正的消息发送逻辑。</p>
<p>由于项目本身结合了 <code>Spring</code>，所以第一步自然是配置 <code>bean</code>。</p>
<p><img src="https://i.loli.net/2019/09/27/XLtUdOwpbghy4J8.jpg"></p>
<p><code>bean</code> 配置好后其实就可以使用了。</p>
<p><img src="https://i.loli.net/2019/09/27/ERIkrX6HLx1ZhAq.jpg"></p>
<p>每当发送的是延时消息时，只需要将这个消息封装为一个 <code>Job</code> 放到时间轮中，然后在自己的业务类中完成业务即可。</p>
<blockquote>
<p>后续可以优化下 <code>api</code>，不用每次新增任务都要调用 <code>start()</code> 方法。</p>
</blockquote>
<p>这样一个延时消息的应用便完成了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>时间轮这样的应用还非常多，比如 <code>Netty</code> 中的 <code>HashedWheelTimer</code> 工具原理也差不多，可以用于维护长连接心跳信息。</p>
<p>甚至 <code>Kafka</code> 在这基础上还优化出了层级时间轮，这些都是后话了，大家感兴趣的话可以自行搜索资料或者抽时间我再完善一次。</p>
<p>这篇文章从前期准备到撸码实现还是花了不少时间，如果对你有帮助的话还请点赞转发。</p>
<p>本文的所有源码都可在此处查阅：</p>
<p><a href="https://github.com/crossoverJie/cim/blob/master/cim-common/src/main/java/com/crossoverjie/cim/common/data/construct/RingBufferWheel.java">https://github.com/crossoverJie/cim</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>时间轮</tag>
      </tags>
  </entry>
  <entry>
    <title>定时任务方案大百科</title>
    <url>/2019/10/14/algorithm/timer-detail/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/10/13/6CGWqQp43avTsLx.jpg"></p>
<blockquote>
<p>原文地址：<a href="https://crossoverjie.top/">https://crossoverjie.top</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>节前有更新一篇定时任务的相关文章<a href="https://crossoverjie.top/2019/09/27/algorithm/time%20wheel/">《延时消息之时间轮》</a>，有朋友提出希望可以完整的介绍下常见的定时任务方案，于是便有了这篇文章。</p>
<span id="more"></span>

<h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>本次会主要讨论大家使用较多的方案，首先第一个就是 <code>Timer</code> 定时器，它可以在指定时间后运行或周期性运行任务；使用方法也非常简单：</p>
<p><img src="https://i.loli.net/2019/10/13/dWENybZVTeaukiI.jpg"></p>
<p>这样便可创建两个简单的定时任务，分别在 <code>3s/5s</code> 之后运行。</p>
<p>使用起来确实很简单，但也有不少毛病，想要搞清楚它所存在的问题首先就要理解其实现原理。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>定时任务要想做到按照我们给定的时间进行调度，那就得需要一个可以排序的容器来存放这些任务。</p>
<p>在 <code>Timer</code> 中内置了一个 <code>TaskQueue</code> 队列，用于存放所有的定时任务。</p>
<p><img src="https://i.loli.net/2019/10/13/Lzb1HNYPRlGuDtV.jpg"></p>
<p>其实本质上是用数组来实现的一个<code>最小堆</code>，它可以让每次写入的定时任务都按照执行时间进行排序，保证在堆顶的任务执行时间是最小的。</p>
<p>这样在需要执行任务时，每次只需要取出堆顶的任务运行即可，所以它取出任务的效率很高为<img src="https://i.loli.net/2019/10/13/SQiJdxYb6LrIDtN.jpg">。</p>
<p>结合代码会比较容易理解：</p>
<p><img src="https://i.loli.net/2019/10/13/nW7rRdGmUhZJ9B4.jpg"></p>
<p>在写入任务的时候会将一些基本属性存放起来（任务的调度时间、周期、初始化任务状态等），最后就是要将任务写入这个内置队列中。</p>
<p><img src="https://i.loli.net/2019/10/13/pdAFsRBaiLvUXnx.jpg"><br><img src="https://i.loli.net/2019/10/13/dnM9G8tqAo5Iigp.jpg"></p>
<p>在任务写入过程中最核心的方法便是这个 <code>fixUp()</code> ,它会将写入的任务从队列的中部通过执行时间与前一个任务做比对，一直不断的向前比较。</p>
<p>如果这个时间是最早执行的，那最后将会被移动到堆顶。</p>
<p><img src="https://i.loli.net/2019/10/13/MCaxQLnEOdWhkP6.jpg"></p>
<p>通过这个过程可以看出 <code>Timer</code> 新增一个任务的时间复杂度为<img src="https://i.loli.net/2019/10/13/yq8um7egtYMUR4P.jpg">。</p>
<hr>
<p>再来看看它执行任务的过程，其实在初始化 <code>Timer</code> 的时候它就会在后台启动一个线程用于从 <code>TaskQueue</code> 队列中获取任务进行调度。</p>
<p><img src="https://i.loli.net/2019/10/13/obDHQ84ZitJ5nsv.jpg"><br><img src="https://i.loli.net/2019/10/13/1gq4aX6wJzCKYRy.jpg"></p>
<p>所以我们只需要看他的 <code>run()</code> 即可。</p>
<p><img src="https://i.loli.net/2019/10/13/tRFa8uQWrCwdTAs.jpg"></p>
<p>从这段代码中很明显可以看出这个线程是一直不断的在调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">task = queue.getMin();</span><br></pre></td></tr></table></figure>
<p>来获取任务，最后使用 <code>task.run()</code> 来执行任务。</p>
<p><img src="https://i.loli.net/2019/10/13/LEAtVPxJalzkY72.jpg"></p>
<p>从 <code>getMin()</code> 方法中可以看出和我们之前说的一致，每次都是取出堆顶的任务执行。</p>
<p>一旦取出来的任务执行时间满足要求便可运行，同时需要将它从这个最小堆实现的队列中删除；也就是调用的 <code>queue.removeMin()</code> 方法。</p>
<p><img src="https://i.loli.net/2019/10/13/dgMlfCHoLbrS81R.jpg"><br><img src="https://i.loli.net/2019/10/13/X146xsFrZefuWdP.jpg"></p>
<p>其实它的核心原理和写入任务类似，只不过是把堆尾的任务提到堆顶，然后再依次比较将任务往后移，直到到达合适的位置。</p>
<blockquote>
<p>从刚才的写入和删除任务的过程中其实也能看出，这个最小堆只是相对有序并不是绝对的有序。</p>
</blockquote>
<p>源码看完了，自然也能得出它所存在的问题了。</p>
<ul>
<li>后台调度任务的线程只有一个，所以导致任务是阻塞运行的，一旦其中一个任务执行周期过长将会影响到其他任务。</li>
<li><code>Timer</code> 本身没有捕获其他异常（只捕获了 <code>InterruptedException</code>），一旦任务出现异常（比如空指针）将导致后续任务不会被执行。</li>
</ul>
<h1 id="ScheduledExecutor"><a href="#ScheduledExecutor" class="headerlink" title="ScheduledExecutor"></a>ScheduledExecutor</h1><p>既然 <code>Timer</code> 存在一些问题，于是在 <code>JDK1.5</code> 中的并发包中推出了 <code>ScheduledThreadPoolExecutor</code> 来替代 <code>Timer</code>，从它所在包路径也能看出它本身是支持任务并发执行的。</p>
<p>先来看看它的类继承图：</p>
<p><img src="https://i.loli.net/2019/10/13/vYkj8HGn9hFsRIK.jpg"></p>
<p>可以看到他本身也是一个线程池，继承了 <code>ThreadPoolExecutor</code>。</p>
<p><img src="https://i.loli.net/2019/10/13/S5giR8ukcfJAhzB.jpg"></p>
<p>从他的构造函数中也能看出，本质上也是创建了一个线程池，只是这个线程池中的阻塞队列是一个自定义的延迟队列 <code>DelayedWorkQueue</code>（与 <code>Timer</code> 中的 <code>TaskQueue</code> 作用一致）</p>
<hr>
<h2 id="新建任务"><a href="#新建任务" class="headerlink" title="新建任务"></a>新建任务</h2><p><img src="https://i.loli.net/2019/10/13/5ulvg6csiprkGYy.jpg"></p>
<p>当我们写入一个定时任务时，首先会将任务写入到 <code>DelayedWorkQueue</code> 中，其实这个队列本质上也是使用数组实现的最小堆。</p>
<p><img src="https://i.loli.net/2019/10/13/gyJEMni9WjQ528h.jpg"></p>
<p>新建任务时最终会调用到 <code>offer()</code> 方法，在这里也会使用 <code>siftUp()</code> 将写入的任务移动到堆顶。</p>
<p><img src="https://i.loli.net/2019/10/13/gWu6BFw9KLrnYDO.jpg"></p>
<p><img src="https://i.loli.net/2019/10/13/YyRvDxC4r16zKfH.jpg"></p>
<p><img src="https://i.loli.net/2019/10/13/RlwgZ6SybYf7h9C.jpg"></p>
<p>原理就和之前的 <code>Timer</code> 类似，只不过这里是通过自定义比较器来排序的，很明显它是通过任务的执行时间进行比较的。</p>
<h2 id="运行任务"><a href="#运行任务" class="headerlink" title="运行任务"></a>运行任务</h2><p>所以这样就能将任务按照执行时间的顺序排好放入到线程池中的阻塞队列中。</p>
<p>这时就得需要回顾一下之前线程池的知识点了：</p>
<blockquote>
<p>在线程池中会利用初始化时候的后台线程从阻塞队列中获取任务，只不过在这里这个阻塞队列变为了 <code>DelayedWorkQueue</code>，所以每次取出来的一定是按照执行时间排序在前的任务。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/10/13/rRUDnSjGloHfyZP.jpg"><br><img src="https://i.loli.net/2019/10/13/h7ZszAwluP6GIpy.jpg"></p>
<p>和 <code>Timer</code> 类似，要在任务取出后调用 <code>finishPoll()</code> 进行删除，也是将最后一个任务提到堆顶，然后挨个对比移动到合适的位置。</p>
<p>而触发消费这个 <code>DelayedWorkQueue</code> 队列的地方则是在写入任务的时候。</p>
<p><img src="https://i.loli.net/2019/10/13/kPewBVyFgsXzpuR.jpg"><br><img src="https://i.loli.net/2019/10/13/KmYwjU7345VbZvo.jpg"></p>
<p>本质上是调用 <code>ThreadPoolExecutor</code> 的 <code>addWorker()</code> 来写入任务的，所以消费 <code>DelayedWorkQueue</code> 也是在其中触发的。</p>
<p>这里更多的是关于线程池的知识点，不太清楚的可以先看看之前总结的线程池篇，这里就不再赘述。</p>
<ul>
<li><a href="https://crossoverjie.top/2019/05/20/concurrent/threadpool-01/">线程池没你想的那么简单</a></li>
<li><a href="https://crossoverjie.top/2019/06/06/concurrent/threadpool-02/">线程池没你想的那么简单（续）</a></li>
</ul>
<p>原理看完了想必也知道和 <code>Timer</code> 的优势在哪儿了。</p>
<table>
<thead>
<tr>
<th align="center">Timer</th>
<th align="center">ScheduledThreadPoolExecutor</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单线程阻塞</td>
<td align="center">多线程任务互不影响</td>
</tr>
<tr>
<td align="center">异常时任务停止</td>
<td align="center">依赖于线程池，单个任务出现异常不影响其他任务</td>
</tr>
</tbody></table>
<p>所以有定时任务的需求时很明显应当淘汰 <code>Timer</code> 了。</p>
<h1 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h1><p>最后一个是基于时间轮的定时任务，这个我在上一篇<a href="https://crossoverjie.top/2019/09/27/algorithm/time%20wheel/">《延时消息之时间轮》</a>有过详细介绍。</p>
<p>通过源码分析我们也可以来做一个对比：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">ScheduledThreadPoolExecutor</th>
<th align="center">基于时间轮</th>
</tr>
</thead>
<tbody><tr>
<td align="center">写入效率</td>
<td align="center"><img src="https://i.loli.net/2019/10/13/yq8um7egtYMUR4P.jpg">基于最小堆，任务越多效率越低</td>
<td align="center"><img src="https://i.loli.net/2019/10/13/SQiJdxYb6LrIDtN.jpg"> 与 <code>HashMap</code> 的写入类似，效率很高。</td>
</tr>
<tr>
<td align="center">执行效率</td>
<td align="center"><img src="https://i.loli.net/2019/10/13/SQiJdxYb6LrIDtN.jpg"> 每次取出第一个，效率很高</td>
<td align="center"><img src="https://i.loli.net/2019/10/13/SQiJdxYb6LrIDtN.jpg"> 每秒拨动一个指针取出任务</td>
</tr>
</tbody></table>
<p>所以当写入的任务较多时，推荐使用时间轮，它的写入效率更高。</p>
<p>但任务很少时其实 <code>ScheduledThreadPoolExecutor</code> 也不错，毕竟它不会每秒都去拨动指针消耗 <code>CPU</code> ，而是一旦没有任务线程会阻塞直到有新的任务写入进来。</p>
<h2 id="RingBufferWheel-更新"><a href="#RingBufferWheel-更新" class="headerlink" title="RingBufferWheel 更新"></a>RingBufferWheel 更新</h2><p>在之前的<a href="https://crossoverjie.top/2019/09/27/algorithm/time%20wheel/">《延时消息之时间轮》</a>中自定义了一个基于时间轮的定时任务工具 <code>RingBufferWheel</code> ，在网友的建议下这次顺便也做了一些调整，优化了 API 也新增了取消任务的 API。</p>
<p><img src="https://i.loli.net/2019/10/13/WDseB5zkGUHIjSy.jpg"></p>
<p>在之前的 API 中，每当新增一个任务都要调用一下 <code>start()</code>，感觉很怪异；这次直接将启动函数合并到 <code>addTask</code> 中，使用起来更加合理。</p>
<p>同时任务的写入也支持并发了。</p>
<p><img src="https://i.loli.net/2019/10/13/dcDfJExQposvGFU.jpg"><br><img src="https://i.loli.net/2019/10/13/UjRbE4wa7c2og1N.jpg"></p>
<p>不过这里需要注意的是 <code>start()</code> 在并发执行的时候只能执行一次，于是就利用了 <code>CAS</code> 来保证同时只有一个线程可以执行成功。</p>
<p>同时在新增任务的时候会返回一个 <code>taskId</code> ，利用此 ID 便可实现取消任务的需求（虽然是比较少见），使用方法如下：</p>
<p><img src="https://i.loli.net/2019/10/13/t9B5JWNwgxOpTQy.jpg"></p>
<p>感兴趣的朋友可以看下源码也很容易理解。</p>
<h1 id="分布式定时任务"><a href="#分布式定时任务" class="headerlink" title="分布式定时任务"></a>分布式定时任务</h1><p>最后再扩展一下，上文我们所提到的所有方案都是单机版的，只能在单个进程中使用。</p>
<p>一旦我们需要在分布式场景下实现定时任务的高可用、可维护之类的需求就得需要一个完善的分布式调度平台的支持。</p>
<p>目前市面上流行的开源解决方案也不少：</p>
<ul>
<li><a href="https://github.com/xuxueli/xxl-job/">xxl_job</a></li>
<li><a href="https://github.com/elasticjob/elastic-job-lite">elastic_job</a></li>
<li><a href="https://github.com/ltsopensource/light-task-scheduler">light-task-scheduler</a></li>
</ul>
<p>我个人在工作中只使用过前面两者，都能很好的解决分布式调度的需求；比如高可用、统一管理、日志报警等。</p>
<p>当然这些开源工具其实在定时调度这个功能上和上文中所提到的一些方案是分不开的，只是需要结合一些分布式相关的知识；比远程调用、统一协调、分布式锁、负载均衡之类的。</p>
<p>感兴趣的朋友可以自行查看下他们的源码或官方文档。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个小小的定时器其实涉及到的知识点还不少，包括数据结构、多线程等，希望大家看完多少有些帮助，顺便帮忙点赞转发搞起🥳。</p>
<p>本文所涉及到的所有源码：</p>
<p><a href="https://github.com/crossoverJie/cim">https://github.com/crossoverJie/cim</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Java</category>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>时间轮</tag>
        <tag>Timer</tag>
        <tag>Schedule</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 年度复盘</title>
    <url>/2018/12/30/annual-summary/2018/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1c31d7fb1b.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看着今年的进度表已经所剩无几，是时候来复盘一把了。</p>
<span id="more"></span>

<p><img src="https://i.loli.net/2019/05/08/5cd1c323a08b1.jpg"></p>
<p>从 16 年初写博客开始到现在我觉得写年终总结的习惯不错，毕竟每次看着去年的 <code>flag</code> 又可以复制粘贴了。</p>
<p>今年我会从工作、技术、身体等方面回顾，这几块也是今年变化最大的几个点。</p>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>先说工作吧，这个变化也贯穿了整年。</p>
<p>从今年年初开始，我从上一个技术团队调到现在的部门；首先是组织结构上的变更，当然更主要的还是角色的变化。</p>
<p>由一个开发人员转变为团队的技术负责人，说实话刚开始是措手不及的。</p>
<p>以前我只需要对我写的代码负责，现在不行了。得对整个团队的产出负责；需要为每一个成员的质量、成长负责。</p>
<p>这对于一个刚入门的菜鸟来说挑战无疑是巨大的。</p>
<p>而且整个研发团队基本上是重头组建，我这入职一年多的都成了司龄最大的老员工了😢。</p>
<p>随着人员的增加，对我的要求也越来越高。在请教了老司机后也逐渐的走上正轨了，虽然中间也踩了不少坑。</p>
<p>总的来说：</p>
<blockquote>
<p>以前只关注我代码写的 6 不 6；现在重点是整个团队的<strong>研发进度、质量把控</strong>。这两点是评估我工作好坏的直接因素。</p>
</blockquote>
<p>要把这两项搞好我不得不提高一些通用技能：包括沟通协调、需求判断、排期风险、人员流动等。</p>
<p>明年的人数还会持续增加，要学的东西还有很多。</p>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><p>作为一个代码从业者，技术能力才是我的本职工作。</p>
<p>随着今年业务性质的变化，我所接触的技术也略有不同。</p>
<p>前几年打交道的主要是 web 相关的技术；大多数技术栈都是围绕着它来展开的。</p>
<p>而今年不太一样的是在 web 的基础上，还需要涉及到网络。主要是现在业务和物联网相关，看平台的还好最直接的就是能支持了多少连接。</p>
<p>这个就需要对物联网特有的一些协议有所了解、应用。</p>
<p>所以今年恶补了 <code>Netty</code> 相关的知识，同时在平时的开发中进行了一些实践发现想要做好网络这种底层开发需要储备的知识太多了。</p>
<p>什么操作系统、<code>IO</code>、<code>TCP</code> 都得掌握，正好也补习了这些短板。</p>
<h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p><img src="https://i.loli.net/2019/05/08/5cd1c32643707.jpg"></p>
<p>GitHub 官方的年度报告可以看出今年是开源大年。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c32a8ba7c.jpg"></p>
<p>从我今年的贡献图可以看出也花了很多时间在这上面。</p>
<p>从注册 GitHub 账号算起每年的提交量看起来今年确实是花了不少心思：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3319ccf6.jpg"></p>
<p>最显著的体现就是 <a href="https://github.com/crossoverJie/JCSprout">JCSprout</a> 一年时间涨了 <code>1W7 star</code>。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c336678b6.jpg"></p>
<p>主要开源的有：</p>
<ul>
<li><a href="https://github.com/crossoverJie/JCSprout">JCSprout</a> <code>Java Core Sprout</code>：处于萌芽阶段的 <code>Java</code> 核心知识库。</li>
<li><a href="https://github.com/TogetherOS/cicada">cicada</a> 基于 <code>Netty</code> 实现的快速、轻量级 <code>HTTP</code> 框架。</li>
<li><a href="https://github.com/crossoverJie/distributed-redis-tool">distributed-redis-tool</a> 根据日常需求实现的一个分布式工具，包括分布式锁、分布式限流。</li>
<li><a href="https://github.com/crossoverJie/netty-action">netty-action</a> 看名字就知道，一个 <code>netty</code> 实战相关案例，现在也正在修改为可水平扩展的 <code>IM</code> 即使通讯系统；预计元旦后发布。</li>
</ul>
<p>要感谢每一位给我提 <code>issue、PR</code> 的朋友，希望来年能把挖的坑填完😭。</p>
<h2 id="技术博客"><a href="#技术博客" class="headerlink" title="技术博客"></a>技术博客</h2><p><img src="https://i.loli.net/2019/05/08/5cd1c3381157d.jpg"></p>
<p>从年初到现在一共撸了 49 篇博客，我还特意按照时间排序、阅读量做了一个柱状图（数据来源为个人博客：<a href="https://crossoverjie.top/">https://crossoverjie.top</a> ）：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c33c24697.jpg"></p>
<p>统计了一下，全年这个博客的阅读总数为：22W，平均每篇差不多 4500 的阅读；虽说不能和一些大佬相比，但比去年可不知道高哪里去了。</p>
<p>同时最高的有将近 2W 当然低的也有4 500的阅读数，不过从这个图中还是可以看出一些规律的。</p>
<blockquote>
<p>比如阅读量高的也是比较吸引眼球的，这不就是常说的“标题党”嘛。</p>
</blockquote>
<h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><p>再来谈谈公众号，现在做公众号的技术人也越来越多；不过在今年申请的账号已经没有留言功能了，还好我申请的早，至少和读者有一个交流的机会。</p>
<p>今年也是把公众号从 0 做到了 1 ，也就是有了 1W+ 的关注数；不过说实话我确实没有画什么心思运营，里面的内容也都是同步于我的博客，除了几篇翻译之外可以说是 100% 原创。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3481859b.jpg"></p>
<p>写过技术文的应该都知道产出一篇文章并不轻松，所以为了能正向激励我也会适当的接一些广告；这样不管是对读者还是我都有好处。</p>
<blockquote>
<p>中途也有一些朋友找我投稿，由于目前不是定位于做一个自媒体；我个人也不能完全对转载的文章理解透彻，还是希望做一个原创的技术号，所以抱歉都没有转载。</p>
</blockquote>
<h1 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h1><p>从前几年的计划表中都提到了身体，但实话说直到现在记性没长只有体重长了。。。</p>
<p>原本热爱的篮球也从每周一次调整为一个月一次，曾经潇洒的 <code>crossover</code> 也变为键盘里一个个的 <code>Bug</code>。</p>
<p>从下面的视频中可以看得出来（需要 FQ 观看）：</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/fg2jqLtDKac" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<hr>
<iframe width="560" height="315" src="https://www.youtube.com/embed/qnfZkSDQi8U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<hr>
<iframe width="560" height="315" src="https://www.youtube.com/embed/c2GgPDOFv9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


<blockquote>
<p>第一段是五年前的，后面两段为最近的。</p>
</blockquote>
<p>明年真得上心了，借着搬家到新小区内的篮球场看能否拯救我这多年的键盘手。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回顾一下对于我个人的几个大事件吧：</p>
<ul>
<li>工作角色大变化，带来的挑战也很大。</li>
<li>做了几个还算成功开源项目，并且带来了一些实质性的好处。</li>
<li>公众号从 0 到 1 ，并且能补贴一些鸡腿钱。</li>
<li>求婚成功，感谢高中班主任当年的不杀之恩（没有揭发我）。</li>
<li>等了三年终于接房装修了。</li>
</ul>
<p>按照历史传统照例还是写个明年的 <code>TODO-LIST</code> 吧：</p>
<ul>
<li>别拖团队后腿，多和老司机学习下软技能。</li>
<li>开源项目接着更新，这也是可持续发展道路之一。</li>
<li>博客、公众号持续输出优质内容，只是更新周期可能会提高。</li>
<li>要逼就往死里逼，看年底能否扣个篮！</li>
<li>搞个事情，看能否把婚接了。</li>
</ul>
<p>对来年写总结的我诚恳的说一句：别在 <code>Ctrl+C,Ctrl+V</code> 了🙏。</p>
]]></content>
      <categories>
        <category>annual-summary</category>
      </categories>
  </entry>
  <entry>
    <title>2019年度总结</title>
    <url>/2019/12/30/annual-summary/2019/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/01/02/o5DSAQsdU6FhjLW.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>消失两个多月后我胡汉三又回来了，比较遗憾的是这并不是一篇技术文，有兴趣的朋友就当做故事看吧。</p>
<p>所以这其实是一份年终总结</p>
<p>其实这段期间一直有朋友在问我咋不接着更新公众号了？甚至一点消息都没了。</p>
<p>真不是不更，主要有以下几个原因：</p>
<span id="more"></span>

<p>我对这个号的定位是【原创技术】博主，大家应该也知道，技术号是一种非常垂直的领域，能写的东西也就那么多；以我个人的工作阅历其实已经快被榨干了。</p>
<p>平时大家应该也能看得出，不少公众号逐渐开始转载和原创混着来，甚至有些已经是全职的转载号了。</p>
<p>当然我不是说这样不好，每个人的选择不同；只是我对我个人的要求是：要么就不写，不然就得是有意义的原创。</p>
<p>乍一看还挺有骨气，然而现实却是两个多月没更新了。</p>
<p><img src="https://i.loli.net/2020/01/02/rkDSUtpo39myNdn.jpg"></p>
<p>所以我现在也在不断学习，希望今年能再给大家带来一些有意思的内容。</p>
<hr>
<p>第二个原因今年下半年我换了份工作，面对全新的领域需要花上不少时间去学习；同时也需要完成几件人生大事，所以总得有侧重点。</p>
<p>具体内容请接着往下看。</p>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>2019年对我来说真的是意义重大的一年，今年发生了许多大事；用我妈的话来说就是喜事连连。<br><img src="https://i.loli.net/2020/01/02/FtRviQBrpJkoSul.jpg"></p>
<h2 id="新家"><a href="#新家" class="headerlink" title="新家"></a>新家</h2><p>确实每一件事对我来说都不是小事；首先是终于搬进了新家。</p>
<p><img src="https://i.loli.net/2020/01/02/lh4PkDSMgd15qzs.jpg"></p>
<p>从去年接房到经历半年的装修终于是搬进了新家，告别了 3 年多的租房日子；但也不是一帆风顺，从装修中踩的坑，以及和家人意见不一致导致的分歧都让这个新房来之不易。</p>
<p>期间为了让我的房间看起来更有极客范，满足所谓的”程序员“逼格；我还特地搞了一套智能家居，现在用了半年发现优点还是明显，但也偶尔会在智能和智障中来回切换。</p>
<p>原本我打算拍一期与智能家居相关的视频来着，也是由于上面两个原因耽搁了，大家感兴趣的话也可以和大家分享。</p>
<p>谈到视频，今年我还更新了 10 期 vlog。</p>
<p><img src="https://i.loli.net/2020/01/02/gsPxD45fhdkUbAn.jpg"></p>
<p>其实效果也不错，也有好多小伙伴反馈挺有意思，但也是自己懒就停更了，来年也得捡起来了，做视频我也很感兴趣，年纪大了后再看看当年的自己我想会很有意思。</p>
<h2 id="新车"><a href="#新车" class="headerlink" title="新车"></a>新车</h2><p>第二件大事自然就是提车了，这事其实完全没在我今年的计划清单里的。</p>
<p>我从拿证到提车中间只间隔了一个周末。</p>
<p>当然第一次事故来的也比较快，好在现在胆子也越来越大；刚提车那段时间，早上为了躲避早高峰我甚至六点过就开车去公司，同样的下班也是8、9点钟才最后一个走。让我一度怀疑我这车买来是遭罪的。</p>
<p><img src="https://i.loli.net/2020/01/02/2mncqwDOCokUS5a.jpg"></p>
<p>还一度成为了公司笑柄，好在现在三个多月已经没那么怂了，当然我也不敢再立 flag 了，第一次剐蹭就是某天早上在公司炫耀不再早起后出事的。</p>
<h2 id="领证"><a href="#领证" class="headerlink" title="领证"></a>领证</h2><p><img src="https://i.loli.net/2020/01/02/NvRlXHOQyo5G26F.jpg"></p>
<p>毫不犹豫这是今年办的最重要的一件事；从 2011 年开始的异地校园恋到现在我都不敢想象真的成了。前几天我填了一个调查问卷，文末让填写婚姻情况，当我习惯性的准备填写未婚时发现我居然也结婚了，当时的心情就像被陌生人归还丢失的钱包，不禁感慨还是好心人多啊。</p>
<p>现在想想我的节奏是去年求婚、今年领证、明年婚礼；看似间隔了挺长但也循序渐进，希望各位读者朋友也早日脱单。</p>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>今年还有一件大事就是我换了份工作，换工作的原因也不是公司不好，而是和我的职业发展规划有些许偏差，同时压力也大到爆炸。</p>
<p>毫不夸张的说，最严重那段时间我甚至都不敢看到邮件、微信、短信等一系列与工作相关的通知，一度还有幻听，总感觉有微信 at 我的那个声音。</p>
<p>当然除了这些我也真的非常感谢我之前的领导，非常的信任我，也是我迄今为止遇到的最 nice 的领导之一。</p>
<p>好，马屁拍完后简单聊聊我现在的工作。现在这家公司是一家纯互联网的创业公司，也是少数可以盈利并活过三年的创业公司。</p>
<p>公司氛围真的非常好，也是我工作以来氛围最 nice 的团队，注意这里没有”之一“。</p>
<p>每周三我们有宅男快乐日（其实就是下班后一起打球），成为了每周大家最期待的日子。</p>
<p><img src="https://i.loli.net/2020/01/02/swXvuSV98MYJrFf.jpg"></p>
<p>而我的工作内容也发生了变化，由上家公司偏团队管理转换为我熟悉的纯技术人员，可能有人说这不相当于降级了嘛？但其实我在加入这个团队时就明确表示不想做管理，我享受在我这个年龄阶段做纯研发工作的过程。</p>
<p>也许再过几年我可能会后悔，但 who care 呢，现在舒服就够了。</p>
<blockquote>
<p>顺便插个广告，我们团队来年也要扩充人马，欢迎从外边回重庆及重庆本地的有志青年联系我😋。</p>
</blockquote>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><p>其实就技术上来说今年本身进步并不多，主要是下半年换工作后我的主力语言由 Java 切换为”人生苦短，我用 Python“了。期间大部分是在用 Python 来完成工程实践，也有部分工作是由我来维护 Java 相关的内容；随着我们业务的发展、人员的扩充不可避免的会由弱类型语言转换强类型，这是目前大部分技术团队发展的规律。</p>
<p>所以就 Java 本身来说我也会继续学习，后面也会继续更新相关的技术文章，待我 Python 入化境后也会尝试写写相关内容。</p>
<h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>同样的下半年之后其实我也没怎么投入精力到开源项目中了，有好多 issues 都还没来得及处理。最近在写一个 orm 相关的框架，断断续续写了两个月，本来打算月初分享出来也被耽搁了。</p>
<blockquote>
<p>这其实最近再使用 Python ORM 时觉得还不错的一个 features 移植过来的。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/01/02/o7Yfem1WFSNniyl.jpg"></p>
<p>年初本来想在年底冲一冲争取访问量过百万，同样的还是因为没有更新现在还差一点🤣。</p>
<p>公众号倒是自增长到了 2W 关注，这点我倒是真没想到，毕竟上次打开这个后台也是两个月前的事了🥶。</p>
<p><img src="https://i.loli.net/2020/01/02/cdJIeo7MB5vWLqR.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>现在来看看去年立下的 flag :</p>
<p><img src="https://i.loli.net/2020/01/02/FEengTOklbX5Jz1.jpg"></p>
<p>好吧，只完成了一项；前几天看到有人说：不要在年初定目标，因为当前大脑容易兴奋不易看清自己。</p>
<p>但目标不在年初立那还有啥意义？所以还是按照历史传统立个 flag：</p>
<ul>
<li>婚礼办了，去日本度个蜜月。</li>
<li>Python 玩的更熟一些，同时能把之前的项目经验带到团队中。</li>
<li>减肥、健身；这个计划从前年就开始了。</li>
<li>vlog 得接着拍起来，再买台无人机换个拍摄视角。</li>
<li>最后就是技术输出了，我预计应该是做不到一周一更了，但两周一更还是可以保证。</li>
</ul>
]]></content>
      <categories>
        <category>annual-summary</category>
      </categories>
  </entry>
  <entry>
    <title>可能是最晚的2020年终总结</title>
    <url>/2021/03/02/annual-summary/2020/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/03/02/AoOv3FR5Vs1N6Ij.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先还是祝大家新年快乐，虽然还有300来天。</p>
<p>哈哈，圆规正传。</p>
<p><img src="https://i.loli.net/2021/03/02/JcymvrS78QtDTOz.jpg"></p>
<p>近三年每年我都有写年终总结，每次看上一年的新年计划时心里就会骂一句：TMD 又白写了；当然今年也不例外。</p>
<p><img src="https://i.loli.net/2021/03/02/i5juC7LQ182drIJ.jpg"></p>
<span id="more"></span>

<p>虽说计划对我来说意义不大，但回顾一年的重要事项用于茶余饭后的谈资还是很有用的。</p>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>依照惯例还是首先回归下 2020 这一整年对我来说有哪些重要事件。</p>
<h2 id="疫情"><a href="#疫情" class="headerlink" title="疫情"></a>疫情</h2><p>首先自然是所有人都面临的疫情；我最直接的感受就是让我对二人世界有了新的认识。</p>
<p><img src="https://i.loli.net/2021/03/02/oN45nG6Ti2FtIaf.jpg"></p>
<p>但也是第一次为老婆单独过生日，谁让她出生的日子挑在了正月初五呢，平常这个时候都还在走亲访友，能记得她生日的都是真爱了。</p>
<p>为此我还特地为她准备了一个小惊喜；</p>
<ul>
<li>悄悄的订了一个蛋糕，运气不错，赶在小区彻底封闭前取到了货，然后在她玩游戏的时候突然袭击；具体见视频：</li>
</ul>
<iframe width="560" height="315" src="//player.bilibili.com/player.html?aid=85534926&bvid=BV1Y7411z78A&cid=146191582&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<hr>
<h2 id="蜜月旅行"><a href="#蜜月旅行" class="headerlink" title="蜜月旅行"></a>蜜月旅行</h2><p>之后整个上半年对我来说都没有什么特别的记忆，因为我一直在期待下半年的婚假。</p>
<p>我是在 19 年 12月中的时候领的证，按照规定我得在20年的12月中旬将婚假休了；由于上半年的疫情也不太乐观（头一年打算去日本的计划也不得不落空），加上工作的上的事情也没有怎么排开；所以我便准备在11月份出去旅行。</p>
<p>说来也惭愧，这还是我们耍朋友8、9年来第一次正儿八经的出远门旅行。</p>
<p>因为有足足 15 天的婚假，加上一个周末就是 17 天；所以我准备将整个旅行分为两部分。</p>
<p>第一部分是在云南，主要地点是大理和丽江。</p>
<p>第二部分则是作为内陆人一直想见的大海：三亚。</p>
<p>为此我还特地做了一个行程表：</p>
<p><img src="https://i.loli.net/2021/03/02/sFTYKPaCDq1v3h8.jpg"></p>
<p><img src="https://i.loli.net/2021/03/02/EPoDR8erMT4YgOs.jpg"></p>
<p>云南之行我也做了一个视频回顾：</p>
<iframe width="560" height="315" src="//player.bilibili.com/player.html?aid=374429273&bvid=BV1UZ4y1A7Lr&cid=304080435&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><img src="https://i.loli.net/2021/03/02/wUmBvtgV5KWGEkA.jpg"></p>
<hr>
<p>在三亚的花费是整个旅程最多的部分，但我个人感觉并没有物超所值；</p>
<p>一个是饮食不太习惯，当地的海鲜吃法对我这种吃惯了川菜的确实有点难以接受，即便尝过了麻辣香锅版的海鲜。</p>
<p>最后三天还咬牙斥”巨资“入驻了三亚出名的亚特兰蒂斯酒店，原本想着这么贵的酒店总得图个清静吧；</p>
<p>没想到办理入住的时候活活排了两个小时队，果然是贫穷限制了想象力。</p>
<p>后面我们发现部分游客居然和我们一样，在市内采购了许多吃得拿到酒店里，因为基本房型只包含了早上的自助早餐。</p>
<p><img src="https://i.loli.net/2021/03/02/txkurioHj6qhlBW.jpg"></p>
<p>而这里”普普通通“餐厅大概是人均 2000 一位。</p>
<p>住着 2 3千一晚的酒店，却在里边吃着 5 块的加大号方便面，可能这就是当代打工人和干饭人的基本素养吧。</p>
<ul>
<li>三亚部分的视频内容也在紧张制作中（文件夹建好了）感兴趣的不妨点个关注吧。</li>
</ul>
<h2 id="婚礼"><a href="#婚礼" class="headerlink" title="婚礼"></a>婚礼</h2><p>再一个重要的事情就是婚礼了，本来我们两个是不太打算办婚礼的，但碍不过家人的要求最终就简简单单的走了个流程。</p>
<p>在我们的观念中婚礼也就是走个形式，为了这个形式足够简单我们花了半天时间加上 700 块钱拍了”婚纱照“。</p>
<p><img src="https://i.loli.net/2021/03/02/HykXt5P4YR9lZAN.jpg"></p>
<p>甚至最终婚礼现场的婚纱也是网上花了 300 块买来的，后面还准备再二手卖掉回回血。</p>
<p>婚礼前一周再和司仪沟通流程时，我还打算去掉所有的对话环节；想着几分钟就搞定不耽搁大家吃饭时间。</p>
<p> 本以为我对待婚礼”无所谓“的态度加上我的二皮脸能让这个仪式快些结束，但真等到我上了那个T台，才发现时间是如此的漫长。</p>
<p>耳边亲友们的欢呼仿佛和我没有丝毫关系，脑子里会不由自主的像放电影一样回顾我和老婆在一起的点滴；不得不庆幸我在”单身夜“后半段背了两个小时的演讲稿，不然当时可能我一句话都说不出来。</p>
<p>当流程走到给双方父母敬茶时，司仪让我们低头看着父母两鬓的白发；虽说我深知这是惯用的煽情”套路“，但依然还是有些绷不住。</p>
<p>果然是：男儿有泪不轻弹 只是未到伤心处。</p>
<p>当时为了婚庆简洁不交”智商税“，婚礼整个过程的摄影都是我老弟帮忙拍摄的，所以回忆还得我自己来剪；同样的也是文件夹已建好。</p>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>接下来聊聊工作，我记得我们公司算是到现场复工比较晚的一批；因为在疫情期间的远程工作我们发现效率还挺不错。</p>
<p>后来我仔细一合计，可不就是因为远程工作，随时随地都可以写代码嘛，连出去玩的机会都没有。</p>
<p><img src="https://i.loli.net/2021/03/02/jgdnRLhGTPrQCXZ.jpg"></p>
<p>哈哈，开个玩笑；其实本质原因还是疫情前我们和产品的需求就一直是远程沟通，整个工作中最扯皮的事情以前我们都能”从容解决“，所以被迫远程时还不就张手就来。</p>
<p><img src="https://i.loli.net/2021/03/02/oRbG3gn2xEa7y5z.jpg"></p>
<p>当五月份复工时，还有些一起工作三个多月却素未谋面的新同事，那真的是大型网友见面会。</p>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>老实说，20年我对自己的要求实在是有点低了；关注我的朋友应该知道整个 20 年我都没更新几篇技术文。</p>
<p><img src="https://i.loli.net/2021/03/02/xl4powND6BTQL1m.jpg"></p>
<p>最扯的是我在19年的总结时也说过类似的话，究其原因我自己总结了几点：</p>
<ol>
<li>个人”包袱“有点重，内心深处觉得毕竟是工作几年的老鸟，不能再像刚入行那样写一些浅显的入门文章。然而现实情况却是入门的看不上，有深度的一篇没有。</li>
<li>第二点是我在影视飓风年度总结上学到的新词：”死亡三角状态“。</li>
</ol>
<p><img src="https://i.loli.net/2021/03/02/jwTMHFkefaXUy9E.jpg"></p>
<p>大家是否觉得似曾相识；没错，这不就是 <code>CAP</code> 理论嘛？</p>
<p>只是我在遇到这个问题时却是选择将三者都拉倒了底。。。</p>
<p>发现这个问题后我在年初尝试做了一些转变，截止目前为止我转载了两篇优秀的原创博文，至少在数量和质量上能先提高上来。</p>
<p>同时我也在逼迫自己可以做到周更，为什么觉得自己能做到？是因为我发现自己并不是缺时间，只是单纯的懒而已。</p>
<p><img src="https://i.loli.net/2021/03/02/APqy1JudfO5W6QM.jpg"><br>毕竟两年前的我也能做到，是时候拿出那时的激情了。</p>
<h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>接下来聊聊开源，开源这事我觉得是我这几年做的最对的一个选择，但同样的也是在18年那段时间产出最多。</p>
<p>20年一共磕磕盼盼写了三个项目：</p>
<p><img src="https://i.loli.net/2021/03/02/iAl5UaK9vO78Md2.jpg"></p>
<p><a href="https://github.com/crossoverJie/sqlalchemy-transfer">sqlalchemy-transfer</a> 应该算是比较有技术含量的一个，主要是复习，相当于重学了一些编译原理的知识。</p>
<p>用于解析 <code>MySQL</code> 的 <code>DDL</code> 语句生成 <code>Python</code> <code>ORM</code> 项目所需要的 <code>model</code> 文件。</p>
<hr>
<p>第二个 <a href="https://github.com/crossoverJie/feign-plus">feign-plus</a>，核心功能是可以不依赖于 <code>SpringCloud</code> 那一套包，从而可以直接在 <code>SpringBoot</code> 中实现 <code>feign</code> 的声明式调用。</p>
<p>这个本身思路还不错，但由于公司技术栈现在转向 <code>Golang</code> 之后就没怎么维护了。</p>
<hr>
<p>最后一个 <a href="https://github.com/crossoverJie/btb">btb</a> 其实是用 <code>Go</code> 重写了之前 <code>Java</code> 写的一个博客工具，可以备份、替换自己文章中的图片。</p>
<p><a href="https://asciinema.org/a/ftFt2WZDx3PV4VQFzZZyw0wSl">btb</a></p>
<p>用 <code>Go</code> 重写之后便改为命令行交互了，使用起来更方便一些。</p>
<p>遗憾的是原本是准备将 <a href="https://github.com/crossoverJie/cim">cim</a> 也用 <code>Go</code> 重构一次，但终究是没有实施，不过今年一定会提上议程。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还是照例看看去年的规划完成了多少：</p>
<p><img src="https://i.loli.net/2021/03/02/46atbPGkmdDSVzB.jpg"></p>
<p>不出所料，大部分都没完成。</p>
<p>但没关系，既然没完成那就顺延到今年吧：</p>
<ul>
<li>工作内容有数量+质量的产出。</li>
<li>深入学习和理解 <code>Go</code>、<code>Docker</code>、云原生相关内容。</li>
<li>博客周更。</li>
<li>减肥。</li>
</ul>
<p>整个20年对我来说玩是玩好了，毕竟还出去玩了大半个月；但相对的个人进步确实太少。</p>
<p>18 年时比现在忙的多，同时个人成长也是呈加速度走势；于是今年 21 年我也在公司主动承担更多的职责，往往不逼自己一把就不知道自己的上限在哪儿。</p>
<p>最后放两段篮球的 <code>mixtap</code> ，希望今年大家身体健康。</p>
<iframe width="560" height="315" src="//player.bilibili.com/player.html?aid=671485892&bvid=BV1AU4y1x7J2&cid=290704072&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<iframe width="560" height="315" src="//player.bilibili.com/player.html?aid=203872135&bvid=BV1Ph41117aK&cid=287150167&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
]]></content>
      <categories>
        <category>annual-summary</category>
      </categories>
  </entry>
  <entry>
    <title>2021 年度报告</title>
    <url>/2022/01/27/annual-summary/2021/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2022/03/13/3KxYVB5liTZvHzJ.jpg"></p>
<p>不知不觉年终总结就像每个人的 KPI 一样，年底不总结一下感觉今年就白过了似的。</p>
<p>今年时间真的感觉过的特别快，经常感觉工资刚发不久结果没几天又到了发薪日；再也没有小时候一个暑假都能过一年的感觉。</p>
<span id="more"></span>

<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>生活上来说最大的变化也许就是年龄+1了，今年也是我们结婚两年恋爱十年的时间；十年这样的跨度现在想想还是觉得不可思议。</p>
<p><img src="https://s2.loli.net/2023/01/17/ozGCbWA48hgFeTL.png"></p>
<p>好在目前为止我们双方父母都没有催生，一切都顺其自然吧。</p>
<hr>
<p>虽然每天都是公司、家里两点一线的生活，但没想到的是今年居然喜欢上和我毫无关系的一项运动：足球。</p>
<p>原本是公司每周组织的足球活动 14 缺 1，没事就去踢了一次，结果发现还挺好玩；</p>
<p><img src="https://s2.loli.net/2023/01/17/gIENyimZAD2BVSM.png"><br><img src="https://s2.loli.net/2023/01/17/C7Sk3vtoW9wGzFL.png"><br>虽然每次报名的都是原有的篮球队员，此消彼长自然篮球就没啥人报名了😂。</p>
<p>贴几段足球小视频：</p>
<iframe src="//player.bilibili.com/player.html?aid=676954694&bvid=BV1xU4y1T7xT&cid=450061966&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<iframe src="//player.bilibili.com/player.html?aid=975700568&bvid=BV1t44y147oD&cid=414155189&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<iframe src="//player.bilibili.com/player.html?aid=720492584&bvid=BV1LQ4y1r7rT&cid=405983161&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><img src="https://s2.loli.net/2023/01/17/TkHo1C5KsWLSRdO.png"></p>
<blockquote>
<p>今年最后一场</p>
</blockquote>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>总的来说今年工作上的变化是最大的，其实简单来说就是我们被收购了；之前总是在网上看别人公司的小道消息吃瓜，没想到这次吃到自己头上来了。</p>
<p>幸运的是我个人受到的影响不大，毕竟也不是公司领导层，我们只需要做好自己的事情就行了。</p>
<p>当然落实到我们日常工作最明显的变化可能就是开发流程的变化了，这点在后文会具体说明。</p>
<p><img src="https://s2.loli.net/2023/01/17/AbgWsZxPXw5t9fi.png"><br>今年因为主导了几个系统的重构以及部门内部技术的推动，相对去年来说成绩上还是有所提升的，所以年底也评了优，算是对我工作的肯定吧。</p>
<p>但其实我个人不是特别满意，几个项目推动了一半，最终也没达到预期目标，只能寄托于来年了。</p>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><p>由于公司的调整自然也带来了我们技术栈的变化；简单来说经历了几个阶段：</p>
<p><img src="https://s2.loli.net/2023/01/17/xJNL2B8YVd5R37M.png"></p>
<p>其实每个阶段都和公司业务+组织架构+业务现状有着千丝万缕的关系；个人的喜好很难起决定性作用。</p>
<p>所以绕来绕去，今年我又得开始写 <code>Java</code> 了；最近这三年时间从 <code>Java</code> 转到 <code>Python</code>，体验到了各种便捷的语法糖，又写了将近两年 <code>Go</code> 之后体验到了大道至简的优雅。</p>
<p>三种语言都各有优势，但从内心深处来讲我还是更愿意写 Go；可能是不想再去卷很难用到的八股文、配置繁琐的 <code>maven</code> 等。</p>
<p>由于团队内部有些同事没有接触过 <code>Java</code> ，所以让我以新手角度带大家一起学习；新版本的 JDK 语法糖+ <code>lombok</code> + <code>mapstruct</code> 这类工具，配合上最新的 IDEA 开发起来也是非常舒服的。</p>
<p>用单纯的 <code>SpringBoot</code> 结合 <code>k8s</code> 后，之前的 <a href="https://github.com/crossoverJie/feign-plus">https://github.com/crossoverJie/feign-plus</a> 就有用武之处了。</p>
<h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p><img src="https://s2.loli.net/2023/01/17/pNwLoPSGD34c8fr.png"><br><img src="https://s2.loli.net/2023/01/17/jbenoQNFK6qlCpr.png"></p>
<p>今年的技术原创博客产量也不高，满打满算将近 20 篇；其中大部分都与 Go 有关，近期确实大部分时间都是在写 Go，但也只是用了点皮毛；不出意外的话来年会 Java 和 Go 的内容都会写一点。</p>
<h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>今年的开源项目上我最喜欢的应该就是 <a href="https://github.com/crossoverJie/ptg">https://github.com/crossoverJie/ptg</a></p>
<blockquote>
<p>这是命令行的接口压测工具，同时也是一个 <code>gRPC</code> 的客户端 app。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/01/17/svaM2ml69kGH4jJ.gif"></p>
<p>UI 确实是我的极限了，我自己还有部分小伙伴使用了一段时间还是挺好用的。</p>
<blockquote>
<p>最近正在加 stream 调用相关的功能。</p>
</blockquote>
<hr>
<p>其实在公司内部也有用过 Go 重构过调度中心，就是大家用的挺多的 <code>xxl-job</code>。</p>
<p>由于我们的项目都是 <code>gRPC</code> 协议，同时运维体系之类的原因就用 Go 重写了一版。</p>
<p><img src="https://s2.loli.net/2023/01/17/2cRFaLHPYEdVJh3.png"></p>
<p>最终在每日百万次数的调度下成功率<code>≈99.9%</code>，已经可以满足业务使用了；</p>
<p>但后期如果业务上不再使用 <code>Go</code> 的话难免会有些可惜，所以我也在想和公司沟通下，可以把这个调度中心开源出来，同时以前也说过我们内部也做了一个 Go 的业务框架，现有的调度业务代码接入调度中心也是通过该业务框架实现的。</p>
<p>所以也准备都开源出来，但时间上还不好说，总之希望来年还能有机会多写写  Go，能参与开源是最好的。</p>
<hr>
<p>最后希望来年疫情能彻底结束了，至少能不限制的跨省旅旅游；也希望有机会能把前年办的健身卡利用起来，根据前几年的经验来看 flag 还是要少立。</p>
]]></content>
      <categories>
        <category>annual-summary</category>
      </categories>
  </entry>
  <entry>
    <title>2022 年度总结</title>
    <url>/2023/01/18/annual-summary/2022/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/01/17/C9tczrjDlwfVqvR.png"></p>
<p>一转眼 2022 年又过去了，不多不少距离上次写年终总结过去了 365 天；今年的艰难情况想必大家都亲身经历过了；如果要举行卖惨大会的话今年也许我能排的上号。</p>
<span id="more"></span>

<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>今年对大家影响最大的事应该都是疫情了，在年底的最后几天家里的老人还是没顶住疫情的冲击离开了，原以为成年后我已经看淡了生老病死，直到我现在敲下这几行字时才发现这么难过。</p>
<p>悲伤的事暂且不提，还是聊聊今年生活上的好事吧。</p>
<h2 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h2><p>首先是健身这个我念叨了几年的运动今年终于被我提上了议程。</p>
<blockquote>
<p>本质原因是请了私教，果然是花自己的钱才会心疼。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/01/17/ojP8sQXracSHM3u.png"><br><img src="https://s2.loli.net/2023/01/17/LWSkPHGEMf1R2UO.png"></p>
<p>体重也由巅峰的 75kg 降到了66kg 左右。<br><img src="https://s2.loli.net/2023/01/17/R38tM2FOocjHGxI.png"></p>
<iframe src="//player.bilibili.com/player.html?aid=685069016&bvid=BV1aU4y1X7Ya&cid=749168314&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>一段视频便能看出差距。</p>
<h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>今年不记得被哪个视频安利了微软的 XGP 服务，冲动下单了 xbox，顺道集齐了御三家的全家桶。<br><img src="https://s2.loli.net/2023/01/17/DzUT7yHYm59iZ2R.jpg"></p>
<p>不得不说 XGP 服务是真的香，游戏也很多，我玩的最多的就是光环、地平线5、奥日这几款游戏；原以为 xbox 后续会成为我的主力机，直到几个月后我在 tb 奸商那儿购买的 XGP 服务被微软退款后我就没怎么碰了。</p>
<p>后面老头环上线，也是我唯一一款花钱购买的 xbox 游戏，在被老头环揉拧了几周后手残党也被劝退，一直到现在估计三个月没开过机了。</p>
<p>不过最近倒还喜欢上玩 Steam 上的一些独立小游戏，特别是肉鸽类型的，比如这个“吸血鬼幸存者”玩着真的非常上头。</p>
<p><img src="https://s2.loli.net/2023/01/17/6Y7lmhtQRMy2TiU.png"></p>
<p>当然今年最期待依然是那个带我入主机坑的“塞尔达传说”，恨不得现在马上快进到5月12号发售日。</p>
<h2 id="世界杯"><a href="#世界杯" class="headerlink" title="世界杯"></a>世界杯</h2><p>今年还有件大事那就是世界杯的召开，真没想到我还会对足球这么感兴趣；因为当时是封控在家远程工作，所以我几乎把凌晨三点场的都看完了。</p>
<p>那段时间因为离职心情还比较 EMO，感谢世界杯带给了我一个月的快乐时间。</p>
<p>当然不出意外的在世界杯期间发生了意外。</p>
<p><img src="https://s2.loli.net/2023/01/17/jUMOHidkxapyRbW.jpg"></p>
<p>大半夜睡得好好的，眼睛被我老婆的手指甲刨到了，连夜赶往医院，最后就成了“带土”的 cos 低配版。</p>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>经常都有大佬说三年是在一家公司的敏感时间，如果感觉不到提升那就需要适当的跳出舒适圈，其实我压根没这个打算，但生活总在你没准备好的时候推你一把。</p>
<p><img src="https://s2.loli.net/2023/01/17/3MGYFZ1fCvLsXBz.png"><br><img src="https://s2.loli.net/2023/01/17/qcZoD2Mr7YX1Ble.jpg"></p>
<p>由于不可抗力因素，我还是离开了这家我有生以来呆的最开心的一家公司；虽然有许多不舍，但江湖总会相见。</p>
<p><img src="https://s2.loli.net/2023/01/17/ztTP1F9ChJ23AR8.png"><br><strong>这不我微信里最活跃的依然还是那个群。</strong></p>
<hr>
<p>后面我花了一个月的时间把重庆大大小小的公司几乎都看了一遍，甚至还差点去成都工作了；最后阴差阳错的来到了现在的公司做我之前非常向往的基础架构+中间件研发，目前也比较满意。</p>
<blockquote>
<p>找工作那段时间也碰到许多有意思的和狗血的事情，年后单独分享。</p>
</blockquote>
<h1 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h1><h2 id="GScript"><a href="#GScript" class="headerlink" title="GScript"></a><a href="https://github.com/crossoverJie/gscript">GScript</a></h2><p><img src="https://s2.loli.net/2023/01/17/9O4pzlC6T2ISKkA.png"></p>
<p>今年个人最满意的就是恶补了编译原理的知识，顺带还做了一个<a href="https://gscript.crossoverjie.top/">脚本语言</a>；现在已经可以拿来编写网站了；也算是一个小目标达成吧。</p>
<p>回想起开发 gscript 的那段时间，真的是没日没夜的干，每完成一个功能就开心的飞起。</p>
<h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2><p><img src="https://s2.loli.net/2023/01/17/kHa4Demu15OiytE.png"><br>除此之外在来到现在这家公司后接触了大量 k8s 相关的知识点，也算是把之前学到的理论实践上了；这不昨晚上才在生产环境升级了 Pulsar，这个技能树终于点亮了一些叶子节点。</p>
<h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p><img src="https://s2.loli.net/2023/01/17/q3CLIhWoM8yEtGY.png"><br><img src="https://s2.loli.net/2023/01/17/hSxHZDsEArRFow1.png"></p>
<p>今年的技术博客产出居然 23 篇，其中大部分都是和编译原理相关的，也是我一步步学习编译原理到实现脚本语言的过程。</p>
<hr>
<p><img src="https://s2.loli.net/2023/01/17/mEPTMByJIAKaiwX.png"><br>同时今年也养成了每日看一篇英文博客的习惯，坚持了几个月效果还是很明显的；比如以前我非常排斥看一些英文资料，要么靠一键翻译，要么就直接只看中文内容。</p>
<p>现在几乎没有这种排斥的感觉了，大部分英文内容也会耐心的阅读完，这点在我订阅了 Pulsar 的开发组邮件后越发明显，明显的能够知道他们在讲些什么，这点与我多年前订阅 Dubbo 社区邮件的感觉完全不同。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>以上就是整年的流水账式的回顾，又到了经典的保留立 flag 环节。</p>
<ul>
<li>首先是健身保持，都说健身是按年算的，希望到今年四月份为期一年的时候能看到健身的痕迹。</li>
<li>今年好歹的出去玩一玩，比如港澳地区或是日本，念叨几年了。</li>
<li>工作技术上能够再提交几个 Pulsar 的 PR，最好是能融入社区；混个脸熟。</li>
<li>云原生和编译原理相关的继续学起来，下半年把 GScript 实现为编写型语言。</li>
</ul>
]]></content>
      <categories>
        <category>annual-summary</category>
      </categories>
  </entry>
  <entry>
    <title>GoodBye 2016,Welcome 2017 | 码农砌墙记</title>
    <url>/2016/12/31/annual-summary/GoodBye%202016,Welcome%202017%20%7C%20%E7%A0%81%E5%86%9C%E7%A0%8C%E5%A2%99%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://i.loli.net/2019/05/08/5cd1c3667b05e.jpg"></p>
<p>早在这个月初的时候我就很想写一篇年终总结了，因为这一年相对于去年确实是经历的太多了。<br>结果一直等到31号，在家里和媳妇吃完晚饭就马上打开电脑开码。</p>
<h1 id="五月二十三-第一次跳槽"><a href="#五月二十三-第一次跳槽" class="headerlink" title="五月二十三-第一次跳槽"></a>五月二十三-第一次跳槽</h1><blockquote>
<p><strong>根据整年的时间线开始第一件大事自然就是换公司了。</strong></p>
</blockquote>
<p>先来点前景提要:我是14年11月份参加工作的。当时其实还没有毕业就在一家给大型企业做定制软件开发的公司实习。刚开始工作的时候什么事情都觉得非常新奇，一个在学校学的东西能运用到实际开发中并能给用户带来便利让我觉得做码农真是一件非常正确的选择啊(ps当时真是太年轻)。</p>
<p>后来真是造化弄人，当时负责我参与的这个项目的负责人跳槽了，我自然就成了整个公司最熟悉此项目的人了。现在不得不佩服公司老板真是心大啊，居然让一个实习生来负责这个项目。就这样我成了整个项目的负责人，从之后的开发到测试到上线到后面的维护几乎都是我一个人在负责。<br>来一张当时上线的截图：<br><img src="https://ooo.0o0.ooo/2017/05/07/590ea72eac0e7.jpg" alt="QQ20161231-222737@2x.jpg"></p>
<p>由于这次项目的顺利验收，公司也对我越来越信任。之后也就理所当然的又负责了几个项目。</p>
<span id="more"></span>

<blockquote>
<p>虽然离开了但真的非常感谢公司当时对一个什么都不懂的新人给予信任。</p>
</blockquote>
<p>之后随着技术的提升我接触了github、v站这样的技术论坛，逐渐的发现天外有天，我这点雕虫小技真的完全不算什么，真正机遇与挑战并存的地方是互联网。</p>
<p>但是此时我已经在这家公司做了一年多了，突然离开这个舒适圈来到一个陌生的环境是需要很大勇气的，或者说需要一个刺激点。</p>
<p>正好<a href="http://tengj.top/">@嘟爷</a>成了这个导火索。那个时候我正在搭我的个人博客正好看到了他的文章，觉得写得非常好。而且正好他也正准备转向互联网，于是我给他写了一封很长的邮件说了我心中的一些疑惑与顾虑让他给点建议。</p>
<p>在他的建议之下我才开始投递简历准备换一家互联网公司，感谢嘟爷给了我一个这么正确的建议。</p>
<p>之后我顺利的进入了一个创业公司，开始了<code>狭义</code>的互联网开发道路，为什么是狭义请接着往后看。</p>
<h1 id="搭建个人博客"><a href="#搭建个人博客" class="headerlink" title="搭建个人博客"></a>搭建个人博客</h1><blockquote>
<p>搭建博客这事也是必须的拿出来说一说的。</p>
</blockquote>
<p>上面说到我看了嘟爷的博客才开始搭建自己的博客，到现在为止由于我的拖延症(<code>加上是真的懒</code>)一共写了20篇。不能说写的有多好，但确实是我在工作和学习中的一些总结。</p>
<p>让我意外的是我博客的访问量，下图是我<code>cnzz</code>的统计截图：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c36b578a3.jpg"></p>
<h1 id="六月二十一-开源项目"><a href="#六月二十一-开源项目" class="headerlink" title="六月二十一-开源项目"></a>六月二十一-开源项目</h1><p>关于开源项目，之前我在<code>github</code>上面看很多优秀的开源项目，也很佩服那些作者，于是就想着自己能不能也搞一个，但是一来就造个轮子对我来说确实有点不现实。</p>
<p>于是我换了一个思路，由于现在我勉强也不算是新入门的菜鸟了，但我是从菜鸟过来的，深知刚开始的时候找资料的痛苦。不是资料太老就是没有体系，讲一点是一点的那种。</p>
<p>于是就有了现在这个项目:<br><code>会不定期更新一些在实际开发中使用的技巧(ps:目前不是很忙基本上一周一更)。 没有复杂的业务流程，更不是XXXX系统，只有一些技术的分享。</code></p>
<p>从六月二十一号到现在还是有100多颗星了：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c36f7774a.jpg"></p>
<h1 id="九月二十三-第二次跳槽"><a href="#九月二十三-第二次跳槽" class="headerlink" title="九月二十三-第二次跳槽"></a>九月二十三-第二次跳槽</h1><p>看到这里是不是觉得我有病啊，怎么又是跳槽。。。</p>
<p>其实我也不想，我在上面说到开始了我的<code>狭义</code>互联网开发，为什么是狭义呢？</p>
<p>因为做了一段时间才发现这个项目除了是部署在云服务器上和有一个微信端之外和我之前所做的项目貌似没有本质上的区别，还是一个管理系统。</p>
<p>这里我不评价公司的业务，但是公司的技术总监在修改问题的时候是直接在云服务器上登陆数据库删除数据，会不会觉得很奇葩。最奇葩的是删除的时候忘了写<code>where</code>条件导致把整张表的数据都删了，这个时候如果是你你会不会怀疑那啥。。</p>
<p>除此之外技术总监本人还是挺好的，不过我更觉得他适合做销售总监。</p>
<p>加上后来公司的业务没有发展起来，所做的系统又老是出问题(联想上文)，加上还在流传我们技术部要裁人。那我还不如自己走(现在V站逛多了突然觉得好亏)。</p>
<p>于是我开始了我的第二次跳槽，前后时间才间隔4个月，不得不感慨命运弄人啊。</p>
<p>之后我来到现在这家员工5000余人的真正的互联网公司，开始了真正意义的互联网开发。这里必须得感谢我的面试官也是我现在这个项目的leader，给了我这个互联网菜鸟机会。</p>
<p>不过命运总是如此的相识，明年也就是下周他就换部门了，意味着现在这个项目我又成<code>负责人</code>了。希望一切顺利吧。</p>
<h1 id="技术相关"><a href="#技术相关" class="headerlink" title="技术相关"></a>技术相关</h1><p>前面说到我是九月份的时候才进入这家正真意义的互联网公司的，所以体术提升最明显也是在这段时间。</p>
<p>这段时间所学的起码是我在前面两家公司一年都学不到的，这里我大致列了一下：</p>
<ul>
<li>熟悉了一个互联网产品的生命周期(关于开发、测试、预发布、灰度以及上线)</li>
<li>熟悉了一些关于<code>并发</code>、<code>主从</code>、<code>缓存</code>、<code>调度</code>、<code>容器</code>这些主流的技术。</li>
<li>最重要的一点，学会了不加班不舒服斯基。</li>
</ul>
<h1 id="身体相关"><a href="#身体相关" class="headerlink" title="身体相关"></a>身体相关</h1><p>不知是错觉还是什么，感觉今年看到<code>IT</code>行业猝死或者是出事的新闻越来越多，加上我这个今年才22岁的青年有时候也会腰疼脖子酸，导致我对于身体也是越来越担忧。</p>
<p>其实我从初中的时候就开始打篮球，在工作之前也是对篮球完全是痴迷的状态，每天不打球就浑身难受。刚工作的那段时间还能坚持每周末去打球，但是今年能做到一个月打一次都非常难得了。。</p>
<p>再此，我立个<code>flag</code>，明天下午出去打球，明年坚持至少每两周打一次球。</p>
<h1 id="2017小目标"><a href="#2017小目标" class="headerlink" title="2017小目标"></a>2017小目标</h1><p>到这里也基本上总结的差不多了，还有半个小时就是17年了。</p>
<p>还是定一个17年的小目标吧：</p>
<blockquote>
<ul>
<li>博客坚持写，至少保持两周一更。</li>
<li>开源项目坚持维护，争取造一个轮子出来。</li>
<li>坚持锻炼，我还得养家糊口。</li>
<li>最后希望家人朋友都平平安安。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>annual-summary</category>
      </categories>
  </entry>
  <entry>
    <title>Go 去找个对象吧</title>
    <url>/2021/02/24/basic/Go-OOP/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/02/23/hFc3XiSMYAZoRr7.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我的读者中应该大部分都是 <code>Java</code> 从业者，不知道写 <code>Java</code> 这些年是否真的有找到对象？</p>
<p>没找到也没关系，总不能在一棵树上吊死，我们也可以来 <code>Go</code> 这边看看，说不定会有新发现。</p>
<p>开个玩笑，本文会以一个 <code>Javaer</code> 的角度来聊聊 <code>Go</code> 语言中的面向对象。</p>
<span id="more"></span>

<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>面向对象这一词来源于<code>Object Oriented Programming</code>，也就是大家常说的 <code>OOP</code>。</p>
<p>对于 <code>Go</code> 是否为面向对象的编程语言，这点也是讨论已久；不过我们可以先看看官方的说法:</p>
<p><img src="https://i.loli.net/2021/02/23/ZMnvzj1tAVXlBsu.jpg"></p>
<p>其他的我们暂且不看，<code>Yes and No.</code> 这个回答就比较微妙了，为了这篇文章还能写下去我们先认为 <code>Go</code> 是面向对象的。</p>
<hr>
<p>面向对象有着三个重要特征：</p>
<ol>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ol>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><code>Go</code> 并没有 <code>Class</code> 的概念，却可以使用 <code>struct</code> 来达到类似的效果，比如我们可以对汽车声明如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Price <span class="type">float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>Java</code> 不同的是，<code>struct</code> 中只存储数据，不能定义行为，也就是方法。</p>
<p>当然也能为 <code>Car</code> 定义方法，只是写法略有不同：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(car *Car)</span></span> Info()  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v price: [%v]&quot;</span>, car.Name, car.Price)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	car := Car&#123;</span><br><span class="line">		Name: <span class="string">&quot;BMW&quot;</span>,</span><br><span class="line">		Price: <span class="number">100.0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	car.Info()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法名称前加上 <code>(car *Car)</code> 便能将该方法指定给 <code>Car</code> ，其中的 <code>car</code> 参数可以理解为 <code>Java</code> 中的 <code>this</code> 以及 <code>Python</code> 中的 <code>self</code>，就语义来说我觉得 <code>go</code> 更加简单一些。</p>
<p>毕竟我见过不少刚学习 <code>Java</code> 的萌新非常不理解 <code>this</code> 的含义与用法。</p>
<h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>既然谈到结构体了那就不得不聊聊 <code>Go</code> 支持的匿名结构体（虽然和面向对象没有太大关系）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upload</span><span class="params">(path <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	body, err := ioutil.ReadAll(res.Body)</span><br><span class="line">	smsRes := <span class="keyword">struct</span> &#123;</span><br><span class="line">		Success <span class="type">bool</span>   <span class="string">`json:&quot;success&quot;`</span></span><br><span class="line">		Code    <span class="type">string</span> <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">		Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">		Data    <span class="keyword">struct</span> &#123;</span><br><span class="line">			URL <span class="type">string</span> <span class="string">`json:&quot;url&quot;`</span></span><br><span class="line">		&#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">		RequestID <span class="type">string</span> <span class="string">`json:&quot;RequestId&quot;`</span></span><br><span class="line">	&#125;&#123;&#125;</span><br><span class="line">	err = json.Unmarshal(body, &amp;smsRes)</span><br><span class="line">	fmt.Printf(smsRes.Message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Go</code> 允许我们在方法内部创建一个匿名的结构体，后续还能直接使用该结构体来获取数据。</p>
<p>这点在我们调用外部接口解析响应数据时非常有用，创建一个临时的结构体也不用额为维护；同时还能用面向对象的方式获取数据。</p>
<p>相比于将数据存放在 <code>map</code> 中用字段名获取要优雅许多。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><code>Go</code> 语言中并没有 <code>Java</code>、<code>C++</code> 这样的继承概念，类之间的关系更加扁平简洁。</p>
<p>各位 <code>Javaer</code> 应该都看过这类图：</p>
<p><img src="https://i.loli.net/2021/02/23/D28awlxb6HZIqS3.jpg"></p>
<p>相信大部分新手看到这图时就已经懵逼，更别说研究各个类之间的关系了。</p>
<p>不过这样好处也明显：如果我们抽象合理，整个系统结构会很好维护和扩展；但前提是我们能抽象合理。</p>
<p>在 <code>Go</code> 语言中更推荐使用组合的方式来复用数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ElectricCar <span class="keyword">struct</span> &#123;</span><br><span class="line">	Car</span><br><span class="line">	Battery <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	xp := ElectricCar&#123;</span><br><span class="line">		Car&#123;Name: <span class="string">&quot;xp&quot;</span>, Price: <span class="number">200</span>&#125;,</span><br><span class="line">		<span class="number">70</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(xp.Name)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们便可以将公共部分的数据组合到新的 <code>struct</code> 中，并能够直接使用。</p>
<h2 id="接口-多态"><a href="#接口-多态" class="headerlink" title="接口(多态)"></a>接口(多态)</h2><p>面向接口编程的好处这里就不在赘述了，我们来看看 Go 是如何实现的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ElectricCar <span class="keyword">struct</span> &#123;</span><br><span class="line">	Car</span><br><span class="line">	Battery <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> PetrolCar <span class="keyword">struct</span> &#123;</span><br><span class="line">	Car</span><br><span class="line">	Gasoline <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个接口</span></span><br><span class="line"><span class="keyword">type</span> RunService <span class="keyword">interface</span> &#123;</span><br><span class="line">	Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(car *PetrolCar)</span></span> Run() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s PetrolCar run \n&quot;</span>, car.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(car *ElectricCar)</span></span>Run() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s ElectricCar run \n&quot;</span>, car.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Do</span><span class="params">(run RunService)</span></span> &#123;</span><br><span class="line">	run.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	xp := ElectricCar&#123;</span><br><span class="line">		Car&#123;Name: <span class="string">&quot;xp&quot;</span>, Price: <span class="number">200</span>&#125;,</span><br><span class="line">		<span class="number">70</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	petrolCar := PetrolCar&#123;</span><br><span class="line">		Car&#123;Name: <span class="string">&quot;BMW&quot;</span>, Price: <span class="number">300</span>&#125;,</span><br><span class="line">		<span class="number">50</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	Do(&amp;xp)</span><br><span class="line">	Do(&amp;petrolCar)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先定义了一个接口 <code>RunService</code>；<code>ElectricCar</code> 与 <code>PetrolCar</code> 都实现了该接口。</p>
<p>可以看到 <code>Go</code> 实现一个接口的方式并不是 <code>implement</code>，而是用结构体声明一个相同签名的方法。</p>
<p>这种实现模式被称为”鸭子类型“，<code>Python</code> 中的接口也是类似的<code>鸭子类型</code>。</p>
<p><img src="https://i.loli.net/2021/02/23/yScLUx7lVJWCojM.jpg"></p>
<p>详细介绍可以参考这篇：<a href="https://crossoverjie.top/2021/01/14/basic/python-oop/">Python 中的面向接口编程</a></p>
<p>接口当然也是可以扩展的，类似于 <code>struct</code> 中的嵌套：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DiService <span class="keyword">interface</span> &#123;</span><br><span class="line">	Di()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个接口</span></span><br><span class="line"><span class="keyword">type</span> RunService <span class="keyword">interface</span> &#123;</span><br><span class="line">	DiService</span><br><span class="line">	Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/02/23/tFmpBuxHcfSvZW2.jpg"></p>
<p>得益于 <code>Go</code> 的强类型，刚才的 <code>struct</code> 也得实现 <code>DiService</code> 这个接口才能编译通过。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里应该是能理解官方所说的 <code>Yes and No.</code> 的含义了；<code>Go</code> 对面向对象的语法不像 <code>Java</code> 那么严苛，甚至整个语言中都找不到 <code>object(对象)</code> 这个关键词；但是利用 <code>Go</code> 里的其他特性也是能实现 <code>OOP</code> 的。</p>
<p>是否为面向对象我觉得并不重要，主要目的是我们能写出易扩展好维护的代码。</p>
<p>例如官方标准库中就有许多利用接口编程的例子：</p>
<p><img src="https://i.loli.net/2021/02/23/yUEi7zVkCxjW863.jpg"></p>
<p>由于公司技术栈现在主要由 <code>Go</code> 为主，后续也会继续更新 <code>Go</code> 相关的实战经验；如果你也对学习 <code>Go</code> 感兴趣那不妨点个关注吧。</p>
]]></content>
      <categories>
        <category>基础原理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Go</tag>
        <tag>OOP</tag>
        <tag>鸭子类型</tag>
      </tags>
  </entry>
  <entry>
    <title>一文搞懂参数传递原理</title>
    <url>/2021/01/11/basic/parameter-trans/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/01/12/1s37bXrxSl8Cp2f.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近一年多的时间陆续接触了一些对我来说陌生的语言，主要就是 <code>Python</code> 和 <code>Go</code>，期间为了快速实现需求只是依葫芦画瓢的撸代码；并没有深究一些细节与原理。</p>
<p>就拿参数传递一事来说各个语言的实现细节各不相同，但又有类似之处；在许多新手入门时容易搞不清楚，导致犯一些低级错误。</p>
<span id="more"></span>

<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="基本类型传递"><a href="#基本类型传递" class="headerlink" title="基本类型传递"></a>基本类型传递</h2><p>先拿我最熟悉的 <code>Java</code> 来说，我相信应该没人会写这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBasic</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">      modifyBasic(a);</span><br><span class="line">      System.out.println(String.format(<span class="string">&quot;最终结果 main a==%s&quot;</span>, a));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">modifyBasic</span><span class="params">(<span class="type">int</span> aa)</span> &#123;</span><br><span class="line">      System.out.println(String.format(<span class="string">&quot;修改之前 aa==%s&quot;</span>, aa));</span><br><span class="line">      aa = <span class="number">20</span>;</span><br><span class="line">      System.out.println(String.format(<span class="string">&quot;修改之后 aa==%s&quot;</span>, aa));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修改之前 aa==<span class="number">10</span></span><br><span class="line">修改之后 aa==<span class="number">20</span></span><br><span class="line">最终结果 main a==<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>不过从这段代码的目的来看应该是想要修改 <code>a</code> 的值，从直觉上来说如果修改成功也是能理解的。</p>
<p>至于结果与预期不符合的根本原因是理解错了参数的值传递与引用传递。</p>
<hr>
<p>在这之前还是先明确下值传递与引用传递的区别：</p>
<p><img src="https://i.loli.net/2021/01/12/ztqLVPTjmacZf1X.jpg"></p>
<p>这里咱们先抛出结论，<code>Java</code> 采用的是值传递；这样也能解释为什么上文的例子没有成功修改原始数据。</p>
<p>参考下图更好理解：</p>
<p><img src="https://i.loli.net/2021/01/12/XJpdDAKOBhwtSxo.jpg"></p>
<p>当发生函数调用的时候 <code>a</code> 将自己传入到 <code>modifyBasic</code> 方法中，同时将自己的值复制了一份并赋值给了一个新变量 <code>aa</code> 从图中可以看出这是 <code>a</code> 和 <code>aa</code> 两个变量没有一毛钱关系，所以对 <code>aa</code> 的修改并不会影响到 <code>a</code>。</p>
<p>有点类似于我把苹果给了老婆，她把苹果削好了；但我手里这颗并没有变化，因为她只是从餐盘里拿了一颗一模一样的苹果削好了。</p>
<p>如果我想要她那颗，只能让她把削好的苹果给我；也就类似于使用方法的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = modifyBasic(a);</span><br></pre></td></tr></table></figure>

<h2 id="引用类型传递"><a href="#引用类型传递" class="headerlink" title="引用类型传递"></a>引用类型传递</h2><p>下面来看看引用类型的传递：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String name)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                  <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                  <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;benz&quot;</span>);</span><br><span class="line">      modifyCar1(car1);</span><br><span class="line">      System.out.println(String.format(<span class="string">&quot;最终结果 main car1==%s&quot;</span>, car1));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">modifyCar1</span><span class="params">(Car car)</span>&#123;</span><br><span class="line">      System.out.println(String.format(<span class="string">&quot;修改之前 car==%s&quot;</span>, car));</span><br><span class="line">      car.name = <span class="string">&quot;bwm&quot;</span>;</span><br><span class="line">      System.out.println(String.format(<span class="string">&quot;修改之后 car==%s&quot;</span>, car));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子里先创建了一个 <code>benz</code> 的 <code>car1</code>，通过一个方法修改为 <code>bmw</code> 那最开始的  <code>car1</code> 会受到影响嘛？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修改之前 car==Car&#123;name=<span class="string">&#x27;benz&#x27;</span>&#125;</span><br><span class="line">修改之后 car==Car&#123;name=<span class="string">&#x27;bwm&#x27;</span>&#125;</span><br><span class="line">最终结果 main car1==Car&#123;name=<span class="string">&#x27;bwm&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>结果可能会与部分人预期相反，这样的修改却是可以影响到原有数据的？这岂不是和<code>值传递</code>不符，看样子这是<code>引用传递</code>吧？</p>
<p>别急，通过下图分析后大家就能明白：</p>
<p><img src="https://i.loli.net/2021/01/12/StL2o1wKqvTazcI.jpg"></p>
<p>在 <code>test01</code> 方法中我们创建了一个 <code>car1</code> 的对象，该对象存放于堆内存中，假设内存地址为 <code>0x1102</code> ，于是 <code>car1</code> 这个变量便应用了这块内存地址。</p>
<p>当我们调用 <code>modifyCar1</code> 这个方法的时候会在该方法栈中创建一个变量 <code>car</code> ,接下来重点到了：</p>
<p>这个 <code>car</code> 变量是由原本的入参 <code>car1</code> 复制而来，所以它所对应的堆内存依然是 <code>0x1102</code>；</p>
<p>所以当我们通过 <code>car</code> 这个变量修改了数据后，本质上修改的是同一块堆内存中的数据。从而原本引用了这块内存地址的 <code>car1</code> 也能查看到对应的变化。</p>
<p>这里理解起来可能会比较绕，但我们记住一点就行：</p>
<p>传递引用类型的数据时，传递的并不是引用本身，依然是值；只是这个<code>值</code> 是<strong>内存地址</strong>罢了。</p>
<p>因为把相同的内存地址传过去了，所以对数据的操作依然会影响到外部。</p>
<p>所以同理，类似于这样的代码也会影响到外部原始数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       list.add(<span class="number">1</span>);</span><br><span class="line">       addList(list);</span><br><span class="line">       System.out.println(list);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addList</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">       list.add(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<hr>
<p>那如果是这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;benz&quot;</span>);</span><br><span class="line">       modifyCar(car1);</span><br><span class="line">       System.out.println(String.format(<span class="string">&quot;最终结果 main car1==%s&quot;</span>, car1));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">modifyCar</span><span class="params">(Car car2)</span> &#123;</span><br><span class="line">       System.out.println(String.format(<span class="string">&quot;修改之前 car2==%s&quot;</span>, car2));</span><br><span class="line">       car2 = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;bmw&quot;</span>);</span><br><span class="line">       System.out.println(String.format(<span class="string">&quot;修改之后 car2==%s&quot;</span>, car2));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>假设 <code>Java</code> 是引用传递那最终的结果应该是打印 <code>bmw</code> 才对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修改之前 car2==Car&#123;name=<span class="string">&#x27;benz&#x27;</span>&#125;</span><br><span class="line">修改之后 car2==Car&#123;name=<span class="string">&#x27;bmw&#x27;</span>&#125;</span><br><span class="line">最终结果 main car1==Car&#123;name=<span class="string">&#x27;benz&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>从结果又能佐证这里依然是值传递。</p>
<p><img src="https://i.loli.net/2021/01/12/QALiPJdkf4ZYuwX.jpg"></p>
<p>如果是引用传递，原本的 <code>0x1102</code> 应该是被直接替换为新创建的 <code>0x1103</code> 才对；而实际情况如上图所示，<code>car2</code> 直接重新引用了一个对象，两个对象之间互不干扰。</p>
<h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h1><p>相对于 <code>Java</code> 来说  <code>Go</code> 的用法又有所不同，不过我们也可以先得出结论：</p>
<p><code>Go语言的参数也是值传递。</code></p>
<p>在 <code>Go</code> 语言中数据类型主要有以下两种：</p>
<p><img src="https://i.loli.net/2021/01/12/mZbnQ9jAEyJdz6H.jpg"></p>
<p>值类型与引用类型；</p>
<h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>先以值类型举例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a :=<span class="number">10</span></span><br><span class="line">	modifyValue(a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;最终 a=%v&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyValue</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	a = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">输出：最终 a=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/01/12/fdnDNxHQZw2hGlb.jpg"></p>
<p>函数调用过程与之前的 <code>Java</code> 类似，本质上传递到函数中的值也是  <code>a</code>  的拷贝，所以对其的修改不会影响到原始数据。</p>
<p>当我们把代码稍加修改：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a :=<span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;传递之前a的内存地址%p \n&quot;</span>, &amp;a)</span><br><span class="line">	modifyValue(&amp;a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;最终 a=%v&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyValue</span><span class="params">(a *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;传递之后a的内存地址%p \n&quot;</span>, &amp;a)</span><br><span class="line">	*a = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">传递之前a的内存地址<span class="number">0xc0000b4040</span> </span><br><span class="line">传递之后a的内存地址<span class="number">0xc0000ae020</span></span><br><span class="line">最终 a=<span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>从结果来看最终 <code>a</code> 的值是被方法修改了，这点便是 <code>Go</code> 与 <code>Java</code> 很大的不同点：</p>
<p>在 <code>Go</code> 中存在着指针的概念，我们可以将变量通过指针的方式传递到不同的方法中，在方法里便可通过这个指针访问甚至修改原始数据。</p>
<p>那这么一看不就是引用传递嘛？</p>
<p>其实不然，我们仔细看看刚才的输出会发现参数传递前后的内存地址并不相同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">传递之前a的内存地址<span class="number">0xc0000b4040</span> </span><br><span class="line">传递之后a的内存地址<span class="number">0xc0000ae020</span></span><br></pre></td></tr></table></figure>

<p>这也恰好论证了值传递，因为这里实际传递的是指针的拷贝。</p>
<p>也就是说 <code>modifyValue</code> 方法中的参数与入参的<code>&amp;a</code>都是同一块内存的指针，但指针本身也是需要内存来存放的，所以在方法调用过程中新建了一个指针 <code>a</code> ，从而导致他们的内存地址不同。</p>
<p>虽然内存地址不同，但指向的数据都是同一块，所以方法内修改后原始数据也受到了影响。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>对于 <code>map slice channel</code> 这类引用类型又略有不同：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> personList = []<span class="type">string</span>&#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>&#125;</span><br><span class="line">	modifySlice(personList)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;slice=%v \n&quot;</span>, personList)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(personList []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	personList[<span class="number">1</span>] = <span class="string">&quot;王五&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slice=[张三 王五]</span><br></pre></td></tr></table></figure>

<p>最终我们会发现原始数据也被修改了，但我们并没有传递指针；同样的特性也适用于 <code>map</code> 。</p>
<p>但其实我们查看 <code>slice</code> 的源码会发现存放数据的 <code>array</code> 就是指针类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们可以直接对数据进行修改，相当于间接的带了指针。</p>
<hr>
<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>那我们在什么时候使用指针呢？有以下几点建议：</p>
<ul>
<li>如果参数是基本的值类型，比如 <code>int,float</code> 建议直接传值。</li>
<li>如果需要修改基本的值类型，那只能是指针；但考虑到代码可读性还是建议将修改后的值返回用于重新赋值。</li>
<li>数据量较大时建议使用指针，减少不必要的值拷贝。（具体多大可以自行判断）</li>
</ul>
<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>在 <code>Python</code> 中变量是否可变是影响参数传递的重要因素：</p>
<p><img src="https://i.loli.net/2021/01/12/wFc4tMbQgA26XWx.jpg"></p>
<p>如上图所示，<code>bool int float</code> 这些不可变类型在参数传递过程中是不能修改原始数据的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">		x = <span class="number">1</span></span><br><span class="line">    modify(x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;最终 x=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x))	</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">val</span>):</span><br><span class="line">    val = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">最终 x=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>原理与 <code>Java Go</code>中类似，是基于值传递的，这里就不再复述。</p>
<p>这里重点看看可变数据类型在参数传递中的过程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">		x = [<span class="number">1</span>]</span><br><span class="line">    modify(x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;最终 x=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x))	</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">val</span>):</span><br><span class="line">    val.append(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">最终 x=[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>最终数据受到了影响，那么就表明这是引用传递嘛？再看个例子试试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">		x = [<span class="number">1</span>]</span><br><span class="line">    modify(x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;最终 x=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x))	</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">val</span>):</span><br><span class="line">    val = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">最终 x=[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>显而易见这并不是引用传递，如果是引用传递最终 <code>x</code> 应当等于 <code>[1, 2 ,3]</code> 。</p>
<p>从结果来看这个传递过程非常类似 <code>Go</code> 中的指针传递，<code>val</code> 拿到的也是 <code>x</code> 这个参数内存地址的拷贝；他们都指向了同一块内存地址。</p>
<p>所以对这块数据的修改本质上改的是同一份数据，但一旦重新赋值就会创建一块新的内存从而不会影响到原始数据。</p>
<p><img src="https://i.loli.net/2021/01/12/ira7WStCIhXwNET.png" alt="image.png"></p>
<p>与 <code>Java</code> 中的上图类似。</p>
<p>所以总结下：</p>
<ul>
<li>对于不可变数据：在参数传递时传递的是值，对参数的修改不会影响到原有数据。</li>
<li>对于可变数据：传递的是内存地址的拷贝，对参数的操作会影响到原始数据。</li>
</ul>
<hr>
<p>这么说来这三种都是值传递了，那有没有引用传递的语言呢？</p>
<p>当然，<code>C++</code>是支持引用传递的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">double</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(Box&amp; b)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Box b1;</span><br><span class="line">	b1.len=<span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用前，b1 的值：&quot;</span> &lt;&lt; b1.len &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">modify</span>(b1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用后，b1 的值：&quot;</span> &lt;&lt; b1.len &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(Box&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	b.len=<span class="number">10.0</span>;</span><br><span class="line">	Box b2;</span><br><span class="line">	b2.len = <span class="number">999</span>;</span><br><span class="line">	b = b2;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用前，b1 的值：<span class="number">100</span></span><br><span class="line">调用后，b1 的值：<span class="number">999</span></span><br></pre></td></tr></table></figure>

<p>可以看到把新对象 <code>b2</code> 赋值给入参 <code>b</code> 后是会影响到原有数据的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实这几种语言看下来会发现他们中也有许多相似之处，所以通常我们在掌握一门语言后也能快速学习其他语言。</p>
<p>但往往是这些基础中的基础最让人忽略，希望大家在日常编码时能够考虑到这些基础知识多想想一定会写出更漂亮的代码(bug)。</p>
]]></content>
      <categories>
        <category>基础原理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Python</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中的面向接口编程</title>
    <url>/2021/01/14/basic/python-oop/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/01/14/pPAYXUDmc2Vxr1d.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>”面向接口编程“</code>写 <code>Java</code> 的朋友耳朵已经可以听出干茧了吧，当然这个思想在 <code>Java</code> 中非常重要，甚至几乎所有的编程语言都需要，毕竟程序具有良好的扩展性、维护性谁都不能拒绝。</p>
<span id="more"></span>

<p>最近无意间看到了我刚开始写 <code>Python</code> 时的部分代码，当时实现的需求有个很明显的特点：</p>
<ul>
<li>不同对象具有公共的行为能力，但具体每个对象的实现方式又各不相同。</li>
</ul>
<p>说人话就是商户需要接入平台，接入的步骤相同，但具体实现不同。</p>
<p>作为一个”资深“ <code>Javaer</code>，需求还没看完我就洋洋洒洒的把各个实现类写好了：</p>
<p><img src="https://i.loli.net/2021/01/14/OanLP4i9VMIBw16.jpg"></p>
<p>当然最终也顺利实现需求，甚至把组里一个没写过 <code>Java</code> 的大哥唬的一愣一愣的，直呼牛逼。</p>
<p><img src="https://i.loli.net/2021/01/14/VnFHiBELTesvXAW.jpg"></p>
<p>不过事后也给我吐槽：</p>
<ul>
<li>你这设计是不错，但是感觉好复杂，跟代码时要找到真正的业务逻辑（实现类）得绕几圈。</li>
</ul>
<p>截止目前 <code>Python</code> 写多了，我总算是能总结他的感受：就是不够 <code>Pythonic</code>。</p>
<p>虽说 <code>Python</code> 没有类似 <code>Java</code> 这样的 <code>Interface</code> 特性，但作为面向对象的高级语言也是支持继承的；</p>
<p>在这里我们也可以利用继承的特性来实现面向接口编程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benz</span>(<span class="title class_ inherited__">Car</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;benz run&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span>(<span class="title class_ inherited__">Car</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bwm run&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">car</span>):</span><br><span class="line">    car.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    benz = Benz()</span><br><span class="line">    bmw = BMW()</span><br><span class="line"></span><br><span class="line">    run(benz)</span><br><span class="line">    run(bmw)</span><br></pre></td></tr></table></figure>

<p>代码非常简单，在 <code>Python</code> 中也没有类似于 <code>Java</code> 中的 <code>extends</code> 关键字，只需要在类声明末尾用括号包含基类即可。</p>
<p>这样在每个子类中就能单独实现业务逻辑，方便扩展和维护。</p>
<h1 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h1><p>由于 <code>Python</code> 作为一个动态类型语言，无法做到 <code>Java</code> 那样在编译期间校验一个类是否完全实现了某个接口的所有方法。</p>
<p>为此 <code>Python</code> 提供了解决办法，那就是 <code>abc(Abstract Base Classes)</code> ，当我们将基类用 <code>abc</code> 声明时就能近似做到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(abc.ABC):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benz</span>(<span class="title class_ inherited__">Car</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;benz run&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span>(<span class="title class_ inherited__">Car</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">car</span>):</span><br><span class="line">    car.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    benz = Benz()</span><br><span class="line">    bmw = BMW()</span><br><span class="line"></span><br><span class="line">    run(benz)</span><br><span class="line">    run(bmw)</span><br></pre></td></tr></table></figure>

<p>一旦有类没有实现方法时，运行期间便会抛出异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bmw = BMW()</span><br><span class="line">TypeError: Can<span class="string">&#x27;t instantiate abstract class BMW with abstract methods run</span></span><br></pre></td></tr></table></figure>

<p>虽然无法做到在运行之前（毕竟不需要编译）进行校验，但有总比没有好。</p>
<h1 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h1><p>以上两种方式看似已经毕竟优雅的实现面向接口编程了，但实际上也不够 <code>Pythonic</code>。</p>
<p>在继续之前我们先聊聊<code>接口</code>的本质到底是什么？</p>
<p>在 <code>Java</code> 这类静态语言中面向接口编程是比较麻烦的，也就是我们常说的子类向父类转型，因此需要编写额外的代码。</p>
<p>带来的好处也是显而易见，只需要父类便可运行。</p>
<p>但我们也不必过于执着于接口，它本身只是一个协议、规范，并不特指 <code>Java</code> 中的 <code>Interface</code>，甚至有些语言压根没有这个关键字。</p>
<p>动态语言的特性也不需要强制校验是否实现了方法。</p>
<p>在 <code>Python</code> 中我们可以利用鸭子类型来优雅的实现面向接口编程。</p>
<p>在这之前先了解下鸭子类型，借用维基百科的说法：</p>
<ul>
<li>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</li>
</ul>
<p>我用大白话翻译下就是：</p>
<p>即便两个完全不想干的类，如果他们都实现了相同的方法，那就可以把他们当做同一类型的类来使用。</p>
<p>举个简单例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">obj</span>):</span><br><span class="line">    obj.create()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    order = Order()</span><br><span class="line">    user = User()</span><br><span class="line">    create(order)</span><br><span class="line">    create(user)</span><br></pre></td></tr></table></figure>

<p>这里的 <code>order</code> 和 <code>user</code> 本身完全没有关系，只是他们都有相同方法，又得益于动态语言没法校验类型的特点，所以完全可以在运行的时候认为他们是同一种类型。</p>
<p>因此基于鸭子类型，之前的代码我们可以稍作简化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benz</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;benz run&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bwm run&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">car</span>):</span><br><span class="line">    car.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    benz = Benz()</span><br><span class="line">    bmw = BMW()</span><br><span class="line"></span><br><span class="line">    run(benz)</span><br><span class="line">    run(bmw)</span><br></pre></td></tr></table></figure>

<p>因为在鸭子类型中我们在意的是它的行为，而不是他们的类型；所以完全可以不用继承便可以实现面向接口编程。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我觉得平时没有接触过动态类型语言的朋友，在了解完这些之后会发现新大陆，就像是 <code>Python</code> 老手第一次使用 <code>Java</code> 时；虽然觉得语法啰嗦，但也会羡慕它的类型检查、参数验证这类特点。</p>
<p>动静语言之争这里不做讨论了，各有各的好，鞋好不好穿只有自己知道。</p>
<p>随便提一下其实不止动态语言具备鸭子类型，有些静态语言也能玩这个骚操作，感兴趣下次再介绍。</p>
]]></content>
      <categories>
        <category>基础原理</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>鸭子类型</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>词法分析器的应用</title>
    <url>/2020/03/23/compilation/Lexer/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/03/23/4onkHVWNTsELqaK.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近大部分时间都在撸 <code>Python</code>，其中也会涉及到将数据库表转换为 <code>Python</code> 中 <code>ORM</code> 框架的 <code>Model</code>，但我们并没有找到一个合适的工具来做这个意义不大的”体力活“，所以每次新建表后大家都是根据自己的表结构手写一遍 <code>Model</code>。</p>
<p>一两张表还好，一旦 10 几张表都要写一遍时那痛苦只有自己知道；这时程序员的 slogan 再次印证：一切毫无意义的体力劳动终将被计算机取代。</p>
<span id="more"></span>

<h1 id="intellij-plugin"><a href="#intellij-plugin" class="headerlink" title="intellij plugin"></a>intellij plugin</h1><p>既然没有现成的工具那就自己写一个吧，演示效果如下：<br><img src="https://i.loli.net/2020/03/23/dLpAoxf4BwEj81S.gif" alt="1-min.gif"></p>
<p>考虑到我们主要是用 <code>PyCharm</code> 开发，正好 <code>jetbrains</code> 也提供了 <code>SDK</code> 用于开发插件，所以 <code>UI</code> 层面可以不用额外考虑了。</p>
<p>使用流程很简单，只需要导入 <code>DDL</code> 语句就可以生成 <code>Python</code> 所需要的 <code>Model</code> 代码。</p>
<p>例如导入以下 DDL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `userName` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `roleId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),  </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">7</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure>

<p>便会生成对应的 Python 代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;user&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    userName = db.Column(db.String)  <span class="comment"># 用户名</span></span><br><span class="line">    password = db.Column(db.String)  <span class="comment"># 密码</span></span><br><span class="line">    roleId = db.Column(db.Integer)  <span class="comment"># 角色ID</span></span><br></pre></td></tr></table></figure>


<h1 id="词法解析"><a href="#词法解析" class="headerlink" title="词法解析"></a>词法解析</h1><p>仔细对比源文件及目标代码会很容易找出规律，无非就是解析出表名、字段、及字段的属性（是否为主键、类型、长度），最后再转换为 <code>Python</code> 所需要的模板即可。</p>
<p>在我动手之前我认为是非常简单的，无非就是解析字符串，但实际上手后发现不是那么回事；主要是有以下几个问题：</p>
<ol>
<li>如何识别出表名称？</li>
<li>同样的如何识别出字段名称，同时还得关联上该字段的类型、长度、注释。</li>
<li>如何识别出主键？</li>
</ol>
<p>总结一句话，如何通过一系列规则识别出一段字符串中的关键信息，这同样也是 MySQL Server 所做的事情。</p>
<p>在开始真正解析 DDL 之前，先来看下一段简单的脚本如何解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>按照我们平时开发的经验，这条语句分为以下几部分：</p>
<ul>
<li><code>x</code> 表示变量</li>
<li><code>=</code> 表示赋值符号</li>
<li><code>20</code> 表示赋值结果</li>
</ul>
<p>所以我们对这段脚本的解析结果应当为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VAR 	 x</span><br><span class="line">GE 	    =</span><br><span class="line">VAL 	 100</span><br></pre></td></tr></table></figure>

<p>这个解析过程在编译原理中称为”词法解析“，可能大家听到<code>编译原理</code>这几个字就头大（我也是）；对于刚才那段脚本我们可以编写一个非常简单的词法解析器生成这样的结果。</p>
<h2 id="状态迁移"><a href="#状态迁移" class="headerlink" title="状态迁移"></a>状态迁移</h2><p>再开始之前先捋一下思路，可以看到上文的结果中通过 <code>VAR</code> 表示变量、<code>GE</code> 表示赋值符号 ”&#x3D;“、<code>VAL</code> 表示赋值结果，现在需要重点记住这三个状态。</p>
<p>在依次读取字符解析时，程序就是在这几个状态中来回切换，如下图：<br><img src="https://i.loli.net/2020/03/23/XPcKbDVUNsSeGM9.jpg"></p>
<ol>
<li>默认为初始状态。</li>
<li>当字符为字母时进入 <code>VAR</code> 状态。</li>
<li>当字符为 ”&#x3D;“ 符号时进入 <code>GE</code> 状态。</li>
</ol>
<p><img src="https://i.loli.net/2020/03/23/3mRvj4O1y8EgPNu.jpg"></p>
<p>同理，当不满足这几个状态时候又会回到初始从而再次确认新的状态。</p>
<p>光看图有点抽象，直接来看核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TokenType tokenType ;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">StringBuilder</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先定义了一个结果类，收集最终的解析结果；其中的 <code>TokenType</code> 就对应了图中的三种状态，简单的用枚举值来表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TokenType</span> &#123;</span><br><span class="line">    INIT,</span><br><span class="line">    VAR,</span><br><span class="line">    GE,</span><br><span class="line">    VAL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先对应到第一张图：初始化状态。</p>
<p>需要对当前解析的字符定义一个 <code>TokenType</code>：<br><img src="https://i.loli.net/2020/03/23/3WU5vyiGF1eCq47.jpg"></p>
<p>和图中描述的流程一致，判断当前字符给定一个状态即可。</p>
<p>接着对应到第二张图：状态之间的转换。</p>
<p><img src="https://i.loli.net/2020/03/23/BXqdW1JPMj59yTG.jpg"></p>
<p>会根据不同的状态进入不同的 <code>case</code>，在不同的 <code>case</code> 中判断是否应当跳转到其他状态（进入 <code>INIT</code> 状态后会重新生成状态）。</p>
<p>举个例子： <code>x = 20</code>:</p>
<p>首选会进入 <code>VAR</code> 状态，接着下一个字符为空格，自然在 38 行中重新进入初始状态，导致再次确定下一个字符 <code>=</code> 进入 <code>GE</code> 状态。</p>
<p>当脚本为 <code>ab = 30</code>:<br>第一个字符为 a 也是进入 <code>VAR</code> 状态，第二个字符为 b，依然为字母，所以进入 36 行，状态不会改变，同时将 b 这个字符追加进来；后续步骤就和上一个例子一致了。</p>
<p>多说无益，建议大家自己跑一下单测就会明白：<br><a href="https://github.com/crossoverJie/sqlalchemy-transfer/blob/master/src/test/java/top/crossoverjie/plugin/core/lab/TestLexerTest.java">https://github.com/crossoverJie/sqlalchemy-transfer/blob/master/src/test/java/top/crossoverjie/plugin/core/lab/TestLexerTest.java</a><br><img src="https://i.loli.net/2020/03/23/xvB3uJAPm8tsDSF.jpg"><br><img src="https://i.loli.net/2020/03/23/EDNnAXGTJRbmkij.jpg"></p>
<h2 id="DDL-解析"><a href="#DDL-解析" class="headerlink" title="DDL 解析"></a>DDL 解析</h2><p>简单的解析完成后来看看 <code>DDL</code> 这样的脚本应当如何解析：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `userName` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `roleId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),  </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">7</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure>

<p>原理类似，首先还是要看出规律（也就是语法）：</p>
<ul>
<li>表名是第一行语句，同时以 <code>CREATE TABLE</code> 开头。</li>
<li>每一个字段的信息（名称、类型、长度、备注）都是以 “&#96;” 符号开头 “,” 结尾。 </li>
<li>主键是以 PRIMART 字符串开头的字段，以 <code>)</code> 结尾。</li>
</ul>
<p>根据我们需要解析的数据种类，我这里定义了这个枚举：<br><img src="https://i.loli.net/2020/03/23/p1UxCHKNGbDQZ5d.jpg"></p>
<p>然后在初始化类型时进行判断赋值：<br><img src="https://i.loli.net/2020/03/23/mtsRX534r7hpqHy.jpg"></p>
<p>由于需要解析的数据不少，所以这里的判断条件自然也就多了。</p>
<h2 id="递归解析"><a href="#递归解析" class="headerlink" title="递归解析"></a>递归解析</h2><p>针对于 <code>DDL</code> 的语法规则，我们这里还有需要有特殊处理的地方；比如解析具体字段信息时如何关联起来？</p>
<p>举个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">`userName` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">`password` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br></pre></td></tr></table></figure>

<p>这里我们解析出来的数据得有一个映射关系：</p>
<p><img src="https://i.loli.net/2020/03/23/MHdbTgSY5IELwQc.jpg"></p>
<p>所以我们只能一个字段的全部信息解析完成并且关联好之后才能解析下一个字段。</p>
<p>于是这里我采用了递归的方式进行解析（不一定是最好的，欢迎大家提出更优的方案）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="string">&#x27;`&#x27;</span> &amp;&amp; pStatus == Status.BASE_INIT) &#123;</span><br><span class="line">    result.tokenType = DDLTokenType.FI;</span><br><span class="line">    result.text.append(value);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>当当前字符为 ”&#96;“ 符号时，将状态置为 “FI”(FieldInfo)，同时当解析到为 “,” 符号时便进入递归处理。</p>
<p><img src="https://i.loli.net/2020/03/23/bDYsyUZB3cwLHu6.jpg"></p>
<p>可以理解为将这一段字符串单独提取出来处理：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">`userName` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br></pre></td></tr></table></figure>

<p>接着再将这段字符递归调用当前方法再次进行解析，这时便按照字段名称、类型、长度、注释的规则解析即可。</p>
<p>同时既然存在递归，还需要将子递归的数据关联起来，所以我在返回结果中新增了一个 <code>pid</code> 的字段，这个也容易理解。</p>
<p>默认值为 0，一旦递归后便自增 +1，保证每次递归的数据都是唯一的。</p>
<p>用同样的方法在解析主键时也是先将整个字符串提取出来:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br></pre></td></tr></table></figure>

<p>只不过是 “P” 打头 “)” 结尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="string">&#x27;P&#x27;</span> &amp;&amp; pStatus == Status.BASE_INIT) &#123;</span><br><span class="line">    result.tokenType = DDLTokenType.P_K;</span><br><span class="line">    result.text.append(value);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/03/23/MYVlc4Sb9LovH2z.jpg"></p>
<p>也是将整段字符串递归解析，再递归的过程中进行状态切换 <code>P_K ---&gt; P_K_V</code> 最终获取到主键。</p>
<hr>
<p><img src="https://i.loli.net/2020/03/23/qRkbKrH9IWtVnw1.jpg"></p>
<p>所以通过对刚才那段 <code>DDL</code> 解析得到的结果如下：</p>
<p><img src="https://i.loli.net/2020/03/23/k3GCZe1sKujtbrp.jpg"></p>
<p>这样每个字段也通过了 <code>pid</code> 进行了区分关联。</p>
<p>所以现在只需要对这个词法解析器进行封装，便可以提供一个简单的 <code>API</code> 来获取表中的数据了。</p>
<p><img src="https://i.loli.net/2020/03/23/1V8vsNFdxMLiRlY.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此整个词法解析器的全部内容都已经完成了，虽然实现的是一个小功能，但我自己花的时间可不少，其中光复习编译原理就让人头疼。</p>
<p>但这还只是整个编译语言知识点的冰山一角，后续还有语法、语义、中间、目标代码等一系列内容，都是一个比一个难啃。</p>
<p>其实我相信大多数人和我想法一样，这个东西太底层而且枯燥，真正从事这方面工作的也都是凤毛麟角，所以花这时间干啥呢？</p>
<p>所以我也决定这个弄完后就弃坑啦。</p>
<p><img src="https://i.loli.net/2020/03/23/6bTSWEcxzaykX9N.jpg"></p>
<hr>
<p>哈哈，开个玩笑，或许有生之年自己也能实现一门编程语言，当老了和儿子吹牛时也能有点资本。</p>
<p>本文所有源码及插件地址：</p>
<p><a href="https://github.com/crossoverJie/sqlalchemy-transfer">https://github.com/crossoverJie/sqlalchemy-transfer</a></p>
<p><strong>大家看完记得点赞分享一键三连哦</strong></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>递归</tag>
        <tag>DDL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中的 os.popen 函数 与 Pipe 管道的坑</title>
    <url>/2021/05/12/cs/Linux%20Pipe/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/07/03/TQEsbHyXncNkLV4.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近用 <code>Python</code> 写了几个简单的脚本来处理一些数据，因为只是简单功能所以我就直接使用 <code>print</code> 来打印日志。</p>
<p>任务运行时偶尔会出现一些异常：</p>
<p><img src="https://i.loli.net/2021/07/03/dC5NDG7SJBxor3R.jpg"></p>
<span id="more"></span>

<p>因为我在不同地方都有打印日志，导致每次报错的地方都不太一样，从而导致程序运行结果非常诡异；有时候是这段代码没有运行，下一次就可能是另外一段代码没有触发。</p>
<p>虽说当时有注意到 <code>Broken pipe</code> 这个关键异常，但没有特别在意，因为代码中也有一些发送 <code>http</code> 请求的地方，一直以为是网络 <code>IO</code> 出现了问题，压根没往 <code>print</code> 这个最基本的打印函数上思考🤔。</p>
<p>直到这个问题反复出现我才认真看了这个异常，定睛一看 <code>print</code> 不也是 <code>IO</code> 操作嘛，难道真的是自带的  <code>print</code> 函数都出问题了？</p>
<hr>
<p>但在本地、测试环境我运行无数次也没能发现异常；于是我找运维拿到了线上的运行方式。</p>
<p>原来为了方便维护大家提交上来的脚本任务，运维自己有维护一个统一的脚本，在这个脚本中使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cmd = <span class="string">&#x27;python /xxx/test.py&#x27;</span></span><br><span class="line">os.popen(cmd)</span><br></pre></td></tr></table></figure>
<p>来触发任务，这也是与我在本地、开发环境的唯一区别。</p>
<h1 id="popen-原理"><a href="#popen-原理" class="headerlink" title="popen 原理"></a>popen 原理</h1><p>为此我在开发环境模拟出了异常：</p>
<p>test.py:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    time.sleep(<span class="number">20</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;1000&#x27;</span>*<span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>task.py:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = <span class="built_in">int</span>(time.time())</span><br><span class="line">    cmd = <span class="string">&#x27;python test.py&#x27;</span></span><br><span class="line">    os.popen(cmd)</span><br><span class="line">    end = <span class="built_in">int</span>(time.time())</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;end****&#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(end-start)</span><br></pre></td></tr></table></figure>

<p>运行:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python task.py</span><br></pre></td></tr></table></figure>
<p>等待 20s 必然会复现这个异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    print &#x27;1000&#x27;*1024</span><br><span class="line">IOError: [Errno 32] Broken pipe</span><br></pre></td></tr></table></figure>

<p>为什么会出现这个异常呢？</p>
<p>首先得了解 <code>os.popen(command[, mode[, bufsize]])</code> 这个函数的运行原理。<br><img src="https://i.loli.net/2021/07/03/hbYLUTvKAg1VDwH.jpg"></p>
<p>根据官方文档的解释，该函数会执行 <code>fork</code> 一个子进程执行 <code>command</code> 这个命令，同时将子进程的标准输出通过管道连接到父进程；</p>
<p>也就该方法返回的文件描述符。</p>
<p>这里画个图能更好地理解其中的原理：<br><img src="https://i.loli.net/2021/07/03/WDnmiu1p7hMFJVG.jpg"></p>
<p>在这里的使用场景中并没有获取 <code>popen()</code> 的返回值，所以 <code>command</code> 的执行本质上是异步的；</p>
<p>也就是说当 <code>task.py</code> 执行完毕后会自动关闭读取端的管道。<br><img src="https://i.loli.net/2021/07/03/IgsLnN1edWXPzDj.jpg"><br>如图所示，关闭之后子进程会向 <code>pipe</code> 中输出  <code>print &#39;1000&#39;*1024</code>，由于这里输出的内容较多会一下子填满管道的缓冲区；</p>
<p>于是写入端会收到 <code>SIGPIPE</code> 信号，从而导致 <code>Broken pipe</code> 的异常。</p>
<p>从维基百科中我们也可以看出这个异常产生的一些条件：<br><img src="https://i.loli.net/2021/07/03/cL3xf6MozGKjT9D.jpg"></p>
<p>其中也提到了 <code>SIGPIPE</code> 信号。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>既然知道了问题原因，那解决起来就比较简单了，主要有以下几个方案：</p>
<ol>
<li>使用 <code>read()</code> 函数读取管道中的数据，全部读取之后再关闭。</li>
<li>如果不需要子进程中的输出时，也可以将 <code>command</code> 的标准输出重定向到 <code>/dev/null</code>。</li>
<li>也可以使用 <code>Python3</code> 的 <code>subprocess.Popen</code> 模块来运行。</li>
</ol>
<p>这里使用第一种方案进行演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = <span class="built_in">int</span>(time.time())</span><br><span class="line">    cmd = <span class="string">&#x27;python test.py&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> os.popen(cmd) <span class="keyword">as</span> p:</span><br><span class="line">        <span class="built_in">print</span> p.read()</span><br><span class="line">    end = <span class="built_in">int</span>(time.time())</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;end****&#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(end-start)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/07/03/kGqe4c2B7rQdz8l.jpg"></p>
<p>运行 <code>task.py</code> 之后不会再抛异常，同时也将 <code>command</code> 的输出打印出来。</p>
<p>线上修复时我没有采用这个方案，为了方便查看日志，还是使用标准的日志框架将日志输出到了 es 中，方便统一在 <code>kibana</code> 中进行查看。</p>
<p>由于日志框架并没有使用到管道，所以自然也不会有这个问题。</p>
<h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p>问题虽然是解决了，其中还是涉及到了一些咱们平时不太注意的知识点，这次我们就来一起回顾一下。</p>
<p>首先是父子进程的内容，这个在 <code>c/c++/python</code> 中比较常见，在 <code>Java/golang</code> 中直接使用多线程、协程会更多一些。</p>
<p>比如这次提到的 <code>Python</code> 中的 <code>os.popen()</code> 就是创建了一个子进程，既然是子进程那肯定是需要和父进程进行通信才能达到协同工作的目的。</p>
<p>很容易想到，父子进程之间可以通过上文提到的管道（匿名管道）来进行通信。</p>
<p>还是以刚才的 Python 程序为例，当运行 task.py 后会生成两个进程：<br><img src="https://i.loli.net/2021/07/03/erJdoNmAuKI5RCD.jpg"></p>
<p>分别进入这两个程序的<code> /proc/pid/fd</code> 目录可以看到这两个进程所打开的文件描述符。</p>
<p>父进程：</p>
<p><img src="https://i.loli.net/2021/07/03/AF4rtxZf8UgM9HG.jpg"></p>
<p>子进程：</p>
<p><img src="https://i.loli.net/2021/07/03/NYBF3rAGQhLgiaR.jpg"></p>
<p>可以看到子进程的标准输出与父进程关联，也就是 <code>popen()</code> 所返回的那个文件描述符。</p>
<blockquote>
<p>这里的 <code>0 1 2</code> 分别对应一个进程的<code>stdin</code>(标准输入)&#x2F;<code>stdout</code>(标准输出)&#x2F;<code>stderr</code>(标准错误)。</p>
</blockquote>
<p>还有一点需要注意的是，当我们在父进程中打开的文件描述符，子进程也会继承过去；</p>
<p>比如在 <code>task.py</code> 中新增一段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">open</span>(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>之后查看文件描述符时会发现父子进程都会有这个文件：<br><img src="https://i.loli.net/2021/07/03/JhxpF5ict78l3yz.jpg"></p>
<p>但相反的，子进程中打开的文件父进程是不会有的，这个应该很容易理解。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一些基础知识在排查一些诡异问题时显得尤为重要，比如本次涉及到的父子进程的管道通信，最后来总结一下：</p>
<ol>
<li><code>os.popen()</code> 函数是异步执行的，如果需要拿到子进程的输出，需要自行调用 <code>read()</code> 函数。</li>
<li>父子进程是通过匿名管道进行通信的，当读取端关闭时，写入端输出到达管道最大缓存时会收到 <code>SIGPIPE</code> 信号，从而抛出 <code>Broken pipe</code> 异常。</li>
<li>子进程会继承父进程的文件描述符。</li>
</ol>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>cs</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pipe</tag>
        <tag>fd</tag>
      </tags>
  </entry>
  <entry>
    <title>不要小看小小的 emoji 表情😂</title>
    <url>/2019/09/10/cs/not%20easy%20emoji/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/09/10/GDoscUdhbC4k3AL.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久没更新了，最近事比较多，或许下个月就会恢复到正常的发文频次。</p>
<p>这篇文章得从一个 <code>emoji</code> 表情开始，我之前开源的一个 <code>IM</code> 项目中有朋友提到希望可以支持 <code>emoji</code> 表情传输。</p>
<p><a href="https://github.com/crossoverJie/cim/issues/12">https://github.com/crossoverJie/cim/issues/12</a></p>
<p><img src="https://i.loli.net/2019/09/10/jwW5rIiUQdLMnkB.jpg"></p>
<p>正好那段时间有空，加上这功能看着也比较简单准备把它实现了。</p>
<span id="more"></span>

<p>但在真正实现时却发现没那么简单。</p>
<p><img src="https://i.loli.net/2019/09/10/dTJSxgEQlAwuKeR.jpg"></p>
<hr>
<p>我首先尝试将一个 <code>emoji</code> 表情存入数据库看看：</p>
<p><img src="https://i.loli.net/2019/09/10/eyEfVD8SKiH23Uu.jpg"></p>
<p>果不其然的出错了，导致这个异常的原因是目前数据库所支持的编码中并不能存放 <code>emoji</code>，那 <code>emoji</code> 表情到底是个什么东西呢。</p>
<p>本质上来说计算机所存储的信息都是二进制 <code>01</code>，<code>emoji</code> 也不例外，只要存储和读取（编解码）的方式一致那就可以准确的展示这个信息。</p>
<blockquote>
<p>更多编解码的内容后文再介绍，这里先想想如何快速解决问题。</p>
</blockquote>
<h1 id="存储-emoji"><a href="#存储-emoji" class="headerlink" title="存储 emoji"></a>存储 emoji</h1><p>虽说想要在 <code>MySQL</code> 中存储 <code>emoji</code> 的方式也有好几种，比如可以升级存储字符集到可以存放 <code>emoji</code> ，但这种需要 <code>MySQL</code> 的版本支持。</p>
<p>所以更保险的方式还是在应用层解决，比如我们是否可以将 emoji 当做字符串存储，只是显示的时候要格式化为一个 emoji 表情，这样对于所有的数据库版本都可兼容。</p>
<p>于是我们这里的需求是一个 <code>emoji</code> 表情转换为字符串，同时还得将这个字符串转换为 emoji。</p>
<p>为此我在 <code>GitHub</code> 上找到了一个库，它可以方便的将一个 <code>emoji</code> 转换为字符串的别名，同时也支持将这个别名转换为 <code>emoji</code>。</p>
<p><a href="https://github.com/vdurmont/emoji-java">https://github.com/vdurmont/emoji-java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">emoji</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;An :grinning:awesome :smiley:string &amp;#128516;with a few :wink:emojis!&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> EmojiParser.parseToUnicode(str);</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">    result = EmojiParser.parseToAliases(str);</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/09/10/Xr6EwodnJepOqKT.jpg"></p>
<p>所以基于这个基础库最终实现了表情功能。</p>
<p><img src="https://i.loli.net/2019/09/10/V4LGmUtx7k1Suvj.jpg"></p>
<p>其实它本质上是自己维护了一个 emoji 的别名及它的 Unicode 编码(本质上是 <code>UTF-16</code>)的映射关系，再每次格式化数据的时候都会从这个表中进行翻译。</p>
<p><img src="https://i.loli.net/2019/09/10/FLs7w8NXfzbYKgH.jpg"></p>
<h1 id="编码知识回顾"><a href="#编码知识回顾" class="headerlink" title="编码知识回顾"></a>编码知识回顾</h1><p>自此需求是完成了，但还有几个问题待解决。</p>
<ul>
<li><code>Java</code> 中是如何存储 <code>emoji</code> 的？</li>
<li><code>emoji</code> 是如何进行编码的？</li>
</ul>
<h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>在谈 <code>emoji</code> 之前非常有必要了解下计算机编码鼻祖的 ASCII 码。</p>
<p>大家现在都知道在计算机内部存储数据本质上都是二进制的 0&#x2F;1，对于一个字节来说有 8 位；每一位可以表示两种状态，也就是 0 或 1，这样排列组合下来，一个字节就可以表示 256(2∧8) 种不同的状态。</p>
<p><img src="https://i.loli.net/2019/09/10/APbq73R4mWMI9Tj.jpg"></p>
<hr>
<p>对于美国来说他们日常使用的英语只需要 26 个英文字母，再加上一些标点符号就足够用计算机来进行信息交流。</p>
<p>于是上个世纪 60年代定义了一套二进制与英文字符的映射关系，可以表明 128 个不同的英文字符，也就是现在的 <code>ASCII</code> 码。</p>
<p>这样我们就可以使用一个字节来表示现代英文，看起来非常不错。</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>随着计算机的发展，逐渐在欧洲、亚洲地区流行；再利用这套 <code>ASCII</code> 码进行信息交流显然是不行的，很多地区压根就不使用英文，而且也远超了 128 位字符（中文就更不用说了）。</p>
<p>虽说一个字节在 <code>ASCII</code> 码中只用了 <code>128</code> 位，但剩下(<code>258-128</code>)的依然不足用用于描述其他语言。</p>
<p>这时如果能有一种包含了世界上所有的文字的字符集，每一个地区的文字都在这个字符集中有唯一的二进制表示，这样便不会出现乱码问题了。</p>
<p><code>Unicode</code> 就是来做这个的，截止目前 <code>Unicode</code> 已经收录了 10W+ 的字符，你所能使用的字符都包含进去了。</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p><code>Unicode</code> 虽说包含了几乎所有的文字，但在我们日常使用好像很少看到他的身影，我们用的更多的还是 <code>UTF-8</code> 这样的编码规则。</p>
<p>这也有几方面的原因，比如说除开英文，其他大部分的文字都需要用 2 个甚至更多的字节来表示；如果统一都用 Unicode 来表示，那必然需要以占用字节最多的字符长度为标准。</p>
<p>比如汉字需要 2 个字节来表示，而英文只需要一个字节；这时就得规定 2 个字节表示一个字符，不然汉字就没法表示了。</p>
<p>但这样也会带来一个问题：用两个字节表示英文会使得第一个字节完全是浪费的，如果一段信息全是英文那对内存的浪费是巨大的。</p>
<hr>
<p>这时大家应该都能想到，我们需要一个可变的长度的字符编码规则，当是英文时我们就用一个字节表示，甚至可以完全兼容 ASCII 码。</p>
<p>UTF-8 便是实现这个需求的，它利用两种规则可以表示一个字节以及多字节的字符。</p>
<p><img src="https://i.loli.net/2019/09/10/DFOgGqsnAH2h56b.jpg"></p>
<p>大致规则如下：</p>
<ul>
<li>当第一个字节的第一位为 0 时便表示为单字节字符，此时和 ASCII 码一致，完全兼容。</li>
<li>当第一个字节为 1 时，有几个 1 便代表是几个字节 Unicode 字符。</li>
</ul>
<p>这样便可根据字符的长度最大程度的节省存储空间。</p>
<p>当然还有其他的编码规则，比如 <code>UTF-16</code>、<code>UTF-32</code>，平时用的不多，但本质上都和 <code>UTF-8</code> 一样，都是 <code>Unicode</code> 的不同实现，也是用于表示世界上大部分文字的字符集。</p>
<h1 id="Java-中的-emoji"><a href="#Java-中的-emoji" class="headerlink" title="Java 中的 emoji"></a>Java 中的 emoji</h1><p>现在来回到本次的主题，<code>emoji</code>。</p>
<p>刚才说到 <code>Unicode</code> 包含了世界上大部分的字符，<code>emoji</code> 自然也不例外。</p>
<p><img src="https://i.loli.net/2019/09/10/Aeo5tuh8HGsNijp.jpg"></p>
<p><a href="https://apps.timwhitlock.info/emoji/tables/unicode">https://apps.timwhitlock.info/emoji/tables/unicode</a></p>
<p>这个表格中包含了所有的 <code>emoji</code> 以及它所对应的 <code>Unicode</code> 编码，同时也有对应的 <code>UTF-8</code> 编码的实现。</p>
<p>从图中也可以看出 <code>emoji</code> 表情用 <code>UTF-8</code> 表示时会占用 4 个字节，那在 Java 中它会是怎么存储的呢？</p>
<p>很简单，debug 一下就知道了。</p>
<p><img src="https://i.loli.net/2019/09/10/CHZ3UjuQOmqAklY.jpg"></p>
<p>在 <code>Java</code> 中也是通过 <code>char</code> 来存储 <code>emoji</code> 的，<code>char</code> 作为基本数据类型会占用 2 个字节；从刚才的图中可以看出，<code>emoji</code> 使用 <code>UTF-8</code> 会占用四个字节，这样很明显 <code>char</code> 是没法存储的，所以在这里其实是使用 <code>UTF-16</code> 编码进行存储。</p>
<p>基于这个原理，我们也可以自己实现将一个 <code>emoji</code> 表情转换为字符串，同时也可通过字符串转换为 <code>emoji</code>。</p>
<p><img src="https://i.loli.net/2019/09/10/LwHmaYAy4Fx9kZD.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从这次研究 <code>emoji</code> 可以看出，任何一门基础知识都是应用的根基，在计算机行业尤为突出，希望大家看完这篇能回忆起大学课堂被老师支配的恐惧😂。</p>
<p>随便提一下，相关源码可在这里查看：</p>
<p><a href="https://github.com/crossoverJie/cim">https://github.com/crossoverJie/cim</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>cs</category>
      </categories>
      <tags>
        <tag>emoji</tag>
        <tag>unicode</tag>
        <tag>utf-8</tag>
        <tag>ascii</tag>
      </tags>
  </entry>
  <entry>
    <title>『并发包入坑指北』之向大佬汇报任务</title>
    <url>/2019/04/28/concurrent/CountDownLatch/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/04/28/5cc5660ef23f4.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在面试过程中聊到并发相关的内容时，不少面试官都喜欢问这类问题：</p>
<blockquote>
<p>当 N 个线程同时完成某项任务时，如何知道他们都已经执行完毕了。</p>
</blockquote>
<p>这也是本次讨论的话题之一，所以本篇为『并发包入坑指北』的第二篇；来聊聊常见的并发工具。</p>
<span id="more"></span>

<h1 id="自己实现"><a href="#自己实现" class="headerlink" title="自己实现"></a>自己实现</h1><p>其实这类问题的核心论点都是：如何在一个线程中得知其他线程是否执行完毕。</p>
<p>假设现在有 3 个线程在运行，需要在主线程中得知他们的运行结果；可以分为以下几步：</p>
<ul>
<li>定义一个计数器为 3。</li>
<li>每个线程完成任务后计数减一。</li>
<li>一旦计数器减为 0 则通知等待的线程。</li>
</ul>
<p>所以也很容易想到可以利用等待通知机制来实现，和上文的<a href="https://crossoverjie.top/2019/04/09/concurrent/ArrayBlockingQueue/">『并发包入坑指北』之阻塞队列</a>的类似。</p>
<p>按照这个思路自定义了一个 <code>MultipleThreadCountDownKit</code> 工具，构造函数如下：</p>
<p><img src="https://i.loli.net/2019/04/28/5cc58f10f1f2e.png"></p>
<p>考虑到并发的前提，这个计数器自然需要保证线程安全，所以采用了 <code>AtomicInteger</code>。</p>
<p>所以在初始化时需要根据线程数量来构建对象。</p>
<h2 id="计数器减一"><a href="#计数器减一" class="headerlink" title="计数器减一"></a>计数器减一</h2><p>当其中一个业务线程完成后需要将这个计数器减一，直到减为0为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程完成后计数 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (counter.get() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.counter.decrementAndGet();</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;concurrent error&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (notify)&#123;</span><br><span class="line">            notify.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 <code>counter.decrementAndGet()</code> 来保证多线程的原子性，当减为 0 时则利用等待通知机制来 <code>notify</code> 其他线程。</p>
<h2 id="等待所有线程完成"><a href="#等待所有线程完成" class="headerlink" title="等待所有线程完成"></a>等待所有线程完成</h2><p>而需要知道业务线程执行完毕的其他线程则需要在未完成之前一直处于等待状态，直到上文提到的在计数器变为 0 时得到通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待所有的线程完成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (notify)&#123;</span><br><span class="line">        <span class="keyword">while</span> (counter.get() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            notify.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (notifyListen != <span class="literal">null</span>)&#123;</span><br><span class="line">            notifyListen.notifyListen();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理也很简单，一旦计数器还存在时则会利用 <code>notify</code> 对象进行等待，直到被业务线程唤醒。</p>
<p>同时这里新增了一个通知接口可以自定义实现唤醒后的一些业务逻辑，后文会做演示。</p>
<h2 id="并发测试"><a href="#并发测试" class="headerlink" title="并发测试"></a>并发测试</h2><p>主要就是这两个函数，下面来做一个演示。</p>
<p><img src="https://i.loli.net/2019/04/28/5cc5b7d4a3543.jpg"></p>
<ul>
<li>初始化了三个计数器的并发工具 <code>MultipleThreadCountDownKit</code></li>
<li>创建了三个线程分别执行业务逻辑，完毕后执行 <code>countDown()</code>。</li>
<li>线程 3 休眠了 2s 用于模拟业务耗时。</li>
<li>主线程执行 <code>await()</code> 等待他们三个线程执行完毕。</li>
</ul>
<p><img src="https://i.loli.net/2019/04/28/5cc5b961066e3.jpg"></p>
<p>通过执行结果可以看出主线程会等待最后一个线程完成后才会退出；从而达到了主线程等待其余线程的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MultipleThreadCountDownKit</span> <span class="variable">multipleThreadKit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultipleThreadCountDownKit</span>(<span class="number">3</span>);</span><br><span class="line">multipleThreadKit.setNotify(() -&gt; LOGGER.info(<span class="string">&quot;三个线程完成了任务&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>也可以在初始化的时候指定一个回调接口，用于接收业务线程执行完毕后的通知。</p>
<p><img src="https://i.loli.net/2019/04/28/5cc5b9f111d92.jpg"></p>
<p>当然和在主线程中执行这段逻辑效果是一样的（和执行 <code>await()</code> 方法处于同一个线程）。</p>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>当然我们自己实现的代码没有经过大量生产环境的验证，所以主要的目的还是尝试窥探官方的实现原理。</p>
<p>所以我们现在来看看 <code>juc</code> 下的 <code>CountDownLatch</code> 是如何实现的。</p>
<p><img src="https://i.loli.net/2019/04/28/5cc5c2b5e0cc8.jpg"></p>
<p>通过构造函数会发现有一个 内部类 <code>Sync</code>，他是继承于 <code>AbstractQueuedSynchronizer</code> ；这是 Java 并发包中的基础框架，都可以单独拿来讲了，所以这次重点不是它，今后我们再着重介绍。</p>
<blockquote>
<p>这里就可以把他简单理解为提供了和上文类似的一个计数器及线程通知工具就行了。</p>
</blockquote>
<h2 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h2><p>其实他的核心逻辑和我们自己实现的区别不大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用这个内部类的 <code>releaseShared</code> 方法，我们可以理解为他想要将计数器减一。</p>
<p><img src="https://i.loli.net/2019/04/28/5cc5ccff8cd90.jpg"></p>
<p>看到这里有没有似曾相识的感觉。</p>
<p><img src="https://i.loli.net/2019/04/29/5cc5cede72d06.jpg"></p>
<p>没错，在 <code>JDK1.7</code> 中的 <code>AtomicInteger</code> 自减就是这样实现的（利用 CAS 保证了线程安全）。</p>
<p>只是一旦计数器减为 0 时则会执行 <code>doReleaseShared</code> 唤醒其他的线程。</p>
<p><img src="https://i.loli.net/2019/04/29/5cc5d0253614a.jpg"><br><img src="https://i.loli.net/2019/04/29/5cc5d04480d58.jpg"></p>
<p>这里我们只需要关心红框部分（其他的暂时不用关心，这里涉及到了 AQS 中的队列相关），最终会调用 <code>LockSupport.unpark</code> 来唤醒线程；就相当于上文调用 <code>object.notify()</code>。</p>
<p>所以其实本质上还是相同的。</p>
<h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>其中的 <code>await()</code> 也是借用 <code>Sync</code> 对象的方法实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">//判断计数器是否还未完成    </span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦还存在未完成的线程时，则会调用 <code>doAcquireSharedInterruptibly</code> 进入阻塞状态。</p>
<p><img src="https://i.loli.net/2019/04/29/5cc5d34d2d1c0.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的由于这也是 <code>AQS</code> 中的方法，我们只需要关心红框部分；其实最终就是调用了 <code>LockSupport.park</code> 方法，也就相当于执行了 <code>object.wait()</code> 。</p>
<ul>
<li>所有的业务线程执行完毕后会在计数器减为 0 时调用 <code>LockSupport.unpark</code> 来唤醒线程。</li>
<li>等待线程一旦计数器 &gt; 0 时则会利用 <code>LockSupport.park</code> 来等待唤醒。</li>
</ul>
<p>这样整个流程也就串起来了，它的使用方法也和上文的类似。</p>
<p><img src="https://i.loli.net/2019/04/29/5cc5d3d9cd0fe.jpg"></p>
<p>就不做过多介绍了。</p>
<h1 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h1><p>同样的来看一个实际案例。</p>
<p>在上一篇<a href="https://crossoverjie.top/2019/04/16/framework-design/sharding-db/">《一次分表踩坑实践的探讨》</a>提到了对于全表扫描的情况下，需要利用多线程来提高查询效率。</p>
<p>比如我们这里分为了 64 张表，计划利用 8 个线程来分别处理这些表的数据，伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">64</span>);</span><br><span class="line"><span class="type">ConcurrentHashMap</span> <span class="variable">total</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();</span><br><span class="line"><span class="keyword">for</span>(Integer i=<span class="number">0</span>;i&lt;=<span class="number">63</span>;i++)&#123;</span><br><span class="line">	executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="type">List</span> <span class="variable">value</span> <span class="operator">=</span> queryTable(i);</span><br><span class="line">			total.put(value,NULL);</span><br><span class="line">			count.countDown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;) ;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count.await();</span><br><span class="line">System.out.println(<span class="string">&quot;查询完毕&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样就可以实现所有数据都查询完毕后再做统一汇总；代码挺简单，也好理解（当然也可以使用线程池的 API）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>CountDownLatch</code> 算是 <code>juc</code> 中一个高频使用的工具，学会和理解他的使用会帮助我们更容易编写并发应用。</p>
<p>文中涉及到的源码：</p>
<p><a href="https://github.com/crossoverJie/JCSprout/blob/master/src/main/java/com/crossoverjie/concurrent/communication/MultipleThreadCountDownKit.java">https://github.com/crossoverJie/JCSprout/blob/master/src/main/java/com/crossoverjie/concurrent/communication/MultipleThreadCountDownKit.java</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>concurrent</tag>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title>『并发包入坑指北』之阻塞队列</title>
    <url>/2019/04/09/concurrent/ArrayBlockingQueue/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/04/29/5cc6544d1fa9c.jpeg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>较长一段时间以来我都发现不少开发者对 jdk 中的 <code>J.U.C</code>（java.util.concurrent）也就是 Java 并发包的使用甚少，更别谈对它的理解了；但这却也是我们进阶的必备关卡。</p>
<p>之前或多或少也分享过相关内容，但都不成体系；于是便想整理一套与并发包相关的系列文章。</p>
<p>其中的内容主要包含以下几个部分：</p>
<ul>
<li>根据定义自己实现一个并发工具。</li>
<li>JDK 的标准实现。</li>
<li>实践案例。</li>
</ul>
<span id="more"></span>

<p>基于这三点我相信大家对这部分内容不至于一问三不知。</p>
<p>既然开了一个新坑，就不想做的太差；所以我打算将这个列表下的大部分类都讲到。</p>
<p><img src="https://i.loli.net/2019/04/29/5cc5dc4cc3a13.jpg"></p>
<p>所以本次重点讨论 <code>ArrayBlockingQueue</code>。</p>
<h1 id="自己实现"><a href="#自己实现" class="headerlink" title="自己实现"></a>自己实现</h1><p>在自己实现之前先搞清楚阻塞队列的几个特点：</p>
<ul>
<li>基本队列特性：先进先出。</li>
<li>写入队列空间不可用时会阻塞。</li>
<li>获取队列数据时当队列为空时将阻塞。</li>
</ul>
<p>实现队列的方式多种，总的来说就是数组和链表；其实我们只需要搞清楚其中一个即可，不同的特性主要表现为数组和链表的区别。</p>
<p>这里的 <code>ArrayBlockingQueue</code> 看名字很明显是由数组实现。</p>
<p>我们先根据它这三个特性尝试自己实现试试。</p>
<h2 id="初始化队列"><a href="#初始化队列" class="headerlink" title="初始化队列"></a>初始化队列</h2><p>我这里自定义了一个类：<code>ArrayQueue</code>，它的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    items = <span class="keyword">new</span> <span class="title class_">Object</span>[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显这里的 <code>items</code> 就是存放数据的数组；在初始化时需要根据大小创建数组。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bec756ce4.jpg"></p>
<h2 id="写入队列"><a href="#写入队列" class="headerlink" title="写入队列"></a>写入队列</h2><p>写入队列比较简单，只需要依次把数据存放到这个数组中即可，如下图：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bec7af131.jpg"></p>
<p>但还是有几个需要注意的点：</p>
<ul>
<li>队列满的时候，写入的线程需要被阻塞。</li>
<li>写入过队列的数量大于队列大小时需要从第一个下标开始写。</li>
</ul>
<p>先看第一个<code>队列满的时候，写入的线程需要被阻塞</code>，先来考虑下如何才能使一个线程被<strong>阻塞</strong>，看起来的表象线程卡住啥事也做不了。</p>
<p>有几种方案可以实现这个效果:</p>
<ul>
<li><code>Thread.sleep(timeout)</code>线程休眠。</li>
<li><code>object.wait()</code> 让线程进入 <code>waiting</code> 状态。</li>
</ul>
<blockquote>
<p>当然还有一些 <code>join、LockSupport.part</code> 等不在本次的讨论范围。</p>
</blockquote>
<p>阻塞队列还有一个非常重要的特性是：当队列空间可用时（取出队列），写入线程需要被唤醒让数据可以写入进去。</p>
<p>所以很明显<code>Thread.sleep(timeout)</code>不合适，它在到达超时时间之后便会继续运行；达不到<strong>空间可用时</strong>才唤醒继续运行这个特点。</p>
<p>其实这样的一个特点很容易让我们想到 Java 的等待通知机制来实现线程间通信；更多线程见通信的方案可以参考这里：<a href="https://crossoverjie.top/2018/03/16/java-senior/thread-communication/#%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6">深入理解线程通信</a></p>
<p>所以我这里的做法是，一旦队列满时就将写入线程调用 <code>object.wait()</code> 进入 <code>waiting</code> 状态，直到空间可用时再进行唤醒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列满时的阻塞锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Object</span> <span class="variable">full</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列空时的阻塞锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Object</span> <span class="variable">empty</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/04/29/5cc65481da328.jpg"></p>
<p>所以这里声明了两个对象用于队列满、空情况下的互相通知作用。</p>
<p>在写入数据成功后需要使用 <code>empty.notify()</code>，这样的目的是当获取队列为空时，一旦写入数据成功就可以把消费队列的线程唤醒。</p>
<blockquote>
<p>这里的 wait 和 notify 操作都需要对各自的对象使用 <code>synchronized</code> 方法块，这是因为 wait 和 notify 都需要获取到各自的锁。</p>
</blockquote>
<h2 id="消费队列"><a href="#消费队列" class="headerlink" title="消费队列"></a>消费队列</h2><p>上文也提到了：当队列为空时，获取队列的线程需要被阻塞，直到队列中有数据时才被唤醒。</p>
<p><img src="https://i.loli.net/2019/04/29/5cc654c0a8f9d.jpg"></p>
<p>代码和写入的非常类似，也很好理解；只是这里的等待、唤醒恰好是相反的，通过下面这张图可以很好理解：</p>
<p><img src="https://i.loli.net/2019/04/29/5cc654e141818.jpg"></p>
<p>总的来说就是：</p>
<ul>
<li>写入队列满时会阻塞直到获取线程消费了队列数据后唤醒<strong>写入线程</strong>。</li>
<li>消费队列空时会阻塞直到写入线程写入了队列数据后唤醒<strong>消费线程</strong>。</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>先来一个基本的测试：单线程的写入和消费。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bec8576c4.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">123</span><br><span class="line">1234</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>通过结果来看没什么问题。</p>
<hr>
<p>当写入的数据超过队列的大小时，就只能消费之后才能接着写入。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bec927a3e.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019-04-09 16:24:41.040 [Thread-0] INFO  c.c.concurrent.ArrayQueueTest - [Thread-0]123</span><br><span class="line">2019-04-09 16:24:41.040 [main] INFO  c.c.concurrent.ArrayQueueTest - size=3</span><br><span class="line">2019-04-09 16:24:41.047 [main] INFO  c.c.concurrent.ArrayQueueTest - 1234</span><br><span class="line">2019-04-09 16:24:41.048 [main] INFO  c.c.concurrent.ArrayQueueTest - 12345</span><br><span class="line">2019-04-09 16:24:41.048 [main] INFO  c.c.concurrent.ArrayQueueTest - 123456</span><br></pre></td></tr></table></figure>

<p>从运行结果也能看出只有当消费数据后才能接着往队列里写入数据。</p>
<hr>
<p><img src="https://i.loli.net/2019/05/08/5cd1bec9ce053.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1becf84deb.jpg"></p>
<p>而当没有消费时，再往队列里写数据则会导致写入线程被阻塞。</p>
<h3 id="并发测试"><a href="#并发测试" class="headerlink" title="并发测试"></a>并发测试</h3><p><img src="https://i.loli.net/2019/05/08/5cd1bed02da8a.jpg"></p>
<p>三个线程并发写入300条数据，其中一个线程消费一条。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=====0</span><br><span class="line">299</span><br></pre></td></tr></table></figure>

<p>最终的队列大小为 299，可见线程也是安全的。</p>
<blockquote>
<p>由于不管是写入还是获取方法里的操作都需要获取锁才能操作，所以整个队列是线程安全的。</p>
</blockquote>
<h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><p>下面来看看 JDK 标准的 <code>ArrayBlockingQueue</code> 的实现，有了上面的基础会更好理解。</p>
<h2 id="初始化队列-1"><a href="#初始化队列-1" class="headerlink" title="初始化队列"></a>初始化队列</h2><p><img src="https://i.loli.net/2019/05/08/5cd1bed11c683.jpg"></p>
<p>看似要复杂些，但其实逐步拆分后也很好理解：</p>
<p>第一步其实和我们自己写的一样，初始化一个队列大小的数组。</p>
<p>第二步初始化了一个重入锁，这里其实就和我们之前使用的 <code>synchronized</code> 作用一致的；</p>
<p>只是这里在初始化重入锁的时候默认是<code>非公平锁</code>，当然也可以指定为 <code>true</code> 使用公平锁；这样就会按照队列的顺序进行写入和消费。</p>
<blockquote>
<p>更多关于 <code>ReentrantLock</code> 的使用和原理请参考这里：<a href="https://crossoverjie.top/2018/01/25/ReentrantLock/">ReentrantLock 实现原理</a></p>
</blockquote>
<p>三四两步则是创建了 <code>notEmpty notFull</code> 这两个条件，他的作用于用法和之前使用的 <code>object.wait/notify</code> 类似。</p>
<p>这就是整个初始化的内容，其实和我们自己实现的非常类似。</p>
<h2 id="写入队列-1"><a href="#写入队列-1" class="headerlink" title="写入队列"></a>写入队列</h2><p><img src="https://i.loli.net/2019/05/08/5cd1bed1c069c.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1bed2c4cac.jpg"></p>
<p>其实会发现阻塞写入的原理都是差不多的，只是这里使用的是 Lock 来显式获取和释放锁。</p>
<p>同时其中的 <code>notFull.await();notEmpty.signal();</code> 和我们之前使用的 <code>object.wait/notify</code> 的用法和作用也是一样的。</p>
<p>当然它还是实现了超时阻塞的 <code>API</code>。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beda6d368.jpg"></p>
<p>也是比较简单，使用了一个具有超时时间的等待方法。 </p>
<h2 id="消费队列-1"><a href="#消费队列-1" class="headerlink" title="消费队列"></a>消费队列</h2><p>再看消费队列：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bedb08e53.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1bedba07a7.jpg"></p>
<p>也是差不多的，一看就懂。</p>
<p>而其中的超时 API 也是使用了 <code>notEmpty.awaitNanos(nanos)</code> 来实现超时返回的，就不具体说了。</p>
<h1 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h1><p>说了这么多，来看一个队列的实际案例吧。</p>
<p>背景是这样的：</p>
<blockquote>
<p>有一个定时任务会按照一定的间隔时间从数据库中读取一批数据，需要对这些数据做校验同时调用一个远程接口。</p>
</blockquote>
<p>简单的做法就是由这个定时任务的线程去完成读取数据、消息校验、调用接口等整个全流程；但这样会有一个问题：</p>
<p>假设调用外部接口出现了异常、网络不稳导致耗时增加就会造成整个任务的效率降低，因为他都是串行会互相影响。</p>
<p>所以我们改进了方案：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bedc34bcb.jpg"></p>
<p>其实就是一个典型的生产者消费者模型：</p>
<ul>
<li>生产线程从数据库中读取消息丢到队列里。</li>
<li>消费线程从队列里获取数据做业务逻辑。</li>
</ul>
<p>这样两个线程就可以通过这个队列来进行解耦，互相不影响，同时这个队列也能起到缓冲的作用。</p>
<p>但在使用过程中也有一些小细节值得注意。</p>
<p>因为这个外部接口是支持批量执行的，所以在消费线程取出数据后会在内存中做一个累加，一旦达到阈值或者是累计了一个时间段便将这批累计的数据处理掉。</p>
<p>但由于开发者的大意，在消费的时候使用的是 <code>queue.take()</code> 这个阻塞的 API；正常运行没啥问题。</p>
<p>可一旦原始的数据源，也就是 DB 中没数据了，导致队列里的数据也被消费完后这个消费线程便会被阻塞。</p>
<p>这样上一轮积累在内存中的数据便一直没机会使用，直到数据源又有数据了，一旦中间间隔较长时便可能会导致严重的业务异常。</p>
<p>所以我们最好是使用 <code>queue.poll(timeout)</code> 这样带超时时间的 api，除非业务上有明确的要求需要阻塞。</p>
<p>这个习惯同样适用于其他场景，比如调用 http、rpc 接口等都需要设置合理的超时时间。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于 <code>ArrayBlockingQueue</code> 的相关分享便到此结束，接着会继续更新其他并发容器及并发工具。</p>
<p>对本文有任何相关问题都可以留言讨论。</p>
<p>本文涉及到的所有源码：</p>
<p><a href="https://github.com/crossoverJie/JCSprout/blob/master/src/main/java/com/crossoverjie/concurrent/ArrayQueue.java">https://github.com/crossoverJie/JCSprout/blob/master/src/main/java/com/crossoverjie/concurrent/ArrayQueue.java</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>concurrent</tag>
        <tag>ArrayBlockingQueue</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池没你想的那么简单</title>
    <url>/2019/05/20/concurrent/threadpool-01/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/20/5ce2427967df757341.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原以为线程池还挺简单的（平时常用，也分析过原理），这次是想自己动手写一个线程池来更加深入的了解它；但在动手写的过程中落地到细节时发现并没想的那么容易。结合源码对比后确实不得不佩服 <code>Doug Lea</code> 。</p>
<p>我觉得大部分人直接去看 <code>java.util.concurrent.ThreadPoolExecutor</code> 的源码时都是看一个大概，因为其中涉及到了许多细节处理，还有部分 <code>AQS</code> 的内容，所以想要理清楚具体细节并不是那么容易。</p>
<span id="more"></span>

<p>与其挨个分析源码不如自己实现一个简版，当然简版并不意味着功能缺失，需要保证核心逻辑一致。</p>
<p>所以也是本篇文章的目的：</p>
<blockquote>
<p>自己动手写一个五脏俱全的线程池，同时会了解到线程池的工作原理，以及如何在工作中合理的利用线程池。</p>
</blockquote>
<p>再开始之前建议对线程池不是很熟悉的朋友看看这几篇：</p>
<p>这里我截取了部分内容，也许可以埋个伏笔（坑）。</p>
<p><img src="https://i.loli.net/2019/05/20/5ce2427a131d077786.jpg"></p>
<hr>
<p><img src="https://i.loli.net/2019/05/20/5ce2427a82e4195813.jpg"></p>
<p>具体请看这两个链接。</p>
<ul>
<li><a href="https://crossoverjie.top/2018/07/29/java-senior/ThreadPool/">如何优雅的使用和理解线程池</a></li>
<li><a href="https://crossoverjie.top/2019/03/26/troubleshoot/thread-gone2/">线程池中你不容错过的一些细节</a></li>
</ul>
<p>由于篇幅限制，本次可能会分为上下两篇。</p>
<h1 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h1><p>现在进入正题，新建了一个 <code>CustomThreadPool</code> 类,它的工作原理如下：</p>
<p><img src="https://i.loli.net/2019/05/20/5ce2427ae4d0d34961.jpg"></p>
<p>简单来说就是往线程池里边丢任务，丢的任务会缓冲到队列里；线程池里存储的其实就是一个个的 <code>Thread</code> ，他们会一直不停的从刚才缓冲的队列里获取任务执行。</p>
<p>流程还是挺简单。</p>
<p>先来看看我们这个自创的线程池的效果如何吧：<br><img src="https://i.loli.net/2019/05/20/5ce2427b4b8ac24777.jpg"><br><img src="https://i.loli.net/2019/05/20/5ce2427dcfd3982345.jpg"></p>
<p>初始化了一个核心为3、最大线程数为5、队列大小为 4 的线程池。</p>
<p>先往其中丢了 10 个任务，由于阻塞队列的大小为 4 ，最大线程数为 5 ，所以由于队列里缓冲不了最终会创建 5 个线程（上限）。</p>
<p>过段时间没有任务提交后（<code>sleep</code>）则会自动缩容到三个线程（保证不会小于核心线程数）。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>来看看具体是如何实现的。</p>
<p>下面则是这个线程池的构造函数：</p>
<p><img src="https://i.loli.net/2019/05/20/5ce2427e4bd1e73907.jpg"></p>
<p>会有以下几个核心参数：</p>
<ul>
<li><code>miniSize</code> 最小线程数，等效于 <code>ThreadPool</code> 中的核心线程数。</li>
<li><code>maxSize</code> 最大线程数。</li>
<li><code>keepAliveTime</code> 线程保活时间。</li>
<li><code>workQueue</code> 阻塞队列。</li>
<li><code>notify</code> 通知接口。</li>
</ul>
<p>大致上都和 <code>ThreadPool</code> 中的参数相同，并且作用也是类似的。</p>
<p>需要注意的是其中初始化了一个 <code>workers</code> 成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;Worker&gt; workers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CustomThreadPool</span><span class="params">(<span class="type">int</span> miniSize, <span class="type">int</span> maxSize, <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                        TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, Notify notify)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    workers = <span class="keyword">new</span> <span class="title class_">ConcurrentHashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>workers</code> 是最终存放线程池中运行的线程，在 <code>j.u.c</code> 源码中是一个 <code>HashSet</code> 所以对他所有的操作都是需要加锁。</p>
<p>我这里为了简便起见就自己定义了一个线程安全的 <code>Set</code> 称为 <code>ConcurrentHashSet</code>。</p>
<p><img src="https://i.loli.net/2019/05/20/5ce2427ea9db544486.jpg"></p>
<p>其实原理也非常简单，和 <code>HashSet</code> 类似也是借助于 <code>HashMap</code> 来存放数据，利用其 <code>key</code> 不可重复的特性来实现 <code>set</code> ，只是这里的 <code>HashMap</code> 是用并发安全的 <code>ConcurrentHashMap</code> 来实现的。</p>
<p>这样就能保证对它的写入、删除都是线程安全的。</p>
<p>不过由于 <code>ConcurrentHashMap</code> 的 <code>size()</code> 函数并不准确，所以我这里单独利用了一个 <code>AtomicInteger</code> 来统计容器大小。</p>
<h2 id="创建核心线程"><a href="#创建核心线程" class="headerlink" title="创建核心线程"></a>创建核心线程</h2><p>往线程池中丢一个任务的时候其实要做的事情还蛮多的，最重要的事情莫过于创建线程存放到线程池中了。</p>
<p>当然我们不能无限制的创建线程，不然拿线程池来就没任何意义了。于是 <code>miniSize maxSize</code> 这两个参数就有了它的意义。</p>
<p>但这两个参数再哪一步的时候才起到作用呢？这就是首先需要明确的。</p>
<p><img src="https://i.loli.net/2019/05/20/5ce242859d06737555.jpg"></p>
<p>从这个流程图可以看出第一步是需要判断是否大于核心线程数，如果没有则创建。</p>
<p><img src="https://i.loli.net/2019/05/20/5ce2427f709a888882.jpg"><br><img src="https://i.loli.net/2019/05/20/5ce24284cece370628.jpg"></p>
<p>结合代码可以发现在执行任务的时候会判断是否大于核心线程数，从而创建线程。</p>
<blockquote>
<p><code>worker.startTask()</code> 执行任务部分放到后面分析。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/20/5ce242851866045125.jpg"></p>
<p>这里的 <code>miniSize</code> 由于会在多线程场景下使用，所以也用 <code>volatile</code> 关键字来保证可见性。</p>
<h2 id="队列缓冲"><a href="#队列缓冲" class="headerlink" title="队列缓冲"></a>队列缓冲</h2><p><img src="https://i.loli.net/2019/05/20/5ce242859d06737555.jpg"></p>
<p>结合上面的流程图，第二步自然是要判断队列是否可以存放任务（是否已满）。</p>
<p><img src="https://i.loli.net/2019/05/20/5ce242860ea8762429.jpg"></p>
<p>优先会往队列里存放。</p>
<h2 id="上至封顶"><a href="#上至封顶" class="headerlink" title="上至封顶"></a>上至封顶</h2><p><img src="https://i.loli.net/2019/05/20/5ce2428663ce360228.jpg"></p>
<p>一旦写入失败则会判断当前线程池的大小是否大于最大线程数，如果没有则继续创建线程执行。</p>
<p>不然则执行会尝试阻塞写入队列（<code>j.u.c</code> 会在这里执行拒绝策略）</p>
<p>以上的步骤和刚才那张流程图是一样的，这样大家是否有看出什么坑嘛？</p>
<h2 id="时刻小心"><a href="#时刻小心" class="headerlink" title="时刻小心"></a>时刻小心</h2><p><img src="https://i.loli.net/2019/05/20/5ce24286ec64d97683.jpg"></p>
<p>从上面流程图的这两步可以看出会直接<strong>创建新的线程</strong>。</p>
<p>这个过程相对于中间<strong>直接写入阻塞队列</strong>的开销是非常大的，主要有以下两个原因：</p>
<ul>
<li>创建线程会加锁，虽说最终用的是 ConcurrentHashMap 的写入函数，但依然存在加锁的可能。</li>
<li>会创建新的线程，创建线程还需要调用操作系统的 API 开销较大。</li>
</ul>
<blockquote>
<p>所以理想情况下我们应该避免这两步，尽量让丢入线程池中的任务进入阻塞队列中。</p>
</blockquote>
<h1 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h1><p>任务是添加进来了，那是如何执行的？</p>
<p>在创建任务的时候提到过 <code>worker.startTask()</code> 函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加任务，需要加锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorker</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(runnable, <span class="literal">true</span>);</span><br><span class="line">    worker.startTask();</span><br><span class="line">    workers.add(worker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是在创建线程执行任务的时候会创建 <code>Worker</code> 对象，利用它的 <code>startTask()</code> 方法来执行任务。</p>
<p>所以先来看看 <code>Worker</code> 对象是长啥样的：</p>
<p><img src="https://i.loli.net/2019/05/20/5ce2428758e9d49713.jpg"></p>
<p>其实他本身也是一个线程，将接收到需要执行的任务存放到成员变量 <code>task</code> 处。</p>
<p>而其中最为关键的则是执行任务 <code>worker.startTask()</code> 这一步骤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startTask</span><span class="params">()</span> &#123;</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是运行了 <code>worker</code> 线程自己，下面来看 <code>run</code> 方法。</p>
<p><img src="https://i.loli.net/2019/05/20/5ce24287cc0b154186.jpg"></p>
<ul>
<li>第一步是将创建线程时传过来的任务执行（<code>task.run</code>）,接着会一直不停的从队列里获取任务执行，直到获取不到新任务了。</li>
<li>任务执行完毕后将内置的计数器 -1 ，方便后面任务全部执行完毕进行通知。</li>
<li>worker 线程获取不到任务后退出，需要将自己从线程池中释放掉（<code>workers.remove(this)</code>）。</li>
</ul>
<h2 id="从队列里获取任务"><a href="#从队列里获取任务" class="headerlink" title="从队列里获取任务"></a>从队列里获取任务</h2><p>其实 <code>getTask</code> 也是非常关键的一个方法，它封装了从队列中获取任务，同时对不需要保活的线程进行回收。</p>
<p><img src="https://i.loli.net/2019/05/20/5ce242885bebb69642.jpg"></p>
<p>很明显，核心作用就是从队列里获取任务；但有两个地方需要注意：</p>
<ul>
<li>当线程数超过核心线程数时，在获取任务的时候需要通过保活时间从队列里获取任务；一旦获取不到任务则队列肯定是空的，这样返回 <code>null</code> 之后在上文的 <code>run()</code> 中就会退出这个线程；从而达到了回收线程的目的，也就是我们之前演示的效果<br><img src="https://i.loli.net/2019/05/20/5ce24288ddeda75126.jpg"></li>
<li>这里需要加锁，加锁的原因是这里肯定会出现并发情况，不加锁会导致 <code>workers.size() &gt; miniSize</code> 条件多次执行，从而导致线程被全部回收完毕。</li>
</ul>
<h1 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h1><p>最后来谈谈线程关闭的事；</p>
<p><img src="https://i.loli.net/2019/05/20/5ce2428f46e6577159.jpg"></p>
<p>还是以刚才那段测试代码为例,如果提交任务后我们没有关闭线程，会发现即便是任务执行完毕后程序也不会退出。</p>
<p>从刚才的源码里其实也很容易看出来，不退出的原因是 <code>Worker</code> 线程一定还会一直阻塞在 <code>task = workQueue.take();</code> 处，即便是线程缩容了也不会小于核心线程数。</p>
<p>通过堆栈也能证明：</p>
<p><img src="https://i.loli.net/2019/05/20/5ce2428fc329642616.jpg"></p>
<p>恰好剩下三个线程阻塞于此处。</p>
<p>而关闭线程通常又有以下两种：</p>
<ul>
<li>立即关闭：执行关闭方法后不管现在线程池的运行状况，直接一刀切全部停掉，这样会导致任务丢失。</li>
<li>不接受新的任务，同时等待现有任务执行完毕后退出线程池。</li>
</ul>
<h2 id="立即关闭"><a href="#立即关闭" class="headerlink" title="立即关闭"></a>立即关闭</h2><p>我们先来看第一种<code>立即关闭</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 立即关闭线程池，会造成任务丢失</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutDownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    isShutDown.set(<span class="literal">true</span>);</span><br><span class="line">    tryClose(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isTry true 尝试关闭      --&gt; 会等待所有任务执行完毕</span></span><br><span class="line"><span class="comment"> *              false 立即关闭线程池--&gt; 任务有丢失的可能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tryClose</span><span class="params">(<span class="type">boolean</span> isTry)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isTry) &#123;</span><br><span class="line">        closeAllTask();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutDown.get() &amp;&amp; totalTask.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            closeAllTask();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭所有任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">closeAllTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">        <span class="comment">//LOGGER.info(&quot;开始关闭&quot;);</span></span><br><span class="line">        worker.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很容易看出，最终就是遍历线程池里所有的 <code>worker</code> 线程挨个执行他们的中断函数。</p>
<p>我们来测试一下：</p>
<p><img src="https://i.loli.net/2019/05/20/5ce242902d08769330.jpg"><br><img src="https://i.loli.net/2019/05/20/5ce24290912fa21399.jpg"></p>
<p>可以发现后面丢进去的三个任务其实是没有被执行的。</p>
<h2 id="完事后关闭"><a href="#完事后关闭" class="headerlink" title="完事后关闭"></a>完事后关闭</h2><p>而<strong>正常关闭</strong>则不一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务执行完毕后关闭线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    isShutDown.set(<span class="literal">true</span>);</span><br><span class="line">    tryClose(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/05/20/5ce2429114e7d55267.jpg"></p>
<p>他会在这里多了一个判断，需要所有任务都执行完毕之后才会去中断线程。</p>
<p>同时在线程需要回收时都会尝试关闭线程：<br><img src="https://i.loli.net/2019/05/20/5ce24292a772464789.jpg"><br><img src="https://i.loli.net/2019/05/20/5ce24292dc72e29251.jpg"></p>
<hr>
<p>来看看实际效果：</p>
<p><img src="https://i.loli.net/2019/05/20/5ce24292466a178764.jpg"></p>
<h1 id="回收线程"><a href="#回收线程" class="headerlink" title="回收线程"></a>回收线程</h1><p>上文或多或少提到了线程回收的事情，其实总结就是以下两点：</p>
<ul>
<li>一旦执行了 <code>shutdown/shutdownNow</code> 方法都会将线程池的状态置为关闭状态，这样只要 <code>worker</code> 线程尝试从队列里获取任务时就会直接返回空，导致 <code>worker</code> 线程被回收。<br><img src="https://i.loli.net/2019/05/20/5ce24292a772464789.jpg"></li>
<li>一旦线程池大小超过了核心线程数就会使用保活时间来从队列里获取任务，所以一旦获取不到返回 <code>null</code> 时就会触发回收。<br><img src="https://i.loli.net/2019/05/20/5ce24292dc72e29251.jpg"></li>
</ul>
<p>但如果我们的队列足够大，导致线程数都不会超过核心线程数，这样是不会触发回收的。</p>
<p><img src="https://i.loli.net/2019/05/20/5ce24298787c153588.jpg"></p>
<p>比如这里我将队列大小调为 10 ，这样任务就会累计在队列里，不会创建五个 <code>worker</code> 线程。</p>
<p>所以一直都是 <code>Thread-1~3</code> 这三个线程在反复调度任务。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次实现了线程池里大部分核心功能，我相信只要看完并动手敲一遍一定会对线程池有不一样的理解。</p>
<p>结合目前的内容来总结下：</p>
<ul>
<li>线程池、队列大小要设计的合理，尽量的让任务从队列中获取执行。</li>
<li>慎用 <code>shutdownNow()</code> 方法关闭线程池，会导致任务丢失（除非业务允许）。</li>
<li>如果任务多，线程执行时间短可以调大 <code>keepalive</code> 值，使得线程尽量不被回收从而可以复用线程。</li>
</ul>
<p>同时下次会分享一些线程池的新特性，如：</p>
<ul>
<li>执行带有返回值的线程。</li>
<li>异常处理怎么办？</li>
<li>所有任务执行完怎么通知我？</li>
</ul>
<p>本文所有源码：</p>
<p><a href="https://github.com/crossoverJie/JCSprout/blob/master/src/main/java/com/crossoverjie/concurrent/CustomThreadPool.java">https://github.com/crossoverJie/JCSprout/blob/master/src/main/java/com/crossoverjie/concurrent/CustomThreadPool.java</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>concurrent</tag>
        <tag>ThreadPool</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池没你想的那么简单（续）</title>
    <url>/2019/06/06/concurrent/threadpool-02/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/06/06/5cf7fff98dd9f45508.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间写过一篇<a href="https://crossoverjie.top/2019/05/20/concurrent/threadpool-01/">《线程池没你想的那么简单》</a>，和大家一起撸了一个基本的线程池，具备：</p>
<ul>
<li>线程池基本调度功能。</li>
<li>线程池自动扩容缩容。</li>
<li>队列缓存线程。</li>
<li>关闭线程池。</li>
</ul>
<span id="more"></span>

<p>这些功能，最后也留下了三个待实现的 <code>features</code> 。</p>
<ul>
<li>执行带有返回值的线程。</li>
<li>异常处理怎么办？</li>
<li>所有任务执行完怎么通知我？</li>
</ul>
<p>这次就实现这三个特性来看看 <code>j.u.c</code> 中的线程池是如何实现这些需求的。</p>
<blockquote>
<p>再看本文之前，强烈建议先查看上文<a href="https://crossoverjie.top/2019/05/20/concurrent/threadpool-01/">《线程池没你想的那么简单》</a></p>
</blockquote>
<h1 id="任务完成后的通知"><a href="#任务完成后的通知" class="headerlink" title="任务完成后的通知"></a>任务完成后的通知</h1><p>大家在用线程池的时候或多或少都会有这样的需求：</p>
<p>线程池中的任务执行完毕后再通知主线程做其他事情，比如一批任务都执行完毕后再执行下一波任务等等。</p>
<p><img src="https://i.loli.net/2019/06/06/5cf7fffa58a8081569.jpg"></p>
<p>以我们之前的代码为例：</p>
<blockquote>
<p>总共往线程池中提交了 13 个任务，直到他们都执行完毕后再打印 “任务执行完毕” 这个日志。</p>
</blockquote>
<p>执行结果如下：</p>
<p><img src="https://i.loli.net/2019/06/06/5cf7fffb21f8d45495.jpg"></p>
<p>为了简单的达到这个效果，我们可以在初始化线程池的时候传入一个接口的实现，这个接口就是用于任务完成之后的回调。</p>
<p><img src="https://i.loli.net/2019/06/06/5cf7fffbe663629607.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Notify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyListen</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是线程池的构造函数以及接口的定义。</p>
<p>所以想要实现这个功能的关键是在何时回调这个接口？</p>
<p>仔细想想其实也简单：只要我们记录提交到线程池中的任务及完成的数量，他们两者的差为 0 时就认为线程池中的任务已执行完毕；这时便可回调这个接口。</p>
<p>所以在往线程池中写入任务时我们需要记录任务数量：</p>
<p><img src="https://i.loli.net/2019/06/06/5cf7fffc8161b82626.jpg"></p>
<p>为了并发安全的考虑，这里的计数器采用了原子的 <code>AtomicInteger</code> 。</p>
<hr>
<p><img src="https://i.loli.net/2019/06/06/5cf7fffd0634612268.jpg"></p>
<p>而在任务执行完毕后就将计数器 -1 ，一旦为 0 时则任务任务全部执行完毕；这时便可回调我们自定义的接口完成通知。</p>
<hr>
<h2 id="JDK-的实现"><a href="#JDK-的实现" class="headerlink" title="JDK 的实现"></a>JDK 的实现</h2><p>这样的需求在 jdk 中的 <code>ThreadPoolExecutor</code> 中也有相关的 <code>API</code> ，只是用法不太一样，但本质原理都大同小异。</p>
<p>我们使用 <code>ThreadPoolExecutor</code> 的常规关闭流程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">executorService.shutdown();</span><br><span class="line"><span class="keyword">while</span> (!executorService.awaitTermination(<span class="number">100</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;thread running&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程提交完毕后执行 <code>shutdown()</code> 关闭线程池，接着循环调用 <code>awaitTermination()</code> 方法，一旦任务全部执行完毕后则会返回 <code>true</code> 从而退出循环。</p>
<p>这两个方法的目的和原理如下：</p>
<ul>
<li>执行 <code>shutdown()</code> 后会将线程池的状态置为关闭状态，这时将会停止接收新的任务同时会等待队列中的任务全部执行完毕后才真正关闭线程池。</li>
<li><code>awaitTermination</code> 会阻塞直到线程池所有任务执行完毕或者超时时间已到。</li>
</ul>
<p>为什么要两个 <code>api</code> 结合一起使用呢？</p>
<p>主要还在最终的目的是：所有线程执行完毕后再做某件事情，也就是在线程执行完毕之前其实主线程是需要<strong>被阻塞</strong>的。</p>
<p><code>shutdown()</code> 执行后并不会阻塞，会立即返回，所有才需要后续用循环不停的调用 <code>awaitTermination()</code>，因为这个 api 才会阻塞线程。</p>
<p>其实我们查看源码会发现，<code>ThreadPoolExecutor</code> 中的阻塞依然也是等待通知机制的运用，只不过用的是 <code>LockSupport</code> 的 <code>API</code> 而已。</p>
<h1 id="带有返回值的线程"><a href="#带有返回值的线程" class="headerlink" title="带有返回值的线程"></a>带有返回值的线程</h1><p>接下来是带有返回值的线程，这个需求也非常常见；比如需要线程异步计算某些数据然后得到结果最终汇总使用。</p>
<p>先来看看如何使用（和 jdk 的类似）：</p>
<p>首先任务是不能实现 <code>Runnable</code> 接口了，毕竟他的 <code>run()</code> 函数是没有返回值的；所以我们改实现一个 <code>Callable</code> 的接口：</p>
<p><img src="https://i.loli.net/2019/06/06/5cf7fffd755d053986.jpg"></p>
<p>这个接口有一个返回值。</p>
<p>同时在提交任务时也稍作改动：</p>
<p><img src="https://i.loli.net/2019/06/06/5cf7fffe1162589733.jpg"></p>
<p>首先是执行任务的函数由 <code>execute()</code> 换为了 <code>submit()</code>，同时他会返回一个返回值 <code>Future</code>，通过它便可拿到线程执行的结果。</p>
<p>最后通过第二步将所有执行结果打印出来：</p>
<p><img src="https://i.loli.net/2019/06/06/5cf7ffff5b48143266.jpg"></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>再看具体实现之前先来思考下这样的功能如何实现？</p>
<ul>
<li>首先受限于 <code>jdk</code> 的线程 <code>api</code> 的规范，要执行一个线程不管是实现接口还是继承类，最终都是执行的 <code>run()</code> 函数。</li>
<li>所以我们想要一个线程有返回值无非只能是在执行 <code>run()</code> 函数时去调用一个有返回值的方法，再将这个返回值存放起来用于后续使用。</li>
</ul>
<p>比如我们这里新建了一个 <code>Callable&lt;T&gt;</code> 的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">call</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的 <code>call</code> 函数就是刚才提到的有返回值的方法，所以我们应当在线程的 run() 函数中去调用它。</p>
<p>接着还会有一个 <code>Future</code> 的接口，他的主要作用是获取线程的返回值，也就是 <code>再将这个返回值存放起来用于后续使用</code> 这里提到的<strong>后续使用</strong>。</p>
<p>既然有了接口那自然就得有它的实现 <code>FutureTask</code>，它实现了 <code>Future</code> 接口用于后续获取返回值。</p>
<p>同时实现了 <code>Runnable</code> 接口会把自己变为一个线程。</p>
<p><img src="https://i.loli.net/2019/06/06/5cf7ffffe7dac41090.jpg"></p>
<p>所以在它的 <code>run()</code> 函数中会调用刚才提到的具有返回值的 <code>call()</code> 函数。</p>
<hr>
<p>再次结合 <code>submit()</code> 提交任务和 <code>get()</code> 获取返回值的源码来看会更加理解这其中的门道。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有返回值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; callable)</span> &#123;</span><br><span class="line">    FutureTask&lt;T&gt; future = <span class="keyword">new</span> <span class="title class_">FutureTask</span>(callable);</span><br><span class="line">    execute(future);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>submit()</code> 非常简单，将我们丢进来的 <code>Callable</code> 对象转换为一个 <code>FutureTask</code> 对象，然后再调用之前的 <code>execute()</code> 来丢进线程池（后续的流程就和一个普通的线程进入线程池的流程一样）。</p>
<blockquote>
<p>FutureTask 本身也是线程，所以可以直接使用 <code>execute()</code> 函数。</p>
</blockquote>
<hr>
<p>而 <code>future.get()</code> 函数中 <code>future</code> 对象由于在 <code>submit()</code> 中返回的真正对象是 <code>FutureTask</code>，所以我们直接看其中的源码就好。</p>
<p><img src="https://i.loli.net/2019/06/06/5cf80005766ef25838.jpg"></p>
<p>由于 <code>get()</code> 在线程没有返回之前是一个阻塞函数，最终也是通过 <code>notify.wait()</code> 使线程进入阻塞状态来实现的。</p>
<p>而使其从 <code>wait()</code> 中返回的条件必然是在线程执行完毕拿到返回值的时候才进行唤醒。</p>
<p>也就是图中的第二部分；一旦线程执行完毕（<code>callable.call()</code>）就会唤醒 <code>notify</code> 对象，这样 <code>get</code> 方法也就能返回了。</p>
<hr>
<p>同样的道理，<code>ThreadPoolExecutor</code> 中的原理也是类似，只不过它考虑的细节更多所以看起来很复杂，但精简代码后核心也就是这些。</p>
<p>甚至最终使用的 api 看起来都是类似的：</p>
<p><img src="https://i.loli.net/2019/06/06/5cf80006c916e52248.jpg"></p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>最后一个是一些新手使用线程池很容易踩坑的一个地方：那就是异常处理。</p>
<p>比如类似于这样的场景：</p>
<p><img src="https://i.loli.net/2019/06/06/5cf8000749e6c64762.jpg"></p>
<p>创建了只有<strong>一个线程</strong>的线程池，这个线程只做一件事，就是一直不停的 while 循环。</p>
<p>但是循环的过程中不小心抛出了一个异常，巧的是这个异常又没有被捕获。你觉得后续会发生什么事情呢？</p>
<p>是线程继续运行？还是线程池会退出？</p>
<p><img src="https://i.loli.net/2019/06/06/5cf800079d51a22414.jpg"></p>
<p>通过现象来看其实哪种都不是，线程既没有继续运行同时线程池也没有退出，会一直卡在这里。</p>
<p>当我们 <code>dump</code> 线程快照会发现：</p>
<p><img src="https://i.loli.net/2019/06/06/5cf8000823ad870419.jpg"></p>
<p>这时线程池中还有一个线程在运行，通过线程名称会发现这是新创建的一个线程（之前是<code>Thread-0</code>，现在是 <code>Thread-1</code>）。</p>
<p>它的线程状态为 <code>WAITING</code> ，通过堆栈发现是卡在了 <code>CustomThreadPool.java:272</code> 处。</p>
<p><img src="https://i.loli.net/2019/06/06/5cf8000872d1f43610.jpg"></p>
<p>就是卡在了从队列里获取任务的地方，由于此时的任务队列是空的，所以他会一直阻塞在这里。</p>
<p><strong>看到这里，之前关注的朋友有没有似曾相识的感觉。</strong></p>
<p>没错，我之前写过两篇：</p>
<ul>
<li><a href="https://crossoverjie.top/2019/03/12/troubleshoot/thread-gone/">一个线程罢工的诡异事件</a></li>
<li><a href="https://crossoverjie.top/2019/03/26/troubleshoot/thread-gone2/">线程池中你不容错过的一些细节</a></li>
</ul>
<p>线程池相关的问题，当时的讨论也非常<code>“激烈”</code>，其实最终的原因和这里是一模一样的。</p>
<p>所以就这次简版的代码来看看其中的问题：</p>
<p><img src="https://i.loli.net/2019/06/06/5cf80008d46e642627.jpg"></p>
<p>现在又简化了一版代码我觉得之前还有疑问的朋友这次应该会更加明白。</p>
<p>其实在线程池内部会对线程的运行捕获异常，但它并不会处理，只是用于标记是否执行成功；</p>
<p>一旦执行失败则会回收掉当前异常的线程，然后重新创建一个新的 <code>Worker</code> 线程继续从<strong>队列里取任务然后执行</strong>。</p>
<p>所以最终才会卡在<code>从队列中取任务</code>处。</p>
<p>其实 <code>ThreadPoolExecutor</code> 的异常处理也是类似的，具体的源码就不多分析了，在上面两篇文章中已经说过几次。</p>
<p><strong>所以我们在使用线程池时，其中的任务一定要做好异常处理。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一波下来我觉得线程池搞清楚没啥问题了，总的来看它内部运用了非常多的多线程解决方案，比如：</p>
<ul>
<li><code>ReentrantLock</code> 重入锁来保证线程写入的并发安全。</li>
<li>利用等待通知机制来实现线程间通信（线程执行结果、等待线程池执行完毕等）。</li>
</ul>
<p>最后也学会了：</p>
<ul>
<li>标准的线程池关闭流程。</li>
<li>如何使用有返回值的线程。</li>
<li>线程异常捕获的重要性。</li>
</ul>
<p>最后本文所有源码（结合其中的测试代码使用）：</p>
<p><a href="https://github.com/crossoverJie/JCSprout/blob/master/src/main/java/com/crossoverjie/concurrent/CustomThreadPool.java">https://github.com/crossoverJie/JCSprout/blob/master/src/main/java/com/crossoverjie/concurrent/CustomThreadPool.java</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>concurrent</tag>
        <tag>ThreadPool</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式(一) 搞定服务注册与发现</title>
    <url>/2018/08/27/distributed/distributed-discovery-zk/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d22474b79.jpg"></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做分布式相关的工作，由于人手不够只能我一个人来怼；看着这段时间的加班表想想就是够惨的。</p>
<p>不过其中也有遇到的不少有意思的事情今后再拿来分享，今天重点来讨论服务的<strong>注册与发现</strong>。</p>
<h2 id="分布式带来的问题"><a href="#分布式带来的问题" class="headerlink" title="分布式带来的问题"></a>分布式带来的问题</h2><p>我的业务比较简单，只是需要知道现在有哪些服务实例可供使用就可以了（并不是做远程调用，只需要拿到信息即可）。</p>
<p>要实现这一功能最简单的方式可以在应用中配置所有的服务节点，这样每次在使用时只需要通过某种算法从配置列表中选择一个就可以了。</p>
<p>但这样会有一个非常严重的问题：</p>
<p>由于应用需要根据应用负载情况来灵活的调整服务节点的数量，这样我的配置就不能写死。</p>
<p>不然就会出现要么新增的节点没有访问或者是已经 down 掉的节点却有请求，这样肯定是不行的。</p>
<p>往往要解决这类分布式问题都需要一个公共的区域来保存这些信息，比如是否可以利用 Redis？</p>
<p>每个节点启动之后都向 Redis 注册信息，关闭时也删除数据。</p>
<p>其实就是存放节点的 <code>ip + port</code>，然后在需要知道服务节点信息时候只需要去 Redis 中获取即可。</p>
<span id="more"></span>

<p>如下图所示：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d22a0ab9f.jpg"></p>
<p>但这样会导致每次使用时都需要频繁的去查询 Redis，为了避免这个问题我们可以在每次查询之后在本地缓存一份最新的数据。这样优先从本地获取确实可以提高效率。</p>
<p>但同样又会出现新的问题，如果服务提供者的节点新增或者删除消费者这边根本就不知道情况。</p>
<p>要解决这个问题最先想到的应该就是利用定时任务定期去更新服务列表。</p>
<p>以上的方案肯定不完美，并且不优雅。主要有以下几点：</p>
<ul>
<li>基于定时任务会导致很多无效的更新。</li>
<li>定时任务存在周期性，没法做到实时，这样就可能存在请求异常。</li>
<li>如果服务被强行 kill，没法及时清除 Redis，这样这个看似可用的服务将永远不可用！</li>
</ul>
<p>所以我们需要一个更加靠谱的解决方案，这样的场景其实和 Dubbo 非常类似。</p>
<p>用过的同学肯定对这张图不陌生。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d22aa8afa.jpg"></p>
<blockquote>
<p>引用自 Dubbo <a href="https://dubbo.incubator.apache.org/en-us/">官网</a></p>
</blockquote>
<p>其中有一块非常核心的内容（红框出）就是服务的注册与发现。</p>
<p>通常来说消费者是需要知道服务提供者的网络地址(ip + port)才能发起远程调用，这块内容和我上面的需求其实非常类似。</p>
<p>而 Dubbo 则是利用 Zookeeper 来解决问题。</p>
<h2 id="Zookeeper-能做什么"><a href="#Zookeeper-能做什么" class="headerlink" title="Zookeeper 能做什么"></a>Zookeeper 能做什么</h2><p>在具体讨论怎么实现之前先看看 Zookeeper 的几个重要特性。</p>
<p>Zookeeper 实现了一个类似于文件系统的树状结构：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d22b37597.jpg"></p>
<p>这些节点被称为 znode(名字叫什么不重要)，其中每个节点都可以存放一定的数据。</p>
<p>最主要的是 znode 有四种类型：</p>
<ul>
<li>永久节点（除非手动删除，节点永远存在）</li>
<li>永久有序节点（按照创建顺序会为每个节点末尾带上一个序号如：<code>root-1</code>）</li>
<li>瞬时节点（创建客户端与 Zookeeper 保持连接时节点存在，断开时则删除并会有相应的通知）</li>
<li>瞬时有序节点（在瞬时节点的基础上加上了顺序）</li>
</ul>
<p>考虑下上文使用 Redis 最大的一个问题是什么？</p>
<p>其实就是不能实时的更新服务提供者的信息。</p>
<p>那利用 Zookeeper 是怎么实现的？</p>
<p>主要看第三个特性：<strong>瞬时节点</strong></p>
<p>Zookeeper 是一个典型的观察者模式。</p>
<ul>
<li>由于瞬时节点的特点，我们的消费者可以订阅瞬时节点的父节点。</li>
<li>当新增、删除节点时所有的瞬时节点也会自动更新。</li>
<li>更新时会给订阅者发起通知告诉最新的节点信息。</li>
</ul>
<p>这样我们就可以实时获取服务节点的信息，同时也只需要在第一次获取列表时缓存到本地；也不需要频繁和 Zookeeper 产生交互，只用等待通知更新即可。</p>
<p>并且不管应用什么原因节点 down 掉后也会在 Zookeeper 中删除该信息。</p>
<h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><p>这样实现方式就变为这样。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d22ba62d5.jpg"></p>
<p>为此我新建了一个应用来进行演示：</p>
<p><a href="https://github.com/crossoverJie/netty-action/tree/master/netty-action-zk">https://github.com/crossoverJie/netty-action/tree/master/netty-action-zk</a></p>
<p>就是一个简单的 SpringBoot 应用，只是做了几件事情。</p>
<ul>
<li>应用启动时新开一个线程用于向 Zookeeper 注册服务。</li>
<li>同时监听一个节点用于更新本地服务列表。</li>
<li>提供一个接口用于返回一个可有的服务节点。</li>
</ul>
<p>我在本地启动了两个应用分别是：<code>127.0.0.1:8083,127.0.0.1:8084</code>。来看看效果图。</p>
<p>两个应用启动完成：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d22d1fd47.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d22ed3d2f.jpg"></p>
<hr>
<p>当前 Zookeeper 的可视化树状结构：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2353b899.jpg"></p>
<hr>
<p>当想知道所有的服务节点信息时：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d235d30ea.jpg"></p>
<hr>
<p>想要获取一个可用的服务节点时：</p>
<p><img src="https://i.loli.net//2019//05//08//5cd1dc84306df.jpg"></p>
<p>这里只是采取了简单的轮询。</p>
<hr>
<p>当 down 掉一个节点时：应用会收到通知更新本地缓存。同时 Zookeeper 中的节点会自动删除。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2b5b15fd.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2b66b2b2.jpg"></p>
<hr>
<p>再次获取最新节点时：</p>
<p><img src="https://i.loli.net//2019//05//08//5cd1dd090d37e.jpg"></p>
<hr>
<p>当节点恢复时自然也能获取到最新信息。本地缓存也会及时更新。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4faa9cfc.jpg"></p>
<p><img src="https://i.loli.net//2019//05//08//5cd1dd8cc097a.jpg"></p>
<h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><p>实现起来倒也比较简单，主要就是 ZKClient 的 api 使用。</p>
<p>贴几段比较核心的吧。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><blockquote>
<p>启动注册 Zookeeper。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/08/5cd1d52ed5080.jpg"></p>
<p>主要逻辑都在这个线程中。</p>
<ul>
<li>首先创建父节点。如上图的 Zookeeper 节点所示；需要先创建 <code>/route</code> 根节点，创建的时候会判断是否已经存在。</li>
<li>接着需要判断是否需要将自己注册到 Zookeeper 中，因为有些节点只是用于服务发现，他自身是不需要承担业务功能（是我自己项目的需求）。</li>
<li>将当前应用的所在 ip 以及端口注册上去，同时需要监听根节点 <code>/route</code> ，这样才能在其他服务上下线时候获得通知。</li>
</ul>
<h3 id="根据本地缓存"><a href="#根据本地缓存" class="headerlink" title="根据本地缓存"></a>根据本地缓存</h3><blockquote>
<p>监听到服务变化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribeEvent</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    zkClient.subscribeChildChanges(path, <span class="keyword">new</span> <span class="title class_">IZkChildListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleChildChange</span><span class="params">(String parentPath, List&lt;String&gt; currentChilds)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;清除/更新本地缓存 parentPath=【&#123;&#125;】,currentChilds=【&#123;&#125;】&quot;</span>, parentPath,currentChilds.toString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新所有缓存/先删除 再新增</span></span><br><span class="line">            serverCache.updateCache(currentChilds) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里是更新了本地缓存，该缓存采用了 Guava 提供的 Cache，感兴趣的可以查看之前的<a href="https://crossoverjie.top/categories/Guava/">源码分析</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新所有缓存/先删除 再新增</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentChilds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateCache</span><span class="params">(List&lt;String&gt; currentChilds)</span> &#123;</span><br><span class="line">    cache.invalidateAll();</span><br><span class="line">    <span class="keyword">for</span> (String currentChild : currentChilds) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> currentChild.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">        addCache(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端负载"><a href="#客户端负载" class="headerlink" title="客户端负载"></a>客户端负载</h3><blockquote>
<p>同时在客户端提供了一个负载算法。</p>
</blockquote>
<p>其实就是一个轮询的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选取服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">selectServer</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; all = getAll();</span><br><span class="line">    <span class="keyword">if</span> (all.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;路由列表为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">position</span> <span class="operator">=</span> index.incrementAndGet() % all.size();</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        position = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all.get(position.intValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这里可以扩展出更多的如权重、随机、<a href="https://crossoverjie.top/%2F2018%2F04%2F07%2Falgorithm%2FLRU-cache%2F">LRU</a> 等算法。</p>
<h2 id="Zookeeper-其他优势及问题"><a href="#Zookeeper-其他优势及问题" class="headerlink" title="Zookeeper 其他优势及问题"></a>Zookeeper 其他优势及问题</h2><p>Zookeeper 自然是一个很棒的分布式协调工具，利用它的特性还可以有其他作用。</p>
<ul>
<li>数据变更发送通知这一特性可以实现统一配置中心，再也不需要在每个服务中单独维护配置。</li>
<li>利用瞬时有序节点还可以实现分布式锁。</li>
</ul>
<p>在实现注册、发现这一需求时，Zookeeper 其实并不是最优选。</p>
<p>由于 Zookeeper 在 CAP 理论中选择了 CP（一致性、分区容错性），当 Zookeeper 集群有半数节点不可用时是不能获取到任何数据的。</p>
<p>对于一致性来说自然没啥问题，但在注册、发现的场景下更加推荐 <code>Eureka</code>，已经在 SpringCloud 中得到验证。具体就不在本文讨论了。</p>
<p>但鉴于我的使用场景来说 Zookeeper 已经能够胜任。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文所有完整代码都托管在 GitHub。</p>
<p><a href="https://github.com/crossoverJie/netty-action">https://github.com/crossoverJie/netty-action</a>。</p>
<p>一个看似简单的注册、发现功能实现了，但分布式应用远远不止这些。</p>
<p>由于网络隔离之后带来的一系列问题还需要我们用其他方式一一完善；后续会继续更新分布式相关内容，感兴趣的朋友不妨持续关注。</p>
<p><strong>你的点赞与转发是最大的支持。</strong></p>
]]></content>
      <categories>
        <category>Distributed</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法实践</title>
    <url>/2022/12/27/desigin-patterns/template-method/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/01/12/TG3RQnjKDOc7vaF.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近不出意外的阳了，加上刚入职新公司不久，所以也没怎么更新；这两天好些后分享一篇前段时间的一个案例：</p>
<p>最近在设计一个对某个中间件的测试方案，这个测试方案需要包含不同的测试逻辑，但相同的是需要对各个环节进行记录；比如统计耗时、调用通知 API 等相同的逻辑。</p>
<p>如果每个测试都单独写这些逻辑那无疑是做了许多重复工作了。</p>
<span id="more"></span>

<p>基于以上的特征很容易能想到<strong>模板方法</strong>这个设计模式。</p>
<p>这是一种有上层定义框架，下层提供不同实现的设计模式。</p>
<p>比如装修房子的时候业主可以按照自己的喜好对不同的房间进行装修，但是整体的户型图不能做修改，比如承重墙是肯定不能打的。</p>
<p>而这些固定好的条条框框就是上层框架给的约束，下层不同的实现就有业主自己决定；所以对于整栋楼来说框架都是固定好的，让业主在有限的范围内自由发挥也方便物业的管理。</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>以我这个案例的背景为例，首先需要定义出上层框架：</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><code>Event</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Event</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增一个任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addJob</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个任务执行完毕</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobName    任务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> finishCost 任务完成耗时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">finishOne</span><span class="params">(String jobName, String finishCost)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**单个任务执行异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobDefine 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">oneException</span><span class="params">(AbstractJobDefine jobDefine, Exception e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有任务执行完毕</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">finishAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    event.addJob();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="type">StopWatch</span> <span class="variable">watch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                watch.start(jobName);</span><br><span class="line">                <span class="comment">// 不同的子业务实现</span></span><br><span class="line">                run(client);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                event.oneException(<span class="built_in">this</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                watch.stop();</span><br><span class="line">                event.finishOne(jobName, StrUtil.format(<span class="string">&quot;cost: &#123;&#125;s&quot;</span>, watch.getTotalTimeSeconds()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, TestCase.EXECUTOR).get(timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        event.oneException(<span class="built_in">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Run busy code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception e</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Client client)</span> <span class="keyword">throws</span> Exception;    </span><br></pre></td></tr></table></figure>

<p>其中最核心的就是 run 函数，它是一个抽象函数，具体实现交由子类完成；这样不同的测试用例之间也互不干扰，同时整体的流程完全相同：</p>
<ul>
<li>记录任务数量</li>
<li>统计耗时</li>
<li>异常记录</li>
</ul>
<p>等流程。</p>
<hr>
<p>接下来看看如何使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test1</span>(event, <span class="string">&quot;测试1&quot;</span>, client, <span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; c1 = CompletableFuture.runAsync(job1::start, EXECUTOR);</span><br><span class="line"></span><br><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test2</span>(event, <span class="string">&quot;测试2&quot;</span>, client, <span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; c2 = CompletableFuture.runAsync(job2::start, EXECUTOR);</span><br><span class="line"></span><br><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test3</span>(event, <span class="string">&quot;测试3&quot;</span>, client, <span class="number">20</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; c3 = CompletableFuture.runAsync(job3::start, EXECUTOR);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(c1, c2, c3);</span><br><span class="line">all.whenComplete((___, __) -&gt; &#123;</span><br><span class="line">    event.finishAll();</span><br><span class="line">    client.close();</span><br><span class="line">&#125;).get();</span><br></pre></td></tr></table></figure>

<p>显而易见 <code>Test1~3</code> 都继承了 <code>AbstractJobDefine</code> 同时实现了其中的 <code>run</code> 函数，使用的时候只需要创建不同的实例等待他们都执行完成即可。</p>
<p>以前在 Java 中也有不同的应用：<br><img src="https://s2.loli.net/2023/01/12/dRl4DEIXj1BfNZ2.png"></p>
<p><a href="https://crossoverjie.top/2019/03/01/algorithm/consistent-hash/?highlight=%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95">https://crossoverjie.top/2019/03/01/algorithm/consistent-hash/?highlight=%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95</a></p>
<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><p>同样的示例用 Go 自然也可以实现：</p>
<p><img src="https://s2.loli.net/2023/01/12/Eu6OUrb7jGtLozN.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJobDefine_start</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	event := NewEvent()</span><br><span class="line">	j1 := &amp;JobDefine&#123;</span><br><span class="line">		Event:   event,</span><br><span class="line">		Run:     &amp;run1&#123;&#125;,</span><br><span class="line">		JobName: <span class="string">&quot;job1&quot;</span>,</span><br><span class="line">		Param1:  <span class="string">&quot;p1&quot;</span>,</span><br><span class="line">		Param2:  <span class="string">&quot;p2&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	j2 := &amp;JobDefine&#123;</span><br><span class="line">		Event:   event,</span><br><span class="line">		Run:     &amp;run2&#123;&#125;,</span><br><span class="line">		JobName: <span class="string">&quot;job2&quot;</span>,</span><br><span class="line">		Param1:  <span class="string">&quot;p11&quot;</span>,</span><br><span class="line">		Param2:  <span class="string">&quot;p22&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	j1.Start()</span><br><span class="line">	j2.Start()</span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> event.GetChan() &#123;</span><br><span class="line">		&lt;-ch</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">&quot;finish all&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *run2)</span></span> Run(param1, param2 <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;run3 param1:%s, param2:%s&quot;</span>, param1, param2)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">return</span> errors.New(<span class="string">&quot;test err&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *run1)</span></span> Run(param1, param2 <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;run1 param1:%s, param2:%s&quot;</span>, param1, param2)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用起来也与 Java 类似，创建不同的实例；最后等待所有的任务执行完毕。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>设计模式往往是对某些共性能力的抽象，但也没有一个设计模式可以适用于所有的场景；需要对不同的需求选择不同的设计模式。</p>
<p>至于在工作中如何进行正确的选择，那就需要自己日常的积累了；比如多去了解不同的设计模式对于的场景，或者多去阅读优秀的代码，Java 中的 <code>InputStream/Reader/Writer</code> 这类 IO 相关的类都有具体的应用。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式工具的一次小升级⏫</title>
    <url>/2018/06/07/distributed-lock/distributed-lock-redis-update/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d53277e6e.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在做 <a href="https://crossoverjie.top/2018/05/07/ssm/SSM18-seconds-kill/#distributed-redis-tool-%E2%AC%86%EF%B8%8Fv1-0-3">秒杀架构实践</a> 时有提到对 <a href="https://github.com/crossoverJie/distributed-redis-tool">distributed-redis-tool</a> 的一次小升级，但是没有细说。</p>
<p>其实主要原因是：</p>
<blockquote>
<p>秒杀时我做压测：由于集成了这个限流组件，并发又比较大，所以导致连接、断开 Redis 非常频繁。<br>最终导致获取不了 Redis connection 的异常。</p>
</blockquote>
<h2 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h2><p>这就是一个典型的对稀缺资源使用不善导致的。</p>
<p>何为稀缺资源？常见的有：</p>
<ul>
<li>线程</li>
<li>数据库连接</li>
<li>网络连接等</li>
</ul>
<p>这些资源都有共同的特点：<strong>创建销毁成本较高</strong>。</p>
<span id="more"></span>

<p>这里涉及到的 Redis 连接也属于该类资源。</p>
<p>我们希望将这些稀有资源管理起来放到一个池子里，当需要时就从中获取，用完就放回去，不够用时就等待（或返回）。</p>
<p>这样我们只需要初始化并维护好这个池子，就能避免频繁的创建、销毁这些资源（也有资源长期未使用需要缩容的情况）。</p>
<p>通常我们称这项姿势为池化技术，如常见的：</p>
<ul>
<li>线程池</li>
<li>各种资源的连接池等。</li>
</ul>
<p>为此我将使用到 Redis 的 <a href="https://crossoverjie.top/%2F2018%2F03%2F29%2Fdistributed-lock%2Fdistributed-lock-redis%2F">分布式锁</a>、<a href="https://crossoverjie.top/2018/04/28/sbc/sbc7-Distributed-Limit/">分布式限流</a> 都升级为利用连接池来获取 Redis 的连接。</p>
<p>这里以<a href="https://github.com/crossoverJie/distributed-redis-tool#distributed-lock">分布式锁</a>为例：</p>
<p>将使用的 api 修改为：</p>
<p>原有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLockConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisLock <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//Need to get Redis connection </span></span><br><span class="line">        <span class="type">RedisLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisLock</span>() ;</span><br><span class="line">        <span class="type">HostAndPort</span> <span class="variable">hostAndPort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7000</span>) ;</span><br><span class="line">        <span class="type">JedisCluster</span> <span class="variable">jedisCluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(hostAndPort) ;</span><br><span class="line">        <span class="type">RedisLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisLock</span>.Builder(jedisCluster)</span><br><span class="line">                .lockPrefix(<span class="string">&quot;lock_test&quot;</span>)</span><br><span class="line">                .sleepTime(<span class="number">100</span>)</span><br><span class="line">                .build();</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> redisLock ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLockConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(RedisLockConfig.class);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JedisConnectionFactory jedisConnectionFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisLock <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RedisLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisLock</span>.Builder(jedisConnectionFactory,RedisToolsConstant.SINGLE)</span><br><span class="line">                .lockPrefix(<span class="string">&quot;lock_&quot;</span>)</span><br><span class="line">                .sleepTime(<span class="number">100</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以前的 Jedis 修改为 <code>JedisConnectionFactory</code>，后续的 Redis 连接就可通过这个对象获取。</p>
<p>并且显示的传入使用 RedisCluster 还是单机的 Redis。</p>
<p>所以在真正操作 Redis 时需要修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key, String request)</span> &#123;</span><br><span class="line">    <span class="comment">//get connection</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">connection</span> <span class="operator">=</span> getConnection();</span><br><span class="line">    String result ;</span><br><span class="line">    <span class="keyword">if</span> (connection <span class="keyword">instanceof</span> Jedis)&#123;</span><br><span class="line">        result =  ((Jedis) connection).set(lockPrefix + key, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, <span class="number">10</span> * TIME);</span><br><span class="line">        ((Jedis) connection).close();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        result = ((JedisCluster) connection).set(lockPrefix + key, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, <span class="number">10</span> * TIME);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((JedisCluster) connection).close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;IOException&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LOCK_MSG.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取连接</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">    Object connection ;</span><br><span class="line">    <span class="keyword">if</span> (type == RedisToolsConstant.SINGLE)&#123;</span><br><span class="line">        <span class="type">RedisConnection</span> <span class="variable">redisConnection</span> <span class="operator">=</span> jedisConnectionFactory.getConnection();</span><br><span class="line">        connection = redisConnection.getNativeConnection();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">RedisClusterConnection</span> <span class="variable">clusterConnection</span> <span class="operator">=</span> jedisConnectionFactory.getClusterConnection();</span><br><span class="line">        connection = clusterConnection.getNativeConnection() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>最大的改变就是将原有操作 Redis 的对象（<code>T extends JedisCommands</code>）改为从连接池中获取。</p>
<p>由于使用了 <code>org.springframework.data.redis.connection.jedis.JedisConnectionFactory</code> 作为 Redis 连接池。</p>
<p>所以需要再使用时构件好这个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">config.setMaxTotal(<span class="number">300</span>);</span><br><span class="line">config.setMaxWaitMillis(<span class="number">10000</span>);</span><br><span class="line">config.setTestOnBorrow(<span class="literal">true</span>);</span><br><span class="line">config.setTestOnReturn(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">RedisClusterConfiguration</span> <span class="variable">redisClusterConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisClusterConfiguration</span>();</span><br><span class="line">redisClusterConfiguration.addClusterNode(<span class="keyword">new</span> <span class="title class_">RedisNode</span>(<span class="string">&quot;10.19.13.51&quot;</span>, <span class="number">7000</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//单机</span></span><br><span class="line"><span class="type">JedisConnectionFactory</span> <span class="variable">jedisConnectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisConnectionFactory</span>(config);</span><br><span class="line"></span><br><span class="line"><span class="comment">//集群</span></span><br><span class="line"><span class="comment">//JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory(redisClusterConfiguration) ;</span></span><br><span class="line">jedisConnectionFactory.setHostName(<span class="string">&quot;47.98.194.60&quot;</span>);</span><br><span class="line">jedisConnectionFactory.setPort(<span class="number">6379</span>);</span><br><span class="line">jedisConnectionFactory.setPassword(<span class="string">&quot;&quot;</span>);</span><br><span class="line">jedisConnectionFactory.setTimeout(<span class="number">100000</span>);</span><br><span class="line">jedisConnectionFactory.afterPropertiesSet();</span><br><span class="line"><span class="comment">//jedisConnectionFactory.setShardInfo(new JedisShardInfo(&quot;47.98.194.60&quot;, 6379));</span></span><br><span class="line"><span class="comment">//JedisCluster jedisCluster = new JedisCluster(hostAndPort);</span></span><br><span class="line"></span><br><span class="line"><span class="type">HostAndPort</span> <span class="variable">hostAndPort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;10.19.13.51&quot;</span>, <span class="number">7000</span>);</span><br><span class="line"><span class="type">JedisCluster</span> <span class="variable">jedisCluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(hostAndPort);</span><br><span class="line">redisLock = <span class="keyword">new</span> <span class="title class_">RedisLock</span>.Builder(jedisConnectionFactory, RedisToolsConstant.SINGLE)</span><br><span class="line">        .lockPrefix(<span class="string">&quot;lock_&quot;</span>)</span><br><span class="line">        .sleepTime(<span class="number">100</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看起比较麻烦，需要构建对象的较多。</p>
<p>但整合 Spring 使用时就要清晰许多。</p>
<h2 id="配合-Spring"><a href="#配合-Spring" class="headerlink" title="配合 Spring"></a>配合 Spring</h2><p>Spring 很大的一个作用就是帮我们管理对象，所以像上文那些看似很复杂的对象都可以交由它来管理：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jedis 配置 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;JedispoolConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.maxIdle&#125;&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.maxTotal&#125;&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.maxWait&#125;&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.testOnBorrow&#125;&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnReturn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.testOnBorrow&#125;&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- redis服务器中心 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolConfig&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;JedispoolConfig&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.port&#125;&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hostName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.host&#125;&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.timeout&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.core.RedisTemplate&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;keySerializer&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;valueSerializer&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个其实没多少好说的，就算是换成 SpringBoot 也是创建 <code>JedispoolConfig,connectionFactory,redisTemplate</code> 这些 bean 即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>换为连接池之后再进行压测自然没有出现获取不了 Redis 连接的异常（并发达到一定的量也会出错）说明更新是很有必要的。</p>
<p>推荐有用到该组件的朋友都升级下，也欢迎提出 Issues 和 PR。</p>
<p>项目地址：</p>
<p><a href="https://github.com/crossoverJie/distributed-redis-tool">https://github.com/crossoverJie/distributed-redis-tool</a></p>
]]></content>
      <categories>
        <category>Distributed Tools</category>
      </categories>
      <tags>
        <tag>Distributed Lock</tag>
        <tag>Distributed Limited</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Redis 的分布式锁</title>
    <url>/2018/03/29/distributed-lock/distributed-lock-redis/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d7a3c310a.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式锁在分布式应用中应用广泛，想要搞懂一个新事物首先得了解它的由来，这样才能更加的理解甚至可以举一反三。</p>
<p>首先谈到分布式锁自然也就联想到分布式应用。</p>
<p>在我们将应用拆分为分布式应用之前的单机系统中，对一些并发场景读取公共资源时如扣库存，卖车票之类的需求可以简单的使用<a href="http://crossoverjie.top/2018/01/14/Synchronize/">同步</a>或者是<a href="http://crossoverjie.top/2018/01/25/ReentrantLock/">加锁</a>就可以实现。</p>
<p>但是应用分布式了之后系统由以前的单进程多线程的程序变为了多进程多线程，这时使用以上的解决方案明显就不够了。</p>
<p>因此业界常用的解决方案通常是借助于一个第三方组件并利用它自身的排他性来达到多进程的互斥。如：</p>
<ul>
<li>基于 DB 的唯一索引。</li>
<li>基于 ZK 的临时有序节点。</li>
<li>基于 Redis 的 <code>NX EX</code> 参数。</li>
</ul>
<p>这里主要基于 Redis 进行讨论。</p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>既然是选用了 Redis，那么它就得具有排他性才行。同时它最好也有锁的一些基本特性：</p>
<ul>
<li>高性能(加、解锁时高性能)</li>
<li>可以使用阻塞锁与非阻塞锁。</li>
<li>不能出现死锁。</li>
<li>可用性(不能出现节点 down 掉后加锁失败)。</li>
</ul>
<p>这里利用 <code>Redis set key</code> 时的一个 NX 参数可以保证在这个 key 不存在的情况下写入成功。并且再加上 EX 参数可以让该 key 在超时之后自动删除。</p>
<p>所以利用以上两个特性可以保证在同一时刻只会有一个进程获得锁，并且不会出现死锁(最坏的情况就是超时自动删除 key)。</p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SET_IF_NOT_EXIST</span> <span class="operator">=</span> <span class="string">&quot;NX&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SET_WITH_EXPIRE_TIME</span> <span class="operator">=</span> <span class="string">&quot;PX&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key, String request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.jedis.set(LOCK_PREFIX + key, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, <span class="number">10</span> * TIME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LOCK_MSG.equals(result))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里使用的 jedis 的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">set</span><span class="params">(String key, String value, String nxxx, String expx, <span class="type">long</span> time)</span>;</span><br></pre></td></tr></table></figure>

<p>api。</p>
<p>该命令可以保证 NX EX 的原子性。</p>
<p>一定不要把两个命令(NX EX)分开执行，如果在 NX 之后程序出现问题就有可能产生死锁。</p>
<h4 id="阻塞锁"><a href="#阻塞锁" class="headerlink" title="阻塞锁"></a>阻塞锁</h4><p>同时也可以实现一个阻塞锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一直阻塞</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(String key, String request)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.jedis.set(LOCK_PREFIX + key, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, <span class="number">10</span> * TIME);</span><br><span class="line">        <span class="keyword">if</span> (LOCK_MSG.equals(result))&#123;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//防止一直消耗 CPU 	</span></span><br><span class="line">        Thread.sleep(DEFAULT_SLEEP_TIME) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//自定义阻塞时间</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String key, String request,<span class="type">int</span> blockTime)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (blockTime &gt;= <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.jedis.set(LOCK_PREFIX + key, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, <span class="number">10</span> * TIME);</span><br><span class="line">        <span class="keyword">if</span> (LOCK_MSG.equals(result))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        blockTime -= DEFAULT_SLEEP_TIME ;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(DEFAULT_SLEEP_TIME) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>解锁也很简单，其实就是把这个 key 删掉就万事大吉了，比如使用 <code>del key</code> 命令。</p>
<p>但现实往往没有那么 easy。</p>
<p>如果进程 A 获取了锁设置了超时时间，但是由于执行周期较长导致到了超时时间之后锁就自动释放了。这时进程 B 获取了该锁执行很快就释放锁。这样就会出现进程 B 将进程 A 的锁释放了。</p>
<p>所以最好的方式是在每次解锁时都需要判断锁<strong>是否是自己</strong>的。</p>
<p>这时就需要结合加锁机制一起实现了。</p>
<p>加锁时需要传递一个参数，将该参数作为这个 key 的 value，这样每次解锁时判断 value 是否相等即可。</p>
<p>所以解锁代码就不能是简单的 <code>del</code>了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">unlock</span><span class="params">(String key,String request)</span>&#123;</span><br><span class="line">    <span class="comment">//lua script</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="keyword">if</span> (jedis <span class="keyword">instanceof</span> Jedis)&#123;</span><br><span class="line">        result = ((Jedis)<span class="built_in">this</span>.jedis).eval(script, Collections.singletonList(LOCK_PREFIX + key), Collections.singletonList(request));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (jedis <span class="keyword">instanceof</span> JedisCluster)&#123;</span><br><span class="line">        result = ((JedisCluster)<span class="built_in">this</span>.jedis).eval(script, Collections.singletonList(LOCK_PREFIX + key), Collections.singletonList(request));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//throw new RuntimeException(&quot;instance is error&quot;) ;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UNLOCK_MSG.equals(result))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了一个 <code>lua</code> 脚本来判断 value 是否相等，相等才执行 del 命令。</p>
<p>使用 <code>lua</code> 也可以保证这里两个操作的原子性。</p>
<p>因此上文提到的四个基本特性也能满足了：</p>
<ul>
<li>使用 Redis 可以保证性能。</li>
<li>阻塞锁与非阻塞锁见上文。</li>
<li>利用超时机制解决了死锁。</li>
<li>Redis 支持集群部署提高了可用性。</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我自己有撸了一个完整的实现，并且已经用于了生产，有兴趣的朋友可以开箱使用:</p>
<p>maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.crossoverjie.opensource<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>distributed-redis-lock<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置 bean :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLockConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisLock <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">RedisLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisLock</span>() ;</span><br><span class="line">        <span class="type">HostAndPort</span> <span class="variable">hostAndPort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7000</span>) ;</span><br><span class="line">        <span class="type">JedisCluster</span> <span class="variable">jedisCluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(hostAndPort) ;</span><br><span class="line">        <span class="comment">// Jedis 或 JedisCluster 都可以</span></span><br><span class="line">        redisLock.setJedisCluster(jedisCluster) ;</span><br><span class="line">        <span class="keyword">return</span> redisLock ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisLock redisLock ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">locktest</span> <span class="operator">=</span> redisLock.tryLock(key, request);</span><br><span class="line">        <span class="keyword">if</span> (!locktest) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;locked error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redisLock.unlock(key,request) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用很简单。这里主要是想利用 Spring 来帮我们管理 RedisLock 这个单例的 bean，所以在释放锁的时候需要手动(因为整个上下文只有一个 RedisLock 实例)的传入 key 以及 request(api 看起来不是特别优雅)。</p>
<p>也可以在每次使用锁的时候 new 一个 RedisLock 传入 key 以及 request，这样倒是在解锁时很方便。但是需要自行管理 RedisLock 的实例。各有优劣吧。</p>
<p>项目源码在：</p>
<p><a href="https://github.com/crossoverJie/distributed-lock-redis">https://github.com/crossoverJie/distributed-lock-redis</a></p>
<p>欢迎讨论。</p>
<h2 id="单测"><a href="#单测" class="headerlink" title="单测"></a>单测</h2><p>在做这个项目的时候让我不得不想提一下<strong>单测</strong>。</p>
<p>因为这个应用是强依赖于第三方组件的(Redis)，但是在单测中我们需要排除掉这种依赖。比如其他伙伴 fork 了该项目想在本地跑一遍单测，结果运行不起来：</p>
<ol>
<li>有可能是 Redis 的 ip、端口和单测里的不一致。</li>
<li>Redis 自身可能也有问题。</li>
<li>也有可能是该同学的环境中并没有 Redis。</li>
</ol>
<p>所以最好是要把这些外部不稳定的因素排除掉，单测只测我们写好的代码。</p>
<p>于是就可以引入单测利器 <code>Mock</code> 了。</p>
<p>它的想法很简答，就是要把你所依赖的外部资源统统屏蔽掉。如：数据库、外部接口、外部文件等等。</p>
<p>使用方式也挺简单，可以参考该项目的单测：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    Mockito.when(jedisCluster.set(Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),</span><br><span class="line">            Mockito.anyString(), Mockito.anyLong())).thenReturn(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">locktest</span> <span class="operator">=</span> redisLock.tryLock(key, request);</span><br><span class="line">    System.out.println(<span class="string">&quot;locktest=&quot;</span> + locktest);</span><br><span class="line"></span><br><span class="line">    Assert.assertTrue(locktest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//check</span></span><br><span class="line">    Mockito.verify(jedisCluster).set(Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),</span><br><span class="line">            Mockito.anyString(), Mockito.anyLong());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是简单演示下，可以的话下次仔细分析分析。</p>
<p>它的原理其实也挺简单，debug 的话可以很直接的看出来：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d7afe72f2.jpg"></p>
<p>这里我们所依赖的 JedisCluster 其实是一个 <code>cglib 代理对象</code>。所以也不难想到它是如何工作的。</p>
<p>比如这里我们需要用到 JedisCluster 的 set 函数并需要它的返回值。</p>
<p>Mock 就将该对象代理了，并在实际执行 set 方法后给你返回了一个你自定义的值。</p>
<p>这样我们就可以随心所欲的测试了，<strong>完全把外部依赖所屏蔽了</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此一个基于 Redis 的分布式锁完成，但是依然有些问题。</p>
<ul>
<li>如在 key 超时之后业务并没有执行完毕但却自动释放锁了，这样就会导致并发问题。</li>
<li>就算 Redis 是集群部署的，如果每个节点都只是 master 没有 slave，那么 master 宕机时该节点上的所有 key 在那一时刻都相当于是释放锁了，这样也会出现并发问题。就算是有 slave 节点，但如果在数据同步到 salve 之前 master 宕机也是会出现上面的问题。</li>
</ul>
<p>感兴趣的朋友还可以参考 <a href="https://github.com/redisson/redisson">Redisson</a> 的实现。</p>
<h2 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h2><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Distributed Tools</category>
      </categories>
      <tags>
        <tag>Distributed Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch 索引 VS MySQL 索引</title>
    <url>/2020/08/24/elasticsearch/ElasticSearch%20VS%20MySQL/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/08/30/RfLEX7Ty1FlqbGm.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这段时间在维护产品的搜索功能，每次在管理台看到 <code>elasticsearch</code> 这么高效的查询效率我都很好奇他是如何做到的。</p>
<p><img src="https://i.loli.net/2020/08/30/IbN48xyOK9MBwQ1.jpg"></p>
<p>这甚至比在我本地使用 <code>MySQL</code> 通过主键的查询速度还快。</p>
<p><img src="https://i.loli.net/2020/08/30/Mh6kDK5wBeIj2sc.jpg"></p>
<span id="more"></span>

<p>为此我搜索了相关资料：</p>
<p><img src="https://i.loli.net/2020/08/30/jAl4zoIcvFCOLK6.jpg"></p>
<p>这类问题网上很多答案，大概意思呢如下：</p>
<ul>
<li>ES 是基于 <code>Lucene</code> 的全文检索引擎，它会对数据进行分词后保存索引，擅长管理大量的索引数据，相对于 <code>MySQL</code> 来说不擅长经常更新数据及关联查询。</li>
</ul>
<p>说的不是很透彻，没有解析相关的原理；不过既然反复提到了索引，那我们就从索引的角度来对比下两者的差异。</p>
<h1 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h1><p>先从 <code>MySQL</code> 说起，索引这个词想必大家也是烂熟于心，通常存在于一些查询的场景，是典型的空间换时间的案例。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">以下内容以 Innodb 引擎为例。</span><br></pre></td></tr></table></figure>

<h2 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h2><p>假设由我们自己来设计 <code>MySQL</code> 的索引，大概会有哪些选择呢？</p>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>首先我们应当想到的是散列表，这是一个非常常见且高效的查询、写入的数据结构，对应到 <code>Java</code> 中就是 <code>HashMap</code></p>
<p><img src="https://i.loli.net/2020/08/30/ijdKm2BawDxCTtN.jpg"></p>
<p>这个数据结构应该不需要过多介绍了，它的写入效率很高<code>O(1)</code>,比如我们要查询 <code>id=3</code> 的数据时，需要将 3 进行哈希运算，然后再这个数组中找到对应的位置即可。</p>
<p>但如果我们想查询 <code>1≤id≤6</code> 这样的区间数据时，散列表就不能很好的满足了，由于它是无序的，所以得将所有数据遍历一遍才能知道哪些数据属于这个区间。</p>
<h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><p><img src="https://i.loli.net/2020/08/30/PjQX6xFEcICUm2r.jpg"></p>
<p>有序数组的查询效率也很高，当我们要查询 <code>id=4</code> 的数据时，只需要通过二分查找也能高效定位到数据<code>O(logn)</code>。</p>
<p>同时由于数据也是有序的，所以自然也能支持区间查询；这么看来有序数组适合用做索引咯?</p>
<p>自然是不行，它有另一个重大问题；假设我们插入了 <code>id=2.5</code> 的数据，就得同时将后续的所有数据都移动一位，这个写入效率就会变得非常低。</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>既然有序数组的写入效率不高，那我们就来看看写入效率高的，很容易就能想到二叉树；这里我们以平衡二叉树为例：</p>
<p><img src="https://i.loli.net/2020/08/30/nth2my7eJSvCM1f.jpg"></p>
<p>由于平衡二叉树的特性：</p>
<blockquote>
<p>左节点小于父节点、右节点大于父节点。</p>
</blockquote>
<p>所以假设我们要查询 <code>id=11</code> 的数据，只需要查询 <code>10—&gt;12—&gt;11</code> 便能最终找到数据，时间复杂度为<code>O(logn)</code>，同理写入数据时也为<code>O(logn)</code>。</p>
<p>但依然不能很好的支持区间范围查找，假设我们要查询<code>5≤id≤20</code> 的数据时，需要先查询10节点的左子树再查询10节点的右子树最终才能查询到所有数据。</p>
<p>导致这样的查询效率并不高。</p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>跳表可能不像上边提到的散列表、有序数组、二叉树那样日常见的比较多，但其实 <code>Redis</code> 中的 <code>sort set</code> 就采用了跳表实现。</p>
<p>这里我们简单介绍下跳表实现的数据结构有何优势。</p>
<p>我们都知道即便是对一个<strong>有序链表</strong>进行查询效率也不高，由于它不能使用数组下标进行二分查找，所以时间复杂度是<code>o(n)</code></p>
<p>但我们也可以巧妙的优化链表来变相的实现二分查找，如下图：</p>
<p><img src="https://i.loli.net/2020/08/30/c2Ak7Wt1ZXUbplR.jpg"></p>
<p>我们可以为最底层的数据提取出一级索引、二级索引，根据数据量的不同，我们可以提取出 N 级索引。</p>
<p>当我们查询时便可以利用这里的索引变相的实现了二分查找。</p>
<p>假设现在要查询 <code>id=13</code> 的数据，只需要遍历 <code>1—&gt;7—&gt;10—&gt;13</code> 四个节点便可以查询到数据，当数越多时，效率提升会更明显。</p>
<p>同时区间查询也是支持，和刚才的查询单个节点类似，只需要查询到起始节点，然后依次往后遍历（<strong>链表有序</strong>）到目标节点便能将整个范围的数据查询出来。</p>
<p>同时由于我们在索引上不会存储真正的数据，只是存放一个指针，相对于最底层存放数据的链表来说占用的空间便可以忽略不计了。</p>
<h2 id="平衡二叉树的优化"><a href="#平衡二叉树的优化" class="headerlink" title="平衡二叉树的优化"></a>平衡二叉树的优化</h2><p>但其实 <code>MySQL</code> 中的 <code>Innodb</code> 并没有采用跳表，而是使用的一个叫做 <code>B+</code> 树的数据结构。</p>
<p>这个数据结构不像是二叉树那样大学老师当做基础数据结构经常讲到，由于这类数据结构都是在实际工程中根据需求场景在基础数据结构中演化而来。</p>
<p>比如这里的 <code>B+</code> 树就可以认为是由平衡二叉树演化而来。</p>
<p>刚才我们提到二叉树的区间查询效率不高，针对这一点便可进行优化：</p>
<p><img src="https://i.loli.net/2020/08/30/rajB1GNEzknXWif.jpg"></p>
<p>在原有二叉树的基础上优化后：所有的非叶子都不存放数据，只是作为叶子节点的索引，数据全部都存放在叶子节点。</p>
<p>这样所有叶子节点的数据都是有序存放的，便能很好的支持区间查询。</p>
<p>只需要先通过查询到起始节点的位置，然后在叶子节点中依次往后遍历即可。</p>
<p>当数据量巨大时，很明显索引文件是不能存放于内存中，虽然速度很快但消耗的资源也不小；所以 <code>MySQL</code> 会将索引文件直接存放于磁盘中。</p>
<p>这点和后文提到 elasticsearch 的索引略有不同。</p>
<p>由于索引存放于磁盘中，所以我们要尽可能的减少与磁盘的 IO（磁盘 IO 的效率与内存不在一个数量级）</p>
<p>通过上图可以看出，我们要查询一条数据至少得进行 4 次IO，很明显这个 IO 次数是与树的高度密切相关的，树的高度越低 IO 次数就会越少，同时性能也会越好。</p>
<p>那怎样才能降低树的高度呢？</p>
<p><img src="https://i.loli.net/2020/08/30/f1Ogz5DUMirth2E.jpg">	</p>
<p>我们可以尝试把二叉树变为三叉树，这样树的高度就会下降很多，这样查询数据时的 IO 次数自然也会降低，同时查询效率也会提高许多。</p>
<blockquote>
<p>这其实就是 B+ 树的由来。</p>
</blockquote>
<h2 id="使用索引的一些建议"><a href="#使用索引的一些建议" class="headerlink" title="使用索引的一些建议"></a>使用索引的一些建议</h2><p>其实通过上图对 <code>B+树</code>的理解，也能优化日常工作的一些小细节；比如为什么需要主键是有序递增的？</p>
<p>假设我们写入的主键数据是无序的，那么有可能后写入数据的 id 小于之前写入的，这样在维护 <code>B+树</code> 索引时便有可能需要移动已经写好数据。</p>
<p>如果是按照递增写入数据时则不会有这个考虑，每次只需要依次写入即可。</p>
<blockquote>
<p>所以我们才会要求数据库主键尽量是趋势递增的，不考虑分表的情况时最合理的就是自增主键。</p>
</blockquote>
<p>整体来看思路和跳表类似，只是针对使用场景做了相关的调整（比如数据全部存储于叶子节点）。</p>
<h1 id="ES-索引"><a href="#ES-索引" class="headerlink" title="ES 索引"></a>ES 索引</h1><p><code>MySQL</code> 聊完了，现在来看看 <code>Elasticsearch</code> 是如何来使用索引的。</p>
<h2 id="正排索引"><a href="#正排索引" class="headerlink" title="正排索引"></a>正排索引</h2><p>在 ES 中采用的是一种名叫<code>倒排索引</code>的数据结构；在正式讲倒排索引之前先来聊聊和他相反的<code>正排索引</code>。</p>
<p><img src="https://i.loli.net/2020/08/30/sWL8rjAKxtSMeh2.jpg"></p>
<p>以上图为例，我们可以通过 <code>doc_id</code> 查询到具体对象的方式称为使用<code>正排索引</code>，其实也能理解为一种散列表。</p>
<blockquote>
<p>本质是通过 key 来查找 value。</p>
</blockquote>
<p>比如通过 <code>doc_id=4</code> 便能很快查询到 <code>name=jetty wang,age=20</code> 这条数据。</p>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>那如果反过来我想查询 <code>name</code> 中包含了 <code>li</code> 的数据有哪些？这样如何高效查询呢？</p>
<p>仅仅通过上文提到的正排索引显然起不到什么作用，只能依次将所有数据遍历后判断名称中是否包含 <code>li</code> ；这样效率十分低下。</p>
<p>但如果我们重新构建一个索引结构：</p>
<p><img src="https://i.loli.net/2020/08/30/vuG4wf1ZhaFEAxQ.jpg"></p>
<p>当要查询 <code>name</code> 中包含 <code>li</code> 的数据时，只需要通过这个索引结构查询到 <code>Posting List</code> 中所包含的数据，再通过映射的方式查询到最终的数据。</p>
<p>这个索引结构其实就是<code>倒排索引</code>。</p>
<h2 id="Term-Dictionary"><a href="#Term-Dictionary" class="headerlink" title="Term Dictionary"></a>Term Dictionary</h2><p>但如何高效的在这个索引结构中查询到 <code>li</code> 呢，结合我们之前的经验，只要我们将 <code>Term</code> 有序排列，便可以使用二叉树搜索树的数据结构在<code>o(logn)</code> 下查询到数据。</p>
<p>将一个文本拆分成一个一个独立<code>Term</code> 的过程其实就是我们常说的分词。</p>
<p>而将所有 <code>Term</code> 合并在一起就是一个 <code>Term Dictionary</code>，也可以叫做单词词典。</p>
<ul>
<li>英文的分词相对简单，只需要通过空格、标点符号将文本分隔便能拆词，中文则相对复杂，但也有许多开源工具做支持（由于不是本文重点，对分词感兴趣的可以自行搜索）。</li>
</ul>
<p>当我们的文本量巨大时，分词后的 <code>Term</code> 也会很多，这样一个倒排索引的数据结构如果存放于内存那肯定是不够存的，但如果像 <code>MySQL</code> 那样存放于磁盘，效率也没那么高。</p>
<h2 id="Term-Index"><a href="#Term-Index" class="headerlink" title="Term Index"></a>Term Index</h2><p>所以我们可以选择一个折中的方法，既然无法将整个 <code>Term Dictionary</code> 放入内存中，那我们可以为<code>Term Dictionary</code> 创建一个索引然后放入内存中。</p>
<p>这样便可以高效的查询<code>Term Dictionary</code> ，最后再通过<code>Term Dictionary</code> 查询到 <code>Posting List</code>。</p>
<p>相对于 <code>MySQL</code> 中的 <code>B+树</code>来说也会减少了几次<code>磁盘IO</code>。</p>
<p><img src="https://i.loli.net/2020/08/30/kvPE3we4gp8SAyZ.jpg"></p>
<p>这个 <code>Term Index</code> 我们可以使用这样的 <code>Trie树</code> 也就是我们常说的<code>字典树</code> 来存放。</p>
<p>更多关于字典树的内容请查看<a href="https://crossoverjie.top/2019/01/14/netty/cim02-v1.0.1/">这里</a>。</p>
<p><img src="https://i.loli.net/2020/08/30/4kd7YJVH93Iigjo.jpg"></p>
<p>如果我们是以 <code>j</code> 开头的 <code>Term</code> 进行搜索，首先第一步就是通过在内存中的 <code>Term Index</code> 查询出以 <code>j</code> 打头的 <code>Term</code> 在 <code>Term Dictionary</code> 字典文件中的哪个位置（这个位置可以是一个文件指针，可能是一个区间范围）。</p>
<p>紧接着在将这个位置区间中的所有 <code>Term</code> 取出，由于已经排好序，便可通过二分查找快速定位到具体位置；这样便可查询出 <code>Posting List</code>。</p>
<p>最终通过 <code>Posting List</code> 中的位置信息便可在原始文件中将目标数据检索出来。</p>
<h2 id="更多优化"><a href="#更多优化" class="headerlink" title="更多优化"></a>更多优化</h2><p>当然 <code>ElasticSearch</code> 还做了许多针对性的优化，当我们对两个字段进行检索时，就可以利用 <code>bitmap</code> 进行优化。</p>
<p>比如现在需要查询 <code>name=li and age=18</code> 的数据，这时我们需要通过这两个字段将各自的结果 <code>Posting List</code> 取出。</p>
<p><img src="https://i.loli.net/2020/08/30/EsajWOkZvro2qhz.jpg"></p>
<p>最简单的方法是分别遍历两个集合，取出重复的数据，但这个明显效率低下。</p>
<p>这时我们便可使用 <code>bitmap</code> 的方式进行存储（还节省存储空间），同时利用先天的<code>位与</code> *<em><strong>计算便可得出结果</strong>。</em>*</p>
<p><code>[1, 3, 5]</code>       ⇒ <code>10101</code></p>
<p><code>[1, 2, 4, 5]</code> ⇒ <code>11011</code></p>
<p>这样两个二进制数组求与便可得出结果：</p>
<p><code>10001</code> ⇒ <code>[1, 5]</code></p>
<p>最终反解出 <code>Posting List</code> 为<code>[1, 5]</code>,这样的效率自然是要高上许多。</p>
<p>同样的查询需求在 <code>MySQL</code> 中并没有特殊优化，只是先将数据量小的数据筛选出来之后再筛选第二个字段，效率自然也就没有 <code>ES</code> 高。</p>
<p>当然在最新版的 <code>ES</code> 中也会对 <code>Posting List</code> 进行压缩，具体压缩规则可以查看<a href="https://www.elastic.co/cn/blog/frame-of-reference-and-roaring-bitmaps">官方文档</a>，这里就不具体介绍了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后我们来总结一下：</p>
<p><img src="https://i.loli.net/2020/08/30/qVy9lWMFfnD7KZt.jpg"></p>
<p>通过以上内容可以看出再复杂的产品最终都是基础数据结构组成，只是会对不同应用场景针对性的优化，所以打好数据结构与算法的基础后再看某个新的技术或中间件时才能快速上手，甚至自己就能知道优化方向。</p>
<p>最后画个饼，后续我会尝试按照 <code>ES</code> 倒排索引的思路做一个单机版的搜索引擎，只有自己写一遍才能加深理解。</p>
<blockquote>
<p>更好的阅读体验请访问<a href="https://www.notion.so/ElasticSearch-VS-MySQL-54bddcc092c64c26b2127f1fb9772a23">此处</a>：<a href="https://www.notion.so/ElasticSearch-VS-MySQL-54bddcc092c64c26b2127f1fb9772a23">https://www.notion.so/ElasticSearch-VS-MySQL-54bddcc092c64c26b2127f1fb9772a23</a></p>
</blockquote>
<p><strong>你的点赞与分享是对我最大的支持</strong><br>œ</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Elasticsearch</tag>
        <tag>倒排索引</tag>
        <tag>B+ 树</tag>
      </tags>
  </entry>
  <entry>
    <title>记于 2018 年高考！</title>
    <url>/2018/06/06/exam/2018-06-07-The-university-entrance-exam/</url>
    <content><![CDATA[<h2 id="2012-x2F-02-x2F-28"><a href="#2012-x2F-02-x2F-28" class="headerlink" title="2012&#x2F;02&#x2F;28"></a>2012&#x2F;02&#x2F;28</h2><p><img src="https://i.loli.net/2019/05/08/5cd1d5256dfa7.jpg"></p>
<blockquote>
<p>2012年二月二十八日。</p>
</blockquote>
<p>这天学校举行了<code>高考 100 天誓师大会</code>，当时完全不知道意味着什么，只感觉现场热血沸腾、激情高涨，心里告诉自己就算只剩下 100 天我也能考上清华其次也是北大。</p>
<h2 id="2012-x2F-06-x2F-03"><a href="#2012-x2F-06-x2F-03" class="headerlink" title="2012&#x2F;06&#x2F;03"></a>2012&#x2F;06&#x2F;03</h2><blockquote>
<p>2012年六月三日。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/08/5cd1d528366b0.jpg"></p>
<p>晚自习拿出前段时间刚拍的毕业合照，恨死摄影师，没有抓拍到我最帅的角度😡。</p>
<span id="more"></span>

<h2 id="2012-x2F-06-x2F-04"><a href="#2012-x2F-06-x2F-04" class="headerlink" title="2012&#x2F;06&#x2F;04"></a>2012&#x2F;06&#x2F;04</h2><blockquote>
<p>2012年六月四日。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/08/5cd1d52ded397.jpg"></p>
<p>离校前的最后一晚，我们像往常每周的音乐晚自习一样，由音乐委员（@猪娅）带着大家唱可米小子的青春纪念册。</p>
<p>小红姐（班主任）特别的没来查岗。</p>
<p>心里想着，这就是青春嘛？也不过如此。</p>
<p>大家拿着热和的手机（才发的，平时会收）肆意的拍着照片：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d530ae860.jpg"></p>
<p>那时没有美颜、没有修图，一切都是那么和谐。</p>
<h2 id="2012-x2F-06-x2F-05"><a href="#2012-x2F-06-x2F-05" class="headerlink" title="2012&#x2F;06&#x2F;05"></a>2012&#x2F;06&#x2F;05</h2><blockquote>
<p>2012年六月五日。</p>
</blockquote>
<p>是进津（江津）赶考，走时特地在六食堂买了一个包子，没想到是在学校最后一顿早餐。</p>
<p>车上大家有说有笑，嗯，就像是资深导游带的一个低价旅游团，每人心里充满了惊喜却不知即将面临什么。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d5331159c.jpg"></p>
<h2 id="2012-x2F-06-x2F-07"><a href="#2012-x2F-06-x2F-07" class="headerlink" title="2012&#x2F;06&#x2F;07"></a>2012&#x2F;06&#x2F;07</h2><blockquote>
<p>2012年六月七日。</p>
</blockquote>
<p>大家在各自的考场奋笔疾书，用两天四场考试来为高中三年画上句号。</p>
<p>有的梦想进入理想的大学、和心仪的 <code>TA</code> 长相厮守，当然也有回家继承百万家产😂。</p>
<p>而我当时只想快速的结束这一切，高中三年，特别是高三这年真的是够了。每天做不完的卷子，背不完的诗词，还得想着为陈家老祖宗出一位正儿八经的大学生。</p>
<p>所以考试完全采用人卷合一的心态（能做就做，不会就过）快速的过完了这两天。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d5364e5cc.jpg"></p>
<p>这些作文题目还看得懂嘛。。</p>
<h2 id="2018-x2F-06-x2F-07"><a href="#2018-x2F-06-x2F-07" class="headerlink" title="2018&#x2F;06&#x2F;07"></a>2018&#x2F;06&#x2F;07</h2><blockquote>
<p><strong>2018</strong>年六月七日。</p>
</blockquote>
<p>高中学过许多关于时光飞逝的成语、古诗，但都没有亲身体会那么深刻！</p>
<p>六年时间，红了樱桃，绿了芭蕉。</p>
<p>有的步入职场、升职加薪、求婚成功、穿上婚纱、组建家庭、初为人母。</p>
<p>每人都过着各自的生活，但一旦相见就有数不尽的话题（@江源），逃课打球、翻墙上网、暗恋女神、天天向上、作业卷子。</p>
<p>这句话送给高2012级10班的所有同学：</p>
<p><em><strong>愿你出走半生，归来仍是少年</strong></em></p>
<p>一大波图片即将袭来：</p>
<p>摆拍虽好，不要抽烟哦：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d538da15f.jpg"></p>
<p>小红姐生日快乐，永远十八：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d53fe6643.jpg"></p>
<p>集体生日，年年十八：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d542680ea.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d544d8c0c.jpg"></p>
<p>状元书摊，不是第一不卖：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d54662671.jpg"></p>
]]></content>
      <categories>
        <category>小情绪</category>
      </categories>
  </entry>
  <entry>
    <title>动态代理与RPC</title>
    <url>/2020/04/28/framework-design/dynamic-rpc/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/04/28/mDN2XjShVI4TBLx.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://i.loli.net/2020/04/28/dMDreQw6JAk87Gs.jpg"><br>随着最近关注 <a href="https://github.com/crossoverJie/cim">cim</a> 项目的人越发增多，导致提的问题以及 Bug 也在增加，在修复问题的过程中难免代码洁癖又上来了。</p>
<p>看着一两年前写的东西总是怀疑这真的是出自自己手里嘛？有些地方实在忍不住了便开始了漫漫重构之路。</p>
<span id="more"></span>

<h1 id="前后对比"><a href="#前后对比" class="headerlink" title="前后对比"></a>前后对比</h1><p>在开始之前先简单介绍一下 <code>cim</code> 这个项目，下面是它的架构图：<br><img src="https://i.loli.net/2020/04/28/LfaP3sFtclEoVX5.jpg"></p>
<p>简单来说就是一个 IM 即时通讯系统，主要有以下部分组成：</p>
<ul>
<li><code>IM-server</code> 自然就是服务端了，用于和客户端保持长连接。</li>
<li><code>IM-client</code> 客户端，可以简单认为是类似于的 QQ 这样的客户端工具；当然功能肯定没那么丰富，只提供了一些简单消息发送、接收的功能。</li>
<li><code>Route</code> 路由服务，主要用于客户端鉴权、消息的转发等；提供一些 http 接口，可以用于查看系统状态、在线人数等功能。</li>
</ul>
<p>当然服务端、路由都可以水平扩展。</p>
<hr>
<p><img src="https://i.loli.net/2020/04/28/eBumPJbrvyQsHTF.jpg"></p>
<p>这是一个消息发送的流程图，假设现在部署了两个服务端 A、B 和一个路由服务；其中 <code>ClientA</code> 和 <code>ClientB</code> 分别和服务端 A、B 保持了长连接。</p>
<p>当 <code>ClientA</code> 向 <code>ClientB</code> 发送一个 <code>hello world</code> 时，整个的消息流转如图所示：</p>
<ol>
<li>先通过 <code>http</code> 将消息发送到 <code>Route</code> 服务。</li>
<li>路由服务得知 <code>ClientB</code> 是连接在 <code>ServerB</code> 上；于是再通过 <code>http</code> 将消息发送给 <code>ServerB</code>。</li>
<li>最终 <code>ServerB</code> 将消息通过与 <code>ClientB</code> 的长连接通道 <code>push</code> 下去，至此消息发送成功。</li>
</ol>
<p>这里我截取了 <code>ClientA</code> 向 <code>Route</code> 发起请求的代码：<br><img src="https://i.loli.net/2020/04/28/7FRrUh1o4GPJCuI.jpg"><br>可以看到这就是利用 <code>okhttp</code> 发起了一个 <code>http</code> 请求，这样虽然能实现功能，但其实并不优雅。</p>
<p>举个例子：假设我们需要对接支付宝的接口，这里发送一个 http 请求自然是没问题；但对于支付宝内部各部门直接互相调用接口时那就不应该再使用原始的 http 请求了。</p>
<p>应该是由服务提供方提供一个 <code>api</code> 包，服务消费者只需要依赖这个包就可以实现接口调用。</p>
<blockquote>
<p>当然最终使用的是 http、还是自定义私有协议都可以。</p>
</blockquote>
<p>也类似于我们在使用 <code>Dubbo</code> 或者是 <code>SpringCloud</code> 时，通常是直接依赖一个 <code>api</code> 包，便可以像调用一个本地方法一样调用远程服务了，并且完全屏蔽了底层细节，不管是使用的 http 还是 其他私有协议都没关系，对于调用者来说完全不关心。</p>
<p>这么一说是不是有内味了，这不就是 RPC 的官方解释嘛。</p>
<p>对应到这里也是同样的道理，<code>Client</code> 、<code>Route</code>、<code>Server</code> 本质上都是一个系统，他们互相的接口调用也应当是走 <code>RPC</code> 才合理。</p>
<p>所以我重构之后的变成这样了：</p>
<p><img src="https://i.loli.net/2020/04/28/R4sqwHxAMYmz7f9.jpg"></p>
<p>是不是代码也简洁了许多，就和调用本地方法一样了，而且这样也有几个好处：</p>
<ul>
<li>完全屏蔽了底层细节，可以更好的实现业务及维护代码。</li>
<li>即便是服务提供方修改了参数，在编译期间就能很快发现，而像之前那样调用是完全不知情的，所以也增加了风险。</li>
</ul>
<h1 id="绕不开的动态代理"><a href="#绕不开的动态代理" class="headerlink" title="绕不开的动态代理"></a>绕不开的动态代理</h1><p>下面来聊聊具体是如何实现的。</p>
<p>其实在上文<a href="https://crossoverjie.top/2020/03/30/wheel/cicada9-proxy/">《动态代理的实际应用》</a> 中也有讲到，原理是类似的。</p>
<p>要想做到对调用者无感知，就得创建一个接口的代理对象；在这个代理对象中实现编码、调用、解码的过程。</p>
<p><img src="https://i.loli.net/2020/04/28/REoaJPXzOlmBjnK.jpg"></p>
<p>对应到此处其实就是创建一个 <code>routeApi</code> 的代理对象，关键就是这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RouteApi</span> <span class="variable">routeApi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyManager</span>&lt;&gt;(RouteApi.class, routeUrl, okHttpClient).getInstance();</span><br></pre></td></tr></table></figure>

<p>完整源码如下：<br><img src="https://i.loli.net/2020/04/28/Z3aJOxrDyeNqzo2.jpg"></p>
<p>其中的 <code>getInstance()</code> 函数就是返回了需要被代理的接口对象；而其中的 <code>ProxyInvocation</code> 则是一个实现了 <code>InvocationHandler</code> 接口的类，这套代码就是利用 <code>JDK</code> 实现动态代理的三板斧。</p>
<p><img src="https://i.loli.net/2020/04/28/N6CoDig2SHjb7lI.jpg"></p>
<p>查看 <code>ProxyInvocation</code> 的源码会发现当我们调用被代理接口的任意一个方法时，都会执行这里的 <code>invoke()</code> 方法。</p>
<p>而 <code>invoke()</code> 方法自然就实现了上图中提到的：编码、远程调用、解码的过程；相信大家很容易看明白，由于不是本次探讨的重点就不过多介绍了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实理解这些就也就很容易看懂 <code>Dubbo</code> 这类 <code>RPC</code> 框架的核心源码了，总体的思路也是类似的，只不过使用的私有协议，所以在编解码时会有所不同。</p>
<p>所以大家要是想自己动手实现一个 <code>RPC</code> 框架，不妨参考这个思路试试，当用自己写的代码跑通一个 <code>RPC</code> 的 <code>helloworld</code> 时的感觉是和自己整合了一个 <code>Dubbo</code>、<code>SpringCloud</code> 这样的第三方框架的感觉是完全不同的。</p>
<p>本文的所有源码：</p>
<p><a href="https://github.com/crossoverJie/cim">https://github.com/crossoverJie/cim</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>cim</category>
        <category>rpc</category>
        <category>动态代理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>5分钟学会 gRPC</title>
    <url>/2022/03/08/framework-design/grpc/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2022/03/13/EvoDe9JNqPLHwdF.jpg"></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>我猜测大部分长期使用 <code>Java</code> 的开发者应该较少会接触 <code>gRPC</code>，毕竟在 <code>Java</code> 圈子里大部分使用的还是 <code>Dubbo/SpringClound</code> 这两类服务框架。</p>
<p>我也是近段时间有机会从零开始重构业务才接触到 <code>gRPC</code> 的，当时选择 <code>gRPC</code> 时也有几个原因：</p>
<p><img src="https://s2.loli.net/2022/03/13/XCYkMxjpUgvZE5L.jpg"></p>
<ul>
<li>基于云原生的思路开发部署项目，而在云原生中 <code>gRPC</code> 几乎已经是标准的通讯协议了。</li>
<li>开发语言选择了 Go，在 Go 圈子中 <code>gRPC</code> 显然是更好的选择。</li>
<li>公司内部有部分业务使用的是 <code>Python</code> 开发，在多语言兼容性上 <code>gRPC</code> 支持的非常好。</li>
</ul>
<span id="more"></span>

<p>经过线上一年多的平稳运行，可以看出 <code>gRPC</code> 还是非常稳定高效的；rpc 框架中最核心的几个要点：</p>
<ul>
<li>序列化</li>
<li>通信协议</li>
<li>IDL（接口描述语言）</li>
</ul>
<p>这些在 <code>gRPC</code> 中分别对应的是：</p>
<ul>
<li>基于 <code>Protocol Buffer</code> 序列化协议，性能高效。</li>
<li>基于 <code>HTTP/2</code> 标准协议开发，自带 <code>stream</code>、多路复用等特性；同时由于是标准协议，第三方工具的兼容性会更好（比如负载均衡、监控等）</li>
<li>编写一份 <code>.proto</code> 接口文件，便可生成常用语言代码。</li>
</ul>
<h1 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h1><p>学习 <code>gRPC</code> 之前首先得知道它是通过什么协议通信的，我们日常不管是开发还是应用基本上接触到最多的还是 <code>HTTP/1.1</code> 协议。</p>
<p><img src="https://s2.loli.net/2022/03/13/r6w2Yvi9dkPqKEW.jpg"></p>
<p>由于 <code>HTTP/1.1</code> 是一个文本协议，对人类非常友好，相反的对机器性能就比较低。</p>
<p>需要反复对文本进行解析，效率自然就低了；要对机器更友好就得采用二进制，<code>HTTP/2</code> 自然做到了。</p>
<p>除此之外还有其他优点：</p>
<ul>
<li>多路复用：可以并行的收发消息，互不影响</li>
<li><code>HPACK</code> 节省 <code>header</code> 空间，避免 <code>HTTP1.1</code> 对相同的 <code>header</code> 反复发送。</li>
</ul>
<h1 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h1><p><code>gRPC</code> 采用的是 <code>Protocol</code> 序列化，发布时间比 <code>gRPC</code> 早一些，所以也不仅只用于 <code>gRPC</code>，任何需要序列化 IO 操作的场景都可以使用它。</p>
<p>它会更加的省空间、高性能；之前在开发 <a href="https://github.com/crossoverJie/cim/blob/master/protocol/BaseRequestProto.proto">https://github.com/crossoverJie/cim</a> 时就使用它来做数据交互。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package order.v1;</span><br><span class="line"></span><br><span class="line">service OrderService&#123;</span><br><span class="line"></span><br><span class="line">  rpc Create(OrderApiCreate) returns (Order) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  rpc Close(CloseApiCreate) returns (Order) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // 服务端推送</span><br><span class="line">  rpc ServerStream(OrderApiCreate) returns (stream Order) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // 客户端推送</span><br><span class="line">  rpc ClientStream(stream OrderApiCreate) returns (Order) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  // 双向推送</span><br><span class="line">  rpc BdStream(stream OrderApiCreate) returns (stream Order) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message OrderApiCreate&#123;</span><br><span class="line">  int64 order_id = 1;</span><br><span class="line">  repeated int64 user_id = 2;</span><br><span class="line">  string remark = 3;</span><br><span class="line">  repeated int32 reason_id = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用起来也是非常简单的，只需要定义自己的 <code>.proto</code> 文件，便可用命令行工具生成对应语言的 SDK。</p>
<p>具体可以参考官方文档：<br><a href="https://grpc.io/docs/languages/go/generated-code/">https://grpc.io/docs/languages/go/generated-code/</a></p>
<h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative \</span><br><span class="line">   --go-grpc_out=. --go-grpc_opt=paths=source_relative \</span><br><span class="line">   test.proto</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/13/vAahTlgs54Pem7c.jpg"><br>生成代码之后编写服务端就非常简单了，只需要实现生成的接口即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order)</span></span> Create(ctx context.Context, in *v1.OrderApiCreate) (*v1.Order, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 获取 metadata</span></span><br><span class="line">	md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.DataLoss, <span class="string">&quot;failed to get metadata&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(md)</span><br><span class="line">	fmt.Println(in.OrderId)</span><br><span class="line">	<span class="keyword">return</span> &amp;v1.Order&#123;</span><br><span class="line">		OrderId: in.OrderId,</span><br><span class="line">		Reason:  <span class="literal">nil</span>,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/03/13/wWJQ7Rv5BnqPrjo.jpg"></p>
<p>客户端也非常简单，只需要依赖服务端代码，创建一个 <code>connection</code> 然后就和调用本地方法一样了。</p>
<p>这是经典的 <code>unary</code>(一元)调用，类似于 http 的请求响应模式，一个请求对应一次响应。</p>
<p><img src="https://s2.loli.net/2022/03/13/cxF2Xlj4BuWOEbz.jpg"></p>
<h2 id="Server-stream"><a href="#Server-stream" class="headerlink" title="Server stream"></a>Server stream</h2><p><code>gRPC</code> 除了常规的 <code>unary</code> 调用之外还支持服务端推送，在一些特定场景下还是很有用的。</p>
<p><img src="https://s2.loli.net/2022/03/13/jz2CwFvfR6iuTMt.jpg"> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order)</span></span> ServerStream(in *v1.OrderApiCreate, rs v1.OrderService_ServerStreamServer) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		rs.Send(&amp;v1.Order&#123;</span><br><span class="line">			OrderId: in.OrderId,</span><br><span class="line">			Reason:  <span class="literal">nil</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端的推送如上所示，调用 <code>Send</code> 函数便可向客户端推送。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	msg, err := rpc.RecvMsg()</span><br><span class="line">	<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">		marshalIndent, _ := json.MarshalIndent(msgs, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">		fmt.Println(msg)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端则通过一个循环判断当前接收到的数据包是否已经截止来获取服务端消息。</p>
<p>为了能更直观的展示这个过程，优化了之前开发的一个 <code>gRPC</code> <a href="https://github.com/crossoverJie/ptg">客户端</a>，可以直观的调试 <code>stream</code> 调用。</p>
<p><img src="https://s2.loli.net/2022/03/13/zqTm3bgysJcMEeZ.gif"></p>
<blockquote>
<p>上图便是一个服务端推送示例。</p>
</blockquote>
<h2 id="Client-Stream"><a href="#Client-Stream" class="headerlink" title="Client Stream"></a>Client Stream</h2><p><img src="https://s2.loli.net/2022/03/13/rkSeCNVEzJ26sMd.jpg"></p>
<p>除了支持服务端推送之外，客户端也支持。</p>
<blockquote>
<p>客户端在同一个连接中一直向服务端发送数据，服务端可以并行处理消息。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 服务端代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order)</span></span> ClientStream(rs v1.OrderService_ClientStreamServer) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> value []<span class="type">int64</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		recv, err := rs.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			rs.SendAndClose(&amp;v1.Order&#123;</span><br><span class="line">				OrderId: <span class="number">100</span>,</span><br><span class="line">				Reason:  <span class="literal">nil</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">			log.Println(value)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		value = <span class="built_in">append</span>(value, recv.OrderId)</span><br><span class="line">		log.Printf(<span class="string">&quot;ClientStream receiv msg %v&quot;</span>, recv.OrderId)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">&quot;ClientStream finish&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 客户端代码</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		messages, _ := GetMsg(data)</span><br><span class="line">		rpc.SendMsg(messages[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	receive, err := rpc.CloseAndReceive()</span><br></pre></td></tr></table></figure>

<p>代码与服务端推送类似，只是角色互换了。</p>
<p><img src="https://s2.loli.net/2022/03/13/lZzfH8yq3MGwKa9.gif"></p>
<h2 id="Bidirectional-Stream"><a href="#Bidirectional-Stream" class="headerlink" title="Bidirectional Stream"></a>Bidirectional Stream</h2><p><img src="https://s2.loli.net/2022/03/13/Le2OdbBN1DGScg6.jpg"></p>
<p>同理，当客户端、服务端同时都在发送消息也是支持的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order)</span></span> BdStream(rs v1.OrderService_BdStreamServer) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> value []<span class="type">int64</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		recv, err := rs.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			log.Println(value)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		value = <span class="built_in">append</span>(value, recv.OrderId)</span><br><span class="line">		log.Printf(<span class="string">&quot;BdStream receiv msg %v&quot;</span>, recv.OrderId)</span><br><span class="line">		rs.SendMsg(&amp;v1.Order&#123;</span><br><span class="line">			OrderId: recv.OrderId,</span><br><span class="line">			Reason:  <span class="literal">nil</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		messages, _ := GetMsg(data)</span><br><span class="line">		<span class="comment">// 发送消息</span></span><br><span class="line">		rpc.SendMsg(messages[<span class="number">0</span>])</span><br><span class="line">		<span class="comment">// 接收消息</span></span><br><span class="line">		receive, _ := rpc.RecvMsg()</span><br><span class="line">		marshalIndent, _ := json.MarshalIndent(receive, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">		fmt.Println(<span class="type">string</span>(marshalIndent))</span><br><span class="line">	&#125;</span><br><span class="line">	rpc.CloseSend()</span><br></pre></td></tr></table></figure>

<p>其实就是将上诉两则合二为一。</p>
<p><img src="https://s2.loli.net/2022/03/13/Lxy7dhbD8ewlpUf.gif"></p>
<p>通过调用示例很容易理解。</p>
<h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p><code>gRPC</code> 也支持元数据传输，类似于 <code>HTTP</code> 中的 <code>header</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端写入</span></span><br><span class="line">metaStr := <span class="string">`&#123;&quot;lang&quot;:&quot;zh&quot;&#125;`</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">err := json.Unmarshal([]<span class="type">byte</span>(metaStr), &amp;m)</span><br><span class="line">md := metadata.New(m)</span><br><span class="line"><span class="comment">// 调用时将 ctx 传入即可</span></span><br><span class="line">ctx := metadata.NewOutgoingContext(context.Background(), md)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端接收</span></span><br><span class="line">md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.DataLoss, <span class="string">&quot;failed to get metadata&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(md)	</span><br></pre></td></tr></table></figure>

<h2 id="gRPC-gateway"><a href="#gRPC-gateway" class="headerlink" title="gRPC gateway"></a>gRPC gateway</h2><p><code>gRPC</code> 虽然功能强大使用也很简单，但对于浏览器、APP的支持还是不如 REST 应用广泛（浏览器也支持，但应用非常少）。</p>
<p>为此社区便创建了 <a href="https://github.com/grpc-ecosystem/grpc-gateway">https://github.com/grpc-ecosystem/grpc-gateway</a> 项目，可以将 gRPC 服务暴露为 RESTFUL API。</p>
<p><img src="https://s2.loli.net/2022/03/13/Gt2sRplIADyvTHg.jpg"></p>
<blockquote>
<p>为了让测试可以习惯用 postman 进行接口测试，我们也将 gRPC 服务代理出去，更方便的进行测试。</p>
</blockquote>
<h2 id="反射调用"><a href="#反射调用" class="headerlink" title="反射调用"></a>反射调用</h2><p>作为一个 rpc 框架，泛化调用也是必须支持的，可以方便开发配套工具；gRPC 是通过反射支持的，通过拿到服务名称、pb 文件进行反射调用。</p>
<p><a href="https://github.com/jhump/protoreflect">https://github.com/jhump/protoreflect</a> 这个库封装了常见的反射操作。</p>
<p>上图中看到的可视化 <code>stream</code> 调用也是通过这个库实现的。</p>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>由于 <code>gRPC</code> 是基于 <code>HTTP/2</code> 实现的，客户端和服务端会保持长连接；这时做负载均衡就不像是 <code>HTTP</code> 那样简单了。</p>
<p>而我们使用 <code>gRPC</code> 想达到效果和 HTTP 是一样的，需要对请求进行负载均衡而不是连接。</p>
<p>通常有两种做法：</p>
<ul>
<li>客户端负载均衡</li>
<li>服务端负载均衡</li>
</ul>
<p>客户端负载均衡在 <code>rpc</code> 调用中应用广泛，比如 <code>Dubbo</code> 就是使用的客户端负载均衡。</p>
<p><code>gRPC</code> 中也提供有相关接口，具体可以参考官方demo。</p>
<p><a href="https://github.com/grpc/grpc-go/blob/87eb5b7502/examples/features/load_balancing/README.md">https://github.com/grpc/grpc-go/blob/87eb5b7502/examples/features/load_balancing&#x2F;README.md</a></p>
<p>客户端负载均衡相对来说对开发者更灵活（可以自定义适合自己的策略），但相对的也需要自己维护这块逻辑，如果有多种语言那就得维护多份。</p>
<p>所以在云原生这个大基调下，更推荐使用服务端负载均衡。</p>
<p>可选方案有：</p>
<ul>
<li>istio</li>
<li>envoy</li>
<li>apix</li>
</ul>
<p>这块我们也在研究，大概率会使用 <code>envoy/istio</code>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>gRPC</code> 内容还是非常多的，本文只是作为一份入门资料希望能让不了解 <code>gRPC</code> 的能有一个基本认识；这在云原生时代确实是一门必备技能。</p>
<blockquote>
<p>对文中的 gRPC 客户端感兴趣的朋友，可以参考这里的源码：<br><a href="https://github.com/crossoverJie/ptg">https://github.com/crossoverJie/ptg</a></p>
</blockquote>
]]></content>
      <categories>
        <category>framework</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>分表后需要注意的二三事</title>
    <url>/2019/06/13/framework-design/sharding-db-02/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/06/13/5d012e6a6fd7729354.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇是上一篇<a href="https://crossoverjie.top/2019/04/16/framework-design/sharding-db/">《一次分表踩坑实践的探讨》</a>，所以还没看过的朋友建议先看上文。</p>
<p>还是先来简单回顾下上次提到了哪些内容：</p>
<ul>
<li>分表策略：哈希、时间归档等。</li>
<li>分表字段的选择。</li>
<li>数据迁移方案。</li>
</ul>
<span id="more"></span>

<p>而本篇文章的背景是在我们上线这段时间遇到的一些问题并尝试解决的方案。</p>
<h1 id="问题产生"><a href="#问题产生" class="headerlink" title="问题产生"></a>问题产生</h1><p>之前提到在分表应用上线前我们需要将原有表的数据迁移到新表中，这样才能保证业务不受影响。</p>
<p><img src="https://i.loli.net/2019/06/13/5d0126128f1e678414.jpg"></p>
<p>所以我们单独写了一个迁移应用，它负责将大表中的数据迁移到 64 张分表，而再迁移过程中产生的数据毕竟是少数，最后在上线当晚再次迁移过去即可。</p>
<p>一切想的很美好，当这个应用上线后却发现没这么简单。</p>
<h2 id="数据库负载升高"><a href="#数据库负载升高" class="headerlink" title="数据库负载升高"></a>数据库负载升高</h2><p>首先第一个问题是数据库自己就顶不住了，在我们上这个迁移程序之前数据库的压力本身就比较大，这个应用一上去就成了最后一根稻草。</p>
<p>最后导致的结果是：所有连接了数据库的程序大部分的操作都出现超时，获取不到数据库连接等一系列的异常。</p>
<p>最后没办法我们只能把这个应用放到凌晨执行，但其实后面观察发现依然不行。</p>
<p>虽说凌晨的业务量下降，但依然有少部分的请求过来，也会出现各种数据库异常。</p>
<p>再一个是迁移程序的效率也非常低下，按照这样是速度，我们预估了一下迁移时间，大约需要 10 几天才能把三张最大的表（3、4亿的数据）迁移到分表中。</p>
<p>于是我们换了一个方案，将这个迁移程序在从库中运行，最后再用运维的方法将分表直接导入进主库。</p>
<p>因为从库的压力要比主库小很多，对业务的影响很小，同时迁移的效率也要快很多。</p>
<p>即便是这样也花了一晚上+一个白天的时间才将一张 1亿的数据迁移完成，但是业务上的压力越来越大，数据量再不断新增，这个效率依然不够。</p>
<h1 id="兼容方案"><a href="#兼容方案" class="headerlink" title="兼容方案"></a>兼容方案</h1><p>最终没办法只有想一个不迁移数据的方案，但是新产生的数据还是往分表里写，至少保证大表的数据不再新增。</p>
<p>但这样对于以前的数据咋办呢？总不能不让看了吧。</p>
<p>其实对于数据的操作无非就分为<code>增删改查</code>，就这四种操作来看看如何兼容。</p>
<h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><p><img src="https://i.loli.net/2019/06/13/5d012612de57f13422.jpg"></p>
<p>新增最简单，所有的数据根据分表规则直接写入新表，这样可以保证老表的数据不再新增。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除就要比新增稍微复杂一些，比如用户想要删除他个人产生的一条信息（比如说是订单数据），有可能这个数据在新表也可能在老表。</p>
<p><img src="https://i.loli.net/2019/06/13/5d01261336daf24547.jpg"></p>
<p>所以删除时优先删除新表（毕竟新产生的数据访问的频次越高），如果删除失败再从老表删除一次。</p>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p><img src="https://i.loli.net/2019/06/13/5d01261380d6599845.jpg"></p>
<p>而修改同理，同样的会不确定数据存在于哪里，所以先要修改新表，失败后再次修改老表。</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>查询相对就要复杂一些了，因为这些大表的数据大部分都是存放一个用户产生的多条记录（比如一个用户的订单信息）。</p>
<p>这时在页面上通常都会有分页，并且按照时间进行排序。</p>
<p>麻烦的地方就出在这里：既然是要分页那就有可能出现要查询一部分分表数据和原来的大表数据做组合。</p>
<p>所以这里的查询其实分为三种情况。</p>
<p><img src="https://i.loli.net/2019/06/13/5d012613da28015150.jpg"></p>
<ul>
<li>首先查询的时候要计算这个用户所在分表中的数据可以分为几页。</li>
<li>第一步首先判断当前页是否可以在分表中全部获取，如果可以则直接从分表中取出数据返回（假设分页中总共可以查询 2 页数据，当前为第 1 页，那就全部取分表数据）。</li>
<li>如果不可以就要判断当前页数在分表中是否取不到任何一条数据，如果是则直接取老表数据（比如现在要取第 5 页的数据，分表中一共才只有 2 页数据，所以第 5 页数据只能全部从老表中获取）。</li>
<li>但如果分表和老表都存在一部分数据时，则需要同时取两张表然后做一个汇总再返回。</li>
</ul>
<p><strong>这种逻辑只适用于根据分表字段进行查询分页的前提下</strong></p>
<hr>
<p>我想肯定会有朋友提出这样是否会有性能问题？</p>
<p>同时如果在计算分表分页数量时出现并发写入的情况，导致分页数量不准从而对后续的查询出现影响该怎么处理？</p>
<p>首先第一个性能问题：</p>
<p>其实这个要看怎么取舍，为了这样的兼容目的其实会比常规查询多出几个步骤：</p>
<ul>
<li>判断当前页是否可以在分表中查询。</li>
<li>当新老表中都有数据时候需要额外多查询一张大表。</li>
</ul>
<p>第一个判断逻辑其实是在内存中计算，这个损耗我觉得完全可以忽略不计。</p>
<p>至于第二步确实会有损耗，毕竟多查了一张表。</p>
<p>但在分表之前所有的数据都是从老表中获取的，当时的业务也没有出现问题；现在多的只是查询分表而已，但分表的数据量肯定要比大表小的多，而且有索引，所以这个效率也不会慢多少。</p>
<p>而且根据局部性原理及用户的使用习惯来看，老表中的数据很少会去查询，随着时间的推移所有的数据肯定都会从分表中获取，逐渐老表就会成为历史表。</p>
<p>而第二个并发带来的问题我觉得影响也不大，一定要这个分页准的前提肯定得是加锁了，但为了这样一个不痒的小问题却带来性能的下降，我觉得是不划算的。</p>
<p>而且后续我们也可以慢慢的将老表的数据迁移到新表，这样就可以完全去掉这个兼容逻辑了，所有的数据都从分表中获取。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还是之前那句话，这里的各种操作、方法不适合所有人，毕竟脱离场景都是耍牛氓。</p>
<p>比如分表搞的早，业务上允许一定的时间将数据迁移到分表那就不会有这次的兼容处理。</p>
<p>甚至一开始业务规划合理、团队架构师看的长远，一来就将关键数据分表存储那根本就不会有数据迁移这个流程（大厂有经验的团队可能，小公司小作坊都得靠自己摸索）。</p>
<p>这段期间也被数据库折腾惨了，数据库是最后一根稻草果然也不是瞎说的。</p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>一次难得的分库分表实践</title>
    <url>/2019/07/24/framework-design/sharding-db-03/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/07/25/5d39840d169ae80383.jpg"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前不久发过两篇关于分表的文章：</p>
<ul>
<li><a href="https://crossoverjie.top/2019/04/16/framework-design/sharding-db/">一次分表踩坑实践的探讨</a></li>
<li><a href="https://crossoverjie.top/2019/06/13/framework-design/sharding-db-02/">分表后需要注意的二三事</a></li>
</ul>
<p>从标题可以看得出来，当时我们只做了分表；还是由于业务发展，截止到现在也做了分库，目前看来都还比较顺利，所以借着脑子还记得清楚来一次复盘。</p>
<span id="more"></span>

<p>先来回顾下整个分库分表的流程如下：</p>
<p><img src="https://i.loli.net/2019/07/25/5d39840dd28fd13220.jpg"></p>
<p>整个过程也很好理解，基本符合大部分公司的一个发展方向。</p>
<p>很少会有业务一开始就会设计为分库分表，虽说这样会减少后续的坑，但部分公司刚开始都是以业务为主。</p>
<p>直到业务发展到单表无法支撑时，自然而然会考虑分表甚至分库的事情。</p>
<p>于是本篇会作一次总结，之前提过的内容可能会再重复一次。</p>
<h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><p>首先讨论下什么样的情况下适合分表？</p>
<p>根据我的经验来看，当某张表的数据量已经达到千万甚至上亿，同时日增数据量在 2% 以上。</p>
<p>当然这些数字并不是绝对的，最重要的还是对这张表的写入和查询都已经影响到正常业务执行，比如查询速度明显下降，数据库整体 IO 居高不下等。</p>
<p>而谈到分表时我们着重讨论的还是水平分表；</p>
<p><img src="https://i.loli.net/2019/06/13/5d0126128f1e678414.jpg"></p>
<p>也就是将一张大表数据通过某种路由算法将数据尽可能的均匀分配到 N 张小表中。</p>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p>而分表策略也有好几种，分别适用不同的场景。</p>
<p>首先第一种是按照范围划分，比如我们可以将某张表的创建时间按照日期划分存为月表；也可以将某张表的主键按照范围划分，比如 【1<del>10000】在一张表，【10001</del>20000】在一张表，以此类推。</p>
<p><img src="https://i.loli.net/2019/07/25/5d39840e3a15251220.jpg"></p>
<p>这样的分表适合需要对数据做归档处理，比如系统默认只提供近三个月历史数据的查询功能，这样也方便操作；只需要把三月之前的数据单独移走备份保存即可）。</p>
<p>这个方案有好处也有弊端：</p>
<ul>
<li>好处是自带水平扩展，不需要过多干预。</li>
<li>缺点是可能会出现数据不均匀的情况（比如某个月请求暴增）。</li>
</ul>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>按照日期这样的范围分表固然简单，但适用范围还是比较窄；毕竟我们大部分的数据查询都不想带上时间。</p>
<p>比如某个用户想查询他产生的所有订单信息，这是很常见的需求。</p>
<p>于是我们分表的维度就得改改，分表算法可以采用主流的 <code>hash+mod</code> 的组合。</p>
<p>这是一个经典的算法，大名鼎鼎的 <code>HashMap</code> 也是这样来存储数据。</p>
<p>假设我们这里将原有的一张大表订单信息分为 64 张分表：</p>
<p><img src="https://i.loli.net/2019/07/25/5d39840e7691e58337.jpg"></p>
<p>这里的 <code>hash</code> 便是将我们需要分表的字段进行一次散列运算，使得经过散列的数据尽可能的均匀并且不重复。</p>
<p>当然如果本身这个字段就是一个整形并且不重复也可以省略这个步骤，直接进行 <code>Mod</code> 得到分表下标即可。</p>
<h3 id="分表数量选择"><a href="#分表数量选择" class="headerlink" title="分表数量选择"></a>分表数量选择</h3><p>至于这里的分表数量（64）也是有讲究的，具体设为多少这个没有标准值，需要根据自身业务发展，数据增量进行预估。</p>
<p>根据我个人的经验来看，至少需要保证分好之后的小表在业务发展的几年之内都不会出现单表数据量过大（比如达到千万级）。</p>
<p>我更倾向于在数据库可接受的范围内尽可能的增大这个分表数，毕竟如果后续小表也达到瓶颈需要再进行一次分表扩容，那是非常痛苦的。</p>
<blockquote>
<p>目前笔者还没经历这一步，所以本文没有相关介绍。</p>
</blockquote>
<p>但是这个数量又不是瞎选的，和 <code>HashMap</code> 一样，也建议得是 <code>2^n</code>，这样可以方便在扩容的时尽可能的少迁移数据。</p>
<h2 id="Range-Hash"><a href="#Range-Hash" class="headerlink" title="Range + Hash"></a>Range + Hash</h2><p>当然还有一种思路，<code>Range</code> 和 <code>Hash</code> 是否可以混用。</p>
<p>比如我们一开始采用的是 Hash 分表，但是数据增长巨大，导致每张分表数据很快达到瓶颈，这样就不得不再做扩容，比如由 64 张表扩容到 256 张。</p>
<p>但扩容时想要做到不停机迁移数据非常困难，即便是停机，那停多久呢？也不好说。</p>
<p>所以我们是否可以在 <code>Mod</code> 分表的基础上再分为月表，借助于 <code>Range</code> 自身的扩展性就不用考虑后续数据迁移的事情了。</p>
<p><img src="https://i.loli.net/2019/07/25/5d39840eedaf273526.jpg"></p>
<p>这种方式理论可行，但我没有实际用过，给大家的思路做个参考吧。</p>
<h2 id="烦人的数据迁移"><a href="#烦人的数据迁移" class="headerlink" title="烦人的数据迁移"></a>烦人的数据迁移</h2><p>分表规则弄好后其实只是完成了分表的第一步，真正麻烦的是数据迁移，或者说是如何做到对业务影响最小的数据迁移。</p>
<p>除非是一开始就做了分表，所以数据迁移这一步骤肯定是跑不掉的。</p>
<p>下面整理下目前我们的做法供大家参考：</p>
<ol>
<li>一旦分表上线后所有的数据写入、查询都是针对于分表的，所以原有大表内的数据必须得迁移到分表里，不然对业务的影响极大。</li>
<li>我们估算了对一张 2 亿左右的表进行迁移，自己写的迁移程序，大概需要花 4~5 天的时间才能完成迁移。</li>
<li>意味着这段时间内，以前的数据对用户是不可见的，显然这样业务不能接受。</li>
<li>于是我们做了一个兼容处理：分表改造上线后，所有新产生的数据写入分表，但对历史数据的操作还走老表，这样就少了数据迁移这一步骤。</li>
<li>只是需要在操作数据之前做一次路由判断，当新数据产生的足够多时（我们是两个月时间），几乎所有的操作都是针对于分表，再从库启动数据迁移，数据迁移完毕后将原有的路由判断去掉。</li>
<li>最后所有的数据都从分表产生和写入。</li>
</ol>
<p>至此整个分表操作完成。</p>
<p><img src="https://i.loli.net/2019/07/25/5d39840f3b3d054411.jpg"></p>
<p><img src="https://i.loli.net/2019/07/25/5d39840f6b9fd31724.jpg"></p>
<h2 id="业务兼容"><a href="#业务兼容" class="headerlink" title="业务兼容"></a>业务兼容</h2><p>同时分表之后还需要兼容其他业务；比如原有的报表业务、分页查询等，现在来看看我们是如何处理的。</p>
<h3 id="报表"><a href="#报表" class="headerlink" title="报表"></a>报表</h3><p>首先是报表，没分表之前之间查询一张表就搞定了，现在不同，由一张表变为 N 张表。</p>
<p>所以原有的查询要改为遍历所有的分表，考虑到性能可以利用多线程并发查询分表数据然后汇总。</p>
<p>不过只依靠 <code>Java</code> 来对这么大量的数据做统计分析还是不现实，刚开始可以应付过去，后续还得用上大数据平台来处理。</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>再一个是查询，原有的分页查询肯定是不能用了，毕竟对上亿的数据分页其实没什么意义。</p>
<p>只能提供通过分表字段的查询，比如是按照订单 ID 分表，那查询条件就得带上这个字段，不然就会涉及到遍历所有表。</p>
<p>这也是所有分表之后都会遇到的一个问题，除非不用 <code>MySQL</code> 这类关系型数据库。</p>
<h1 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h1><p>分表完成后可以解决单表的压力，但数据库本身的压力却没有下降。</p>
<p>我们在完成分表之后的一个月内又由于数据库里“其他表”的写入导致整个数据库 IO 增加，而且这些“其他表”还和业务关系不大。</p>
<p>也就是说一些可有可无的数据导致了整体业务受影响，这是非常不划算的事情。</p>
<p>于是我们便把这几张表单独移到一个新的数据库中，完全和现有的业务隔离开来。</p>
<p>这样就会涉及到几个改造：</p>
<ol>
<li>应用自身对这些数据的查询、写入都要改为调用一个独立的 <code>Dubbo</code> 服务，由这个服务对迁移的表进行操作。</li>
<li>暂时不做数据迁移，所以查询时也得按照分表那样做一个兼容，如果查询老数据就要在当前库查询，新数据就要调用 <code>Dubbo</code> 接口进行查询。</li>
<li>对这些表的一些关联查询也得改造为查询 <code>Dubbo</code> 接口，在内存中进行拼接即可。</li>
<li>如果数据量确实很大，也可将同步的 <code>Dubbo</code> 接口换为写入消息队列来提高吞吐量。</li>
</ol>
<p>目前我们将这类数据量巨大但对业务不太影响的表单独迁到一个库后，数据库的整体 <code>IO</code> 下降明显，业务也恢复正常。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后我们还需要做一步历史数据归档的操作，将 N 个月之前的数据要定期迁移到 <code>HBASE</code> 之类存储，保证 <code>MySQL</code> 中的数据一直保持在一个可接受的范围。</p>
<p>而归档数据的查询便依赖于大数据提供服务。</p>
<p>本次分库分表是一次非常难得的实践操作，网上大部分的资料都是在汽车出厂前就换好了轮胎。</p>
<p>而我们大部分碰到的场景都是要对高速路上跑着的车子换胎，一不小心就“车毁人亡”。</p>
<p>有更好的方式方法欢迎大家评论区留言讨论。</p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>一次分表踩坑实践的探讨</title>
    <url>/2019/04/16/framework-design/sharding-db/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/04/29/5cc65343e8bc4.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前不少人问我“能否分享一些分库分表相关的实践”，其实不是我不分享，而是真的经验不多🤣；和大部分人一样都是停留在理论阶段。</p>
<p>不过这次多少有些可以说道了。</p>
<p>先谈谈背景，我们生产数据库随着业务发展量也逐渐起来；好几张单表已经突破<strong>亿级</strong>数据，并且保持每天 200+W 的数据量增加。</p>
<p>而我们有些业务需要进行关联查询、或者是报表统计；在这样的背景下大表的问题更加突出（比如一个查询功能需要跑好几分钟）。</p>
<span id="more"></span>

<blockquote>
<p>可能很多人会说：为啥单表都过亿了才想方案解决？其实不是不想，而是由于历史原因加上错误预估了数据增长才导致这个局面。总之原因比较复杂，也不是本次讨论的重点。</p>
</blockquote>
<h1 id="临时方案"><a href="#临时方案" class="headerlink" title="临时方案"></a>临时方案</h1><p>由于需求紧、人手缺的情况下，整个处理的过程分为几个阶段。</p>
<p>第一阶段应该是去年底，当时运维反应 <code>MySQL</code> 所在的主机内存占用很高，整体负载也居高不下，导致整个 MySQL 的吞吐量明显降低（写入、查询数据都明显减慢）。</p>
<p>为此我们找出了数据量最大的几张表，发现大部分数据量在7&#x2F;8000W 左右，少数的已经突破一亿。</p>
<p>通过业务层面进行分析发现，这些数据多数都是用户产生的一些<strong>日志型数据</strong>，而且这些数据在业务上并不是强相关的，甚至两三个月前的数据其实已经不需要实时查询了。</p>
<p>因为接近年底，尽可能的不想去动应用，考虑是否可以在运维层面缓解压力；主要的目的就是把单表的数据量降低。</p>
<p>原本是想把两个月之前的数据直接迁移出来放到备份表中，但在准备实施的过程中发现一个大坑。</p>
<blockquote>
<p>表中没有一个可以排序的索引，导致我们无法快速的筛选出一部分数据！这真是一个深坑，为后面的一些优化埋了个地雷；即便是加索引也需要花几个小时（具体多久没敢在生产测试）。</p>
</blockquote>
<p>如果我们强行按照时间进行筛选，可能查询出 4000W 的数据就得花上好几个小时；这显然是行不通的。</p>
<p>于是我们便想到了一个大胆的想法：这部分数据是否可以直接不要了？</p>
<p>这可能是最有效及最快的方式了，和产品沟通后得知这部分数据真的只是日志型的数据，即便是报表出不来今后补上也是可以的。</p>
<p>于是我们就简单粗暴的做了以下事情：</p>
<ul>
<li>修改原有表的表名，比如加上(<code>_190416bak</code>)。</li>
<li>再新建一张和原有表名称相同的表。</li>
</ul>
<p>这样新的数据就写到了新表，同时业务上也是使用的这个数据量较小的新表。</p>
<p>虽说过程不太优雅，但至少是解决了问题同时也给我们做技术改造预留了时间。</p>
<h1 id="分表方案"><a href="#分表方案" class="headerlink" title="分表方案"></a>分表方案</h1><p>之前的方案虽说可以缓解压力，但不能根本解决问题。</p>
<p>有些业务必须得查询之前的数据，导致之前那招行不通了，所以正好我们就借助这个机会把表分了。</p>
<p>我相信大部分人虽说没有做过实际做过分表，但也见过猪跑；网上一搜各种方案层出不穷。</p>
<p>我认为最重要的一点是要结合实际业务找出需要 sharding 的字段，同时还有上线阶段的数据迁移也非常重要。</p>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>可能大家都会说用 hash 的方式分配得最均匀，但我认为这还是需要使用历史数据的场景才用哈希分表。</p>
<p>而对于不需要历史数据的场景，比如业务上只查询近三个月的数据。</p>
<p>这类需求完成可以采取时间分表，按照月份进行划分，这样改动简单，同时对历史数据也比较好迁移。</p>
<p>于是我们首先将这类需求的表筛选出来，按照月份进行拆分，只是在查询的时候拼接好表名即可；也比较好理解。</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>刚才也提到了：需要根据业务需求进行分表策略。</p>
<p>而一旦所有的数据都有可能查询时，按照时间分表也就行不通了。（也能做，只是如果不是按照时间进行查询时需要遍历所有的表）</p>
<p>因此我们计划采用 <code>hash</code> 的方式分表，这算是业界比较主流的方式就不再赘述。</p>
<p>采用哈希时需要将 <code>sharding</code> 字段选好，由于我们的业务比较单纯；是一个物联网应用，所有的数据都包含有物联网设备的唯一标识（IMEI），并且这个字段天然的就保持了唯一性；大多数的业务也都是根据这个字段来的，所以它非常适合来做这个 <code>sharding</code> 字段。</p>
<p>在做分表之前也调研过 <code>MyCAT</code> 及 <code>sharding-jdbc</code>(现已升级为 <code>shardingsphere</code>)，最终考虑到对开发的友好性及不增加运维复杂度还是决定在 jdbc 层 sharding 的方式。</p>
<p>但由于历史原因我们并不太好集成 <code>sharding-jdbc</code>，但基于 <code>sharding</code> 的特点自己实现了一个分表策略。</p>
<p>这个简单也好理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash(sharding字段) % 分表数量 ;</span><br><span class="line"></span><br><span class="line">select xx from <span class="string">&#x27;busy_&#x27;</span>+index where sharding字段 = xxx;</span><br></pre></td></tr></table></figure>

<p>其实就是算出了表名，然后路由过去查询即可。</p>
<p>只是我们实现的非常简单：修改了所有的底层查询方法，每个方法都里都做了这样的一个判断。</p>
<p>并没有像 <code>sharding-jdbc</code> 一样，代理了数据库的查询方法；其中还要做 <code>SQL解析--&gt;SQL路由--&gt;执行SQL--&gt;合并结果</code> 这一系列的流程。</p>
<p>如果自己再做一遍无异于重新造了一个轮子，并且并不专业，只是在现有的技术条件下选择了一个快速实现达成效果的方法。</p>
<p>不过这个过程中我们节省了将 sharding 字段哈希的过程，因为每一个 IMEI 号其实都是一个唯一的整型，直接用它做 mod 运算即可。</p>
<p>还有一个是需要一个统一的主键生成规则，分表后不能再依赖于单表的字段自增了；方法还是挺多的：</p>
<ul>
<li>比如时间戳+随机数可满足大部分业务。</li>
<li>UUID，生成简单，但没法做排序。</li>
<li>雪花算法统一生成主键ID。</li>
</ul>
<p>大家可以根据自己的实际情况做选择。</p>
<h1 id="业务调整"><a href="#业务调整" class="headerlink" title="业务调整"></a>业务调整</h1><p>因为我们并没有使用第三方的 sharding-jdbc 组件，所以没有办法做到对代码的低侵入性；每个涉及到分表的业务代码都需要做底层方法的改造（也就是路由到正确的表）。</p>
<p>考虑到后续业务的发展，我们决定将拆分的表分为 64 张；加上后续引入大数据平台足以应对几年的数据增长。</p>
<blockquote>
<p>这里还有个小细节需要注意：分表的数量需要为 2∧N 次方，因为在取模的这种分表方式下，即便是今后再需要分表影响的数据也会尽量的小。</p>
</blockquote>
<p>再修改时只能将表名称进行全局搜索，然后加以修改，同时根据修改的方法倒推到表现的业务并记录下来，方便后续回归测试。</p>
<hr>
<p>当然无法避免查询时利用非 sharding 字段导致的全表扫描，这是所有分片后都会遇到的问题。</p>
<p>因此我们在修改分表方法的底层查询时同时也会查看是否有走分片字段，如果不是，那是否可以调整业务。</p>
<p>比如对于一个上亿的数据是否还有必要存在按照分页查询、日期查询？这样的业务是否真的具有意义？</p>
<p>我们尽可能的引导产品按照这样的方式来设计产品或者做出调整。</p>
<p>但对于报表这类的需求确实也没办法，比如统计表中某种类型的数据；这种我们也可以利用多线程的方式去并行查询然后汇总统计来提高查询效率。</p>
<p>有时也有一些另类场景：</p>
<blockquote>
<p>比如一个千万表中有某一特殊类型的数据只占了很小一部分，比如说几千上万条。</p>
</blockquote>
<p>这时页面上需要对它进行分页查询是比较正常的（比如某种投诉消息，客户需要一条一条的单独处理），但如果我们按照 IMEI 号或者是主键进行分片后再分页查询那就比较蛋疼了。</p>
<p>所以这类型的数据建议单独新建一张表来维护，不要和其他数据混合在一起，这样不管是做分页还是 like 都比较简单和独立。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>代码改完，开发也单测完成后怎么来验证分表的业务是否正常也比较麻烦。</p>
<p>一个是测试麻烦，再一个是万一哪里改漏了还是查询的原表，但这样在测试环境并不会有异常，一旦上线产生了生产数据到新的 64 张表后想要再修复就比较麻烦了。</p>
<p>所以我们取了个巧，直接将原表的表名修改，比如加一个后缀；这样在测试过程中观察前后台有无报错就比较容易提前发现这个问题。</p>
<h1 id="上线流程"><a href="#上线流程" class="headerlink" title="上线流程"></a>上线流程</h1><p>测试验收通过后只是分表这个需求的80%，剩下如何上线也是比较头疼。</p>
<p>一旦应用上线后所有的查询、写入、删除都会先走路由然后到达新表；而老数据在原表里是不会发生改变的。</p>
<h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><p>所以我们上线前的第一步自然是需要将原有的数据进行迁移，迁移的目的是要分片到新的 64 张表中，这样才会对原有的业务无影响。</p>
<p>因此我们需要额外准备一个程序，它需要将老表里的数据按照分片规则复制到新表中；</p>
<p>在我们这个场景下，生产数据有些已经上亿了，这个迁移过程我们在测试环境模拟发现耗时是非常久的。而且我们老表中对于 <code>create_time</code> 这样用于筛选数据的字段没有索引（以前的技术债），所以查询起来就更加慢了。</p>
<p>最后没办法，我们只能和产品协商告知用户对于之前产生的数据短期可能会查询不到，这个时间最坏可能会持续几天（我们只能在凌晨迁移，白天会影响到数据库负载）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这便是我们这次的分表实践，虽说不少过程都不优雅，但受限于条件也只能折中处理。</p>
<p>但我们后续的计划是，修改我们底层的数据连接（目前是自己封装的一个 jar 包，导致集成 sharding-jdbc 比较麻烦）最终逐渐迁移到 <code>sharding-jdbc</code> .</p>
<p>最后得出了几个结论：</p>
<ul>
<li>一个好的产品规划非常有必要，可以在合理的时间对数据处理（不管是分表还是切入归档）。</li>
<li>每张表都需要一个可以用于排序查询的字段（自增ID、创建时间），整个过程由于没有这个字段导致耽搁了很长时间。</li>
<li>分表字段需要谨慎，要全盘的考虑业务情况，尽量避免出现查询扫表的情况。</li>
</ul>
<p>最后欢迎留言讨论。</p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的 for 循环也会踩的坑</title>
    <url>/2021/12/28/go/for-mistake/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/09/24/gohfjR5CtU9Qvr6.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近实现某个业务时，需要读取数据然后再异步处理；在 Go 中实现起来自然就比较简单，伪代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">list := []*Demo&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;name=&quot;</span>+v.Name)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Demo <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>看似非常简单几行代码却和我们的预期不符，打印之后输出的是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=b</span><br><span class="line">name=b</span><br></pre></td></tr></table></figure>

<p>并不是我们预期的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=a</span><br><span class="line">name=b</span><br></pre></td></tr></table></figure>

<h1 id="坑一"><a href="#坑一" class="headerlink" title="坑一"></a>坑一</h1><p>由于写 go 的资历尚浅、道行更是浅薄，这 <code>bug</code> 我硬是找了个把小时；刚开始还以为是数据源的问题，经历了好几轮自我怀疑。总之过程先不表，先看看如何修复这个问题。</p>
<p>首先第一种办法是使用临时变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">list := []*Demo&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">	temp:=v</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;name=&quot;</span>+temp.Name)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样便可正确输出，其实从这种写法中也能看出问题的端倪。</p>
<p>在第一种没有使用临时变量时，主协程很快就运行完毕，这时候打印的子协程可能还没运行；当开始运行的时候，这里的 v 已经被最后一个赋值了。</p>
<p>所以这里打印的一直都是最后一个变量。</p>
<p>而使用临时变量会将当前遍历的值拷贝一份，自然就不会互相影响了。</p>
<hr>
<p>当然除了临时变量也可使用闭包解决。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">list := []*Demo&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(temp *Demo)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;name=&quot;</span>+temp.Name)</span><br><span class="line">	&#125;(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将参数通过闭包传递时，每个 <code>goroutine</code> 都会在自己的栈中存放一份参数的拷贝，这样也能区分了。</p>
<h1 id="坑二"><a href="#坑二" class="headerlink" title="坑二"></a>坑二</h1><p>与之类似的还有第二个坑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">list2 := []Demo&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> alist []*Demo</span><br><span class="line"><span class="keyword">for</span> _, test := <span class="keyword">range</span> list2 &#123;</span><br><span class="line">	alist = <span class="built_in">append</span>(alist, &amp;test)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(alist[<span class="number">0</span>].Name, alist[<span class="number">1</span>].Name)</span><br></pre></td></tr></table></figure>

<p>这段代码与我们预期不不符：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">b b</span><br></pre></td></tr></table></figure>

<p>但我们稍加修改就可以了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">list2 := []Demo&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> alist []Demo</span><br><span class="line"><span class="keyword">for</span> _, test := <span class="keyword">range</span> list2 &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;addr=%p\n&quot;</span>, &amp;test)</span><br><span class="line">	alist = <span class="built_in">append</span>(alist, test)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(alist[<span class="number">0</span>].Name, alist[<span class="number">1</span>].Name)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">addr=0xc000010240</span><br><span class="line">addr=0xc000010240</span><br><span class="line">a b</span><br></pre></td></tr></table></figure>

<p>顺便打印了内存地址，其实从结果中大概就能猜到原因；每次遍历打印的内存地址都是相同，所以如果我们存放的是指针，本质上存储的都是同一块内存地址的内容，所以值相同。</p>
<p>而如果我们只存储值，不存指针自然也不会有这个问题。</p>
<p>但如果想使用指针如何处理呢?</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">list2 := []Demo&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> alist []*Demo</span><br><span class="line"><span class="keyword">for</span> _, test := <span class="keyword">range</span> list2 &#123;</span><br><span class="line">	temp := test</span><br><span class="line">	<span class="comment">//fmt.Printf(&quot;addr=%p\n&quot;, &amp;test)</span></span><br><span class="line">	alist = <span class="built_in">append</span>(alist, &amp;temp)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(alist[<span class="number">0</span>].Name, alist[<span class="number">1</span>].Name)</span><br></pre></td></tr></table></figure>

<p>也简单，同样的使用临时变量即可。</p>
<p>通过官方源码可以得知，<code>for range</code> 只是语法糖，本质上也是 for 循环；因为每次都是对同一个对象遍历赋值，所以便会出现这样的“乌龙”。</p>
<p><img src="https://s2.loli.net/2023/09/24/ortJYa4fk3QCz18.png"></p>
<h1 id="defer-的坑"><a href="#defer-的坑" class="headerlink" title="defer 的坑"></a>defer 的坑</h1><p><code>for</code> 循环 + <code>defer</code> 也是组合坑（虽然不推荐这么用），还是先来看个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// demo1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(v)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//demo1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">//demo2</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><code>demo1</code>的结果很好理解，<code>defer</code> 可以理解为将执行语句放入到栈中，所以呈现的结果是先进后出。</p>
<p>而<code>demo2</code>中，由于是闭包，闭包对变量 v 持有的是引用，所以在最终延迟执行时 v 已经被最后一个值赋值，所以打印出来都是相同的。</p>
<p>解决方法与上文类似，传入参数即可解决：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这类细节问题日常开发大概率是碰不上的，最有可能遇到的就是面试了，所以多了解了解也没坏处。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>类似于第一种情况在 for 循环中 <code>goroutine</code> 调用，我觉得  <code>IDE</code> 完全是可以做到提醒的；比如 <code>IDEA</code> 中就把大部分认为可能发的错误包含进去，期待后续 <code>goland</code> 的更新。</p>
<p>但其实这几种错误官方博客已经提醒过了。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxstzwhykqj311f0u0q71.jpg"><br><a href="https://github.com/golang/go/wiki/CommonMistakes#using-reference-to-loop-iterator-variable">https://github.com/golang/go/wiki/CommonMistakes#using-reference-to-loop-iterator-variable</a><br>只是大部分人估计都没去看过，这事之后我也得花时间好好阅读下。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>for</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 GitHub Action 自动发布 Docker</title>
    <url>/2021/03/26/go/github-actions/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/03/26/UIZzdFfNb7exGvE.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近公司内部项目的发布流程接入了 <code>GitHub Actions</code>，整个体验过程还是比较美好的；本文主要目的是对于没有还接触过 <code>GitHub Actions</code>的新手，能够利用它快速构建自动测试及打包推送 <code>Docker</code> 镜像等自动化流程。</p>
<span id="more"></span>

<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>本文主要以 <code>Go</code> 语言为例，当然其他语言也是类似的，与语言本身关系不大。</p>
<p>这里我们首先在 <code>GitHub</code> 上创建一个项目，编写了几段简单的代码 <code>main.go</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> version = <span class="string">&quot;0.0.1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetVersion</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> version</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(GetVersion())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内容非常简单，只是打印了了版本号；同时配套了一个单元测试 <code>main_test.go</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetVersion1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="type">string</span></span><br><span class="line">		want <span class="type">string</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;name: <span class="string">&quot;test1&quot;</span>, want: <span class="string">&quot;0.0.1&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> got := GetVersion(); got != tt.want &#123;</span><br><span class="line">				t.Errorf(<span class="string">&quot;GetVersion() = %v, want %v&quot;</span>, got, tt.want)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以执行  <code>go test</code> 运行该单元测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span>                          </span><br><span class="line">PASS</span><br><span class="line">ok      github.com/crossoverJie/go-docker       1.729s</span><br></pre></td></tr></table></figure>

<h2 id="自动测试"><a href="#自动测试" class="headerlink" title="自动测试"></a>自动测试</h2><p>当然以上流程完全可以利用 <code>Actions</code> 自动化搞定。</p>
<p>首选我们需要在项目根路径创建一个 <em><code>.github/workflows/*.yml</code></em> 的配置文件，新增如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">go-docker</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">test:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">if:</span> <span class="string">github.ref</span> <span class="string">==</span> <span class="string">&#x27;refs/heads/main&#x27;</span> <span class="string">||</span> <span class="string">startsWith(github.ref,</span> <span class="string">&#x27;refs/tags&#x27;</span><span class="string">)</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Unit</span> <span class="string">Tests</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">go</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>

<p>简单解释下：</p>
<ul>
<li><code>name</code> 不必多说，是为当前工作流创建一个名词。</li>
<li><code>on</code> 指在什么事件下触发，这里指代码发生 <code>push</code> 时触发，更多事件定义可以参考官方文档：</li>
</ul>
<p><a href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows">Events that trigger workflows</a></p>
<ul>
<li><code>jobs</code> 则是定义任务，这里只有一个名为 <code>test</code> 的任务。</li>
</ul>
<p>该任务是运行在 <code>ubuntu-latest</code> 的环境下，只有在 <code>main</code> 分支有推送或是有 <code>tag</code> 推送时运行。</p>
<p>运行时会使用 <code>actions/checkout@v2</code> 这个由他人封装好的 <code>Action</code>，当然这里使用的是由官方提供的拉取代码 <code>Action</code>。</p>
<ul>
<li>基于这个逻辑，我们可以灵活的分享和使用他人的 <code>Action</code> 来简化流程，这点也是 <code>GitHub Action</code>扩展性非常强的地方。</li>
</ul>
<p>最后的 <code>run</code> 则是运行自己命令，这里自然就是触发单元测试了。</p>
<ul>
<li>如果是 Java 便可改为  <code>mvn test</code>.</li>
</ul>
<p>之后一旦我们在 <code>main</code> 分支上推送代码，或者有其他分支的代码合并过来时都会自动运行单元测试，非常方便。</p>
<p><img src="https://i.loli.net/2021/03/26/K7YuUF2iTJzRpwd.jpg"></p>
<p><img src="https://i.loli.net/2021/03/26/NbIpDG1vA8fwK4z.jpg"></p>
<p>与我们本地运行效果一致。</p>
<h2 id="自动发布"><a href="#自动发布" class="headerlink" title="自动发布"></a>自动发布</h2><p>接下来考虑自动打包 <code>Docker</code> 镜像，同时上传到 <code>Docker Hub</code>；为此首先创建 <code>Dockerfile</code> ：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.15</span> AS builder</span><br><span class="line"><span class="keyword">ARG</span> VERSION=<span class="number">0.0</span>.<span class="number">10</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> main.go .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o main -ldflags=<span class="string">&quot;-X &#x27;main.version=<span class="variable">$&#123;VERSION&#125;</span>&#x27;&quot;</span> main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> debian:stable-slim</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /go/src/app/main /go/bin/main</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/go/bin:$&#123;PATH&#125;&quot;</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;main&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>这里利用 <code>ldflags</code> 可在编译期间将一些参数传递进打包程序中，比如打包时间、go 版本、git 版本等。</p>
<p>这里只是将 <code>VERSION</code> 传入了  <code>main.version</code> 变量中，这样在运行时就便能取到了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t go-docker:last .</span><br><span class="line">docker run --<span class="built_in">rm</span> go-docker:0.0.10</span><br><span class="line">0.0.10</span><br></pre></td></tr></table></figure>

<p>接着继续编写 <code>docker.yml</code> 新增自动打包 <code>Docker</code> 以及推送到 <code>docker hub</code> 中。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">if:</span> <span class="string">startsWith(github.ref,</span> <span class="string">&#x27;refs/tags&#x27;</span><span class="string">)</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Extract</span> <span class="string">Version</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">version_step</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          echo &quot;##[set-output name=version;]VERSION=$&#123;GITHUB_REF#$&quot;refs/tags/v&quot;&#125;&quot;</span></span><br><span class="line"><span class="string">          echo &quot;##[set-output name=version_tag;]$GITHUB_REPOSITORY:$&#123;GITHUB_REF#$&quot;refs/tags/v&quot;&#125;&quot;</span></span><br><span class="line"><span class="string">          echo &quot;##[set-output name=latest_tag;]$GITHUB_REPOSITORY:latest&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">QEMU</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/setup-qemu-action@v1</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Docker</span> <span class="string">Buildx</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/setup-buildx-action@v1</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Login</span> <span class="string">to</span> <span class="string">DockerHub</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/login-action@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_USER_NAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_ACCESS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PrepareReg</span> <span class="string">Names</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">read-docker-image-identifiers</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          echo VERSION_TAG=$(echo $&#123;&#123; steps.version_step.outputs.version_tag &#125;&#125; | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;) &gt;&gt; $GITHUB_ENV</span></span><br><span class="line"><span class="string">          echo LASTEST_TAG=$(echo $&#123;&#123; steps.version_step.outputs.latest_tag  &#125;&#125; | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;) &gt;&gt; $GITHUB_ENV</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">push</span> <span class="string">Docker</span> <span class="string">images</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">docker_build</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/build-push-action@v2.3.0</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">push:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">tags:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123;env.VERSION_TAG&#125;&#125;</span></span><br><span class="line"><span class="string">            $&#123;&#123;env.LASTEST_TAG&#125;&#125;</span></span><br><span class="line"><span class="string"></span>          <span class="attr">build-args:</span> <span class="string">|</span></span><br><span class="line">            <span class="string">$&#123;&#123;steps.version_step.outputs.version&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>新增了一个 <code>deploy</code> 的 job。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">needs:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">if:</span> <span class="string">startsWith(github.ref,</span> <span class="string">&#x27;refs/tags&#x27;</span><span class="string">)</span></span><br></pre></td></tr></table></figure>

<p>运行的条件是上一步的单测流程跑通，同时有新的 <code>tag</code> 生成时才会触发后续的 <code>steps</code>。</p>
<p><code>name: Login to DockerHub</code></p>
<p>在这一步中我们需要登录到 <code>DockerHub</code>，所以首先需要在 GitHub 项目中配置 hub 的 <code>user_name</code> 以及 <code>access_token</code>.</p>
<p><img src="https://i.loli.net/2021/03/26/A8DtcYazfU1HC7O.jpg"></p>
<p><img src="https://i.loli.net/2021/03/26/XI8u4nU6lEP1bCF.jpg"></p>
<p>配置好后便能在 action 中使用该变量了。</p>
<p><img src="https://i.loli.net/2021/03/26/KzOQB8L7SRFDVNr.jpg"></p>
<p>这里使用的是由 docker 官方提供的登录 action(<code>docker/login-action</code>)。</p>
<p>有一点要非常注意，我们需要将镜像名称改为小写，不然会上传失败，比如我的名称中 <code>J</code> 字母是大写的，直接上传时就会报错。</p>
<p><img src="https://i.loli.net/2021/03/26/a5WBhtEorzelfOK.jpg"></p>
<p>所以在上传之前先要执行该步骤转换为小写。</p>
<p><img src="https://i.loli.net/2021/03/26/LPcNBvznGqEd9jy.jpg"></p>
<p>最后再用这两个变量上传到 Docker Hub。</p>
<p><img src="https://i.loli.net/2021/03/26/cw4EekaZXpJi1Kh.jpg"></p>
<p>今后只要我们打上 <code>tag</code> 时，<code>Action</code> 就会自动执行单测、构建、上传的流程。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>GitHub Actions</code> 非常灵活，你所需要的大部分功能都能在 <code>marketplace</code> 找到现成的直接使用，</p>
<p>比如可以利用 <code>ssh</code> 登录自己的服务器，执行一些命令或脚本，这样想象空间就很大了。</p>
<p>使用起来就像是搭积木一样，可以很灵活的完成自己的需求。</p>
<p>参考链接：</p>
<p><a href="https://tonyuk.medium.com/how-to-build-a-ci-cd-pipeline-with-go-github-actions-and-docker-3c69e50b6043">How to Build a CI&#x2F;CD Pipeline with Go, GitHub Actions and Docker</a></p>
]]></content>
      <categories>
        <category>CICD</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Docker</tag>
        <tag>GitHub Actions</tag>
      </tags>
  </entry>
  <entry>
    <title>Go channel VS Java BlockingQueue</title>
    <url>/2021/07/02/go/go%20channel%20vs%20java%20BlockingQueue/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/07/03/PykYJp6qmdb2h1B.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在实现两个需求，由于两者之间并没有依赖关系，所以想利用队列进行解耦；但在 <code>Go</code> 的标准库中并没有现成可用并且并发安全的数据结构；但 <code>Go</code> 提供了一个更加优雅的解决方案，那就是 <code>channel</code>。</p>
<h1 id="channel-应用"><a href="#channel-应用" class="headerlink" title="channel 应用"></a>channel 应用</h1><p><code>Go</code> 与 <code>Java</code> 的一个很大的区别就是并发模型不同，Go 采用的是 <code>CSP(Communicating sequential processes)</code> 模型；用 Go 官方的说法：</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<span id="more"></span>

<p>翻译过来就是：不用使用共享内存来通信，而是用通信来共享内存。</p>
<p>而这里所提到的<strong>通信</strong>，在 Go 里就是指代的 <code>channel</code>。</p>
<p>只讲概念并不能快速的理解与应用，所以接下来会结合几个实际案例更方便理解。</p>
<h2 id="futrue-task"><a href="#futrue-task" class="headerlink" title="futrue task"></a>futrue task</h2><p><code>Go</code> 官方没有提供类似于 <code>Java</code> 的 <code>FutureTask</code> 支持：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line">        executorService.submit(futureTask);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 模拟http</span></span><br><span class="line">        System.out.println(<span class="string">&quot;http request&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;request success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但我们可以使用 <code>channel</code> 配合 <code>goroutine</code> 实现类似的功能：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := Request(<span class="string">&quot;https://github.com&quot;</span>)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> r := &lt;-ch:</span><br><span class="line">		fmt.Println(r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Request</span><span class="params">(url <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 模拟http请求</span></span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		ch &lt;- fmt.Sprintf(<span class="string">&quot;url=%s, res=%s&quot;</span>, url, <span class="string">&quot;ok&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>goroutine</code> 发起请求后直接将这个 <code>channel</code> 返回，调用方会在请求响应之前一直阻塞，直到 <code>goroutine</code> 拿到了响应结果。</p>
<h2 id="goroutine-互相通信"><a href="#goroutine-互相通信" class="headerlink" title="goroutine 互相通信"></a>goroutine 互相通信</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 偶数线程</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OuNum</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> TwoThreadWaitNotifySimple number;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">OuNum</span><span class="params">(TwoThreadWaitNotifySimple number)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.number = number;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (TwoThreadWaitNotifySimple.class) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (number.flag) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                         System.out.println(Thread.currentThread().getName() + <span class="string">&quot;+-+偶数&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">                         number.flag = <span class="literal">false</span>;</span><br><span class="line">                         TwoThreadWaitNotifySimple.class.notify();</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         TwoThreadWaitNotifySimple.class.wait();</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                         e.printStackTrace();</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 奇数线程</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JiNum</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> TwoThreadWaitNotifySimple number;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">JiNum</span><span class="params">(TwoThreadWaitNotifySimple number)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.number = number;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (TwoThreadWaitNotifySimple.class) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (!number.flag) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                         System.out.println(Thread.currentThread().getName() + <span class="string">&quot;+-+奇数&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">                         number.flag = <span class="literal">true</span>;</span><br><span class="line">                         TwoThreadWaitNotifySimple.class.notify();</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         TwoThreadWaitNotifySimple.class.wait();</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                         e.printStackTrace();</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里截取了”两个线程交替打印奇偶数“的部分代码。</p>
</blockquote>
<p>Java 提供了 <code>object.wait()/object.notify()</code> 这样的等待通知机制，可以实现两个线程间通信。</p>
<p><code>go</code> 通过 <code>channel</code> 也能实现相同效果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">11</span>; i++ &#123;</span><br><span class="line">			ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			<span class="comment">//奇数</span></span><br><span class="line">			<span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;奇数:&quot;</span>, i)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">11</span>; i++ &#123;</span><br><span class="line">			&lt;-ch</span><br><span class="line">			<span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;偶数:&quot;</span>, i)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>本质上他们都是利用了线程(<code>goroutine</code>)阻塞然后唤醒的特性，只是 Java 是通过 wait&#x2F;notify 机制；</p>
<p>而 go 提供的 channel 也有类似的特性：</p>
<ol>
<li>向 <code>channel</code> 发送数据时(<code>ch&lt;-struct&#123;&#125;&#123;&#125;</code>)会被阻塞，直到 channel 被消费(<code>&lt;-ch</code>)。</li>
</ol>
<blockquote>
<p>以上针对于<code>无缓冲 channel</code>。</p>
</blockquote>
<p><code>channel</code> 本身是由 <code>go</code> 原生保证并发安全的，不用额外的同步措施，可以放心使用。</p>
<h2 id="广播通知"><a href="#广播通知" class="headerlink" title="广播通知"></a>广播通知</h2><p>不仅是两个 <code>goroutine</code> 之间通信，同样也能广播通知，类似于如下 <code>Java</code> 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (NotifyAll.class)&#123;</span><br><span class="line">                    NotifyAll.class.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;done....&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (NotifyAll.class)&#123;</span><br><span class="line">        NotifyAll.class.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程将所有等待的子线程全部唤醒，这个本质上也是通过 <code>wait/notify</code> 机制实现的，区别只是通知了所有等待的线程。</p>
<p>换做是 <code>go</code> 的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	notify := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-notify:</span><br><span class="line">					fmt.Println(<span class="string">&quot;done.......&quot;</span>,i)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">					fmt.Println(<span class="string">&quot;wait notify&quot;</span>,i)</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="built_in">close</span>(notify)</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当关闭一个 <code>channel</code> 后，会使得所有获取 <code>channel</code> 的 <code>goroutine</code> 直接返回，不会阻塞，正是利用这一特性实现了广播通知所有 <code>goroutine</code> 的目的。</p>
<blockquote>
<p>注意，同一个 channel 不能反复关闭，不然会出现panic。</p>
</blockquote>
<h2 id="channel-解耦"><a href="#channel-解耦" class="headerlink" title="channel 解耦"></a>channel 解耦</h2><p>以上例子都是基于无缓冲的 <code>channel</code>，通常用于 <code>goroutine</code> 之间的同步；同时 channel 也具备缓冲的特性：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch :=<span class="built_in">make</span>(<span class="keyword">chan</span> T, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>可以直接将其理解为队列，正是因为具有缓冲能力，所以我们可以将业务之间进行解耦，生产方只管往 <code>channel</code> 中丢数据，消费者只管将数据取出后做自己的业务。</p>
<p>同时也具有阻塞队列的特性：</p>
<ul>
<li>当 <code>channel</code> 写满时生产者将会被阻塞。</li>
<li>当 <code>channel</code> 为空时消费者也会阻塞。</li>
</ul>
<blockquote>
<p>从上文的例子中可以看出，实现相同的功能 go 的写法会更加简单直接，相对的 Java 就会复杂许多（当然这也和这里使用的偏底层 api 有关）。</p>
</blockquote>
<h1 id="Java-中的-BlockingQueue"><a href="#Java-中的-BlockingQueue" class="headerlink" title="Java 中的 BlockingQueue"></a>Java 中的 BlockingQueue</h1><p>这些特性都与 Java 中的 <code>BlockingQueue</code> 非常类似，他们具有以下的相同点：</p>
<ul>
<li>可以通过两者来进行 <code>goroutine/thread</code> 通信。</li>
<li>具备队列的特征，可以解耦业务。</li>
<li>支持并发安全。</li>
</ul>
<p>同样的他们又有很大的区别，从表现上看：</p>
<ul>
<li><code>channel</code> 支持 <code>select</code> 语法，对 <code>channel</code> 的管理更加简洁直观。</li>
<li><code>channel</code> 支持关闭，不能向已关闭的 <code>channel</code> 发送消息。</li>
<li><code>channel</code> 支持定义方向，在编译器的帮助下可以在语义上对行为的描述更加准确。</li>
</ul>
<p>当然还有本质上的区别就是 channel 是 go 推荐的 <code>CSP</code> 模型的核心，具有编译器的支持，可以有很轻量的成本实现并发通信。</p>
<p>而 <code>BlockingQueue</code> 对于 <code>Java</code> 来说只是一个实现了并发安全的数据结构，即便不使用它也有其他的通信方式；只是他们都具有阻塞队列的特征，所有在初步接触 <code>channel</code> 时容易产生混淆。</p>
<table>
<thead>
<tr>
<th>相同点</th>
<th>channel 特有</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞策略</td>
<td>支持select</td>
</tr>
<tr>
<td>设置大小</td>
<td>支持关闭</td>
</tr>
<tr>
<td>并发安全</td>
<td>自定义方向</td>
</tr>
<tr>
<td>普通数据结构</td>
<td>编译器支持</td>
</tr>
</tbody></table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有过一门编程语言的使用经历在学习其他语言是确实是要方便许多，比如之前写过 <code>Java</code> 再看 <code>Go</code> 时就会发现许多类似之处，只是实现不同。</p>
<p>拿这里的并发通信来说，本质上是因为并发模型上的不同；</p>
<p><code>Go</code> 更推荐使用通信来共享内存，而 <code>Java</code> 大部分场景都是使用共享内存来通信（这样就得加锁来同步）。</p>
<p>带着疑问来学习确实会事半功倍。</p>
<p>最近和网友讨论后再补充一下，其实 <code>Go channel</code> 的底层实现也是通过对共享内存的加锁来实现的，这点任何语言都不可避免。</p>
<p>既然都是共享内存那和我们自己使用共享内存有什么区别呢？主要还是 channel 的抽象层级更高，我们使用这类高抽象层级的方式编写代码会更易理解和维护。</p>
<p>但在一些特殊场景，需要追求极致的性能，降低加锁颗粒度时用共享内存会更加合适，所以 Go 官方也提供有<code> sync.Map/Mutex</code> 这样的库；只是在并发场景下更推荐使用 <code>channel</code> 来解决问题。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Go</tag>
        <tag>channel</tag>
        <tag>BlockingQueue</tag>
      </tags>
  </entry>
  <entry>
    <title>编写一个接口压测工具</title>
    <url>/2021/11/15/go/go-benchmark-test/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/11/15/NPjnuqgBEMTRSJk.jpg" alt="go-benchmark-test.md---008i3skNly1gwer3yhu0dj30vn0u00v3.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间有个项目即将上线，需要对其中的核心接口进行压测；由于我们的接口是 <code>gRPC</code> 协议，找了一圈发现压测工具并不像 <code>HTTP</code> 那么多。</p>
<p>最终发现了 <a href="https://ghz.sh/">ghz</a> 这个工具，功能也非常齐全。</p>
<p>事后我在想为啥做 <code>gRPC</code> 压测的工具这么少，是有什么难点嘛？为了验证这个问题于是我准备自己写一个工具。</p>
<span id="more"></span>

<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>前前后后大概花了个周末的时间完成了相关功能。</p>
<p><a href="https://github.com/crossoverJie/ptg/">https://github.com/crossoverJie/ptg/</a></p>
<p><img src="https://i.loli.net/2021/11/15/lrNwUd1HFZuiQoe.gif" alt="go-benchmark-test.md---008i3skNly1gw04urcj16g30gn0571kz.gif"></p>
<p>也是一个命令行工具，使用起来效果如上图；完整的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME:</span><br><span class="line">   ptg - Performance testing tool (Go)</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   ptg [global options] command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">   help, h  Shows a list of commands or help for one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   --thread value, -t value              -t 10 (default: 1 thread)</span><br><span class="line">   --Request value, --proto value        -proto http/grpc (default: http)</span><br><span class="line">   --protocol value, --pf value          -pf /file/order.proto</span><br><span class="line">   --fully-qualified value, --fqn value  -fqn package.Service.Method</span><br><span class="line">   --duration value, -d value            -d 10s (default: Duration of test in seconds, Default 10s)</span><br><span class="line">   --request value, -c value             -c 100 (default: 100)</span><br><span class="line">   --HTTP value, -M value                -m GET (default: GET)</span><br><span class="line">   --bodyPath value, --body value        -body bodyPath.json</span><br><span class="line">   --header value, -H value              HTTP header to add to request, e.g. &quot;-H Content-Type: application/json&quot;</span><br><span class="line">   --target value, --tg value            http://gobyexample.com/grpc:127.0.0.1:5000</span><br><span class="line">   --help, -h                            show help (default: false)</span><br></pre></td></tr></table></figure>

<p>考虑到受众，所以同时支持 <code>HTTP</code> 与 <code>gRPC</code> 接口的压测。</p>
<p>做 <code>gRPC</code> 压测时所需的参数要多一些：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">ptg -t 10 -c 100 -proto grpc  -pf /xx/xx.proto -fqn hello.Hi.Say -body test.json  -tg &quot;127.0.0.1:5000&quot;</span><br></pre></td></tr></table></figure>

<p>比如需要提供 <code>proto</code> 文件的路径、具体的请求参数还有请求接口的全路径名称。</p>
<blockquote>
<p>目前只支持最常见的 unary call 调用，后续如果有需要的话也可以 stream。</p>
</blockquote>
<p>同时也支持压测时间、次数两种压测方式。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>想体验的朋友如果本地有 go 环境那直接运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get github.com/crossoverJie/ptg</span><br></pre></td></tr></table></figure>

<p>没有环境也没关系，可以再 release 页面下载与自己环境对应的版本解压使用。</p>
<p><img src="https://i.loli.net/2021/11/15/fvrtNbmxW3AOzEu.jpg" alt="go-benchmark-test.md---008i3skNly1gwf1nq32qyj31ei0sqjts.jpg"><br><a href="https://github.com/crossoverJie/ptg/releases">https://github.com/crossoverJie/ptg/releases</a></p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>整个开发过程中还是有几个点想和大家分享，首先是设计模式。</p>
<p>因为一开始设计时就考虑到需要支持不同的压测模式（次数、时间；后续也可以新增其他的模式）。</p>
<p>所以我便根据压测的生命周期定义了一套接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	Model <span class="keyword">interface</span> &#123;</span><br><span class="line">		Init()</span><br><span class="line">		Run()</span><br><span class="line">		Finish()</span><br><span class="line">		PrintSate()</span><br><span class="line">		Shutdown()</span><br><span class="line">	&#125;</span><br><span class="line">)	</span><br></pre></td></tr></table></figure>

<p>从名字也能看出来，分别对应：</p>
<ul>
<li>压测初始化</li>
<li>运行压测</li>
<li>停止压测</li>
<li>打印压测信息</li>
<li>关闭程序、释放资源</li>
</ul>
<p><img src="https://i.loli.net/2021/11/15/TQ9jVHKtOeXlSnd.jpg" alt="go-benchmark-test.md---008i3skNly1gwf21h4wa0j30pa09ewfo.jpg"><br><img src="https://i.loli.net/2021/11/15/QcmOHB6lxAUszTE.jpg" alt="go-benchmark-test.md---008i3skNly1gwf21psdzhj30p809odh6.jpg"></p>
<p>然后在两个不同的模式中进行实现。</p>
<p>这其实就是一个典型的依赖倒置原则。</p>
<blockquote>
<p>程序员要依赖于抽象接口编程、不要依赖具体的实现。</p>
</blockquote>
<p>其实大白话就是咱们 <code>Java</code> 里常说的面向接口编程；这个编程技巧在开发框架、SDK或是多种实现的业务中常用。</p>
<p>好处当然是显而易见：<br>当接口定义好之后，不同的业务只需要根据接口实现自己的业务就好，完全不会互相影响；维护、扩展都很方便。</p>
<p>支持 <code>HTTP</code> 和 <code>gRPC</code> 也是同理实现的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	Client <span class="keyword">interface</span> &#123;</span><br><span class="line">		Request() (*Response, <span class="type">error</span>)</span><br><span class="line">	&#125;</span><br><span class="line">)	</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/15/s4SY6B97GVjotAz.jpg"><br><img src="https://i.loli.net/2021/11/15/2a8vRwb9skJhtqr.jpg"></p>
<p>当然前提得是前期的接口定义需要考虑周全、不能之后频繁修改接口定义，这样的接口就没有意义了。</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>另外一点则是不得不感叹 <code>goroutine+select+channel</code> 这套并发编程模型真的好用，并且也非常容易理解。</p>
<p>很容易就能写出一套并发代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CountModel)</span></span> Init() &#123;</span><br><span class="line">	c.wait.Add(c.count)</span><br><span class="line">	c.workCh = <span class="built_in">make</span>(<span class="keyword">chan</span> *Job, c.count)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; c.count; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.workCh &lt;- &amp;Job&#123;</span><br><span class="line">				thread:   thread,</span><br><span class="line">				duration: duration,</span><br><span class="line">				count:    c.count,</span><br><span class="line">				target:   target,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如这里需要初始化 N 个 <code>goroutine</code> 执行任务，只需要使用 <code>go</code> 关键字，然后利用 channel 将任务写入。</p>
<p>当然在使用 <code>goroutine+channel</code> 配合使用时也得小心 <code>goroutine</code> 泄露的问题；简单来说就是在程序员退出时还有 <code>goroutine</code> 没有退出。</p>
<p>比较常见的例子就是向一个无缓冲的 <code>channel</code> 中写数据，当没有其他 <code>goroutine</code> 来读取数时，写入的 <code>goroutine</code> 就会被一直阻塞，最终导致泄露。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有 <code>gRPC</code> 接口压测需求的朋友欢迎试用，提出宝贵意见；当然 <code>HTTP</code> 接口也可以。</p>
<p>源码地址：<br><a href="https://github.com/crossoverJie/ptg/">https://github.com/crossoverJie/ptg/</a></p>
<p>最后如果有同样在学习 go 的朋友，特别是有 Java 开发经验的（这里大部分应该都写 Java）朋友，感兴趣的可以在公众号后台回复 “go群” 加入我创建的一个与 go 开发相关的技术群。</p>
]]></content>
      <categories>
        <category>Go</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>grpc</tag>
        <tag>http</tag>
        <tag>benchmark</tag>
        <tag>performance</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>撸了一个可调试 gRPC 的 GUI 客户端</title>
    <url>/2021/11/28/go/go-grpc-client-gui/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/11/29/FzbRvSVafJ6glCm.jpg" alt="go-grpc-client-gui.md---008i3skNly1gwuz3q9a2nj30rs0rs3z1.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平时大家写完 <code>gRPC</code> 接口后是如何测试的？往往有以下几个方法：</p>
<ol>
<li><p>写单测代码，自己模拟客户端测试。<br><img src="https://i.loli.net/2021/11/29/OVNjXQbYal7o9kP.jpg" alt="go-grpc-client-gui.md---008i3skNly1gwv0138u2ij31eq0lwn07.jpg"></p>
</li>
<li><p>可以搭一个 <code>gRPC-Gateway</code> 服务，这样就可以在 <code>postman</code> 中进行模拟。</p>
</li>
</ol>
<span id="more"></span>

<p>但这两种方法都不是特别优雅；第一种方法当请求结构体嵌套特别复杂时，在代码中维护起来就不是很直观；而且代码会特别长。</p>
<p>第二种方法在 postman 中与请求 HTTP 接口一样，看起来非常直观；但需要额为维护一个 <code>gRPC-Gateway</code> 服务，同时接口定义发生变化时也得重新发布，使用起来稍显复杂。</p>
<p>于是我经过一番搜索找到了两个看起来还不错的工具：</p>
<ul>
<li><a href="https://github.com/bloomrpc/bloomrpc">BloomRPC</a></li>
<li><a href="https://github.com/fullstorydev/grpcui">https://github.com/fullstorydev/grpcui</a></li>
</ul>
<p><img src="https://i.loli.net/2021/11/29/zJ5I12HNfpso6XK.jpg"></p>
<p>首先看 <code>BloomRPC</code> 页面美观，功能也很完善；但却有个非常难受的地方，那就是不支持 <code>int64</code> 数据的请求, 会有精度问题。</p>
<p><img src="https://i.loli.net/2021/11/29/tAFs8zbN5yRJo7d.jpg"></p>
<blockquote>
<p>这里我写了一个简单的接口，直接将请求的 <code>int64</code> 返回回来。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order)</span></span> Create(ctx context.Context, in *v1.OrderApiCreate) (*v1.Order, <span class="type">error</span>) &#123;</span><br><span class="line">	fmt.Println(in.OrderId)</span><br><span class="line">	<span class="keyword">return</span> &amp;v1.Order&#123;</span><br><span class="line">		OrderId: in.OrderId,</span><br><span class="line">		Reason:  <span class="literal">nil</span>,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会发现服务端收到的数据精度已经丢失了。</p>
<p>这个在我们大量使用 <code>int64</code> 的业务中非常难受，大部分接口都没法用了。</p>
<hr>
<p><img src="https://i.loli.net/2021/11/29/VaBdYTsGiKzMnr8.jpg"><br><code>grpcui</code> 是我在使用了 <code>BloomRPC</code> 一段时间之后才发现的工具，功能也比较完善; <code>BloomRPC</code> 中的精度问题也不存在。</p>
<p>但由于我之前已经习惯了在 <code>BloomRPC</code> 中去调试接口，加上日常开发过程中我的浏览器几乎都是开了几十个 tap 页面，导致在其中找到 <code>grpcui</code> 不是那么方便。</p>
<p>所以我就想着能不能有一个类似于  <code>BloomRPC</code> 的独立 APP，也支持 <code>int64</code> 的工具。</p>
<hr>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>找了一圈，貌似没有发现。恰好前段时间写了一个 <code>gRPC</code> 的压测工具，其实已经把该 APP 需要的核心功能也就是泛化调用实现了。</p>
<p>由于核心能力是用 Go 实现的，所以这个 APP 最好也是用 Go 来写，这样复用代码会更方便一些；正好也想看看用 Go 来实现 GUI 应用效果如何。</p>
<p>但可惜 Go 并没有提供原生的 GUI 库支持，最后翻来找去发现了一个库：<a href="https://github.com/fyne-io/fyne">fyne</a></p>
<p>从 <code>star</code> 上看用的比较多，同时也支持跨平台打包；所以最终就决定使用该库在构建这个应用。</p>
<h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><p>整个 App 的交互流程我参考了  <code>BloomRPC</code> ，但作为一个不懂审美、设计的后端开发来说，整个过程中最难的就是布局了。</p>
<p><img src="https://i.loli.net/2021/11/29/lUmXMxyZcQ3dtuW.jpg" alt="go-grpc-client-gui.md---008i3skNly1gwv8ft1l4rj30rs0eimxs.jpg"></p>
<p>这是我花了好几个晚上调试出来的第一版页面，虽然也能用但查看请求和响应数据非常不方便。</p>
<p>于是又花了一个周末最终版如下（乍一看貌似没区别）：</p>
<p><img src="https://i.loli.net/2021/11/29/GnPF5UESwNrojOl.gif" alt="ptg-min.gif"></p>
<p>虽然页面上与 <code>BloomRPC</code> 还有一定差距，但也不影响使用；关键是 <code>int64</code> 的问题解决了；又可以愉快的撸码了。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>有类似需求也想体验的朋友可以在这里下载使用：<br><a href="https://github.com/crossoverJie/ptg/releases/download/0.0.2/ptg-mac-gui.tar">https://github.com/crossoverJie/ptg/releases/download/0.0.2/ptg-mac-gui.tar</a></p>
<p>由于我手上暂时没有 <code>Windows</code> 电脑，所以就没有打包 exe 程序；有相关需求的朋友可以自行下载源码编译：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:crossoverJie/ptg.git</span><br><span class="line">cd ptg</span><br><span class="line"><span class="built_in">make</span> pkg-win</span><br></pre></td></tr></table></figure>

<h1 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h1><p>当前版本的功能还比较简陋，只支持常用的 <code>unary</code> 调用；后续也会逐步加上 <code>stream</code>、<code>metadata</code>、工作空间的存储与还原等支持。</p>
<p>对页面、交互有建议也欢迎提出。</p>
<p><img src="https://i.loli.net/2021/11/29/zTkSKE2HWPVhfgA.jpg"></p>
<blockquote>
<p>原本是准备上传到 <code>brew</code> 方便安装的，结果折腾了一晚上因为数据不够被拒了，所以对大家有帮助或者感兴趣的话帮忙点点关注（咋有种直播带货的感觉🐶） </p>
</blockquote>
<p>源码地址：<a href="https://github.com/crossoverJie/ptg">https://github.com/crossoverJie/ptg</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 日常开发常备第三方库和工具</title>
    <url>/2021/11/02/go/go-lib/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/11/15/dTLx3bkmalG2HsE.jpg"></p>
<p>不知不觉写 <code>Go</code> 已经快一年了，上线了大大小小好几个项目；心态也经历了几轮变化。</p>
<p>因为我个人大概前五年时间写的是 <code>Java</code> ，中途写过一年多的 <code>Python</code>，所以刚接触到 Go 时的感觉如下图：<br><img src="https://i.loli.net/2021/11/15/9DJWgIx4XRvFHpj.jpg"></p>
<p>既没有 <code>Java</code> 的生态，也没有 <code>Python</code> 这么多语法糖。</p>
<span id="more"></span>

<p>写到现在的感觉就是：<br><img src="https://i.loli.net/2021/11/15/EUsdxVA51v3CoQ9.jpg"></p>
<p>这里就不讨论这几门语言谁强谁弱了；重点和大家分享下我们日常开发中所使用到的一些第三方库与工具。</p>
<p>这里我主要将这些库分为两类：</p>
<ul>
<li>业务开发</li>
<li>基础工具开发</li>
</ul>
<h1 id="业务开发"><a href="#业务开发" class="headerlink" title="业务开发"></a>业务开发</h1><p>首先是业务开发，主要包含了 <code>web</code>、数据库、<code>Redis</code> 等。</p>
<h2 id="Gin-⭐️⭐️⭐️⭐️⭐️"><a href="#Gin-⭐️⭐️⭐️⭐️⭐️" class="headerlink" title="Gin ⭐️⭐️⭐️⭐️⭐️"></a>Gin ⭐️⭐️⭐️⭐️⭐️</h2><p>首先是 <a href="https://gin-gonic.com/zh-cn/docs/">Gin</a>，一款 HTTP 框架，使用简单、性能优秀、资料众多；你还在犹豫选择哪款框架时，那就选择它吧，基本没错。</p>
<p>当然和它配套的 <a href="https://github.com/swaggo/gin-swagger">github.com&#x2F;swaggo&#x2F;gin-swagger</a> swagger 工具也是刚需；利用它可以生成 swagger 文档。</p>
<h2 id="GORM-⭐️⭐️⭐️⭐️⭐️"><a href="#GORM-⭐️⭐️⭐️⭐️⭐️" class="headerlink" title="GORM ⭐️⭐️⭐️⭐️⭐️"></a>GORM ⭐️⭐️⭐️⭐️⭐️</h2><p><a href="https://gorm.io/zh_CN/">GORM</a> 也没啥好说的，如果你喜欢 <code>orm</code> 的方式操作数据库，那就选它吧；同样的也是使用简单、资料较多。</p>
<p>如果有读写分离需求，也可以使用 <code>GORM</code> 官方提供的插件 <a href="https://github.com/go-gorm/dbresolver">https://github.com/go-gorm/dbresolver</a> ，配合 <code>GORM</code> 使用也是非常简单。</p>
<h2 id="errors-⭐️⭐️⭐️⭐️⭐️"><a href="#errors-⭐️⭐️⭐️⭐️⭐️" class="headerlink" title="errors ⭐️⭐️⭐️⭐️⭐️"></a>errors ⭐️⭐️⭐️⭐️⭐️</h2><p>Go 语言自身提供的错误处理比较简单，<a href="https://github.com/pkg/errors">https://github.com/pkg/errors</a> 提供了更强大的功能，比如：</p>
<ul>
<li>包装异常</li>
<li>包装堆栈等。</li>
</ul>
<p>常用的有以下 API：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WithMessagef annotates err with the format specifier.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMessagef</span><span class="params">(err <span class="type">error</span>, format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WithStack annotates err with a stack trace at the point WithStack was called.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStack</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>


<h2 id="zorolog-⭐️⭐️⭐️⭐️⭐️"><a href="#zorolog-⭐️⭐️⭐️⭐️⭐️" class="headerlink" title="zorolog ⭐️⭐️⭐️⭐️⭐️"></a>zorolog ⭐️⭐️⭐️⭐️⭐️</h2><p>Go 里的日志打印库非常多，日志在日常开发中最好就是存在感低；也就是说性能强（不能影响到业务代码）、使用 API 简单。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;github.com/rs/zerolog/log&quot;</span></span><br><span class="line">log.Debug().Msgf(<span class="string">&quot;OrderID :%s&quot;</span>, <span class="string">&quot;12121&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="excelize"><a href="#excelize" class="headerlink" title="excelize"></a>excelize</h2><p><a href="https://github.com/qax-os/excelize">https://github.com/qax-os/excelize</a>是一个读写 Excel 的库，基本上你能遇到的 Excel 操作它都能实现。</p>
<h2 id="now-⭐️⭐️⭐️⭐️"><a href="#now-⭐️⭐️⭐️⭐️" class="headerlink" title="now ⭐️⭐️⭐️⭐️"></a>now ⭐️⭐️⭐️⭐️</h2><p><a href="https://github.com/jinzhu/now">https://github.com/jinzhu/now</a> 是一个时间工具库：</p>
<ul>
<li>获取当前的年月日、时分秒。</li>
<li>不同时区支持。</li>
<li>最后一周、最后一个月等。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/jinzhu/now&quot;</span></span><br><span class="line"></span><br><span class="line">time.Now() <span class="comment">// 2013-11-18 17:51:49.123456789 Mon</span></span><br><span class="line"></span><br><span class="line">now.BeginningOfMinute()        <span class="comment">// 2013-11-18 17:51:00 Mon</span></span><br><span class="line">now.BeginningOfHour()          <span class="comment">// 2013-11-18 17:00:00 Mon</span></span><br><span class="line">now.BeginningOfDay()           <span class="comment">// 2013-11-18 00:00:00 Mon</span></span><br><span class="line">now.BeginningOfWeek()          <span class="comment">// 2013-11-17 00:00:00 Sun</span></span><br><span class="line">now.BeginningOfMonth()         <span class="comment">// 2013-11-01 00:00:00 Fri</span></span><br><span class="line">now.BeginningOfQuarter()       <span class="comment">// 2013-10-01 00:00:00 Tue</span></span><br><span class="line">now.BeginningOfYear()          <span class="comment">// 2013-01-01 00:00:00 Tue</span></span><br><span class="line"></span><br><span class="line">now.EndOfMinute()              <span class="comment">// 2013-11-18 17:51:59.999999999 Mon</span></span><br><span class="line">now.EndOfHour()                <span class="comment">// 2013-11-18 17:59:59.999999999 Mon</span></span><br><span class="line">now.EndOfDay()                 <span class="comment">// 2013-11-18 23:59:59.999999999 Mon</span></span><br><span class="line">now.EndOfWeek()                <span class="comment">// 2013-11-23 23:59:59.999999999 Sat</span></span><br><span class="line">now.EndOfMonth()               <span class="comment">// 2013-11-30 23:59:59.999999999 Sat</span></span><br><span class="line">now.EndOfQuarter()             <span class="comment">// 2013-12-31 23:59:59.999999999 Tue</span></span><br><span class="line">now.EndOfYear()                <span class="comment">// 2013-12-31 23:59:59.999999999 Tue</span></span><br><span class="line"></span><br><span class="line">now.WeekStartDay = time.Monday <span class="comment">// Set Monday as first day, default is Sunday</span></span><br><span class="line">now.EndOfWeek()                <span class="comment">// 2013-11-24 23:59:59.999999999 Sun</span></span><br></pre></td></tr></table></figure>

<h2 id="Decimal-⭐️⭐️⭐️⭐️"><a href="#Decimal-⭐️⭐️⭐️⭐️" class="headerlink" title="Decimal ⭐️⭐️⭐️⭐️"></a>Decimal ⭐️⭐️⭐️⭐️</h2><p>当业务上需要精度计算时 <a href="https://github.com/shopspring/decimal">https://github.com/shopspring/decimal</a> 可以帮忙。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/shopspring/decimal&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	price, err := decimal.NewFromString(<span class="string">&quot;136.02&quot;</span>)</span><br><span class="line"></span><br><span class="line">	quantity := decimal.NewFromInt(<span class="number">3</span>)</span><br><span class="line">	fee, _ := decimal.NewFromString(<span class="string">&quot;.035&quot;</span>)</span><br><span class="line">	taxRate, _ := decimal.NewFromString(<span class="string">&quot;.08875&quot;</span>)</span><br><span class="line"></span><br><span class="line">	subtotal := price.Mul(quantity)</span><br><span class="line"></span><br><span class="line">	preTax := subtotal.Mul(fee.Add(decimal.NewFromFloat(<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">	total := preTax.Mul(taxRate.Add(decimal.NewFromFloat(<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Subtotal:&quot;</span>, subtotal)                      <span class="comment">// Subtotal: 408.06</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Pre-tax:&quot;</span>, preTax)                         <span class="comment">// Pre-tax: 422.3421</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Taxes:&quot;</span>, total.Sub(preTax))                <span class="comment">// Taxes: 37.482861375</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Total:&quot;</span>, total)                            <span class="comment">// Total: 459.824961375</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Tax rate:&quot;</span>, total.Sub(preTax).Div(preTax)) <span class="comment">// Tax rate: 0.08875</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本上你能想到的精度转换它都能做到；配合上 <code>GORM</code> 也可以将 <code>model</code> 字段声明为 <code>decimal</code> 的类型，数据库对应的也是 <code>decimal</code> ，这样使用起来时会更方便。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Amount decimal.Decimal <span class="string">`gorm:&quot;column:amout;default:0.0000;NOT NULL&quot; json:&quot;amout&quot;`</span> </span><br></pre></td></tr></table></figure>

<h2 id="configor-⭐️⭐️⭐️⭐️"><a href="#configor-⭐️⭐️⭐️⭐️" class="headerlink" title="configor ⭐️⭐️⭐️⭐️"></a>configor ⭐️⭐️⭐️⭐️</h2><p><a href="https://github.com/jinzhu/configor">https://github.com/jinzhu/configor</a> 是一个配置文件读取库，支持 <code>YAML/JSON/TOML</code> 等格式。</p>
<h2 id="go-cache-⭐️⭐️⭐️"><a href="#go-cache-⭐️⭐️⭐️" class="headerlink" title="go-cache ⭐️⭐️⭐️"></a>go-cache ⭐️⭐️⭐️</h2><p><a href="https://github.com/patrickmn/go-cache">https://github.com/patrickmn/go-cache</a> 是一个类似于 Java 中的 <code>Guava cache</code>，线程安全，使用简单；不需要分布式缓存的简单场景可以考虑。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := cache.New(<span class="number">5</span>*time.Minute, <span class="number">10</span>*time.Minute)</span><br><span class="line"><span class="comment">// Set the value of the key &quot;foo&quot; to &quot;bar&quot;, with the default expiration time</span></span><br><span class="line">c.Set(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, cache.DefaultExpiration)</span><br></pre></td></tr></table></figure>

<h2 id="copier-⭐️⭐️⭐️"><a href="#copier-⭐️⭐️⭐️" class="headerlink" title="copier ⭐️⭐️⭐️"></a>copier ⭐️⭐️⭐️</h2><p><a href="https://github.com/jinzhu/copier">https://github.com/jinzhu/copier</a> 看名字就知道这是一个数据复制的库，与 <code>Java</code> 中的 <code>BeanUtils.copy()</code> 类似；可以将两个字段相同但对象不同的  <code>struct</code> 进行数据复制，也支持深拷贝。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(toValue <span class="keyword">interface</span>&#123;&#125;, fromValue <span class="keyword">interface</span>&#123;&#125;)</span></span> (err <span class="type">error</span>) </span><br></pre></td></tr></table></figure>

<p>在我们需要一个临时 struct 来存放数据时很有用，特别是一个 struct 中字段非常多时，一个个来回赋值确实有点费手指。</p>
<p>但也要注意不要什么情况都使用，会带来一些弊端：</p>
<ul>
<li>当删除字段时，不能利用编译器提示。</li>
<li>当一些字段需要额外人工处理时，代码不易阅读。</li>
<li>反射赋值，有一定性能损耗。</li>
</ul>
<p>总之在业务开发时，还是建议人工编写，毕竟代码是给人看的。</p>
<h2 id="env-⭐️⭐️⭐️"><a href="#env-⭐️⭐️⭐️" class="headerlink" title="env ⭐️⭐️⭐️"></a>env ⭐️⭐️⭐️</h2><p><a href="https://github.com/caarlos0/env">https://github.com/caarlos0/env</a> 这个库可以将我们的环境变量转换为一个 <code>struct</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">	Home <span class="type">string</span> <span class="string">`env:&quot;HOME&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cfg := config&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> err := env.Parse(&amp;cfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个在我们打包代码到不同的运行环境时非常有用，利用它可以方便的获取不同环境变量。</p>
<h2 id="user-agent-⭐️⭐️⭐️"><a href="#user-agent-⭐️⭐️⭐️" class="headerlink" title="user_agent ⭐️⭐️⭐️"></a>user_agent ⭐️⭐️⭐️</h2><p><a href="https://github.com/mssola/user_agent">https://github.com/mssola/user_agent</a> 是一个格式化 <code>user-agent</code> 的小工具。</p>
<p>当我们需要在服务端收集 <code>user-agen</code> 时可以更快的读取数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ua := user_agent.New(<span class="string">&quot;Mozilla/5.0 (Linux; U; Android 2.3.7; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, ua.Mobile())   <span class="comment">// =&gt; true</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, ua.Bot())      <span class="comment">// =&gt; false</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, ua.Mozilla())  <span class="comment">// =&gt; &quot;5.0&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, ua.Model())    <span class="comment">// =&gt; &quot;Nexus One&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, ua.Platform()) <span class="comment">// =&gt; &quot;Linux&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, ua.OS()) </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="phonenumbers-⭐️⭐️⭐️"><a href="#phonenumbers-⭐️⭐️⭐️" class="headerlink" title="phonenumbers ⭐️⭐️⭐️"></a>phonenumbers ⭐️⭐️⭐️</h2><p><a href="https://github.com/nyaruka/phonenumbers">https://github.com/nyaruka/phonenumbers</a> 手机号码验证库，可以不用自己写正则表达式了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parse our phone number</span></span><br><span class="line">num, err := phonenumbers.Parse(<span class="string">&quot;6502530000&quot;</span>, <span class="string">&quot;US&quot;</span>)</span><br></pre></td></tr></table></figure>




<h1 id="基础工具"><a href="#基础工具" class="headerlink" title="基础工具"></a>基础工具</h1><p>接下来是一些基础工具库，包含一些主流的存储的客户端、中间件等。</p>
<h2 id="gomonkey-⭐️⭐️⭐️⭐️⭐️"><a href="#gomonkey-⭐️⭐️⭐️⭐️⭐️" class="headerlink" title="gomonkey ⭐️⭐️⭐️⭐️⭐️"></a>gomonkey ⭐️⭐️⭐️⭐️⭐️</h2><p><a href="github.com/agiledragon/gomonkey">github.com&#x2F;agiledragon&#x2F;gomonkey</a> 是一个 <code>mock</code> 打桩工具，当我们写单元测试时，需要对一些非接口函数进行 <code>mock</code> 会比较困难，这时就需要用到它了。</p>
<p>由于它是修改了调用对应函数时机器跳转指令，而 CPU 架构的不同对应的指令也不同，所以在我们使用时还不兼容苹果的 M1 芯片，不过目前应该已经兼容了，大家可以试试。</p>
<h2 id="goconvey-⭐️⭐️⭐️⭐️⭐️"><a href="#goconvey-⭐️⭐️⭐️⭐️⭐️" class="headerlink" title="goconvey ⭐️⭐️⭐️⭐️⭐️"></a>goconvey ⭐️⭐️⭐️⭐️⭐️</h2><p><a href="https://github.com/smartystreets/goconvey">https://github.com/smartystreets/goconvey</a> 也是配合单元测试的库，可以兼容 <code>go test</code> 命令。</p>
<ul>
<li>提供可视化 web UI。</li>
<li>与 IDE 集成显示单元覆盖率。<br><img src="https://i.loli.net/2021/11/15/OvbkDrHTsyMPXpJ.jpg"></li>
</ul>
<h2 id="dig-⭐️⭐️⭐️⭐️⭐️"><a href="#dig-⭐️⭐️⭐️⭐️⭐️" class="headerlink" title="dig ⭐️⭐️⭐️⭐️⭐️"></a>dig ⭐️⭐️⭐️⭐️⭐️</h2><p><a href="https://github.com/uber-go/dig">https://github.com/uber-go/dig</a> 这是一个依赖注入库，我们这里暂不讨论是否应该使用依赖注入，至少目前我们使用下来还是有几个好处：</p>
<ul>
<li>所有的对象都是单例。</li>
<li>有一个统一的地方管理对象。</li>
<li>使用时直接传递对象当做参数进来即可（容器会自动注入）。</li>
</ul>
<p>当然也有一些不太方便的地方：</p>
<ul>
<li>不熟悉时，一个对象是如何创建的不清楚。</li>
<li>代码不是很好理解。</li>
</ul>
<p>我们内部有自己开发一个业务框架，其中所有的对象都交由 dig 进行管理，使用起来倒也是比较方便。</p>
<h2 id="cobra-⭐️⭐️⭐️⭐️"><a href="#cobra-⭐️⭐️⭐️⭐️" class="headerlink" title="cobra ⭐️⭐️⭐️⭐️"></a>cobra ⭐️⭐️⭐️⭐️</h2><p><a href="https://github.com/spf13/cobra">https://github.com/spf13/cobra</a>是一个功能强大的命令行工具库，我们用它来实现内部的命令行工具，同时也推荐使用 <a href="https://github.com/urfave/cli/">https://github.com/urfave/cli/</a> 我个人会更习惯用后者，要简洁一些。</p>
<h2 id="BloomRPC-⭐️⭐️⭐️⭐️"><a href="#BloomRPC-⭐️⭐️⭐️⭐️" class="headerlink" title="BloomRPC ⭐️⭐️⭐️⭐️"></a>BloomRPC ⭐️⭐️⭐️⭐️</h2><p><a href="https://github.com/uw-labs/bloomrpc">https://github.com/uw-labs/bloomrpc</a> 一个 <code>gRPC</code> 可视化工具，比起自己写 <code>gRPC</code> 客户端的代码那确实是要简单许多。</p>
<p><img src="https://i.loli.net/2021/11/15/81grVLXcMyFCNSD.jpg"><br>但也有些小问题，比如精度。如果是 int64 超过了 2^56 服务端拿到的值会发生错误，这点目前还未解决。</p>
<h2 id="redis-⭐️⭐️⭐️⭐️"><a href="#redis-⭐️⭐️⭐️⭐️" class="headerlink" title="redis ⭐️⭐️⭐️⭐️"></a>redis ⭐️⭐️⭐️⭐️</h2><p><a href="https://github.com/go-redis/redis/">https://github.com/go-redis/redis/</a> Redis 客户端，没有太多可说的；发展了许多年，该有的的功能都有了。</p>
<h2 id="elastic-⭐️⭐️⭐️⭐️"><a href="#elastic-⭐️⭐️⭐️⭐️" class="headerlink" title="elastic ⭐️⭐️⭐️⭐️"></a>elastic ⭐️⭐️⭐️⭐️</h2><p><a href="https://github.com/olivere/elastic">https://github.com/olivere/elastic</a> 这也是一个非常成熟的 <code>elasticsearch</code> 库。</p>
<h2 id="resty-⭐️⭐️⭐️⭐️"><a href="#resty-⭐️⭐️⭐️⭐️" class="headerlink" title="resty ⭐️⭐️⭐️⭐️"></a>resty ⭐️⭐️⭐️⭐️</h2><p><a href="https://github.com/go-resty/resty/">https://github.com/go-resty/resty/</a>  一个 http client, 使用起来非常简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a Resty Client</span></span><br><span class="line">client := resty.New()</span><br><span class="line">resp, err := client.R().</span><br><span class="line">    EnableTrace().</span><br><span class="line">    Get(<span class="string">&quot;https://httpbin.org/get&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>有点 <code>Python requests</code> 包那味了。</p>
<h2 id="pulsar-client-go-⭐️⭐️⭐️"><a href="#pulsar-client-go-⭐️⭐️⭐️" class="headerlink" title="pulsar-client-go ⭐️⭐️⭐️"></a>pulsar-client-go ⭐️⭐️⭐️</h2><p>Pulsar 官方出品的 go 语言客户端，相对于 Java 来说其他语言的客户端几乎都是后娘养的；功能会比较少，同时更新也没那么积极；但却没得选。</p>
<h2 id="go-grpc-middleware-⭐️⭐️⭐️"><a href="#go-grpc-middleware-⭐️⭐️⭐️" class="headerlink" title="go-grpc-middleware ⭐️⭐️⭐️"></a>go-grpc-middleware ⭐️⭐️⭐️</h2><p><a href="https://github.com/grpc-ecosystem/go-grpc-middleware">https://github.com/grpc-ecosystem/go-grpc-middleware</a> 官方提供的 <code>gRPC</code> 中间件，可以自己实现内部的一些鉴权、元数据、日志等功能。</p>
<h2 id="go-pilosa-⭐️⭐️⭐️"><a href="#go-pilosa-⭐️⭐️⭐️" class="headerlink" title="go-pilosa ⭐️⭐️⭐️"></a>go-pilosa ⭐️⭐️⭐️</h2><p><a href="https://github.com/pilosa/go-pilosa">https://github.com/pilosa/go-pilosa</a> 是一个位图数据库的客户端，位图数据库的场景应用比较有限，通常是有标签需求时才会用到；比如求 N 个标签的交并补集；数据有一定规模后运营一定会提相关需求；可以备着以备不时之需。</p>
<h2 id="pb-⭐️⭐️⭐️"><a href="#pb-⭐️⭐️⭐️" class="headerlink" title="pb ⭐️⭐️⭐️"></a>pb ⭐️⭐️⭐️</h2><p><a href="https://github.com/cheggaaa/pb">https://github.com/cheggaaa/pb</a> 一个命令行工具进度条，编写命令行工具时使用它交互会更优雅。</p>
<p><img src="https://i.loli.net/2021/11/15/lrNwUd1HFZuiQoe.gif" alt="go-benchmark-test.md---008i3skNly1gw04urcj16g30gn0571kz.gif"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后我汇总了一个表格，方便查看：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>功能</th>
<th>星级</th>
</tr>
</thead>
<tbody><tr>
<td>Gin</td>
<td>业务开发</td>
<td><code>HTTP</code> 框架</td>
<td>⭐️⭐️⭐️⭐️⭐️</td>
</tr>
<tr>
<td>GORM</td>
<td>业务开发</td>
<td><code>ORM</code> 框架</td>
<td>⭐️⭐️⭐️⭐️⭐️</td>
</tr>
<tr>
<td>errors</td>
<td>业务开发</td>
<td>异常处理库</td>
<td>⭐️⭐️⭐️⭐️⭐️</td>
</tr>
<tr>
<td>zorolog</td>
<td>业务开发</td>
<td>日志库</td>
<td>⭐️⭐️⭐️⭐️⭐️</td>
</tr>
<tr>
<td>excelize</td>
<td>业务开发</td>
<td><code>Excel</code>相关需求</td>
<td>⭐️⭐️⭐️⭐️⭐️</td>
</tr>
<tr>
<td>now</td>
<td>业务开发</td>
<td>时间处理</td>
<td>⭐️⭐️⭐️⭐️️</td>
</tr>
<tr>
<td>Decimal</td>
<td>业务开发</td>
<td>精度处理</td>
<td>⭐️⭐️⭐️⭐️️</td>
</tr>
<tr>
<td>configor</td>
<td>业务开发</td>
<td>配置文件</td>
<td>⭐️⭐️⭐️⭐️️</td>
</tr>
<tr>
<td>go-cache</td>
<td>业务开发</td>
<td>本地缓存</td>
<td>⭐️⭐️⭐️</td>
</tr>
<tr>
<td>copier</td>
<td>业务开发</td>
<td>数据复制</td>
<td>⭐️⭐️⭐️️️</td>
</tr>
<tr>
<td>env</td>
<td>业务开发</td>
<td>环境变量</td>
<td>⭐️⭐️⭐️️️</td>
</tr>
<tr>
<td>user_agent</td>
<td>业务开发</td>
<td>读取 <code>user-agent</code></td>
<td>⭐️⭐️⭐️️️</td>
</tr>
<tr>
<td>phonenumbers</td>
<td>业务开发</td>
<td>手机号码验证</td>
<td>⭐️⭐️⭐️️️</td>
</tr>
<tr>
<td>gomonkey</td>
<td>基础工具</td>
<td><code>mock</code>工具</td>
<td>⭐️⭐️⭐️⭐️⭐</td>
</tr>
<tr>
<td>goconvey</td>
<td>基础工具</td>
<td>单测覆盖率</td>
<td>⭐️⭐️⭐️⭐️⭐</td>
</tr>
<tr>
<td>dig</td>
<td>基础工具</td>
<td>依赖注入</td>
<td>⭐️⭐️⭐️⭐️⭐</td>
</tr>
<tr>
<td>cobra</td>
<td>基础工具</td>
<td>命令行工具</td>
<td>⭐️⭐️⭐️⭐</td>
</tr>
<tr>
<td>cli</td>
<td>基础工具</td>
<td>命令行工具</td>
<td>⭐️⭐️⭐️⭐</td>
</tr>
<tr>
<td>BloomRPC</td>
<td>基础工具</td>
<td><code>gRPC</code> 调试客户端</td>
<td>⭐️⭐️⭐️⭐</td>
</tr>
<tr>
<td>redis</td>
<td>基础工具</td>
<td>Redis 客户端</td>
<td>⭐️⭐️⭐️⭐</td>
</tr>
<tr>
<td>elastic</td>
<td>基础工具</td>
<td><code>elasticsearch</code> 客户端</td>
<td>⭐️⭐️⭐️⭐</td>
</tr>
<tr>
<td>resty</td>
<td>基础工具</td>
<td>http 客户端</td>
<td>⭐️⭐️⭐️⭐</td>
</tr>
<tr>
<td>pulsar-client-go</td>
<td>基础工具</td>
<td><code>Pulsar</code> 客户端</td>
<td>⭐️⭐️⭐️</td>
</tr>
<tr>
<td>go-grpc-middleware</td>
<td>基础工具</td>
<td><code>gRPC</code> 中间件</td>
<td>⭐️⭐️⭐</td>
</tr>
<tr>
<td>go-pilosa</td>
<td>基础工具</td>
<td><code>pilosa</code> 客户端</td>
<td>⭐️⭐️⭐️</td>
</tr>
<tr>
<td><a href="https://github.com/cheggaaa/pb">pb</a></td>
<td>基础工具</td>
<td>命令行工具进度条</td>
<td>⭐️⭐️⭐️</td>
</tr>
</tbody></table>
<blockquote>
<p>星级评分的规则主要是看实际使用的频次。</p>
</blockquote>
<p>最后夹带一点私货（其实也谈不上）<br>文中提到了我们内部有基于以上库整合了一个业务开发框架；也基于该框架上线了大大小小10几个项目，改进空间依然不少，目前还是在快速迭代中。</p>
<p>大概的用法，入口 <code>main.go</code>:<br><img src="https://i.loli.net/2021/11/15/YWcphM86xnKBjsE.jpg"><br><img src="https://i.loli.net/2021/11/15/pZ4SxVoEuikPOB9.jpg"><br>最后截取我在内部的分享就概括了整体的思想<code>--引用自公司一司姓同事</code>。</p>
<p>也许我们内部经过多次迭代，觉得有能力开放出来给社区带来一些帮助时也会尝试开源；现阶段就不嫌丑了。</p>
<p>这些库都是我们日常开发最常用到的，也欢迎大家在评论区留下你们常用的库与工具。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>gomonkey</tag>
        <tag>zerolog</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 里的超时控制</title>
    <url>/2021/10/28/go/go-timeout/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/11/15/yI7WFgfcobRiHkx.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>日常开发中我们大概率会遇到超时控制的场景，比如一个批量耗时任务、网络请求等；一个良好的超时控制可以有效的避免一些问题（比如 <code>goroutine</code> 泄露、资源不释放等）。</p>
<span id="more"></span>

<h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>在 go 中实现超时控制的方法非常简单，首先第一种方案是 <code>Time.After(d Duration)</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(time.Now())</span><br><span class="line">	x := &lt;-time.After(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2021-10-27 23:06:04.304596 +0800 CST m=+0.000085653</span><br><span class="line">2021-10-27 23:06:07.306311 +0800 CST m=+3.001711390</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/15/E4eIjN9nHrcTpOk.jpg"></p>
<p><code>time.After()</code> 会返回一个 <code>Channel</code>，该 <code>Channel</code> 会在延时 d 段时间后写入数据。</p>
<p>有了这个特性就可以实现一些异步控制超时的场景：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;do something...&quot;</span>)</span><br><span class="line">		time.Sleep(<span class="number">4</span>*time.Second)</span><br><span class="line">		ch&lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">		fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">3</span>*time.Second):</span><br><span class="line">		fmt.Println(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里假设有一个 <code>goroutine</code> 在跑一个耗时任务，利用 select 有一个 <code>channel</code> 获取到数据便退出的特性，当 <code>goroutine</code> 没有在有限时间内完成任务时，主 <code>goroutine</code> 便会退出，也就达到了超时的目的。</p>
<p>output:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">do something...</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>



<p>timer.After 取消，同时 Channel 发出消息，也可以关闭通道等通知方式。</p>
<p>注意 Channel 最好是有大小，防止阻塞 goroutine ，导致泄露。</p>
<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>第二种方案是利用 context，go 的 context 功能强大；<br><img src="https://i.loli.net/2021/11/15/Z4pzi1THxMFXCWj.jpg"><br>利用 <code>context.WithTimeout()</code> 方法会返回一个具有超时功能的上下文。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">timeout, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">	ch &lt;- <span class="string">&quot;done&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> res := &lt;-ch:</span><br><span class="line">	fmt.Println(res)</span><br><span class="line"><span class="keyword">case</span> &lt;-timeout.Done():</span><br><span class="line">	fmt.Println(<span class="string">&quot;timout&quot;</span>, timeout.Err())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的用法，<code>context</code> 的 <code>Done()</code> 函数会返回一个 <code>channel</code>，该 <code>channel</code> 会在当前工作完成或者是上下文取消生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">timout context deadline exceeded</span><br></pre></td></tr></table></figure>

<p>通过 <code>timeout.Err()</code> 也能知道当前 <code>context </code> 关闭的原因。</p>
<h2 id="goroutine-传递-context"><a href="#goroutine-传递-context" class="headerlink" title="goroutine 传递 context"></a>goroutine 传递 context</h2><p>使用 <code>context</code> 还有一个好处是，可以利用其天然在多个 goroutine 中传递的特性，让所有传递了该 context 的 goroutine 同时接收到取消通知，这点在多 go 中应用非常广泛。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	total := <span class="number">12</span></span><br><span class="line">	<span class="keyword">var</span> num <span class="type">int32</span></span><br><span class="line">	log.Println(<span class="string">&quot;begin&quot;</span>)</span><br><span class="line">	ctx, cancelFunc := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; total; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">//time.Sleep(3 * time.Second)</span></span><br><span class="line">			atomic.AddInt32(&amp;num, <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span> atomic.LoadInt32(&amp;num) == <span class="number">10</span> &#123;</span><br><span class="line">				cancelFunc()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				log.Println(<span class="string">&quot;ctx1 done&quot;</span>, ctx.Err())</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">				<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">						log.Println(<span class="string">&quot;ctx2 done&quot;</span>, ctx.Err())</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;()</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second*<span class="number">5</span>)</span><br><span class="line">	log.Println(<span class="string">&quot;end&quot;</span>, ctx.Err())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;执行完毕 %v&quot;</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上例子中，无论 <code>goroutine</code> 嵌套了多少层，都是可以在 <code>context</code> 取消时获得消息（当然前提是 <code>context</code> 得传递走）</p>
<p>某些特殊情况需要提前取消 context 时，也可以手动调用 <code>cancelFunc()</code> 函数。</p>
<h2 id="Gin-中的案例"><a href="#Gin-中的案例" class="headerlink" title="Gin 中的案例"></a>Gin 中的案例</h2><p>Gin 提供的 <code>Shutdown(ctx)</code> 函数也充分使用了 <code>context</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">if</span> err := srv.Shutdown(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(<span class="string">&quot;Server Shutdown:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;Server exiting&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/15/KhaxHcAbd3foJjZ.jpg"></p>
<p>比如以上代码便是超时等待 10s 进行 <code>Gin</code> 的资源释放，实现的原理也和上文的例子相同。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为写 go 的时间不长，所以自己写了一个练手的项目：一个接口压力测试工具。</p>
<p><img src="https://i.loli.net/2021/11/15/lrNwUd1HFZuiQoe.gif" alt="go-benchmark-test.md---008i3skNly1gw04urcj16g30gn0571kz.gif"><br><img src="https://i.loli.net/2021/11/15/VMFemnbtlI8JXZP.jpg"></p>
<p>其中一个很常见的需求就是压测 N 秒后退出，这里正好就应用到了相关知识点，同样是初学 <code>go</code> 的小伙伴可以参考。</p>
<p><a href="https://github.com/crossoverJie/ptg/blob/d0781fcb5551281cf6d90a86b70130149e1525a6/duration.go#L41">https://github.com/crossoverJie/ptg/blob/d0781fcb5551281cf6d90a86b70130149e1525a6/duration.go#L41</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>timer</tag>
      </tags>
  </entry>
  <entry>
    <title>写了一个 gorm 乐观锁插件</title>
    <url>/2021/03/15/go/gorm-optimistic/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/03/26/kiPBytpXJ7T4csH.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在用 <code>Go</code> 写业务的时碰到了并发更新数据的场景，由于该业务并发度不高，只是为了防止出现并发时数据异常。</p>
<p>所以自然就想到了乐观锁的解决方案。</p>
<span id="more"></span>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>乐观锁的实现比较简单，相信大部分有数据库使用经验的都能想到。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `<span class="keyword">table</span>` <span class="keyword">SET</span> `amount`<span class="operator">=</span><span class="number">100</span>,`version`<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> `version` <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> `id` <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>需要在表中新增一个类似于 <code>version</code> 的字段，本质上我们只是执行这段 <code>SQL</code>，在更新时比较当前版本与数据库版本是否一致。</p>
<p><img src="https://i.loli.net/2021/03/26/FYTKZ2lS1WhDg6w.jpg"></p>
<p>如上图所示：版本一致则更新成功，并且将版本号+1；如果不一致则认为出现并发冲突，更新失败。</p>
<p>这时可以直接返回失败，让业务重试；当然也可以再次获取最新数据进行更新尝试。</p>
<hr>
<p>我们使用的是 <code>gorm</code> 这个 <code>orm</code> 库，不过我查阅了官方文档却没有发现乐观锁相关的支持，看样子后续也不打算提供实现。</p>
<p><img src="https://i.loli.net/2021/03/26/CHGLJpvBn4SK89i.jpg"></p>
<p>不过借助 <code>gorm</code> 实现也很简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Optimistic <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id      <span class="type">int64</span>   <span class="string">`gorm:&quot;column:id;primary_key;AUTO_INCREMENT&quot; json:&quot;id&quot;`</span></span><br><span class="line">	UserId  <span class="type">string</span>  <span class="string">`gorm:&quot;column:user_id;default:0;NOT NULL&quot; json:&quot;user_id&quot;`</span> <span class="comment">// 用户ID</span></span><br><span class="line">	Amount  <span class="type">float32</span> <span class="string">`gorm:&quot;column:amount;NOT NULL&quot; json:&quot;amount&quot;`</span>             <span class="comment">// 金额</span></span><br><span class="line">	Version <span class="type">int64</span>   <span class="string">`gorm:&quot;column:version;default:0;NOT NULL&quot; json:&quot;version&quot;`</span> <span class="comment">// 版本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUpdate</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	dsn := <span class="string">&quot;root:abc123@/test?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">	db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> out Optimistic</span><br><span class="line">	db.First(&amp;out, Optimistic&#123;Id: <span class="number">1</span>&#125;)</span><br><span class="line">	out.Amount = out.Amount + <span class="number">10</span></span><br><span class="line">	column := db.Model(&amp;out).Where(<span class="string">&quot;id&quot;</span>, out.Id).Where(<span class="string">&quot;version&quot;</span>, out.Version).</span><br><span class="line">		UpdateColumn(<span class="string">&quot;amount&quot;</span>, out.Amount).</span><br><span class="line">		UpdateColumn(<span class="string">&quot;version&quot;</span>, gorm.Expr(<span class="string">&quot;version+1&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;#######update %v line \n&quot;</span>, column.RowsAffected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们创建了一张 <code>t_optimistic</code> 表用于测试，生成的 <code>SQL</code> 也满足乐观锁的要求。</p>
<p>不过考虑到这类业务的通用性，每次需要乐观锁更新时都需要这样硬编码并不太合适。对于业务来说其实 <code>version</code> 是多少压根不需要关心，只要能满足并发更新时的准确性即可。</p>
<p>因此我做了一个封装，最终使用如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> out Optimistic</span><br><span class="line">db.First(&amp;out, Optimistic&#123;Id: <span class="number">1</span>&#125;)</span><br><span class="line">out.Amount = out.Amount + <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> err = UpdateWithOptimistic(db, &amp;out, <span class="literal">nil</span>, <span class="number">0</span>, <span class="number">0</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%+v \n&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的使用场景是每次更新时将 <code>amount</code> 金额加上 <code>10</code>。</li>
</ul>
<p>这样只会更新一次，如果更新失败会返回一个异常。</p>
<p>当然也支持更新失败时执行一个回调函数，在该函数中实现对应的业务逻辑，同时会使用该业务逻辑尝试更新 N 次。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUpdateWithOptimistic</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	dsn := <span class="string">&quot;root:abc123@/test?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">	db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> out Optimistic</span><br><span class="line">		db.First(&amp;out, Optimistic&#123;Id: <span class="number">1</span>&#125;)</span><br><span class="line">		out.Amount = out.Amount + <span class="number">10</span></span><br><span class="line">		err = UpdateWithOptimistic(db, &amp;out, <span class="function"><span class="keyword">func</span><span class="params">(model Lock)</span></span> Lock &#123;</span><br><span class="line">			bizModel := model.(*Optimistic)</span><br><span class="line">			bizModel.Amount = bizModel.Amount + <span class="number">10</span></span><br><span class="line">			<span class="keyword">return</span> bizModel</span><br><span class="line">		&#125;, <span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%+v \n&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的目的是：</p>
<p>将 <code>amount</code> 金额 <code>+10</code>，失败时再次依然将金额+10，尝试更新 <code>3</code> 次；经过上述的并行测试，最终查看数据库确认数据并没有发生错误。</p>
<h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><p>下面来看看具体是如何实现的；其实真正核心的代码也比较少：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateWithOptimistic</span><span class="params">(db *gorm.DB, model Lock, callBack <span class="keyword">func</span>(model Lock)</span></span> Lock, retryCount, currentRetryCount <span class="type">int32</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> currentRetryCount &gt; retryCount &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithStack(NewOptimisticError(<span class="string">&quot;Maximum number of retries exceeded:&quot;</span> + strconv.Itoa(<span class="type">int</span>(retryCount))))</span><br><span class="line">	&#125;</span><br><span class="line">	currentVersion := model.GetVersion()</span><br><span class="line">	model.SetVersion(currentVersion + <span class="number">1</span>)</span><br><span class="line">	column := db.Model(model).Where(<span class="string">&quot;version&quot;</span>, currentVersion).UpdateColumns(model)</span><br><span class="line">	affected := column.RowsAffected</span><br><span class="line">	<span class="keyword">if</span> affected == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> callBack == <span class="literal">nil</span> &amp;&amp; retryCount == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.WithStack(NewOptimisticError(<span class="string">&quot;Concurrent optimistic update error&quot;</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		db.First(model)</span><br><span class="line">		bizModel := callBack(model)</span><br><span class="line">		currentRetryCount++</span><br><span class="line">		err := UpdateWithOptimistic(db, bizModel, callBack, retryCount, currentRetryCount)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> column.Error</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体步骤如下：</p>
<ul>
<li>判断重试次数是否达到上限。</li>
<li>获取当前更新对象的版本号，将当前版本号 +1。</li>
<li>根据版本号条件执行更新语句。</li>
<li>更新成功直接返回。</li>
<li>更新失败 <code>affected == 0</code>  时，执行重试逻辑。<ul>
<li>重新查询该对象的最新数据，目的是获取最新版本号。</li>
<li>执行回调函数。</li>
<li>从回调函数中拿到最新的业务数据。</li>
<li>递归调用自己执行更新，直到重试次数达到上限。</li>
</ul>
</li>
</ul>
<p>这里有几个地方值得说一下；由于 <code>Go</code> 目前还不支持泛型，所以我们如果想要获取 <code>struct</code> 中的 <code>version</code> 字段只能通过反射。</p>
<p>考虑到反射的性能损耗以及代码的可读性，有没有更”优雅“的实现方式呢？</p>
<p>于是我定义了一个 <code>interface</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">	SetVersion(version <span class="type">int64</span>)</span><br><span class="line">	GetVersion() <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中只有两个方法，目的则是获取 <code>struct</code> 中的 <code>version</code> 字段；所以每个需要乐观锁的 <code>struct</code> 都得实现该接口，类似于这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Optimistic)</span></span> GetVersion() <span class="type">int64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> o.Version</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Optimistic)</span></span> SetVersion(version <span class="type">int64</span>) &#123;</span><br><span class="line">	o.Version = version</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样还带来了一个额外的好处：</p>
<p><img src="https://i.loli.net/2021/03/26/nrA3FCHx4w1vLMV.jpg"></p>
<p>一旦该结构体没有实现接口，在乐观锁更新时编译器便会提前报错，如果使用反射只能是在运行期间才能进行校验。</p>
<p>所以这里在接收数据库实体的便可以是 <code>Lock</code> 接口，同时获取和重新设置 <code>version</code> 字段也是非常的方便。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">currentVersion := model.GetVersion()</span><br><span class="line">model.SetVersion(currentVersion + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>当并发更新失败时<code>affected == 0</code>，便会回调传入进来的回调函数，在回调函数中我们需要实现自己的业务逻辑。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = UpdateWithOptimistic(db, &amp;out, <span class="function"><span class="keyword">func</span><span class="params">(model Lock)</span></span> Lock &#123;</span><br><span class="line">			bizModel := model.(*Optimistic)</span><br><span class="line">			bizModel.Amount = bizModel.Amount + <span class="number">10</span></span><br><span class="line">			<span class="keyword">return</span> bizModel</span><br><span class="line">		&#125;, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%+v \n&quot;</span>, err)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>但由于回调函数的入参只能知道是一个 <code>Lock</code> 接口，并不清楚具体是哪个 <code>struct</code>，所以在执行业务逻辑之前需要将这个接口转换为具体的 <code>struct</code>。</p>
<p>这其实和 <code>Java</code> 中的父类向子类转型非常类似，必须得是强制类型转换，也就是说运行时可能会出问题。</p>
<p>在 <code>Go</code> 语言中这样的行为被称为<code>类型断言</code>；虽然叫法不同，但目的类似。其语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x.(T)</span><br><span class="line">x:表示 <span class="keyword">interface</span> </span><br><span class="line">T:表示 向下转型的具体 <span class="keyword">struct</span></span><br></pre></td></tr></table></figure>

<p>所以在回调函数中得根据自己的需要将 <code>interface</code> 转换为自己的 <code>struct</code>，这里得确保是自己所使用的 <code>struct</code> ，因为是强制转换，编译器无法帮你做校验，具体能否转换成功得在运行时才知道。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有需要的朋友可以在这里获取到源码及具体使用方式:</p>
<p><a href="https://github.com/crossoverJie/gorm-optimistic">https://github.com/crossoverJie/gorm-optimistic</a></p>
<p>最近工作中使用了几种不同的编程语言，会发现除了语言自身的语法特性外大部分知识点都是相同的；</p>
<p>比如面向对象、数据库、IO操作等；所以掌握了这些基本知识，学习其他语言自然就能触类旁通了。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Go</tag>
        <tag>OOP</tag>
        <tag>乐观锁</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Go 实现一个 LRU cache</title>
    <url>/2021/12/20/go/lru-cache/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2021/12/20/Q6LHFvrl81RUVAm.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>早在几年前写过关于 <code>LRU cache</code> 的文章：<br><a href="https://crossoverjie.top/2018/04/07/algorithm/LRU-cache/">https://crossoverjie.top/2018/04/07/algorithm/LRU-cache/</a></p>
<p>当时是用 Java 实现的，最近我在完善 <a href="https://github.com/crossoverJie/ptg">ptg</a> 时正好需要一个最近最少使用的数据结构来存储历史记录。</p>
<blockquote>
<p>ptg: Performance testing tool (Go), 用 Go 实现的 gRPC 客户端调试工具。</p>
</blockquote>
<p>Go 官方库中并没有相关的实现，考虑到程序的简洁就不打算依赖第三方库，自己写一个；本身复杂度也不高，没有几行代码。</p>
<span id="more"></span>

<p>配合这个数据结构，我便在 <a href="https://github.com/crossoverJie/ptg">ptg</a> 中实现了请求历史记录的功能：</p>
<blockquote>
<p>将每次的请求记录存储到 lru cache 中，最近使用到的历史记录排在靠前，同时也能提供相关的搜索功能；具体可见下图。</p>
</blockquote>
<p><img src="https://s2.loli.net/2021/12/20/Arq5pxZoF2ksnXW.gif"></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="https://s2.loli.net/2021/12/20/1MXvgZ32WaQ8U4s.jpg"></p>
<p>实现原理没什么好说的，和 <code>Java</code> 的一样：</p>
<ul>
<li>一个双向链表存储数据的顺序</li>
<li>一个 <code>map</code> 存储最终的数据</li>
<li>当数据达到上限时移除链表尾部数据</li>
<li>将使用到的 <code>Node</code> 移动到链表的头结点</li>
</ul>
<p>虽然 Go 比较简洁，但好消息是基本的双向链表结构还是具备的。</p>
<p><img src="https://s2.loli.net/2021/12/20/nEHFimku5AYOqv9.jpg"></p>
<p>所以基于此便定义了一个 <code>LruCache</code>:</p>
<p><img src="https://s2.loli.net/2021/12/20/iT2ZORsy4tL5mBC.jpg"></p>
<p>根据之前的分析：</p>
<ul>
<li><code>size</code> 存储缓存大小。</li>
<li>链表存储数据顺序。</li>
<li><code>map</code> 存储数据。</li>
<li><code>lock</code> 用于控制并发安全。</li>
</ul>
<p><img src="https://s2.loli.net/2021/12/20/zpGjK4BWcITwfA2.jpg"></p>
<p>接下来重点是两个函数：写入、查询。</p>
<p>写入时判断是否达到容量上限，达到后删除尾部数据；否则就想数据写入头部。</p>
<p>而获取数据时，这会将查询到的结点移动到头结点。</p>
<p>这些结点操作都由 List 封装好了的。<br><img src="https://s2.loli.net/2021/12/20/xUquXg2BMoTdGFC.jpg"></p>
<p>所以使用起来也比较方便。</p>
<p>最终就是通过这个 <code>LruCache</code> 实现了上图的效果，想要了解更多细节的可以参考源码:</p>
<p><a href="https://github.com/crossoverJie/ptg/blob/main/gui/lru.go">https://github.com/crossoverJie/ptg/blob/main/gui/lru.go</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>LRU cache</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式的实际应用</title>
    <url>/2021/09/02/go/observer/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/10/25/QWzgA94m6MpIndl.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设计模式不管是在面试还是工作中都会遇到，但我经常碰到小伙伴抱怨实际工作中自己应用设计模式的机会非常小。</p>
<p>正好最近工作中遇到一个用<code>观察者模式</code>解决问题的场景，和大家一起分享。</p>
<span id="more"></span>

<p>背景如下：</p>
<p>在用户创建完订单的标准流程中需要做额外一些事情：<br><img src="https://i.loli.net/2021/10/25/H3ZKealzx4LfdIv.jpg"></p>
<p>同时这些业务也是不固定的，随时会根据业务发展增加、修改逻辑。</p>
<p>如果直接将逻辑写在下单业务中，这一<code>”坨“</code>不是很核心的业务就会占据的越来越多，修改时还有可能影响到正常的下单流程。</p>
<p>当然也有其他方案，比如可以启动几个定时任务，定期扫描扫描订单然后实现自己的业务逻辑；但这样会浪费许多不必要的请求。</p>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>因此观察者模式就应运而生，它是由事件发布者在自身状态发生变化时发出通知，由观察者获取消息实现业务逻辑。</p>
<p>这样事件发布者和接收者就可以完全解耦，互不影响；本质上也是对开闭原则的一种实现。</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><img src="https://i.loli.net/2021/10/25/185RJunI4wDX7TF.jpg"></p>
<p>先大体看一下观察者模式所使用到的接口与关系：</p>
<ul>
<li>主体接口：定义了注册实现、循环通知接口。</li>
<li>观察者接口：定义了接收主体通知的接口。</li>
<li>主体、观察者接口都可以有多个实现。</li>
<li>业务代码只需要使用 <code>Subject.Nofity()</code> 接口即可。</li>
</ul>
<hr>
<p>接下来看看创建订单过程中的实现案例。</p>
<blockquote>
<p>代码采用 go 实现，其他语言也是类似。</p>
</blockquote>
<p>首先按照上图定义了两个接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Subject <span class="keyword">interface</span> &#123;</span><br><span class="line">	Register(Observer)</span><br><span class="line">	Notify(data <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Observer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Update(data <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们这是一个下单的事件，所以定义了 <code>OrderCreateSubject</code> 实现 <code>Subject</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderCreateSubject <span class="keyword">struct</span> &#123;</span><br><span class="line">	observerList []Observer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderCreate</span><span class="params">()</span></span> Subject &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;OrderCreateSubject&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *OrderCreateSubject)</span></span> Register(observer Observer) &#123;</span><br><span class="line">	o.observerList = <span class="built_in">append</span>(o.observerList, observer)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *OrderCreateSubject)</span></span> Notify(data <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, observer := <span class="keyword">range</span> o.observerList &#123;</span><br><span class="line">		observer.Update(data)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的 <code>observerList</code> 切片是用于存放所有订阅了下单事件的观察者。</p>
<p>接着便是编写观察者业务逻辑了，这里我实现了两个：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> B1CreateOrder <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B1CreateOrder)</span></span> Update(data <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;b1.....data %v \n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B2CreateOrder <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B2CreateOrder)</span></span> Update(data <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;b2.....data %v \n&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用起来也非常简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestObserver</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	create := NewOrderCreate()</span><br><span class="line">	create.Register(&amp;B1CreateOrder&#123;&#125;)</span><br><span class="line">	create.Register(&amp;B2CreateOrder&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	create.Notify(<span class="string">&quot;abc123&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b1.....data abc123 </span><br><span class="line">b2.....data abc123 </span><br></pre></td></tr></table></figure>

<ol>
<li>创建一个<code>创建订单</code>的主体 <code>subject</code>。</li>
<li>注册所有的订阅事件。</li>
<li>在需要通知处调用 <code>Notify</code> 方法。</li>
</ol>
<p>这样一旦我们需要修改各个事件的实现时就不会互相影响，即便是要加入其他实现也是非常容易的：</p>
<ol>
<li>编写实现类。</li>
<li>注册进实体。</li>
</ol>
<p>不会再修改核心流程。</p>
<h2 id="配合容器"><a href="#配合容器" class="headerlink" title="配合容器"></a>配合容器</h2><p>其实我们也可以省略掉注册事件的步骤，那就是使用容器；大致流程如下：</p>
<ol>
<li>自定义的事件全部注入进容器。</li>
<li>再注册事件的地方从容器中取出所有的事件，挨个注册。</li>
</ol>
<blockquote>
<p>这里所使用的容器是 <a href="https://github.com/uber-go/dig">https://github.com/uber-go/dig</a></p>
</blockquote>
<p><img src="https://i.loli.net/2021/10/25/WXOG27IZ8x4EwDi.jpg"></p>
<p>修改后的代码中，每当我们新增一个观察者（事件订阅）时，只需要使用容器所提供 <code>Provide</code> 函数注册进容器即可。</p>
<p>同时为了让容器能够支持同一个对象存在多个实例也需要新增部分代码：</p>
<p>Observer.go:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Observer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Update(data <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	Instance <span class="keyword">struct</span> &#123;</span><br><span class="line">		dig.Out</span><br><span class="line">		Instance Observer <span class="string">`group:&quot;observers&quot;`</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	InstanceParams <span class="keyword">struct</span> &#123;</span><br><span class="line">		dig.In</span><br><span class="line">		Instances []Observer <span class="string">`group:&quot;observers&quot;`</span></span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在 <code>observer</code> 接口中需要新增两个结构体用于存放同一个接口的多个实例。</p>
<blockquote>
<p> <code>group:&quot;observers&quot;</code> 用于声明是同一个接口。</p>
</blockquote>
<p>创建具体观察者对象时返回 <code>Instance</code> 对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewB1</span><span class="params">()</span></span> Instance &#123;</span><br><span class="line">	<span class="keyword">return</span> Instance&#123;</span><br><span class="line">		Instance: &amp;B1CreateOrder&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewB2</span><span class="params">()</span></span> Instance &#123;</span><br><span class="line">	<span class="keyword">return</span> Instance&#123;</span><br><span class="line">		Instance: &amp;B2CreateOrder&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实就是用 Instance 包装了一次。</p>
</blockquote>
<p>这样在注册观察者时，便能从 <code>InstanceParams.Instances</code> 中取出所有的观察者对象了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = c.Invoke(<span class="function"><span class="keyword">func</span><span class="params">(subject Subject, params InstanceParams)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, instance := <span class="keyword">range</span> params.Instances &#123;</span><br><span class="line">		subject.Register(instance)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>这样在使用时直接从容器中获取主题对象，然后通知即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = c.Invoke(<span class="function"><span class="keyword">func</span><span class="params">(subject Subject)</span></span> &#123;</span><br><span class="line">	subject.Notify(<span class="string">&quot;abc123&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>更多关于 dig 的用法可以参考官方文档：</p>
<p><a href="https://pkg.go.dev/go.uber.org/dig#hdr-Value_Groups">https://pkg.go.dev/go.uber.org/dig#hdr-Value_Groups</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有经验的开发者会发现和发布订阅模式非常类似，当然他们的思路是类似的；我们不用纠结与两者的差异（面试时除外）；学会其中的思路更加重要。</p>
]]></content>
      <categories>
        <category>Go</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>observer</tag>
      </tags>
  </entry>
  <entry>
    <title>一个小时学会用 Go 编写命令行工具</title>
    <url>/2020/12/08/go/one-hour-write-cli-app/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/12/08/DMPGzwab7TyWeo9.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近因为项目需要写了一段时间的 <code>Go</code> ，相对于 <code>Java</code> 来说语法简单同时又有着一些 <code>Python</code> 之类的语法糖，让人大呼”真香“。</p>
<p><img src="https://i.loli.net/2020/12/08/tEPj46risD7ahUH.jpg"></p>
<span id="more"></span>

<p>但现阶段相对来说还是 <code>Python</code> 写的多一些，偶尔还得回炉写点 <code>Java</code> ；自然对 <code>Go</code> 也谈不上多熟悉。</p>
<p>于是便利用周末时间自己做个小项目来加深一些使用经验。于是我便想到了之前利用 <code>Java</code> 写的一个博客<a href="https://github.com/crossoverJie/blog.toolbox">小工具</a>。</p>
<p>那段时间正值微博图床大量图片禁止外链，导致许多个人博客中的图片都不能查看。这个工具可以将文章中的图片备份到本地，还能将图片直接替换到其他图床。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1cc7612c25.gif"></p>
<p>我个人现在是一直在使用，通常是在码字的时候利用 <code>iPic</code> 之类的工具将图片上传到微博图床（主要是方便+免费）。写完之后再通过这个工具一键切换到 <code>[SM.MS](http://sm.MS)</code> 这类付费图床，同时也会将图片备份到本地磁盘。</p>
<p>改为用 <code>Go</code> 重写为 <code>cli</code> 工具后使用效果如下：</p>
<p><img src="https://i.loli.net/2020/12/08/enU3RDfikIKq9ao.gif" alt="3-min.gif"></p>
<h1 id="需要掌握哪些技能"><a href="#需要掌握哪些技能" class="headerlink" title="需要掌握哪些技能"></a>需要掌握哪些技能</h1><p>之所以选择这个工具用 <code>Go</code> 来重写；一个是功能比较简单，但也正好可以利用到 <code>Go</code> 的一些特点，比如网络 IO、协程同步之类。</p>
<p>同时修改为命令行工具后是不是感觉更极客了呢。</p>
<p>再开始之前还是先为不熟悉 <code>Go</code> 的 <code>Javaer</code> 介绍下大概会用到哪些知识点：</p>
<ul>
<li>使用和管理第三方依赖包(<code>go mod</code>)</li>
<li>协程的运用。</li>
<li>多平台打包。</li>
</ul>
<p>下面开始具体操作，我觉得即便是没怎么接触过 <code>Go</code> 的朋友看完之后也能快速上手实现一个小工具。</p>
<h2 id="使用和管理第三方依赖"><a href="#使用和管理第三方依赖" class="headerlink" title="使用和管理第三方依赖"></a>使用和管理第三方依赖</h2><ul>
<li>还没有安装 Go 的朋友请参考官网自行安装。</li>
</ul>
<p>首先介绍一下 Go 的依赖管理，在版本 <code>1.11</code> 之后官方就自带了依赖管理模块，所以在当下最新版 <code>1.15</code> 中已经强烈推荐使用。</p>
<p>它的目的和作用与 <code>Java</code> 中的 <code>maven</code>，<code>Python</code> 中的 <code>pip</code> 类似，但使用起来比 <code>maven</code> 简单许多。</p>
<p><img src="https://i.loli.net/2020/12/08/kxClhNWr13UZHzT.jpg"></p>
<p>根据它的使用参考，需要首先在项目目录下执行 <code>go mod init</code> 用于初始化一个 <code>go.mod</code> 文件，当然如果你使用的是 <code>GoLang</code> 这样的 <code>IDE</code>，在新建项目时会自动帮我们创建好目录结构，当然也包含 <code>go.mod</code> 这个文件。</p>
<p>在这个文件中我们引入我们需要的第三方包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module btb</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.15</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">	github.com/cheggaaa/pb/v3 v3<span class="number">.0</span><span class="number">.5</span></span><br><span class="line">	github.com/fatih/color v1<span class="number">.10</span><span class="number">.0</span></span><br><span class="line">	github.com/urfave/cli/v2 v2<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我这里使用了三个包，分别是：</p>
<ul>
<li><code>pb</code>: progress bar，用于在控制台输出进度条。</li>
<li><code>color</code>: 用于在控制台输出不同颜色的文本。</li>
<li><code>cli</code>: 命令行工具开发包。</li>
</ul>
<hr>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;btb/constants&quot;</span></span><br><span class="line">	<span class="string">&quot;btb/service&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/urfave/cli/v2&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> model <span class="type">string</span></span><br><span class="line">	downloadPath := constants.DownloadPath</span><br><span class="line">	markdownPath := constants.MarkdownPath</span><br><span class="line"></span><br><span class="line">	app := &amp;cli.App&#123;</span><br><span class="line">		Flags: []cli.Flag&#123;</span><br><span class="line">			&amp;cli.StringFlag&#123;</span><br><span class="line">				Name:        <span class="string">&quot;model&quot;</span>,</span><br><span class="line">				Usage:       <span class="string">&quot;operating mode; r:replace, b:backup&quot;</span>,</span><br><span class="line">				DefaultText: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">				Aliases:     []<span class="type">string</span>&#123;<span class="string">&quot;m&quot;</span>&#125;,</span><br><span class="line">				Required:    <span class="literal">true</span>,</span><br><span class="line">				Destination: &amp;model,</span><br><span class="line">			&#125;,</span><br><span class="line">			&amp;cli.StringFlag&#123;</span><br><span class="line">				Name:        <span class="string">&quot;download-path&quot;</span>,</span><br><span class="line">				Usage:       <span class="string">&quot;The path where the image is stored&quot;</span>,</span><br><span class="line">				Aliases:     []<span class="type">string</span>&#123;<span class="string">&quot;dp&quot;</span>&#125;,</span><br><span class="line">				Destination: &amp;downloadPath,</span><br><span class="line">				Required:    <span class="literal">true</span>,</span><br><span class="line">				Value:       constants.DownloadPath,</span><br><span class="line">			&#125;,</span><br><span class="line">			&amp;cli.StringFlag&#123;</span><br><span class="line">				Name:        <span class="string">&quot;markdown-path&quot;</span>,</span><br><span class="line">				Usage:       <span class="string">&quot;The path where the markdown file is stored&quot;</span>,</span><br><span class="line">				Aliases:     []<span class="type">string</span>&#123;<span class="string">&quot;mp&quot;</span>&#125;,</span><br><span class="line">				Destination: &amp;markdownPath,</span><br><span class="line">				Required:    <span class="literal">true</span>,</span><br><span class="line">				Value:       constants.MarkdownPath,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		Action: <span class="function"><span class="keyword">func</span><span class="params">(c *cli.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			service.DownLoadPic(markdownPath, downloadPath)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;,</span><br><span class="line">		Name:  <span class="string">&quot;btb&quot;</span>,</span><br><span class="line">		Usage: <span class="string">&quot;Help you backup and replace your blog&#x27;s images&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err := app.Run(os.Args)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码非常简单，无非就是使用了 <code>cli</code> 所提供的 api 创建了几个命令，将用户输入的 <code>-dp</code>、<code>-mp</code> 参数映射到 <code>downloadPath</code>、<code>markdownPath</code> 变量中。</p>
<p>之后便利用这两个数据扫描所有的图片，以及将图片下载到对应的目录中。</p>
<p>更多使用指南可以直接参考<a href="https://github.com/urfave/cli/blob/master/docs/v2/manual.md">官方文档</a>。</p>
<p>可以看到部分语法与 <code>Java</code> 完全不同，比如：</p>
<ul>
<li>申明变量时类型是放在后边，先定义变量名称；方法参数类似。</li>
<li>类型推导，可以不指定变量类型（新版本的 <code>Java</code> 也支持）</li>
<li>方法支持同时返回多个值，这点非常好用。</li>
<li>公共、私用函数利用首字母大小写来区分。</li>
<li>还有其他的就不一一列举了。</li>
</ul>
<hr>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>紧接着命令执行处调用了 <code>service.DownLoadPic(markdownPath, downloadPath)</code> 处理业务逻辑。</p>
<p>这里包含的文件扫描、图片下载之类的代码就不分析了；官方 <code>SDK</code> 写的很清楚，也比较简单。</p>
<p>重点看看 <code>Go</code> 里的 <code>goroutine</code> 也就是协程。</p>
<p>我这里使用的场景是每扫描到一个文件就利用一个协程去解析和下载图片，从而可以提高整体的运行效率。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DownLoadPic</span><span class="params">(markdownPath, downloadPath <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	allFile, err := util.GetAllFile(markdownPath)</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(*allFile))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;read file error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, filePath := <span class="keyword">range</span> *allFile &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(filePath <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			allLine, err := util.ReadFileLine(filePath)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatal(err)</span><br><span class="line">			&#125;</span><br><span class="line">			availableImgs := util.MatchAvailableImg(allLine)</span><br><span class="line">			bar := pb.ProgressBarTemplate(constants.PbTmpl).Start(<span class="built_in">len</span>(*availableImgs))</span><br><span class="line">			bar.Set(<span class="string">&quot;fileName&quot;</span>, filePath).</span><br><span class="line">				SetWidth(<span class="number">120</span>)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> _, url := <span class="keyword">range</span> *availableImgs &#123;</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Fatal(err)</span><br><span class="line">				&#125;</span><br><span class="line">				err := util.DownloadFile(url, *genFullFileName(downloadPath, filePath, &amp;url))</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Fatal(err)</span><br><span class="line">				&#125;</span><br><span class="line">				bar.Increment()</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			bar.Finish()</span><br><span class="line">			wg.Done()</span><br><span class="line"></span><br><span class="line">		&#125;(filePath)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	color.Green(<span class="string">&quot;Successful handling of [%v] files.\n&quot;</span>, <span class="built_in">len</span>(*allFile))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就代码使用层面看起来是不是要比 <code>Java</code> 简洁许多，我们不用像 <code>Java</code> 那样需要维护一个 <code>executorService</code>，也不需要考虑这个线程池的大小，一切都交给 <code>Go</code> 自己去调度。</p>
<p>使用时只需要在调用函数之前加上 <code>go</code> 关键字，只不过这里是一个匿名函数。</p>
<p>而且由于 <code>goroutine</code> 非常轻量，与 <code>Java</code> 中的 <code>thread</code> 相比占用非常少的内存，所以我们也不需要精准的控制创建数量。</p>
<hr>
<p>不过这里也用到了一个和 <code>Java</code> 非常类似的东西：<code>WaitGroup</code>。</p>
<p>它的用法与作用都与 <code>Java</code> 中的 <code>CountDownLatch</code> 非常相似；主要用于等待所有的 <code>goroutine</code> 执行完毕，在这里自然是等待所有的图片都下载完毕然后退出程序。</p>
<p>使用起来主要分为三步：</p>
<ul>
<li>创建和初始化 <code>goruntime</code> 的数量：<code>wg.Add(len(number)</code></li>
<li>每当一个 <code>goruntime</code> 执行完毕调用 <code>wg.Done()</code> 让计数减一。</li>
<li>最终调用 <code>wg.Wait()</code> 等待<code>WaitGroup</code> 的数量减为0。</li>
</ul>
<p>对于协程 Go 推荐使用 <code>chanel</code> 来互相通信，这点今后有机会再讨论。 </p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>核心逻辑也就这么多，下面来讲讲打包与运行；这点和 <code>Java</code> 的区别就比较大了。</p>
<p>众所周知，<code>Java</code> 有一句名言：<code>write once run anywhere</code></p>
<p>这是因为有了 <code>JVM</code> 虚拟机，所以我们不管代码最终运行于哪个平台都只需要打出一个包；但 <code>Go</code> 没有虚拟机它是怎么做到在个各平台运行呢。</p>
<p>简单来说 <code>Go</code> 可以针对不同平台打包出不同的二进制文件，这个文件包含了所有运行所需要的依赖，甚至都不需要在目标平台安装 <code>Go</code> 环境。</p>
<ul>
<li>虽说 Java 最终只需要打一个包，但也得在各个平台安装兼容的 <code>Java</code> 运行环境。</li>
</ul>
<p>我在这里编写了一个 <code>Makefile</code> 用于执行打包：<code>make release</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Binary name</span></span><br><span class="line">BINARY=btb</span><br><span class="line">GOBUILD=go build -ldflags <span class="string">&quot;-s -w&quot;</span> -o $&#123;BINARY&#125;</span><br><span class="line">GOCLEAN=go clean</span><br><span class="line">RMTARGZ=rm -rf *.gz</span><br><span class="line">VERSION=0.0.1</span><br><span class="line"></span><br><span class="line"><span class="section">release:</span></span><br><span class="line">	<span class="comment"># Clean</span></span><br><span class="line">	<span class="variable">$(GOCLEAN)</span></span><br><span class="line">	<span class="variable">$(RMTARGZ)</span></span><br><span class="line">	<span class="comment"># Build for mac</span></span><br><span class="line">	CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 <span class="variable">$(GOBUILD)</span></span><br><span class="line">	tar czvf $&#123;BINARY&#125;-mac64-$&#123;VERSION&#125;.tar.gz ./$&#123;BINARY&#125;</span><br><span class="line">	<span class="comment"># Build for arm</span></span><br><span class="line">	<span class="variable">$(GOCLEAN)</span></span><br><span class="line">	CGO_ENABLED=0 GOOS=linux GOARCH=arm64 <span class="variable">$(GOBUILD)</span></span><br><span class="line">	tar czvf $&#123;BINARY&#125;-arm64-$&#123;VERSION&#125;.tar.gz ./$&#123;BINARY&#125;</span><br><span class="line">	<span class="comment"># Build for linux</span></span><br><span class="line">	<span class="variable">$(GOCLEAN)</span></span><br><span class="line">	CGO_ENABLED=0 GOOS=linux GOARCH=amd64 <span class="variable">$(GOBUILD)</span></span><br><span class="line">	tar czvf $&#123;BINARY&#125;-linux64-$&#123;VERSION&#125;.tar.gz ./$&#123;BINARY&#125;</span><br><span class="line">	<span class="comment"># Build for win</span></span><br><span class="line">	<span class="variable">$(GOCLEAN)</span></span><br><span class="line">	CGO_ENABLED=0 GOOS=windows GOARCH=amd64 <span class="variable">$(GOBUILD)</span>.exe</span><br><span class="line">	tar czvf $&#123;BINARY&#125;-win64-$&#123;VERSION&#125;.tar.gz ./$&#123;BINARY&#125;.exe</span><br><span class="line">	<span class="variable">$(GOCLEAN)</span></span><br></pre></td></tr></table></figure>

<p>可以看到我们只需要在 <code>go build</code> 之前指定系统变量即可打出不同平台的包，比如我们为 <code>Linux</code> 系统的 <code>arm64</code> 架构打包文件：</p>
<p><code>CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build main.go -o btb</code></p>
<p>便可以直接在目标平台执行 <code>./btb</code>  运行程序。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文所有代码都已上传 <code>Github</code>: <a href="https://github.com/crossoverJie/btb">https://github.com/crossoverJie/btb</a></p>
<p>感兴趣的也可以直接运行安装脚本体验。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://raw.githubusercontent.com/crossoverJie/btb/master/install.sh | bash</span><br></pre></td></tr></table></figure>

<ul>
<li>目前这个版本只实现了图片下载备份，后续会完善图床替换及其他功能。</li>
</ul>
<hr>
<p>这段时间接触 <code>Go</code> 之后给我的感触颇深，对于年纪 25 岁的 <code>Java</code> 来说，<code>Go</code> 确实是后生可畏，更气人的是还赶上了云原生这个浪潮，就更惹不起了。</p>
<p>一些以前看来不那么重要的小毛病也被重点放大，比如启动慢、占用内存多、语法啰嗦等；不过我依然对这位赏饭吃的祖师爷保持期待，从新版本的 <code>Java</code> 可以看出也在积极改变，更不用说它还有无人撼动的庞大生态。</p>
<p>更多 <code>Java</code> 后续内容可以参考周志明老师的文章：<a href="https://mp.weixin.qq.com/s/fVz2A-AmgfhF0sTkz8ADNw">云原生时代，Java危矣？</a></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>cli</tag>
      </tags>
  </entry>
  <entry>
    <title>不同语言对单例模式的不同实现</title>
    <url>/2020/10/09/go/other-lang-singleton-pattern/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/10/09/MbZHxvDFeyhmAtQ.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间在用 <code>Python</code> 实现业务的时候发现一个坑，准确的来说是对于 <code>Python</code> 门外汉容易踩的坑；</p>
<p>大概代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mom</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    sons = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    m1 = Mom()</span><br><span class="line">    m1.name = <span class="string">&#x27;m1&#x27;</span></span><br><span class="line">    m1.sons.append([<span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;&#123;&#125; sons=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(m1.name, m1.sons)</span><br><span class="line"></span><br><span class="line">    m2 = Mom()</span><br><span class="line">    m2.name = <span class="string">&#x27;m2&#x27;</span></span><br><span class="line">    m2.sons.append([<span class="string">&#x27;s3&#x27;</span>, <span class="string">&#x27;s4&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;&#123;&#125; sons=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(m2.name, m2.sons)</span><br></pre></td></tr></table></figure>

<p>首先定义了一个 <code>Mom</code> 的类，它包含了一个字符串类型的 <code>name</code> 与列表类型的 <code>sons</code> 属性；</p>
<span id="more"></span>

<p>在使用时首先创建了该类的一个实例 <code>m1</code> 并往 <code>sons</code> 中写入一个列表数据；紧接着又创建了一个实例 <code>m2</code> ，也往 <code>sons</code> 中写入了另一个列表数据。</p>
<p>如果是一个 <code>Javaer</code> 很少写 <code>Python</code> 看到这样的代码首先想到的输出应该是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m1 sons=[[<span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>]]</span><br><span class="line">m2 sons=[[<span class="string">&#x27;s3&#x27;</span>, <span class="string">&#x27;s4&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<p>但其实最终的输出结果是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m1 sons=[[<span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>]]</span><br><span class="line">m2 sons=[[<span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>], [<span class="string">&#x27;s3&#x27;</span>, <span class="string">&#x27;s4&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<p>如果想要达到期望值需要稍微修改一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mom</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.sons = []</span><br></pre></td></tr></table></figure>

<p>只需要修改类的定义就可以了，我相信即使没有 <code>Python</code> 相关经验对比这两个代码应该也能猜到原因：</p>
<p>在 <code>Python</code> 中如果需要将变量作为实例变量（也就是每个我们期望的输出）时，需要将变量定义到构造函数中，通过 <code>self</code> 访问。</p>
<p>如果只放在类中，和 <code>Java</code> 中的 <code>static</code> 静态变量效果类似；这些数据由类共享，也就能解释为什么会出现第一种情况，因为其中的 <code>sons</code> 是由 <code>Mom</code> 类共享，所以每次都会累加。</p>
<h1 id="Python-单例"><a href="#Python-单例" class="headerlink" title="Python 单例"></a>Python 单例</h1><p>既然 <code>Python</code> 可以通过类变量达到变量在同一个类中共享的效果，那是否可以实现单例模式呢？</p>
<p>可以利用 <code>Python</code> 的 <code>metaclass</code> 的特性，动态的控制类的创建。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">            cls._instances[cls] = <span class="built_in">super</span>(Singleton, cls).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br></pre></td></tr></table></figure>

<p>首先创建一个 <code>Singleton</code> 的基类，然后我们在我们需要实现单例的类中将其作为 <code>metaclass</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLDriver</span>:</span><br><span class="line">    __metaclass__ = Singleton</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;MySQLDriver init.....&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样<code>Singleton</code> 就可以控制 <code>MySQLDriver</code> 这个类的创建了；其实在 <code>Singleton</code> 中的 <code>__call__</code> 可以很容易理解这个单例创建的过程：</p>
<ul>
<li>定义一个私有的类属性 <code>_instances</code> 的字典（也就是 <code>Java</code> 中的 <code>map</code>）可以做到在整个类中共享，无论创建多少个实例。</li>
<li>当我们自定义类使用了 <code>__metaclass__ = Singleton</code> 后，便可以控制自定义类的创建了；如果已经创建了实例，那就直接从 <code>_instances</code> 取出对象返回，不然就创建一个实例并写回到 <code>_instances</code> ，有点 <code>Spring</code> 容器的感觉。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    m1 = MySQLDriver()</span><br><span class="line">    m2 = MySQLDriver()</span><br><span class="line">    m3 = MySQLDriver()</span><br><span class="line">    m4 = MySQLDriver()</span><br><span class="line">    <span class="built_in">print</span> m1</span><br><span class="line">    <span class="built_in">print</span> m2</span><br><span class="line">    <span class="built_in">print</span> m3</span><br><span class="line">    <span class="built_in">print</span> m4</span><br><span class="line"></span><br><span class="line">MySQLDriver init.....</span><br><span class="line">&lt;__main__.MySQLDriver <span class="built_in">object</span> at <span class="number">0x10d848790</span>&gt;</span><br><span class="line">&lt;__main__.MySQLDriver <span class="built_in">object</span> at <span class="number">0x10d848790</span>&gt;</span><br><span class="line">&lt;__main__.MySQLDriver <span class="built_in">object</span> at <span class="number">0x10d848790</span>&gt;</span><br><span class="line">&lt;__main__.MySQLDriver <span class="built_in">object</span> at <span class="number">0x10d848790</span>&gt;</span><br></pre></td></tr></table></figure>

<p>最后我们通过实验结果可以看到单例创建成功。</p>
<h1 id="Go-单例"><a href="#Go-单例" class="headerlink" title="Go 单例"></a>Go 单例</h1><p>由于最近团队中有部分业务开始在用 <code>go</code> ，所以也想看看在 <code>go</code> 中如何实现单例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MySQLDriver <span class="keyword">struct</span> &#123;</span><br><span class="line">	username <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这样一个简单的结构体（可以简单理解为 <code>Java</code> 中的 <code>class</code>）中是没法类似于 <code>Python</code> 和 <code>Java</code> 一样可以声明类共享变量的；<code>go</code> 语言中不存在 <code>static</code> 的概念。</p>
<p>但我们可以在包中声明一个全局变量来达到同样的效果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MySQLDriver <span class="keyword">struct</span> &#123;</span><br><span class="line">	username <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mySQLDriver *MySQLDriver</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDriver</span><span class="params">()</span></span> *MySQLDriver &#123;</span><br><span class="line">	<span class="keyword">if</span> mySQLDriver == <span class="literal">nil</span> &#123;</span><br><span class="line">		mySQLDriver = &amp;MySQLDriver&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mySQLDriver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在使用时：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	driver := GetDriver()</span><br><span class="line">	driver.username = <span class="string">&quot;cj&quot;</span></span><br><span class="line">	fmt.Println(driver.username)</span><br><span class="line"></span><br><span class="line">	driver2 := GetDriver()</span><br><span class="line">	fmt.Println(driver2.username)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就不需要直接构造 <code>MySQLDriver</code>  ，而是通过<code>GetDriver()</code> 函数来获取，通过 <code>debug</code> 也能看到 <code>driver</code> 和 <code>driver1</code> 引用的是同一个内存地址。</p>
<p><img src="https://i.loli.net/2020/10/09/BkIGFx3tJjWRSiY.jpg"></p>
<p>这样的实现常规情况是没有什么问题的，机智的朋友一定能想到和 <code>Java</code> 一样，一旦并发访问就没那么简单了。</p>
<p>在 <code>go</code> 中，如果有多个 <code>goroutine</code> 同时访问<code>GetDriver()</code> ，那大概率会创建多个 <code>MySQLDriver</code> 实例。</p>
<p>这里说的没那么简单其实是相对于 <code>Java</code> 来说的，<code>go</code> 语言中提供了简单的 <code>api</code> 便可实现临界资源的访问。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDriver</span><span class="params">()</span></span> *MySQLDriver &#123;</span><br><span class="line">	lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> mySQLDriver == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;create instance......&quot;</span>)</span><br><span class="line">		mySQLDriver = &amp;MySQLDriver&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mySQLDriver</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> GetDriver()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">2000</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍加改造上文的代码，加入了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> lock.Unlock()</span><br></pre></td></tr></table></figure>

<p>代码就能简单的控制临界资源的访问，即便我们开启了100个协程并发执行，<code>mySQLDriver</code> 实例也只会被初始化一次。</p>
<ul>
<li>这里的 <code>defer</code> 类似于 <code>Java</code> 中的 <code>finally</code> ，在方法调用前加上 <code>go</code> 关键字即可开启一个协程。</li>
</ul>
<p>虽说能满足并发要求了，但其实这样的实现也不够优雅；仔细想想这里</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mySQLDriver = &amp;MySQLDriver&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>创建实例只会调用一次，但后续的每次调用都需要加锁从而带来了不必要的开销。</p>
<p>这样的场景每个语言都是相同的，拿 <code>Java</code> 来说是不是经常看到这样的单例实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;     </span><br><span class="line">         <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">           <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;    </span><br><span class="line">             instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个典型的双重检查的单例，这里做了两次检查便可以避免后续其他线程再次访问锁。</p>
<p>同样的对于 <code>go</code> 来说也类似：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDriver</span><span class="params">()</span></span> *MySQLDriver &#123;</span><br><span class="line">	<span class="keyword">if</span> mySQLDriver == <span class="literal">nil</span> &#123;</span><br><span class="line">		lock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">		<span class="keyword">if</span> mySQLDriver == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;create instance......&quot;</span>)</span><br><span class="line">			mySQLDriver = &amp;MySQLDriver&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mySQLDriver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 <code>Java</code> 一样，在原有基础上额外做一次判断也能达到同样的效果。</p>
<p>但有没有觉得这样的代码非常繁琐，这一点 <code>go</code> 提供的 <code>api</code> 就非常省事了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDriver</span><span class="params">()</span></span> *MySQLDriver &#123;</span><br><span class="line">	once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> mySQLDriver == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;create instance......&quot;</span>)</span><br><span class="line">			mySQLDriver = &amp;MySQLDriver&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> mySQLDriver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上我们只需要不管在什么情况下  <code>MySQLDriver</code> 实例只初始化一次就能达到单例的目的，所以利用 <code>once.Do()</code> 就能让代码只执行一次。</p>
<p><img src="https://i.loli.net/2020/10/09/kvKn5QFczBYH6j7.jpg"></p>
<p>查看源码会发现 <code>once.Do()</code> 也是通过锁来实现，只是在加锁之前利用底层的原子操作做了一次校验，从而避免每次都要加锁，性能会更好。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相信大家日常开发中很少会碰到需要自己实现一个单例；首先大部分情况下我们都不需要单例，即使是需要，框架通常也都有集成。</p>
<p>类似于 <code>go</code> 这样框架较少，需要我们自己实现时其实也不需要过多考虑并发的问题；摸摸自己肚子左上方的位置想想，自己写的这个对象真的同时有几百上千的并发来创建嘛？</p>
<p>不过通过这个对比会发现 <code>go</code> 的语法确实要比 <code>Java</code> 简洁太多，同时轻量级的协程以及简单易用的并发工具支持看起来都要比 <code>Java</code> 优雅许多；后续有机会再接着深入。</p>
<p>参考链接：</p>
<p><a href="https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python">Creating a singleton in Python</a></p>
<p><a href="https://progolang.com/how-to-implement-singleton-pattern-in-go/">How to implement Singleton Pattern in Go</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Python</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>切片 slice 原理分析</title>
    <url>/2021/07/28/go/slice%20pointer/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/09/05/5oSTgOQHaIL6KdY.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一个 Go 语言新手，看到一切”诡异“的代码都会感到好奇；比如我最近看到的几个方法；伪代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindA</span><span class="params">()</span></span> ([]*T,<span class="type">error</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindB</span><span class="params">()</span></span> ([]T,<span class="type">error</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveA</span><span class="params">(data *[]T)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveB</span><span class="params">(data *[]*T)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>相信大部分刚入门 <code>Go</code> 的新手看到这样的代码也是一脸懵逼，其中最让人疑惑的就是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[]*T</span><br><span class="line">*[]T</span><br><span class="line">*[]*T</span><br></pre></td></tr></table></figure>
<p>这样对切片的声明，先不看后面两种写法；单独看 <code>[]*T</code> 还是很好理解的：<br>该切片中存放的是所有 T 的内存地址，会比存放 T 本身来说要更省空间，同时 <code>[]*T</code> 在方法内部是可以修改 T 的值，而<code>[]T</code> 是修改不了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSaveSlice</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	a := []T&#123;&#123;Name: <span class="string">&quot;1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;2&quot;</span>&#125;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, t2 := <span class="keyword">range</span> a &#123;</span><br><span class="line">		fmt.Println(t2)</span><br><span class="line">	&#125;</span><br><span class="line">	_ = SaveB(a)</span><br><span class="line">	<span class="keyword">for</span> _, t2 := <span class="keyword">range</span> a &#123;</span><br><span class="line">		fmt.Println(t2)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveB</span><span class="params">(data []T)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	t := data[<span class="number">0</span>]</span><br><span class="line">	t.Name = <span class="string">&quot;1233&quot;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如以上例子打印的是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1&#125;</span><br><span class="line">&#123;2&#125;</span><br><span class="line">&#123;1&#125;</span><br><span class="line">&#123;2&#125;</span><br></pre></td></tr></table></figure>
<p>只有将方法修改为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveB</span><span class="params">(data []*T)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	t := data[<span class="number">0</span>]</span><br><span class="line">	t.Name = <span class="string">&quot;1233&quot;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>才能修改 T 的值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;&#123;1&#125;</span><br><span class="line">&amp;&#123;2&#125;</span><br><span class="line">&amp;&#123;1233&#125;</span><br><span class="line">&amp;&#123;2&#125;</span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>下面重点来看看 <code>[]*T</code> 与 <code>*[]T</code> 的区别，这里写了两个 <code>append</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAppendA</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	x:=[]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	appendA(x)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;main %v\n&quot;</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendA</span><span class="params">(x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	x[<span class="number">0</span>]= <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;appendA %v\n&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看第一种，输出是结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendA [1000 2 3]</span><br><span class="line">main [1000 2 3]</span><br></pre></td></tr></table></figure>
<p>说明在函数传递过程中，函数内部的修改能够影响到外部。</p>
<hr>
<p>下面我们再看一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendB</span><span class="params">(x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	x = <span class="built_in">append</span>(x, <span class="number">4</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;appendA %v\n&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果却是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendA [1 2 3 4]</span><br><span class="line">main [1 2 3]</span><br></pre></td></tr></table></figure>
<p>没有影响到外部。</p>
<p>而当我们再调整一下会发现又有所不同：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAppendC</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	x:=[]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	appendC(&amp;x)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;main %v\n&quot;</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendC</span><span class="params">(x *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	*x = <span class="built_in">append</span>(*x, <span class="number">4</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;appendA %v\n&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendA &amp;[1 2 3 4]</span><br><span class="line">main [1 2 3 4]</span><br></pre></td></tr></table></figure>

<p>可以发现如果传递切片的指针时，使用 <code>append</code> 函数追加数据时会影响到外部。</p>
<h1 id="slice-原理"><a href="#slice-原理" class="headerlink" title="slice 原理"></a>slice 原理</h1><p>在分析上面三种情况之前，我们先来了解下 <code>slice</code> 的数据结构。</p>
<p>直接查看源码会发现 slice 其实就是一个结构体，只是不能直接对外访问。</p>
<p><img src="https://i.loli.net/2021/09/05/6odYQRwDSm4rNxa.jpg"></p>
<blockquote>
<p>源码地址 <code>runtime/slice.go</code></p>
</blockquote>
<p>其中有三个重要的属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>底层存放数据的数组，是一个指针。</td>
</tr>
<tr>
<td>len</td>
<td>切片长度</td>
</tr>
<tr>
<td>cap</td>
<td>切片容量 <code>cap&gt;=len</code></td>
</tr>
</tbody></table>
<p>提到切片就不得不想到数组，可以这么理解：</p>
<blockquote>
<p>切片是对数组的抽象，而数组则是切片的底层实现。</p>
</blockquote>
<p>其实通过切片这个名字也不难看出，它就是从数组中切了一部分；相对于数组的固定大小，切片可以根据实际使用情况进行扩容。</p>
<p>所以切片也可以通过对数组”切一刀”获得：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x1:=[<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">x2 := x[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(x2), <span class="built_in">cap</span>(x2))</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/09/05/od62x5UpqahBQOX.jpg"></p>
<p>其中 <code>x1</code> 的长度与容量都是6。</p>
<p><code>x2</code> 的长度与容量则为3和5。</p>
<ul>
<li>x2 的长度很容易理解。</li>
<li>容量等于5可以理解为，当前这个切片最多可以使用的长度。</li>
</ul>
<p>因为切片 x2 是对数组 x1 的引用，所以底层数组排除掉左边一个没有被引用的位置则是该切片最大的容量，也就是5。</p>
<h2 id="同一个底层数组"><a href="#同一个底层数组" class="headerlink" title="同一个底层数组"></a>同一个底层数组</h2><p>以刚才的代码为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAppendA</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	x:=[]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	appendA(x)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;main %v\n&quot;</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendA</span><span class="params">(x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	x[<span class="number">0</span>]= <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;appendA %v\n&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/09/05/T9FQXJlChyM3sm1.jpg"></p>
<p>在函数传递过程中，<code>main</code> 中的 x 与 <code>appendA</code> 函数中的 x 切片所引用的是同个数组。</p>
<p>所以在函数中对 <code>x[0]=100</code>，<code>main</code>函数中也能获取到。</p>
<p><img src="https://i.loli.net/2021/09/05/E3Yezc5GRWnoraI.jpg"></p>
<p>本质上修改的就是同一块内存数据。</p>
<h2 id="值传递带来的误会"><a href="#值传递带来的误会" class="headerlink" title="值传递带来的误会"></a>值传递带来的误会</h2><p>在上述例子中，在 <code>appendB</code> 中调用 <code>append</code> 函数追加数据后会发现 main 函数中并没有受到影响，这里我稍微调整了一下示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAppendB</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">//x:=[]int&#123;1,2,3&#125;</span></span><br><span class="line">	x := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">	x[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	x[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">	x[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">	appendB(x)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;main %v len=%v,cap=%v\n&quot;</span>, x,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendB</span><span class="params">(x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	x = <span class="built_in">append</span>(x, <span class="number">444</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;appendB %v len=%v,cap=%v\n&quot;</span>, x,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主要是修改了切片初始化方式，使得容量大于了长度，具体原因后续会说明。</p>
</blockquote>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendB [1 2 3 444] len=4,cap=5</span><br><span class="line">main [1 2 3] len=3,cap=5</span><br></pre></td></tr></table></figure>
<p><code>main</code> 函数中的数据看样子确实没有受到影响；但细心的朋友应该会注意到  <code>appendB</code> 函数中的 x 在 <code>append()</code> 之后长度 +1 变为了4。</p>
<p>而在 <code>main</code> 函数中长度又变回了3.</p>
<p>这个细节区别就是为什么 <code>append()</code> “看似” 没有生效的原因；至于为什么要说“看似”，再次调整了代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAppendB</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">//x:=[]int&#123;1,2,3&#125;</span></span><br><span class="line">	x := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">	x[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	x[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">	x[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">	appendB(x)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;main %v len=%v,cap=%v\n&quot;</span>, x,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x))</span><br><span class="line"></span><br><span class="line">	y:=x[<span class="number">0</span>:<span class="built_in">cap</span>(x)]</span><br><span class="line">	fmt.Printf(<span class="string">&quot;y %v len=%v,cap=%v\n&quot;</span>, y,<span class="built_in">len</span>(y),<span class="built_in">cap</span>(y))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在刚才的基础之上，以 <code>append</code> 之后的 x 为基础再做了一个切片；该切片的范围为 x 所引用数组的全部数据。</p>
<p>再来看看执行结果如何：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendB [1 2 3 444] len=4,cap=5</span><br><span class="line">main [1 2 3] len=3,cap=5</span><br><span class="line">y [1 2 3 444 0] len=5,cap=5</span><br></pre></td></tr></table></figure>
<p>会神奇的发现 y 将所有数据都打印出来，在 <code>appendB</code> 函数中追加的数据其实已经写入了数组中，但为什么 <code>x</code> 本身没有获取到呢？</p>
<p><img src="https://i.loli.net/2021/09/05/FTxiQ6HOLkaWJ4v.jpg"></p>
<p>看图就很容易理解了：</p>
<ul>
<li>在<code>appendB</code>中确实是对原始数组追加了数据，同时长度也增加了。</li>
<li>但由于是值传递，所以 <code>slice</code> 这个结构体即便是修改了长度为4，也只是对复制的那个对象修改了长度，<code>main</code> 中的长度依然为3.</li>
<li>由于底层数组是同一个，所以基于这个底层数组重新生成了一个完整长度的切片便能看到追加的数据了。</li>
</ul>
<p>所以这里本质的原因是因为 <code>slice</code> 是一个结构体，传递的是值，不管方法里如何修改长度也不会影响到原有的数据（这里指的是长度和容量这两个属性）。</p>
<h2 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h2><p>还有一个需要注意：</p>
<p>刚才特意提到这里的例子稍有改变，主要是将切片的容量设置超过了数组的长度；</p>
<p>如果不做这个特殊设置会怎么样呢？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAppendB</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	x:=[]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	<span class="comment">//x := make([]int, 3,5)</span></span><br><span class="line">	x[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	x[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">	x[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">	appendB(x)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;main %v len=%v,cap=%v\n&quot;</span>, x,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x))</span><br><span class="line"></span><br><span class="line">	y:=x[<span class="number">0</span>:<span class="built_in">cap</span>(x)]</span><br><span class="line">	fmt.Printf(<span class="string">&quot;y %v len=%v,cap=%v\n&quot;</span>, y,<span class="built_in">len</span>(y),<span class="built_in">cap</span>(y))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendB</span><span class="params">(x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	x = <span class="built_in">append</span>(x, <span class="number">444</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;appendB %v len=%v,cap=%v\n&quot;</span>, x,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendB [1 2 3 444] len=4,cap=6</span><br><span class="line">main [1 2 3] len=3,cap=3</span><br><span class="line">y [1 2 3] len=3,cap=3</span><br></pre></td></tr></table></figure>

<p>这时会发现 main 函数中的 y 切片数据也没有发生变化，这是为什么呢？</p>
<p><img src="https://i.loli.net/2021/09/05/ONairsIRJSX2PQH.jpg"></p>
<p>这是因为初始化 x 切片时长度和容量都为3，当在 <code>appendB</code> 函数中追加数据时，会发现没有位置了。</p>
<p>这时便会进行扩容：</p>
<ul>
<li>将老数据复制一份到新的数组中。</li>
<li>追加数据。</li>
<li>将新的数据内存地址返回给 <code>appendB</code> 中的 x .</li>
</ul>
<p>同样的由于是值传递，所以 <code>appendB</code> 中的切片换了底层数组对 <code>main</code> 函数中的切片没有任何影响，也就导致最终 <code>main</code> 函数的数据没有任何变化了。</p>
<h2 id="传递切片指针"><a href="#传递切片指针" class="headerlink" title="传递切片指针"></a>传递切片指针</h2><p>有没有什么办法即便是在扩容时也能对外部产生影响呢？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAppendC</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	x:=[]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	appendC(&amp;x)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;main %v len=%v,cap=%v\n&quot;</span>, x,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendC</span><span class="params">(x *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	*x = <span class="built_in">append</span>(*x, <span class="number">4</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;appendC %v\n&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendC &amp;[1 2 3 4]</span><br><span class="line">main [1 2 3 4] len=4,cap=6</span><br></pre></td></tr></table></figure>

<p>这时外部的切片就能受到影响了，其实原因也很简单；</p>
<p>刚才也说了，因为 <code>slice</code> 本身是一个结构体，所以当我们传递指针时，就和平时自定义的 <code>struct</code> 在函数内部通过指针修改数据原理相同。</p>
<p>最终在 <code>appendC</code> 中的 x 的指针指向了扩容后的结构体，因为传递的是 main 函数中 x 的指针，所以同样的 main 函数中的 x 也指向了该结构体。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以总结一下：</p>
<ul>
<li>切片是对数组的抽象，同时切片本身也是一个结构体。</li>
<li>参数传递时函数内部与外部引用的是同一个数组，所以对切片的修改会影响到函数外部。</li>
<li>如果发生扩容，情况会发生变化，同时扩容会导致数据拷贝；所以要尽量预估切片大小，避免数据拷贝。</li>
<li>对切片或数组重新生成切片时，由于共享的是同一个底层数组，所以数据会互相影响，这点需要注意。</li>
<li>切片也可以传递指针，但场景很少，还会带来不必要的误解；建议值传值就好，长度和容量占用不了多少内存。</li>
</ul>
<p>相信使用过切片会发现非常类似于  <code>Java</code>  中的 <code>ArrayList</code>，同样是基于数组实现，也会扩容发生数据拷贝；这样看来语言只是上层使用的选择，一些通用的底层实现大家都差不多。</p>
<p>这时我们再看标题中的 <code>[]*T *[]T *[]*T</code> 就会发现这几个并没有什么联系，只是看起来很像容易唬人。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>切片</tag>
        <tag>数组</tag>
        <tag>slice</tag>
      </tags>
  </entry>
  <entry>
    <title>几百行代码实现一个 JSON 解析器</title>
    <url>/2022/06/28/gjson/gjson01/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3m5tef1rzj218a0u07ju.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在写 <a href="https://crossoverjie.top/2022/05/30/gscript/gscript01/">gscript</a>时我就在想有没有利用编译原理实现一个更实际工具？毕竟真写一个语言的难度不低，并且也很难真的应用起来。</p>
<p>一次无意间看到有人提起 <code>JSON</code> 解析器，这类工具充斥着我们的日常开发，运用非常广泛。</p>
<p>以前我也有思考过它是如何实现的，过程中一旦和编译原理扯上关系就不由自主的劝退了；但经过这段时间的实践我发现实现一个 <code>JSON</code> 解析器似乎也不困难，只是运用到了编译原理前端的部分知识就完全足够了。</p>
<p>得益于 <code>JSON</code> 的轻量级，同时语法也很简单，所以核心代码大概只用了 800 行便实现了一个语法完善的 <code>JSON</code> 解析器。</p>
<span id="more"></span>

<p>首先还是来看看效果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/crossoverJie/xjson&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJson</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	str := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">   &quot;glossary&quot;: &#123;</span></span><br><span class="line"><span class="string">       &quot;title&quot;: &quot;example glossary&quot;,</span></span><br><span class="line"><span class="string">		&quot;age&quot;:1,</span></span><br><span class="line"><span class="string">		&quot;long&quot;:99.99,</span></span><br><span class="line"><span class="string">		&quot;GlossDiv&quot;: &#123;</span></span><br><span class="line"><span class="string">           &quot;title&quot;: &quot;S&quot;,</span></span><br><span class="line"><span class="string">			&quot;GlossList&quot;: &#123;</span></span><br><span class="line"><span class="string">               &quot;GlossEntry&quot;: &#123;</span></span><br><span class="line"><span class="string">                   &quot;ID&quot;: &quot;SGML&quot;,</span></span><br><span class="line"><span class="string">					&quot;SortAs&quot;: &quot;SGML&quot;,</span></span><br><span class="line"><span class="string">					&quot;GlossTerm&quot;: &quot;Standard Generalized Markup Language&quot;,</span></span><br><span class="line"><span class="string">					&quot;Acronym&quot;: &quot;SGML&quot;,</span></span><br><span class="line"><span class="string">					&quot;Abbrev&quot;: &quot;ISO 8879:1986&quot;,</span></span><br><span class="line"><span class="string">					&quot;GlossDef&quot;: &#123;</span></span><br><span class="line"><span class="string">                       &quot;para&quot;: &quot;A meta-markup language, used to create markup languages such as DocBook.&quot;,</span></span><br><span class="line"><span class="string">						&quot;GlossSeeAlso&quot;: [&quot;GML&quot;, &quot;XML&quot;, true, null]</span></span><br><span class="line"><span class="string">                   &#125;,</span></span><br><span class="line"><span class="string">					&quot;GlossSee&quot;: &quot;markup&quot;</span></span><br><span class="line"><span class="string">               &#125;</span></span><br><span class="line"><span class="string">           &#125;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">	decode, err := xjson.Decode(str)</span><br><span class="line">	assert.Nil(t, err)</span><br><span class="line">	fmt.Println(decode)</span><br><span class="line">	v := decode.(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	glossary := v[<span class="string">&quot;glossary&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	assert.Equal(t, glossary[<span class="string">&quot;title&quot;</span>], <span class="string">&quot;example glossary&quot;</span>)</span><br><span class="line">	assert.Equal(t, glossary[<span class="string">&quot;age&quot;</span>], <span class="number">1</span>)</span><br><span class="line">	assert.Equal(t, glossary[<span class="string">&quot;long&quot;</span>], <span class="number">99.99</span>)</span><br><span class="line">	glossDiv := glossary[<span class="string">&quot;GlossDiv&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	assert.Equal(t, glossDiv[<span class="string">&quot;title&quot;</span>], <span class="string">&quot;S&quot;</span>)</span><br><span class="line">	glossList := glossDiv[<span class="string">&quot;GlossList&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	glossEntry := glossList[<span class="string">&quot;GlossEntry&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	assert.Equal(t, glossEntry[<span class="string">&quot;ID&quot;</span>], <span class="string">&quot;SGML&quot;</span>)</span><br><span class="line">	assert.Equal(t, glossEntry[<span class="string">&quot;SortAs&quot;</span>], <span class="string">&quot;SGML&quot;</span>)</span><br><span class="line">	assert.Equal(t, glossEntry[<span class="string">&quot;GlossTerm&quot;</span>], <span class="string">&quot;Standard Generalized Markup Language&quot;</span>)</span><br><span class="line">	assert.Equal(t, glossEntry[<span class="string">&quot;Acronym&quot;</span>], <span class="string">&quot;SGML&quot;</span>)</span><br><span class="line">	assert.Equal(t, glossEntry[<span class="string">&quot;Abbrev&quot;</span>], <span class="string">&quot;ISO 8879:1986&quot;</span>)</span><br><span class="line">	glossDef := glossEntry[<span class="string">&quot;GlossDef&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	assert.Equal(t, glossDef[<span class="string">&quot;para&quot;</span>], <span class="string">&quot;A meta-markup language, used to create markup languages such as DocBook.&quot;</span>)</span><br><span class="line">	glossSeeAlso := glossDef[<span class="string">&quot;GlossSeeAlso&quot;</span>].(*[]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	assert.Equal(t, (*glossSeeAlso)[<span class="number">0</span>], <span class="string">&quot;GML&quot;</span>)</span><br><span class="line">	assert.Equal(t, (*glossSeeAlso)[<span class="number">1</span>], <span class="string">&quot;XML&quot;</span>)</span><br><span class="line">	assert.Equal(t, (*glossSeeAlso)[<span class="number">2</span>], <span class="literal">true</span>)</span><br><span class="line">	assert.Equal(t, (*glossSeeAlso)[<span class="number">3</span>], <span class="string">&quot;&quot;</span>)</span><br><span class="line">	assert.Equal(t, glossEntry[<span class="string">&quot;GlossSee&quot;</span>], <span class="string">&quot;markup&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个用例中可以看到支持字符串、布尔值、浮点、整形、数组以及各种嵌套关系。                                                                                      </p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3mz1xo687j20iw0evt9f.jpg"></p>
<p>这里简要说明一下实现原理，本质上就是两步：</p>
<ol>
<li><strong>词法解析</strong>：根据原始输入的 <code>JSON</code> 字符串解析出 token，也就是类似于 <code>&quot;&#123;&quot; &quot;obj&quot; &quot;age&quot; &quot;1&quot; &quot;[&quot; &quot;]&quot;</code> 这样的标识符，只是要给这类标识符分类。</li>
<li>根据生成的一组 <code>token</code> 集合，以流的方式进行读取，最终可以生成图中的树状结构，也就是一个 <code>JSONObject</code> 。</li>
</ol>
<p>下面来重点看看这两个步骤具体做了哪些事情。</p>
<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BeginObject  &#123;</span><br><span class="line">String  &quot;name&quot;</span><br><span class="line">SepColon  :</span><br><span class="line">String  &quot;cj&quot;</span><br><span class="line">SepComma  ,</span><br><span class="line">String  &quot;object&quot;</span><br><span class="line">SepColon  :</span><br><span class="line">BeginObject  &#123;</span><br><span class="line">String  &quot;age&quot;</span><br><span class="line">SepColon  :</span><br><span class="line">Number  10</span><br><span class="line">SepComma  ,</span><br><span class="line">String  &quot;sex&quot;</span><br><span class="line">SepColon  :</span><br><span class="line">String  &quot;girl&quot;</span><br><span class="line">EndObject  &#125;</span><br><span class="line">SepComma  ,</span><br><span class="line">String  &quot;list&quot;</span><br><span class="line">SepColon  :</span><br><span class="line">BeginArray  [</span><br></pre></td></tr></table></figure>

<p>其实词法解析就是构建一个有限自动机的过程（<code>DFA</code>)，目的是可以生成这样的集合（token）,只是我们需要将这些 token进行分类以便后续做语法分析的时候进行处理。</p>
<p>比如 <code>&quot;&#123;&quot;</code> 这样的左花括号就是一个 <code>BeginObject</code> 代表一个对象声明的开始，而 <code>&quot;&#125;&quot;</code> 则是 <code>EndObject</code> 代表一个对象的结束。</p>
<p>其中 <code>&quot;name&quot;</code> 这样的就被认为是 <code>String</code> 字符串，以此类推 <code>&quot;[&quot;</code> 代表 <code>BeginArray</code></p>
<p>这里我一共定义以下几种 token 类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Token <span class="type">string</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Init        Token = <span class="string">&quot;Init&quot;</span></span><br><span class="line">	BeginObject       = <span class="string">&quot;BeginObject&quot;</span></span><br><span class="line">	EndObject         = <span class="string">&quot;EndObject&quot;</span></span><br><span class="line">	BeginArray        = <span class="string">&quot;BeginArray&quot;</span></span><br><span class="line">	EndArray          = <span class="string">&quot;EndArray&quot;</span></span><br><span class="line">	Null              = <span class="string">&quot;Null&quot;</span></span><br><span class="line">	Null1             = <span class="string">&quot;Null1&quot;</span></span><br><span class="line">	Null2             = <span class="string">&quot;Null2&quot;</span></span><br><span class="line">	Null3             = <span class="string">&quot;Null3&quot;</span></span><br><span class="line">	Number            = <span class="string">&quot;Number&quot;</span></span><br><span class="line">	Float             = <span class="string">&quot;Float&quot;</span></span><br><span class="line">	BeginString       = <span class="string">&quot;BeginString&quot;</span></span><br><span class="line">	EndString         = <span class="string">&quot;EndString&quot;</span></span><br><span class="line">	String            = <span class="string">&quot;String&quot;</span></span><br><span class="line">	True              = <span class="string">&quot;True&quot;</span></span><br><span class="line">	True1             = <span class="string">&quot;True1&quot;</span></span><br><span class="line">	True2             = <span class="string">&quot;True2&quot;</span></span><br><span class="line">	True3             = <span class="string">&quot;True3&quot;</span></span><br><span class="line">	False             = <span class="string">&quot;False&quot;</span></span><br><span class="line">	False1            = <span class="string">&quot;False1&quot;</span></span><br><span class="line">	False2            = <span class="string">&quot;False2&quot;</span></span><br><span class="line">	False3            = <span class="string">&quot;False3&quot;</span></span><br><span class="line">	False4            = <span class="string">&quot;False4&quot;</span></span><br><span class="line">	<span class="comment">// SepColon :</span></span><br><span class="line">	SepColon = <span class="string">&quot;SepColon&quot;</span></span><br><span class="line">	<span class="comment">// SepComma ,</span></span><br><span class="line">	SepComma = <span class="string">&quot;SepComma&quot;</span></span><br><span class="line">	EndJson  = <span class="string">&quot;EndJson&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中可以看到  true&#x2F;false&#x2F;null 会有多个类型，这点先忽略，后续会解释。</p>
</blockquote>
<p>以这段 <code>JSON</code> 为例：<code>&#123;&quot;age&quot;:1&#125;</code>，它的状态扭转如下图：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n83xkv82j21360i0t9r.jpg"></p>
<p>总的来说就是依次遍历字符串，然后更新一个全局状态，根据该状态的值进行不同的操作。</p>
<p>部分代码如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n866cfqfj20u01jyjxt.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n86kgy9qj20u012kadx.jpg"></p>
<p>感兴趣的朋友可以跑跑单例 debug 一下就很容易理解：</p>
<p><a href="https://github.com/crossoverJie/xjson/blob/main/token_test.go">https://github.com/crossoverJie/xjson/blob/main/token_test.go</a></p>
<p>以这段 JSON 为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestInitStatus</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	str := <span class="string">`&#123;&quot;name&quot;:&quot;cj&quot;, &quot;age&quot;:10&#125;`</span></span><br><span class="line">	tokenize, err := Tokenize(str)</span><br><span class="line">	assert.Nil(t, err)</span><br><span class="line">	<span class="keyword">for</span> _, tokenType := <span class="keyword">range</span> tokenize &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s  %s\n&quot;</span>, tokenType.T, tokenType.Value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终生成的 <code>token</code> 集合如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BeginObject  &#123;</span><br><span class="line">String  &quot;name&quot;</span><br><span class="line">SepColon  :</span><br><span class="line">String  &quot;cj&quot;</span><br><span class="line">SepComma  ,</span><br><span class="line">String  &quot;age&quot;</span><br><span class="line">SepColon  :</span><br><span class="line">Number  10</span><br><span class="line">EndObject  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="提前检查"><a href="#提前检查" class="headerlink" title="提前检查"></a>提前检查</h3><p>由于 <code>JSON</code> 的语法简单，一些规则甚至在词法规则中就能校验。</p>
<p>举个例子：<br><code>JSON</code> 中允许 <code>null</code> 值，当我们字符串中存在 <code>nu  nul</code> 这类不匹配 <code>null</code> 的值时，就可以提前抛出异常。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n8dt7d1aj211w0tigpa.jpg"><br>比如当检测到第一个字符串为 n 时，那后续的必须为 <code>u-&gt;l-&gt;l</code> 不然就抛出异常。</p>
<p>浮点数同理，当一个数值中存在多个 . 点时，依然需要抛出异常。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n8fk2xsbj20u010hgp2.jpg"></p>
<p>这也是前文提到 <code>true/false/null</code> 这些类型需要有多个中间状态的原因。</p>
<h2 id="生成-JSONObject-树"><a href="#生成-JSONObject-树" class="headerlink" title="生成 JSONObject 树"></a>生成 JSONObject 树</h2><p>在讨论生成 <code>JSONObject</code> 树之前我们先来看这么一个问题，给定一个括号集合，判断是否合法。</p>
<ul>
<li><code>[&lt;()&gt;]</code> 这样是合法的。</li>
<li><code>[&lt;()&gt;)</code> 而这样是不合法的。</li>
</ul>
<p>如何实现呢？其实也很简单，只需要利用栈就能完成，如下图所示：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n8u1brbbj216u0rsgp1.jpg"><br>利用栈的特性，依次遍历数据，遇到是左边的符号就入栈，当遇到是右符号时就与栈顶数据匹配，能匹配上就出栈。</p>
<p>当匹配不上时则说明格式错误，数据遍历完毕后如果栈为空时说明数据合法。</p>
<p>其实仔细观察 <code>JSON</code> 的语法也是类似的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;cj&quot;,</span><br><span class="line">    &quot;object&quot;: &#123;</span><br><span class="line">        &quot;age&quot;: 10,</span><br><span class="line">        &quot;sex&quot;: &quot;girl&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;1&quot;: &quot;a&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;2&quot;: &quot;b&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BeginObject:&#123;</code> 与 <code>EndObject:&#125;</code> 一定是成对出现的，中间如论怎么嵌套也是成对的。<br>而对于 <code>&quot;age&quot;:10</code> 这样的数据，: 冒号后也得有数据进行匹配，不然就是非法格式。</p>
<p>所以基于刚才的括号匹配原理，我们也能用类似的方法来解析 <code>token</code> 集合。</p>
<p>我们也需要创建一个栈，当遇到 <code>BeginObject</code> 时就入栈一个 Map，当遇到一个 <code>String</code> 键时也将该值入栈。</p>
<p>当遇到 <code>value</code> 时，就将出栈一个 <code>key</code>,同时将数据写入当前栈顶的 <code>map</code> 中。</p>
<p>当然在遍历 <code>token</code> 的过程中也需要一个全局状态，所以这里也是一个<strong>有限状态机</strong>。</p>
<hr>
<p>举个例子：当我们遍历到 <code>Token</code> 类型为 <code>String</code>，值为 <code>&quot;name&quot;</code> 时，预期下一个 <code>token</code> 应当是 :冒号；</p>
<p>所以我们得将当前的 status 记录为 <code>StatusColon</code>，一旦后续解析到 token 为 <code>SepColon</code> 时，就需要判断当前的 status 是否为 <code>StatusColon</code> ，如果不是则说明语法错误，就可以抛出异常。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n9ilzooqj20u00u442z.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n9j1iex0j21bc09q0uj.jpg"></p>
<p>同时值得注意的是这里的 <code>status</code> 其实是一个<code>集合</code>，因为下一个状态可能是多种情况。</p>
<p><code>&#123;&quot;e&quot;:[1,[2,3],&#123;&quot;d&quot;:&#123;&quot;f&quot;:&quot;f&quot;&#125;&#125;]&#125;</code><br>比如当我们解析到一个 <code>SepColon</code> 冒号时，后续的状态可能是 <code>value</code> 或 <code>BeginObject &#123;</code> 或 <code>BeginArray [</code></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n9pwpspuj21hg09q76e.jpg"><br>因此这里就得把这三种情况都考虑到，其他的以此类推。</p>
<p>具体解析过程可以参考源码：<br><a href="https://github.com/crossoverJie/xjson/blob/main/parse.go">https://github.com/crossoverJie/xjson/blob/main/parse.go</a></p>
<hr>
<p>虽然是借助一个栈结构就能将 <code>JSON</code> 解析完毕，不知道大家发现一个问题没有：<br>这样非常容易遗漏规则，比如刚才提到的一个冒号后面就有三种情况，而一个 <code>BeginArray</code> 后甚至有四种情况（<code>StatusArrayValue, StatusBeginArray, StatusBeginObject, StatusEndArray</code>）</p>
<p>这样的代码读起来也不是很直观，同时容易遗漏语法，只能出现问题再进行修复。</p>
<p>既然提到了问题那自然也有相应的解决方案，其实就是语法分析中常见的递归下降算法。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n9vzwepij20u01ecwgy.jpg"><br>我们只需要根据 <code>JSON</code> 的文法定义，递归的写出算法即可，这样代码阅读起来非常清晰，同时也不会遗漏规则。</p>
<p>完整的 <code>JSON</code> 语法查看这里：<br><a href="https://github.com/antlr/grammars-v4/blob/master/json/JSON.g4">https://github.com/antlr/grammars-v4/blob/master/json/JSON.g4</a></p>
<p>我也预计将下个版本改为递归下降算法来实现。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当目前为止其实只是实现了一个非常基础的 <code>JSON</code> 解析，也没有做性能优化，和官方的 <code>JSON</code> 包对比性能差的不是一星半点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz</span><br><span class="line">BenchmarkJsonDecode-12            372298             15506 ns/op             512 B/op         12 allocs/op</span><br><span class="line">BenchmarkDecode-12                141482             43516 ns/op           30589 B/op        962 allocs/op</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>

<p>同时还有一些基础功能没有实现，比如将解析后的 <code>JSONObject</code> 可以反射生成自定义的 <code>Struct</code>，以及我最终想实现的支持 <code>JSON</code> 的四则运算：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">xjson.Get(<span class="string">&quot;glossary.age+long*(a.b+a.c)&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>目前我貌似没有发现有类似的库实现了这个功能，后面真的完成后应该会很有意思，感兴趣的朋友请持续关注。</p>
<p>源码：<br><a href="https://github.com/crossoverJie/xjson">https://github.com/crossoverJie/xjson</a></p>
]]></content>
      <categories>
        <category>xjson</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>用面向对象的方式操作 JSON 甚至还能做四则运算 JSON 库</title>
    <url>/2022/07/04/gjson/gjson02/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3vuj0uxlcj208u07tmxb.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在之前实现的 <a href="https://crossoverjie.top/2022/06/28/xjson/xjson01/"><code>JSON</code> 解析器</a>中当时只实现了将一个 JSON 字符串转换为一个 <code>JSONObject</code>，并没有将其映射为一个具体的 <code>struct</code>；如果想要获取值就需要先做断言将其转换为 <code>map</code> 或者是切片再来获，会比较麻烦。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">decode, err := xjson.Decode(<span class="string">`&#123;&quot;glossary&quot;:&#123;&quot;title&quot;:&quot;example glossary&quot;,&quot;age&quot;:1&#125;&#125;`</span>)</span><br><span class="line">assert.Nil(t, err)</span><br><span class="line">glossary := v[<span class="string">&quot;glossary&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">assert.Equal(t, glossary[<span class="string">&quot;title&quot;</span>], <span class="string">&quot;example glossary&quot;</span>)</span><br><span class="line">assert.Equal(t, glossary[<span class="string">&quot;age&quot;</span>], <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>但其实转念一想，部分场景我们甚至我们只需要拿到 <code>JSON</code> 中的某个字段的值，这样还需要先声明一个 <code>struct</code> 会略显麻烦。</p>
<p>经过查询发现已经有了一个类似的库来解决该问题，<a href="https://github.com/tidwall/xjson">https://github.com/tidwall/xjson</a> 并且 star 数还很多（甚至名字都是一样的😂），说明这样的需求大家还是很强烈的。</p>
<p>于是我也打算增加类似的功能，使用方式如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3t43ocuudj20zn0u0wha.jpg"></p>
<span id="more"></span>

<blockquote>
<p>最后还加上了一个四则运算的功能。</p>
</blockquote>
<h1 id="面向对象的方式操作-JSON"><a href="#面向对象的方式操作-JSON" class="headerlink" title="面向对象的方式操作 JSON"></a>面向对象的方式操作 JSON</h1><p>因为功能类似，所以我参考了 <code>tidwall</code> 的 <code>API</code> 但去掉一些我觉得暂时用不上的特性，并调整了一点语法。</p>
<p>当前这个版本只能通过确定的 <code>key</code> 加上 <code>.</code> 点符号访问数据，如果是数组则用 <code>[index]</code> 的方式访问下标。<br><code>[]</code> 符号访问数组我觉得要更符合直觉一些。</p>
<p>以下是一个包含多重嵌套 <code>JSON</code> 的访问示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">`</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;bob&quot;,</span></span><br><span class="line"><span class="string">&quot;age&quot;: 20,</span></span><br><span class="line"><span class="string">&quot;skill&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;lang&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;go&quot;: &#123;</span></span><br><span class="line"><span class="string">                &quot;feature&quot;: [</span></span><br><span class="line"><span class="string">                    &quot;goroutine&quot;,</span></span><br><span class="line"><span class="string">                    &quot;channel&quot;,</span></span><br><span class="line"><span class="string">                    &quot;simple&quot;,</span></span><br><span class="line"><span class="string">                    true</span></span><br><span class="line"><span class="string">                ]</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line"></span><br><span class="line">name := xjson.Get(str, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">assert.Equal(t, name.String(), <span class="string">&quot;bob&quot;</span>)</span><br><span class="line"></span><br><span class="line">age := xjson.Get(str, <span class="string">&quot;age&quot;</span>)</span><br><span class="line">assert.Equal(t, age.Int(), <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">assert.Equal(t, xjson.Get(str,<span class="string">&quot;skill.lang[0].go.feature[0]&quot;</span>).String(), <span class="string">&quot;goroutine&quot;</span>)</span><br><span class="line">assert.Equal(t, xjson.Get(str,<span class="string">&quot;skill.lang[0].go.feature[1]&quot;</span>).String(), <span class="string">&quot;channel&quot;</span>)</span><br><span class="line">assert.Equal(t, xjson.Get(str,<span class="string">&quot;skill.lang[0].go.feature[2]&quot;</span>).String(), <span class="string">&quot;simple&quot;</span>)</span><br><span class="line">assert.Equal(t, xjson.Get(str,<span class="string">&quot;skill.lang[0].go.feature[3]&quot;</span>).Bool(), <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>这样的语法使用个人觉得还是满符合直觉的，相信对使用者来说也比较简单。</p>
<p>返回值参考了 <code>tidwall</code> 使用了一个 <code>Result</code> 对象，它提供了多种方法可以方便的获取各种类型的数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> String() <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> Bool() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> Int() <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> Float() <span class="type">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> Map() <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> Array() *[]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> Exists() <span class="type">bool</span></span><br></pre></td></tr></table></figure>
<p>比如使用 <code>Map()/Array()</code> 这两个函数可以将 <code>JSON</code> 数据映射到 <code>map</code> 和切片中，当然前提是传入的语法返回的是一个合法 <code>JSONObject</code> 或数组。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在实现之前需要先定义一个基本语法，主要支持以下四种用法：</p>
<ul>
<li>单个 <code>key</code> 的查询：<code>Get(json,&quot;name&quot;)</code></li>
<li>嵌套查询： <code>Get(json,&quot;obj1.obj2.obj3.name&quot;)</code></li>
<li>数组查询：<code>Get(json,&quot;obj.array[0]&quot;)</code></li>
<li>数组嵌套查询：<code>Get(json,&quot;obj.array[0].obj2.obj3[1].name&quot;)</code></li>
</ul>
<p>语法很简单，符合我们日常接触到语法规则，这样便可以访问到 <code>JSON</code> 数据中的任何一个值。</p>
<p>其实实现过程也不复杂，我们已经在上一文中实现将 <code>JSON</code> 字符串转换为一个 <code>JSONObject</code> 了。</p>
<p>这次只是额外再解析刚才定义的语法为 <code>token</code>，然后解析该 <code>token</code> 的同时再从生成好的 <code>JSONObject</code> 中获取数据。</p>
<p>最后在解析完 <code>token</code> 时拿到的 <code>JSONObject</code> 数据返回即可。</p>
<hr>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3u0oie3saj213r0u0n0h.jpg"></p>
<p>我们以这段查询代码为例：</p>
<p>首先第一步是对查询语法做词法分析，最终得到下图的 <code>token</code>。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3u0ruv7upj218605uaap.jpg"></p>
<p>在词法分析过程中也可以做简单的语法校验；比如如果包含数组查询，并不是以 <code>]</code> 符号结尾时就抛出语法错误。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3u0r6v29nj219e0nojuq.jpg"></p>
<p>接着我们遍历语法的 token。如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3u0w0sb8xj217h0u042u.jpg"></p>
<p>每当遍历到 <code>token</code> 类型为 <code>Key</code> 时便从当前的 JSONObject 对象中获取数据，<strong>并用获取到的值替覆盖为当前的 JSONObject。</strong></p>
<p>其中每当遇到 <code>.</code> <code>[</code> <code>]</code> 这样的 token 时便消耗掉，直到我们将 token 遍历完毕，这时将当前 <code>JSONObject</code> 返回即可。</p>
<p>在遍历过程中当遇到非法格式时，比如 <code>obj_list[1.]</code> 便会返回一个空的 <code>JSONObject</code>。</p>
<p>语法校验这点其实也很容易办到，因为根据我们的语法规则，<code>Array</code> 中的 <code>index</code> 后一定紧接的是一个 <code>EndArray</code>，只要不是一个 <code>EndArray</code> 便能知道语法不合法了。</p>
<p>有兴趣的可以看下解析过程的源码：</p>
<p><a href="https://github.com/crossoverJie/xjson/blob/cfbca51cc9bc0c77e6cb9c9ad3f964b2054b3826/json.go#L46">https://github.com/crossoverJie/xjson/blob/cfbca51cc9bc0c77e6cb9c9ad3f964b2054b3826/json.go#L46</a></p>
<h1 id="对-JSON-做四则运算"><a href="#对-JSON-做四则运算" class="headerlink" title="对 JSON 做四则运算"></a>对 JSON 做四则运算</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str := `&#123;&quot;name&quot;:&quot;bob&quot;, &quot;age&quot;:10,&quot;magic&quot;:10.1, &quot;score&quot;:&#123;&quot;math&quot;:[1,2]&#125;&#125;`</span><br><span class="line">result := GetWithArithmetic(str, &quot;(age+age)*age+magic&quot;)</span><br><span class="line">assert.Equal(t, result.Float(), 210.1)</span><br><span class="line">result = GetWithArithmetic(str, &quot;(age+age)*age&quot;)</span><br><span class="line">assert.Equal(t, result.Int(), 200)</span><br><span class="line"></span><br><span class="line">result = GetWithArithmetic(str, &quot;(age+age) * age + score.math[0]&quot;)</span><br><span class="line">assert.Equal(t, result.Int(), 201)</span><br><span class="line"></span><br><span class="line">result = GetWithArithmetic(str, &quot;(age+age) * age - score.math[0]&quot;)</span><br><span class="line">assert.Equal(t, result.Int(), 199)</span><br><span class="line"></span><br><span class="line">result = GetWithArithmetic(str, &quot;score.math[1] / score.math[0]&quot;)</span><br><span class="line">assert.Equal(t, result.Int(), 2)</span><br></pre></td></tr></table></figure>

<p>最后我还扩展了一下语法，可以支持对 <code>JSON</code> 数据中的整形<code>（int、float）</code>做四则运算，虽然这是一个小众需求，但做完我觉得还挺有意思的，目前在市面上我还没发现有类似功能的库，可能和小众需求有关🤣。</p>
<p>其中核心的四则运算逻辑是由之前写的脚本解释器提供的:</p>
<p><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3u84i945oj218c0iwgpw.jpg"><br>单独提供了一个函数，传入一个四则运算表达式返回计算结果。</p>
<blockquote>
<p>由于上一版本还不支持 float，所以这次专门适配了一下。</p>
</blockquote>
<p>限于篇幅，更多关于这个四则运算的实现逻辑会在后面继续分享。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此算是我第一次利用编译原理的知识解决了一点特定领域问题，在大学以及工作这些年一直觉得编译原理比较高深，所以内心一直是抗拒的，但经过这段时间的学习和实践慢慢的也掌握到了一点门道。</p>
<p>不过目前也只是冰山一角，后面的编译原理后端更是要涉及到计算机底层知识，所以依然任重而道远。</p>
<p>已上都是题外话，针对于这个库我也会长期维护；为了能达到生产的使用要求，尽量提高了单测覆盖率，目前是98%。</p>
<p>也欢迎大家使用，提 bug🐛。</p>
<p>后面会继续优化，比如支持转义字符、提高性能等。</p>
<p>感兴趣的朋友请持续关注：<br><a href="https://github.com/crossoverJie/xjson">https://github.com/crossoverJie/xjson</a></p>
]]></content>
      <categories>
        <category>xjson</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>XJSON 是如何实现四则运算的？</title>
    <url>/2022/07/12/gjson/xjson03/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h42y3ylnbuj20wi0lomz7.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<a href="https://crossoverjie.top/2022/07/04/gjson/gjson02/">上一篇</a>中介绍了 <code>xjson</code> 的功能特性以及使用查询语法快速方便的获取 <code>JSON</code> 中的值。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h42btsa4cgj21cs0mmjuh.jpg"></p>
<p>同时这次也更新了一个版本，主要是两个升级：</p>
<ol>
<li>对转义字符的支持。</li>
<li>性能优化，大约提升了30%⬆️。</li>
</ol>
<span id="more"></span>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>先说第一个转义字符，不管是原始 <code>JSON</code> 字符串中存在转义字符，还是查询语法中存在转义字符都已经支持，具体用法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str = <span class="string">`&#123;&quot;1a.b.[]&quot;:&quot;b&quot;&#125;`</span></span><br><span class="line">get = Get(str, <span class="string">&quot;1a\\.b\\.\\[\\]&quot;</span>)</span><br><span class="line">assert.Equal(t, get.String(), <span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line">str = <span class="string">`&#123;&quot;.&quot;:&quot;b&quot;&#125;`</span></span><br><span class="line">get = Get(str, <span class="string">&quot;\\.&quot;</span>)</span><br><span class="line">assert.Equal(t, get.String(), <span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line">str = <span class="string">`&#123;&quot;a&quot;:&quot;&#123;\&quot;a\&quot;:\&quot;123\&quot;&#125;&quot;&#125;`</span></span><br><span class="line">get = Get(str, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">fmt.Println(get)</span><br><span class="line">assert.Equal(t, get.String(), <span class="string">&quot;&#123;\&quot;a\&quot;:\&quot;123\&quot;&#125;&quot;</span>)</span><br><span class="line">assert.Equal(t, Get(get.String(), <span class="string">&quot;a&quot;</span>).String(), <span class="string">&quot;123&quot;</span>)</span><br><span class="line"></span><br><span class="line">str = <span class="string">`&#123;&quot;a&quot;:&quot;&#123;\&quot;a\&quot;:[1,2]&#125;&quot;&#125;`</span></span><br><span class="line">get = Get(str, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">fmt.Println(get)</span><br><span class="line">assert.Equal(t, get.String(), <span class="string">&quot;&#123;\&quot;a\&quot;:[1,2]&#125;&quot;</span>)</span><br><span class="line">assert.Equal(t, Get(get.String(), <span class="string">&quot;a[0]&quot;</span>).Int(), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>性能也有部分优化，大约比上一版本提升了 30%。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pkg: github.com/crossoverJie/xjson/benckmark</span><br><span class="line">cpu: Intel(R) Core(TM) i7<span class="number">-9750</span>H CPU @ <span class="number">2.60</span>GHz</span><br><span class="line">BenchmarkDecode<span class="number">-12</span>        	   <span class="number">14968</span>	     <span class="number">77130</span> ns/op	   <span class="number">44959</span> B/op	    <span class="number">1546</span> allocs/op</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line">pkg: github.com/crossoverJie/xjson/benckmark</span><br><span class="line">cpu: Intel(R) Core(TM) i7<span class="number">-9750</span>H CPU @ <span class="number">2.60</span>GHz</span><br><span class="line">BenchmarkDecode<span class="number">-12</span>        	   <span class="number">19136</span>	     <span class="number">62960</span> ns/op	   <span class="number">41593</span> B/op	    <span class="number">1407</span> allocs/op</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>

<p>但总体来说还有不少优化空间，主要是上限毕竟低，和官方库比还是有不小的差距。</p>
<h1 id="实现四则运算"><a href="#实现四则运算" class="headerlink" title="实现四则运算"></a>实现四则运算</h1><p>接下来聊聊四则运算是如何实现的，这本身算是一个比较有意思的 <code>feature</code>，虽然用的场景不多🙂。</p>
<p>先来看看是如何使用的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">json :=<span class="string">`&#123;&quot;alice&quot;:&#123;&quot;age&quot;:10&#125;,&quot;bob&quot;:&#123;&quot;age&quot;:20&#125;,&quot;tom&quot;:&#123;&quot;age&quot;:20&#125;&#125;`</span></span><br><span class="line">query := <span class="string">&quot;(alice.age+bob.age) * tom.age&quot;</span></span><br><span class="line">arithmetic := GetWithArithmetic(json, query)</span><br><span class="line">assert.Equal(t, arithmetic.Int(), <span class="number">600</span>)</span><br></pre></td></tr></table></figure>
<p>输入一个 <code>JSON</code> 字符串以及计算公式然后得到计算结果。</p>
<p>其实实现原理也比较简单，总共分为是三步:</p>
<ol>
<li>对 <code>json</code> 进行词法分析，得到一个四则运算的第一步 <code>token</code>。</li>
<li>基于该 <code>token</code> 流，生产出最终的四则运算表达式，比如 <code>(3+2)*5</code></li>
<li>调用四则运算处理器，拿到最终结果。</li>
</ol>
<hr>
<p>先看第一步，根据 <code>(alice.age+bob.age) * tom.age</code> 解析出 <code>token</code>：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h43ekglsqej21g6078jsl.jpg"></p>
<p>第二步，解析该 token，碰到 <code>Identifier</code> 类型时，将其解析为具体的数据。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h43em2y8q3j21ha0l2tcj.jpg"><br>而其他类型的 token 直接拼接字符串即可，最终生成表达式：<code>(10+20)*20</code></p>
<blockquote>
<p>这一步的核心功能是由 <code>xjson.Get(json, query)</code> 函数提供的。</p>
</blockquote>
<p>关键代码如下图所示：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h43epvk5t8j20u00v20ws.jpg"></p>
<p>最终的目的就是能够生成一个表达式，只要拿到这个四则运算表达式便能得到最终计算结果。</p>
<p>而最终的计算逻辑其实也挺简单，构建一个 AST 树，然后深度遍历递归求解即可，如下图所示：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h43eugwrduj20n80n4mxz.jpg"></p>
<blockquote>
<p>这一步的核心功能是有之前实现的脚本解释器 <a href="https://github.com/crossoverJie/gscript/blob/4897b0dd0e4110820c1e69f7a692d90640325cbd/syntax/parse.go#L10">gscipt</a> 提供的。</p>
</blockquote>
<p>感兴趣的朋友可以查看源码。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个 <code>JSON</code> 库的功能其实并不多，欢迎大家分享平时用 <code>JSON</code> 库的常用功能；也欢迎大家体验下这个库。</p>
<p>源码地址：<br><a href="https://github.com/crossoverJie/xjson">https://github.com/crossoverJie/xjson</a></p>
]]></content>
      <categories>
        <category>xjson</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>用位运算为你的程序加速</title>
    <url>/2022/08/01/gjson/xjson04-bitwisee-operation/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4p37zeb9aj20xc0go0tv.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在持续优化之前编写的 <code>JSON</code> 解析库 <a href="https://github.com/crossoverJie/xjson">xjson</a>，主要是两个方面的优化。</p>
<p>第一个是支持将一个 <code>JSONObject</code> 对象输出为 <code>JSON</code> 字符串。</p>
<p>这点在上个版本中只是利用自带的 <code>Print</code> 函数打印数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJson4</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	str := <span class="string">`&#123;&quot;people&quot;:&#123;&quot;name&quot;:&#123;&quot;first&quot;:&quot;bob&quot;&#125;&#125;&#125;`</span></span><br><span class="line">	first := xjson.Get(str, <span class="string">&quot;people.name.first&quot;</span>)</span><br><span class="line">	assert.Equal(t, first.String(), <span class="string">&quot;bob&quot;</span>)</span><br><span class="line">	get := xjson.Get(str, <span class="string">&quot;people&quot;</span>)</span><br><span class="line">	fmt.Println(get.String())</span><br><span class="line">	<span class="comment">//assert.Equal(t, get.String(),`&#123;&quot;name&quot;:&#123;&quot;first&quot;:&quot;bob&quot;&#125;&#125;`)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">map[name:map[first:bob]]</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>本次优化之后便能直接输出 JSON 字符串了：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4p3ihijjgj20ne05s0sw.jpg"></p>
<p>实现过程也很简单，只需要递归遍历 object 中的数据，然后拼接字符串即可，核心代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> r.Token &#123;</span><br><span class="line">	<span class="keyword">case</span> String:</span><br><span class="line">		<span class="keyword">return</span> fmt.Sprint(r.object)</span><br><span class="line">	<span class="keyword">case</span> Bool:</span><br><span class="line">		<span class="keyword">return</span> fmt.Sprint(r.object)</span><br><span class="line">	<span class="keyword">case</span> Number:</span><br><span class="line">		i, _ := strconv.Atoi(fmt.Sprint(r.object))</span><br><span class="line">		<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, i)</span><br><span class="line">	<span class="keyword">case</span> Float:</span><br><span class="line">		i, _ := strconv.ParseFloat(fmt.Sprint(r.object), <span class="number">64</span>)</span><br><span class="line">		<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, i)</span><br><span class="line">	<span class="keyword">case</span> JSONObject:</span><br><span class="line">		<span class="keyword">return</span> object2JSONString(r.object)</span><br><span class="line">	<span class="keyword">case</span> ArrayObject:</span><br><span class="line">		<span class="keyword">return</span> object2JSONString(r.Array())</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4q0yqg8u1j20u00zl0vy.jpg"></p>
<h1 id="用位运算优化"><a href="#用位运算优化" class="headerlink" title="用位运算优化"></a>用位运算优化</h1><p>第二个优化主要是提高了性能，查询一个复杂 JSON 数据的时候性能提高了大约 ⏫16%.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">优化前</span></span><br><span class="line">BenchmarkDecode-12         90013             66905 ns/op           42512 B/op       1446 allocs/op</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">优化后</span></span><br><span class="line">BenchmarkDecode-12        104746             59766 ns/op           37749 B/op       1141 allocs/op</span><br></pre></td></tr></table></figure>


<p>这里截取了一些重点改动的部分：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4q29pojhdj223g0u0gsv.jpg"></p>
<p>在 JSON 解析过程中会有一个有限状态机状态迁移的过程，而迁移的时候可能会出现多个状态。</p>
<p>比如当前解析到的 token 值为 <code>&#123;</code>，那它接下来的 token 可能会为 <code>ObjectKey:&quot;name&quot;</code>,也可能会是 <code>BeginObject:&#123;</code>,当然也可能会是 <code>EndObject:&#125;</code>，<br>所以在优化之前我是将状态全部存放在一个集合中的，在解析过程中如果发现状态不满足预期的列表时则会抛出语法异常的错误。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4q2ysk89kj22s409omyd.jpg"></p>
<p>所以优化之前是遍历这个集合来进行判断的，这样的时间复杂度为 <code>O(N)</code>,但当我们换成位运算就不一样了，时间复杂度直接就变为<code>O(1)</code>了，同时还节省了一个切片的存储空间。</p>
<p>我们简单来分析下这个位运算为什么会达到判断一个数据是否在一个集合中同样的效果。</p>
<p>首先以这两个状态为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">StatusObjectKey   status = <span class="number">0x0002</span></span><br><span class="line">StatusColon       status = <span class="number">0x0004</span></span><br></pre></td></tr></table></figure>

<p>他们分别对应的二进制数据为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">StatusObjectKey   status = <span class="number">0x0002</span> <span class="comment">//0010</span></span><br><span class="line">StatusColon       status = <span class="number">0x0004</span> <span class="comment">//0100</span></span><br></pre></td></tr></table></figure>

<p>当我们对这两个数据求 <code>|</code> 运算得到的数据是 <code>0110</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">A:<span class="number">0010</span></span><br><span class="line">B:<span class="number">0100</span></span><br><span class="line"></span><br><span class="line">C:<span class="number">0110</span></span><br></pre></td></tr></table></figure>

<p>这时候如何我们如果用这两个原始数据与 <code>C:0110</code> 做 <code>&amp;</code> 运算时就会还原为刚才的两个数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// input:</span></span><br><span class="line">A:<span class="number">0010</span></span><br><span class="line">C:<span class="number">0110</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">A:<span class="number">0010</span></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"><span class="comment">// input:</span></span><br><span class="line">B:<span class="number">0100</span></span><br><span class="line">C:<span class="number">0110</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">B:<span class="number">0100</span></span><br></pre></td></tr></table></figure>


<p>但我们换一个 D 与 C 求 <code>&amp;</code> 时：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">D: <span class="number">1000</span> <span class="comment">// 0x0008 对应的二进制为 1000</span></span><br><span class="line">C: <span class="number">0110</span></span><br><span class="line">D<span class="string">&#x27;:0000</span></span><br></pre></td></tr></table></figure>
<p>将会得到一个 0 值，只要得出的数据大于 0 我们就能判断一个数据是否在给定的集合中了。</p>
<blockquote>
<p>当然这里有一个前提条件就是，我们输入的数据高位永远都是是 1 才行，也就是2的幂。</p>
</blockquote>
<p>同样的优化在解析查询语法时也有使用：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4q45v8q2dj22va0msaf2.jpg"></p>
<h1 id="其他奇淫巧技"><a href="#其他奇淫巧技" class="headerlink" title="其他奇淫巧技"></a>其他奇淫巧技</h1><p>当然位运算还有一些其他技巧，比如判断奇偶数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 偶数</span></span><br><span class="line">a &amp; <span class="number">1</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 奇数</span></span><br><span class="line">a &amp; <span class="number">1</span> == <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>乘法和除法，右移1一位是除以2，左移一位是乘以2.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">2</span></span><br><span class="line">fmt.Println(x&gt;&gt;<span class="number">1</span>) <span class="comment">//1</span></span><br><span class="line">fmt.Println(x&lt;&lt;<span class="number">1</span>) <span class="comment">//4</span></span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>位运算在带来程序性能提升的同时也降低代码可读性，所以我们得按需选择是否使用；</p>
<p>再一些底层库、框架代码对性能有极致追求的场景推荐使用，但在业务代码中对数据做加减乘除就没必要用位运算了，只会让后续的维护者一脸懵逼。</p>
<p>相关代码：<a href="https://github.com/crossoverJie/xjson">https://github.com/crossoverJie/xjson</a></p>
]]></content>
      <categories>
        <category>xjson</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>Bitwise operation</tag>
      </tags>
  </entry>
  <entry>
    <title>几百行代码实现一个脚本解释器</title>
    <url>/2022/05/30/gscript/gscript01/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2pp039p8mj20rs0rsmy0.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近又在重新学习编译原理了，其实两年前也复习过，当初是为了能实现通过 <code>MySQL</code> 的 <code>DDL</code> 生成 <code>Python</code> 中 <code>sqlalchemy</code> 的 <code>model</code>。</p>
<p><img src="https://i.loli.net/2020/03/23/dLpAoxf4BwEj81S.gif"><br>相关文章在这里：<a href="https://crossoverjie.top/2020/03/23/compilation/Lexer/">手写一个词法分析器</a></p>
<span id="more"></span>

<p>虽然完成了相关功能，但现在看来其实实现的比较糙的，而且也只运用到了词法分析；所以这次我的目的是可以通过词法分析-&gt;语法分析-&gt;语义分析 最终能实现一个功能完善的脚本”语言”。</p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>现在也有了一些阶段性的成果，如下图所示：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2pp97cs39j20hi0cwgmo.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2pp9ez7ibj20im0hcgnd.jpg"></p>
<p>目前具备以下基本功能：</p>
<ul>
<li>变量声明与赋值（只支持 int)</li>
<li>二次运算（优先级支持）</li>
<li>语法检查</li>
<li>debug 模式，可以打印 AST</li>
</ul>
<p>感兴趣的朋友可以在这里查看源码：<br><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p>
<p>本地有 go 环境的话也可以安装运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get github.com/crossoverJie/gscript</span><br><span class="line">gscript -h</span><br></pre></td></tr></table></figure>

<p>或者直接下载二进制文件运行：<a href="https://github.com/crossoverJie/gscript/releases">https://github.com/crossoverJie/gscript/releases</a></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>当前版本是使用 go 编写的，确实也如标题所说，核心代码还不到 1k 行代码，当然这也和目前功能简陋有关。</p>
<p>不过麻雀虽小五脏俱全，从当前版本还是运用到了编译原理中的部分知识：词法、语法分析。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2pq6r1ilkj210k0ngq4l.jpg"></p>
<p>基本实现流程如上图：</p>
<ul>
<li>通过词法分析器将源码中解析出 token</li>
<li>再通过对 token  推导生成出抽象语法树（AST）<ul>
<li>如果语法语法出现错误，这一步骤便会抛出编译失败，比如 <code>2*(1+</code> 少了一个括号。</li>
</ul>
</li>
</ul>
<p>因为没有使用类似于 <code>ANTLR</code> 这样工具来辅助生成代码（不然功能也不会只有这么点），所以其中的词法、语法分析都是手写的，代码量并不大，对于想要调试的朋友可以直接查看源码。</p>
<p>词法分析器：<code>token/token.go:39</code><br>语法分析器：<code>syntax/syntax.go</code></p>
<p>其中会涉及到一些概念，比如有限状态机、递归下降算法等知识点就没在本文讨论了，后续这个项目功能更加完善后也会重头整理。</p>
<h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><p>最后是画饼阶段了，不出意外后续会继续新增如下功能：</p>
<ul>
<li>更多的基础类型，string&#x2F;long 之类的。</li>
<li>变量作用域、函数。</li>
<li>甚至是闭包。</li>
<li>OOP 肯定也少不了。</li>
</ul>
<p>这些特性都实现后那也算是一个”现代”的脚本语言了，后续我也会继续更新学习和实现过程中的有趣内容。</p>
<p>源码地址：<br><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p>
]]></content>
      <categories>
        <category>gscript</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Antlr 重构脚本解释器</title>
    <url>/2022/08/08/gscript/gscript02-antlr-statement/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4y7c4s1gbj20z20kd0we.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一个版本实现的脚本解释器 <a href="https://github.com/crossoverJie/gscript">GScript</a> 中实现了基本的四则运算以及 <code>AST</code> 的生成。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4ybcb7x07j20im0hcgne.jpg"></p>
<p>当我准备再新增一个 <code>%</code> 取模的运算符时，会发现工作很繁琐而且几乎都是重复的；主要是两步：</p>
<ol>
<li>需要在词法解析器中新增对 <code>%</code> 符号的支持。</li>
<li>在语法解析器遍历 AST 时对 <code>%</code> token 实现具体逻辑。</li>
</ol>
<p>其中的词法解析和遍历 AST 完全是重复工作，所以我们可否能够简化这两步呢？</p>
<span id="more"></span>

<h1 id="Antlr"><a href="#Antlr" class="headerlink" title="Antlr"></a>Antlr</h1><p><code>Antlr</code> 就是做帮我们解决这些问题的常用工具，利用它我们只需要编写词法文件，然后就可以自动生成词法、语法解析器，并且可以生成不同语言的代码。</p>
<p>下面以 <code>GScript</code> 的示例来看看 antlr 是如何帮我们生成词法分析器的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGScriptVisitor_Visit_Lexer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	expression := <span class="string">&quot;(2+3) * 2&quot;</span></span><br><span class="line">	input := antlr.NewInputStream(expression)</span><br><span class="line">	lexer := parser.NewGScriptLexer(input)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		t := lexer.NextToken()</span><br><span class="line">		<span class="keyword">if</span> t.GetTokenType() == antlr.TokenEOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s (%q) %d\n&quot;</span>,</span><br><span class="line">			lexer.SymbolicNames[t.GetTokenType()], t.GetText(),t.GetColumn())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//output:</span><br><span class="line"> (&quot;(&quot;) 0</span><br><span class="line">DECIMAL_LITERAL (&quot;2&quot;) 1</span><br><span class="line">PLUS (&quot;+&quot;) 2</span><br><span class="line">DECIMAL_LITERAL (&quot;3&quot;) 3</span><br><span class="line"> (&quot;)&quot;) 4</span><br><span class="line">MULT (&quot;*&quot;) 6</span><br><span class="line">DECIMAL_LITERAL (&quot;2&quot;) 8</span><br></pre></td></tr></table></figure>

<p><code>Antlr </code> 会自动将我们的表达式解析为 <code>token</code>，遍历 <code>token</code> 时还能拿到该 <code>token</code> 所在的代码行数、位置等信息，在编译期间做语法检查非常有用。</p>
<p>要实现这些我们只需要编写词法、语法规则文件即可。</p>
<p>刚才的示例所对应的词法、语法规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expr</span><br><span class="line">    : &#x27;(&#x27; expr &#x27;)&#x27;                        #NestedExpr</span><br><span class="line">    | liter=literal #Liter</span><br><span class="line">    | lhs=expr bop=( MULT | DIV ) rhs=expr #MultDivExpr</span><br><span class="line">    | lhs=expr bop=MOD rhs=expr            #ModExpr</span><br><span class="line">    | lhs=expr bop=( PLUS | SUB ) rhs=expr #PlusSubExpr</span><br><span class="line">    | expr bop=(LE | GE | GT | LT ) expr # GLe</span><br><span class="line">    | expr bop=(EQUAL | NOTEQUAL) expr # EqualOrNot</span><br><span class="line">    ;</span><br><span class="line">DECIMAL_LITERAL:    (&#x27;0&#x27; | [1-9] (Digits? | &#x27;_&#x27;+ Digits)) [lL]?;    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>完整规则：<a href="https://github.com/crossoverJie/gscript/blob/main/GScript.g4">https://github.com/crossoverJie/gscript/blob/main/GScript.g4</a></p>
</blockquote>
<p>运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">antlr -Dlanguage=Go -o parser -visitor -no-listener GScript.g4</span><br></pre></td></tr></table></figure>

<p>就可以帮我们生成 <code>Go</code> 的代码（默认是 <code>Java</code>），关于 <code>Antlr</code> 的词法、文法规则以及安装步骤请参考<a href="https://www.antlr.org/">官网</a>。</p>
<p>而我们要实现具体的语法逻辑时只需要实现相关的接口，<code>Antlr</code> 会自动遍历 <code>AST</code>（当然也可以手动控制），同时在访问不同的 <code>AST</code> 节点时会回调我们自己实现的接口，这样我们就能编写自己的语法规则了。</p>
<p>以这里的新增的取模运算为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *GScriptVisitor)</span></span> VisitModExpr(ctx *parser.ModExprContext) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	lhs := v.Visit(ctx.GetLhs())</span><br><span class="line">	rhs := v.Visit(ctx.GetRhs())</span><br><span class="line">	<span class="keyword">return</span> lhs.(<span class="type">int</span>) % rhs.(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>Antlr</code> 回调 <code>VisitModExpr</code> 方法时，便能获取到 % 符号左右两侧的数据，这时只需要做相关运算即可。</p>
<p>基于这个模式这次新增了一个 <code>statement</code>，具体语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGScriptVisitor_VisitIfElse8</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	expression := <span class="string">`</span></span><br><span class="line"><span class="string">if(3!=(1+2))&#123;</span></span><br><span class="line"><span class="string">	return 1+3</span></span><br><span class="line"><span class="string">&#125; else &#123;</span></span><br><span class="line"><span class="string">	return false</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">	input := antlr.NewInputStream(expression)</span><br><span class="line">	lexer := parser.NewGScriptLexer(input)</span><br><span class="line">	stream := antlr.NewCommonTokenStream(lexer, <span class="number">0</span>)</span><br><span class="line">	parser := parser.NewGScriptParser(stream)</span><br><span class="line">	parser.BuildParseTrees = <span class="literal">true</span></span><br><span class="line">	tree := parser.Prog()</span><br><span class="line">	visitor := GScriptVisitor&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> result = visitor.Visit(tree)</span><br><span class="line">	fmt.Println(expression, <span class="string">&quot; result:&quot;</span>, result)</span><br><span class="line">	assert.Equal(t, result, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Antlr 还有其他各种优势，比如可以解决：</p>
<ul>
<li>左递归。</li>
<li>二义性。</li>
<li>优先级。</li>
</ul>
<p>等问题。</p>
<p>这里也推荐在 IDE 中安装 Antlr 的插件，这样就可以直观的查看  AST 语法树，可以帮我们更好的调试代码。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4ydh1xkenj22gk0qm43a.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4ydhe0vnpj217s0r277g.jpg"></p>
<h1 id="升级-xjson"><a href="#升级-xjson" class="headerlink" title="升级 xjson"></a>升级 xjson</h1><p>借助 <code>GScript</code> 提供的 <code>statement</code>，<code>xjson</code> 也提供了有些有意思的写法：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4yekrs5r5j219w0fu0v9.jpg"></p>
<p>因为 <code>xjson</code> 的四则运算语法没有使用 <code>Antlr</code> 生成，所以为了能支持 <code>GScript</code> 提供的 <code>statement</code> 需要手写许多词法代码。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4ye5optx1j21ji0u0wir.jpg"></p>
<p>这也体现了 <code>Antlr</code> 这类前端工具的重要性，效率提升是非常明显的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>借助于 <code>Antlr</code> 后续 <code>GScript</code> 会继续支持函数调用、更完善的类型系统、面向对象等特性；感兴趣的朋友请持续关注。</p>
<p>源码地址：<br><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a><br><a href="https://github.com/crossoverJie/xjson">https://github.com/crossoverJie/xjson</a></p>
]]></content>
      <categories>
        <category>gscript</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>antlr</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手写脚本解释器--实现作用域与函数调用</title>
    <url>/2022/08/17/gscript/gscript03-scope-func/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h594ovvpt6j20k00k0jse.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次利用 Antlr 重构一版 <a href="https://crossoverjie.top/2022/08/08/gscript/gscript02-antlr-statement/">用 Antlr 重构脚本解释器</a> 之后便着手新增其他功能，也就是现在看到的支持了作用域以及函数调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b= <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		age++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b+age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> foo(<span class="number">10</span>);</span><br><span class="line">	e = e+<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> a+b+<span class="number">3</span>+e;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">// Output:65</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>整个语法规则大部分参考了 Java，现阶段支持了：</p>
<ul>
<li>函数声明与调用。</li>
<li>函数调用的入栈和出栈，保证了函数局部变量在函数退出时销毁。</li>
<li>作用域支持，内部作用域可以访问外部作用域的变量。</li>
<li>基本的表达式语句，如 <code>i++, !=,==</code></li>
</ul>
<p>这次实现的重点与难点则是作用域与函数调用，实现之后也算是满足了我的好奇心，不过在讲作用域与函数调用之前先来看看一个简单的变量声明与访问语句是如何实现的，这样后续的理解会更加容易。</p>
<h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">a;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于还没有实现内置函数，比如控制台输出函数 print()，所以这里就直接访问变量也能拿到数据</p>
</blockquote>
<p>运行后结果如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5904p530kj20nc0ewdgo.jpg"></p>
<p>首先看看变量声明语句的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">variableDeclarators</span><br><span class="line">    : typeType variableDeclarator (&#x27;,&#x27; variableDeclarator)*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">variableDeclarator</span><br><span class="line">    : variableDeclaratorId (&#x27;=&#x27; variableInitializer)?</span><br><span class="line">    ;</span><br><span class="line">typeList</span><br><span class="line">    : typeType (&#x27;,&#x27; typeType)*</span><br><span class="line">    ;</span><br><span class="line">typeType</span><br><span class="line">    : (functionType | primitiveType) (&#x27;[&#x27; &#x27;]&#x27;)*</span><br><span class="line">    ;</span><br><span class="line">primitiveType</span><br><span class="line">    : INT</span><br><span class="line">    | STRING</span><br><span class="line">    | FLOAT</span><br><span class="line">    | BOOLEAN</span><br><span class="line">    ;        </span><br></pre></td></tr></table></figure>
<p> 只看语法不太直观，直接看下生成的 AST 树就明白了：<br> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5907v0pzmj20w80gkmy9.jpg"><br> 编译期<br> 左边这棵 <code>BlockVardeclar</code> 树对应的就是  <code>int a=10;</code>，右边的 <code>blockStm</code> 对应的就是变量访问 <code>a</code>。</p>
<p> 整个程序的运行过程分为编译期和运行期，对应的流程：</p>
<ul>
<li>遍历 AST 树，做语义分析，生成对应的符号表、类型表、引用消解、还有一些语法校验，比如变量名、函数名是否重复、是否能访问私有变量等。</li>
<li>运行期：从编译期中生成的符号表、类型表中获取数据，执行具体的代码逻辑。</li>
</ul>
<h2 id="访问-AST"><a href="#访问-AST" class="headerlink" title="访问 AST"></a>访问 AST</h2><p>对于刚才提到的编译期和运行期其实分别对应两种访问 <code>AST</code> 的方式，这也是 <code>Antlr</code> 所提供两种方式。</p>
<h3 id="Listener-模式"><a href="#Listener-模式" class="headerlink" title="Listener 模式"></a>Listener 模式</h3><p>第一种是 <code>Listener</code> 模式，就这名字也能猜到是如何运行的；我们需要实现 Antlr 所提供的接口，这些接口分别对应 AST 树中的不同节点。</p>
<p>接着 Antlr 会自动遍历这棵树，当访问和退出某个节点时变会回调我们自定义的方法，这些接口都是没有返回值的，所以我们需要将遍历过程中的数据自行存放起来。</p>
<p>这点非常适合上文提到的编译期，遍历过程中产生的数据自然就会存放到符号表、类型表这些容器中。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h591ozeop0j20u00uote1.jpg"><br>以这段代码为例，我们实现了程序根节点、for循环节点的进入和退出 Listener，当 Antlr 运行到这些节点时便会执行其中的逻辑。</p>
<p><a href="https://github.com/crossoverJie/gscript/blob/main/resolver/type_scope_resolver.go">https://github.com/crossoverJie/gscript/blob/main/resolver/type_scope_resolver.go</a></p>
<h3 id="Visitor-模式"><a href="#Visitor-模式" class="headerlink" title="Visitor 模式"></a>Visitor 模式</h3><p><code>Visitor</code> 模式正好和 <code>Listener</code> 相反，这是由我们自行控制需要访问哪个 AST 节点，同时需要在每次访问之后返回数据，这点非常适合来做程序运行期。</p>
<p>配合在编译期中存放的数据，便可以实现各种特性了。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5922ws8o0j21n00tcgsc.jpg"></p>
<p>以上图为例，在访问 Prog 节点时便可以从编译期中拿到当前节点所对应的作用域 <code>scope</code>，同时我们可以自行控制访问下一个节点 <code>VisitBlockStms</code>，访问其他节点当然也是可以的，不过通常我们还是按照语法中定义的结构进行访问。</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>即便是同一个语法生成的 AST 是相同的，但我们在遍历 AST 时实现不同也就会导致不同的语义，这就是各个语言语义分析的不同之处。</p>
<blockquote>
<p>比如 Java 不允许在子作用域中声明和父作用域中相同的变量，但 JavaScript 却是可以的。</p>
</blockquote>
<p>有了上面的基础下面我们来看看作用域是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">a;</span><br></pre></td></tr></table></figure>

<p>还是以这段代码为例：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59355xwevj21bw0rsq9k.jpg"></p>
<p>这里我简单画了下流程：</p>
<p>在编译期间会会为当前节点写入一个 <code>scope</code>，以及在 <code>scope</code> 中写入变量 <code>“a”</code>。</p>
<blockquote>
<p>这里的写入 scope 和写入变量是分为两次 Listener 进行的，具体代码实现在下面查看源码。</p>
</blockquote>
<p>第一次：<br><a href="https://github.com/crossoverJie/gscript/blob/main/resolver/type_scope_resolver.go#L21">https://github.com/crossoverJie/gscript/blob/main/resolver/type_scope_resolver.go#L21</a></p>
<p>第二次：<br><a href="https://github.com/crossoverJie/gscript/blob/main/resolver/type_resolver.go#L59">https://github.com/crossoverJie/gscript/blob/main/resolver/type_resolver.go#L59</a></p>
<p>接着是运行期，从编译期中生成的数据拿到 <code>scope</code> 以及其中的变量，获取变量时有一个细节：<br>当前 scope 中如果获取不到需要尝试从父级 <code>scope</code> 中获取，比如如下情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b= <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 b 在当前函数作用域中是获取不到的，只能在父级 <code>scope</code> 中获取。</p>
<blockquote>
<p>父级 scope 的关系是在创建 scope 的时候维护进去的，默认当前 scope 就是写入时 scope 的父级。</p>
</blockquote>
<p>关键代码试下如下图：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h593bq2mrgj211e0lwtby.jpg"></p>
<p>第四步获取变量的值也是需要访问到 AST 中的字面量节点获取值即可，核心代码如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h593fchoccj20wa0ia3zy.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h593fwqkgmj217p0u078h.jpg"></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数的调用最核心的就是在运行时需要把当前函数中的所有数据入栈，访问完毕后出栈，这样才能实现函数退出后自动释放函数体类的数据。</p>
<p>核心代码如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h593mb2qrqj216y0u0n37.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b= <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> foo();</span><br><span class="line">	<span class="keyword">return</span> a+b+<span class="number">3</span>+e;</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">2</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>即便是有上面这类函数类调其他函数情况也不必担心，无非就是在执行函数体的时候再往栈中写入数据而已，函数退出后会依次退出栈帧。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h593r5bgs5j20rs11bq4b.jpg"></p>
<p>有点类似于匹配括号的算法 <code>&#123;[()]&#125;</code>，本质上就是递归调用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>限于篇幅其中的许多细节没有仔细讨论，感兴趣的朋友可以直接跑跑单测，debug 试试。</p>
<p><a href="https://github.com/crossoverJie/gscript/blob/main/compiler_test.go">https://github.com/crossoverJie/gscript/blob/main/compiler_test.go</a></p>
<p>目前的版本还比较初级，比如基本类型还只有 int，也没有一些常用的内置函数。</p>
<p>后续会逐步完善，比如新增：</p>
<ul>
<li>函数多返回值。</li>
<li>自定义类型</li>
<li>闭包</li>
</ul>
<p>等特性，这个坑会一直填下去，希望在年底可以用 <code>gscript</code> 写一个 <code>web</code> 服务端那就算是里程碑完成了。</p>
<p>现阶段也实现了一个简易的 <code>REPL</code> 工具，大家可以安装试用：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h594523npmj20bc0de74n.jpg"></p>
<p>源码地址：<br><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p>
]]></content>
      <categories>
        <category>gscript</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>antlr</tag>
      </tags>
  </entry>
  <entry>
    <title>终于实现了一门属于自己的编程语言</title>
    <url>/2022/09/07/gscript/gscript04-preview/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5x5v62lgsj21o00u00u2.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>都说程序员的三大浪漫是：操作系统、编译原理、图形学；最后的图形学确实是特定的专业领域，我们几乎接触不到，所以对我来说换成网络更合适一些，最后再加上一个数据库。</p>
<p>这四项技术如果都能掌握的话那岂不是在 IT 行业横着走了，加上这几年互联网行业越来越不景气，越底层的技术就越不可能被替代；所以为了给自己的 30+ 危机留点出路，从今年上半年开始我就逐渐开始从头学习编译原理。</p>
<p>功夫不负有心人，经过近一个月的挑灯夜战，每晚都在老婆的催促下才休息，克服了中途好几次想放弃的冲动，终于现在完成了 <a href="https://github.com/crossoverJie/gscript">GScript</a> 一个预览版。</p>
<blockquote>
<p>预览版的意思是语法结构与整体设计基本完成，后续更新也不太会改动这部分内容、但还缺少一些易用功能。</p>
</blockquote>
<span id="more"></span>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>首先来看看保留环节， <a href="https://github.com/crossoverJie/gscript">GScript</a> 是如何编写 <code>hello world</code> 的。</p>
<p>hello_world.gs:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ gscript hello_world.gs</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>废话说完了接下来重点聊聊 <code>GScript</code> 所支持的特性了。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5x9767yayj20mi0h6myk.jpg"><br>后文会重点说明每一个特性。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>除了刚才提到的 hello world，再来看一个也是示例代码经常演示的<code>打印斐波那契数列</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">func <span class="title function_">int</span><span class="params">()</span> fib()&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = a+c;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="title function_">int</span><span class="params">()</span> f = fib();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    println(f());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>整体写法与 Go 官方推荐的类似：<a href="https://go.dev/play/p/NeGuDahW2yP">https://go.dev/play/p/NeGuDahW2yP</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fib returns a function that returns</span></span><br><span class="line"><span class="comment">// successive Fibonacci numbers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		a, b = b, a+b</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := fib()</span><br><span class="line">	<span class="comment">// Function calls are evaluated left-to-right.</span></span><br><span class="line">	fmt.Println(f(), f(), f(), f(), f())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都是通过闭包变量实现的，同时也展示了 <code>GScript</code> 对闭包、函数的使用，后文详细介绍闭包的用法。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>GScript</code> 的语法与常见的 <code>Java/Go</code> 类似，所以上手非常简单。</p>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>先来看看基本类型，目前支持 <code>int/string/float/bool</code> 四种基本类型以及 <code>nil</code> 特殊类型。</p>
<p>变量声明语法和 <code>Java</code> 类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">string b,c;</span><br><span class="line"><span class="type">float</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">10.1</span>;</span><br><span class="line"><span class="type">bool</span> <span class="variable">f</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>个人觉得将类型放在前面，代码阅读起来会更清晰一些，当然这也是个人喜好。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明并初始化</span></span><br><span class="line"><span class="type">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">println(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个空数组并指定大小</span></span><br><span class="line"><span class="type">int</span>[] table = [<span class="number">4</span>]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">println();</span><br><span class="line"><span class="comment">// 向数组 append 数据</span></span><br><span class="line">a = append(a,<span class="number">4</span>);</span><br><span class="line">println(a);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len(a);i++)&#123;</span><br><span class="line">	println(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过下标获取数组数据</span></span><br><span class="line"><span class="type">int</span> b=a[<span class="number">2</span>];</span><br><span class="line">println(b);</span><br></pre></td></tr></table></figure>

<p>其实严格来讲这并不算是数组，因为它的底层是用 <code>Go</code> 切片实现的，所以可以动态扩容。</p>
<p>以这段代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a=[<span class="number">2</span>]&#123;&#125;;</span><br><span class="line">println(<span class="string">&quot;数组大小:&quot;</span>+len(a));</span><br><span class="line">a = append(a,<span class="number">1</span>);</span><br><span class="line">println(<span class="string">&quot;数组大小:&quot;</span>+len(a));</span><br><span class="line">println(a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">100</span>;</span><br><span class="line">println(a);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">数组大小:2</span><br><span class="line">数组大小:3</span><br><span class="line">[&lt;nil&gt; &lt;nil&gt; 1]</span><br><span class="line">[100 &lt;nil&gt; 1]</span><br></pre></td></tr></table></figure>

<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>类的支持非常重要，是实现面向对象的基础，目前还未完全实现面向对象，只实现了数据与函数的封装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> v, ListNode n)&#123;</span><br><span class="line">        value =v;</span><br><span class="line">        next = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用构造函数时不需要使用 new 关键字。</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> ListNode(<span class="number">1</span>, nil);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 . 调用对象属性或函数。</span></span><br><span class="line">println(l1.value);</span><br></pre></td></tr></table></figure>

<p>缺省情况下 <code>class</code> 具有无参构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="type">int</span> age=<span class="number">10</span>;</span><br><span class="line">	string name=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">100</span>+age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造函数</span></span><br><span class="line">Person xx= Person();</span><br><span class="line">println(xx.age);</span><br><span class="line">assertEqual(xx.age, <span class="number">10</span>);</span><br><span class="line">println(xx.getAge());</span><br><span class="line">assertEqual(xx.getAge(), <span class="number">110</span>);</span><br></pre></td></tr></table></figure>

<p>得益于 <code>class</code> 的实现，结合刚才的数组也可以定义出自定义类型的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小为 16 的 Person 数组</span></span><br><span class="line">Person[] personList = [<span class="number">16</span>]&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数其实分为两类：</p>
<ul>
<li>普通的全局函数。</li>
<li>类的函数。</li>
</ul>
<p>本质上没有任何区别，只是所属范围不同而已。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断链表是否有环</span></span><br><span class="line">bool <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == nil)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.next == nil)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">bool</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (fast.next != nil)&#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.next == nil)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast.next.next == nil)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slow.next == nil)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow)&#123;</span><br><span class="line">            ret = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> ListNode(<span class="number">1</span>, nil);</span><br><span class="line"><span class="type">bool</span> <span class="variable">b1</span> <span class="operator">=</span>hasCycle(l1);</span><br><span class="line">println(b1);</span><br><span class="line">assertEqual(b1, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">l4</span> <span class="operator">=</span> ListNode(<span class="number">4</span>, nil);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">l3</span> <span class="operator">=</span> ListNode(<span class="number">3</span>, l4);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> ListNode(<span class="number">2</span>, l3);</span><br><span class="line"><span class="type">bool</span> <span class="variable">b2</span> <span class="operator">=</span> hasCycle(l2);</span><br><span class="line">println(b2);</span><br><span class="line">assertEqual(b2, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">l4.next = l2;</span><br><span class="line"><span class="type">bool</span> <span class="variable">b3</span> <span class="operator">=</span> hasCycle(l2);</span><br><span class="line">println(b3);</span><br><span class="line">assertEqual(b3, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>这里演示了链表是否有环的一个函数，只要有其他语言的使用基础，相信阅读起来没有任何问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(<span class="type">int</span> a)&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当函数没有返回值时，可以声明为 void 或直接忽略返回类型。</p>
</blockquote>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包我认为是非常有意思的一个特性，可以实现很灵活的设计，也是函数式编程的基础。</p>
<p>所以在 <code>GScript</code> 中函数是作为一等公民存在；因此 <code>GScript</code> 也支持函数类型的变量。</p>
<p>函数变量声明语法如下：<code>func typeTypeOrVoid &#39;(&#39; typeList? &#39;)&#39;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部变量，全局共享。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">varExternal</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f1()&#123;</span><br><span class="line">	<span class="comment">// 闭包变量对每个闭包单独可见</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">varInner</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">innerFun</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">		println(a);</span><br><span class="line">		<span class="type">int</span> c=<span class="number">100</span>;</span><br><span class="line">		varExternal++;</span><br><span class="line">		varInner++;</span><br><span class="line">		<span class="keyword">return</span> varInner;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回函数</span></span><br><span class="line">	<span class="keyword">return</span> innerFun;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f2 作为一个函数类型，接收的是一个返回值和参数都是 int 的函数。</span></span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f2 = f1();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">	println(<span class="string">&quot;varInner=&quot;</span> + f2(i) + <span class="string">&quot;, varExternal=&quot;</span> + varExternal);</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;=======&quot;</span>);</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f3 = f1();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">	println(<span class="string">&quot;varInner=&quot;</span> + f3(i) + <span class="string">&quot;, varExternal=&quot;</span> + varExternal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">varInner=21, varExternal=11</span><br><span class="line">1</span><br><span class="line">varInner=22, varExternal=12</span><br><span class="line">=======</span><br><span class="line">0</span><br><span class="line">varInner=21, varExternal=13</span><br><span class="line">1</span><br><span class="line">varInner=22, varExternal=14</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f2 = f1();</span><br></pre></td></tr></table></figure>

<p>以这段代码为例：f2 是一个返回值，入参都为 int 的函数类型；所以后续可以直接当做函数调用 <code>f2(i)</code>.</p>
<p>例子中将闭包分别赋值给 f2 和 f3 变量，这两个变量中的闭包数据也是互相隔离、互不影响的，所有基于这个特性甚至还是实现面向对象。</p>
<blockquote>
<p>关于闭包的实现，后续会单独更新一篇。</p>
</blockquote>
<p>更多样例请参考：<a href="https://github.com/crossoverJie/gscript/tree/main/example">https://github.com/crossoverJie/gscript/tree/main/example</a></p>
<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><p>标准库源码：<a href="https://github.com/crossoverJie/gscript/tree/main/internal">https://github.com/crossoverJie/gscript/tree/main/internal</a></p>
<p>目前实现的标准库并不多，这完全是一个体力活；基于现有的语法和基础数据类型，几乎可以实现大部分的数据结构了，所以感兴趣的朋友也欢迎来贡献标准库代码；比如 <code>Stack</code>、<code>Set</code> 之类的数据结构。</p>
<h2 id="MapString"><a href="#MapString" class="headerlink" title="MapString"></a>MapString</h2><p>以这个 <code>MapString</code> 为例：键值对都为 <code>string</code> 的 <code>HashMap</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">100</span>;</span><br><span class="line"><span class="type">MapString</span> <span class="variable">m1</span> <span class="operator">=</span> MapString();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">	<span class="type">string</span> <span class="variable">key</span> <span class="operator">=</span> i+<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="type">string</span> <span class="variable">value</span> <span class="operator">=</span> key;</span><br><span class="line">	m1.put(key,value);</span><br><span class="line">&#125;</span><br><span class="line">println(m1.getSize());</span><br><span class="line">assertEqual(m1.getSize(),count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">	<span class="type">string</span> <span class="variable">key</span> <span class="operator">=</span> i+<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="type">string</span> <span class="variable">value</span> <span class="operator">=</span> m1.get(key);</span><br><span class="line">	println(<span class="string">&quot;key=&quot;</span>+key+ <span class="string">&quot;:&quot;</span>+ value);</span><br><span class="line">	assertEqual(key,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用起来和 <code>Java</code> 的 <code>HashMap</code> 类似，当然他的实现源码也是参考的 jdk1.7 的 <code>HashMap</code>。</p>
<blockquote>
<p>由于目前并有一个类似于 Java 的 <code>object</code> 或者是 go 中的 <code>interface&#123;&#125;</code>, 所以如果需要存放 int，那还得实现一个 MapInt，不过这个通用类型很快会实现。</p>
</blockquote>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// len 返回数组大小</span></span><br><span class="line">println(len(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组追加数据</span></span><br><span class="line">a = append(a,<span class="number">4</span>);</span><br><span class="line">println(a);</span><br><span class="line"><span class="comment">// output: [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言函数，不相等时会抛出运行时异常，并中断程序。</span></span><br><span class="line">assertEqual(len(a),<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 hashcode</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hashcode</span> <span class="operator">=</span> hash(key);</span><br></pre></td></tr></table></figure>
<p>也内置了一些基本函数，当然也这不是由 <code>GScript</code> 源码实现的，而是编译器实现的，所以新增起来要稍微麻烦一些；后续会逐步完善，比如和 IO 相关的内置函数。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>现阶段的 <code>GScript</code> 还有许多功能没有完善，比如 JSON、网络库、更完善的语法检查、编译报错信息等；现在拿来刷刷 <code>LeetCode</code> 还是没有问题的。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5xaige47gj216o0lkq78.jpg"></p>
<p>从这 65 个 todo 就能看出还有很长的路要走，我对它的终极目标就是可以编写一个网站那就算是一个成熟的语言了。</p>
<p>目前还有一个问题是没有集成开发环境，现在的开发体验和白板上写代码相差无异，所以后续有时间的话尝试写一个 VS Code 的插件，至少能有语法高亮与提示。</p>
<p>最后对 <code>GScript</code> 或者是编译原理感兴趣的小伙伴可以加我微信一起交流。</p>
<p>项目源码：<a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a><br>下载地址：<a href="https://github.com/crossoverJie/gscript/releases/tag/v0.0.6">https://github.com/crossoverJie/gscript/releases/tag/v0.0.6</a></p>
]]></content>
      <categories>
        <category>gscript</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>antlr</tag>
      </tags>
  </entry>
  <entry>
    <title>用自己的编程语言实现了一个网站</title>
    <url>/2022/09/14/gscript/gscript05-write-site/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h65ahhmp7uj20h80beweu.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇<a href="https://crossoverjie.top/2022/09/07/gscript/gscript04-preview/">《终于实现了一门属于自己的编程语言》</a> 介绍了自己写的编程语言 <a href="https://github.com/crossoverJie/gscript">GScript</a> ，在文中提到希望最终可以使用 <code>GScript</code> 开发一个网站。</p>
<p>到目前为止确实是做到了，首页地址：</p>
<p><a href="https://gscript.crossoverjie.top/index">https://gscript.crossoverjie.top/index</a></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h65g2ios46j20zk0iyabv.jpg"></p>
<p>要称为一个网站确实有点勉强，不过也是一个动态网页，因为返回的是 <code>HTML</code>，所以在当前阶段只要不嫌麻烦其实也能写一个“合格”的网站，有点像以前我们学习 <code>Java</code> 时的 <code>servlet</code>。</p>
<span id="more"></span>

<p>该页面的源码地址在这里：<br><a href="https://github.com/crossoverjie/gscript-homepage">https://github.com/crossoverjie/gscript-homepage</a></p>
<p>其实总共也就40来行代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GScript</span>&#123;</span><br><span class="line">    string author;</span><br><span class="line">    string[] features;</span><br><span class="line">    string since;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">GScript</span>(string a, string[] f, string s)&#123;</span><br><span class="line">        author = a;</span><br><span class="line">        features = f;</span><br><span class="line">        since = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="title class_">HttpContext</span>) <span class="title function_">index</span>(<span class="params">HttpContext ctx</span>)&#123;</span><br><span class="line">    string[] features = &#123;<span class="string">&quot;statically&quot;</span>, <span class="string">&quot;strongly&quot;</span>&#125;;</span><br><span class="line">    <span class="title class_">GScript</span> gs = <span class="title class_">GScript</span>(<span class="string">&quot;crossoverJie&quot;</span>,features, <span class="string">&quot;2022&quot;</span>);</span><br><span class="line">    string j = <span class="title class_">JSON</span>(gs);</span><br><span class="line">    <span class="title function_">println</span>(j);</span><br><span class="line">    string local = <span class="title function_">getCurrentTime</span>(<span class="string">&quot;Asia/Shanghai&quot;</span>,<span class="string">&quot;2006-01-02 15:04:05&quot;</span>);</span><br><span class="line">    <span class="title function_">println</span>(<span class="string">&quot;local=&quot;</span> + local);</span><br><span class="line">    string html = ^</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>GScript<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                 _     _   </span></span><br><span class="line"><span class="language-xml"> ___ ___ ___ ___|_|___| |_ </span></span><br><span class="line"><span class="language-xml">| . |_ -|  _|  _| | . |  _|</span></span><br><span class="line"><span class="language-xml">|_  |___|___|_| |_|  _|_|  </span></span><br><span class="line"><span class="language-xml">|___|             |_|   v0.0.7   </span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">^+ j +^</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>current ^+ local +^<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com/crossoverjie/gscript-homepage&quot;</span>&gt;</span>GScript-homepace source code<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line">    ^;</span><br><span class="line">    ctx.<span class="title function_">HTML</span>(<span class="number">200</span>, html);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">httpHandle</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/index&quot;</span>, index);</span><br><span class="line">string[] args = <span class="title function_">getOSArgs</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">len</span>(args) ==<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="title function_">httpRun</span>(<span class="string">&quot;:&quot;</span> + args[<span class="number">2</span>]);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">httpRun</span>(<span class="string">&quot;:8000&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全是利用 <code>GScript</code> 所提供的标准库实现的，后文会详细聊聊内置 HTTP 包。</p>
<h1 id="更新内容"><a href="#更新内容" class="headerlink" title="更新内容"></a>更新内容</h1><p>下面重点来看看 <code>v0.0.8</code> 这个版本相较于上一个更新了哪些地方。</p>
<p>因为我是把自己当做一个开发者的角度去实现了一个 http 服务，同时还用 <code>GScript</code> 刷了两道简单的 LeetCode；为了让这个过程更流畅，更符合一个现代语言的使用方式，所以本次真的更新不少东西。</p>
<blockquote>
<p>刷题源码：<a href="https://github.com/crossoverJie/gscript/tree/main/example/leetcode">https://github.com/crossoverJie/gscript/tree/main/example/leetcode</a></p>
</blockquote>
<p>大概如下：</p>
<ul>
<li><code>any</code> 类型的支持，简化标准库的实现。</li>
<li>可以用 <code>^^</code> 来声明多行字符串，方便声明复杂字符串。</li>
<li>更完善的类型推导，修复了上个版本中某些情况推导不出类型的bug。</li>
<li>支持运算符重载。</li>
<li>基本的 http 包，可以开发出 http 服务，目前能响应 <code>JSON</code> 以及 <code>HTML</code>。</li>
<li>新增内置函数：根据时区获取当前时间、获取应用启动参数等。</li>
<li><code>JSON</code> 的序列表以及查询，语法级适配了 <a href="https://github.com/crossoverJie/xjson">XJSON</a>。</li>
<li>修复了在多个 <code>block</code> 嵌套情况下不能正确 <code>return</code> 的 bug。</li>
</ul>
<p>其实从这些更新中也能看出，上个版本只是一个简单能用的状态，而现在这个版本已经可以拿来写复杂逻辑了，当然目前还缺乏一些更友好的编译提示以及运行时错误。</p>
<p>下面仔细聊聊一些更新内容。</p>
<h2 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h2><p>首先是 <code>any</code> 通用类型，这个类似于 Java 中的 <code>Object</code> 和 Go 中的 <code>interface&#123;&#125;</code>,极大的方便了我们编写一些标准库。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h65gmnjk39j22u20jyjum.jpg"></p>
<p>以之前内置的 hash 和 len 函数为例，需要对每种类型都实现一遍，非常麻烦而且毫无必要；现在只需要定义一次即可，代码量直接省几倍。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h65go7c0lrj22ui0hqaem.jpg"><br>同理，之前实现的 Map 只支持存放 string 类型，现在便能存放任何类型的数据。</p>
<blockquote>
<p>对 any 的实现过程感兴趣的朋友，今后可以单独分享一下。</p>
</blockquote>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>写 go 或者是 Java 的朋友应该知道，这两门语言都无法对两个对象进行运算，编译器会直接报错。</p>
<p>但在一些特殊场景下还是蛮好用的，于是我参考了 <code>C#</code> 的语法在 <code>GScript</code> 中也实现了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	int age;</span><br><span class="line">	<span class="title class_">Person</span>(int a)&#123;</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> operator + (<span class="title class_">Person</span> p1, <span class="title class_">Person</span> p2)&#123;</span><br><span class="line">	<span class="title class_">Person</span> pp = <span class="title class_">Person</span>(p1.<span class="property">age</span>+p2.<span class="property">age</span>);</span><br><span class="line">	<span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> operator - (<span class="title class_">Person</span> p1, <span class="title class_">Person</span> p2)&#123;</span><br><span class="line">	<span class="title class_">Person</span> pp = <span class="title class_">Person</span>(p1.<span class="property">age</span>-p2.<span class="property">age</span>);</span><br><span class="line">	<span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> p1 = <span class="title class_">Person</span>(<span class="number">10</span>);</span><br><span class="line"><span class="title class_">Person</span> p2 = <span class="title class_">Person</span>(<span class="number">20</span>);</span><br><span class="line"><span class="title class_">Person</span> p3 = p1+p2;</span><br><span class="line"><span class="title function_">println</span>(<span class="string">&quot;p3.age=&quot;</span>+p3.<span class="property">age</span>);</span><br><span class="line"><span class="title function_">assertEqual</span>(p3.<span class="property">age</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>声明的函数名称必须为 <code>operator</code>，之后跟上运算符便实现了重载。</p>
<p>支持的运算符有：<code>+-*/ &lt; &gt;= &lt;= &gt; ==</code>。</p>
<h2 id="JSON支持"><a href="#JSON支持" class="headerlink" title="JSON支持"></a>JSON支持</h2><p>当前版本中支持将对象、基本类型进行序列化，暂不支持反序列化为对象，但可以根据 <code>JSON</code> 字符串通过一定的语法查询数据。</p>
<p>内置了两个 JSON 相关函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return JSON string</span></span><br><span class="line">string <span class="title class_">JSON</span>(any a)&#123;&#125;</span><br><span class="line"><span class="comment">// JSON query with path</span></span><br><span class="line">any <span class="title class_">JSON</span>Get(string json, string path)&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	int age;</span><br><span class="line">	string name;</span><br><span class="line">	float weight;</span><br><span class="line">	bool man;</span><br><span class="line">	<span class="title class_">Person</span>(string n, int a, float w, bool m)&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		age = a;</span><br><span class="line">		weight = w;</span><br><span class="line">		man =m;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> p1 = <span class="title class_">Person</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">10</span>,<span class="number">99.99</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="title class_">Person</span> p2 = <span class="title class_">Person</span>(<span class="string">&quot;a&quot;</span>,<span class="number">11</span>,<span class="number">999.99</span>,<span class="literal">false</span>);</span><br><span class="line">string json = <span class="title class_">JSON</span>(p1);</span><br><span class="line"><span class="title function_">println</span>(json);</span><br><span class="line"><span class="comment">// output:&#123;&quot;age&quot;:10,&quot;man&quot;:true,&quot;name&quot;:&quot;abc&quot;,&quot;weight&quot;:99.99&#125;</span></span><br></pre></td></tr></table></figure>
<p>以这段代码为例，调用 <code>JSON</code> 函数可以将对象序列化为 <code>JSON</code> 字符串。</p>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	int age;</span><br><span class="line">	string name;</span><br><span class="line">	float weight;</span><br><span class="line">	bool man;</span><br><span class="line">	<span class="title class_">Person</span>(string n, int a, float w, bool m)&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		age = a;</span><br><span class="line">		weight = w;</span><br><span class="line">		man =m;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> p1 = <span class="title class_">Person</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">10</span>,<span class="number">99.99</span>,<span class="literal">true</span>);</span><br><span class="line">string json = <span class="title class_">JSON</span>(p1);</span><br><span class="line"><span class="title function_">println</span>(json);</span><br><span class="line"></span><br><span class="line">int age = <span class="title class_">JSON</span>Get(json, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="title function_">println</span>(age);</span><br><span class="line"><span class="title function_">assertEqual</span>(age,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>使用 <code>JSONGet</code> 函数可以在一个 JSON 字符串中查询任意的数据，这个功能是通过适配 <a href="https://github.com/crossoverJie/xjson">XJSON</a> 实现的，所以 <code>XJSON</code> 支持的查询语法都能实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">string j=^&#123;<span class="string">&quot;age&quot;</span>:<span class="number">10</span>, <span class="string">&quot;abc&quot;</span>:&#123;<span class="string">&quot;def&quot;</span>:<span class="string">&quot;def&quot;</span>&#125;,<span class="string">&quot;list&quot;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;^;</span><br><span class="line"><span class="title class_">String</span> def = <span class="title class_">JSON</span>Get(j, <span class="string">&quot;abc.def&quot;</span>);</span><br><span class="line"><span class="title function_">println</span>(def);</span><br><span class="line"><span class="title function_">assertEqual</span>(def,<span class="string">&quot;def&quot;</span>);</span><br><span class="line">int l1 = <span class="title class_">JSON</span>Get(j, <span class="string">&quot;list[0]&quot;</span>);</span><br><span class="line"><span class="title function_">println</span>(l1);</span><br><span class="line"><span class="title function_">assertEqual</span>(l1,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">string str=^</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bob&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&quot;skill&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;lang&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;go&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;feature&quot;</span>: [</span><br><span class="line">                        <span class="string">&quot;goroutine&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;channel&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;simple&quot;</span>,</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">^;</span><br><span class="line"><span class="title class_">String</span> g = <span class="title class_">JSON</span>Get(str, <span class="string">&quot;skill.lang[0].go.feature[0]&quot;</span>);</span><br><span class="line"><span class="title function_">println</span>(g);</span><br><span class="line"><span class="title function_">assertEqual</span>(g,<span class="string">&quot;goroutine&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>比如这样复杂的嵌套 <code>JSON</code>，也能通过查询语法获取数据。</p>
<h2 id="HTTP-包"><a href="#HTTP-包" class="headerlink" title="HTTP 包"></a>HTTP 包</h2><p>HTTP 包是本次升级的重点，标准库中提供了以下函数和类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http lib</span></span><br><span class="line"><span class="comment">// Response json</span></span><br><span class="line"><span class="title class_">FprintfJSON</span>(int code, string path, string json)&#123;&#125;</span><br><span class="line"><span class="comment">// Resonse html</span></span><br><span class="line"><span class="title class_">FprintfHTML</span>(int code, string path, string html)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// path (relative paths may omit leading slash)</span></span><br><span class="line">string <span class="title class_">QueryPath</span>(string path)&#123;&#125;</span><br><span class="line"></span><br><span class="line">string <span class="title class_">FormValue</span>(string path, string key)&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpContext</span>&#123;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="title class_">JSON</span>(int code, any v)&#123;</span><br><span class="line">        string json = <span class="title class_">JSON</span>(v);</span><br><span class="line">        <span class="title class_">FprintfJSON</span>(code, path, json);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">HTML</span>(<span class="params">int code, any v</span>) &#123;</span><br><span class="line">        string html = v;</span><br><span class="line">        <span class="title class_">FprintfHTML</span>(code, path, html);</span><br><span class="line">    &#125;</span><br><span class="line">    string <span class="title function_">queryPath</span>(<span class="params"></span>) &#123;</span><br><span class="line">        string p = <span class="title class_">QueryPath</span>(path);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string <span class="title function_">formValue</span>(<span class="params">string key</span>)&#123;</span><br><span class="line">        string v = <span class="title class_">FormValue</span>(path, key);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bind route</span></span><br><span class="line"><span class="title function_">httpHandle</span>(<span class="params">string method, string path, func (HttpContext) handle</span>)&#123;</span><br><span class="line">    <span class="comment">// println(&quot;path=&quot;+path);</span></span><br><span class="line">    <span class="title class_">HttpContext</span> ctx = <span class="title class_">HttpContext</span>();</span><br><span class="line">    <span class="title function_">handle</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Run http server.</span></span><br><span class="line"><span class="title function_">httpRun</span>(<span class="params">string addr</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>具体的使用流程：</p>
<ol>
<li>通过定义一个函数变量实现自己的业务逻辑。</li>
<li>注册路由。</li>
<li>启动 HTTP 服务。</li>
</ol>
<p>在自己的 <code>handle</code> 中可以通过 <code>HttpContext</code> 对象拿到请求上下文，可以获取请求参数以及响应数据。<br>具体使用示例可以参考这份代码。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h65ha9w1q4j20u00w841m.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次更新比我预期的要顺利一些，因为语法树和编译器已经基本实现完毕，不会怎么改了，现在新增的特性无非就是运行时实现一些语法糖，大部分都是体力劳动；可能是新鲜感带来的兴奋剂效果，大部分时间都是痛并快乐着。</p>
<p>比如这两天主要就是在修复多层 <code>block</code> 嵌套时遇到 <code>return</code> 语句无法正确返回的 bug，死活折腾了两夜；终于在无数次分析 AST 找到了解决方案，现在想想确实还是相关经验太少。</p>
<blockquote>
<p>对这个 Bug 感兴趣的朋友可以点个赞，后面可以分享一下。</p>
</blockquote>
<p>下一阶段重点就是将编译信息好好整理，让开发体验更好。之后抽空再把 <code>SQL</code> 标准库实现了，这样就能愉快的 <code>CURD</code>了。</p>
<p>最后希望对该项目或者是编译原理感兴趣的朋友可以下载使用，提出宝贵意见，欢迎加我微信交流。</p>
<p>v0.0.8 下载地址：<br><a href="https://github.com/crossoverJie/gscript/releases/tag/v0.0.8">https://github.com/crossoverJie/gscript/releases/tag/v0.0.8</a></p>
]]></content>
      <categories>
        <category>gscript</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>antlr</tag>
      </tags>
  </entry>
  <entry>
    <title>手写编程语言-实现运算符重载</title>
    <url>/2022/09/18/gscript/gscript06-operator-overloading/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6at95ynkaj21900u07aw.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先带来日常的 <a href="https://github.com/crossoverJie/gscript">GScript</a> 更新：新增了可变参数的特性，语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int <span class="title function_">add</span>(<span class="params">string s, int ...num</span>)&#123;</span><br><span class="line">	<span class="title function_">println</span>(s);</span><br><span class="line">	int sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="title function_">len</span>(num);i++)&#123;</span><br><span class="line">		int v = num[i];</span><br><span class="line">		sum = sum+v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">int x = <span class="title function_">add</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="title function_">println</span>(x);</span><br><span class="line"><span class="title function_">assertEqual</span>(x, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>得益于可变参数，所以新增了格式化字符串的内置函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//formats according to a format specifier and writes to standard output.</span></span><br><span class="line"><span class="title function_">printf</span>(<span class="params">string format, any ...a</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//formats according to a format specifier and returns the resulting string.</span></span><br><span class="line">string <span class="title function_">sprintf</span>(<span class="params">string format, any ...a</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>下面重点看看 <a href="https://github.com/crossoverJie/gscript#operator-overloading">GScript</a> 所支持的运算符重载是如何实现的。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>运算符重载其实也是多态的一种表现形式，我们可以重写运算符的重载函数，从而改变他们的计算规则。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="number">100</span>+<span class="number">2</span>*<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>以这段代码的运算符为例，输出的结果自然是：104.</p>
<p>但如果我们是对两个对象进行计算呢，举个例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	Person(<span class="type">int</span> a)&#123;</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> Person(<span class="number">10</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> Person(<span class="number">20</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> p1+p2;</span><br></pre></td></tr></table></figure>

<p>这样的写法在 <code>Java/Go</code> 中都会报编译错误，这是因为他们两者都不支持运算符重载；</p>
<p>但 <code>Python/C#</code> 是支持的，相比之下我觉得 <code>C#</code> 的实现方式更符合 <code>GScript</code> 语法，所以参考 C# 实现了以下的语法规则。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span> operator + (<span class="title class_">Person</span> p1, <span class="title class_">Person</span> p2)&#123;</span><br><span class="line">	<span class="title class_">Person</span> pp = <span class="title class_">Person</span>(p1.<span class="property">age</span>+p2.<span class="property">age</span>);</span><br><span class="line">	<span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> p3 = p1+p2;</span><br><span class="line"><span class="title function_">println</span>(<span class="string">&quot;p3.age=&quot;</span>+p3.<span class="property">age</span>);</span><br><span class="line"><span class="title function_">assertEqual</span>(p3.<span class="property">age</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>有几个硬性条件：</p>
<ul>
<li>函数名必须是 <code>operator</code> </li>
<li>名称后跟上运算符即可。</li>
</ul>
<blockquote>
<p>目前支持的运算符有：+-*&#x2F;   &#x3D;&#x3D; !&#x3D; &lt; &lt;&#x3D; &gt; &gt;&#x3D;</p>
</blockquote>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>以前在使用 <code>Python</code> 运算符重载时就有想过它是如何实现的？但没有深究，这次借着自己实现相关功能从而需要深入理解。</p>
<p>其中重点就为两步：</p>
<ol>
<li>编译期间：记录所有的重载函数和运算符的关系。</li>
<li>运行期：根据当前的运算找到声明的函数，直接运行即可。</li>
</ol>
<p>第一步的重点是扫描所有的重载函数，将重载函数与运算符存放起来，需要关注的是函数的返回值与运算符类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OpOverload 重载符</span></span><br><span class="line"><span class="keyword">type</span> OpOverload <span class="keyword">struct</span> &#123;</span><br><span class="line">	function  *Func</span><br><span class="line">	tokenType <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符重载自定义函数</span></span><br><span class="line">opOverloads []*symbol.OpOverload</span><br></pre></td></tr></table></figure>

<p>在编译器中使用一个切片存放。</p>
<p>而在运行期中当两个入参类型相同时，则需要查找重载函数。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6b310mefaj21ky05u3zz.jpg"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GetOpFunction 获取运算符重载函数</span></span><br><span class="line"><span class="comment">// 通过返回值以及运算符号(+-*/) 匹配重载函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AnnotatedTree)</span></span> GetOpFunction(returnType symbol.Type, tokenType <span class="type">int</span>) *symbol.Func &#123;</span><br><span class="line">	<span class="keyword">for</span> _, overload := <span class="keyword">range</span> a.opOverloads &#123;</span><br><span class="line">		isType := overload.GetFunc().GetReturnType().IsType(returnType)</span><br><span class="line">		<span class="keyword">if</span> isType &amp;&amp; overload.GetTokenType() == tokenType &#123;</span><br><span class="line">			<span class="keyword">return</span> overload.GetFunc()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找方式就是通过编译期存放的数据进行匹配，拿到重载函数后自动调用便实现了重载。</p>
<p>感兴趣的朋友可以查看相关代码：</p>
<ul>
<li><p>编译期：<a href="https://github.com/crossoverJie/gscript/blob/ae729ce7d4cf39fe115121993fcd2222716755e5/resolver/type_scope_resolver.go#L127">https://github.com/crossoverJie/gscript/blob/ae729ce7d4cf39fe115121993fcd2222716755e5/resolver/type_scope_resolver.go#L127</a></p>
</li>
<li><p>运行期：<a href="https://github.com/crossoverJie/gscript/blob/499236af549be47ff827c6d55de1fc8e5600b9b3/visitor.go#L387">https://github.com/crossoverJie/gscript/blob/499236af549be47ff827c6d55de1fc8e5600b9b3/visitor.go#L387</a></p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>运算符重载其实并不是一个常用的功能；因为会改变运算符的语义，比如明明是加法却在重载函数中写为减法。</p>
<p>这会使得代码阅读起来困难，但在某些情况下我们又非常希望语言本身能支持运算符重载。</p>
<p>比如在 Go 中常用的一个第三方精度库<code>decimal.Decimal</code>，进行运算时只能使用 <code>d1.Add(d2)</code> 这样的函数，当运算复杂时：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a5 = (a1.Add(a2).Add(a3)).Mul(a4);</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a5 = (a1+a2+a3)*a4;</span><br></pre></td></tr></table></figure>

<p>就不如下面这种直观，所以有利有弊吧，多一个选项总不是坏事。</p>
<p>GScript 源码：<br><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p>
]]></content>
      <categories>
        <category>gscript</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>antlr</tag>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title>手写编程语言-递归函数是如何实现的？</title>
    <url>/2022/09/27/gscript/gscript07-return/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6k7cg9ushj20ic05kdge.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章主要是记录一下在 <a href="https://github.com/crossoverJie/gscript">GScript</a> 中实现递归调用时所遇到的坑，类似的问题在中文互联网上我几乎没有找到相关的内容，所以还是很有必要记录一下。</p>
<p>在开始之前还是简单介绍下本次更新的 <code>GScript</code> v0.0.9 所包含的内容：</p>
<ul>
<li>支持可变参数</li>
<li>优化 <code>append</code> 函数语义</li>
<li>优化编译错误信息</li>
<li>最后一个就是支持递归调用</li>
</ul>
<span id="more"></span>

<hr>
<p>先看第一个可变参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//formats according to a format specifier and writes to standard output.</span></span><br><span class="line">printf(string format, any ...a)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//formats according to a format specifier and returns the resulting string.</span></span><br><span class="line">string <span class="title function_">sprintf</span><span class="params">(string format, any ...a)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>以上是随着本次更新新增的两个标准函数，均支持可变参数，其中使用 <code>...</code> 表示可变参数，调用时如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">printf</span>(<span class="string">&quot;hello %s &quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="title function_">printf</span>(<span class="string">&quot;hello-%s-%s &quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="title function_">printf</span>(<span class="string">&quot;hello-%s-%d &quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="number">123</span>);</span><br><span class="line">string format = <span class="string">&quot;this is %s &quot;</span>;</span><br><span class="line"><span class="title function_">printf</span>(format, <span class="string">&quot;gscript&quot;</span>);</span><br><span class="line"></span><br><span class="line">string s = <span class="title function_">sprintf</span>(<span class="string">&quot;nice to meet %s&quot;</span>, <span class="string">&quot;you&quot;</span>);</span><br><span class="line"><span class="title function_">assertEqual</span>(s,<span class="string">&quot;nice to meet you&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>与大部分语言类似，可变参数本质上就是一个数组，所以可以拿来循环遍历：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int <span class="title function_">add</span>(<span class="params">string s, int ...num</span>)&#123;</span><br><span class="line">	<span class="title function_">println</span>(s);</span><br><span class="line">	int sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="title function_">len</span>(num);i++)&#123;</span><br><span class="line">		int v = num[i];</span><br><span class="line">		sum = sum+v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">int x = <span class="title function_">add</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="title function_">println</span>(x);</span><br><span class="line"><span class="title function_">assertEqual</span>(x, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// appends &quot;v&quot; to the end of a array &quot;a&quot;</span></span><br><span class="line"><span class="title function_">append</span>(<span class="params">any[] a, any v</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>之后是优化了内置函数 <code>append()</code> 的语义，本次优化来自于 issue12 的建议：<br><a href="https://github.com/crossoverJie/gscript/issues/12">https://github.com/crossoverJie/gscript/issues/12</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line">int[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="title function_">println</span>(a);</span><br><span class="line"><span class="title function_">println</span>();</span><br><span class="line">a = <span class="title function_">append</span>(a,<span class="number">4</span>);</span><br><span class="line"><span class="title function_">println</span>(a);</span><br><span class="line"><span class="comment">// Output: [1 2 3 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Now</span></span><br><span class="line">int[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="title function_">println</span>(a);</span><br><span class="line"><span class="title function_">println</span>();</span><br><span class="line"><span class="title function_">append</span>(a,<span class="number">4</span>);</span><br><span class="line">int b = a[<span class="number">3</span>];</span><br><span class="line"><span class="title function_">assertEqual</span>(<span class="number">4</span>, b);</span><br><span class="line"><span class="title function_">println</span>(a);</span><br><span class="line"><span class="comment">// Output: [1 2 3 4]</span></span><br></pre></td></tr></table></figure>

<p>现在 <code>append</code> 之后不需要再重新赋值，也会追加数据，优化后这里看起来是一个值&#x2F;引用传递的问题，但其实底层也是值传递，只是在语法上增加了这样的语法糖，帮使用者重新做了一次赋值。</p>
<hr>
<p>之后是新增了编译错误信息提示，比如下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a+<span class="number">2</span>;</span><br><span class="line">b+c;</span><br></pre></td></tr></table></figure>
<p>使用没有声明的变量，现在会直接编译失败：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1:0: undefined: a</span><br><span class="line">2:0: undefined: b</span><br><span class="line">2:2: undefined: c</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">2</span>:<span class="number">0</span>: <span class="keyword">class</span> <span class="title class_">T</span> redeclared <span class="keyword">in</span> <span class="variable language_">this</span> block</span><br></pre></td></tr></table></figure>
<p>重复声明之类的语法错误也有相关提示。</p>
<hr>
<p>最后一个才是本次讨论的重点，也就是递归函数的支持。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int <span class="title function_">num</span>(<span class="params">int x,int y</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> (y==<span class="number">1</span> || y ==x) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	int v1 = <span class="title function_">num</span>(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再上一个版本中 <code>int v1 = num(x - 1, y - 1);</code> 这行代码是不会执行的，具体原因后文会分析。</p>
<p>现在利用递归便可以实现类似于<code>打印杨辉三角</code>之类的程序了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int <span class="title function_">num</span>(<span class="params">int x,int y</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> (y==<span class="number">1</span> || y ==x) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    int v1 = <span class="title function_">num</span>(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">    int v2 = <span class="title function_">num</span>(x - <span class="number">1</span>, y);</span><br><span class="line">	int c = v1+v2;</span><br><span class="line">    <span class="comment">// int c = num(x - 1, y - 1)+num(x - 1, y);</span></span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printTriangle</span>(<span class="params">int row</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= row - i; j++) &#123;</span><br><span class="line">           <span class="title function_">print</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="title function_">print</span>(<span class="title function_">num</span>(i, j) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printTriangle</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">      <span class="number">1</span> </span><br><span class="line">     <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">    <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line">   <span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> </span><br><span class="line">  <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">4</span> <span class="number">1</span> </span><br><span class="line"> <span class="number">1</span> <span class="number">5</span> <span class="number">10</span> <span class="number">10</span> <span class="number">5</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">15</span> <span class="number">20</span> <span class="number">15</span> <span class="number">6</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure>

<h1 id="函数中的-return"><a href="#函数中的-return" class="headerlink" title="函数中的 return"></a>函数中的 return</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int <span class="title function_">num</span>(<span class="params">int x,int y</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> (y==<span class="number">1</span> || y ==x) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	int v1 = <span class="title function_">num</span>(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来看看这样的代码为什么执行完 <code>return 1</code> 之后就不会执行后边的语句了。</p>
<p>其实在此之前我首先解决的时候函数 <code>return</code> 后不能执行后续 <code>statement</code> 的需求，其实正好就是上文提到的逻辑，只是这里是递归而已。</p>
<p>先把代码简化一下方便分析：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int <span class="title function_">f1</span>(<span class="params">int a</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> (a==<span class="number">10</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">println</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当参数 a 等于 10 的时候确实不能执行后续的打印语句了，那么如何实现该需求呢？</p>
<p>以正常人类的思考方式：当我们执行完 <code>return</code> 语句的时候，就应该标记该语句所属的函数直接返回，不能在执行后续的 <code>statement</code>。</p>
<p>可是这应该如何实操呢？</p>
<p>其实看看 <code>AST</code> 就能明白了：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6kgqzbu9xj21ss0u0wiy.jpg"></p>
<p>当碰到 <code>return</code> 语句的时，会递归向上遍历语法树，标记上所有 <code>block</code> 节点表明这个 <code>block</code> 后续的语句不再执行了，同时还得把返回值记录下来。</p>
<p>这样当执行到下一个 <code>statement</code> 时，也就是 <code>	println(&quot;abc&quot;);</code> 则会判断他所属的 <code>block</code> 是否有被标记，如果有则直接返回，这样便实现了 <code>return</code> 语句不执行后续代码。</p>
<p>部分实现代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 return 的时候递归向上扫描所有的 Block，并打上标记，用于后面执行 return 的时候直接返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Visitor)</span></span> scanBlockStatementCtx(tree antlr.ParseTree, value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	context, ok := tree.(*parser.BlockContext)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="keyword">if</span> v.blockCtx2Mark == <span class="literal">nil</span> &#123;</span><br><span class="line">			v.blockCtx2Mark = <span class="built_in">make</span>(<span class="keyword">map</span>[*parser.BlockContext]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		v.blockCtx2Mark[context] = value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tree.GetParent() != <span class="literal">nil</span> &#123;</span><br><span class="line">		v.scanBlockStatementCtx(tree.GetParent().(antlr.ParseTree), value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6kh2esn6jj214m0u0tec.jpg"></p>
<p>源码地址：<br><a href="https://github.com/crossoverJie/gscript/blob/793d196244416574bd6be641534742e57c54db7a/visitor.go#L182">https://github.com/crossoverJie/gscript/blob/793d196244416574bd6be641534742e57c54db7a/visitor.go#L182</a></p>
<h1 id="递归的问题"><a href="#递归的问题" class="headerlink" title="递归的问题"></a>递归的问题</h1><p>但同时问题也来了，就是递归的时候也不会执行后续的递归代码了。</p>
<p>其实解决问题的方法也很简单，就是在判断是否需要直接返回那里新增一个条件，这个 <code>block</code> 中不存在递归调用。</p>
<p>所以我们就得先知道这个 <code>block</code> 中是否存在递归调用。</p>
<p>整个过程有以下几步：</p>
<ul>
<li>编译期：在函数声明处记录下函数与当前 <code>context</code> 的映射关系。</li>
<li>编译期：扫描 <code>statement</code> 时，取出该 <code>statement</code> 的 <code>context</code> 所对应的函数。</li>
<li>编译期：扫描到的 <code>statement</code> 如果是一个函数调用，则判断该函数是否为该 <code>block</code> 中的函数，也就是第二步取出的函数。</li>
<li>编译期：如果两个函数相等，则将当前 <code>block</code> 标记为递归调用。</li>
<li>运行期：在刚才判断 <code>return</code> 语句处，额外多出判断当前 <code>block</code> 是否为递归调用，如果是则不能返回。</li>
</ul>
<p>部分代码如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6khkphcxtj21660u043f.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6khle6mnvj219a0g2tbj.jpg"></p>
<p><a href="https://github.com/crossoverJie/gscript/blob/3e179f27cb30ca5c3af57b3fbf2e46075baa266b/resolver/ref_resolver.go#L70">https://github.com/crossoverJie/gscript/blob/3e179f27cb30ca5c3af57b3fbf2e46075baa266b/resolver/ref_resolver.go#L70</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里的递归调用其实卡了我挺长时间的，思路是有的，但是写出来的代码总是和预期不符，当天晚上坐在电脑面前到凌晨两三点，百思不得其解。</p>
<p>最后受不了上床休息的时候，突然一个灵光乍现让我想到了解决方案，于是第二天起了个早床赶忙实践，还真给解决了。</p>
<p>所以有些时候碰到棘手问题时给自己放松一下，往往会有出其不意的效果。</p>
<p>最后是目前的递归在某些情况下性能还有些问题，后续会尽量将这些标记过程都放在编译期，编译慢点没事，但运行时慢那就有问题了。</p>
<p>之后还会继续优化运行时的异常，目前是直接 <code>panic</code>，堆栈也没有，体感非常不好；欢迎感兴趣的朋友试用反馈bug。</p>
<p>源码地址：</p>
<p><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p>
]]></content>
      <categories>
        <category>gscript</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>go</tag>
        <tag>antlr</tag>
      </tags>
  </entry>
  <entry>
    <title>用自己的编程语言实现了一个网站（增强版）</title>
    <url>/2022/10/08/gscript/gscript08-write-site-enhance/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/01/29/Tr3H1wBh9NJi5lQ.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间在<a href="https://crossoverjie.top/2022/09/14/gscript/gscript05-write-site/">《用自己的编程语言实现了一个网站》</a>用介绍了用 <code>GScript</code> 写的一个简单“网站”，虽然是打上引号的；页面长这样：</p>
<p><img src="https://s2.loli.net/2023/01/29/kXMWY2Dy3RwatHb.png"></p>
<p>看起来确实非常的挫，其实之前一直也想做一个 <code>GScript</code> 的在线 <code>playground</code> ，于是国庆期间学了一点  皮毛 <code>Vue</code> 加上老弟的帮忙（他是前端开发），最终完成了下面这个网站：</p>
<p><a href="https://gscript.crossoverjie.top/">https://gscript.crossoverjie.top/</a></p>
<p><img src="https://s2.loli.net/2023/01/29/3iP94haxUzYWbwe.png"></p>
<blockquote>
<p>❤打印源码参考了：<a href="https://wa-lang.org/playground/">https://wa-lang.org/playground/</a></p>
</blockquote>
<span id="more"></span>

<p>在这里可以在线运行 <code>GScript</code> 代码，借助于前端的代码编辑器插件甚至还能有一些语法提示。</p>
<blockquote>
<p>不过有些提示与 GScript 的语法不兼容，毕竟编辑器的提示是基于 JavaScript 的语法。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/01/29/RTWZxm42MIJQCBE.png"></p>
<p>内置了几个 demo，可以选择运行试试。</p>
<p>同时也支持查看 <code>AST</code> 树和 <code>symbol</code> 符号表。</p>
<blockquote>
<p>虽然显示上还有待优化。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/01/29/4h1ySCk5QlVMcZG.png"><br><img src="https://s2.loli.net/2023/01/29/gXsqORWBdDaxry2.png"></p>
<p>整个后端接口全都是用 <code>GScript</code> 原生代码编写的，所以这也算是 <code>GScript</code> 的一个实际应用案例。</p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func (<span class="title class_">HttpContext</span>) <span class="title function_">run</span>(<span class="params">HttpContext ctx</span>) &#123;</span><br><span class="line">    string body = ctx.<span class="title function_">postFormValue</span>(<span class="string">&quot;body&quot;</span>);</span><br><span class="line">    string local = d.<span class="title function_">getCurrentTime</span>(<span class="string">&quot;Asia/Shanghai&quot;</span>,<span class="string">&quot;2006-01-02 15:04:05&quot;</span>);</span><br><span class="line">    <span class="title function_">println</span>(<span class="string">&quot;===&quot;</span> + local);</span><br><span class="line">    <span class="title function_">println</span>(body);</span><br><span class="line">    <span class="title function_">println</span>(<span class="string">&quot;===&quot;</span>);</span><br><span class="line">    <span class="title class_">RunResponse</span> r = <span class="title class_">RunResponse</span>();</span><br><span class="line">    <span class="keyword">if</span> (body == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        r.<span class="property">body</span> = <span class="string">&quot;empty code&quot;</span>;</span><br><span class="line">        ctx.<span class="title class_">JSON</span>(<span class="number">200</span>, r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string fileName = d.<span class="title function_">unix</span>(<span class="string">&quot;Asia/Shanghai&quot;</span>) + <span class="string">&quot;temp.gs&quot;</span> ;</span><br><span class="line">    s.<span class="title function_">writeFile</span>(fileName, body, <span class="number">438</span>);</span><br><span class="line">    string pwd = s.<span class="title function_">getwd</span>();</span><br><span class="line">    <span class="comment">// string res = s.command(&quot;gscript&quot;, fileName);</span></span><br><span class="line">    string res = s.<span class="title function_">command</span>(<span class="string">&quot;docker&quot;</span>,<span class="string">&quot;run&quot;</span>,<span class="string">&quot;--rm&quot;</span>,<span class="string">&quot;-v&quot;</span>, pwd+<span class="string">&quot;:/usr/src/gscript&quot;</span>,<span class="string">&quot;-w&quot;</span>,<span class="string">&quot;/usr/src/gscript&quot;</span>, <span class="string">&quot;crossoverjie/gscript&quot;</span>,<span class="string">&quot;gscript&quot;</span>, fileName);</span><br><span class="line">    s.<span class="title function_">remove</span>(fileName);</span><br><span class="line">    r.<span class="property">body</span> = res;</span><br><span class="line">    r.<span class="property">ast</span> = <span class="title function_">dumpAST</span>(body);</span><br><span class="line">    r.<span class="property">symbol</span>=<span class="title function_">dumpSymbol</span>(body);</span><br><span class="line">    ctx.<span class="title class_">JSON</span>(<span class="number">200</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">httpHandle</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/index&quot;</span>, index);</span><br><span class="line"><span class="title function_">httpHandle</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/run&quot;</span>, run);</span><br><span class="line">string[] args = s.<span class="title function_">getOSArgs</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">len</span>(args) ==<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="title function_">httpRun</span>(<span class="string">&quot;:&quot;</span> + args[<span class="number">2</span>]);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">httpRun</span>(<span class="string">&quot;:8000&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际代码量也并不多，将前端输入的代码写入到一个临时文件，再调用 OS 的 <code>command api</code> 在本地执行执行 docker，最后将标准输出和错误返回即可。</p>
<h1 id="版本更新"><a href="#版本更新" class="headerlink" title="版本更新"></a>版本更新</h1><p>为了能实现上述的需求，所以本次也更新了 <code>GScript</code> 的版本，新增了一些内置 <code>API</code>。</p>
<p><img src="https://s2.loli.net/2023/01/29/cQUbaZI9s8ONvXA.png"></p>
<p>主要是新增了 <code>playground</code> 需要的一些 <code>OS api</code>、文件写入、执行系统命令、日期相关等。</p>
<p>同时将同一类的 <code>API</code> 合并到一个 <code>class</code> 中，方便后期维护与调用。</p>
<h2 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h2><p>除此之外也新增了一些易用功能，比如现在提供了更友好的编译错误信息：<br><img src="https://s2.loli.net/2023/01/29/Du3Xga8czBTiCQh.png"></p>
<h2 id="运行时错误"><a href="#运行时错误" class="headerlink" title="运行时错误"></a>运行时错误</h2><p>运行时的异常现在也有对应提示：<br><img src="https://s2.loli.net/2023/01/29/COwbQqXtlsaGdK6.png"></p>
<p>只不过目前的显示还不太友好，打印的堆栈还是 <code>Go</code> 的，之后会优化为只显示 <code>GScript</code> 的堆栈。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有了在线的 <a href="https://gscript.crossoverjie.top/">playground</a> 后使得对 <code>GScript</code> 感兴趣的门槛更低了一些，欢迎大家试用。</p>
<hr>
<p>经过最近几个版本的迭代，<code>GScript</code> 也逐步完善了，基本完成了第一版本的需求。</p>
<p>后续会继续完善第二阶段的，比如：</p>
<ul>
<li>namespace</li>
<li>包管理</li>
<li>并发</li>
</ul>
<p>等内容，每一项看起来都不是那么容易啊。</p>
<p>之前有不少人问我 <code>GScript</code> 是拿来解决什么问题的？当时我确实没仔细想过；不过现在经过几个版本的开发有了一点想法：</p>
<p>是否可以将 <code>GScript</code> 作为一个脚本化的 Go 语言，毕竟 Go 是编译类型的，每次修改发布都需要经过编译才能运行，但如果可以像脚本语言，比如 <code>Python、Bash</code> 修改后就可以直接运行，这在写一些不是那么重的业务时非常有用。</p>
<p>同时借助于语法糖甚至可以优化掉 Go 本身被人“吐槽”的地方，比如异常、append 函数、没有运算符重载、三目运算符等。</p>
<blockquote>
<p>部分吐槽 <code>GScript</code> 已经支持。</p>
</blockquote>
<p>同时因为得益于本身也是 Go 编写的，所以 Go 的一些优点也能继承过来，比如轻量级的协程等。</p>
<p>Go 本身也有大量的第三方库，后续甚至也能直接使用这些现成的库。</p>
<p>以上只是一些美好的畅想，就像老板画的大饼一样，具体在实现过程中可能又有不一样的想法，欢迎提供建议。</p>
<p><code>playground</code> 地址：<br><a href="https://gscript.crossoverjie.top/">https://gscript.crossoverjie.top/</a></p>
<p>源码地址：<br><a href="https://github.com/crossoverjie/gscript">https://github.com/crossoverjie/gscript</a></p>
]]></content>
      <categories>
        <category>gscript</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>如何为 GScript 编写标准库</title>
    <url>/2022/10/15/gscript/gscript10-write-native-lib/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/01/17/Ig7svqZCcPB9FuU.png"></p>
<h1 id="版本更新"><a href="#版本更新" class="headerlink" title="版本更新"></a>版本更新</h1><p>最近 <code>GScript</code> 更新了 <code>v0.0.11</code> 版本，重点更新了：</p>
<ul>
<li><code>Docker</code> 运行环境</li>
<li>新增了 byte 原始类型</li>
<li>新增了一些字符串标准库 <code>Strings/StringBuilder</code></li>
<li>数组切片语法：<code>int[] b = a[1: len(a)];</code></li>
</ul>
<blockquote>
<p>具体更新内容请看下文。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间发布了 <code>GScript</code> 的在线 <code>playground</code>，<br><img src="https://s2.loli.net/2023/01/17/RmTtoqbxPipOgKj.gif"></p>
<span id="more"></span>

<p>这是一个可以在线运行 <code>GScript</code> 脚本的网站，其本质原理是接收用户的输入源码从而在服务器上运行的服务；这简直就是后门大开的 <code>XSS</code> 攻击，为保住服务器我设置了运行 <code>API</code> 的后端服务的用户权限，这样可以避免执行一些恶意的请求。</p>
<p>但也避免不了一些用户执行了一些耗时操作，比如一个死循环、或者是我提供 <code>demo</code> 里的打印杨辉三角。<br><img src="https://s2.loli.net/2023/01/17/LR7EAtxQnB42Wf9.png"></p>
<p>这本质上是一个递归函数，当打印的三角层数过高时便会非常耗时，同时也非常消耗 CPU。</p>
<p>有几次我去检查服务器时发现了几个 CPU 过高的进程，基本上都是这样的耗时操作，不可避免的会影响到服务器的性能。</p>
<h1 id="使用-Docker"><a href="#使用-Docker" class="headerlink" title="使用 Docker"></a>使用 Docker</h1><p>为了解决这类问题，很自然的就能想到可以使用 <code>Docker</code>，所有的资源都和宿主机是隔离开的，无论怎么瞎折腾也不会影响到宿主机。</p>
<p>说干就干，最后修改了 API 执行脚本的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">string</span> <span class="variable">fileName</span> <span class="operator">=</span> d.unix(<span class="string">&quot;Asia/Shanghai&quot;</span>) + <span class="string">&quot;temp.gs&quot;</span> ;</span><br><span class="line">s.writeFile(fileName, body, <span class="number">438</span>);</span><br><span class="line"><span class="type">string</span> <span class="variable">pwd</span> <span class="operator">=</span> s.getwd();</span><br><span class="line"><span class="comment">// string res = s.command(&quot;gscript&quot;, fileName);</span></span><br><span class="line"><span class="type">string</span> <span class="variable">res</span> <span class="operator">=</span> s.command(<span class="string">&quot;docker&quot;</span>,<span class="string">&quot;run&quot;</span>,<span class="string">&quot;--rm&quot;</span>,<span class="string">&quot;-v&quot;</span>, pwd+<span class="string">&quot;:/usr/src/gscript&quot;</span>,<span class="string">&quot;-w&quot;</span>,<span class="string">&quot;/usr/src/gscript&quot;</span>, <span class="string">&quot;crossoverjie/gscript&quot;</span>,<span class="string">&quot;gscript&quot;</span>, fileName);</span><br><span class="line">s.remove(fileName);</span><br><span class="line">r.body = res;</span><br><span class="line">r.ast = dumpAST(body);</span><br><span class="line">r.symbol=dumpSymbol(body);</span><br><span class="line">ctx.JSON(<span class="number">200</span>, r);</span><br></pre></td></tr></table></figure>

<p>主要修改的就是将直接执行的 <code>GScript</code> 命令修改为了调用 <code>docker</code> 执行。</p>
<blockquote>
<p>但其实也还有改进空间，后续新增协程之后可以便可监控运行时间，超时后便会自动 kill 进程。</p>
</blockquote>
<p>我也将该 <code>Docker</code> 上传到了 <code>DockerHub</code>，现在大家想在本地体验 <code>GScript</code> 的 <code>REPL</code> 时也只需要运行<code>Docker</code> 就能使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull crossoverjie/gscript</span><br><span class="line">docker run --rm -it  crossoverjie/gscript:latest gscript</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/01/17/sg67rJAc4BafouI.png"></p>
<p>当然也可以执行用 <code>Docker</code> 执行 <code>GScript</code> 脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -v $PWD:/usr/src/gscript -w /usr/src/gscript crossoverjie/gscript gscript &#123;yourpath&#125;/temp.gs</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h76194c45pj320g0ee41b.jpg"></p>
<h1 id="编写-GScript-标准库"><a href="#编写-GScript-标准库" class="headerlink" title="编写 GScript 标准库"></a>编写 GScript 标准库</h1><p>接下来重点聊聊 <code>GScript</code> 标准库的事情，其实编写标准库是一个费时费力的事情。<br><img src="https://s2.loli.net/2023/01/17/oKnZq5mDPpkF7Ix.png"><br>现在编译器已经提供了一些可用的内置函数，借由这些内置函数写一些常见的工具类是完全没有问题的。</p>
<p>对写 <code>GScript</code> 标准库感谢的朋友可以当做一个参考，这里我打了一个样，先看下运行效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串工具类</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">b</span> <span class="operator">=</span> StringBuilder();</span><br><span class="line">b.writeString(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">b.writeString(<span class="string">&quot;20&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> b.writeString(<span class="string">&quot;30&quot;</span>);</span><br><span class="line"><span class="type">string</span> <span class="variable">s</span> <span class="operator">=</span> b.String();</span><br><span class="line">printf(<span class="string">&quot;s:%s, len=%d &quot;</span>,s,l);</span><br><span class="line">assertEqual(s,<span class="string">&quot;102030&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] b2 = toByteArray(<span class="string">&quot;40&quot;</span>);</span><br><span class="line">b.WriteBytes(b2);</span><br><span class="line">s = b.String();</span><br><span class="line">assertEqual(s,<span class="string">&quot;10203040&quot;</span>);</span><br><span class="line">println(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Strings 工具类</span></span><br><span class="line"><span class="type">Strings</span> <span class="variable">s</span> <span class="operator">=</span> Strings();</span><br><span class="line">string[] elems = &#123;<span class="string">&quot;name=xxx&quot;</span>,<span class="string">&quot;age=xx&quot;</span>&#125;;</span><br><span class="line"><span class="type">string</span> <span class="variable">ret</span> <span class="operator">=</span> s.join(elems, <span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">println(ret);</span><br><span class="line">assertEqual(ret, <span class="string">&quot;name=xxx&amp;age=xx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="variable">b</span> <span class="operator">=</span> s.hasPrefix(<span class="string">&quot;http://www.xx.com&quot;</span>, <span class="string">&quot;http&quot;</span>);</span><br><span class="line">println(b);</span><br><span class="line">assertEqual(b,<span class="literal">true</span>);</span><br><span class="line">b = s.hasPrefix(<span class="string">&quot;http://www.xx.com&quot;</span>, <span class="string">&quot;https&quot;</span>);</span><br><span class="line">println(b);</span><br><span class="line">assertEqual(b,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>其中的实现源码基本上是借鉴了 Go 的标准库，先来看看 <code>StringBuilder</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringBuilder</span>&#123;</span><br><span class="line">    <span class="type">byte</span>[] buf = [<span class="number">0</span>]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// append contents to buf, it returns the length of s</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">writeString</span><span class="params">(string s)</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] temp = toByteArray(s);</span><br><span class="line">        append(buf, temp);</span><br><span class="line">        <span class="keyword">return</span> len(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// append b to buf, it returns the length of b.</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">WriteBytes</span><span class="params">(<span class="type">byte</span>[] b)</span>&#123;</span><br><span class="line">        append(buf, b);</span><br><span class="line">        <span class="keyword">return</span> len(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copies the buffer to a new.</span></span><br><span class="line">    grow(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// when there is not enough space left.</span></span><br><span class="line">            <span class="keyword">if</span> (cap(buf) - len(buf) &lt; n) &#123;</span><br><span class="line">                <span class="type">byte</span>[] newBuf = [len(buf), <span class="number">2</span>*cap(buf)+n]&#123;&#125;;</span><br><span class="line">                copy(newBuf, buf);</span><br><span class="line">                buf = newBuf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string <span class="title function_">String</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是借助了原始的数组类型以及 <code>toByteArray/toString</code> 字节数组和字符串的转换函数实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Strings</span>&#123;</span><br><span class="line">    <span class="comment">// concatenates the elements of its first argument to create a single string. The separator</span></span><br><span class="line">    <span class="comment">// string sep is placed between elements in the resulting string.</span></span><br><span class="line">    string <span class="title function_">join</span><span class="params">(string[] elems, string sep)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len(elems) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len(elems) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> elems[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">byte</span>[] bs = toByteArray(sep);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> len(bs) * (len(elems) -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; len(elems); i++) &#123;</span><br><span class="line">            <span class="type">string</span> <span class="variable">s</span> <span class="operator">=</span> elems[i];</span><br><span class="line">            <span class="type">byte</span>[] bs = toByteArray(s);</span><br><span class="line">            n = n + len(bs);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> StringBuilder();</span><br><span class="line">        sb.grow(n);</span><br><span class="line">        <span class="type">string</span> <span class="variable">first</span> <span class="operator">=</span> elems[<span class="number">0</span>];</span><br><span class="line">        sb.writeString(first);</span><br><span class="line"></span><br><span class="line">        string[] remain = elems[<span class="number">1</span>:len(elems)];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; len(remain); i++)&#123;</span><br><span class="line">            sb.writeString(sep);</span><br><span class="line">            <span class="type">string</span> <span class="variable">r</span> <span class="operator">=</span> remain[i];</span><br><span class="line">            sb.writeString(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.String();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// tests whether the string s begins with prefix.</span></span><br><span class="line">    bool <span class="title function_">hasPrefix</span><span class="params">(string s, string prefix)</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toByteArray(s);</span><br><span class="line">        <span class="type">byte</span>[] bp = toByteArray(prefix);    </span><br><span class="line">        <span class="keyword">return</span> len(bs) &gt;= len(bp) &amp;&amp; toString(bs[<span class="number">0</span>:len(bp)]) == prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Strings</code> 工具类也是类似的，都是一些内置函数的组合运用；</p>
<p>在写标准库的过程中还会有额外收获，可以再次阅读一遍 Go 标准库的实现流程，换了一种语法实现出来，会加深对 Go 标准库的理解。</p>
<p>所以欢迎感兴趣的朋友向 <code>GScript</code> 贡献标准库，由于我个人精力有限，实现过程中可能会发现缺少某些内置函数或数据结构，这也没关系，反馈 <code>issue</code> 后我会尽快处理。</p>
<blockquote>
<p>由于目前 <code>GScript</code> 还不支持包管理，所以新增的函数可以创建 <code>Class</code> 来实现，后续支持包或者是 <code>namespace</code> 之后直接将该 <code>Class</code> 迁移过去即可。</p>
</blockquote>
<hr>
<p>本文相关资源链接</p>
<ul>
<li>GScript 源码：<a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></li>
<li>Playground 源码：<a href="https://github.com/crossoverJie/gscript-homepage">https://github.com/crossoverJie/gscript-homepage</a></li>
<li>GScript Docker地址：<a href="https://hub.docker.com/r/crossoverjie/gscript">https://hub.docker.com/r/crossoverjie/gscript</a></li>
</ul>
]]></content>
      <categories>
        <category>gscript</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解闭包实现原理</title>
    <url>/2022/10/24/gscript/gscript11-closure/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/01/14/QnYTwcpIxEH5WOm.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>闭包对于一个长期写 <code>Java</code> 的开发者来说估计鲜有耳闻，我在写 <code>Python</code> 和 <code>Go</code> 之前也是没怎么了解，光这名字感觉就有点”神秘莫测”，这篇文章的主要目的就是从编译器的角度来分析闭包，彻底搞懂闭包的实现原理。</p>
<span id="more"></span>

<h1 id="函数一等公民"><a href="#函数一等公民" class="headerlink" title="函数一等公民"></a>函数一等公民</h1><p>一门语言在实现闭包之前首先要具有的特性就是：<code>First class function</code> 函数是第一公民。</p>
<p>简单来说就是函数可以像一个普通的值一样在函数中传递，也能对变量赋值。</p>
<p>先来看看在 Go 里是如何编写的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> varExternal <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	varInner := <span class="number">20</span></span><br><span class="line">	innerFun := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		fmt.Println(a)</span><br><span class="line">		varExternal++</span><br><span class="line">		varInner++</span><br><span class="line">		<span class="keyword">return</span> varInner</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> innerFun</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	varExternal = <span class="number">10</span></span><br><span class="line">	f2 := f1()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;varInner=%d, varExternal=%d \n&quot;</span>, f2(i), varExternal)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;======&quot;</span>)</span><br><span class="line"></span><br><span class="line">	f3 := f1()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;varInner=%d, varExternal=%d \n&quot;</span>, f3(i), varExternal)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">varInner=<span class="number">21</span>, varExternal=<span class="number">11</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line">varInner=<span class="number">22</span>, varExternal=<span class="number">12</span> </span><br><span class="line">======</span><br><span class="line"><span class="number">0</span></span><br><span class="line">varInner=<span class="number">21</span>, varExternal=<span class="number">13</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line">varInner=<span class="number">22</span>, varExternal=<span class="number">14</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里体现了闭包的两个重要特性，第一个自然就是函数可以作为值返回，同时也能赋值给变量。</p>
<p>第二个就是在闭包函数 <code>f1()</code> 对闭包变量 <code>varInner</code> 的访问，每个闭包函数的引用都会在自己的函数内部保存一份闭包变量 <code>varInner</code>，这样在调用过程中就不会互相影响。</p>
<p>从打印的结果中也能看出这个特性。</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>闭包之所以不太好理解的主要原因是它不太符合自觉。</p>
<p><img src="https://s2.loli.net/2023/01/14/FwMJpUvdPgyhCNY.png"></p>
<p>本质上就是作用域的关系，当我们调用 <code>f1()</code> 函数的时候，会在栈中分配变量 <code>varInner</code>，正常情况下调用完毕后 <code>f1</code> 的栈会弹出，里面的变量 <code>varInner</code> 自然也会销毁才对。</p>
<p>但在后续的 <code>f2()</code> 和 <code>f3()</code> 调用的时，却依然能访问到 <code>varInner</code>，就这点不符合我们对函数调用的直觉。</p>
<p>但其实换个角度来看，对 <code>innerFun</code> 来说，他能访问到 <code>varExternal</code> 和 <code>varInner</code> 变量，最外层的 <code>varExternal</code> 就不用说了，一定是可以访问的。</p>
<p>但对于 <code>varInner</code> 来说就不一定了，这里得分为两种情况；重点得看该语言是<strong>静态&#x2F;动态</strong>作用域。</p>
<p>就静态作用域来说，每个符号在编译器就确定好了树状关系，运行时不会发生变化；也就是说 <code>varInner</code> 对于 <code>innerFun</code> 这个函数来说在编译期已经确定可以访问了，在运行时自然也是可以访问的。</p>
<p>但对于动态作用域来说，完全是在运行时才确定访问的变量是哪一个。</p>
<p>恰好 <code>Go</code> 就是一个静态作用域的语言，所以返回的 <code>innerFun</code> 函数可以一直访问到 <code>varInner</code> 变量。</p>
<h1 id="实现闭包"><a href="#实现闭包" class="headerlink" title="实现闭包"></a>实现闭包</h1><p>但 Go 是如何做到在 <code>f1()</code> 函数退出之后依然能访问到 <code>f1()</code> 中的变量呢？</p>
<p>这里我们不妨大胆假设一下：</p>
<p>首先在编译期扫描出哪些是闭包变量，也就是这里的 <code>varInner</code>，需要将他保存到函数 <code>innerFun()</code> 中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f2 := f1()</span><br><span class="line">f2()</span><br></pre></td></tr></table></figure>

<p>运行时需要判断出 <code>f2</code> 是一个函数，而不是一个变量，同时得知道它所包含的函数体是 <code>innerFun()</code> 所定义的。</p>
<p>接着便是执行函数体的 <code>statement</code> 即可。</p>
<p>而当 <code>f3 := f1()</code> 重新赋值给 <code>f3</code> 时，在 <code>f2</code> 中累加的 <code>varInner</code> 变量将不会影响到 <code>f3</code>，这就得需要在给 <code>f3</code> 赋值的重新赋值一份闭包变量到  <code>f3</code> 中，这样便能达到互不影响的效果。</p>
<h2 id="闭包扫描"><a href="#闭包扫描" class="headerlink" title="闭包扫描"></a>闭包扫描</h2><p><code>GScript</code> 本身也是支持闭包的，所以把 Go 的代码翻译过来便长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">varExternal</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f1()&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">varInner</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">innerFun</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">		println(a);</span><br><span class="line">		<span class="type">int</span> c=<span class="number">100</span>;</span><br><span class="line">		varExternal++;</span><br><span class="line">		varInner++;</span><br><span class="line">		<span class="keyword">return</span> varInner;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> innerFun;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f2 = f1();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">	println(<span class="string">&quot;varInner=&quot;</span> + f2(i) + <span class="string">&quot;, varExternal=&quot;</span> + varExternal);</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;=======&quot;</span>);</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f3 = f1();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">	println(<span class="string">&quot;varInner=&quot;</span> + f3(i) + <span class="string">&quot;, varExternal=&quot;</span> + varExternal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">varInner=<span class="number">21</span>, varExternal=<span class="number">11</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">varInner=<span class="number">22</span>, varExternal=<span class="number">12</span></span><br><span class="line">=======</span><br><span class="line"><span class="number">0</span></span><br><span class="line">varInner=<span class="number">21</span>, varExternal=<span class="number">13</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">varInner=<span class="number">22</span>, varExternal=<span class="number">14</span></span><br></pre></td></tr></table></figure>

<p>可以看到运行结果和 Go 的一样，所以我们来看看 <code>GScript</code> 是如何实现的便也能理解 Go 的原理了。</p>
<hr>
<p>先来看看第一步扫描闭包变量：<br><img src="https://s2.loli.net/2023/01/14/uMxlDhkrs1g9zoT.png"></p>
<p><code>allVariable := c.allVariable(function)</code><br>查询所有的变量，包括父 <code>scope</code> 的变量。</p>
<p><code>scopeVariable := c.currentScopeVariable(function)</code><br>查询当前 <code>scope</code> 包含下级所有 <code>scope</code> 中的变量，这样一减之后就能知道闭包变量了，然后将所有的闭包变量存放进闭包函数中。</p>
<h2 id="闭包赋值"><a href="#闭包赋值" class="headerlink" title="闭包赋值"></a>闭包赋值</h2><p><img src="https://s2.loli.net/2023/01/14/tLBOHCpdwfYj7DX.png"><br>之后在 <code>return innerFun</code> 处，将闭包变量的数据赋值到变量中。</p>
<p><img src="https://s2.loli.net/2023/01/14/2jf6kYVHXBvbmNo.png"></p>
<h2 id="闭包函数调用"><a href="#闭包函数调用" class="headerlink" title="闭包函数调用"></a>闭包函数调用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f2 = f1();</span><br><span class="line"></span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f3 = f1();</span><br></pre></td></tr></table></figure>

<p>在这里每一次赋值时，都会把 <code>f1()</code> 返回函数复制到变量 <code>f2/f3</code> 中，这样两者所包含的闭包变量就不会互相影响。</p>
<hr>
<p><img src="https://s2.loli.net/2023/01/14/OmlVzJLASZpEP73.png"><br>在调用函数变量时，判断到该变量是一个函数，则直接返回函数。</p>
<p>之后直接调用该函数即可。</p>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>接下来便可以利用 <code>First class function</code> 来试试函数式编程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="type">int</span> value=<span class="number">0</span>;</span><br><span class="line">	Test(<span class="type">int</span> v)&#123;</span><br><span class="line">		value=v;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="title function_">map</span><span class="params">(func <span class="type">int</span>(<span class="type">int</span>)</span> f)&#123;</span><br><span class="line">		<span class="keyword">return</span> f(value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> v*v; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> v++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add2</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	v=v+<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> v; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span>Test(<span class="number">100</span>);</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> s= square;</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> a= add;</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> a2= add2;</span><br><span class="line">println(t.map(s));</span><br><span class="line">assertEqual(t.map(s),<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">println(t.map(a));</span><br><span class="line">assertEqual(t.map(a),<span class="number">101</span>);</span><br><span class="line"></span><br><span class="line">println(t.map(a2));</span><br><span class="line">assertEqual(t.map(a2),<span class="number">102</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个有点类似于 Java 中流的 map 函数，将函数作为值传递进去，后续支持匿名函数后会更像是函数式编程，现在必须得先定义一个函数变量再进行传递。</p>
<hr>
<p>除此之外在 <code>GScript</code> 中的 <code>http</code> 标准库也利用了函数是一等公民的特性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标准库：Bind route</span></span><br><span class="line">httpHandle(string method, string path, func (HttpContext) handle)&#123;</span><br><span class="line">    <span class="type">HttpContext</span> <span class="variable">ctx</span> <span class="operator">=</span> HttpContext();</span><br><span class="line">    handle(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在绑定路由时，<code>handle</code> 便是一个函数，使用的时候直接传递业务逻辑的 <code>handle</code> 即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">func (HttpContext) handle (HttpContext ctx)&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> Person();</span><br><span class="line">    p.name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    println(<span class="string">&quot;p.name=&quot;</span> + p.name);</span><br><span class="line">    println(<span class="string">&quot;ctx=&quot;</span> + ctx);</span><br><span class="line">    ctx.JSON(<span class="number">200</span>, p);</span><br><span class="line">&#125;</span><br><span class="line">httpHandle(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;/p&quot;</span>, handle);</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说闭包具有以下特性：</p>
<ul>
<li>函数需要作为一等公民。</li>
<li>编译期扫描出所有的闭包变量。</li>
<li>在返回闭包函数时，为闭包变量赋值。</li>
<li>每次创建新的函数变量时，需要将闭包数据复制进去，这样闭包变量才不会互相影响。</li>
<li>调用函数变量时，需要判断为函数，而不是变量。</li>
</ul>
<p><img src="https://s2.loli.net/2023/01/14/y2zhcrXgWJbODju.png"><br>可以在 <a href="https://gscript.crossoverjie.top/">Playground</a> 中体验闭包函数打印裴波那切数列的运用。</p>
<p>本文相关资源链接</p>
<ul>
<li><p>GScript 源码：<a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p>
</li>
<li><p>Playground 源码：<a href="https://github.com/crossoverJie/gscript-homepage">https://github.com/crossoverJie/gscript-homepage</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>gscript</category>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>闭包</tag>
        <tag>closure</tag>
      </tags>
  </entry>
  <entry>
    <title>如何判断一个元素在亿级数据中是否存在？</title>
    <url>/2018/11/26/guava/guava-bloom-filter/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1c60f09a00.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近有朋友问我这么一个面试题目：</p>
<blockquote>
<p>现在有一个非常庞大的数据，假设全是 int 类型。现在我给你一个数，你需要告诉我它是否存在其中(尽量高效)。</p>
</blockquote>
<p>需求其实很清晰，只是要判断一个数据是否存在即可。</p>
<p>但这里有一个比较重要的前提：<strong>非常庞大的数据</strong>。</p>
<span id="more"></span>

<h1 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h1><p>先不考虑这个条件，我们脑海中出现的第一种方案是什么？</p>
<p>我想大多数想到的都是用 <code>HashMap</code> 来存放数据，因为它的写入查询的效率都比较高。</p>
<p>写入和判断元素是否存在都有对应的 <code>API</code>，所以实现起来也比较简单。</p>
<p>为此我写了一个单测，利用 <code>HashSet</code> 来存数据（底层也是 <code>HashMap</code> ）；同时为了后面的对比将堆内存写死：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms64m -Xmx64m -XX:+PrintHeapAtGC -XX:+HeapDumpOnOutOfMemoryError </span><br></pre></td></tr></table></figure>

<p>为了方便调试加入了 <code>GC</code> 日志的打印，以及内存溢出后 <code>Dump</code> 内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hashMapTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">star</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; hashset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">100</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        hashset.add(i) ;</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.assertTrue(hashset.contains(<span class="number">1</span>));</span><br><span class="line">    Assert.assertTrue(hashset.contains(<span class="number">2</span>));</span><br><span class="line">    Assert.assertTrue(hashset.contains(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行时间：&quot;</span> + (end - star));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我只写入 100 条数据时自然是没有问题的。</p>
<p>还是在这个基础上，写入 1000W 数据试试：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6103f765.jpg"></p>
<p>执行后马上就内存溢出。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c61188141.jpg"></p>
<p>可见在内存有限的情况下我们不能使用这种方式。</p>
<p>实际情况也是如此；既然要判断一个数据是否存在于集合中，考虑的算法的效率以及准确性肯定是要把数据全部 <code>load</code> 到内存中的。</p>
<h1 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h1><p>基于上面分析的条件，要实现这个需求最需要解决的是<code>如何将庞大的数据 load 到内存中。</code></p>
<p>而我们是否可以换种思路，因为只是需要判断数据是否存在，也不是需要把数据查询出来，所以完全没有必要将真正的数据存放进去。</p>
<p>伟大的科学家们已经帮我们想到了这样的需求。</p>
<p><code>Burton Howard Bloom</code> 在 1970 年提出了一个叫做 <code>Bloom Filter</code>（中文翻译：布隆过滤）的算法。</p>
<p>它主要就是用于解决判断一个元素是否在一个集合中，但它的优势是只需要占用很小的内存空间以及有着高效的查询效率。</p>
<p>所以在这个场景下在合适不过了。</p>
<h2 id="Bloom-Filter-原理"><a href="#Bloom-Filter-原理" class="headerlink" title="Bloom Filter 原理"></a>Bloom Filter 原理</h2><p>下面来分析下它的实现原理。</p>
<blockquote>
<p>官方的说法是：它是一个保存了很长的二级制向量，同时结合 Hash 函数实现的。</p>
</blockquote>
<p>听起来比较绕，但是通过一个图就比较容易理解了。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c612648cb.jpg"></p>
<p>如图所示：</p>
<ul>
<li>首先需要初始化一个二进制的数组，长度设为 L（图中为 8），同时初始值全为 0 。</li>
<li>当写入一个 <code>A1=1000</code> 的数据时，需要进行 H 次 <code>hash</code> 函数的运算（这里为 2 次）；与 HashMap 有点类似，通过算出的 <code>HashCode</code> 与 L 取模后定位到 0、2 处，将该处的值设为 1。</li>
<li><code>A2=2000</code> 也是同理计算后将 <code>4、7</code> 位置设为 1。</li>
<li>当有一个 <code>B1=1000</code> 需要判断是否存在时，也是做两次 Hash 运算，定位到 0、2 处，此时他们的值都为 1 ，所以认为 <code>B1=1000</code> 存在于集合中。</li>
<li>当有一个 <code>B2=3000</code> 时，也是同理。第一次 Hash 定位到 <code>index=4</code> 时，数组中的值为 1，所以再进行第二次 Hash 运算，结果定位到 <code>index=5</code> 的值为 0，所以认为 <code>B2=3000</code> 不存在于集合中。</li>
</ul>
<p>整个的写入、查询的流程就是这样，汇总起来就是：</p>
<blockquote>
<p>对写入的数据做 H 次 hash 运算定位到数组中的位置，同时将数据改为 1 。当有数据查询时也是同样的方式定位到数组中。<br>一旦其中的有一位为 <strong>0</strong> 则认为数据<strong>肯定不存在于集合</strong>，否则数据<strong>可能存在于集合中</strong>。</p>
</blockquote>
<p>所以布隆过滤有以下几个特点：</p>
<ol>
<li>只要返回数据不存在，则肯定不存在。</li>
<li>返回数据存在，但只能是大概率存在。</li>
<li>同时不能清除其中的数据。</li>
</ol>
<p>第一点应该都能理解，重点解释下 2、3 点。</p>
<p>为什么返回存在的数据却是可能存在呢，这其实也和 <code>HashMap</code> 类似。</p>
<p>在有限的数组长度中存放大量的数据，即便是再完美的 Hash 算法也会有冲突，所以有可能两个完全不同的 <code>A、B</code> 两个数据最后定位到的位置是一模一样的。</p>
<p>这时拿 B 进行查询时那自然就是误报了。</p>
<p>删除数据也是同理，当我把 B 的数据删除时，其实也相当于是把 A 的数据删掉了，这样也会造成后续的误报。</p>
<p>基于以上的 <code>Hash</code> 冲突的前提，所以 <code>Bloom Filter</code> 有一定的误报率，这个误报率和 <code>Hash</code> 算法的次数 H，以及数组长度 L 都是有关的。</p>
<h1 id="自己实现一个布隆过滤"><a href="#自己实现一个布隆过滤" class="headerlink" title="自己实现一个布隆过滤"></a>自己实现一个布隆过滤</h1><p>算法其实很简单不难理解，于是利用 <code>Java</code> 实现了一个简单的雏形。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilters</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> arraySize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BloomFilters</span><span class="params">(<span class="type">int</span> arraySize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arraySize = arraySize;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">int</span>[arraySize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> hashcode_1(key);</span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> hashcode_2(key);</span><br><span class="line">        <span class="type">int</span> <span class="variable">third</span> <span class="operator">=</span> hashcode_3(key);</span><br><span class="line"></span><br><span class="line">        array[first % arraySize] = <span class="number">1</span>;</span><br><span class="line">        array[second % arraySize] = <span class="number">1</span>;</span><br><span class="line">        array[third % arraySize] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断数据是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> hashcode_1(key);</span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> hashcode_2(key);</span><br><span class="line">        <span class="type">int</span> <span class="variable">third</span> <span class="operator">=</span> hashcode_3(key);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">firstIndex</span> <span class="operator">=</span> array[first % arraySize];</span><br><span class="line">        <span class="keyword">if</span> (firstIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">secondIndex</span> <span class="operator">=</span> array[second % arraySize];</span><br><span class="line">        <span class="keyword">if</span> (secondIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">thirdIndex</span> <span class="operator">=</span> array[third % arraySize];</span><br><span class="line">        <span class="keyword">if</span> (thirdIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash 算法1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashcode_1</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; key.length(); ++i) &#123;</span><br><span class="line">            hash = <span class="number">33</span> * hash + key.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(hash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash 算法2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashcode_2</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">16777619</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">2166136261L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length(); i++) &#123;</span><br><span class="line">            hash = (hash ^ data.charAt(i)) * p;</span><br><span class="line">        &#125;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">17</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(hash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  hash 算法3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashcode_3</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> hash, i;</span><br><span class="line">        <span class="keyword">for</span> (hash = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; key.length(); ++i) &#123;</span><br><span class="line">            hash += key.charAt(i);</span><br><span class="line">            hash += (hash &lt;&lt; <span class="number">10</span>);</span><br><span class="line">            hash ^= (hash &gt;&gt; <span class="number">6</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hash += (hash &lt;&lt; <span class="number">3</span>);</span><br><span class="line">        hash ^= (hash &gt;&gt; <span class="number">11</span>);</span><br><span class="line">        hash += (hash &lt;&lt; <span class="number">15</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.abs(hash);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先初始化了一个 int 数组。</li>
<li>写入数据的时候进行三次 <code>hash</code> 运算，同时把对应的位置置为 1。</li>
<li>查询时同样的三次 <code>hash</code> 运算，取到对应的值，一旦值为 0 ，则认为数据不存在。</li>
</ol>
<p>实现逻辑其实就和上文描述的一样。</p>
<p>下面来测试一下，同样的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms64m -Xmx64m -XX:+PrintHeapAtGC</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bloomFilterTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">star</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">BloomFilters</span> <span class="variable">bloomFilters</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BloomFilters</span>(<span class="number">10000000</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        bloomFilters.add(i + <span class="string">&quot;&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.assertTrue(bloomFilters.check(<span class="number">1</span>+<span class="string">&quot;&quot;</span>));</span><br><span class="line">    Assert.assertTrue(bloomFilters.check(<span class="number">2</span>+<span class="string">&quot;&quot;</span>));</span><br><span class="line">    Assert.assertTrue(bloomFilters.check(<span class="number">3</span>+<span class="string">&quot;&quot;</span>));</span><br><span class="line">    Assert.assertTrue(bloomFilters.check(<span class="number">999999</span>+<span class="string">&quot;&quot;</span>));</span><br><span class="line">    Assert.assertFalse(bloomFilters.check(<span class="number">400230340</span>+<span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行时间：&quot;</span> + (end - star));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c613ebab4.jpg"></p>
<p>只花了 3 秒钟就写入了 1000W 的数据同时做出来准确的判断。</p>
<hr>
<p><img src="https://i.loli.net/2019/05/08/5cd1c61b6299a.jpg"></p>
<p>当让我把数组长度缩小到了 100W 时就出现了一个误报，<code>400230340</code> 这个数明明没在集合里，却返回了存在。</p>
<p>这也体现了 <code>Bloom Filter</code> 的误报率。</p>
<p>我们提高数组长度以及 <code>hash</code> 计算次数可以降低误报率，但相应的 <code>CPU、内存</code>的消耗就会提高；这就需要根据业务需要自行权衡。</p>
<h1 id="Guava-实现"><a href="#Guava-实现" class="headerlink" title="Guava 实现"></a>Guava 实现</h1><p><img src="https://i.loli.net/2019/05/08/5cd1c61fbb3a9.jpg"></p>
<p>刚才的方式虽然实现了功能，也满足了大量数据。但其实观察 <code>GC</code> 日志非常频繁，同时老年代也使用了 90%，接近崩溃的边缘。</p>
<p>总的来说就是内存利用率做的不好。</p>
<p>其实 Google Guava 库中也实现了该算法，下面来看看业界权威的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms64m -Xmx64m -XX:+PrintHeapAtGC </span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">guavaTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">star</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    BloomFilter&lt;Integer&gt; filter = BloomFilter.create(</span><br><span class="line">            Funnels.integerFunnel(),</span><br><span class="line">            <span class="number">10000000</span>,</span><br><span class="line">            <span class="number">0.01</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        filter.put(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Assert.assertTrue(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">    Assert.assertTrue(filter.mightContain(<span class="number">2</span>));</span><br><span class="line">    Assert.assertTrue(filter.mightContain(<span class="number">3</span>));</span><br><span class="line">    Assert.assertFalse(filter.mightContain(<span class="number">10000000</span>));</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行时间：&quot;</span> + (end - star));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>也是同样写入了 1000W 的数据，执行没有问题。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c622018c7.jpg"></p>
<p>观察 GC 日志会发现没有一次 <code>fullGC</code>，同时老年代的使用率很低。和刚才的一对比这里明显的要好上很多，也可以写入更多的数据。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>那就来看看 <code>Guava</code> 它是如何实现的。</p>
<p>构造方法中有两个比较重要的参数，一个是预计存放多少数据，一个是可以接受的误报率。<br>我这里的测试 demo 分别是 1000W 以及 0.01。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c62939dfe.jpg"></p>
<p><code>Guava</code> 会通过你预计的数量以及误报率帮你计算出你应当会使用的数组大小 <code>numBits</code> 以及需要计算几次 Hash 函数 <code>numHashFunctions</code> 。</p>
<p>这个算法计算规则可以参考维基百科。</p>
<h3 id="put-写入函数"><a href="#put-写入函数" class="headerlink" title="put 写入函数"></a>put 写入函数</h3><p>真正存放数据的 <code>put</code> 函数如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c62cc9f87.jpg"></p>
<ul>
<li>根据 <code>murmur3_128</code> 方法的到一个 128 位长度的 <code>byte[]</code>。</li>
<li>分别取高低 8 位的到两个 <code>hash</code> 值。</li>
<li>再根据初始化时的到的执行 <code>hash</code> 的次数进行 <code>hash</code> 运算。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bitsChanged |= bits.set((combinedHash &amp; Long.MAX_VALUE) % bitSize);</span><br></pre></td></tr></table></figure>

<p>其实也是 <code>hash取模</code>拿到 <code>index</code> 后去赋值 1.</p>
<p>重点是 <code>bits.set()</code> 方法。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c63425e23.jpg"></p>
<p>其实 set 方法是 <code>BitArray</code> 中的一个函数，<code>BitArray</code> 就是真正存放数据的底层数据结构。</p>
<p>利用了一个 <code>long[] data</code> 来存放数据。</p>
<p>所以 <code>set()</code> 时候也是对这个 <code>data</code> 做处理。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6370a2ea.jpg"></p>
<ul>
<li>在 <code>set</code> 之前先通过 <code>get()</code> 判断这个数据是否存在于集合中，如果已经存在则直接返回告知客户端写入失败。</li>
<li>接下来就是通过位运算进行<code>位或赋值</code>。</li>
<li><code>get()</code> 方法的计算逻辑和 set 类似，只要判断为 0 就直接返回存在该值。</li>
</ul>
<h3 id="mightContain-是否存在函数"><a href="#mightContain-是否存在函数" class="headerlink" title="mightContain 是否存在函数"></a>mightContain 是否存在函数</h3><p><img src="https://i.loli.net/2019/05/08/5cd1c63b199b4.jpg"></p>
<p>前面几步的逻辑都是类似的，只是调用了刚才的 <code>get()</code> 方法判断元素是否存在而已。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>布隆过滤的应用还是蛮多的，比如数据库、爬虫、防缓存击穿等。</p>
<p>特别是需要精确知道某个数据不存在时做点什么事情就非常适合布隆过滤。</p>
<p>这段时间的研究发现算法也挺有意思的，后续应该会继续分享一些类似的内容。</p>
<p>如果对你有帮助那就分享一下吧。</p>
<p>本问的示例代码参考这里：</p>
<p><a href="https://github.com/crossoverJie/JCSprout/blob/master/src/test/java/com/crossoverjie/algorithm/BloomFiltersTest.java">https://github.com/crossoverJie/JCSprout</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Bloom Filter</tag>
        <tag>算法</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava 源码分析（Cache 原理【二阶段】）</title>
    <url>/2018/07/16/guava/guava-cache-2/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d2da38c8f.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上文「<a href="https://crossoverjie.top/2018/06/13/guava/guava-cache/">Guava 源码分析（Cache 原理）</a>」中分析了 <code>Guava Cache</code> 的相关原理。</p>
<p>文末提到了<strong>回收机制、移除时间通知</strong>等内容，许多朋友也挺感兴趣，这次就这两个内容再来分析分析。</p>
<blockquote>
<p>在开始之前先补习下 Java 自带的两个特性，Guava 中都有具体的应用。</p>
</blockquote>
<h2 id="Java-中的引用"><a href="#Java-中的引用" class="headerlink" title="Java 中的引用"></a>Java 中的引用</h2><p>首先是 Java 中的<strong>引用</strong>。</p>
<p>在之前分享过 JVM 是根据<a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/GarbageCollection.md#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95">可达性分析算法</a>找出需要回收的对象，判断对象的存活状态都和<code>引用</code>有关。</p>
<p>在 JDK1.2 之前这点设计的非常简单：一个对象的状态只有<strong>引用</strong>和<strong>没被引用</strong>两种区别。</p>
<span id="more"></span>

<p>这样的划分对垃圾回收不是很友好，因为总有一些对象的状态处于这两之间。</p>
<p>因此 1.2 之后新增了四种状态用于更细粒度的划分引用关系：</p>
<ul>
<li>强引用（Strong Reference）:这种对象最为常见，比如 **<code>A a = new A();</code>**这就是典型的强引用；这样的强引用关系是不能被垃圾回收的。</li>
<li>软引用（Soft Reference）:这样的引用表明一些有用但不是必要的对象，在将发生垃圾回收之前是需要将这样的对象再次回收。</li>
<li>弱引用（Weak Reference）:这是一种比软引用还弱的引用关系，也是存放非必须的对象。当垃圾回收时，无论当前内存是否足够，这样的对象都会被回收。</li>
<li>虚引用（Phantom Reference）:这是一种最弱的引用关系，甚至没法通过引用来获取对象，它唯一的作用就是在被回收时可以获得通知。</li>
</ul>
<h2 id="事件回调"><a href="#事件回调" class="headerlink" title="事件回调"></a>事件回调</h2><p>事件回调其实是一种常见的设计模式，比如之前讲过的 <a href="https://crossoverjie.top/categories/Netty/">Netty</a> 就使用了这样的设计。</p>
<p>这里采用一个 demo，试下如下功能：</p>
<ul>
<li>Caller 向 Notifier 提问。</li>
<li>提问方式是异步，接着做其他事情。</li>
<li>Notifier 收到问题执行计算然后回调 Caller 告知结果。</li>
</ul>
<p>在 Java 中利用接口来实现回调，所以需要定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CallBackListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回调通知函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">callBackNotify</span><span class="params">(String msg)</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Caller 中调用 Notifier 执行提问，调用时将接口传递过去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(Caller.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CallBackListener callBackListener ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Notifier notifier ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String question ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;开始提问&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//新建线程，达到异步效果 </span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    notifier.execute(Caller.<span class="built_in">this</span>,question);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;提问完毕，我去干其他事了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//隐藏 getter/setter</span></span><br><span class="line">    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>Notifier 收到提问，执行计算（耗时操作），最后做出响应（回调接口，告诉 Caller 结果）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notifier</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(Notifier.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Caller caller, String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;收到消息=【&#123;&#125;】&quot;</span>, msg);</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;等待响应中。。。。。&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        caller.getCallBackListener().callBackNotify(<span class="string">&quot;我在北京！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>模拟执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Notifier</span> <span class="variable">notifier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notifier</span>() ;</span><br><span class="line"></span><br><span class="line">    <span class="type">Caller</span> <span class="variable">caller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caller</span>() ;</span><br><span class="line">    caller.setNotifier(notifier) ;</span><br><span class="line">    caller.setQuestion(<span class="string">&quot;你在哪儿！&quot;</span>);</span><br><span class="line">    caller.setCallBackListener(<span class="keyword">new</span> <span class="title class_">CallBackListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callBackNotify</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;回复=【&#123;&#125;】&quot;</span> ,msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    caller.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-07-15 19:52:11.105 [main] INFO  c.crossoverjie.guava.callback.Caller - 开始提问</span><br><span class="line">2018-07-15 19:52:11.118 [main] INFO  c.crossoverjie.guava.callback.Caller - 提问完毕，我去干其他事了</span><br><span class="line">2018-07-15 19:52:11.117 [Thread-0] INFO  c.c.guava.callback.Notifier - 收到消息=【你在哪儿！】</span><br><span class="line">2018-07-15 19:52:11.121 [Thread-0] INFO  c.c.guava.callback.Notifier - 等待响应中。。。。。</span><br><span class="line">2018-07-15 19:52:13.124 [Thread-0] INFO  com.crossoverjie.guava.callback.Main - 回复=【我在北京！】</span><br></pre></td></tr></table></figure>

<p>这样一个模拟的异步事件回调就完成了。</p>
<h2 id="Guava-的用法"><a href="#Guava-的用法" class="headerlink" title="Guava 的用法"></a>Guava 的用法</h2><p>Guava 就是利用了上文的两个特性来实现了<strong>引用回收</strong>及<strong>移除通知</strong>。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>可以在初始化缓存时利用：</p>
<ul>
<li>CacheBuilder.weakKeys()</li>
<li>CacheBuilder.weakValues()</li>
<li>CacheBuilder.softValues()</li>
</ul>
<p>来自定义键和值的引用关系。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2e161dd6.jpg"></p>
<p>在上文的分析中可以看出 Cache 中的 <code>ReferenceEntry</code> 是类似于 HashMap 的 Entry 存放数据的。</p>
<p>来看看 ReferenceEntry 的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">interface</span> <span class="title class_">ReferenceEntry</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value reference from this entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ValueReference&lt;K, V&gt; <span class="title function_">getValueReference</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the value reference for this entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setValueReference</span><span class="params">(ValueReference&lt;K, V&gt; valueReference)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next entry in the chain.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    ReferenceEntry&lt;K, V&gt; <span class="title function_">getNext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the entry&#x27;s hash.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getHash</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the key for this entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    K <span class="title function_">getKey</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Used by entries that use access order. Access entries are maintained in a doubly-linked list.</span></span><br><span class="line"><span class="comment">     * New entries are added at the tail of the list at write time; stale entries are expired from</span></span><br><span class="line"><span class="comment">     * the head of the list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the time that this entry was last accessed, in ns.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getAccessTime</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the entry access time in ns.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAccessTime</span><span class="params">(<span class="type">long</span> time)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包含了很多常用的操作，如值引用、键引用、访问时间等。</p>
<p>根据 <code>ValueReference&lt;K, V&gt; getValueReference();</code> 的实现：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2e34ee46.jpg"></p>
<p>具有强引用和弱引用的不同实现。</p>
<p>key 也是相同的道理：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2e4ec5ff.jpg"></p>
<p>当使用这样的构造方式时，弱引用的 key 和 value 都会被垃圾回收。</p>
<p>当然我们也可以显式的回收：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Discards any cached value for key &#123;@code key&#125;.</span><br><span class="line"> * 单个回收</span><br><span class="line"> */</span><br><span class="line">void invalidate(Object key);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Discards any cached values for keys &#123;@code keys&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @since 11.0</span><br><span class="line"> */</span><br><span class="line">void invalidateAll(Iterable&lt;?&gt; keys);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Discards all entries in the cache.</span><br><span class="line"> */</span><br><span class="line">void invalidateAll();</span><br></pre></td></tr></table></figure>

<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>改造了之前的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">loadingCache = CacheBuilder.newBuilder()</span><br><span class="line">        .expireAfterWrite(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">        .removalListener(<span class="keyword">new</span> <span class="title class_">RemovalListener</span>&lt;Object, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRemoval</span><span class="params">(RemovalNotification&lt;Object, Object&gt; notification)</span> &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;删除原因=&#123;&#125;，删除 key=&#123;&#125;,删除 value=&#123;&#125;&quot;</span>,notification.getCause(),notification.getKey(),notification.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;Integer, AtomicLong&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> AtomicLong <span class="title function_">load</span><span class="params">(Integer key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-07-15 20:41:07.433 [main] INFO  c.crossoverjie.guava.CacheLoaderTest - 当前缓存值=0,缓存大小=1</span><br><span class="line">2018-07-15 20:41:07.442 [main] INFO  c.crossoverjie.guava.CacheLoaderTest - 缓存的所有内容=&#123;1000=0&#125;</span><br><span class="line">2018-07-15 20:41:07.443 [main] INFO  c.crossoverjie.guava.CacheLoaderTest - job running times=10</span><br><span class="line">2018-07-15 20:41:10.461 [main] INFO  c.crossoverjie.guava.CacheLoaderTest - 删除原因=EXPIRED，删除 key=1000,删除 value=1</span><br><span class="line">2018-07-15 20:41:10.462 [main] INFO  c.crossoverjie.guava.CacheLoaderTest - 当前缓存值=0,缓存大小=1</span><br><span class="line">2018-07-15 20:41:10.462 [main] INFO  c.crossoverjie.guava.CacheLoaderTest - 缓存的所有内容=&#123;1000=0&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出当缓存被删除的时候会回调我们自定义的函数，并告知删除原因。</p>
<p>那么 Guava 是如何实现的呢？</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2e5d3a34.jpg"></p>
<p>根据 LocalCache 中的 <code>getLiveValue()</code> 中判断缓存过期时，跟着这里的调用关系就会一直跟到：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2e71f98f.jpg"></p>
<p><code>removeValueFromChain()</code> 中的：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2e809482.jpg"></p>
<p><code>enqueueNotification()</code> 方法会将回收的缓存（包含了 key，value）以及回收原因包装成之前定义的事件接口加入到一个<strong>本地队列</strong>中。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2e8e1800.jpg"></p>
<p>这样一看也没有回调我们初始化时候的事件啊。</p>
<p>不过用过队列的同学应该能猜出，既然这里写入队列，那就肯定就有消费。</p>
<p>我们回到获取缓存的地方：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2eba7159.jpg"></p>
<p>在 finally 中执行了 <code>postReadCleanup()</code> 方法；其实在这里面就是对刚才的队列进行了消费：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2f1e162f.jpg"></p>
<p>一直跟进来就会发现这里消费了队列，将之前包装好的移除消息调用了我们自定义的事件，这样就完成了一次事件回调。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上所有源码：</p>
<p><a href="https://github.com/crossoverJie/Java-Interview/blob/master/src/main/java/com/crossoverjie/guava/callback/Main.java">https://github.com/crossoverJie/Java-Interview/blob/master/src/main/java/com/crossoverjie/guava/callback/Main.java</a></p>
<p>通过分析 Guava 的源码可以让我们学习到顶级的设计及实现方式，甚至自己也能尝试编写。</p>
<p>Guava 里还有很多强大的增强实现，值得我们再好好研究。</p>
<h2 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h2><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
<p><strong>欢迎关注公众号一起交流：</strong></p>
]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava 源码分析（Cache 原理）</title>
    <url>/2018/06/13/guava/guava-cache/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/06/12/5b1fea79e07cb.jpeg" alt="1.jpeg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Google 出的 <a href="https://github.com/google/guava">Guava</a> 是 Java 核心增强的库，应用非常广泛。</p>
<p>我平时用的也挺频繁，这次就借助日常使用的 Cache 组件来看看 Google 大牛们是如何设计的。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><blockquote>
<p>本次主要讨论缓存。</p>
</blockquote>
<p>缓存在日常开发中举足轻重，如果你的应用对某类数据有着较高的读取频次，并且改动较小时那就非常适合利用缓存来提高性能。</p>
<p>缓存之所以可以提高性能是因为它的读取效率很高，就像是 CPU 的 <code>L1、L2、L3</code> 缓存一样，级别越高相应的读取速度也会越快。</p>
<p>但也不是什么好处都占，读取速度快了但是它的内存更小资源更宝贵，所以我们应当缓存真正需要的数据。</p>
<blockquote>
<p>其实也就是典型的空间换时间。</p>
</blockquote>
<p>下面谈谈 Java 中所用到的缓存。</p>
<span id="more"></span>

<h3 id="JVM-缓存"><a href="#JVM-缓存" class="headerlink" title="JVM 缓存"></a>JVM 缓存</h3><p>首先是 JVM 缓存，也可以认为是堆缓存。</p>
<p>其实就是创建一些全局变量，如 <code>Map、List</code> 之类的容器用于存放数据。</p>
<p>这样的优势是使用简单但是也有以下问题：</p>
<ul>
<li>只能显式的写入，清除数据。</li>
<li>不能按照一定的规则淘汰数据，如 <code>LRU，LFU，FIFO</code> 等。</li>
<li>清除数据时的回调通知。</li>
<li>其他一些定制功能等。</li>
</ul>
<h3 id="Ehcache、Guava-Cache"><a href="#Ehcache、Guava-Cache" class="headerlink" title="Ehcache、Guava Cache"></a>Ehcache、Guava Cache</h3><p>所以出现了一些专门用作 JVM 缓存的开源工具出现了，如本文提到的 Guava Cache。</p>
<p>它具有上文 JVM 缓存不具有的功能，如自动清除数据、多种清除算法、清除回调等。</p>
<p>但也正因为有了这些功能，这样的缓存必然会多出许多东西需要额外维护，自然也就增加了系统的消耗。</p>
<h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>刚才提到的两种缓存其实都是堆内缓存，只能在单个节点中使用，这样在分布式场景下就招架不住了。</p>
<p>于是也有了一些缓存中间件，如 Redis、Memcached，在分布式环境下可以共享内存。</p>
<p>具体不在本次的讨论范围。</p>
<h2 id="Guava-Cache-示例"><a href="#Guava-Cache-示例" class="headerlink" title="Guava Cache 示例"></a>Guava Cache 示例</h2><p>之所以想到 Guava 的 Cache，也是最近在做一个需求，大体如下：</p>
<blockquote>
<p>从 Kafka 实时读取出应用系统的日志信息，该日志信息包含了应用的健康状况。<br>如果在时间窗口 N 内发生了 X 次异常信息，相应的我就需要作出反馈（报警、记录日志等）。</p>
</blockquote>
<p>对此 Guava 的 Cache 就非常适合，我利用了它的 N 个时间内不写入数据时缓存就清空的特点，在每次读取数据时判断异常信息是否大于 X 即可。</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;alert.in.time:2&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> time ;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LoadingCache <span class="title function_">buildCache</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CacheBuilder.newBuilder()</span><br><span class="line">            .expireAfterWrite(time, TimeUnit.MINUTES)</span><br><span class="line">            .build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;Long, AtomicLong&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> AtomicLong <span class="title function_">load</span><span class="params">(Long key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否需要报警</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAlert</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (counter.get(KEY).incrementAndGet() &gt;= limit) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;***********报警***********&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将缓存清空</span></span><br><span class="line">            counter.get(KEY).getAndSet(<span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">&quot;Exception&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>首先是构建了 LoadingCache 对象，在 N 分钟内不写入数据时就回收缓存（当通过 Key 获取不到缓存时，默认返回 0）。</p>
<p>然后在每次消费时候调用 <code>checkAlert()</code> 方法进行校验，这样就可以达到上文的需求。</p>
<p>我们来设想下 Guava 它是如何实现过期自动清除数据，并且是可以按照 LRU 这样的方式清除的。</p>
<p>大胆假设下：</p>
<blockquote>
<p>内部通过一个队列来维护缓存的顺序，每次访问过的数据移动到队列头部，并且额外开启一个线程来判断数据是否过期，过期就删掉。有点类似于我之前写过的 <a href="https://crossoverjie.top/%2F2018%2F04%2F07%2Falgorithm%2FLRU-cache%2F">动手实现一个 LRU cache</a></p>
</blockquote>
<p>胡适说过：大胆假设小心论证</p>
<p>下面来看看 Guava 到底是怎么实现。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>看原理最好不过是跟代码一步步走了：</p>
<p>示例代码在这里：</p>
<p><a href="https://github.com/crossoverJie/Java-Interview/blob/master/src/main/java/com/crossoverjie/guava/CacheLoaderTest.java">https://github.com/crossoverJie/Java-Interview/blob/master/src/main/java/com/crossoverjie/guava/CacheLoaderTest.java</a></p>
<p><img src="https://i.loli.net/2018/06/13/5b2008f4c1003.png" alt="8.png"></p>
<p>为了能看出 Guava 是怎么删除过期数据的在获取缓存之前休眠了 5 秒钟，达到了超时条件。</p>
<p><img src="https://i.loli.net/2018/06/13/5b1ffe4eebae0.png" alt="2.png"></p>
<p>最终会发现在 <code>com.google.common.cache.LocalCache</code> 类的 2187 行比较关键。</p>
<p>再跟进去之前第 2182 行会发现先要判断 count 是否大于 0，这个 count 保存的是当前缓存的数量，并用 volatile 修饰保证了可见性。</p>
<blockquote>
<p>更多关于 volatile 的相关信息可以查看 <a href="https://crossoverjie.top/%2F2018%2F03%2F09%2Fvolatile%2F">你应该知道的 volatile 关键字</a></p>
</blockquote>
<p>接着往下跟到：</p>
<p><img src="https://i.loli.net/2018/06/13/5b1fffc88c3e6.png" alt="3.png"></p>
<p>2761 行，根据方法名称可以看出是判断当前的 Entry 是否过期，该 entry 就是通过 key 查询到的。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2f2b95ed.jpg"></p>
<p>这里就很明显的看出是根据根据构建时指定的过期方式来判断当前 key 是否过期了。</p>
<p><img src="https://i.loli.net/2018/06/13/5b20017f32ff0.png" alt="5.png"></p>
<p>如果过期就往下走，尝试进行过期删除（需要加锁，后面会具体讨论）。</p>
<p><img src="https://i.loli.net/2018/06/13/5b2001eeb40d5.png" alt="6.png"></p>
<p>到了这里也很清晰了：</p>
<ul>
<li>获取当前缓存的总数量</li>
<li>自减一（前面获取了锁，所以线程安全）</li>
<li>删除并将更新的总数赋值到 count。</li>
</ul>
<p>其实大体上就是这个流程，Guava 并没有按照之前猜想的另起一个线程来维护过期数据。</p>
<p>应该是以下原因：</p>
<ul>
<li>新起线程需要资源消耗。</li>
<li>维护过期数据还要获取额外的锁，增加了消耗。</li>
</ul>
<p>而在查询时候顺带做了这些事情，但是如果该缓存迟迟没有访问也会存在数据不能被回收的情况，不过这对于一个高吞吐的应用来说也不是问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后再来总结下 Guava 的 Cache。</p>
<p>其实在上文跟代码时会发现通过一个 key 定位数据时有以下代码：</p>
<p><img src="https://i.loli.net/2018/06/13/5b20040d257cb.png" alt="7.png"></p>
<p>如果有看过 <a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/ConcurrentHashMap.md">ConcurrentHashMap 的原理</a> 应该会想到这其实非常类似。</p>
<p>其实 Guava Cache 为了满足并发场景的使用，核心的数据结构就是按照 ConcurrentHashMap 来的，这里也是一个 key 定位到一个具体位置的过程。</p>
<blockquote>
<p>先找到 Segment，再找具体的位置，等于是做了两次 Hash 定位。</p>
</blockquote>
<p>上文有一个假设是对的，它内部会维护两个队列 <code>accessQueue,writeQueue</code> 用于记录缓存顺序，这样才可以按照顺序淘汰数据（类似于利用 LinkedHashMap 来做 LRU 缓存）。</p>
<p>同时从上文的构建方式来看，它也是<a href="https://crossoverjie.top/2018/04/28/sbc/sbc7-Distributed-Limit/">构建者模式</a>来创建对象的。</p>
<p>因为作为一个给开发者使用的工具，需要有很多的自定义属性，利用构建则模式再合适不过了。</p>
<p>Guava 其实还有很多东西没谈到，比如它利用 GC 来回收内存，移除数据时的回调通知等。之后再接着讨论。</p>
<p>扫码关注微信公众号，第一时间获取消息。</p>
]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Istio 升级后踩的坑</title>
    <url>/2023/02/20/istio/istio1.12-upgrade-fix/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/02/19/FwgABGdDrhR4a3j.png"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间我们将 istio 版本升级到 1.12 后导致现有的应用监控有部分数据丢失（页面上显示不出来）。</p>
<ul>
<li>一个是应用基础信息丢失。</li>
<li>再一个是应用 JVM 数据丢失。</li>
<li>接口维度的监控数据丢失。</li>
</ul>
<span id="more"></span>
<p><img src="https://s2.loli.net/2023/02/19/6eSAIF1Jcjhrp4x.png"></p>
<hr>
<p><img src="https://s2.loli.net/2023/02/19/Lyr4cSxVmutjJU6.png"></p>
<hr>
<p><img src="https://s2.loli.net/2023/02/19/aPzD9t7L1mGqiJR.png"></p>
<hr>
<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p>首先是第一个基础信息丢失的问题，页面上其实显示的是我们的一个聚合指标<code>istio_requests_total:source:rate1m</code>。</p>
<blockquote>
<p>聚合后可以将多个指标合并为一个，减少系统压力</p>
</blockquote>
<p>具体可以参考 Istio 的最佳实践 <a href="https://istio.io/latest/docs/ops/best-practices/observability/#workload-level-aggregation-via-recording-rules">Observability Best Practices</a> 有详细说明。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">groups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">istio.service.source.istio_requests_total</span></span><br><span class="line">      <span class="attr">rules:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">expr:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            sum(irate(istio_requests_total&#123;reporter=&quot;source&quot;&#125;[1m]))</span></span><br><span class="line"><span class="string">            by (</span></span><br><span class="line"><span class="string">              destination_app,</span></span><br><span class="line"><span class="string">              source_workload_namespace,</span></span><br><span class="line"><span class="string">              response_code,</span></span><br><span class="line"><span class="string">              source_app</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string"></span>          <span class="attr">record:</span> <span class="string">istio_requests_total:source:rate1m</span></span><br></pre></td></tr></table></figure>

<p>本质上是通过以上四个维度进行统计 <code>istio_requests_total</code>；但在升级之后查看原始数据发现丢失了 <code>destination_app, source_app</code> 这两个 tag。</p>
<p>至于为啥丢失，查了许久，最后在升级后的资源文件 <code>stats-filter-1.12.yaml</code> 中找到了答案:<br><img src="https://s2.loli.net/2023/02/19/B7a6sH9CYznVGUI.png"><br>升级后新增了 <code>tags_to_remove</code> 标记，将我们所需要的两个 tag 直接删掉了。</p>
<p>后续在当前 namespace 下重新建一个 <code>EnvoyFilter</code> 资源覆盖掉默认的便能恢复这两个 tag，修复后监控页面也显示正常了。</p>
<blockquote>
<p>EnvoyFilter 是实时生效的，并不需要重建应用 Pod。</p>
</blockquote>
<h3 id="JVM-监控"><a href="#JVM-监控" class="headerlink" title="JVM 监控"></a>JVM 监控</h3><p><code>JVM</code> 数据丢失的这个应用，直接进入 <code>Pod</code> 查看暴露出的 <code>metric</code>，发现数据都有，一切正常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;Code Cache&quot;,&#125; 1.32126784E8</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;Metaspace&quot;,&#125; 2.74250552E8</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;Compressed Class Space&quot;,&#125; 3.1766024E7</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;G1 Eden Space&quot;,&#125; 1.409286144E9</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;G1 Survivor Space&quot;,&#125; 2.01326592E8</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;G1 Old Gen&quot;,&#125; 2.583691248E9</span><br></pre></td></tr></table></figure>

<p>说明不是数据源的问题，那就可能是数据采集节点的问题了。</p>
<p>进入<code>VictoriaMetrics</code> 的 <code>target</code> 页面发现应用确实已经下线，原来是采集的端口不通导致的。</p>
<blockquote>
<p>我们使用 VictoriaMetrics 代替了 Prometheus。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/02/19/Hhj6LutlvUsycES.png"></p>
<p>而这个端口 15020 之前并未使用，我们使用的是另外一个自定义端口和端点来采集数据。</p>
<p>经过查阅发现 15020 是 istio 默认的端口：<br><img src="https://s2.loli.net/2023/02/19/LjOewSXl5IVPv6q.png"></p>
<p>原来在默认情况下 Istio 会为所有的数据面 Pod 加上：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">prometheus.io/path:</span> <span class="string">/stats/prometheus</span></span><br><span class="line">    <span class="attr">prometheus.io/port:</span> <span class="string">&quot;15020&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个注解用于采集数据，由于我们是自定义的端点，所以需要修改默认行为：<br><img src="https://s2.loli.net/2023/02/19/R7v8rG6f2XixlBU.png"></p>
<p>在控制面将 <code>--set meshConfig.enablePrometheusMerge=false</code> 设置为 false，其实官方文档已经说明，如果不是使用的标准 <code>prometheus.io</code> 注解，需要将这个设置为 false。</p>
<blockquote>
<p>修改后需要重建应用 Pod 方能生效。</p>
</blockquote>
<p>有了 url 这个 tag 后，接口监控页也恢复了正常。</p>
<h3 id="接口维度"><a href="#接口维度" class="headerlink" title="接口维度"></a>接口维度</h3><p>接口维度的数据丢失和基本数据丢失的原因类似，本质上也是原始数据中缺少了 url 这个 tag，因为我们所聚合的指标使用了 url：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio.service.source.url.istio_requests_total</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">expr:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        sum(irate(istio_requests_total&#123;reporter=&quot;source&quot;&#125;[1m]))</span></span><br><span class="line"><span class="string">        by (</span></span><br><span class="line"><span class="string">          destination_app,</span></span><br><span class="line"><span class="string">          source_workload_namespace,</span></span><br><span class="line"><span class="string">          response_code,</span></span><br><span class="line"><span class="string">          source_app,</span></span><br><span class="line"><span class="string">          url</span></span><br><span class="line"><span class="string">        )</span></span><br></pre></td></tr></table></figure>
<p>最终参考了 <a href="https://istio.io/latest/docs/reference/config/proxy_extensions/stats/#MetricConfig">MetricConfig</a> 自定义了 URL 的tag.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;dimensions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;request.url_path&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/02/19/tERXzV3TI1oe7bJ.png"><br>但这也有个大前提，当我们 tag 的指标没有在默认 tag 列表中时，需要在 Deployment 或者是 Istio 控制面中全局加入我们自定义的 tag 声明。</p>
<p>比如这里新增了 url 的 tag，那么就需要在控制面中加入：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">meshConfig:</span></span><br><span class="line">  <span class="attr">defaultConfig:</span></span><br><span class="line">    <span class="attr">extraStatTags:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">url</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改了控制面后需要重新构建 Pod 后才会生效。</p>
</blockquote>
<h2 id="EnvoyFilter的问题"><a href="#EnvoyFilter的问题" class="headerlink" title="EnvoyFilter的问题"></a>EnvoyFilter的问题</h2><p>查看<a href="https://istio.io/latest/docs/reference/config/proxy_extensions/stats/#MetricConfig">MetricConfig</a>的配置后发现是可以直接去掉指标以及去掉指标中的 tag ，这个很有用，能够大大减低指标采集系统 <code>VictoriaMetrics</code> 的系统负载。</p>
<p>于是参考了官方的示例，去掉了一些 tag，同时还去掉了指标：<code>istio_request_messages_total</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      <span class="attr">&quot;tags_to_remove&quot;:</span> [</span><br><span class="line">        <span class="string">&quot;source_principal&quot;</span>,</span><br><span class="line">        <span class="string">&quot;source_version&quot;</span>,</span><br><span class="line">        <span class="string">&quot;destination_principal&quot;</span>,</span><br><span class="line">        <span class="string">&quot;destination_version&quot;</span>,</span><br><span class="line">        <span class="string">&quot;source_workload&quot;</span>,</span><br><span class="line">        <span class="string">&quot;source_cluster&quot;</span>,</span><br><span class="line">      ]</span><br><span class="line">&#125;<span class="string">,</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;name&quot;:</span> <span class="string">&quot;istio_request_messages_total&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;drop&quot;:</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但并没有生效，于是换成了在 <code>v1.12</code> 中新增的 <code>Telemetry API</code>。</p>
<h1 id="使用-Telemetry-API"><a href="#使用-Telemetry-API" class="headerlink" title="使用 Telemetry API"></a>使用 Telemetry API</h1><p><img src="https://s2.loli.net/2023/02/19/bN4LiwQZm7rJHXW.png"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">telemetry.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Telemetry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mesh-istio-test</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># no selector specified, applies to all workloads</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">overrides:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">metric:</span> <span class="string">GRPC_REQUEST_MESSAGES</span></span><br><span class="line">            <span class="attr">mode:</span> <span class="string">CLIENT_AND_SERVER</span></span><br><span class="line">          <span class="attr">disabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<p>但是参考了官方文档后发现依然不能生效，<code>GRPC_REQUEST_MESSAGES</code> 所对应的 <code>istio_request_messages_total</code> 指标依然存在。</p>
<p>接着在我领导查看 <code>Istio</code> 源码以及相关 <a href="https://github.com/istio/istio/issues/37645">issue</a> 后发现 <code>Telemetry API</code> 和 <code>EnvoyFilter</code> 是不能同时存在的，也就是说会优先使用 <code>EnvoyFilter</code>；这也就是为什么我之前配置没有生效的原因。<br><img src="https://s2.loli.net/2023/02/19/M3uevVscNk5XOTd.png"></p>
<blockquote>
<p>后初始化 EnvoyFilter</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/02/19/sbkrBdRwULSo9Yg.png"><br>正如这个 issue 中所说，需要删掉现在所有的 EnvoyFilter；删除后果然就生效了。</p>
<p>新的 <code>Telemetry API</code> 不但语义更加清晰，功能也一样没少，借助他我们依然可以自定义、删除指标、tag 等。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">telemetry.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Telemetry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mesh-istio-telemetry-test</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">overrides:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">metric:</span> <span class="string">GRPC_RESPONSE_MESSAGES</span></span><br><span class="line">            <span class="attr">mode:</span> <span class="string">CLIENT_AND_SERVER</span></span><br><span class="line">          <span class="attr">disabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">tagOverrides:</span></span><br><span class="line">            <span class="attr">url:</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;request.url_path&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">metric:</span> <span class="string">ALL_METRICS</span></span><br><span class="line">          <span class="attr">tagOverrides:</span></span><br><span class="line">            <span class="attr">source_workload:</span></span><br><span class="line">              <span class="attr">operation:</span> <span class="string">REMOVE</span></span><br></pre></td></tr></table></figure>

<p>比如以上配置便可以删除掉 <code>GRPC_RESPONSE_MESSAGES</code> 指标，新增一个 url 的指标，同时在所有指标中删除了 <code>source_workload</code> 这个 tag。</p>
<p>借助于这一个声明文件便能满足我们多个需求。</p>
<h2 id="裁剪指标"><a href="#裁剪指标" class="headerlink" title="裁剪指标"></a>裁剪指标</h2><p>后续根据我们实际需求借助于 <code>Telemetry API</code> 裁剪掉了许多指标和 tag，使得指标系统负载下降了一半左右。<br><img src="https://s2.loli.net/2023/02/19/rLqd3lUTgOK9RbS.png"><br>效果相当明显。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次定位修复 <code>Istio</code> 升级后带来的指标系统问题收获巨大，之前对 Istio 一直只停留在理论阶段，只知道他可以实现传统微服务中对接口粒度的控制，完美弥补了 <code>k8s</code> 只有服务层级的粗粒度控制；</p>
<p>这两周下来对一个现代云原生监控系统也有了系统的认识，从 <code>App-&gt;Pod-&gt;sidecar-&gt;VictoriaMetrics(Prometheus)-&gt;Grafana</code> 这一套流程中每个环节都可能会出错；</p>
<p>所以学无止境吧，幸好借助公司业务场景后续还有更多机会参与实践。</p>
]]></content>
      <categories>
        <category>Istio</category>
      </categories>
      <tags>
        <tag>K8s</tag>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的集合容器应当避免的坑</title>
    <url>/2019/07/04/java-senior/ArrayList%20VS%20LinkedList/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/07/04/5d1cdc7680acc67477.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前不久帮同事一起 <code>review</code> 一个 <code>job</code> 执行缓慢的问题时发现不少朋友在撸码实现功能时还是有需要细节不够注意，于是便有了这篇文章。</p>
<h1 id="ArrayList-踩坑"><a href="#ArrayList-踩坑" class="headerlink" title="ArrayList 踩坑"></a>ArrayList 踩坑</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>() ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一批数据</span></span><br><span class="line">List&lt;String&gt; all = getData();</span><br><span class="line"><span class="keyword">for</span>(String str : all) &#123;</span><br><span class="line">	temp.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先大家看看这段代码有什么问题嘛？</p>
<span id="more"></span>

<p>其实在大部分情况下这都是没啥问题，无非就是循环的往 <code>ArrayList</code> 中写入数据而已。</p>
<p>但在特殊情况下，比如这里的 <code>getData()</code> 返回数据非常巨大时后续 <code>temp.add(str)</code> 就会有问题了。</p>
<p>比如我们在 <code>review</code> 代码时发现这里返回的数据有时会高达 2000W，这时 <code>ArrayList</code> 写入的问题就凸显出来了。</p>
<h2 id="填坑指南"><a href="#填坑指南" class="headerlink" title="填坑指南"></a>填坑指南</h2><p>大家都知道 ArrayList 是由数组实现，而数据的长度有限；需要在合适的时机对数组扩容。</p>
<blockquote>
<p>这里以插入到尾部为例 add(E e)。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/07/04/5d1cdc77047aa18412.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>) ;</span><br><span class="line">temp.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">temp.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">temp.add(<span class="string">&quot;3&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当我们初始化一个长度为 2 的 <code>ArrayList</code> ，并往里边写入三条数据时 <code>ArrayList</code> 就得扩容了，也就是将之前的数据复制一份到新的数组长度为 3 的数组中。</p>
<p><img src="https://i.loli.net/2019/07/04/5d1cdc774fbe780989.jpg"></p>
<blockquote>
<p>之所以是 3 ，是因为新的长度&#x3D;原有长度 * 1.5</p>
</blockquote>
<p>通过源码我们可以得知 <code>ArrayList</code> 的默认长度为 10.</p>
<p><img src="https://i.loli.net/2019/07/04/5d1cdc78ce03788576.jpg"><br><img src="https://i.loli.net/2019/07/04/5d1cdc791275268933.jpg"></p>
<p>但其实并不是在初始化的时候就创建了 <code>DEFAULT_CAPACITY = 10</code> 的数组。</p>
<p><img src="https://i.loli.net/2019/07/04/5d1cdc7a45b6264440.jpg"></p>
<p>而是在往里边 <code>add</code> 第一个数据的时候会扩容到 10.</p>
<p>既然知道了默认的长度为 10 ，那说明后续一旦写入到第九个元素的时候就会扩容为 <code>10*1.5 =15</code>。<br>这一步为数组复制，也就是要重新开辟一块新的内存空间存放这 15 个数组。</p>
<p>一旦我们频繁且数量巨大的进行写入时就会导致许多的数组复制，这个效率是极低的。</p>
<p>但如果我们提前预知了可能会写入多少条数据时就可以提前避免这个问题。</p>
<p>比如我们往里边写入 1000W 条数据，在初始化的时候就给定数组长度与用默认 10 的长度之间性能是差距巨大的。</p>
<blockquote>
<p>我用 JMH 基准测试验证如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TEN_MILLION</span> <span class="operator">=</span> <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line">    <span class="meta">@OutputTimeUnit(TimeUnit.MICROSECONDS)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">arrayList</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TEN_MILLION; i++) &#123;</span><br><span class="line">            array.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line">    <span class="meta">@OutputTimeUnit(TimeUnit.MICROSECONDS)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">arrayListSize</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(TEN_MILLION);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TEN_MILLION; i++) &#123;</span><br><span class="line">            array.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(CollectionsTest.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/07/04/5d1cdc7a910a851524.jpg"></p>
<p>根据结果可以看出预设长度的效率会比用默认的效率高上很多（这里的 <code>Score</code> 指执行完函数所消耗的时间）。</p>
<p>所以这里强烈建议大家：在有大量数据写入 <code>ArrayList</code> 时，一定要初始化指定长度。</p>
<hr>
<p>再一个是一定要慎用 <code>add(int index, E element)</code> 向指定位置写入数据。</p>
<p><img src="https://i.loli.net/2019/07/04/5d1cdc7adefae63526.jpg"></p>
<p>通过源码我们可以看出，每一次写入都会将 index 后的数据往后移动一遍，其实本质也是要复制数组；</p>
<p>但区别于往常规的往数组尾部写入数据，它每次都会进行数组复制，效率极低。</p>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>提到 <code>ArrayList</code> 就不得不聊下 <code>LinkedList</code> 这个孪生兄弟；虽说都是 <code>List</code> 的容器，但本质实现却完全不同。</p>
<p><img src="https://i.loli.net/2019/07/04/5d1cdc7b0c7d526575.jpg"></p>
<p><code>LinkedList</code> 是由链表组成，每个节点又有头尾两个节点分别引用了前后两个节点；因此它也是一个双向链表。</p>
<p>所以理论上来说它的写入非常高效，将不会有 ArrayList 中效率极低的数组复制，每次只需要移动指针即可。</p>
<blockquote>
<p>这里偷懒就不画图了，大家自行脑补下。</p>
</blockquote>
<h1 id="对比测试"><a href="#对比测试" class="headerlink" title="对比测试"></a>对比测试</h1><p>坊间一直流传：</p>
<blockquote>
<p>LinkedList 的写入效率高于 ArrayList，所以在写大于读的时候非常适用于 LinkedList 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.MICROSECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">linkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TEN_MILLION; i++) &#123;</span><br><span class="line">        array.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/07/04/5d1cdc7b3353a90285.jpg"></p>
<p>这里测试看下结论是否符合；同样的也是对 <code>LinkedList</code> 写入 <code>1000W</code> 次数据，通过结果来看初始化数组长度的 <code>ArrayList</code> 效率明显是要高于 <code>LinkedList</code> 。</p>
<p>但这里的前提是要提前预设 <code>ArrayList</code> 的数组长度，避免数组扩容，这样 <code>ArrayList</code> 的写入效率是非常高的，而 <code>LinkedList</code> 的虽然不需要复制内存，但却需要创建对象，变换指针等操作。</p>
<p>而查询就不用多说了，<code>ArrayList</code> 可以支持下标随机访问，效率非常高。</p>
<p> <code>LinkedList</code> 由于底层不是数组，不支持通过下标访问，而是需要根据查询 index 所在的位置来判断是从头还是从尾进行遍历。</p>
<p><img src="https://i.loli.net/2019/07/04/5d1cdc9f5b7d645892.jpg"></p>
<p>但不管是哪种都得需要移动指针来一个个遍历，特别是 <code>index</code> 靠近中间位置时将会非常慢。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>高性能应用都是从小细节一点点堆砌起来的，就如这里提到的 <code>ArrayList</code> 的坑一样，日常使用没啥大问题，一旦数据量起来所有的小问题都会成为大问题。</p>
<p>所以再总结下：</p>
<ul>
<li>再使用 ArrayList 时如果能提前预测到数据量大小，比较大时一定要指定其长度。</li>
<li>尽可能避免使用 <code>add(index,e)</code> api，会导致复制数组，降低效率。</li>
<li>再额外提一点，我们常用的另一个 <code>Map</code> 容器 <code>HashMap</code> 也是推荐要初始化长度从而避免扩容。</li>
</ul>
<p>本文所有测试代码：</p>
<p><a href="https://github.com/crossoverJie/JCSprout/blob/master/src/main/java/com/crossoverjie/basic/CollectionsTest.java">https://github.com/crossoverJie/JCSprout/blob/master/src/main/java/com/crossoverjie/basic/CollectionsTest.java</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayList</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！</title>
    <url>/2018/07/23/java-senior/ConcurrentHashMap/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d2be294c6.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Map 这样的 <code>Key Value</code> 在软件开发中是非常经典的结构，常用于在内存中存放数据。</p>
<p>本篇主要想讨论 ConcurrentHashMap 这样一个并发容器，在正式开始之前我觉得有必要谈谈 HashMap，没有它就不会有后面的 ConcurrentHashMap。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>众所周知 HashMap 底层是基于 <code>数组 + 链表</code> 组成的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。</p>
<h3 id="Base-1-7"><a href="#Base-1-7" class="headerlink" title="Base 1.7"></a>Base 1.7</h3><p>1.7 中的数据结构图：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2be77958.jpg"></p>
<span id="more"></span>

<p>先来看看 1.7 中的实现。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2bfd6aba.jpg"></p>
<p>这是 HashMap 中比较核心的几个成员变量；看看分别是什么意思？</p>
<ol>
<li>初始化桶大小，因为底层是数组，所以这是数组默认的大小。</li>
<li>桶最大值。</li>
<li>默认的负载因子（0.75）</li>
<li><code>table</code> 真正存放数据的数组。</li>
<li><code>Map</code> 存放数量的大小。</li>
<li>桶大小，可在初始化时显式指定。</li>
<li>负载因子，可在初始化时显式指定。</li>
</ol>
<p>重点解释下负载因子：</p>
<p>由于给定的 HashMap 的容量大小是固定的，比如默认初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 <code>16 * 0.75 = 12</code> 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
<p>因此通常建议能提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗。</p>
<p>根据代码可以看到其实真正存放数据的是 </p>
<p><code>transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</code> </p>
<p>这个数组，那么它又是如何定义的呢？</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2c08e693.jpg"></p>
<p>Entry 是 HashMap 中的一个内部类，从他的成员变量很容易看出：</p>
<ul>
<li>key 就是写入时的键。</li>
<li>value 自然就是值。</li>
<li>开始的时候就提到 HashMap 是由数组和链表组成，所以这个 next 就是用于实现链表结构。</li>
<li>hash 存放的是当前 key 的 hashcode。</li>
</ul>
<p>知晓了基本结构，那来看看其中重要的写入、获取函数：</p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断当前数组是否需要初始化。</li>
<li>如果 key 为空，则 put 一个空值进去。</li>
<li>根据 key 计算出 hashcode。</li>
<li>根据计算出的 hashcode 定位出所在桶。</li>
<li>如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。</li>
<li>如果桶是空的，说明当前位置没有数据存入；新增一个 Entry 对象写入当前位置。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 addEntry 写入 Entry 时需要判断是否需要扩容。</p>
<p>如果需要就进行两倍扩充，并将当前的 key 重新 hash 并定位。</p>
<p>而在 <code>createEntry</code> 中会将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表。</p>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><p>再来看看 get 函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> == entry ? <span class="literal">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先也是根据 key 计算出 hashcode，然后定位到具体的桶中。</li>
<li>判断该位置是否为链表。</li>
<li>不是链表就根据 <code>key、key 的 hashcode</code> 是否相等来返回值。</li>
<li>为链表则需要遍历直到 key 及 hashcode 相等时候就返回值。</li>
<li>啥都没取到就直接返回 null 。</li>
</ul>
<h3 id="Base-1-8"><a href="#Base-1-8" class="headerlink" title="Base 1.8"></a>Base 1.8</h3><p>不知道 1.7 的实现大家看出需要优化的点没有？</p>
<p>其实一个很明显的地方就是：</p>
<blockquote>
<p>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 <code>O(N)</code>。</p>
</blockquote>
<p>因此 1.8 中重点优化了这个查询效率。</p>
<p>1.8 HashMap 结构图：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2c1c1cd7.jpg"></p>
<p>先来看看几个核心的成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>

<p>和 1.7 大体上都差不多，还是有几个重要的区别：</p>
<ul>
<li><code>TREEIFY_THRESHOLD</code> 用于判断是否需要将链表转换为红黑树的阈值。</li>
<li>HashEntry 修改为 Node。</li>
</ul>
<p>Node 的核心组成其实也是和 1.7 中的 HashEntry 一样，存放的都是 <code>key value hashcode next</code> 等数据。</p>
<p>再来看看核心方法。</p>
<h4 id="put-方法-1"><a href="#put-方法-1" class="headerlink" title="put 方法"></a>put 方法</h4><p><img src="https://i.loli.net/2019/05/08/5cd1d2c378090.jpg"></p>
<p>看似要比 1.7 的复杂，我们一步步拆解：</p>
<ol>
<li>判断当前桶是否为空，空的就需要初始化（resize 中会判断是否进行初始化）。</li>
<li>根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。</li>
<li>如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 <code>key、key 的 hashcode</code> 与写入的 key 是否相等，相等就赋值给 <code>e</code>,在第 8 步的时候会统一进行赋值及返回。</li>
<li>如果当前桶为红黑树，那就要按照红黑树的方式写入数据。</li>
<li>如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）。</li>
<li>接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</li>
<li>如果在遍历过程中找到 key 相同时直接退出遍历。</li>
<li>如果 <code>e != null</code> 就相当于存在相同的 key,那就需要将值覆盖。</li>
<li>最后判断是否需要进行扩容。</li>
</ol>
<h4 id="get-方法-1"><a href="#get-方法-1" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get 方法看起来就要简单许多了。</p>
<ul>
<li>首先将 key hash 之后取得所定位的桶。</li>
<li>如果桶为空则直接返回 null 。</li>
<li>否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。</li>
<li>如果第一个不匹配，则判断它的下一个是红黑树还是链表。</li>
<li>红黑树就按照树的查找方式返回值。</li>
<li>不然就按照链表的方式遍历匹配返回值。</li>
</ul>
<p>从这两个核心方法（get&#x2F;put）可以看出 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 <code>O(logn)</code>。</p>
<p>但是 HashMap 原有的问题也都存在，比如在并发场景下使用时容易出现死循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            map.put(UUID.randomUUID().toString(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是为什么呢？简单分析下。</p>
<p>看过上文的还记得在 HashMap 扩容的时候会调用 <code>resize()</code> 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。</p>
<p>如下图：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2c4ede54.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2c58e4c2.jpg"></p>
<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;key=&quot;</span> + next.getKey() + <span class="string">&quot; value=&quot;</span> + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;key=&quot;</span> + key + <span class="string">&quot; value=&quot;</span> + map.get(key));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><code>强烈建议</code>使用第一种 EntrySet 进行遍历。</p>
<p>第一种可以把 key value 同时取出，第二种还得需要通过 key 取一次 value，效率较低。</p>
<blockquote>
<p>简单总结下 HashMap：无论是 1.7 还是 1.8 其实都能看出 JDK 没有对它做任何的同步操作，所以并发会出问题，甚至 1.7 中出现死循环导致系统不可用（1.8 已经修复死循环问题）。</p>
</blockquote>
<p>因此 JDK 推出了专项专用的 ConcurrentHashMap ，该类位于 <code> java.util.concurrent</code> 包下，专门用于解决并发问题。</p>
<blockquote>
<p>坚持看到这里的朋友算是已经把 ConcurrentHashMap 的基础已经打牢了，下面正式开始分析。</p>
</blockquote>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap 同样也分为 1.7 、1.8 版，两者在实现上略有不同。</p>
<h3 id="Base-1-7-1"><a href="#Base-1-7-1" class="headerlink" title="Base 1.7"></a>Base 1.7</h3><p>先来看看 1.7 的实现，下面是他的结构图：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2c5ce95c.jpg"></p>
<p>如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。</p>
<p>它的核心成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>


<p>Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2249069246763182397L</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">transient</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">transient</span> <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>看看其中 HashEntry 的组成：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2c635c69.jpg"></p>
<p>和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。</p>
<p>原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p>
<p>下面也来看看核心的 <code>put get</code> 方法。</p>
<h4 id="put-方法-2"><a href="#put-方法-2" class="headerlink" title="put 方法"></a>put 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。</p>
<p>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 <code>scanAndLockForPut()</code> 自旋获取锁。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2cc3c982.jpg"></p>
<ol>
<li>尝试自旋获取锁。</li>
<li>如果重试的次数达到了 <code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</li>
</ol>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2cd25c37.jpg"></p>
<p>再结合图看看 put 的流程。</p>
<ol>
<li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li>
<li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li>
<li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li>
<li>最后会解除在 1 中所获取当前 Segment 的锁。</li>
</ol>
<h4 id="get-方法-2"><a href="#get-方法-2" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="type">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get 逻辑比较简单：</p>
<p>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</p>
<p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</p>
<p>ConcurrentHashMap 的 get 方法是非常高效的，<strong>因为整个过程都不需要加锁</strong>。</p>
<h3 id="Base-1-8-1"><a href="#Base-1-8-1" class="headerlink" title="Base 1.8"></a>Base 1.8</h3><p>1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但依然存在 HashMap 在 1.7 版本中的问题。</p>
<blockquote>
<p>那就是查询遍历链表效率太低。</p>
</blockquote>
<p>因此 1.8 做了一些数据结构上的调整。</p>
<p>首先来看下底层的组成结构：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2ce33795.jpg"></p>
<p>看起来是不是和 1.8 HashMap 结构类似？</p>
<p>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2ceebe02.jpg"></p>
<p>也将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的。</p>
<p>其中的 <code>val next</code> 都用了 volatile 修饰，保证了可见性。</p>
<h4 id="put-方法-3"><a href="#put-方法-3" class="headerlink" title="put 方法"></a>put 方法</h4><p>重点来看看 put 函数：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2cfc3293.jpg"></p>
<ul>
<li>根据 key 计算出 hashcode 。</li>
<li>判断是否需要进行初始化。</li>
<li><code>f</code> 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>
</ul>
<h4 id="get-方法-3"><a href="#get-方法-3" class="headerlink" title="get 方法"></a>get 方法</h4><p><img src="https://i.loli.net/2019/05/08/5cd1d2d22c6cb.jpg"></p>
<ul>
<li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li>
<li>如果是红黑树那就按照树的方式获取值。</li>
<li>就不满足那就按照链表的方式遍历获取值。</li>
</ul>
<blockquote>
<p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（<code>O(logn)</code>），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完了整个 HashMap 和 ConcurrentHashMap 在 1.7 和 1.8 中不同的实现方式相信大家对他们的理解应该会更加到位。</p>
<p>其实这块也是面试的重点内容，通常的套路是：</p>
<ol>
<li>谈谈你理解的 HashMap，讲讲其中的 get put 过程。</li>
<li>1.8 做了什么优化？</li>
<li>是线程安全的嘛？</li>
<li>不安全会导致哪些问题？</li>
<li>如何解决？有没有线程安全的并发容器？</li>
<li>ConcurrentHashMap 是如何实现的？ 1.7、1.8 实现有何不同？为什么这么做？</li>
</ol>
<p>这一串问题相信大家仔细看完都能怼回面试官。</p>
<p>除了面试会问到之外平时的应用其实也蛮多，像之前谈到的 <a href="https://crossoverjie.top/categories/Guava/">Guava 中 Cache</a> 的实现就是利用 ConcurrentHashMap 的思想。</p>
<p>同时也能学习 JDK 作者大牛们的优化思路以及并发解决方案。</p>
<blockquote>
<p>其实写这篇的前提是源于 GitHub 上的一个 <a href="https://github.com/crossoverJie/Java-Interview/issues/59">Issues</a>，也希望大家能参与进来，共同维护好这个项目。</p>
</blockquote>
<h2 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h2><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
<p><strong>欢迎关注公众号一起交流：</strong></p>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrent</tag>
        <tag>ConcurrentHashMap</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>一次线上问题排查所引发的思考</title>
    <url>/2018/07/08/java-senior/JVM-Troubleshoot/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d2fb7f975.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前或多或少分享过一些<a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/MemoryAllocation.md">内存模型</a>、<a href="https://crossoverjie.top/2018/01/18/newObject/">对象创建</a>之类的内容，其实大部分人看完都是懵懵懂懂，也不知道这些的实际意义。</p>
<p>直到有一天你会碰到线上奇奇怪怪的问题，如：</p>
<ul>
<li>线程执行一个任务迟迟没有返回，应用假死。</li>
<li>接口响应缓慢，甚至请求超时。</li>
<li>CPU 高负载运行。</li>
</ul>
<p>这类问题并不像一个空指针、数组越界这样明显好查，这时就需要刚才提到的内存模型、对象创建、线程等相关知识结合在一起来排查问题了。</p>
<p>正好这次借助之前的一次生产问题来聊聊如何排查和解决问题。</p>
<h2 id="生产现象"><a href="#生产现象" class="headerlink" title="生产现象"></a>生产现象</h2><p>首先看看问题的背景吧：</p>
<p>我这其实是一个定时任务，在固定的时间会开启 N 个线程并发的从 Redis 中获取数据进行运算。</p>
<p><strong>业务逻辑非常简单，但应用一般涉及到多线程之后再简单的事情都要小心对待。</strong></p>
<p>果不其然这次就出问题了。</p>
<p>现象:原本只需要执行几分钟的任务执行了几个小时都没退出。翻遍了所有的日志都没找到异常。</p>
<p>于是便开始定位问题之路。</p>
<span id="more"></span>


<h3 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h3><p>既然没办法直接从日志中发现异常，那就只能看看应用到底在干嘛了。</p>
<p>最常见的工具就是 JDK 自带的那一套。</p>
<p>这次我使用了 <code>jstack</code> 来查看线程的执行情况，它的作用其实就是 dump 当前的线程堆栈。</p>
<p>当然在 dump 之前是需要知道我应用的 pid 的，可以使用 <code>jps -v</code> 这样的方式列出所有的 Java 进程。</p>
<p>当然如果知道关键字的话直接使用 <code>ps aux|grep java</code> 也是可以的。</p>
<p>拿到 <code>pid=1523</code> 了之后就可以利用 <code>jstack 1523 &gt; 1523.log</code> 这样的方式将 dump 文件输出到日志文件中。</p>
<p>如果应用简单不复杂，线程这些也比较少其实可以直接打开查看。</p>
<p>但复杂的应用导出来的日志文件也比较大还是建议用专业的分析工具。</p>
<p>我这里的日志比较少直接打开就可以了。</p>
<p>因为我清楚知道应用中开启的线程名称，所以直接根据线程名就可以在日志中找到相关的堆栈：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2fedfc7f.jpg"></p>
<blockquote>
<p>所以通常建议大家线程名字给的有意义，在排查问题时很有必要。</p>
</blockquote>
<p>其实其他几个线程都和这里的堆栈类似，很明显的看出都是在做 Redis 连接。</p>
<p>于是我登录 Redis 查看了当前的连接数，发现已经非常高了。</p>
<p>这样 Redis 的响应自然也就变慢了。</p>
<p>接着利用 <code>jps -v</code> 列出了当前所以在跑的 Java 进程，果不其然有好几个应用都在查询 Redis，而且都是并发连接，问题自然就找到了。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><blockquote>
<p>所以问题的主要原因是：大量的应用并发查询 Redis，导致 Redis 的性能降低。</p>
</blockquote>
<p>既然找到了问题，那如何解决呢？</p>
<ul>
<li>减少同时查询 Redis 的应用，分开时段降低 Redis 的压力。</li>
<li>将 Redis 复制几个集群，各个应用分开查询。但是这样会涉及到数据的同步等运维操作，或者由程序了进行同步也会增加复杂度。</li>
</ul>
<p>目前我们选择的是第一个方案，效果很明显。</p>
<h2 id="本地模拟"><a href="#本地模拟" class="headerlink" title="本地模拟"></a>本地模拟</h2><p>上文介绍的是线程相关问题，现在来分析下内存的问题。</p>
<p>以这个类为例：</p>
<p><a href="https://github.com/crossoverJie/Java-Interview/blob/master/src/main/java/com/crossoverjie/oom/heap/HeapOOM.java">https://github.com/crossoverJie/Java-Interview/blob/master/src/main/java/com/crossoverjie/oom/heap/HeapOOM.java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">10</span>) ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            list.add(<span class="string">&quot;1&quot;</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动参数如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Xms20m</span><br><span class="line">-Xmx20m</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=/Users/xx/Documents</span><br></pre></td></tr></table></figure>

<p>为了更快的突出内存问题将堆的最大内存固定在 20M，同时在 JVM 出现 OOM 的时候自动 dump 内存到 <code>/Users/xx/Documents</code>(不配路径则会生成在当前目录)。</p>
<p>执行之后果不其然出现了异常：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d43d66d71.jpg"></p>
<p>同时对应的内存 dump 文件也生成了。</p>
<h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p>这时就需要相应的工具进行分析了，最常用的自然就是 MAT 了。</p>
<p>我试了一个在线工具也不错（文件大了就不适合了）：</p>
<p><a href="http://heaphero.io/index.jsp">http://heaphero.io/index.jsp</a></p>
<p>上传刚才生成的内存文件之后：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4418757d.jpg"></p>
<p>因为是内存溢出，所以主要观察下大对象：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d44485b1f.jpg"></p>
<p>也有相应提示，这个很有可能就是内存溢出的对象，点进去之后：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d445b728f.jpg"></p>
<p>看到这个堆栈其实就很明显了：</p>
<p>在向 ArrayList 中不停的写入数据时，会导致频繁的扩容也就是数组复制这些过程，最终达到 20M 的上限导致内存溢出了。</p>
<h2 id="更多建议"><a href="#更多建议" class="headerlink" title="更多建议"></a>更多建议</h2><p>上文说过，一旦使用了多线程，那就要格外小心。</p>
<p>以下是一些日常建议：</p>
<ul>
<li>尽量不要在线程中做大量耗时的网络操作，如查询数据库（可以的话在一开始就将数据从从 DB 中查出准备好）。</li>
<li>尽可能的减少多线程竞争锁。可以将数据分段，各个线程分别读取。</li>
<li>多利用 <code>CAS+自旋</code> 的方式更新数据，减少锁的使用。</li>
<li>应用中加上 <code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp</code> 参数，在内存溢出时至少可以拿到内存日志。</li>
<li>线程池监控。如线程池大小、队列大小、最大线程数等数据，可提前做好预估。</li>
<li>JVM 监控，可以看到堆内存的涨幅趋势，GC 曲线等数据，也可以提前做好准备。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>线上问题定位需要综合技能，所以是需要一些基础技能。如线程、内存模型、Linux 等。</p>
<p>当然这些问题没有实操过都是纸上谈兵；如果第一次碰到线上问题，不要慌张，反而应该庆幸解决之后你又会习得一项技能。</p>
<h2 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h2><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
<p><strong>欢迎关注公众号一起交流：</strong></p>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>concurrent</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>一次 HashSet 所引起的并发问题</title>
    <url>/2018/11/08/java-senior/JVM-concurrent-HashSet-problem/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1c669d9581.jpg"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>上午刚到公司，准备开始一天的摸鱼之旅时突然收到了一封监控中心的邮件。</p>
<p>心中暗道不好，因为监控系统从来不会告诉我应用完美无 <code>bug</code>，其实系统挺猥琐。</p>
<p>打开邮件一看，果然告知我有一个应用的线程池队列达到阈值触发了报警。</p>
<p>由于这个应用出问题非常影响用户体验；于是立马让运维保留现场 <code>dump</code> 线程和内存同时重启应用，还好重启之后恢复正常。于是开始着手排查问题。</p>
<span id="more"></span>

<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先了解下这个应用大概是做什么的。</p>
<p>简单来说就是从 <code>MQ</code> 中取出数据然后丢到后面的业务线程池中做具体的业务处理。</p>
<p>而报警的队列正好就是这个线程池的队列。</p>
<p>跟踪代码发现构建线程池的方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(coreSize, maxSize,</span><br><span class="line">              <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());;</span><br><span class="line">             put(poolName,executor);</span><br></pre></td></tr></table></figure>

<p>采用的是默认的 <code>LinkedBlockingQueue</code> 并没有指定大小（这也是个坑），于是这个队列的默认大小为 <code>Integer.MAX_VALUE</code>。</p>
<p>由于应用已经重启，只能从仅存的线程快照和内存快照进行分析。</p>
<h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><p>先利用 <code>MAT</code> 分析了内存，的到了如下报告。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c66f983e1.jpg"></p>
<p>其中有两个比较大的对象，一个就是之前线程池存放任务的 <code>LinkedBlockingQueue</code>，还有一个则是 <code>HashSet</code>。</p>
<p>当然其中队列占用了大量的内存，所以优先查看，<code>HashSet</code> 一会儿再看。</p>
<blockquote>
<p> 由于队列的大小给的够大，所以结合目前的情况来看应当是线程池里的任务处理较慢，导致队列的任务越堆越多，至少这是目前可以得出的结论。</p>
</blockquote>
<h2 id="线程分析"><a href="#线程分析" class="headerlink" title="线程分析"></a>线程分析</h2><p>再来看看线程的分析，这里利用 <a href="http://fastthread.io/index.jsp">fastthread.io</a> 这个网站进行线程分析。</p>
<p>因为从表现来看线程池里的任务迟迟没有执行完毕，所以主要看看它们在干嘛。</p>
<p>正好他们都处于 <strong>RUNNABLE</strong> 状态，同时堆栈如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c67e5a9b5.jpg"></p>
<p>发现正好就是在处理上文提到的 <code>HashSet</code>，看这个堆栈是在查询 <code>key</code> 是否存在。通过查看 312 行的业务代码确实也是如此。</p>
<blockquote>
<p>这里的线程名字也是个坑，让我找了好久。</p>
</blockquote>
<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>分析了内存和线程的堆栈之后其实已经大概猜出一些问题了。</p>
<p>这里其实有一个前提忘记讲到：</p>
<p>这个告警是<code>凌晨三点</code>发出的邮件，但并没有电话提醒之类的，所以大家都不知道。</p>
<p>到了早上上班时才发现并立即 <code>dump</code> 了上面的证据。</p>
<p>所有有一个很重要的事实：<strong>这几个业务线程在查询 <code>HashSet</code> 的时候运行了 6 7 个小时都没有返回</strong>。</p>
<p>通过之前的监控曲线图也可以看出：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c67c5e613.jpg"></p>
<p>操作系统在之前一直处于高负载中，直到我们早上看到报警重启之后才降低。</p>
<p>同时发现这个应用生产上运行的是 <code>JDK1.7</code> ，所以我初步认为应该是在查询 key 的时候进入了 <code>HashMap</code> 的环形链表导致 <code>CPU</code> 高负载同时也进入了死循环。</p>
<p>为了验证这个问题再次 review 了代码。</p>
<p>整理之后的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程池</span></span><br><span class="line"><span class="keyword">private</span> ExecutorService executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">hashSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="comment">//从 MQ 中获取数据</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> subMQ();</span><br><span class="line">		executor.excute(<span class="keyword">new</span> <span class="title class_">Worker</span>(key)) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String key ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String key)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.key = key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!set.contains(key))&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//数据库查询</span></span><br><span class="line">			<span class="keyword">if</span>(queryDB(key))&#123;</span><br><span class="line">				set.add(key);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//达到某种条件时清空 set</span></span><br><span class="line">		<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">			set = <span class="literal">null</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致的流程如下：</p>
<ul>
<li>源源不断的从 MQ 中获取数据。</li>
<li>将数据丢到业务线程池中。</li>
<li>判断数据是否已经写入了 <code>Set</code>。</li>
<li>没有则查询数据库。</li>
<li>之后写入到 <code>Set</code> 中。</li>
</ul>
<p>这里有一个很明显的问题，<strong>那就是作为共享资源的 Set 并没有做任何的同步处理</strong>。</p>
<p>这里会有多个线程并发的操作，由于 <code>HashSet</code> 其实本质上就是 <code>HashMap</code>，所以它肯定是线程不安全的，所以会出现两个问题：</p>
<ul>
<li>Set 中的数据在并发写入时被覆盖导致数据不准确。</li>
<li><strong>会在扩容的时候形成环形链表</strong>。</li>
</ul>
<p>第一个问题相对于第二个还能接受。</p>
<p>通过上文的内存分析我们已经知道这个 set 中的数据已经不少了。同时由于初始化时并没有指定大小，仅仅只是默认值，所以在大量的并发写入时候会导致频繁的扩容，而在 1.7 的条件下又可能会形成<strong>环形链表</strong>。</p>
<p>不巧的是代码中也有查询操作（<code>contains()</code>）,观察上文的堆栈情况：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c67e5a9b5.jpg"></p>
<p>发现是运行在 <code>HashMap</code> 的 465 行，来看看 1.7 中那里具体在做什么：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c687f186c.jpg"></p>
<p>已经很明显了。这里在遍历链表，同时由于形成了环形链表导致这个 <code>e.next</code> 永远不为空，所以这个循环也不会退出了。</p>
<p>到这里其实已经找到问题了，但还有一个疑问是为什么线程池里的任务队列会越堆越多。我第一直觉是任务执行太慢导致的。</p>
<p>仔细查看了代码发现只有一个地方可能会慢：也就是有一个<strong>数据库的查询</strong>。</p>
<p>把这个 SQL 拿到生产环境执行发现确实不快，查看索引发现都有命中。</p>
<p>但我一看表中的数据发现已经快有 <strong>7000W</strong> 的数据了。同时经过运维得知 <code>MySQL</code> 那台服务器的 <code>IO</code> 压力也比较大。</p>
<p>所以这个原因也比较明显了：</p>
<blockquote>
<p> 由于每消费一条数据都要去查询一次数据库，MySQL 本身压力就比较大，加上数据量也很高所以导致这个 IO 响应较慢，导致整个任务处理的就比较慢了。</p>
</blockquote>
<p>但还有一个原因也不能忽视；由于所有的业务线程在某个时间点都进入了死循环，根本没有执行完任务的机会，而后面的数据还在源源不断的进入，所以这个队列只会越堆越多！</p>
<p>这其实是一个老应用了，可能会有人问为什么之前没出现问题。</p>
<p>这是因为之前数据量都比较少，即使是并发写入也没有出现并发扩容形成环形链表的情况。这段时间业务量的暴增正好把这个隐藏的雷给揪出来了。所以还是得信墨菲他老人家的话。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此整个排查结束，而我们后续的调整措施大概如下：</p>
<ul>
<li><code>HashSet</code> 不是线程安全的，换为 <code>ConcurrentHashMap</code>同时把 <code>value</code> 写死一样可以达到 <code>set</code> 的效果。</li>
<li>根据我们后面的监控，初始化 <code>ConcurrentHashMap</code> 的大小尽量大一些，避免频繁的扩容。</li>
<li><code>MySQL</code> 中很多数据都已经不用了，进行冷热处理。尽量降低单表数据量。同时后期考虑分表。</li>
<li>查数据那里调整为查缓存，提高查询效率。</li>
<li>线程池的名称一定得取的有意义，不然是自己给自己增加难度。</li>
<li>根据监控将线程池的队列大小调整为一个具体值，并且要有拒绝策略。</li>
<li>升级到 <code>JDK1.8</code>。</li>
<li>再一个是报警邮件酌情考虑为电话通知😂。</li>
</ul>
<p><code>HashMap</code> 的死循环问题在网上层出不穷，没想到还真被我遇到了。现在要满足这个条件还是挺少见的，比如 1.8 以下的 <code>JDK</code> 这一条可能大多数人就碰不到，正好又证实了一次墨菲定律。</p>
<p>同时我会将文章更到这里，方便大家阅读和查询。</p>
<p><a href="https://crossoverjie.top/JCSprout/">https://crossoverjie.top/JCSprout/</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>concurrent</tag>
        <tag>HashMap</tag>
        <tag>JVM</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>强如 Disruptor 也发生内存溢出？</title>
    <url>/2018/08/29/java-senior/OOM-Disruptor/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d2226b558.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>OutOfMemoryError</code> 问题相信很多朋友都遇到过，相对于常见的业务异常（数组越界、空指针等）来说这类问题是很难定位和解决的。</p>
<p>本文以最近碰到的一次线上内存溢出的定位、解决问题的方式展开；希望能对碰到类似问题的同学带来思路和帮助。</p>
<p>主要从<code>表现--&gt;排查--&gt;定位--&gt;解决</code> 四个步骤来分析和解决问题。</p>
<span id="more"></span>

<h1 id="表象"><a href="#表象" class="headerlink" title="表象"></a>表象</h1><p>最近我们生产上的一个应用不断的爆出内存溢出，并且随着业务量的增长出现的频次越来越高。</p>
<p>该程序的业务逻辑非常简单，就是从 Kafka 中将数据消费下来然后批量的做持久化操作。</p>
<p>而现象则是随着 Kafka 的消息越多，出现的异常的频次就越快。由于当时还有其他工作所以只能让运维做重启，并且监控好堆内存以及 GC 情况。</p>
<blockquote>
<p>重启大法虽好，可是依然不能根本解决问题。</p>
</blockquote>
<h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>于是我们想根据运维之前收集到的内存数据、GC 日志尝试判断哪里出现问题。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d229ad931.jpg"></p>
<p>结果发现老年代的内存使用就算是发生 GC 也一直居高不下，而且随着时间推移也越来越高。</p>
<p>结合 jstat 的日志发现就算是发生了 FGC 老年代也已经回收不了，内存已经到顶。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d22b93e86.jpg"></p>
<p>甚至有几台应用 FGC 达到了上百次，时间也高的可怕。</p>
<p>这说明应用的内存使用肯定是有问题的，有许多赖皮对象始终回收不掉。</p>
<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>由于生产上的内存 dump 文件非常大，达到了几十G。也是由于我们的内存设置太大有关。</p>
<p>所以导致想使用 MAT 分析需要花费大量时间。</p>
<p>因此我们便想是否可以在本地复现，这样就要好定位的多。</p>
<p>为了尽快的复现问题，我将本地应用最大堆内存设置为 150M。</p>
<p>然后在消费 Kafka 那里 Mock 为一个 while 循环一直不断的生成数据。</p>
<p>同时当应用启动之后利用 VisualVM 连上应用实时监控内存、GC 的使用情况。</p>
<p>结果跑了 10 几分钟内存使用并没有什么问题。根据图中可以看出，每产生一次 GC 内存都能有效的回收，所以这样并没有复现问题。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d22c8db27.jpg"></p>
<p>没法复现问题就很难定位了。于是我们 review 代码，发现生产的逻辑和我们用 while 循环 Mock 数据还不太一样。</p>
<p>查看生产的日志发现每次从 Kafka 中取出的都是几百条数据，而我们 Mock 时每次只能产生<strong>一条</strong>。</p>
<p>为了尽可能的模拟生产情况便在服务器上跑着一个生产者程序，一直源源不断的向 Kafka 中发送数据。</p>
<p>果然不出意外只跑了一分多钟内存就顶不住了，观察左图发现 GC 的频次非常高，但是内存的回收却是相形见拙。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d22d99ae5.jpg"></p>
<p>同时后台也开始打印内存溢出了，这样便复现出问题。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>从目前的表现来看就是内存中有许多对象一直存在强引用关系导致得不到回收。</p>
<p>于是便想看看到底是什么对象占用了这么多的内存，利用 VisualVM 的 HeapDump 功能可以立即 dump 出当前应用的内存情况。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d234c531b.jpg"></p>
<p>结果发现 <code>com.lmax.disruptor.RingBuffer</code> 类型的对象占用了将近 50% 的内存。</p>
<p>看到这个包自然就想到了 <code>Disruptor</code> 环形队列。</p>
<p>再次 review 代码发现：从 Kafka 里取出的 700 条数据是直接往 Disruptor 里丢的。</p>
<p>这里也就能说明为什么第一次模拟数据没复现问题了。</p>
<p>模拟的时候是一个对象放进队列里，而生产的情况是 700 条数据放进队列里。这个数据量是 700 倍的差距。</p>
<p>而 Disruptor 作为一个环形队列，再对象没有被覆盖之前是一直存在的。</p>
<p>我也做了一个实验，证明确实如此。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d235d0fac.jpg"></p>
<p>我设置队列大小为 8 ，从 0~9 往里面写 10 条数据，当写到 8 的时候就会把之前 0 的位置覆盖掉，后面的以此类推（类似于 HashMap 的取模定位）。</p>
<p>所以在生产上假设我们的队列大小是 1024，那么随着系统的运行最终肯定会导致 1024 个位置上装满了对象，而且每个位置是 700 个！</p>
<p>于是查看了生产上 Disruptor 的 RingBuffer 配置，结果是：<code>1024*1024</code>。</p>
<p>这个数量级就非常吓人了。</p>
<p>为了验证是否是这个问题，我在本地将该值换为 2 ，一个最小值试试。</p>
<p>同样的 128M 内存，也是通过 Kafka 一直源源不断的取出数据。通过监控如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2379a1ce.jpg"></p>
<p>跑了 20 几分钟系统一切正常，每当一次 GC 都能回收大部分内存，最终呈现锯齿状。</p>
<p>这样问题就找到了，不过生产上这个值具体设置多少还得根据业务情况测试才能知道，但原有的 1024*1024 是绝对不能再使用了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然到了最后也就改了一行代码(还没改，直接修改配置)，但这排查过程我觉得是有意义的。</p>
<p>也会让大部分觉得 JVM 这样的黑盒难以下手的同学有一个直观的感受。</p>
<p><code>同时也得感叹 Disruptor 东西虽好，也不能乱用哦！</code></p>
<p>相关演示代码查看：</p>
<p><a href="https://github.com/crossoverJie/JCSprout/tree/master/src/main/java/com/crossoverjie/disruptor">https://github.com/crossoverJie/JCSprout/tree/master/src/main/java/com/crossoverjie/disruptor</a></p>
<p><strong>你的点赞与转发是最大的支持。</strong></p>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>concurrent</tag>
        <tag>JVM</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅的使用和理解线程池</title>
    <url>/2018/07/29/java-senior/ThreadPool/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d2a867bea.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时接触过多线程开发的童鞋应该都或多或少了解过线程池，之前发布的《阿里巴巴 Java 手册》里也有一条：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2a8dad64.jpg"></p>
<p>可见线程池的重要性。</p>
<p>简单来说使用线程池有以下几个目的：</p>
<ul>
<li>线程是稀缺资源，不能频繁的创建。</li>
<li>解耦作用；线程的创建于执行完全分开，方便维护。</li>
<li>应当将其放入一个池子中，可以给其他任务进行复用。</li>
</ul>
<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>谈到线程池就会想到池化技术，其中最核心的思想就是把宝贵的资源放到一个池子中；每次使用都从里面获取，用完之后又放回池子供其他人使用，有点吃大锅饭的意思。</p>
<p>那在 Java 中又是如何实现的呢？</p>
<p>在 JDK 1.5 之后推出了相关的 api，常见的创建线程池方式有以下几种：</p>
<ul>
<li><code>Executors.newCachedThreadPool()</code>：无限线程池。</li>
<li><code>Executors.newFixedThreadPool(nThreads)</code>：创建固定大小的线程池。</li>
<li><code>Executors.newSingleThreadExecutor()</code>：创建单个线程的线程池。</li>
</ul>
<span id="more"></span>

<p>其实看这三种方式创建的源码就会发现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上还是利用 <code>ThreadPoolExecutor</code> 类实现的。</p>
<p>所以我们重点来看下 <code>ThreadPoolExecutor</code> 是怎么玩的。</p>
<p>首先是创建线程的 api：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) </span><br></pre></td></tr></table></figure>

<p>这几个核心参数的作用：</p>
<ul>
<li><code>corePoolSize</code> 为线程池的基本大小。</li>
<li><code>maximumPoolSize</code> 为线程池最大线程大小。</li>
<li><code>keepAliveTime</code> 和 <code>unit</code> 则是线程空闲后的存活时间。</li>
<li><code>workQueue</code> 用于存放任务的阻塞队列。</li>
<li><code>handler</code> 当队列和最大线程池都满了之后的饱和策略。</li>
</ul>
<p>了解了这几个参数再来看看实际的运用。</p>
<p>通常我们都是使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadPool.execute(<span class="keyword">new</span> <span class="title class_">Job</span>());</span><br></pre></td></tr></table></figure>

<p>这样的方式来提交一个任务到线程池中，所以核心的逻辑就是 <code>execute()</code> 函数了。</p>
<p>在具体分析之前先了解下线程池中所定义的状态，这些状态都和线程的执行密切相关：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2a9bc566.jpg"></p>
<ul>
<li><code>RUNNING</code> 自然是运行状态，指可以接受任务执行队列里的任务</li>
<li><code>SHUTDOWN</code> 指调用了 <code>shutdown()</code> 方法，不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><code>STOP</code> 指调用了 <code>shutdownNow()</code> 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</li>
<li><code>TIDYING</code> 所有任务都执行完毕，在调用 <code>shutdown()/shutdownNow()</code> 中都会尝试更新为这个状态。</li>
<li><code>TERMINATED</code> 终止状态，当执行 <code>terminated()</code> 后会更新为这个状态。</li>
</ul>
<p>用图表示为：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2aa81655.jpg"></p>
<p>然后看看 <code>execute()</code> 方法是如何处理的：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2ab921db.jpg"></p>
<ol>
<li>获取当前线程池的状态。</li>
<li>当前线程数量小于 coreSize 时创建一个新的线程运行。</li>
<li>如果当前线程处于运行状态，并且写入阻塞队列成功。</li>
<li>双重检查，再次获取线程状态；如果线程状态变了（非运行状态）就需要从阻塞队列移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</li>
<li>如果当前线程池为空就新创建一个线程并执行。</li>
<li>如果在第三步的判断为非运行状态，尝试新建线程，如果失败则执行拒绝策略。</li>
</ol>
<p>这里借助《聊聊并发》的一张图来描述这个流程：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2ac0936c.jpg"></p>
<h3 id="如何配置线程"><a href="#如何配置线程" class="headerlink" title="如何配置线程"></a>如何配置线程</h3><p>流程聊完了再来看看上文提到了几个核心参数应该如何配置呢？</p>
<p>有一点是肯定的，线程池肯定是不是越大越好。</p>
<p>通常我们是需要根据这批任务执行的性质来确定的。</p>
<ul>
<li>IO 密集型任务：由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 * 2 </li>
<li>CPU 密集型任务（大量复杂的运算）应当分配较少的线程，比如 CPU 个数相当的大小。</li>
</ul>
<p>当然这些都是经验值，最好的方式还是根据实际情况测试得出最佳配置。</p>
<h3 id="优雅的关闭线程池"><a href="#优雅的关闭线程池" class="headerlink" title="优雅的关闭线程池"></a>优雅的关闭线程池</h3><p>有运行任务自然也有关闭任务，从上文提到的 5 个状态就能看出如何来关闭线程池。</p>
<p>其实无非就是两个方法 <code>shutdown()/shutdownNow()</code>。</p>
<p>但他们有着重要的区别：</p>
<ul>
<li><code>shutdown()</code> 执行后停止接受新任务，会把队列的任务执行完毕。</li>
<li><code>shutdownNow()</code> 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。</li>
</ul>
<blockquote>
<p>两个方法都会中断线程，用户可自行判断是否需要响应中断。</p>
</blockquote>
<p><code>shutdownNow()</code> 要更简单粗暴，可以根据实际场景选择不同的方法。</p>
<p>我通常是按照以下方式关闭线程池的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    pool.execute(<span class="keyword">new</span> <span class="title class_">Job</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!pool.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;线程还在执行。。。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">LOGGER.info(<span class="string">&quot;一共处理了【&#123;&#125;】&quot;</span>, (end - start));</span><br></pre></td></tr></table></figure>

<p><code>pool.awaitTermination(1, TimeUnit.SECONDS)</code> 会每隔一秒钟检查一次是否执行完毕（状态为 <code>TERMINATED</code>），当从 while 循环退出时就表明线程池已经完全终止了。</p>
<h2 id="SpringBoot-使用线程池"><a href="#SpringBoot-使用线程池" class="headerlink" title="SpringBoot 使用线程池"></a>SpringBoot 使用线程池</h2><p>2018 年了，SpringBoot 盛行；来看看在 SpringBoot 中应当怎么配置和使用线程池。</p>
<p>既然用了 SpringBoot ，那自然得发挥 Spring 的特性，所以需要 Spring 来帮我们管理线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreadPoolConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费队列线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(value = &quot;consumerQueueThreadPool&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ExecutorService <span class="title function_">buildConsumerQueueThreadPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ThreadFactory</span> <span class="variable">namedThreadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                .setNameFormat(<span class="string">&quot;consumer-queue-thread-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">5</span>),namedThreadFactory,<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pool ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource(name = &quot;consumerQueueThreadPool&quot;)</span></span><br><span class="line"><span class="keyword">private</span> ExecutorService consumerQueueThreadPool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        consumerQueueThreadPool.execute(<span class="keyword">new</span> <span class="title class_">ConsumerQueueThread</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实也挺简单，就是创建了一个线程池的 bean，在使用时直接从 Spring 中取出即可。</p>
<h2 id="监控线程池"><a href="#监控线程池" class="headerlink" title="监控线程池"></a>监控线程池</h2><p>谈到了 SpringBoot，也可利用它 actuator 组件来做线程池的监控。</p>
<p>线程怎么说都是稀缺资源，对线程池的监控可以知道自己任务执行的状况、效率等。</p>
<p>关于 actuator 就不再细说了，感兴趣的可以看看<a href="http://t.cn/ReimM0o">这篇</a>，有详细整理过如何暴露监控端点。</p>
<p>其实 ThreadPool 本身已经提供了不少 api 可以获取线程状态：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2accbbcf.jpg"></p>
<p>很多方法看名字就知道其含义，只需要将这些信息暴露到 SpringBoot 的监控端点中，我们就可以在可视化页面查看当前的线程池状态了。</p>
<p>甚至我们可以继承线程池扩展其中的几个函数来自定义监控逻辑：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2add4d31.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2aeea439.jpg"></p>
<p>看这些名称和定义都知道，这是让子类来实现的。</p>
<p>可以在线程执行前、后、终止状态执行自定义逻辑。</p>
<h2 id="线程池隔离"><a href="#线程池隔离" class="headerlink" title="线程池隔离"></a>线程池隔离</h2><blockquote>
<p>线程池看似很美好，但也会带来一些问题。</p>
</blockquote>
<p>如果我们很多业务都依赖于同一个线程池,当其中一个业务因为各种不可控的原因消耗了所有的线程，导致线程池全部占满。</p>
<p>这样其他的业务也就不能正常运转了，这对系统的打击是巨大的。</p>
<p>比如我们 Tomcat 接受请求的线程池，假设其中一些响应特别慢，线程资源得不到回收释放；线程池慢慢被占满，最坏的情况就是整个应用都不能提供服务。</p>
<p>所以我们需要将线程池<strong>进行隔离</strong>。</p>
<p>通常的做法是按照业务进行划分：</p>
<blockquote>
<p>比如下单的任务用一个线程池，获取数据的任务用另一个线程池。这样即使其中一个出现问题把线程池耗尽，那也不会影响其他的任务运行。</p>
</blockquote>
<h3 id="hystrix-隔离"><a href="#hystrix-隔离" class="headerlink" title="hystrix 隔离"></a>hystrix 隔离</h3><p>这样的需求 <a href="https://github.com/Netflix/Hystrix">Hystrix</a> 已经帮我们实现了。</p>
<blockquote>
<p>Hystrix 是一款开源的容错插件，具有依赖隔离、系统容错降级等功能。</p>
</blockquote>
<p>下面来看看 <code>Hystrix</code> 简单的应用：</p>
<p>首先需要定义两个线程池，分别用于执行订单、处理用户。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function:订单服务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> crossoverJie</span></span><br><span class="line"><span class="comment"> *         Date: 2018/7/28 16:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandOrder</span> <span class="keyword">extends</span> <span class="title class_">HystrixCommand</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(CommandOrder.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommandOrder</span><span class="params">(String orderName)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(Setter.withGroupKey(</span><br><span class="line">                <span class="comment">//服务分组</span></span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;OrderGroup&quot;</span>))</span><br><span class="line">                <span class="comment">//线程分组</span></span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">&quot;OrderPool&quot;</span>))</span><br><span class="line"></span><br><span class="line">                <span class="comment">//线程池配置</span></span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(<span class="number">10</span>)</span><br><span class="line">                        .withKeepAliveTimeMinutes(<span class="number">5</span>)</span><br><span class="line">                        .withMaxQueueSize(<span class="number">10</span>)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line">                .andCommandPropertiesDefaults(</span><br><span class="line">                        HystrixCommandProperties.Setter()</span><br><span class="line">                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))</span><br><span class="line">        )</span><br><span class="line">        ;</span><br><span class="line">        <span class="built_in">this</span>.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;orderName=[&#123;&#125;]&quot;</span>, orderName);</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OrderName=&quot;</span> + orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function:用户服务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> crossoverJie</span></span><br><span class="line"><span class="comment"> *         Date: 2018/7/28 16:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandUser</span> <span class="keyword">extends</span> <span class="title class_">HystrixCommand</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(CommandUser.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommandUser</span><span class="params">(String userName)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(Setter.withGroupKey(</span><br><span class="line">                <span class="comment">//服务分组</span></span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;UserGroup&quot;</span>))</span><br><span class="line">                <span class="comment">//线程分组</span></span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">&quot;UserPool&quot;</span>))</span><br><span class="line"></span><br><span class="line">                <span class="comment">//线程池配置</span></span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(<span class="number">10</span>)</span><br><span class="line">                        .withKeepAliveTimeMinutes(<span class="number">5</span>)</span><br><span class="line">                        .withMaxQueueSize(<span class="number">10</span>)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line">                <span class="comment">//线程池隔离</span></span><br><span class="line">                .andCommandPropertiesDefaults(</span><br><span class="line">                        HystrixCommandProperties.Setter()</span><br><span class="line">                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))</span><br><span class="line">        )</span><br><span class="line">        ;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;userName=[&#123;&#125;]&quot;</span>, userName);</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userName=&quot;</span> + userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><code>api</code> 特别简洁易懂，具体详情请查看官方文档。</p>
<p>然后模拟运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">CommandOrder</span> <span class="variable">commandPhone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommandOrder</span>(<span class="string">&quot;手机&quot;</span>);</span><br><span class="line">    <span class="type">CommandOrder</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommandOrder</span>(<span class="string">&quot;电视&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞方式执行</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">execute</span> <span class="operator">=</span> commandPhone.execute();</span><br><span class="line">    LOGGER.info(<span class="string">&quot;execute=[&#123;&#125;]&quot;</span>, execute);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异步非阻塞方式</span></span><br><span class="line">    Future&lt;String&gt; queue = command.queue();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> queue.get(<span class="number">200</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    LOGGER.info(<span class="string">&quot;value=[&#123;&#125;]&quot;</span>, value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">CommandUser</span> <span class="variable">commandUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommandUser</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> commandUser.execute();</span><br><span class="line">    LOGGER.info(<span class="string">&quot;name=[&#123;&#125;]&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>运行结果：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2b06ef2d.jpg"></p>
<p>可以看到两个任务分成了两个线程池运行，他们之间互不干扰。</p>
<p>获取任务任务结果支持同步阻塞和异步非阻塞方式，可自行选择。</p>
<p>它的实现原理其实容易猜到：</p>
<blockquote>
<p>利用一个 Map 来存放不同业务对应的线程池。</p>
</blockquote>
<p>通过刚才的构造函数也能证明：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2b69cd32.jpg"></p>
<p>还要注意的一点是：</p>
<blockquote>
<p>自定义的 Command 并不是一个单例，每次执行需要 new 一个实例，不然会报 <code> This instance can only be executed once. Please instantiate a new instance.</code> 异常。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>池化技术确实在平时应用广泛，熟练掌握能提高不少效率。</p>
<p>文末的 hystrix 源码：</p>
<p><a href="https://github.com/crossoverJie/Java-Interview/tree/master/src/main/java/com/crossoverjie/hystrix">https://github.com/crossoverJie/Java-Interview/tree/master/src/main/java/com/crossoverjie/hystrix</a></p>
<p>最后插播个小广告：</p>
<p><a href="https://github.com/crossoverJie/Java-Interview">Java-Interview</a> 截止目前将近 8K star。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2b777ec3.jpg"></p>
<p>这次定个小目标：争取冲击 <code>1W star</code>。</p>
<p>感谢各位老铁的支持与点赞。</p>
<p><strong>欢迎关注公众号一起交流：</strong></p>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>ThreadPool</tag>
        <tag>Hystirx</tag>
      </tags>
  </entry>
  <entry>
    <title>不改一行代码定位线上性能问题</title>
    <url>/2018/11/12/java-senior/coding-online-analysis/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1c65a7d9df.jpg"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近时运不佳，几乎天天被线上问题骚扰。前几天刚解决了一个 <a href="https://crossoverjie.top/2018/11/08/java-senior/JVM-concurrent-HashSet-problem/">HashSet 的并发</a>问题，周六又来了一个性能问题。</p>
<p>大致的现象是：</p>
<blockquote>
<p>我们提供出去的一个 OpenAPI 反应时快时慢，快的时候几十毫秒，慢的时候几秒钟才响应。</p>
</blockquote>
<h1 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h1><p>由于这种也不是业务问题，不能直接定位。所以尝试在测试环境复现，但遗憾的测试环境贼快。</p>
<p>没办法只能硬着头皮上了。</p>
<p>中途有抱着侥幸心里让运维查看了 <code>Nginx</code> 里 <code>OpenAPI</code> 的响应时间，想把锅扔给网络。结果果然打脸了；<code>Nginx</code> 里的日志也表明确实响应时间确实有问题。</p>
<span id="more"></span>

<p>为了清晰的了解这个问题，我简单梳理了这个调用过程。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c65c82a8f.jpg"></p>
<p>整个的流程算是比较常见的分层架构：</p>
<ul>
<li>客户端请求到 <code>Nginx</code>。</li>
<li><code>Nginx</code> 负载了后端的 <code>web</code> 服务。</li>
<li><code>web</code> 服务通过 <code>RPC</code> 调用后端的 <code>Service</code> 服务。</li>
</ul>
<h2 id="日志大法"><a href="#日志大法" class="headerlink" title="日志大法"></a>日志大法</h2><p>我们首先想到的是打日志，在可能会慢的方法或接口处记录处理时间来判断哪里有问题。</p>
<p>但通过刚才的调用链来说，这个请求流程不短。加日志涉及的改动较多而且万一加漏了还有可能定位不到问题。</p>
<p>再一个是改动代码之后还会涉及到发版上线。</p>
<h2 id="工具分析"><a href="#工具分析" class="headerlink" title="工具分析"></a>工具分析</h2><p>所以最好的方式就是不改动一行代码把这个问题分析出来。</p>
<p>这时就需要一个 <code>agent</code> 工具了。我们选用了阿里以前开源的  <a href="https://github.com/alibaba/TProfiler">Tprofile</a> 来使用。</p>
<p>只需要在启动参数中加入 <code>-javaagent:/xx/tprofiler.jar</code> 即可监控你想要监控的方法耗时，并且可以给你输出报告，非常方便。对代码没有任何侵入性同时性能影响也较小。</p>
<h1 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h1><p>下面来简单展示下如何使用这个工具。</p>
<p>首先第一步自然是 <code>clone</code> 源码然后打包，可以克隆我修改过的源码。</p>
<blockquote>
<p>因为这个项目阿里多年没有维护了，还残留一些 <code>bug</code>,我在它原有的基础上修复了个影响使用的 <code>bug</code>，同时做了一些优化。</p>
</blockquote>
<p>执行以下脚本即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/crossoverJie/TProfiler</span><br><span class="line"></span><br><span class="line">mvn assembly:assembly</span><br></pre></td></tr></table></figure>

<p>到这里之后会在项目的 <code>TProfiler/pkg/TProfiler/lib/tprofiler-1.0.1.jar</code> 中生成好我们要使用的 jar 包。</p>
<p>接下来只需要将这个 jar 包配置到启动参数中，同时再配置一个配置文件路径即可。</p>
<p>这个配置文件我 copy 官方的解释。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#log file name</span></span><br><span class="line"><span class="attr">logFileName</span> = <span class="string">tprofiler.log</span></span><br><span class="line"><span class="attr">methodFileName</span> = <span class="string">tmethod.log</span></span><br><span class="line"><span class="attr">samplerFileName</span> = <span class="string">tsampler.log</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#basic configuration items</span></span><br><span class="line"><span class="comment"># 开始取样时间</span></span><br><span class="line"><span class="attr">startProfTime</span> = <span class="string">1:00:00</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 结束取样时间</span></span><br><span class="line"><span class="attr">endProfTime</span> = <span class="string">23:00:00</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 取样的时间长度</span></span><br><span class="line"><span class="attr">eachProfUseTime</span> = <span class="string">10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 每次取样的时间间隔</span></span><br><span class="line"><span class="attr">eachProfIntervalTime</span> = <span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">samplerIntervalTime</span> = <span class="string">20</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 端口，主要不要冲突了</span></span><br><span class="line"><span class="attr">port</span> = <span class="string">50000</span></span><br><span class="line"><span class="attr">debugMode</span> = <span class="string">false</span></span><br><span class="line"><span class="attr">needNanoTime</span> = <span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 是否忽略 get set 方法</span></span><br><span class="line"><span class="attr">ignoreGetSetMethod</span> = <span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#file paths 日志路径</span></span><br><span class="line"><span class="attr">logFilePath</span> = <span class="string">/data/work/logs/tprofile/$&#123;logFileName&#125;</span></span><br><span class="line"><span class="attr">methodFilePath</span> =<span class="string">/data/work/logs/tprofile/$&#123;methodFileName&#125;</span></span><br><span class="line"><span class="attr">samplerFilePath</span> =<span class="string">/data/work/logs/tprofile/$&#123;samplerFileName&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#include &amp; excludes items</span></span><br><span class="line"><span class="attr">excludeClassLoader</span> = <span class="string">org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 需要监控的包</span></span><br><span class="line"><span class="attr">includePackageStartsWith</span> = <span class="string">top.crossoverjie.cicada.example.action</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 不需要监控的包</span></span><br><span class="line"><span class="attr">excludePackageStartsWith</span> = <span class="string">com.taobao.sketch;org.apache.velocity;com.alibaba;com.taobao.forest.domain.dataobject</span></span><br></pre></td></tr></table></figure>

<p>最终的启动参数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-javaagent:/TProfiler/lib/tprofiler-<span class="number">1.0</span><span class="number">.1</span>.jar</span><br><span class="line">-Dprofile.properties=/TProfiler/profile.properties</span><br></pre></td></tr></table></figure>

<p>为了模拟排查接口响应慢的问题，我用 <a href="https://github.com/TogetherOS/cicada">cicada</a> 实现了一个 <code>HTTP</code> 接口。其中调用了两个耗时方法：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c65e8d995.jpg"></p>
<p>这样当我启动应用时，<code>Tprofile</code> 就会在我配置的目录记录它所收集的方法信息。</p>
<p>我访问接口 <code>http://127.0.0.1:5688/cicada-example/demoAction?name=test&amp;id=10</code> 几次后它就会把每个方法的明细响应写入 <code>tprofile.log</code>。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c65f6352a.jpg"></p>
<p>由左到右每列分别代表为：</p>
<p>线程ID、方法栈深度、方法编号、耗时（毫秒）。</p>
<p>但 <code>tmethod.log</code> 还是空的；</p>
<p>这时我们只需要执行这个命令即可把最新的方法采样信息刷到 <code>tmethod.log</code> 文件中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp /TProfiler/tprofiler.jar com.taobao.profile.client.TProfilerClient <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">50000</span> flushmethod</span><br><span class="line"></span><br><span class="line">flushmethod success</span><br></pre></td></tr></table></figure>

<p>其实就是访问了 <code>Tprofile</code> 暴露出的一个服务，他会读取、解析 <code>tprofile.log</code> 同时写入 <code>tmethod.log</code>.</p>
<blockquote>
<p>其中的端口就是配置文件中的 port。</p>
</blockquote>
<p>再打开 <code>tmethod.log</code> ：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c66074125.jpg"></p>
<p>其中会记录方法的信息。</p>
<ul>
<li>第一行数字为方法的编号。可以通过这个编号去 <code>tprofile.log</code>(明细)中查询每次的耗时情况。</li>
<li>行末的数字则是这个方法在源码中最后一行的行号。</li>
</ul>
<p>其实大部分的性能分析都是统计某个方法的平均耗时。</p>
<p>所以还需要执行下面的命令，通过 <code>tmethod.log tprofile.log </code>来生成每个方法的平均耗时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp /TProfiler/tprofiler.jar com.taobao.profile.analysis.ProfilerLogAnalysis tprofiler.log tmethod.log topmethod.log topobject.log</span><br><span class="line">print result success</span><br></pre></td></tr></table></figure>

<p>打开 <code>topmethod.log</code> 就是所有方法的平均耗时。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c66707fb8.jpg"></p>
<ul>
<li>4 为请求次数。</li>
<li>205 为平均耗时。</li>
<li>818 则为总耗时。</li>
</ul>
<p>和实际情况是相符的。</p>
<h2 id="方法的明细耗时"><a href="#方法的明细耗时" class="headerlink" title="方法的明细耗时"></a>方法的明细耗时</h2><p>这是可能还会有其他需求；比如说我想查询某个方法所有的明细耗时怎么办呢？</p>
<p>官方没有提供，但也是可以的，只是要麻烦一点。</p>
<p>比如我想查看 <code>selectDB()</code> 的耗时明细：</p>
<p>首先得知道这个方法的编号，在 <code>tmethod.log</code> 中可以看查到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> top/crossoverjie/cicada/example/action/DemoAction:selectDB:<span class="number">84</span></span><br></pre></td></tr></table></figure>

<p>编号为 2.</p>
<p>之前我们就知道 <code>tprofile.log</code> 记录的是明细，所以通过下面的命令即可查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep 2 tprofiler.log</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/05/08/5cd1c668a6d28.jpg"></p>
<p>通过第三列方法编号为 2 的来查看每次执行的明细。</p>
<p>但这样的方式显然不够友好，需要人为来过滤干扰，步骤也多；所以我也准备加上这样一个功能。</p>
<p>只需要传入一个方法名称即可查询采集到的所有方法耗时明细。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回到之前的问题；线上通过这个工具分析我们得到了如下结果。</p>
<ul>
<li>有些方法确实执行时快时慢，但都是和数据库相关的。由于目前数据库压力较大，准备在接下来进行冷热数据分离，以及分库分表。</li>
<li>在第一步操作还没实施之前将部分写数据库的操作改为异步，减小响应时间。</li>
<li>考虑接入 <code>pinpoint</code> 这样的 <code>APM工具</code>。</li>
</ul>
<p>类似于 <a href="https://github.com/crossoverJie/TProfiler">Tprofile</a> 的工具确实挺多的，找到适合自己的就好。</p>
<p>在还没有使用类似于 <code>pinpoint</code> 这样的分布式跟踪工具之前应该会大量依赖于这个工具，所以后续说不定也会做一些定制，比如增加一些可视化界面等，可以提高排查效率。</p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>Tprofile</tag>
      </tags>
  </entry>
  <entry>
    <title>一份针对于新手的多线程实践</title>
    <url>/2018/10/29/java-senior/concurrent-in-action/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1c697587d0.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://i.loli.net/2019/05/08/5cd1c69801b99.jpg"></p>
<p>前段时间在某个第三方平台看到我写作字数居然突破了 10W 字，难以想象高中 800 字作文我都得巧妙的<strong>利用换行</strong>来完成(懂的人肯定也干过😏)。</p>
<p>干了这行养成了一个习惯：能撸码验证的事情都自己验证一遍。</p>
<p>于是在上周五通宵加班的空余时间写了一个工具：</p>
<p><a href="https://github.com/crossoverJie/NOWS">https://github.com/crossoverJie/NOWS</a></p>
<p>利用 <code>SpringBoot</code> 只需要一行命令即可统计自己写了多少个字。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar nows-0.0.1-SNAPSHOT.jar /xx/Hexo/source/_posts</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>传入需要扫描的文章目录即可输出结果（目前只支持 <code>.md</code> 结尾 <code>Markdown</code> 文件）</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c69c8aeb9.jpg"></p>
<p>当然结果看个乐就行（40 几万字），因为早期的博客我喜欢大篇的贴代码，还有一些英文单词也没有过滤，所以导致结果相差较大。</p>
<blockquote>
<p>如果仅仅只是中文文字统计肯定是准的，并且该工具内置灵活的扩展方式，使用者可以自定义统计策略，具体请看后文。</p>
</blockquote>
<p>其实这个工具挺简单的，代码量也少，没有多少可以值得拿出来讲的。但经过我回忆不管是面试还是和网友们交流都发现一个普遍的现象：</p>
<blockquote>
<p>大部分<strong>新手开发</strong>都会去看多线程、但几乎都没有相关的实践。甚至有些都不知道多线程拿来在实际开发中有什么用。</p>
</blockquote>
<p>为此我想基于这个简单的工具为这类朋友带来一个可实践、易理解的多线程案例。</p>
<p>至少可以让你知道：</p>
<ul>
<li>为什么需要多线程？</li>
<li>怎么实现一个多线程程序？</li>
<li>多线程带来的问题及解决方案？</li>
</ul>
<h1 id="单线程统计"><a href="#单线程统计" class="headerlink" title="单线程统计"></a>单线程统计</h1><p>再谈多线程之前先来聊聊单线程如何实现。</p>
<p>本次的需求也很简单，只是需要扫描一个目录读取下面的所有文件即可。</p>
<p>所有我们的实现有以下几步：</p>
<ul>
<li>读取某个目录下的所有文件。</li>
<li>将所有文件的路径保持到内存。</li>
<li>遍历所有的文件挨个读取文本记录字数即可。</li>
</ul>
<p>先来看前两个如何实现，并且当扫描到目录时需要继续读取当前目录下的文件。</p>
<p>这样的场景就非常适合递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getAllFile</span><span class="params">(String path)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path) ;</span><br><span class="line">        File[] files = f.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory())&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">directoryPath</span> <span class="operator">=</span> file.getPath();</span><br><span class="line">                getAllFile(directoryPath);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> file.getPath();</span><br><span class="line">                <span class="keyword">if</span> (!filePath.endsWith(<span class="string">&quot;.md&quot;</span>))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                allFile.add(filePath) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> allFile ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取之后将文件的路径保持到一个集合中。</p>
<blockquote>
<p>需要注意的是这个递归次数需要控制下，避免出现栈溢出(<code>StackOverflow</code>)。</p>
</blockquote>
<p>最后读取文件内容则是使用 <code>Java8</code> 中的流来进行读取，这样代码可以更简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = Files.lines(Paths.get(path), StandardCharsets.UTF_8);</span><br><span class="line">List&lt;String&gt; collect = stringStream.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>接下来便是读取字数，同时要过滤一些特殊文本（比如我想过滤掉所有的空格、换行、超链接等）。</p>
<h1 id="扩展能力"><a href="#扩展能力" class="headerlink" title="扩展能力"></a>扩展能力</h1><p>简单处理可在上面的代码中遍历 <code>collect</code> 然后把其中需要过滤的内容替换为空就行。</p>
<p>但每个人的想法可能都不一样。比如我只想过滤掉<code>空格、换行、超链接</code>就行了，但有些人需要去掉其中所有的英文单词，甚至换行还得留着（就像写作文一样可以充字数）。</p>
<p>所有这就需要一个比较灵活的处理方式。</p>
<p>看过上文<a href="https://crossoverjie.top/2018/10/22/wheel/cicada5/">《利用责任链模式设计一个拦截器》</a>应该很容易想到这样的场景责任链模式再合适不过了。</p>
<p>关于<code>责任链模式</code>具体的内容就不在详述了，感兴趣的可以查看<a href="https://crossoverjie.top/2018/10/22/wheel/cicada5/">上文</a>。</p>
<p>这里直接看实现吧：</p>
<p>定义责任链的抽象接口及处理方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FilterProcess</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">process</span><span class="params">(String msg)</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>处理空格和换行的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrapFilterProcess</span> <span class="keyword">implements</span> <span class="title class_">FilterProcess</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">process</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        msg = msg.replaceAll(<span class="string">&quot;\\s*&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msg ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>处理超链接的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpFilterProcess</span> <span class="keyword">implements</span> <span class="title class_">FilterProcess</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">process</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        msg = msg.replaceAll(<span class="string">&quot;^((https|http|ftp|rtsp|mms)?:\\/\\/)[^\\s]+&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msg ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>这样在初始化时需要将这些处理 <code>handle</code> 都加入责任链中，同时提供一个 <code>API</code> 供客户端执行即可。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c69e73410.jpg"></p>
<p>这样一个简单的统计字数的工具就完成了。</p>
<h1 id="多线程模式"><a href="#多线程模式" class="headerlink" title="多线程模式"></a>多线程模式</h1><p>在我本地一共就几十篇博客的条件下执行一次还是很快的，但如果我们的文件是几万、几十万甚至上百万呢。</p>
<p>虽然功能可以实现，但可以想象这样的耗时绝对是成倍的增加。</p>
<p>这时多线程就发挥优势了，由多个线程分别去读取文件最后汇总结果即可。</p>
<p>这样实现的过程就变为：</p>
<ul>
<li>读取某个目录下的所有文件。</li>
<li>将文件路径交由不同的线程自行处理。</li>
<li>最终汇总结果。</li>
</ul>
<h2 id="多线程带来的问题"><a href="#多线程带来的问题" class="headerlink" title="多线程带来的问题"></a>多线程带来的问题</h2><p>也不是使用多线程就万事大吉了，先来看看第一个问题：共享资源。</p>
<p>简单来说就是怎么保证多线程和单线程统计的总字数是一致的。</p>
<p>基于我本地的环境先看看单线程运行的结果：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6a0cf61d.jpg"></p>
<p>总计为：414142 字。</p>
<p>接下来换为多线程的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; allFile = scannerFile.getAllFile(strings[<span class="number">0</span>]);</span><br><span class="line">logger.info(<span class="string">&quot;allFile size=[&#123;&#125;]&quot;</span>,allFile.size());</span><br><span class="line"><span class="keyword">for</span> (String msg : allFile) &#123;</span><br><span class="line">	executorService.execute(<span class="keyword">new</span> <span class="title class_">ScanNumTask</span>(msg,filterProcessManager));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScanNumTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ScanNumTask.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FilterProcessManager filterProcessManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScanNumTask</span><span class="params">(String path, FilterProcessManager filterProcessManager)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.path = path;</span><br><span class="line">        <span class="built_in">this</span>.filterProcessManager = filterProcessManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; stringStream = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stringStream = Files.lines(Paths.get(path), StandardCharsets.UTF_8);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;IOException&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; collect = stringStream.collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">for</span> (String msg : collect) &#123;</span><br><span class="line">            filterProcessManager.process(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>使用线程池管理线程，更多线程池相关的内容请看这里：<a href="https://crossoverjie.top/2018/07/29/java-senior/ThreadPool/">《如何优雅的使用和理解线程池》</a></p>
</blockquote>
<p>执行结果：<br><img src="https://i.loli.net/2019/05/08/5cd1c6a7b0f8f.jpg"></p>
<p>我们会发现无论执行多少次，这个值都会小于我们的预期值。</p>
<p>来看看统计那里是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TotalWords</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        sum += count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">total</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到就是对一个基本类型进行累加而已。那导致这个值比预期小的原因是什么呢？</p>
<p>我想大部分人都会说：多线程运行时会导致有些线程把其他线程运算的值覆盖。</p>
<blockquote>
<p>但其实这只是导致这个问题的表象，根本原因还是没有讲清楚。</p>
</blockquote>
<h2 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h2><p>核心原因其实是由 Java 内存模型（<code>JMM</code>）的规定导致的。</p>
<p>这里引用一段之前写的<a href="https://crossoverjie.top/2018/03/09/volatile/">《你应该知道的 volatile 关键字》</a>一段解释：</p>
<blockquote>
<p>由于 <code>Java</code> 内存模型(<code>JMM</code>)规定，所有的变量都存放在主内存中，而每个线程都有着自己的工作内存(高速缓存)。</p>
</blockquote>
<blockquote>
<p>线程在工作时，需要将主内存中的数据拷贝到工作内存中。这样对数据的任何操作都是基于工作内存(效率提高)，并且不能直接操作主内存以及其他线程工作内存中的数据，之后再将更新之后的数据刷新到主内存中。</p>
</blockquote>
<blockquote>
<blockquote>
<p>这里所提到的主内存可以简单认为是<strong>堆内存</strong>，而工作内存则可以认为是<strong>栈内存</strong>。</p>
</blockquote>
</blockquote>
<blockquote>
<p>如下图所示：</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6a9c6546.jpg"></p>
<blockquote>
<p>所以在并发运行时可能会出现线程 B 所读取到的数据是线程 A 更新之前的数据。</p>
</blockquote>
<p>更多相关内容就不再展开了，感兴趣的朋友可以翻翻以前的博文。</p>
<p>直接来说如何解决这个问题吧，JDK 其实已经帮我们想到了这些问题。</p>
<p>在 <code>java.util.concurrent</code> 并发包下有许多你可能会使用到的并发工具。</p>
<p>这里就非常适合 <code>AtomicLong</code>，它可以原子性的对数据进行修改。</p>
<p>来看看修改后的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TotalWords</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>() ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        sum.addAndGet(count) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">long</span> <span class="title function_">total</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum.get() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是使用了它的两个 <code>API</code> 而已。再来运行下程序会发现<strong>结果居然还是不对</strong>。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6ac29d9f.jpg"></p>
<p>甚至为 0 了。</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>这时又出现了一个新的问题，来看看获取总计数据是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; allFile = scannerFile.getAllFile(strings[<span class="number">0</span>]);</span><br><span class="line">logger.info(<span class="string">&quot;allFile size=[&#123;&#125;]&quot;</span>,allFile.size());</span><br><span class="line"><span class="keyword">for</span> (String msg : allFile) &#123;</span><br><span class="line">	executorService.execute(<span class="keyword">new</span> <span class="title class_">ScanNumTask</span>(msg,filterProcessManager));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executorService.shutdown();</span><br><span class="line"><span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> totalWords.total();</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">logger.info(<span class="string">&quot;total sum=[&#123;&#125;],[&#123;&#125;] ms&quot;</span>,total,end-start);</span><br></pre></td></tr></table></figure>

<p>不知道大家看出问题没有，其实是在最后打印总数时并不知道其他线程是否已经执行完毕了。</p>
<p>因为 <code>executorService.execute()</code> 会直接返回，所以当打印获取数据时还没有一个线程执行完毕，也就导致了这样的结果。</p>
<p>关于线程间通信之前我也写过相关的内容：<a href="https://crossoverjie.top/2018/03/16/java-senior/thread-communication/">《深入理解线程通信》</a></p>
<p>大概的方式有以下几种：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6ad47413.jpg"></p>
<p>这里我们使用线程池的方式：</p>
<p>在停用线程池后加上一个判断条件即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">executorService.shutdown();</span><br><span class="line"><span class="keyword">while</span> (!executorService.awaitTermination(<span class="number">100</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">	logger.info(<span class="string">&quot;worker running&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> totalWords.total();</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">logger.info(<span class="string">&quot;total sum=[&#123;&#125;],[&#123;&#125;] ms&quot;</span>,total,end-start);</span><br></pre></td></tr></table></figure>

<p>这样我们再次尝试，发现无论多少次结果都是正确的了：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6b0c711c.jpg"></p>
<h2 id="效率提升"><a href="#效率提升" class="headerlink" title="效率提升"></a>效率提升</h2><p>可能还会有朋友问，这样的方式也没见提升多少效率啊。</p>
<p>这其实是由于我本地文件少，加上一个文件处理的耗时也比较短导致的。</p>
<p>甚至线程数开的够多导致频繁的上下文切换还是让执行效率降低。</p>
<p>为了模拟效率的提升，每处理一个文件我都让当前线程休眠 100 毫秒来模拟执行耗时。</p>
<p>先看单线程运行需要耗时多久。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6b2e840c.jpg"></p>
<p>总共耗时：<code>[8404] ms</code></p>
<p>接着在线程池大小为 4 的情况下耗时：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6bc142b3.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6bfdb822.jpg"></p>
<p>总共耗时：<code>[2350] ms</code></p>
<p>可见效率提升还是非常明显的。</p>
<h1 id="更多思考"><a href="#更多思考" class="headerlink" title="更多思考"></a>更多思考</h1><p>这只是多线程其中的一个用法，相信看到这里的朋友应该多它的理解更进一步了。</p>
<p>再给大家留个阅后练习，场景也是类似的：</p>
<blockquote>
<p>在 Redis 或者其他存储介质中存放有上千万的手机号码数据，每个号码都是唯一的，需要在最快的时间内把这些号码全部都遍历一遍。</p>
</blockquote>
<p>有想法感兴趣的朋友欢迎在文末留言参与讨论🤔🤨。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>希望看完的朋友心中能对文初的几个问题能有自己的答案：</p>
<ul>
<li>为什么需要多线程？</li>
<li>怎么实现一个多线程程序？</li>
<li>多线程带来的问题及解决方案？</li>
</ul>
<p>文中的代码都在此处。</p>
<p><a href="https://github.com/crossoverJie/NOWS">https://github.com/crossoverJie/NOWS</a></p>
<p><strong>你的点赞与转发是最大的支持。</strong></p>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>ThreadPool</tag>
      </tags>
  </entry>
  <entry>
    <title>一份针对于新手的多线程实践--进阶篇</title>
    <url>/2018/10/31/java-senior/concurrent-in-action2/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d10a48d3c.jpg" alt="img"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上文<a href="https://crossoverjie.top/2018/10/29/java-senior/concurrent-in-action/#%E6%9B%B4%E5%A4%9A%E6%80%9D%E8%80%83">《一份针对于新手的多线程实践》</a>留下了一个问题：</p>
<blockquote>
<p>这只是多线程其中的一个用法，相信看到这里的朋友应该多它的理解更进一步了。</p>
<p>再给大家留个阅后练习，场景也是类似的：</p>
<blockquote>
<p>在 Redis 或者其他存储介质中存放有上千万的手机号码数据，每个号码都是唯一的，需要在最快的时间内把这些号码全部都遍历一遍。</p>
</blockquote>
<p>有想法感兴趣的朋友欢迎在文末留言参与讨论🤔🤨。</p>
</blockquote>
<h2 id="网友们的方案"><a href="#网友们的方案" class="headerlink" title="网友们的方案"></a>网友们的方案</h2><span id="more"></span>

<p>我在公众号以及其他一些平台收到了大家的回复，果然是<code>众人拾柴火焰高</code>啊。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c68e16cf8.jpg"></p>
<hr>
<p><img src="https://i.loli.net/2019/05/08/5cd1c698514ba.jpg"></p>
<hr>
<p><img src="https://i.loli.net/2019/05/08/5cd1c69b3e818.jpg"></p>
<hr>
<p>感谢每一位参与的朋友。</p>
<p>其实看了大家的方案大多都想到了数据肯定要分段，因为大量的数据肯定没法一次性 <code>load</code> 到内存。</p>
<p>但怎么加载就要考虑清楚了，有些人说放在数据库中通过分页的方式进行加载，然后将每页的数据丢到一个线程里去做遍历。</p>
<p>其实想法挺不错的，但有个问题就是：</p>
<blockquote>
<p>这样肯定会导致有一个主线程去遍历所有的号码，即便是分页查询的那也得全部查询一遍，效率还是很低。</p>
<p>即便是分页加载号码用多线程，那就会涉及到锁的问题，怎么保证每个线程读取的数据是互不冲突的。</p>
</blockquote>
<p>但如果存储换成 <code>Redis</code> 的 <code>String</code> 结构这样就更行不通了。</p>
<h1 id="遍历数据方案"><a href="#遍历数据方案" class="headerlink" title="遍历数据方案"></a>遍历数据方案</h1><p>有没有一种利用多线程加载效率高，并且线程之间互相不需要竞争锁的方案呢？</p>
<p>下面来看看这个方案：</p>
<p>首先在存储这千万号码的时候我们把它的号段单独提出来并冗余存储一次。</p>
<p>比如有个号码是 <code>18523981123</code> 那么就还需要存储一个号段：<code>1852398</code>。</p>
<p>这样当我们有以下这些号码时：</p>
<p><code>18523981123 18523981124 18523981125 13123874321 13123874322 13123874323</code></p>
<p>我们就还会维护一个号段数据为：</p>
<p><code>1852398 1312387</code></p>
<p>这样我想大家应该明白下一步应当怎么做了吧。</p>
<p>在需要遍历时：</p>
<ul>
<li>通过主线程先把所有的号段加载到内存，即便是千万的号码号段也顶多几千条数据。</li>
<li>遍历这个号段，将每个号段提交到一个 <code>task</code> 线程中。</li>
<li>由这个线程通过号段再去查询真正的号码进行遍历。</li>
<li>最后所有的号段都提交完毕再等待所有的线程执行完毕即可遍历所有的号码。</li>
</ul>
<p>这样做的根本原因其实是避免了线程之间加锁，通过号段可以让每个线程只取自己那一部分数据。</p>
<p>可能会有人说，如果号码持续增多导致号段的数据也达到了上万甚至几十万这怎么办呢？</p>
<p>那其实也是同样的思路，可以再把号段进行拆分。</p>
<p>比如之前是 <code>1852398</code> 的号段，那我继续拆分为 <code>1852</code> 。</p>
<p>这样只需要在之前的基础上再启动一个线程去查询子号段即可，有点 <code>fork/join</code> 的味道。</p>
<blockquote>
<p>这样的思路其实也和 JDK1.7 中的 ConcurrentHashMap 类似，定位一个真正的数据需要两次定位。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/08/5cd1c69cd14d7.jpg"></p>
<h1 id="分布式方案"><a href="#分布式方案" class="headerlink" title="分布式方案"></a>分布式方案</h1><p>上面的方案也是由局限性的，毕竟说到底还是一个单机应用。没法扩展；处理的数据始终是有上限。</p>
<p>这个上限就和服务器的配置以及线程数这些相关，说的高大上一点其实就是<code>垂直扩展</code>增加单机的处理性能。</p>
<p>因此随着数据量的提升我们肯定得需要通过<code>水平扩展</code>的方式才能达到最好的性能，这就是分布式的方案。</p>
<p>假设我现在有上亿的数据需要遍历，但我当前的服务器配置只能支撑一个应用启动 N 个线程 5 分钟跑<code>5000W</code> 的数据。</p>
<p>于是我水平扩展，在三台服务器上启动了三个独立的进程。假设一个应用能跑 5000W ，那么理论上来说三个应用就可以跑<strong>1.5亿</strong>的数据了。</p>
<p>但这个的前提还是和上文一样：每个应用只能<strong>处理自己的数据</strong>，不能出现加锁的情况（这样会大大的降低性能）。</p>
<p>所以我们得对刚才的号段进行分组。</p>
<p>先通过一张图来直观的表示这个逻辑：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c69f810e6.jpg"></p>
<p>假设现在我有 9 个号段，那么我就得按照图中的方式把数据隔离开来。</p>
<p>第一个数据给应用0，第二个数据给应用1，第三个数据给应用2。后面的数据以此类推（就是一个简单的取模运算）。</p>
<p>这样就可以将号段均匀的分配给不同的应用来进行处理，然后每个应用再按照上文提到的将分配给自己的号段丢到线程池中由具体的线程去查询、遍历即可。</p>
<h2 id="分布式带来的问题"><a href="#分布式带来的问题" class="headerlink" title="分布式带来的问题"></a>分布式带来的问题</h2><p>这样看似没啥问题，但一旦引入了分布式之后就不可避免的会出现 <code>CAP</code> 的取舍，这里不做过多讨论，感兴趣的朋友可以自行搜索。</p>
<p>首先要解决的一个问题就是：</p>
<p>这三个应用怎么知道它自己应该取哪些号段的数据呢？比如 0 号应用就取 <code>0 3 6</code>（这个相当于号段的下标），难道在配置文件里配置嘛？</p>
<p>那如果数据量又增大了，对应的机器数也增加到了 5 台，那自然 0 号应用就不是取 <code>0 3 6</code> 了（取模之后数据会变）。</p>
<blockquote>
<p>所以我们得需要一个统一的调度来分配各个应用他们应当取哪些号段，这也就是<strong>数据分片</strong>。</p>
</blockquote>
<p>假设我这里有一个统一的分配中心，他知道现在有多少个应用来处理数据。还是假设上文的三个应用吧。</p>
<p>在真正开始遍历数据的时候，这个分配中心就会去告诉这三个应用：</p>
<blockquote>
<p>你们要开始工作了啊，0 号应用你的工作内容是 <strong>0 3 6</strong>，1 号应用你的工作内容是 <strong>1 4 7</strong>，2 号应用你的工作内容是 <strong>2 5 8</strong>。</p>
</blockquote>
<p>这样各个应用就知道他们所应当处理的数据了。</p>
<p>当我们新增了一个应用来处理数据时也很简单，同样这个分配中心知道现在有多少台应用会工作。</p>
<p>他会再拿着现有的号段对 4(3+1台应用) 进行取模然后对数据进行重新分配，这样就可以再次保证数据分配均匀了。</p>
<blockquote>
<p>只是分配中心如何知道有多少应用呢，其实也简单，只要中心和应用之间通信就可以了。比如启动的时候调用分配中心的接口即可。</p>
</blockquote>
<p>上面提到的这个分配中心其实就是一个常见的定时任务的分布式调度中心，由它来统一发起调度，当然<strong>分片</strong>只是它其中的一个功能而已（关于调度中心之后有兴趣再细说）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次探讨了多线程的更多应用方式，如要是如何高效的运行。最主要的一点其实就是尽量的避免加锁。</p>
<p>同时对分布式水平扩展谈了一些处理建议，本次也是难得的一行代码都没贴，大家感兴趣的话在后面更新相关代码。</p>
<blockquote>
<p>也欢迎大家留言讨论。😄</p>
</blockquote>
<p><strong>你的点赞与转发是最大的支持。</strong></p>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>ThreadPool</tag>
      </tags>
  </entry>
  <entry>
    <title>利用策略模式优化过多 if else 代码</title>
    <url>/2019/01/30/java-senior/design-if-else/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/05/5ccef1ffd774f.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不出意外，这应该是年前最后一次分享，本次来一点实际开发中会用到的小技巧。</p>
<span id="more"></span>

<p>比如平时大家是否都会写类似这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a)&#123;</span><br><span class="line">	<span class="comment">//dosomething</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(b)&#123;</span><br><span class="line">	<span class="comment">//doshomething</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(c)&#123;</span><br><span class="line">	<span class="comment">//doshomething</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">////doshomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件少还好，一旦 <code>else if</code> 过多这里的逻辑将会比较混乱，并很容易出错。</p>
<p>比如这样：</p>
<p><img src="https://i.loli.net/2019/05/05/5ccef63089d79.jpg"></p>
<blockquote>
<p>摘自 <a href="https://github.com/crossoverJie/cim">cim</a> 中的一个客户端命令的判断条件。</p>
</blockquote>
<p>刚开始条件较少，也就没管那么多直接写的；现在功能多了导致每次新增一个 <code>else</code> 条件我都得仔细核对，生怕影响之前的逻辑。</p>
<p>这次终于忍无可忍就把他重构了，重构之后这里的结构如下：</p>
<p><img src="https://i.loli.net/2019/05/05/5ccef221d1575.jpg"></p>
<p>最后直接变为两行代码，简洁了许多。</p>
<p>而之前所有的实现逻辑都单独抽取到其他实现类中。</p>
<p><img src="https://i.loli.net/2019/05/05/5ccef23ed1f7c.jpg"><br><img src="https://i.loli.net/2019/05/05/5ccef256abc9b.jpg"></p>
<p>这样每当我需要新增一个 <code>else</code> 逻辑，只需要新增一个类实现同一个接口便可完成。每个处理逻辑都互相独立互不干扰。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="https://i.loli.net/2019/05/05/5ccef2723156b.jpg"></p>
<p>按照目前的实现画了一个草图。</p>
<p>整体思路如下：</p>
<ul>
<li>定义一个 <code>InnerCommand</code> 接口，其中有一个 <code>process</code> 函数交给具体的业务实现。</li>
<li>根据自己的业务，会有多个类实现 <code>InnerCommand</code> 接口；这些实现类都会注册到 <code>Spring Bean</code> 容器中供之后使用。</li>
<li>通过客户端输入命令，从 <code>Spring Bean</code> 容器中获取一个 <code>InnerCommand</code> 实例。</li>
<li>执行最终的 <code>process</code> 函数。</li>
</ul>
<p>主要想实现的目的就是不在有多个判断条件，只需要根据当前客户端的状态动态的获取 <code>InnerCommand</code> 实例。</p>
<p>从源码上来看最主要的就是 <code>InnerCommandContext</code> 类，他会根据当前客户端命令动态获取 <code>InnerCommand</code> 实例。</p>
<p><img src="https://i.loli.net/2019/05/05/5ccef28c2eedc.jpg"></p>
<ul>
<li>第一步是获取所有的 <code>InnerCommand</code> 实例列表。</li>
<li>根据客户端输入的命令从第一步的实例列表中获取类类型。</li>
<li>根据类类型从 <code>Spring</code> 容器中获取具体实例对象。</li>
</ul>
<p>因此首先第一步需要维护各个命令所对应的类类型。</p>
<p><img src="https://i.loli.net/2019/05/05/5ccef2b72abb8.jpg"></p>
<p>所以在之前的枚举中就维护了命令和类类型的关系，只需要知道命令就能知道他的类类型。</p>
<p>这样才能满足只需要两行代码就能替换以前复杂的 <code>if else</code>，同时也能灵活扩展。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InnerCommand</span> <span class="variable">instance</span> <span class="operator">=</span> innerCommandContext.getInstance(msg);</span><br><span class="line">instance.process(msg) ;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当然还可以做的更灵活一些，比如都不需要显式的维护命令和类类型的对应关系。</p>
<p>只需要在应用启动时扫描所有实现了 <code>InnerCommand</code> 接口的类即可，在 <a href="https://github.com/TogetherOS/cicada">cicada</a> 中有类似实现，感兴趣的可以自行<a href="https://github.com/TogetherOS/cicada">查看</a>。</p>
<p>这样一些小技巧希望对你有所帮助。</p>
<p>以上所有源码可以在这里查看：</p>
<p><a href="https://github.com/crossoverJie/cim">https://github.com/crossoverJie/cim</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>Java 进阶</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>没错，老板让我写个 BUG！</title>
    <url>/2018/12/12/java-senior/java-memary-allocation/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1c38cba7ec.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>标题没有看错，真的是让我写个 <code>bug</code>！</p>
<p>刚接到这个需求时我内心没有丝毫波澜，甚至还有点激动。这可是我特长啊；终于可以光明正大的写 <code>bug</code> 了🙄。</p>
<p>先来看看具体是要干啥吧，其实主要就是要让一些负载很低的服务器额外消耗一些内存、CPU 等资源（至于背景就不多说了），让它的负载可以提高一些。</p>
<span id="more"></span>
<h1 id="JVM-内存分配回顾"><a href="#JVM-内存分配回顾" class="headerlink" title="JVM 内存分配回顾"></a>JVM 内存分配回顾</h1><p>于是我刷刷一把梭的就把代码写好了，大概如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3c278c42.jpg"></p>
<p>写完之后我就在想一个问题，代码中的 <code>mem</code> 对象在方法执行完之后会不会被立即回收呢？我想肯定会有一部分人认为就是在方法执行完之后回收。</p>
<p>我也正儿八经的去调研了下，问了一些朋友；果不其然确实有一部分认为是在方法执行完毕之后回收。</p>
<p>那事实情况如何呢？我做了一个试验。</p>
<p>我用以下的启动参数将刚才这个应用启动起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=<span class="number">10.</span>xx.xx.xx </span><br><span class="line">-Djava.security.policy=jstatd.all.policy </span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span> </span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=<span class="literal">false</span> </span><br><span class="line">-Dcom.sun.management.jmxremote.port=<span class="number">8888</span>  </span><br><span class="line">-Xms4g -Xmx4g  -jar bug-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>这样我就可以通过 JMX 端口远程连接到这个应用观察内存、GC 情况了。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c39bc036e.jpg"></p>
<hr>
<p>如果是方法执行完毕就回收 <code>mem</code> 对象，当我分配 <code>250M</code> 内存时；内存就会有一个明显的曲线，同时 GC 也会执行。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c39f7851e.jpg"></p>
<hr>
<p>这时观察内存曲线。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3a9d62ef.jpg"></p>
<p>会发现确实有明显的涨幅，但是之后并没有立即回收，而是一直保持在这个水位。同时左边的 GC 也没有任何的反应。</p>
<p>用 <code>jstat</code> 查看内存布局也是同样的情况。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3b066f78.jpg"></p>
<p>不管是 <code>YGC,FGC</code> 都没有，只是 Eden 区的使用占比有所增加，毕竟分配了 250M 内存嘛。</p>
<p>那怎样才会回收呢？</p>
<p>我再次分配了两个 250M 之后观察内存曲线。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3b2edd01.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3b7b078d.jpg"></p>
<p>发现第三个 250M 的时候 <code>Eden</code> 区达到了 <code>98.83%</code> 于是再次分配时就需要回收 <code>Eden</code> 区产生了 <code>YGC</code>。</p>
<p>同时内存曲线也得到了下降。</p>
<p>整个的换算过程如图：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3bad06b4.jpg"></p>
<p>由于初始化的堆内存为 <code>4G</code>，所以算出来的 <code>Eden</code> 区大概为 <code>1092M</code> 内存。</p>
<p>加上应用启动 <code>Spring</code> 之类消耗的大约 <code>20%</code> 内存，所以分配 3 次 250M 内存就会导致 <code>YGC</code>。</p>
<p>再来回顾下刚才的问题：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3c278c42.jpg"></p>
<p><code>mem</code> 对象既然在方法执行完毕后不会回收，那什么时候回收呢。</p>
<p>其实只要记住一点即可：<strong>对象都需要垃圾回收器发生 <code>GC</code> 时才能回收；不管这个对象是局部变量还是全局变量。</strong></p>
<p>通过刚才的实验也发现了，当 <code>Eden</code> 区空间不足产生 <code>YGC</code> 时才会回收掉我们创建的 <code>mem</code> 对象。</p>
<p>但这里其实还有一个隐藏条件：那就是这个对象是<strong>局部变量</strong>。如果该对象是全局变量那依然不能被回收。</p>
<p>也就是我们常说的<strong>对象不可达</strong>，这样不可达的对象在 <code>GC</code> 发生时就会被认为是需要回收的对象从而进行回收。</p>
<p>在多考虑下，为什么有些人会认为方法执行完毕后局部变量会被回收呢？</p>
<p>我想这应当是记混了，其实方法执行完毕后回收的是<code>栈帧</code>。</p>
<p>它最直接的结果就是导致 <code>mem</code> 这个对象没有被引用了。但没有引用并不代表会被马上回收，也就是上面说到的需要产生 <code>GC</code> 才会回收。</p>
<p>所以使用的是上面提到的对象不可达所采用的<strong>可达性分析算法</strong>来表明哪些对象需要被回收。</p>
<p>当对象没有被引用后也就认为不可达了。</p>
<p>这里有一张动图比较清晰：</p>
<p><img src="https://camo.githubusercontent.com/dc705fafcecd5df825706c0599a5993a1d8e4351/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f342f34612f416e696d6174696f6e5f6f665f7468655f4e616976655f4d61726b5f616e645f53776565705f476172626167655f436f6c6c6563746f725f416c676f726974686d2e676966"></p>
<p>当方法执行完之后其中的 <code>mem</code> 对象就相当于图中的 <code>Object 5</code>，所以在 <code>GC</code> 时候就会回收掉。</p>
<h2 id="优先在-Eden-区分配对象"><a href="#优先在-Eden-区分配对象" class="headerlink" title="优先在 Eden 区分配对象"></a>优先在 Eden 区分配对象</h2><p>其实从上面的例子中可以看出对象是优先分配在新生代中 Eden 区的，但有个前提就是对象不能太大。</p>
<p>以前也写过相关的内容：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3c5ab0af.jpg"></p>
<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>而大对象则是直接分配到老年代中（至于多大算大，可以通过参数配置）。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3c730526.jpg"></p>
<hr>
<p>当我直接分配 1000M 内存时，由于 Eden 区不能直接装下，所以改为分配在老年代中。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3ca2e8ae.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3cd20694.jpg"></p>
<p>可以看到 <code>Eden</code> 区几乎没有变动，但是老年代却涨了 37% ，根据之前计算的老年代内存 <code>2730M</code> 算出来也差不多是 <code>1000M</code> 的内存。</p>
<h1 id="Linux-内存查看"><a href="#Linux-内存查看" class="headerlink" title="Linux 内存查看"></a>Linux 内存查看</h1><p>回到这次我需要完成的需求：增加服务器内存和 CPU 的消耗。</p>
<p>CPU 还好，本身就有一定的使用，同时每创建一个对象也会消耗一些 CPU。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3ceaf475.jpg"></p>
<p>主要是内存,先来看下没启动这个应用之前的内存情况。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3cfecdb7.jpg"></p>
<p>大概只使用了 3G 的内存。</p>
<p>启动应用之后大概只消耗了 600M 左右的内存。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3d7b8325.jpg"></p>
<p>为了满足需求我需要分配一些内存，但这里有点需要讲究。</p>
<p>不能一直分配内存，这样会导致 CPU 负载太高了，同时内存也会由于 GC 回收导致占用也不是特别多。</p>
<p>所以我需要少量的分配，让大多数对象在新生代中，为了不被回收需要保持在百分之八九十。</p>
<p>同时也需要分配一些大对象到老年代中，也要保持老年代的使用在百分之八九十。</p>
<p>这样才能最大限度的利用这 4G 的堆内存。</p>
<p>于是我做了以下操作：</p>
<ul>
<li>先分配一些小对象在新生代中（800M）保持新生代在90%</li>
<li>接着又分配了<code>老年代内 *（100%-已使用的28%）；也就是 2730*60%=1638M</code> 让老年代也在 90% 左右。</li>
</ul>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3d9acf62.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3e0ac17a.jpg"></p>
<p>效果如上。</p>
<p>最主要的是一次 <code>GC</code> 都没有发生这样也就达到了我的目的。</p>
<p>最终内存消耗了 3.5G 左右。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3e398b1b.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽说这次的需求是比较奇葩，但想要精确的控制 <code>JVM</code> 的内存分配还是没那么容易。</p>
<p>需要对它的内存布局，回收都要有一定的了解，写这个 Bug 的过程确实也加深了印象，如果对你有所帮助请不要吝啬你的点赞与分享。</p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解线程通信</title>
    <url>/2018/03/16/java-senior/thread-communication/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d7d3bbf16.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开发中不免会遇到需要所有子线程执行完毕通知主线程处理某些逻辑的场景。</p>
<p>或者是线程 A 在执行到某个条件通知线程 B 执行某个操作。</p>
<p>可以通过以下几种方式实现：</p>
<h2 id="等待通知机制"><a href="#等待通知机制" class="headerlink" title="等待通知机制"></a>等待通知机制</h2><blockquote>
<p>等待通知模式是 Java 中比较经典的线程通信方式。</p>
</blockquote>
<p>两个线程通过对同一对象调用等待 wait() 和通知 notify() 方法来进行通讯。</p>
<p>如两个线程交替打印奇偶数：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoThreadWaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TwoThreadWaitNotify</span> <span class="variable">twoThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoThreadWaitNotify</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">OuNum</span>(twoThread));</span><br><span class="line">        t1.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">JiNum</span>(twoThread));</span><br><span class="line">        t2.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 偶数线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OuNum</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> TwoThreadWaitNotify number;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">OuNum</span><span class="params">(TwoThreadWaitNotify number)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.number = number;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (number.start &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TwoThreadWaitNotify.class) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;偶数线程抢到锁了&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (number.flag) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;+-+偶数&quot;</span> + number.start);</span><br><span class="line">                        number.start++;</span><br><span class="line"></span><br><span class="line">                        number.flag = <span class="literal">false</span>;</span><br><span class="line">                        TwoThreadWaitNotify.class.notify();</span><br><span class="line"></span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TwoThreadWaitNotify.class.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 奇数线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JiNum</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> TwoThreadWaitNotify number;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">JiNum</span><span class="params">(TwoThreadWaitNotify number)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.number = number;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number.start &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TwoThreadWaitNotify.class) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;奇数线程抢到锁了&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!number.flag) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;+-+奇数&quot;</span> + number.start);</span><br><span class="line">                        number.start++;</span><br><span class="line"></span><br><span class="line">                        number.flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                        TwoThreadWaitNotify.class.notify();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TwoThreadWaitNotify.class.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t2+-+奇数93</span><br><span class="line">t1+-+偶数94</span><br><span class="line">t2+-+奇数95</span><br><span class="line">t1+-+偶数96</span><br><span class="line">t2+-+奇数97</span><br><span class="line">t1+-+偶数98</span><br><span class="line">t2+-+奇数99</span><br><span class="line">t1+-+偶数100</span><br></pre></td></tr></table></figure>

<p>这里的线程 A 和线程 B 都对同一个对象 <code>TwoThreadWaitNotify.class</code> 获取锁，A 线程调用了同步对象的 wait() 方法释放了锁并进入 <code>WAITING</code> 状态。</p>
<p>B 线程调用了 notify() 方法，这样 A 线程收到通知之后就可以从 wait() 方法中返回。</p>
<p>这里利用了 <code>TwoThreadWaitNotify.class</code> 对象完成了通信。</p>
<p>有一些需要注意:</p>
<ul>
<li>wait() 、nofify() 、nofityAll() 调用的前提都是获得了对象的锁(也可称为对象监视器)。</li>
<li>调用 wait() 方法后线程会释放锁，进入 <code>WAITING</code> 状态，该线程也会被移动到<strong>等待队列</strong>中。</li>
<li>调用 notify() 方法会将<strong>等待队列</strong>中的线程移动到<strong>同步队列</strong>中，线程状态也会更新为 <code>BLOCKED</code></li>
<li>从 wait() 方法返回的前提是调用 notify() 方法的线程释放锁，wait() 方法的线程获得锁。</li>
</ul>
<p>等待通知有着一个经典范式：</p>
<p>线程 A 作为消费者：</p>
<ol>
<li>获取对象的锁。</li>
<li>进入 while(判断条件)，并调用 wait() 方法。</li>
<li>当条件满足跳出循环执行具体处理逻辑。</li>
</ol>
<p>线程 B 作为生产者:</p>
<ol>
<li>获取对象锁。</li>
<li>更改与线程 A 共用的判断条件。</li>
<li>调用 notify() 方法。</li>
</ol>
<p>伪代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Thread A</span><br><span class="line"></span><br><span class="line">synchronized(Object)&#123;</span><br><span class="line">    while(条件)&#123;</span><br><span class="line">        Object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    //do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Thread B</span><br><span class="line">synchronized(Object)&#123;</span><br><span class="line">    条件=false;//改变条件</span><br><span class="line">    Object.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="join-方法"><a href="#join-方法" class="headerlink" title="join() 方法"></a>join() 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) ;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;running2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) ;</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待线程1终止</span></span><br><span class="line">    t1.join();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待线程2终止</span></span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">&quot;main over&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-03-16 20:21:30.967 [Thread-1] INFO  c.c.actual.ThreadCommunication - running2</span><br><span class="line">2018-03-16 20:21:30.967 [Thread-0] INFO  c.c.actual.ThreadCommunication - running</span><br><span class="line">2018-03-16 20:21:34.972 [main] INFO  c.c.actual.ThreadCommunication - main over</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在  <code>t1.join()</code> 时会一直阻塞到 t1 执行完毕，所以最终主线程会等待 t1 和 t2 线程执行完毕。</p>
<p>其实从源码可以看出，join() 也是利用的等待通知机制：</p>
<p>核心逻辑:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 join 线程完成后会调用 notifyAll() 方法，是在 JVM 实现中调用，所以这里看不出来。</p>
<h2 id="volatile-共享内存"><a href="#volatile-共享内存" class="headerlink" title="volatile 共享内存"></a>volatile 共享内存</h2><p>因为 Java 是采用共享内存的方式进行线程通信的，所以可以采用以下方式用主线程关闭 A 线程:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Volatile</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在运行。。。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Volatile</span> <span class="variable">aVolatile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Volatile</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(aVolatile,<span class="string">&quot;thread A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程正在运行&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>) ;</span><br><span class="line"></span><br><span class="line">        aVolatile.stopThread();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stopThread</span><span class="params">()</span>&#123;</span><br><span class="line">        flag = <span class="literal">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thread A正在运行。。。</span><br><span class="line">thread A正在运行。。。</span><br><span class="line">thread A正在运行。。。</span><br><span class="line">thread A正在运行。。。</span><br><span class="line">thread A执行完毕</span><br></pre></td></tr></table></figure>

<p>这里的 flag 存放于主内存中，所以主线程和线程 A 都可以看到。</p>
<p>flag 采用 volatile 修饰主要是为了内存可见性，更多内容可以查看<a href="http://crossoverjie.top/2018/03/09/volatile/">这里</a>。</p>
<h2 id="CountDownLatch-并发工具"><a href="#CountDownLatch-并发工具" class="headerlink" title="CountDownLatch 并发工具"></a>CountDownLatch 并发工具</h2><p>CountDownLatch 可以实现 join 相同的功能，但是更加的灵活。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countDownLatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="number">3</span> ;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDown</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(thread);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span> ;i&lt;thread ; i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;thread run&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    countDown.countDown();</span><br><span class="line"></span><br><span class="line">                    LOGGER.info(<span class="string">&quot;thread end&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    countDown.await();</span><br><span class="line">    <span class="type">long</span> <span class="variable">stop</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    LOGGER.info(<span class="string">&quot;main over total time=&#123;&#125;&quot;</span>,stop-start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-03-16 20:19:44.126 [Thread-0] INFO  c.c.actual.ThreadCommunication - thread run</span><br><span class="line">2018-03-16 20:19:44.126 [Thread-2] INFO  c.c.actual.ThreadCommunication - thread run</span><br><span class="line">2018-03-16 20:19:44.126 [Thread-1] INFO  c.c.actual.ThreadCommunication - thread run</span><br><span class="line">2018-03-16 20:19:46.136 [Thread-2] INFO  c.c.actual.ThreadCommunication - thread end</span><br><span class="line">2018-03-16 20:19:46.136 [Thread-1] INFO  c.c.actual.ThreadCommunication - thread end</span><br><span class="line">2018-03-16 20:19:46.136 [Thread-0] INFO  c.c.actual.ThreadCommunication - thread end</span><br><span class="line">2018-03-16 20:19:46.136 [main] INFO  c.c.actual.ThreadCommunication - main over total time=2012</span><br></pre></td></tr></table></figure>

<p>CountDownLatch 也是基于 AQS(AbstractQueuedSynchronizer) 实现的，更多实现参考 <a href="http://crossoverjie.top/2018/01/25/ReentrantLock/">ReentrantLock 实现原理</a></p>
<ul>
<li>初始化一个 CountDownLatch 时告诉并发的线程，然后在每个线程处理完毕之后调用 countDown() 方法。</li>
<li>该方法会将 AQS 内置的一个 state 状态 -1 。</li>
<li>最终在主线程调用 await() 方法，它会阻塞直到 <code>state == 0</code> 的时候返回。</li>
</ul>
<h2 id="CyclicBarrier-并发工具"><a href="#CyclicBarrier-并发工具" class="headerlink" title="CyclicBarrier 并发工具"></a>CyclicBarrier 并发工具</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cyclicBarrier</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;thread run&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier.await() ;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LOGGER.info(<span class="string">&quot;thread end do something&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;thread run&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier.await() ;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LOGGER.info(<span class="string">&quot;thread end do something&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;thread run&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                cyclicBarrier.await() ;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LOGGER.info(<span class="string">&quot;thread end do something&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">&quot;main thread&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CyclicBarrier 中文名叫做屏障或者是栅栏，也可以用于线程间通信。</p>
<p>它可以等待 N 个线程都达到某个状态后继续运行的效果。</p>
<ol>
<li>首先初始化线程参与者。</li>
<li>调用 <code>await()</code> 将会在所有参与者线程都调用之前等待。</li>
<li>直到所有参与者都调用了 <code>await()</code> 后，所有线程从 <code>await()</code> 返回继续后续逻辑。</li>
</ol>
<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-03-18 22:40:00.731 [Thread-0] INFO  c.c.actual.ThreadCommunication - thread run</span><br><span class="line">2018-03-18 22:40:00.731 [Thread-1] INFO  c.c.actual.ThreadCommunication - thread run</span><br><span class="line">2018-03-18 22:40:00.731 [Thread-2] INFO  c.c.actual.ThreadCommunication - thread run</span><br><span class="line">2018-03-18 22:40:00.731 [main] INFO  c.c.actual.ThreadCommunication - main thread</span><br><span class="line">2018-03-18 22:40:05.741 [Thread-0] INFO  c.c.actual.ThreadCommunication - thread end do something</span><br><span class="line">2018-03-18 22:40:05.741 [Thread-1] INFO  c.c.actual.ThreadCommunication - thread end do something</span><br><span class="line">2018-03-18 22:40:05.741 [Thread-2] INFO  c.c.actual.ThreadCommunication - thread end do something</span><br></pre></td></tr></table></figure>

<p>可以看出由于其中一个线程休眠了五秒，所有其余所有的线程都得等待这个线程调用 <code>await()</code> 。</p>
<p>该工具可以实现 CountDownLatch 同样的功能，但是要更加灵活。甚至可以调用 <code>reset()</code> 方法重置 CyclicBarrier (需要自行捕获 BrokenBarrierException 处理) 然后重新执行。</p>
<h2 id="线程响应中断"><a href="#线程响应中断" class="headerlink" title="线程响应中断"></a>线程响应中断</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">// 线程执行具体逻辑</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;运行中。。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;退出。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">StopThread</span>(), <span class="string">&quot;thread A&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程正在运行&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>) ;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thread A运行中。。</span><br><span class="line">thread A运行中。。</span><br><span class="line">thread A退出。。</span><br></pre></td></tr></table></figure>

<p>可以采用中断线程的方式来通信，调用了 <code>thread.interrupt()</code> 方法其实就是将 thread 中的一个标志属性置为了 true。</p>
<p>并不是说调用了该方法就可以中断线程，如果不对这个标志进行响应其实是没有什么作用(这里对这个标志进行了判断)。</p>
<p><strong>但是如果抛出了 InterruptedException 异常，该标志就会被 JVM 重置为 false。</strong></p>
<h2 id="线程池-awaitTermination-方法"><a href="#线程池-awaitTermination-方法" class="headerlink" title="线程池 awaitTermination() 方法"></a>线程池 awaitTermination() 方法</h2><p>如果是用线程池来管理线程，可以使用以下方式来让主线程等待线程池中所有任务执行完毕:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">executorService</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>) ;</span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">poolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>, TimeUnit.MILLISECONDS,queue) ;</span><br><span class="line">    poolExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    poolExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;running2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    poolExecutor.shutdown();</span><br><span class="line">    <span class="keyword">while</span> (!poolExecutor.awaitTermination(<span class="number">1</span>,TimeUnit.SECONDS))&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;线程还在执行。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;main over&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-03-16 20:18:01.273 [pool-1-thread-2] INFO  c.c.actual.ThreadCommunication - running2</span><br><span class="line">2018-03-16 20:18:01.273 [pool-1-thread-1] INFO  c.c.actual.ThreadCommunication - running</span><br><span class="line">2018-03-16 20:18:02.273 [main] INFO  c.c.actual.ThreadCommunication - 线程还在执行。。。</span><br><span class="line">2018-03-16 20:18:03.278 [main] INFO  c.c.actual.ThreadCommunication - 线程还在执行。。。</span><br><span class="line">2018-03-16 20:18:04.278 [main] INFO  c.c.actual.ThreadCommunication - main over</span><br></pre></td></tr></table></figure>

<p>使用这个 <code>awaitTermination()</code> 方法的前提需要关闭线程池，如调用了 <code>shutdown()</code> 方法。</p>
<p>调用了 <code>shutdown()</code> 之后线程池会停止接受新任务，并且会平滑的关闭线程池中现有的任务。</p>
<h2 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">piped</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//面向于字符 PipedInputStream 面向于字节</span></span><br><span class="line">    <span class="type">PipedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedWriter</span>();</span><br><span class="line">    <span class="type">PipedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedReader</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入输出流建立连接</span></span><br><span class="line">    writer.connect(reader);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                    writer.write(i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;running2&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((msg = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    LOGGER.info(<span class="string">&quot;msg=&#123;&#125;&quot;</span>, (<span class="type">char</span>) msg);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-03-16 19:56:43.014 [Thread-0] INFO  c.c.actual.ThreadCommunication - running</span><br><span class="line">2018-03-16 19:56:43.014 [Thread-1] INFO  c.c.actual.ThreadCommunication - running2</span><br><span class="line">2018-03-16 19:56:43.130 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=0</span><br><span class="line">2018-03-16 19:56:43.132 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=1</span><br><span class="line">2018-03-16 19:56:43.132 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=2</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=3</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=4</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=5</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=6</span><br><span class="line">2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=7</span><br><span class="line">2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=8</span><br><span class="line">2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=9</span><br></pre></td></tr></table></figure>

<p>Java 虽说是基于内存通信的，但也可以使用管道通信。</p>
<p>需要注意的是，输入流和输出流需要首先建立连接。这样线程 B 就可以收到线程 A 发出的消息了。</p>
<p>实际开发中可以灵活根据需求选择最适合的线程通信方式。</p>
<h2 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h2><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>分享一些 Kafka 消费数据的小经验</title>
    <url>/2018/11/20/kafka/kafka-consumer/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1c61375484.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前写过一篇<a href="https://crossoverjie.top/2018/10/11/kafka/kafka-product/">《从源码分析如何优雅的使用 Kafka 生产者》</a> ，有生产者自然也就有消费者。</p>
<blockquote>
<p>建议对 Kakfa 还比较陌生的朋友可以先看看。</p>
</blockquote>
<p>就我的使用经验来说，大部分情况都是处于数据下游的消费者角色。也用 <code>Kafka</code> 消费过日均过亿的消息（不得不佩服 Kakfa 的设计），本文将借助我使用 Kakfa 消费数据的经验来聊聊如何高效的消费数据。</p>
<span id="more"></span>

<h1 id="单线程消费"><a href="#单线程消费" class="headerlink" title="单线程消费"></a>单线程消费</h1><p>以之前生产者中的代码为例，事先准备好了一个 <code>Topic:data-push</code>，3个分区。</p>
<p>先往里边发送 100 条消息，没有自定义路由策略，所以消息会均匀的发往三个分区。</p>
<p>先来谈谈最简单的单线程消费，如下图所示：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6196e396.jpg"></p>
<p>由于数据散列在三个不同分区，所以单个线程需要遍历三个分区将数据拉取下来。</p>
<p>单线程消费的示例代码：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c61ac2377.jpg"></p>
<p>这段代码大家在官网也可以找到：将数据取出放到一个内存缓冲中最后写入数据库的过程。</p>
<blockquote>
<p>先不讨论其中的 offset 的提交方式。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/08/5cd1c61e93ea2.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6267f7e3.jpg"></p>
<p>通过消费日志可以看出：</p>
<p>取出的 100 条数据确实是分别遍历了三个分区。</p>
<p>单线程消费虽然简单，但存在以下几个问题：</p>
<ul>
<li>效率低下。如果分区数几十上百个，单线程无法高效的取出数据。</li>
<li>可用性很低。一旦消费线程阻塞，甚至是进程挂掉，那么整个消费程序都将出现问题。</li>
</ul>
<h1 id="多线程消费"><a href="#多线程消费" class="headerlink" title="多线程消费"></a>多线程消费</h1><p>既然单线程有诸多问题，那是否可以用多线程来提高效率呢？</p>
<p>在多线程之前不得不将消费模式分为两种进行探讨：消费组、独立消费者。</p>
<p>这两种消费模式对应的处理方式有着很大的不同，所以很有必要单独来讲。</p>
<h2 id="独立消费者模式"><a href="#独立消费者模式" class="headerlink" title="独立消费者模式"></a>独立消费者模式</h2><p>先从<code>独立消费者模式</code>谈起，这种模式相对于消费组来说用的相对小众一些。</p>
<p>看一个简单示例即可知道它的用法：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c62e08760.jpg"></p>
<blockquote>
<p>值得注意的是：独立消费者可以不设置 group.id 属性。</p>
</blockquote>
<p>也是发送100条消息，消费结果如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6368d48a.jpg"></p>
<p>通过 API 可以看出：我们可以手动指定需要消费哪些分区。</p>
<p>比如 <code>data-push</code> Topic 有三个分区，我可以手动只消费其中的 1 2 分区，第三个可以视情况来消费。</p>
<p>同时它也支持多线程的方式，每个线程消费指定分区进行消费。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c639d07b5.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c63bcd72a.jpg"></p>
<p>为了直观，只发送了 10 条数据。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c63e42c09.jpg"></p>
<p>根据消费结果可以看出：</p>
<p>c1 线程只取 0 分区；c2 只取 1 分区；c3 只取 2 分区的数据。</p>
<p>甚至我们可以将消费者多进程部署，这样的消费方式如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c642b1eb2.jpg"></p>
<p>假设 <code>Topic:data-push</code> 的分区数为 4 个，那我们就可以按照图中的方式创建两个进程。</p>
<p>每个进程内有两个线程，每个线程再去消费对应的分区。</p>
<p>这样当我们性能不够新增 Topic 的分区数时，消费者这边只需要这样水平扩展即可，非常的灵活。</p>
<p>这种自定义分区消费的方式在某些场景下还是适用的，比如生产者每次都将某一类的数据只发往一个分区。这样我们就可以只针对这一个分区消费。</p>
<p>但这种方式有一个问题：可用性不高，当其中一个进程挂掉之后；该进程负责的分区数据没法转移给其他进程处理。</p>
<h2 id="消费组模式"><a href="#消费组模式" class="headerlink" title="消费组模式"></a>消费组模式</h2><p>消费组模式应当是使用最多的一种消费方式。</p>
<p>我们可以创建 N 个消费者实例（<code>new KafkaConsumer()</code>）,当这些实例都用同一个 <code>group.id</code> 来创建时，他们就属于同一个消费组。</p>
<p>在同一个消费组中的消费实例可以收到消息，但一个分区的消息只会发往一个消费实例。</p>
<p>还是借助官方的示例图来更好的理解它。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c64a28e38.jpg"></p>
<p>某个 Topic 有四个分区 <code>p0 p1 p2 p3</code>，同时创建了两个消费组 <code>groupA，groupB</code>。</p>
<ul>
<li>A 消费组中有两个消费实例 <code>C1、C2</code>。</li>
<li>B 消费组中有四个消费实例 <code>C3、C4、C5、C6</code>。</li>
</ul>
<p>这样消息是如何划分到每个消费实例的呢？</p>
<p>通过图中可以得知：</p>
<ul>
<li>A 组中的 C1 消费了 P0 和 P3 分区；C2 消费 P1、P2 分区。</li>
<li>B 组有四个实例，所以每个实例消费一个分区；也就是消费实例和分区是一一对应的。</li>
</ul>
<p>需要注意的是：</p>
<blockquote>
<p>这里的消费实例简单的可以理解为 <code>new KafkaConsumer</code>，<strong>它和进程没有关系</strong>。</p>
</blockquote>
<hr>
<p>比如说某个 Topic 有三个分区，但是我启动了两个进程来消费它。</p>
<p>其中每个进程有两个消费实例，那其实就相当于有四个实例了。</p>
<p>这时可能就会问 4 个实例怎么消费 3 个分区呢？</p>
<h1 id="消费组自平衡"><a href="#消费组自平衡" class="headerlink" title="消费组自平衡"></a>消费组自平衡</h1><p>这个 Kafka 已经帮我做好了，它会来做消费组里的 <code>Rebalance</code>。</p>
<p>比如上面的情况，3 个分区却有 4 个消费实例；最终肯定只有三个实例能取到消息。但至于是哪三个呢，这点 Kakfa 会自动帮我们分配好。</p>
<p>看个例子，还在之前的 <code>data-push</code> 这个 Topic，其中有三个分区。</p>
<p>当其中一个进程（其中有三个线程，每个线程对应一个消费实例）时，消费结果如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c64d5033e.jpg"></p>
<p>里边的 20 条数据都被这个进程的三个实例消费掉。</p>
<p>这时我新启动了一个进程，程序和上面那个一模一样；这样就相当于有两个进程，同时就是 6 个实例。</p>
<p>我再发送 10 条消息会发现：</p>
<p>进程1 只取到了分区 1 里的两条数据（之前是所有数据都是进程1里的线程获取的）。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6503fd42.jpg"></p>
<hr>
<p>同时进程2则消费了剩下的 8 条消息，分别是分区 0、2 的数据（总的还是只有三个实例取到了数据，只是分别在不同的进程里）。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c651f08b2.jpg"></p>
<hr>
<p>当我关掉进程2，再发送10条数据时会发现所有数据又被进程1里的三个线程消费了。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c65727453.jpg"></p>
<p>通过这些测试相信大家已经可以看到消费组的优势了。</p>
<blockquote>
<p>我们可以在一个消费组中创建多个消费实例来达到高可用、高容错的特性，不会出现单线程以及独立消费者挂掉之后数据不能消费的情况。同时基于多线程的方式也极大的提高了消费效率。</p>
</blockquote>
<p>而当新增消费实例或者是消费实例挂掉时 <code>Kakfa</code> 会为我们重新分配消费实例与分区的关系就被称为消费组 <code>Rebalance</code>。</p>
<p>发生这个的前提条件一般有以下几个：</p>
<ul>
<li>消费组中新增消费实例。</li>
<li>消费组中消费实例 down 掉。</li>
<li>订阅的 Topic 分区数发生变化。</li>
<li>如果是正则订阅 Topic 时，匹配的 Topic 数发生变化也会导致 <code>Rebalance</code>。</li>
</ul>
<p>所以推荐使用这样的方式消费数据，同时扩展性也非常好。当性能不足新增分区时只需要启动新的消费实例加入到消费组中即可。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次只分享了几个不同消费数据的方式，并没有着重研究消费参数、源码；这些内容感兴趣的话可以在下次分享。</p>
<p>文中提到的部分源码可以在这里查阅：</p>
<p><a href="https://github.com/crossoverJie/JCSprout">https://github.com/crossoverJie/JCSprout</a></p>
<p><strong>欢迎关注公众号一起交流：</strong></p>
]]></content>
      <categories>
        <category>Kafka</category>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>从源码分析如何优雅的使用 Kafka 生产者</title>
    <url>/2018/10/11/kafka/kafka-product/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d10ebd53b.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上文 <a href="https://crossoverjie.top/2018/09/25/netty/million-sms-push/">设计一个百万级的消息推送系统</a> 中提到消息流转采用的是 <code>Kafka</code> 作为中间件。</p>
<p>其中有朋友咨询在大量消息的情况下 <code>Kakfa</code> 是如何保证消息的高效及一致性呢？</p>
<p>正好以这个问题结合 <code>Kakfa</code> 的源码讨论下如何正确、高效的发送消息。</p>
<blockquote>
<p>内容较多，对源码感兴趣的朋友请系好安全带😏(源码基于 <code>v0.10.0.0</code> 版本分析)。同时最好是有一定的 Kafka 使用经验，知晓基本的用法。</p>
</blockquote>
<span id="more"></span>

<h1 id="简单的消息发送"><a href="#简单的消息发送" class="headerlink" title="简单的消息发送"></a>简单的消息发送</h1><p>在分析之前先看一个简单的消息发送是怎么样的。</p>
<blockquote>
<p>以下代码基于 SpringBoot 构建。</p>
</blockquote>
<p>首先创建一个 <code>org.apache.kafka.clients.producer.Producer</code> 的 bean。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d11527115.jpg"></p>
<p>主要关注 <code>bootstrap.servers</code>，它是必填参数。指的是 Kafka 集群中的 broker 地址，例如 <code>127.0.0.1:9094</code>。</p>
<blockquote>
<p>其余几个参数暂时不做讨论，后文会有详细介绍。</p>
</blockquote>
<p>接着注入这个 bean 即可调用它的发送函数发送消息。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1166034a.jpg"></p>
<p>这里我给某一个 Topic 发送了 10W 条数据，运行程序消息正常发送。</p>
<p>但这仅仅只是做到了消息发送，对消息是否成功送达完全没管，等于是纯<code>异步</code>的方式。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>那么我想知道消息到底发送成功没有该怎么办呢？</p>
<p>其实 <code>Producer</code> 的 <code>API</code> 已经帮我们考虑到了，发送之后只需要调用它的 <code>get()</code> 方法即可同步获取发送结果。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d11748eb5.jpg"></p>
<p>发送结果：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d118ac608.jpg"></p>
<p>这样的发送效率其实是比较低下的，因为每次都需要同步等待消息发送的结果。 </p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>为此我们应当采取异步的方式发送，其实 <code>send()</code> 方法默认则是异步的，只要不手动调用  <code>get()</code> 方法。</p>
<p>但这样就没法获知发送结果。</p>
<p>所以查看 <code>send()</code> 的 API 可以发现还有一个参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;RecordMetadata&gt; <span class="title function_">send</span><span class="params">(ProducerRecord&lt;K, V&gt; producer, Callback callback)</span>;</span><br></pre></td></tr></table></figure>

<p><code>Callback</code> 是一个回调接口，在消息发送完成之后可以回调我们自定义的实现。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d119c9164.jpg"></p>
<p>执行之后的结果：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d11badd71.jpg"></p>
<p>同样的也能获取结果，同时发现回调的线程并不是上文同步时的<code>主线程</code>，这样也能证明是异步回调的。</p>
<p>同时回调的时候会传递两个参数：</p>
<ul>
<li><code>RecordMetadata</code> 和上文一致的消息发送成功后的元数据。</li>
<li><code>Exception</code> 消息发送过程中的异常信息。</li>
</ul>
<p>但是这两个参数并不会同时都有数据，只有发送失败才会有异常信息，同时发送元数据为空。</p>
<p>所以正确的写法应当是：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1216d13b.jpg"></p>
<blockquote>
<p>至于为什么会只有参数一个有值，在下文的源码分析中会一一解释。</p>
</blockquote>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>现在只掌握了基本的消息发送，想要深刻的理解发送中的一些参数配置还是得源码说了算。</p>
<p>首先还是来谈谈消息发送时的整个流程是怎么样的，<code>Kafka</code> 并不是简单的把消息通过网络发送到了 <code>broker</code> 中，在 Java 内部还是经过了许多优化和设计。</p>
<h2 id="发送流程"><a href="#发送流程" class="headerlink" title="发送流程"></a>发送流程</h2><p>为了直观的了解发送的流程，简单的画了几个在发送过程中关键的步骤。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d12228c9b.jpg"></p>
<p>从上至下依次是：</p>
<ul>
<li>初始化以及真正发送消息的 <code>kafka-producer-network-thread</code> IO 线程。</li>
<li>将消息序列化。</li>
<li>得到需要发送的分区。</li>
<li>写入内部的一个缓存区中。</li>
<li>初始化的 IO 线程不断的消费这个缓存来发送消息。</li>
</ul>
<h2 id="步骤解析"><a href="#步骤解析" class="headerlink" title="步骤解析"></a>步骤解析</h2><p>接下来详解每个步骤。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><img src="https://i.loli.net/2019/05/08/5cd1d12331873.jpg"></p>
<p>调用该构造方法进行初始化时，不止是简单的将基本参数写入 <code>KafkaProducer</code>。比较麻烦的是初始化 <code>Sender</code> 线程进行缓冲区消费。</p>
<p>初始化 IO 线程处：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1242d911.jpg"></p>
<p>可以看到 Sender 线程有需要成员变量，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acks,retries,requestTimeout</span><br></pre></td></tr></table></figure>

<p>等，这些参数会在后文分析。</p>
<h3 id="序列化消息"><a href="#序列化消息" class="headerlink" title="序列化消息"></a>序列化消息</h3><p>在调用 <code>send()</code> 函数后其实第一步就是序列化，毕竟我们的消息需要通过网络才能发送到 Kafka。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d12561bc2.jpg"></p>
<p>其中的 <code>valueSerializer.serialize(record.topic(), record.value());</code> 是一个接口，我们需要在初始化时候指定序列化实现类。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d12b5da80.jpg"></p>
<p>我们也可以自己实现序列化，只需要实现 <code>org.apache.kafka.common.serialization.Serializer</code> 接口即可。</p>
<h3 id="路由分区"><a href="#路由分区" class="headerlink" title="路由分区"></a>路由分区</h3><p>接下来就是路由分区，通常我们使用的 <code>Topic</code> 为了实现扩展性以及高性能都会创建多个分区。</p>
<p>如果是一个分区好说，所有消息都往里面写入即可。</p>
<p>但多个分区就不可避免需要知道写入哪个分区。</p>
<p>通常有三种方式。</p>
<h4 id="指定分区"><a href="#指定分区" class="headerlink" title="指定分区"></a>指定分区</h4><p>可以在构建 <code>ProducerRecord</code> 为每条消息指定分区。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d12c3c202.jpg"></p>
<p>这样在路由时会判断是否有指定，有就直接使用该分区。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d12d27034.jpg"></p>
<p>这种一般在特殊场景下会使用。</p>
<h4 id="自定义路由策略"><a href="#自定义路由策略" class="headerlink" title="自定义路由策略"></a>自定义路由策略</h4><p><img src="https://i.loli.net/2019/05/08/5cd1d12e065fd.jpg"></p>
<p>如果没有指定分区，则会调用 <code>partitioner.partition</code> 接口执行自定义分区策略。</p>
<p>而我们也只需要自定义一个类实现 <code>org.apache.kafka.clients.producer.Partitioner</code> 接口，同时在创建 <code>KafkaProducer</code> 实例时配置 <code>partitioner.class</code> 参数。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d135e046c.jpg"></p>
<p>通常需要自定义分区一般是在想尽量的保证消息的顺序性。</p>
<p>或者是写入某些特有的分区，由特别的消费者来进行处理等。</p>
<h4 id="默认策略"><a href="#默认策略" class="headerlink" title="默认策略"></a>默认策略</h4><p>最后一种则是默认的路由策略，如果我们啥都没做就会执行该策略。</p>
<p>该策略也会使得消息分配的比较均匀。</p>
<p>来看看它的实现：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d13759e66.jpg"></p>
<p>简单的来说分为以下几步：</p>
<ul>
<li>获取 Topic 分区数。</li>
<li>将内部维护的一个线程安全计数器 +1。</li>
<li>与分区数取模得到分区编号。</li>
</ul>
<p>其实这就是很典型的轮询算法，所以只要分区数不频繁变动这种方式也会比较均匀。</p>
<h3 id="写入内部缓存"><a href="#写入内部缓存" class="headerlink" title="写入内部缓存"></a>写入内部缓存</h3><p>在 <code>send()</code> 方法拿到分区后会调用一个 <code>append()</code> 函数：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d138711e9.jpg"></p>
<p>该函数中会调用一个 <code>getOrCreateDeque()</code> 写入到一个内部缓存中 <code>batches</code>。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1394ac36.jpg"></p>
<h3 id="消费缓存"><a href="#消费缓存" class="headerlink" title="消费缓存"></a>消费缓存</h3><p>在最开始初始化的 IO 线程其实是一个守护线程，它会一直消费这些数据。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d13fc139d.jpg"></p>
<p>通过图中的几个函数会获取到之前写入的数据。这块内容可以不必深究，但其中有个 <code>completeBatch</code> 方法却非常关键。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d141d52c5.jpg"></p>
<p>调用该方法时候肯定已经是消息发送完毕了，所以会调用 <code>batch.done()</code> 来完成之前我们在 <code>send()</code> 方法中定义的回调接口。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d14327d87.jpg"></p>
<blockquote>
<p>从这里也可以看出为什么之前说发送完成后元数据和异常信息只会出现一个。</p>
</blockquote>
<h1 id="Producer-参数解析"><a href="#Producer-参数解析" class="headerlink" title="Producer 参数解析"></a>Producer 参数解析</h1><p>发送流程讲完了再来看看 <code>Producer</code> 中比较重要的几个参数。</p>
<h2 id="acks"><a href="#acks" class="headerlink" title="acks"></a>acks</h2><p><code>acks</code> 是一个影响消息吞吐量的一个关键参数。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d14413679.jpg"></p>
<p>主要有 <code>[all、-1, 0, 1]</code> 这几个选项，默认为 1。</p>
<p>由于 <code>Kafka</code> 不是采取的主备模式，而是采用类似于 Zookeeper 的主备模式。</p>
<blockquote>
<p>前提是 <code>Topic</code> 配置副本数量 <code>replica &gt; 1</code>。 </p>
</blockquote>
<p>当 <code>acks = all/-1</code> 时：</p>
<p>意味着会确保所有的 follower 副本都完成数据的写入才会返回。</p>
<p>这样可以保证消息不会丢失！</p>
<blockquote>
<p>但同时性能和吞吐量却是最低的。</p>
</blockquote>
<p>当 <code>acks = 0</code> 时：</p>
<p>producer 不会等待副本的任何响应，这样最容易丢失消息但同时性能却是最好的！</p>
<p>当 <code>acks = 1</code> 时：</p>
<p>这是一种折中的方案，它会等待副本 Leader 响应，但不会等到 follower 的响应。</p>
<p>一旦 Leader 挂掉消息就会丢失。但性能和消息安全性都得到了一定的保证。</p>
<h2 id="batch-size"><a href="#batch-size" class="headerlink" title="batch.size"></a>batch.size</h2><p>这个参数看名称就知道是内部缓存区的大小限制，对他适当的调大可以提高吞吐量。</p>
<p>但也不能极端，调太大会浪费内存。小了也发挥不了作用，也是一个典型的时间和空间的权衡。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1453fc23.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1464d1b3.jpg"></p>
<p>上图是几个使用的体现。</p>
<h2 id="retries"><a href="#retries" class="headerlink" title="retries"></a>retries</h2><p><code>retries</code> 该参数主要是来做重试使用，当发生一些网络抖动都会造成重试。</p>
<p>这个参数也就是限制重试次数。</p>
<p>但也有一些其他问题。</p>
<ul>
<li>因为是重发所以消息顺序可能不会一致，这也是上文提到就算是一个分区消息也不会是完全顺序的情况。</li>
<li>还是由于网络问题，本来消息已经成功写入了但是没有成功响应给 producer，进行重试时就可能会出现<code>消息重复</code>。这种只能是消费者进行幂等处理。</li>
</ul>
<h1 id="高效的发送方式"><a href="#高效的发送方式" class="headerlink" title="高效的发送方式"></a>高效的发送方式</h1><p>如果消息量真的非常大，同时又需要尽快的将消息发送到 <code>Kafka</code>。一个 <code>producer</code> 始终会收到缓存大小等影响。</p>
<p>那是否可以创建多个 <code>producer</code> 来进行发送呢？</p>
<ul>
<li>配置一个最大 producer 个数。</li>
<li>发送消息时首先获取一个 <code>producer</code>，获取的同时判断是否达到最大上限，没有就新建一个同时保存到内部的 <code>List</code> 中，保存时做好同步处理防止并发问题。</li>
<li>获取发送者时可以按照默认的分区策略使用轮询的方式获取（保证使用均匀）。</li>
</ul>
<p>这样在大量、频繁的消息发送场景中可以提高发送效率减轻单个 <code>producer</code> 的压力。</p>
<h1 id="关闭-Producer"><a href="#关闭-Producer" class="headerlink" title="关闭 Producer"></a>关闭 Producer</h1><p>最后则是 <code>Producer</code> 的关闭，Producer 在使用过程中消耗了不少资源（线程、内存、网络等）因此需要显式的关闭从而回收这些资源。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d14dd3792.jpg"></p>
<p>默认的 <code>close()</code> 方法和带有超时时间的方法都是在一定的时间后强制关闭。</p>
<p>但在过期之前都会处理完剩余的任务。</p>
<p>所以使用哪一个得视情况而定。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文内容较多，从实例和源码的角度分析了 Kafka 生产者。</p>
<p>希望看完的朋友能有收获，同时也欢迎留言讨论。</p>
<p>不出意外下期会讨论 Kafka 消费者。</p>
<blockquote>
<p>如果对你有帮助还请分享让更多的人看到。</p>
</blockquote>
<p><strong>欢迎关注公众号一起交流：</strong></p>
]]></content>
      <categories>
        <category>Kafka</category>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>从源码彻底理解 Prometheus/VictoriaMetrics 中的 relabel_configs/metric_relabel_configs 配置</title>
    <url>/2023/03/13/metrics/relabel_configs_%20metric_relabel_configs/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/03/11/Xxp5yNTH1ASBk3Z.png"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近接手维护了公司的指标监控系统，之后踩到坑就没站起来过。。<br><img src="https://s2.loli.net/2023/03/11/UwBJ28ZafziRsQS.png"></p>
<span id="more"></span>

<p>本次问题的起因是我们配置了一些指标的删除策略没有生效：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">action:</span> <span class="string">drop_metrics</span></span><br><span class="line">  <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br></pre></td></tr></table></figure>

<p>与这两个容易引起误解的配置<code>relabel_configs/metric_relabel_configs</code>有关。</p>
<p>他们都是对抓取的数据进行重命名、过滤、新增、删除等操作，但应用场景却完全不同。</p>
<blockquote>
<p>我们使用了 VictoriaMetrics 替换了 Prometheus，VM 完全兼容 Prometheus ，所以本文也对 Prometheus 同样适用。</p>
</blockquote>
<h1 id="理解错误1"><a href="#理解错误1" class="headerlink" title="理解错误1"></a>理解错误1</h1><p><img src="https://s2.loli.net/2023/03/12/9oYRlCGTZaNuc5j.png" alt="image.png"><br>但这里其实是有一个错误理解的，我是通过 VM 的服务发现页面的指标响应页面查询指标的，打开之后确实能搜到需要被删除的相关指标。</p>
<p>但其实即便是真的删除了数据这个页面也会有数据存在，删除的数据只是不会写入 VM 的时序数据库中。</p>
<blockquote>
<p>这一点是在后续查源码时才发现；后面我配置对了依然在这里查看数据，发现还是没有删除，这个错误理解浪费了不少时间😂。</p>
</blockquote>
<h1 id="理解错误2"><a href="#理解错误2" class="headerlink" title="理解错误2"></a>理解错误2</h1><p>为了解决问题，通过 <code>drop metrics</code> 这类关键字在 VM 的官方文档中查询，最终找到一篇文章。<br><a href="https://www.robustperception.io/dropping-metrics-at-scrape-time-with-prometheus/">https://www.robustperception.io/dropping-metrics-at-scrape-time-with-prometheus/</a><br><img src="https://s2.loli.net/2023/03/12/oRQKnf7u6j3Ulq5.png"></p>
<p>按照这里的介绍，将删除的配置加入到 <code>metric_relabel_configs</code> 配置下，经过测试确实有效。</p>
<p>不过为啥将同样的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">drop_metrics</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br></pre></td></tr></table></figure>

<p>加入到 <code>relabel_configs</code> 未能生效呢？</p>
<p>估计确实容易令人误导，在文档中也找到了相关的解释：<br><a href="https://www.robustperception.io/relabel_configs-vs-metric_relabel_configs/">https://www.robustperception.io/relabel_configs-vs-metric_relabel_configs&#x2F;</a><br><img src="https://s2.loli.net/2023/03/12/xyaqKjkf85YZzeA.png"><br>这篇文章主要是表达几个重点：</p>
<ul>
<li><code>relabel_configs</code> 用于配置哪个目标需要被抓取，发生在指标抓取之前。</li>
<li><code>metric_relabel_configs</code> 发生在指标抓取之后，写入存储之前。</li>
<li>如果其中一个没生效，就换一个（这句话很容易让人犯迷糊）</li>
</ul>
<p>但说实话当时我看到这里还是一脸懵，为了彻底了解两则的区别还是看源码来的直接。</p>
<h2 id="阅读源码理解本质原因"><a href="#阅读源码理解本质原因" class="headerlink" title="阅读源码理解本质原因"></a>阅读源码理解本质原因</h2><h3 id="metric-relabel-configs"><a href="#metric-relabel-configs" class="headerlink" title="metric_relabel_configs"></a>metric_relabel_configs</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">metric_relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">drop_metrics</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br></pre></td></tr></table></figure>
<p>首先看下<code>metric_relabel_configs</code>配置生效的原因。</p>
<p><img src="https://s2.loli.net/2023/03/12/dWA4a3kzGPIxFEX.png"></p>
<p><code>metric_relabel_configs</code> 配置的整体流程如上图：</p>
<ul>
<li>启动 VM 时加载配置到内存</li>
<li>根据配置的抓取间隔时间(<code>scrape_interval</code>)抓取数据，拿到的每一条数据都需要通过 <code>metric_relabel_configs</code> 的应用。</li>
<li>针对于这里的 <code>drop_metrics</code> 来说，就是判断是否需要删除掉所有的 <code>Label</code>。</li>
<li>如果可以匹配删除，那就不会写入存储。</li>
</ul>
<p>其中的关键代码如下：<br><img src="https://s2.loli.net/2023/03/12/ZlIKFDbhLVpx8Om.png"></p>
<p>这里还有一个小细节，源码里判断的 <code>action</code> 是 <code>drop</code>，而我们配置的是 <code>drop_metrics</code>，其实 <code>drop_metrics</code> 也是 drop 的一个封装而已。</p>
<p><img src="https://s2.loli.net/2023/03/12/2kQ9rSBsJ3IuAwm.png"><br>在解析配置的时候会进行转换。</p>
<p>与这个写法是等价的：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">source_labels:</span> [ <span class="string">__name__</span> ]</span><br><span class="line">  <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br><span class="line">  <span class="attr">action:</span> <span class="string">drop</span></span><br></pre></td></tr></table></figure>

<h3 id="relabel-configs"><a href="#relabel-configs" class="headerlink" title="relabel_configs"></a>relabel_configs</h3><p>然后来看看 <code>relabel_configs</code> 没有按照预期生效的原因。</p>
<p><img src="https://s2.loli.net/2023/03/12/itlzeXC8DNhpQf4.png"></p>
<p>其实核心的应用配置就是同一份代码，只是触发点不一样。</p>
<p><code>relabel_configs</code> 是在应用启动的时候根据我们配置的抓取目标的数据当做数据源，所以这里的 <code>action: drop</code> 删除的是抓取目标，而不是真正的抓取数据。<br><img src="https://s2.loli.net/2023/03/12/qXbwjh5e3uRds4z.png"></p>
<p>而且它的目的是在应用启动的时候，用于生成抓取目标的任务，<strong>只会运行一次</strong>。</p>
<p>假设我这里改写为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [ <span class="string">__address__</span> ]</span><br><span class="line">      <span class="attr">regex:</span> <span class="string">&#x27;192.xx.xx.xx:443&#x27;</span></span><br><span class="line">      <span class="attr">action:</span> <span class="string">drop</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/03/12/SfJnMP547ltQohW.png"><br>那么我这个抓取任务就会被删除掉，而不是删除这个指标了。</p>
<p>因此之前我在这里配置的是一些业务指标 <code>regex: &quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</code>，在所有元数据里自然是没有任何一个可以匹配了，所以也就无事发生。</p>
<blockquote>
<p>元数据都是以 <code>__</code> 开头。</p>
</blockquote>
<hr>
<p>其实 VM 也有提供一个 Debug 页面用于调试 <code>relabel_configs</code>，但如果知道怎么用这个调试页面其实也理解了他的运行原理😂<br><img src="https://s2.loli.net/2023/03/12/q8KAwpOsBMIEXT3.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://www.robustperception.io/relabelling-can-discard-targets-timeseries-and-alerts/">https://www.robustperception.io/relabelling-can-discard-targets-timeseries-and-alerts/</a> </p>
<p><img src="https://s2.loli.net/2023/03/12/lJsntMyoCruRYi7.png"><br>后面我查到这篇文章也有相关解释，理解了两者的区别后再看这里的分析会更加容易理解。</p>
<p>总的来说：</p>
<ul>
<li><code>relabel_configs</code> 用于对抓取目标元数据的增删改；如果删除后连后续的抓取任务也会被取消。</li>
<li><code>metric_relabel_configs</code> 用于对抓取到的数据增删改，对于不需要的业务指标可以在这里配置。</li>
</ul>
<p>也就是前文讲到的 <code>relabel_configs</code> 应用于指标抓取前，<code>metric_relabel_configs</code> 应用于指标抓取后。</p>
]]></content>
      <categories>
        <category>metrics</category>
      </categories>
      <tags>
        <tag>K8s</tag>
        <tag>Prometheus</tag>
        <tag>VictoriaMetrics</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生背景下如何配置 JVM 内存</title>
    <url>/2023/05/15/k8s/cloudnative-java/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/05/12/IAxSF3oZ1j8GHbi.png" alt="image.png"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间业务研发反馈说是他的应用内存使用率很高，导致频繁的重启，让我排查下是怎么回事；</p>
<p>在这之前我也没怎么在意过这个问题，正好这次排查分析的过程做一个记录。</p>
<span id="more"></span>

<p>首先我查看了监控面板里的 Pod 监控：<br><img src="https://s2.loli.net/2023/05/14/wyYu8SI7eGprqmQ.png" alt="WeChatWorkScreenshot_ac6f8d80-bdb4-469e-af1a-b2199c9ee288.png"></p>
<p>发现确实是快满了，而此时去查看应用的 JVM 占用情况却只有30%左右；说明并不是应用内存满了导致 JVM 的 OOM，而是 Pod 的内存满了，导致 Pod 的内存溢出，从而被 k8s 杀掉了。</p>
<p>而 <code>k8s</code> 为了维持应用的副本数量就得重启一个 Pod，所以看起来就是应用运行一段时间后就被重启。</p>
<hr>
<p><img src="https://s2.loli.net/2023/05/14/Lhkjys1TEQUKV86.png" alt="WeChatWorkScreenshot_6213e2f8-c429-4d33-acdd-e639275dd92b.png"><br>而这个应用配置的是 JVM 8G，容器申请的内存是16G，所以 Pod 的内存占用看起来也就 50% 左右。</p>
<h1 id="容器的原理"><a href="#容器的原理" class="headerlink" title="容器的原理"></a>容器的原理</h1><p>在解决这个问题之前还是先简单了解下容器的运行原理，因为在 k8s 中所有的应用都是运行在容器中的，而容器本质上也是运行在宿主机上的一个个进程而已。</p>
<p>但我们使用 Docker 的时候会感觉每个容器启动的应用之间互不干扰，从文件系统、网络、CPU、内存这些都能完全隔离开来，就像两个运行在不同的服务器中的应用。</p>
<p>其实这一点也不是啥黑科技，Linux 早就支持 2.6.x 的版本就已经支持 <code>namespace</code> 隔离了，使用 <code>namespace</code> 可以将两个进程完全隔离。</p>
<p>仅仅将资源隔离还不够，还需要限制对资源的使用，比如 CPU、内存、磁盘、带宽这些也得做限制；这点也可以使用 <code>cgroups</code> 进行配置。</p>
<p>它可以限制某个进程的资源，比如宿主机是 4 核 CPU，8G 内存，为了保护其他容器，必须给这个容器配置使用上限：1核 CPU，2G内存。</p>
<p><img src="https://s2.loli.net/2023/05/14/dzcHK6G8VZQuFC5.png" alt="image.png"></p>
<p>这张图就很清晰的表示了 <code>namespace</code>  和 <code>cgroups</code> 在容器技术中的作用，简单来说就是：</p>
<ul>
<li>namespace 负责隔离</li>
<li>cgroups 负责限制</li>
</ul>
<p>在 k8s 中也有对应的提现：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="number">0.1</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>这个资源清单表示该应用至少需要为一个容器分配一个 0.1 核和 1024M 的资源，CPU 的最高上限为 4 个核心。</p>
<h1 id="不同的OOM"><a href="#不同的OOM" class="headerlink" title="不同的OOM"></a>不同的OOM</h1><p>回到本次的问题，可以确认是容器发生了 OOM 从而导致被 k8s 重启，这也是我们配置 limits 的作用。</p>
<blockquote>
<p>k8s 内存溢出导致容器退出会出现 exit code 137 的一个 event 日志。</p>
</blockquote>
<p>因为该应用的 JVM 内存配置和容器的配置大小是一样的，都是8GB，但 Java 应用还有一些非 JVM 管理的内存，比如堆外内存之类的，这样很容易就导致容器内存大小超过了限制的 8G 了，也就导致了容器内存溢出。</p>
<h1 id="云原生背景的优化"><a href="#云原生背景的优化" class="headerlink" title="云原生背景的优化"></a>云原生背景的优化</h1><p>因为这个应用本身使用的内存不多，所以建议将堆内存限制到 4GB，这样就避免了容器内存超限，从而解决了问题。</p>
<p>当然之后我们也会在应用配置栏里加上建议：推荐 JVM 的配置小于容器限制的 2&#x2F;3，预留一些内存。</p>
<p>其实本质上还是开发模式没有转变过来，以传统的 Java 应用开发模式甚至都不会去了解容器的内存大小，因为以前大家的应用都是部署在一个内存较大的虚拟机上，所以感知不到容器内存的限制。</p>
<p>从而误以为将两者画了等号，这一点可能在 Java 应用中尤为明显，毕竟多了一个 JVM；甚至在老版本的 JDK 中如果没有设置堆内存大小，无法感知到容器的内存限制，从而自动生成的 Xmx 大于了容器的内存大小，以致于 OOM。</p>
]]></content>
      <categories>
        <category>cloudnative</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>K8s</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Grafana 变量转义处理</title>
    <url>/2023/06/26/k8s/grafana-variable/</url>
    <content><![CDATA[<p>Grafana 是一款强大的可视化工具，不止是用于 Prometheus 做数据源，还可以集成数据库、日志等作为数据源整体使用。</p>
<p>最近我在配置一个监控面板，其中的数据由 Prometheus 和 MySQL 组成；简单来说就是一个指标的查询条件是从数据库中来的。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pulsar_subscription_back_log_no_delayed&#123;topic=~&quot;$topic&quot;,subscription=~&quot;$subscription&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>其中的 topic 数据是从  MySQL 中来的，其实就是在 Grafana 声明一个变量，从数据库返回了一个列表。</p>
<p><img src="https://s2.loli.net/2023/06/25/OE37acurFIQjVNH.png"></p>
<p>因为我们的查询条件是 <code>topic=~&quot;$topic&quot;</code>是正则匹配，所以理论上应该把所有的 <code>topic</code> 关联的数据都查询出来。</p>
<p><img src="https://s2.loli.net/2023/06/25/WMetKBAvg24hzZk.png"></p>
<p>但实际情况是任何数据都查不到。</p>
<p>查看发出去的原始请求后才发现问题出在哪里：</p>
<p><img src="https://s2.loli.net/2023/06/25/AUXs9lnHoYMQjhO.png"></p>
<p>原来是选择所有 topic 后 grafana 会~~~~自动对参数转义，这个我查了好多资料包括咨询 ChatGPT 都没有得到解决。</p>
<p>经过多次测试，发现只要开启多选 grafana 就会自动转义。<br><img src="https://s2.loli.net/2023/06/25/ao51AysPEeiTQNr.png"></p>
<p>最后我只能想到一个不需要生成多行记录的办法：将所有数据合并成一条记录。</p>
<p><img src="https://s2.loli.net/2023/06/25/o7Xaf3NKD1rystn.png"></p>
<p>这样的话就只会生成一条数据，其中包含了所有的 topic，也就避免了被转义。</p>
<blockquote>
<p>SQL 中的 CONCAT 函数其实我也不知道怎么使用，还是 ChatGPT 告诉我的。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/06/25/InPYWyiqAL1xRfK.png"></p>
<p>最后便能完美的查询出数据了。</p>
<p>有碰到类似问题的朋友可以尝试这个方法，我估计用到这个场景的并不多，不然 ChatGPT 也不会不知道。</p>
]]></content>
      <categories>
        <category>cloudnative</category>
      </categories>
      <tags>
        <tag>Grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty(一) SpringBoot 整合长连接心跳机制</title>
    <url>/2018/05/24/netty/Netty(1)TCP-Heartbeat/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/05/25/5b0774828db53.jpeg" alt="photo-1522204657746-fccce0824cfd.jpeg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Netty 是一个高性能的 NIO 网络框架，本文基于 SpringBoot 以常见的心跳机制来认识 Netty。</p>
<p>最终能达到的效果：</p>
<ul>
<li>客户端每隔 N 秒检测是否需要发送心跳。</li>
<li>服务端也每隔 N 秒检测是否需要发送心跳。</li>
<li>服务端可以主动 push 消息到客户端。</li>
<li>基于 SpringBoot 监控，可以查看实时连接以及各种应用信息。</li>
</ul>
<p>效果如下：</p>
<p><img src="https://crossoverjie.top/uploads/netty-Heartbeat.gif" alt="show"></p>
<span id="more"></span>

<h1 id="IdleStateHandler"><a href="#IdleStateHandler" class="headerlink" title="IdleStateHandler"></a>IdleStateHandler</h1><p>Netty 可以使用 IdleStateHandler 来实现连接管理，当连接空闲时间太长（没有发送、接收消息）时则会触发一个事件，我们便可在该事件中实现心跳机制。</p>
<h2 id="客户端心跳"><a href="#客户端心跳" class="headerlink" title="客户端心跳"></a>客户端心跳</h2><p>当客户端空闲了 N 秒没有给服务端发送消息时会自动发送一个心跳来维持连接。</p>
<p>核心代码代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoClientHandle</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;ByteBuf&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(EchoClientHandle.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            <span class="type">IdleStateEvent</span> <span class="variable">idleStateEvent</span> <span class="operator">=</span> (IdleStateEvent) evt ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (idleStateEvent.state() == IdleState.WRITER_IDLE)&#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;已经 10 秒没有发送信息！&quot;</span>);</span><br><span class="line">                <span class="comment">//向服务端发送消息</span></span><br><span class="line">                <span class="type">CustomProtocol</span> <span class="variable">heartBeat</span> <span class="operator">=</span> SpringBeanFactory.getBean(<span class="string">&quot;heartBeat&quot;</span>, CustomProtocol.class);</span><br><span class="line">                ctx.writeAndFlush(heartBeat).addListener(ChannelFutureListener.CLOSE_ON_FAILURE) ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf in)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从服务端收到消息时被调用</span></span><br><span class="line">        LOGGER.info(<span class="string">&quot;客户端收到消息=&#123;&#125;&quot;</span>,in.toString(CharsetUtil.UTF_8)) ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>实现非常简单，只需要在事件回调中发送一个消息即可。</p>
<p>由于整合了 SpringBoot ，所以发送的心跳信息是一个单例的 Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartBeatConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;channel.id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;heartBeat&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CustomProtocol <span class="title function_">heartBeat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomProtocol</span>(id,<span class="string">&quot;ping&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到了自定义协议的内容，请继续查看下文。</p>
<p>当然少不了启动引导：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartbeatClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(HeartbeatClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;netty.server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nettyPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;netty.server.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SocketChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">CustomerHandleInitializer</span>())</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(host, nettyPort).sync();</span><br><span class="line">        <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;启动 Netty 成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel = (SocketChannel) future.channel();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerHandleInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ch.pipeline()</span><br><span class="line">                <span class="comment">//10 秒没发送消息 将IdleStateHandler 添加到 ChannelPipeline 中</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>))</span><br><span class="line">                .addLast(<span class="keyword">new</span> <span class="title class_">HeartbeatEncode</span>())</span><br><span class="line">                .addLast(<span class="keyword">new</span> <span class="title class_">EchoClientHandle</span>())</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>所以当应用启动每隔 10 秒会检测是否发送过消息，不然就会发送心跳信息。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d54648799.jpg"></p>
<h2 id="服务端心跳"><a href="#服务端心跳" class="headerlink" title="服务端心跳"></a>服务端心跳</h2><p>服务器端的心跳其实也是类似，也需要在 ChannelPipeline 中添加一个 IdleStateHandler 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartBeatSimpleHandle</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;CustomProtocol&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(HeartBeatSimpleHandle.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">HEART_BEAT</span> <span class="operator">=</span>  Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(<span class="keyword">new</span> <span class="title class_">CustomProtocol</span>(<span class="number">123456L</span>,<span class="string">&quot;pong&quot;</span>).toString(),CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消绑定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        NettySocketHolder.remove((NioSocketChannel) ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            <span class="type">IdleStateEvent</span> <span class="variable">idleStateEvent</span> <span class="operator">=</span> (IdleStateEvent) evt ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (idleStateEvent.state() == IdleState.READER_IDLE)&#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;已经5秒没有收到信息！&quot;</span>);</span><br><span class="line">                <span class="comment">//向客户端发送消息</span></span><br><span class="line">                ctx.writeAndFlush(HEART_BEAT).addListener(ChannelFutureListener.CLOSE_ON_FAILURE) ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, CustomProtocol customProtocol)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;收到customProtocol=&#123;&#125;&quot;</span>, customProtocol);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存客户端与 Channel 之间的关系</span></span><br><span class="line">        NettySocketHolder.put(customProtocol.getId(),(NioSocketChannel)ctx.channel()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里有点需要注意</strong>：</p>
<p>当有多个客户端连上来时，服务端需要区分开，不然响应消息就会发生混乱。</p>
<p>所以每当有个连接上来的时候，我们都将当前的 Channel 与连上的客户端 ID 进行关联（<strong>因此每个连上的客户端 ID 都必须唯一</strong>）。</p>
<p>这里采用了一个 Map 来保存这个关系，并且在断开连接时自动取消这个关联。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettySocketHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, NioSocketChannel&gt; MAP = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Long id, NioSocketChannel socketChannel)</span> &#123;</span><br><span class="line">        MAP.put(id, socketChannel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> NioSocketChannel <span class="title function_">get</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MAP.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Long, NioSocketChannel&gt; <span class="title function_">getMAP</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MAP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(NioSocketChannel nioSocketChannel)</span> &#123;</span><br><span class="line">        MAP.entrySet().stream().filter(entry -&gt; entry.getValue() == nioSocketChannel).forEach(entry -&gt; MAP.remove(entry.getKey()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动引导程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Component</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartBeatServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(HeartBeatServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">EventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">EventLoopGroup</span> <span class="variable">work</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;netty.server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nettyPort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 Netty</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                .group(boss, work)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .localAddress(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(nettyPort))</span><br><span class="line">                <span class="comment">//保持长连接</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">HeartbeatInitializer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind().sync();</span><br><span class="line">        <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;启动 Netty 成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        boss.shutdownGracefully().syncUninterruptibly();</span><br><span class="line">        work.shutdownGracefully().syncUninterruptibly();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;关闭 Netty 成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartbeatInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ch.pipeline()</span><br><span class="line">                <span class="comment">//五秒没有收到消息 将IdleStateHandler 添加到 ChannelPipeline 中</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">                .addLast(<span class="keyword">new</span> <span class="title class_">HeartbeatDecoder</span>())</span><br><span class="line">                .addLast(<span class="keyword">new</span> <span class="title class_">HeartBeatSimpleHandle</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也是同样将IdleStateHandler 添加到 ChannelPipeline 中，也会有一个定时任务，每5秒校验一次是否有收到消息，否则就主动发送一次请求。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d54fe2535.jpg"></p>
<p>因为测试是有两个客户端连上所以有两个日志。</p>
<h2 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h2><p>上文其实都看到了：服务端与客户端采用的是自定义的 POJO 进行通讯的。</p>
<p>所以需要在客户端进行编码，服务端进行解码，也都只需要各自实现一个编解码器即可。</p>
<p>CustomProtocol：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomProtocol</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4671171056588401542L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id ;</span><br><span class="line">    <span class="keyword">private</span> String content ;</span><br><span class="line">    <span class="comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端的编码器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartbeatEncode</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;CustomProtocol&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, CustomProtocol msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        out.writeLong(msg.getId()) ;</span><br><span class="line">        out.writeBytes(msg.getContent().getBytes()) ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说消息的前八个字节为 header，剩余的全是 content。</p>
<p>服务端的解码器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartbeatDecoder</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> in.readLong() ;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[in.readableBytes()] ;</span><br><span class="line">        in.readBytes(bytes) ;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes) ;</span><br><span class="line"></span><br><span class="line">        <span class="type">CustomProtocol</span> <span class="variable">customProtocol</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomProtocol</span>() ;</span><br><span class="line">        customProtocol.setId(id);</span><br><span class="line">        customProtocol.setContent(content) ;</span><br><span class="line">        out.add(customProtocol) ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要按照刚才的规则进行解码即可。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>其实联想到 IdleStateHandler 的功能，自然也能想到它实现的原理：</p>
<blockquote>
<p>应该会存在一个定时任务的线程去处理这些消息。</p>
</blockquote>
<p>来看看它的源码：</p>
<p>首先是构造函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public IdleStateHandler(</span><br><span class="line">        int readerIdleTimeSeconds,</span><br><span class="line">        int writerIdleTimeSeconds,</span><br><span class="line">        int allIdleTimeSeconds) &#123;</span><br><span class="line"></span><br><span class="line">    this(readerIdleTimeSeconds, writerIdleTimeSeconds, allIdleTimeSeconds,</span><br><span class="line">         TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是初始化了几个数据：</p>
<ul>
<li>readerIdleTimeSeconds：一段时间内没有数据读取</li>
<li>writerIdleTimeSeconds：一段时间内没有数据发送</li>
<li>allIdleTimeSeconds：以上两种满足其中一个即可</li>
</ul>
<p>因为 IdleStateHandler 也是一种 ChannelHandler，所以会在 <code>channelActive</code> 中初始化任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// This method will be invoked only if this handler was added</span></span><br><span class="line">    <span class="comment">// before channelActive() event is fired.  If a user adds this handler</span></span><br><span class="line">    <span class="comment">// after the channelActive() event, initialize() will be called by beforeAdd().</span></span><br><span class="line">    initialize(ctx);</span><br><span class="line">    <span class="built_in">super</span>.channelActive(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">    <span class="comment">// Avoid the case where destroy() is called before scheduling timeouts.</span></span><br><span class="line">    <span class="comment">// See: https://github.com/netty/netty/issues/143</span></span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state = <span class="number">1</span>;</span><br><span class="line">    initOutputChanged(ctx);</span><br><span class="line"></span><br><span class="line">    lastReadTime = lastWriteTime = ticksInNanos();</span><br><span class="line">    <span class="keyword">if</span> (readerIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        readerIdleTimeout = schedule(ctx, <span class="keyword">new</span> <span class="title class_">ReaderIdleTimeoutTask</span>(ctx),</span><br><span class="line">                readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        writerIdleTimeout = schedule(ctx, <span class="keyword">new</span> <span class="title class_">WriterIdleTimeoutTask</span>(ctx),</span><br><span class="line">                writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        allIdleTimeout = schedule(ctx, <span class="keyword">new</span> <span class="title class_">AllIdleTimeoutTask</span>(ctx),</span><br><span class="line">                allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>也就是会按照我们给定的时间初始化出定时任务。</p>
<p>接着在任务真正执行时进行判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ReaderIdleTimeoutTask</span> <span class="keyword">extends</span> <span class="title class_">AbstractIdleTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    ReaderIdleTimeoutTask(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        <span class="built_in">super</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">nextDelay</span> <span class="operator">=</span> readerIdleTimeNanos;</span><br><span class="line">        <span class="keyword">if</span> (!reading) &#123;</span><br><span class="line">            nextDelay -= ticksInNanos() - lastReadTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextDelay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Reader is idle - set a new timeout and notify the callback.</span></span><br><span class="line">            readerIdleTimeout = schedule(ctx, <span class="built_in">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> firstReaderIdleEvent;</span><br><span class="line">            firstReaderIdleEvent = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> newIdleStateEvent(IdleState.READER_IDLE, first);</span><br><span class="line">                channelIdle(ctx, event);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                ctx.fireExceptionCaught(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Read occurred before the timeout - set a new timeout with shorter delay.</span></span><br><span class="line">            readerIdleTimeout = schedule(ctx, <span class="built_in">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果满足条件则会生成一个 IdleStateEvent 事件。</p>
<h1 id="SpringBoot-监控"><a href="#SpringBoot-监控" class="headerlink" title="SpringBoot 监控"></a>SpringBoot 监控</h1><p>由于整合了 SpringBoot 之后不但可以利用 Spring 帮我们管理对象，也可以利用它来做应用监控。</p>
<h2 id="actuator-监控"><a href="#actuator-监控" class="headerlink" title="actuator 监控"></a>actuator 监控</h2><p>当我们为引入了:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就开启了 SpringBoot 的 actuator 监控功能，他可以暴露出很多监控端点供我们使用。</p>
<p>如一些应用中的一些统计数据：<br><img src="https://i.loli.net/2019/05/08/5cd1d555538b7.jpg"></p>
<p>存在的 Beans：<br><img src="https://i.loli.net/2019/05/08/5cd1d569ca76a.jpg"></p>
<p>更多信息请查看：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html">https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html</a></p>
<p>但是如果我想监控现在我的服务端有多少客户端连上来了，分别的 ID 是多少？</p>
<p>其实就是实时查看我内部定义的那个关联关系的 Map。</p>
<p>这就需要暴露自定义端点了。</p>
<h2 id="自定义端点"><a href="#自定义端点" class="headerlink" title="自定义端点"></a>自定义端点</h2><p>暴露的方式也很简单：</p>
<p>继承 AbstractEndpoint 并复写其中的 invoke 函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractEndpoint</span>&lt;Map&lt;Long,NioSocketChannel&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监控端点的 访问地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomEndpoint</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="comment">//false 表示不是敏感端点</span></span><br><span class="line">        <span class="built_in">super</span>(id, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Long, NioSocketChannel&gt; <span class="title function_">invoke</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> NettySocketHolder.getMAP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是返回了 Map 中的数据。</p>
<p>再配置一个该类型的 Bean 即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EndPointConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;monitor.channel.map.key&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String channelMap;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomEndpoint <span class="title function_">buildEndPoint</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CustomEndpoint</span> <span class="variable">customEndpoint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomEndpoint</span>(channelMap) ;</span><br><span class="line">        <span class="keyword">return</span> customEndpoint ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以通过配置文件中的 <code>monitor.channel.map.key</code> 来访问了：</p>
<p>一个客户端连接时：<br><img src="https://i.loli.net/2019/05/08/5cd1d56d1fd2d.jpg"></p>
<p>两个客户端连接时：<br><img src="https://i.loli.net/2019/05/08/5cd1d6e3140db.jpg"></p>
<h2 id="整合-SBA"><a href="#整合-SBA" class="headerlink" title="整合 SBA"></a>整合 SBA</h2><p>这样其实监控功能已经可以满足了，但能不能展示的更美观、并且多个应用也可以方便查看呢？</p>
<p>有这样的开源工具帮我们做到了：</p>
<p><a href="https://github.com/codecentric/spring-boot-admin">https://github.com/codecentric/spring-boot-admin</a></p>
<p>简单来说我们可以利用该工具将 actuator 暴露出来的接口可视化并聚合的展示在页面中：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d6e7c835b.jpg"></p>
<p>接入也很简单，首先需要引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>并在配置文件中加入：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭健康检查权限</span></span><br><span class="line"><span class="attr">management.security.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># SpringAdmin 地址</span></span><br><span class="line"><span class="attr">spring.boot.admin.url</span>=<span class="string">http://127.0.0.1:8888</span></span><br></pre></td></tr></table></figure>

<p>在启动应用之前先讲 SpringBootAdmin 部署好：</p>
<p>这个应用就是一个纯粹的 SpringBoot ，只需要在主函数上加入 <code>@EnableAdminServer</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(AdminApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-server-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后直接启动就行了。</p>
<p>这样我们在 SpringBootAdmin 的页面中就可以查看很多应用信息了。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d6ed19d78.jpg"></p>
<p>更多内容请参考官方指南：</p>
<p><a href="http://codecentric.github.io/spring-boot-admin/1.5.6/">http://codecentric.github.io/spring-boot-admin/1.5.6/</a></p>
<h3 id="自定义监控数据"><a href="#自定义监控数据" class="headerlink" title="自定义监控数据"></a>自定义监控数据</h3><p>其实我们完全可以借助 actuator 以及这个可视化页面帮我们监控一些简单的度量信息。</p>
<p>比如我在客户端和服务端中写了两个 Rest 接口用于向对方发送消息。</p>
<p>只是想要记录分别发送了多少次：</p>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计 service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CounterService counterService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HeartbeatClient heartbeatClient ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向服务端发消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sendMsgReqVO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;客户端发送消息&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;sendMsg&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> BaseResponse&lt;SendMsgResVO&gt; <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@RequestBody</span> SendMsgReqVO sendMsgReqVO)</span>&#123;</span><br><span class="line">        BaseResponse&lt;SendMsgResVO&gt; res = <span class="keyword">new</span> <span class="title class_">BaseResponse</span>();</span><br><span class="line">        heartbeatClient.sendMsg(<span class="keyword">new</span> <span class="title class_">CustomProtocol</span>(sendMsgReqVO.getId(),sendMsgReqVO.getMsg())) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用 actuator 来自增</span></span><br><span class="line">        counterService.increment(Constants.COUNTER_CLIENT_PUSH_COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="type">SendMsgResVO</span> <span class="variable">sendMsgResVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendMsgResVO</span>() ;</span><br><span class="line">        sendMsgResVO.setMsg(<span class="string">&quot;OK&quot;</span>) ;</span><br><span class="line">        res.setCode(StatusEnum.SUCCESS.getCode()) ;</span><br><span class="line">        res.setMessage(StatusEnum.SUCCESS.getMessage()) ;</span><br><span class="line">        res.setDataBody(sendMsgResVO) ;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要我们引入了 actuator 的包，那就可以直接注入 counterService ，利用它来帮我们记录数据。</p>
<p>当我们调用该接口时：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d6f026a21.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d6f5911b1.jpg"></p>
<p>在监控页面中可以查询刚才的调用情况：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d6fa3cec7.jpg"></p>
<p>服务端主动 push 消息也是类似，只是需要在发送时候根据客户端的 ID 查询到具体的 Channel 发送：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d6fd37fb9.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d7009a4ef.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d704eb0a6.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是一个简单 Netty 心跳示例，并演示了 SpringBoot 的监控，之后会继续更新 Netty 相关内容，欢迎关注及指正。</p>
<p>本文所有代码：</p>
<p><a href="https://github.com/crossoverJie/netty-action">https://github.com/crossoverJie/netty-action</a></p>
<h1 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h1><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>TCP</tag>
        <tag>Heartbeat</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty(二) 从线程模型的角度看 Netty 为什么是高性能的？</title>
    <url>/2018/07/04/netty/Netty(2)Thread-model/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d5154c72b.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的 <a href="http://t.cn/Rd7He1Z">SpringBoot 整合长连接心跳机制</a> 一文中认识了 Netty。</p>
<p>但其实只是能用，为什么要用 Netty？它有哪些优势？这些其实都不清楚。</p>
<p>本文就来从历史源头说道说道。</p>
<h2 id="传统-IO"><a href="#传统-IO" class="headerlink" title="传统 IO"></a>传统 IO</h2><p>在 Netty 以及 NIO 出现之前，我们写 IO 应用其实用的都是用 <code>java.io.*</code> 下所提供的包。  </p>
<p>比如下面的伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServeSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServeSocket</span>(<span class="number">8080</span>);</span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept() ;</span><br><span class="line"><span class="type">BufferReader</span> <span class="variable">in</span> <span class="operator">=</span> .... ;</span><br><span class="line"></span><br><span class="line">String request ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>((request = in.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>()).start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>大概是这样，其实主要想表达的是：<strong>这样一个线程只能处理一个连接</strong>。</p>
<p>如果是 100 个客户端连接那就得开 100 个线程，1000 那就得 1000 个线程。</p>
<p>要知道线程资源非常宝贵，每次的创建都会带来消耗，而且每个线程还得为它分配对应的栈内存。</p>
<p>即便是我们给 JVM 足够的内存，大量线程所带来的上下文切换也是受不了的。</p>
<blockquote>
<p>并且传统 IO 是阻塞模式，每一次的响应必须的是发起 IO 请求，处理请求完成再同时返回，直接的结果就是性能差，吞吐量低。</p>
</blockquote>
<h2 id="Reactor-模型"><a href="#Reactor-模型" class="headerlink" title="Reactor 模型"></a>Reactor 模型</h2><p>因此业界常用的高性能 IO 模型是 <code>Reactor</code>。</p>
<p>它是一种异步、非阻塞的事件驱动模型。</p>
<p>通常也表现为以下三种方式：</p>
<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p><img src="https://i.loli.net/2019/05/08/5cd1d517b9784.jpg"></p>
<p>从图中可以看出：</p>
<p>它是由一个线程来接收客户端的连接，并将该请求分发到对应的事件处理 handler 中，整个过程完全是异步非阻塞的；并且完全不存在共享资源的问题。所以理论上来说吞吐量也还不错。</p>
<blockquote>
<p>但由于是一个线程，对多核 CPU 利用率不高，一旦有大量的客户端连接上来性能必然下降，甚至会有大量请求无法响应。<br>最坏的情况是一旦这个线程哪里没有处理好进入了死循环那整个服务都将不可用！</p>
</blockquote>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p><img src="https://i.loli.net/2019/05/08/5cd1d51b21bb6.jpg"></p>
<p>因此产生了多线程模型。</p>
<p>其实最大的改进就是将原有的事件处理改为了多线程。</p>
<p>可以基于 Java 自身的线程池实现，这样在大量请求的处理上性能提示是巨大的。</p>
<p>虽然如此，但理论上来说依然有一个地方是单点的；那就是处理客户端连接的线程。</p>
<p>因为大多数服务端应用或多或少在连接时都会处理一些业务，如鉴权之类的，当连接的客户端越来越多时这一个线程依然会存在性能问题。</p>
<p>于是又有了下面的线程模型。</p>
<h3 id="主从多线程"><a href="#主从多线程" class="headerlink" title="主从多线程"></a>主从多线程</h3><p><img src="https://i.loli.net/2019/05/08/5cd1d51da676a.jpg"></p>
<p>该模型将客户端连接那一块的线程也改为多线程，称为主线程。</p>
<p>同时也是多个子线程来处理事件响应，这样无论是连接还是事件都是高性能的。</p>
<h2 id="Netty-实现"><a href="#Netty-实现" class="headerlink" title="Netty 实现"></a>Netty 实现</h2><p>以上谈了这么多其实 Netty 的线程模型与之的类似。</p>
<p>我们回到之前 <a href="https://crossoverjie.top/2018/05/24/netty/Netty(1)TCP-Heartbeat/">SpringBoot 整合长连接心跳机制</a> 中的服务端代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">EventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">EventLoopGroup</span> <span class="variable">work</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动 Netty</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">            .group(boss, work)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .localAddress(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(nettyPort))</span><br><span class="line">            <span class="comment">//保持长连接</span></span><br><span class="line">            .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">            .childHandler(<span class="keyword">new</span> <span class="title class_">HeartbeatInitializer</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind().sync();</span><br><span class="line">    <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;启动 Netty 成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这里的 boss 就相当于 Reactor 模型中处理客户端连接的线程池。</p>
<p>work 自然就是处理事件的线程池了。</p>
<p>那么如何来实现上文的三种模式呢？其实也很简单：</p>
<p>单线程模型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                .group(group)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">HeartbeatInitializer</span>());</span><br></pre></td></tr></table></figure>

<p>多线程模型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">EventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="type">EventLoopGroup</span> <span class="variable">work</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                .group(boss,work)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">HeartbeatInitializer</span>());</span><br></pre></td></tr></table></figure>

<p>主从多线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">EventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">EventLoopGroup</span> <span class="variable">work</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                .group(boss,work)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">HeartbeatInitializer</span>());</span><br></pre></td></tr></table></figure>

<p>相信大家一看也明白。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实看过了 Netty 的线程模型之后能否对我们平时做高性能应用带来点启发呢？</p>
<p>我认为是可以的：</p>
<ul>
<li>接口同步转异步处理。</li>
<li>回调通知结果。</li>
<li>多线程提高并发效率。</li>
</ul>
<p>无非也就是这些，只是做了这些之后就会带来其他问题：</p>
<ul>
<li>异步之后事务如何保证？</li>
<li>回调失败的情况？</li>
<li>多线程所带来的上下文切换、共享资源的问题。</li>
</ul>
<p>这就是一个博弈的过程，想要做到一个尽量高效的应用是需要不断磨合试错的。</p>
<p>上文相关的代码：</p>
<p><a href="https://github.com/crossoverJie/netty-action">https://github.com/crossoverJie/netty-action</a></p>
<p><strong>欢迎关注公众号一起交流：</strong></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty(三) 什么是 TCP 拆、粘包？如何解决？</title>
    <url>/2018/08/03/netty/Netty(3)TCP-Sticky/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d26cc6ea5.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记得前段时间我们生产上的一个网关出现了故障。</p>
<p>这个网关逻辑非常简单，就是接收客户端的请求然后解析报文最后发送短信。</p>
<p>但这个请求并不是常见的 HTTP ，而是利用 Netty 自定义的协议。</p>
<blockquote>
<p>有个前提是：网关是需要读取一段完整的报文才能进行后面的逻辑。</p>
</blockquote>
<p>问题是有天突然发现网关解析报文出错，查看了客户端的发送日志也没发现问题，最后通过日志发现收到了许多<strong>不完整的报文</strong>，有些还多了。</p>
<p>于是想会不会是 TCP 拆、粘包带来的问题，最后利用 Netty 自带的拆包工具解决了该问题。</p>
<p>这便有了此文。</p>
<span id="more"></span>

<h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>问题虽然解决了，但还是得想想原因，为啥会这样？打破砂锅问到底才是一个靠谱的程序员。</p>
<p>这就得从 TCP 这个协议说起了。</p>
<p>TCP 是一个面向字节流的协议，它是性质是流式的，所以它并没有分段。就像水流一样，你没法知道什么时候开始，什么时候结束。</p>
<p>所以他会根据当前的套接字缓冲区的情况进行拆包或是粘包。</p>
<p>下图展示了一个 TCP 协议传输的过程：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d26dcc48d.jpg"></p>
<p>发送端的字节流都会先传入缓冲区，再通过网络传入到接收端的缓冲区中，最终由接收端获取。</p>
<p>当我们发送两个完整包到接收端的时候：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d26e3e083.jpg"></p>
<p>正常情况会接收到两个完整的报文。</p>
<hr>
<p>但也有以下的情况：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d26ea061e.jpg"></p>
<p>接收到的是一个报文，它是由发送的两个报文组成的，这样对于应用程序来说就很难处理了（这样称为粘包）。</p>
<hr>
<p><img src="https://i.loli.net/2019/05/08/5cd1d26f1dcce.jpg"></p>
<p>还有可能出现上面这样的虽然收到了两个包，但是里面的内容却是互相包含，对于应用来说依然无法解析（拆包）。</p>
<p>对于这样的问题只能通过上层的应用来解决，常见的方式有：</p>
<ul>
<li>在报文末尾增加换行符表明一条完整的消息，这样在接收端可以根据这个换行符来判断消息是否完整。</li>
<li>将消息分为消息头、消息体。可以在消息头中声明消息的长度，根据这个长度来获取报文（比如 808 协议）。</li>
<li>规定好报文长度，不足的空位补齐，取的时候按照长度截取即可。</li>
</ul>
<p>以上的这些方式我们在 Netty 的 pipline 中里加入对应的解码器都可以手动实现。</p>
<p>但其实 Netty 已经帮我们做好了，完全可以开箱即用。</p>
<p>比如：</p>
<ul>
<li><code>LineBasedFrameDecoder</code> 可以基于换行符解决。</li>
<li><code>DelimiterBasedFrameDecoder </code>可基于分隔符解决。</li>
<li><code>FixedLengthFrameDecoder </code>可指定长度解决。</li>
</ul>
<h2 id="字符串拆、粘包"><a href="#字符串拆、粘包" class="headerlink" title="字符串拆、粘包"></a>字符串拆、粘包</h2><p>下面来模拟一下最简单的字符串传输。</p>
<p>还是在之前的</p>
<p><a href="https://github.com/crossoverJie/netty-action">https://github.com/crossoverJie/netty-action</a></p>
<p>进行演示。</p>
<p>在 Netty 客户端中加了一个入口可以循环发送 100 条字符串报文到接收端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向服务端发消息 字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stringReqVO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;客户端发送消息，字符串&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;sendStringMsg&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;NULLBody&gt; <span class="title function_">sendStringMsg</span><span class="params">(<span class="meta">@RequestBody</span> StringReqVO stringReqVO)</span>&#123;</span><br><span class="line">    BaseResponse&lt;NULLBody&gt; res = <span class="keyword">new</span> <span class="title class_">BaseResponse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        heartbeatClient.sendStringMsg(stringReqVO.getMsg()) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用 actuator 来自增</span></span><br><span class="line">    counterService.increment(Constants.COUNTER_CLIENT_PUSH_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="type">SendMsgResVO</span> <span class="variable">sendMsgResVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendMsgResVO</span>() ;</span><br><span class="line">    sendMsgResVO.setMsg(<span class="string">&quot;OK&quot;</span>) ;</span><br><span class="line">    res.setCode(StatusEnum.SUCCESS.getCode()) ;</span><br><span class="line">    res.setMessage(StatusEnum.SUCCESS.getMessage()) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送消息字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendStringMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">message</span> <span class="operator">=</span> Unpooled.buffer(msg.getBytes().length) ;</span><br><span class="line">    message.writeBytes(msg.getBytes()) ;</span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> channel.writeAndFlush(message);</span><br><span class="line">    future.addListener((ChannelFutureListener) channelFuture -&gt;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;客户端手动发消息成功=&#123;&#125;&quot;</span>, msg));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端直接打印即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;收到msg=&#123;&#125;&quot;</span>, msg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便提一下，这里加的有一个字符串的解码器：<code>.addLast(new StringDecoder())</code> 其实就是把消息解析为字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    out.add(msg.toString(charset));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在 Swagger 中调用了客户端的接口用于给服务端发送了 100 次消息：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2700caaf.jpg"></p>
<p>正常情况下接收端应该打印 100 次 <code>hello</code> 才对，但是查看日志会发现：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d276b04f8.jpg"></p>
<p>收到的内容有完整的、多的、少的、拼接的；这也就对应了上面提到的拆包、粘包。</p>
<p>该怎么解决呢？这便可采用之前提到的 <code>LineBasedFrameDecoder</code> 利用换行符解决。</p>
<h3 id="利用-LineBasedFrameDecoder-解决问题"><a href="#利用-LineBasedFrameDecoder-解决问题" class="headerlink" title="利用 LineBasedFrameDecoder 解决问题"></a>利用 LineBasedFrameDecoder 解决问题</h3><p><code>LineBasedFrameDecoder</code> 解码器使用非常简单，只需要在 pipline 链条上添加即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串解析,换行防拆包</span></span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>))</span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())</span><br></pre></td></tr></table></figure>

<p>构造函数中传入了 1024 是指报的长度最大不超过这个值，具体可以看下文的源码分析。</p>
<p>然后我们再进行一次测试看看结果：</p>
<blockquote>
<p>注意，由于 LineBasedFrameDecoder 解码器是通过换行符来判断的，所以在发送时，一条完整的消息需要加上 <code>\n</code>。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/08/5cd1d278852a8.jpg"></p>
<p>最终的结果：<br><img src="https://i.loli.net/2019/05/08/5cd1d27c66730.jpg"></p>
<p>仔细观察日志，发现确实没有一条被拆、粘包。</p>
<h3 id="LineBasedFrameDecoder-的原理"><a href="#LineBasedFrameDecoder-的原理" class="headerlink" title="LineBasedFrameDecoder 的原理"></a>LineBasedFrameDecoder 的原理</h3><p>目的达到了，来看看它的实现原理：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2807657f.jpg"></p>
<ol>
<li>第一步主要就是 <code>findEndOfLine</code> 方法去找到当前报文中是否存在分隔符，存在就会返回分隔符所在的位置。</li>
<li>判断是否需要丢弃，默认为 false ，第一次走这个逻辑（下文会判断是否需要改为 true）。</li>
<li>如果报文中存在换行符，就会将数据截取到那个位置。</li>
<li>如果不存在换行符（有可能是拆包、粘包），就看当前报文的长度是否大于预设的长度。大于则需要缓存这个报文长度，并将 discarding 设为 true。</li>
<li>如果是需要丢弃时，判断是否找到了换行符，存在则需要丢弃掉之前记录的长度然后截取数据。</li>
<li>如果没有找到换行符，则将之前缓存的报文长度进行累加，用于下次抛弃。</li>
</ol>
<p>从这个逻辑中可以看出就是寻找报文中是否包含换行符，并进行相应的截取。</p>
<p>由于是通过缓冲区读取的，所以即使这次没有换行符的数据，只要下一次的报文存在换行符，上一轮的数据也不会丢。</p>
<h2 id="高效的编码方式-Google-Protocol"><a href="#高效的编码方式-Google-Protocol" class="headerlink" title="高效的编码方式 Google Protocol"></a>高效的编码方式 Google Protocol</h2><p>上面提到的其实就是在解码中进行操作，我们也可以自定义自己的拆、粘包工具。</p>
<p>编解码的主要目的就是为了可以编码成字节流用于在网络中传输、持久化存储。</p>
<p>Java 中也可以实现 Serializable 接口来实现序列化，但由于它性能等原因在一些 RPC 调用中用的很少。</p>
<p>而 <code>Google Protocol</code> 则是一个高效的序列化框架，下面来演示在 Netty 中如何使用。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先第一步自然是安装：</p>
<p>在<a href="https://github.com/google/protobuf/releases/tag/v3.6.1">官网</a>下载对应的包。</p>
<p>本地配置环境变量：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d281120d5.jpg"></p>
<p>当执行 <code>protoc --version</code> 出现以下结果表明安装成功：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2820a66f.jpg"></p>
<h3 id="定义自己的协议格式"><a href="#定义自己的协议格式" class="headerlink" title="定义自己的协议格式"></a>定义自己的协议格式</h3><p>接着是需要按照官方要求的语法定义自己的协议格式。</p>
<p>比如我这里需要定义一个输入输出的报文格式：</p>
<p>BaseRequestProto.proto:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> protocol;</span><br><span class="line"></span><br><span class="line"><span class="type">option</span> <span class="variable">java_package</span> <span class="operator">=</span> <span class="string">&quot;com.crossoverjie.netty.action.protocol&quot;</span>;</span><br><span class="line"><span class="type">option</span> <span class="variable">java_outer_classname</span> <span class="operator">=</span> <span class="string">&quot;BaseRequestProto&quot;</span>;</span><br><span class="line"></span><br><span class="line">message RequestProtocol &#123;</span><br><span class="line">  required <span class="type">int32</span> <span class="variable">requestId</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">  required <span class="type">string</span> <span class="variable">reqMsg</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BaseResponseProto.proto:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> protocol;</span><br><span class="line"></span><br><span class="line"><span class="type">option</span> <span class="variable">java_package</span> <span class="operator">=</span> <span class="string">&quot;com.crossoverjie.netty.action.protocol&quot;</span>;</span><br><span class="line"><span class="type">option</span> <span class="variable">java_outer_classname</span> <span class="operator">=</span> <span class="string">&quot;BaseResponseProto&quot;</span>;</span><br><span class="line"></span><br><span class="line">message ResponseProtocol &#123;</span><br><span class="line">  required <span class="type">int32</span> <span class="variable">responseId</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">  required <span class="type">string</span> <span class="variable">resMsg</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再通过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">protoc --java_out=/dev BaseRequestProto.proto BaseResponseProto.proto</span><br></pre></td></tr></table></figure>

<p>protoc 命令将刚才定义的协议格式转换为 Java 代码，并生成在 <code>/dev</code> 目录。</p>
<p>只需要将生成的代码拷贝到我们的项目中，同时引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>利用 Protocol 的编解码也非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtocolUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvalidProtocolBufferException &#123;</span><br><span class="line">        BaseRequestProto.<span class="type">RequestProtocol</span> <span class="variable">protocol</span> <span class="operator">=</span> BaseRequestProto.RequestProtocol.newBuilder()</span><br><span class="line">                .setRequestId(<span class="number">123</span>)</span><br><span class="line">                .setReqMsg(<span class="string">&quot;你好啊&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] encode = encode(protocol);</span><br><span class="line"></span><br><span class="line">        BaseRequestProto.<span class="type">RequestProtocol</span> <span class="variable">parseFrom</span> <span class="operator">=</span> decode(encode);</span><br><span class="line"></span><br><span class="line">        System.out.println(protocol.toString());</span><br><span class="line">        System.out.println(protocol.toString().equals(parseFrom.toString()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> protocol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encode(BaseRequestProto.RequestProtocol protocol)&#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.toByteArray() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InvalidProtocolBufferException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BaseRequestProto.RequestProtocol <span class="title function_">decode</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> InvalidProtocolBufferException &#123;</span><br><span class="line">        <span class="keyword">return</span> BaseRequestProto.RequestProtocol.parseFrom(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用 <code>BaseRequestProto</code> 来做一个演示，先编码再解码最后比较最终的结果是否相同。答案肯定是一致的。</p>
<p>利用 protoc 命令生成的 Java 文件里已经帮我们把编解码全部都封装好了，只需要简单调用就行了。</p>
<p>可以看出 Protocol 创建对象使用的是构建者模式，对使用者来说清晰易读，更多关于构建器的内容可以参考<a href="https://crossoverjie.top/2018/04/28/sbc/sbc7-Distributed-Limit/#Builder-%E6%9E%84%E5%BB%BA%E5%99%A8">这里</a>。</p>
<p>更多关于 <code>Google Protocol</code> 内容请查看<a href="https://developers.google.com/protocol-buffers/docs/javatutorial">官方开发文档</a>。</p>
<h3 id="结合-Netty"><a href="#结合-Netty" class="headerlink" title="结合 Netty"></a>结合 Netty</h3><p>Netty 已经自带了对 Google protobuf 的编解码器，也是只需要在 pipline 中添加即可。</p>
<p>server 端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// google Protobuf 编解码</span></span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">ProtobufDecoder</span>(BaseRequestProto.RequestProtocol.getDefaultInstance()))</span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">ProtobufEncoder</span>())</span><br></pre></td></tr></table></figure>



<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// google Protobuf 编解码</span></span><br><span class="line"></span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">ProtobufDecoder</span>(BaseResponseProto.ResponseProtocol.getDefaultInstance()))</span><br><span class="line"></span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">ProtobufEncoder</span>())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>稍微注意的是，在构建 ProtobufDecoder 时需要显式指定解码器需要解码成什么类型。</p>
</blockquote>
<p>我这里服务端接收的是 BaseRequestProto，客户端收到的是服务端响应的 BaseResponseProto 所以就设置了对应的实例。</p>
<p>同样的提供了一个接口向服务端发送消息，当服务端收到了一个特殊指令时也会向客户端返回内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, BaseRequestProto.RequestProtocol msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;收到msg=&#123;&#125;&quot;</span>, msg.getReqMsg());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">999</span> == msg.getRequestId())&#123;</span><br><span class="line">        BaseResponseProto.<span class="type">ResponseProtocol</span> <span class="variable">responseProtocol</span> <span class="operator">=</span> BaseResponseProto.ResponseProtocol.newBuilder()</span><br><span class="line">                .setResponseId(<span class="number">1000</span>)</span><br><span class="line">                .setResMsg(<span class="string">&quot;服务端响应&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        ctx.writeAndFlush(responseProtocol) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 swagger 中调用相关接口：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d28328230.jpg"></p>
<p>在日志可以看到服务端收到了消息，同时客户端也收到了返回：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2840564c.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d284ab76f.jpg"></p>
<p>虽说 Netty 封装了 Google Protobuf 相关的编解码工具，其实查看它的编码工具就会发现也是利用上文提到的 api 实现的。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d287b83cd.jpg"></p>
<h3 id="Protocol-拆、粘包"><a href="#Protocol-拆、粘包" class="headerlink" title="Protocol 拆、粘包"></a>Protocol 拆、粘包</h3><p>Google Protocol 的使用确实非常简单，但还是有值的注意的地方，比如它依然会有拆、粘包问题。</p>
<p>不妨模拟一下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d28e427ab.jpg"></p>
<p>连续发送 100 次消息看服务端收到的怎么样：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d29a34961.jpg"></p>
<p>会发现服务端在解码的时候报错，其实就是被拆、粘包了。</p>
<p>这点 Netty 自然也考虑到了，所以已经提供了相关的工具。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拆包解码</span></span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">ProtobufVarint32FrameDecoder</span>())</span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">ProtobufVarint32LengthFieldPrepender</span>())</span><br></pre></td></tr></table></figure>

<p>只需要在服务端和客户端加上这两个编解码工具即可，再来发送一百次试试。</p>
<p>查看日志发现没有出现一次异常，100 条信息全部都接收到了。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2a1158f4.jpg"></p>
<p>这个编解码工具可以简单理解为是在消息体中加了一个 32 位长度的整形字段，用于表明当前消息长度。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>网络这块同样是计算机的基础，由于近期在做相关的工作所以接触的比较多，也算是给大学补课了。</p>
<p>后面会接着更新 Netty 相关的内容，最后会产出一个高性能的 HTTP 以及 RPC 框架，敬请期待。</p>
<p>上文相关的代码：</p>
<p><a href="https://github.com/crossoverJie/netty-action">https://github.com/crossoverJie/netty-action</a></p>
<h2 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h2><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
<p><strong>欢迎关注公众号一起交流：</strong></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>拆包</tag>
        <tag>粘包</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>为自己搭建一个分布式 IM(即时通讯) 系统</title>
    <url>/2019/01/02/netty/cim01-started/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d44c450a3.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家新年快乐！</p>
<p>新的一年第一篇技术文章希望开个好头，所以元旦三天我也没怎么闲着，希望给大家带来一篇比较感兴趣的干货内容。</p>
<p>老读者应该还记得我在去年国庆节前分享过一篇<a href="https://crossoverjie.top/2018/09/25/netty/million-sms-push/">《设计一个百万级的消息推送系统》</a>；虽然我在文中有贴一些伪代码，依然有些朋友希望能直接分享一些可以运行的源码；这么久了是时候把坑填上了。</p>
<blockquote>
<p>本文较长，高能预警；带好瓜子板凳。</p>
</blockquote>
<span id="more"></span>

<p><img src="https://i.loli.net/2019/05/08/5cd1d44f7d731.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d450bc89e.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d452461aa.jpg"></p>
<p>于是在之前的基础上我完善了一些内容，先来看看这个项目的介绍吧：</p>
<p><code>CIM(CROSS-IM)</code> 一款面向开发者的 <code>IM(即时通讯)</code>系统；同时提供了一些组件帮助开发者构建一款属于自己可水平扩展的 <code>IM</code> 。</p>
<p>借助 <code>CIM</code> 你可以实现以下需求：</p>
<ul>
<li><code>IM</code> 即时通讯系统。</li>
<li>适用于 <code>APP</code> 的消息推送中间件。</li>
<li><code>IOT</code> 海量连接场景中的消息透传中间件。</li>
</ul>
<p>完整源码托管在 GitHub : <a href="https://github.com/crossoverJie/cim">https://github.com/crossoverJie/cim</a></p>
<h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>本次主要涉及到 IM 即时通讯，所以特地录了两段视频演示（群聊、私聊）。</p>
<blockquote>
<p>点击下方链接可以查看视频版 Demo。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">YouTube</th>
<th align="center">Bilibili</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://youtu.be/_9a4lIkQ5_o">群聊</a> <a href="https://youtu.be/kfEfQFPLBTQ">私聊</a></td>
<td align="center"><a href="https://www.bilibili.com/video/av39405501">群聊</a> <a href="https://www.bilibili.com/video/av39405821">私聊</a></td>
</tr>
<tr>
<td align="center"><img src="https://i.loli.net//2019//05//08//5cd1d9e788004.jpg"  height="295px" /></td>
<td align="center"><img src="https://i.loli.net//2019//05//08//5cd1da2f943c5.jpg" height="295px" /></td>
</tr>
</tbody></table>
<p>也在公网部署了一套演示环境，想要试一试的可以联系我加入内测群获取账号一起尬聊😋。</p>
<h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><p>下面来看看具体的架构设计。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d45a156f1.jpg"></p>
<ul>
<li><code>CIM</code> 中的各个组件均采用 <code>SpringBoot</code> 构建。</li>
<li>采用 <code>Netty + Google Protocol Buffer</code> 构建底层通信。</li>
<li><code>Redis</code> 存放各个客户端的路由信息、账号信息、在线状态等。</li>
<li><code>Zookeeper</code> 用于 <code>IM-server</code> 服务的注册与发现。</li>
</ul>
<p>整体主要由以下模块组成：</p>
<h2 id="cim-server"><a href="#cim-server" class="headerlink" title="cim-server"></a>cim-server</h2><p><code>IM</code> 服务端；用于接收 <code>client</code> 连接、消息透传、消息推送等功能。</p>
<p><strong>支持集群部署。</strong></p>
<h2 id="cim-forward-route"><a href="#cim-forward-route" class="headerlink" title="cim-forward-route"></a>cim-forward-route</h2><p>消息路由服务器；用于处理消息路由、消息转发、用户登录、用户下线以及一些运营工具（获取在线用户数等）。</p>
<h2 id="cim-client"><a href="#cim-client" class="headerlink" title="cim-client"></a>cim-client</h2><p><code>IM</code> 客户端；给用户使用的消息终端，一个命令即可启动并向其他人发起通讯（群聊、私聊）；同时内置了一些常用命令方便使用。</p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>整体的流程也比较简单，流程图如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d45b982b3.jpg"></p>
<ul>
<li>客户端向 <code>route</code> 发起登录。</li>
<li>登录成功从 <code>Zookeeper</code> 中选择可用 <code>IM-server</code> 返回给客户端，并保存登录、路由信息到 <code>Redis</code>。</li>
<li>客户端向 <code>IM-server</code> 发起长连接，成功后保持心跳。</li>
<li>客户端下线时通过 <code>route</code> 清除状态信息。</li>
</ul>
<p>所以当我们自己部署时需要以下步骤：</p>
<ul>
<li>搭建基础中间件 <code>Redis、Zookeeper</code>。</li>
<li>部署 <code>cim-server</code>，这是真正的 IM 服务器，为了满足性能需求所以支持水平扩展，只需要注册到同一个 <code>Zookeeper</code> 即可。</li>
<li>部署 <code>cim-forward-route</code>，这是路由服务器，所有的消息都需要经过它。由于它是无状态的，所以也可以利用 <code>Nginx</code> 代理提高可用性。</li>
<li><code>cim-client</code> 真正面向用户的客户端；启动之后会自动连接 IM 服务器便可以在控制台收发消息了。</li>
</ul>
<p>更多使用介绍可以参考<a href="https://github.com/crossoverJie/cim#%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8">快速启动</a>。</p>
<h1 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h1><p>接下来重点看看具体的实现，比如群聊、私聊消息如何流转；IM 服务端负载均衡；服务如何注册发现等等。</p>
<h2 id="IM-服务端"><a href="#IM-服务端" class="headerlink" title="IM 服务端"></a>IM 服务端</h2><p>先来看看服务端；主要是实现客户端上下线、消息下发等功能。</p>
<p>首先是服务启动：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d45e52ec0.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d46019aa9.jpg"></p>
<p>由于是在 <code>SpringBoot</code> 中搭建的，所以在应用启动时需要启动 <code>Netty</code> 服务。</p>
<p>从 <code>pipline</code> 中可以看出使用了 <code>Protobuf</code> 的编解码（具体报文在客户端中分析）。</p>
<h2 id="注册发现"><a href="#注册发现" class="headerlink" title="注册发现"></a>注册发现</h2><p>需要满足 <code>IM</code> 服务端的水平扩展需求，所以 <code>cim-server</code> 是需要将自身数据发布到注册中心的。</p>
<p>这里参考之前分享的<a href="https://crossoverjie.top/2018/08/27/distributed/distributed-discovery-zk/">《搞定服务注册与发现》</a>有具体介绍。</p>
<p>所以在应用启动成功后需要将自身数据注册到 <code>Zookeeper</code> 中。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d462666f6.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d463e6401.jpg"></p>
<p>最主要的目的就是将当前应用的 <code>ip + cim-server-port+ http-port</code> 注册上去。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d46549848.jpg"></p>
<p>上图是我在演示环境中注册的两个 <code>cim-server</code> 实例（由于在一台服务器，所以只是端口不同）。</p>
<p>这样在客户端（监听这个 <code>Zookeeper</code> 节点）就能实时的知道目前可用的服务信息。</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>当客户端请求 <code>cim-forward-route</code> 中的登录接口（详见下文）做完业务验证（就相当于日常登录其他网站一样）之后，客户端会向服务端发起一个长连接，如之前的流程所示：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4690d364.jpg"></p>
<p>这时客户端会发送一个特殊报文，表明当前是登录信息。</p>
<p>服务端收到后就需要将该客户端的 <code>userID</code> 和当前 <code>Channel</code> 通道关系保存起来。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d46b2f41e.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d46e99d71.jpg"></p>
<p>同时也缓存了用户的信息，也就是 <code>userID</code> 和 用户名。</p>
<h2 id="离线"><a href="#离线" class="headerlink" title="离线"></a>离线</h2><p>当客户端断线后也需要将刚才缓存的信息清除掉。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d476665ff.jpg"></p>
<p>同时也需要调用 <code>route</code> 接口清除相关信息（具体接口看下文）。</p>
<h2 id="IM-路由"><a href="#IM-路由" class="headerlink" title="IM 路由"></a>IM 路由</h2><p><img src="https://i.loli.net/2019/05/08/5cd1d479a88a4.jpg"></p>
<p>从架构图中可以看出，路由层是非常重要的一环；它提供了一系列的 <code>HTTP</code> 服务承接了客户端和服务端。</p>
<p>目前主要是以下几个接口。</p>
<h3 id="注册接口"><a href="#注册接口" class="headerlink" title="注册接口"></a>注册接口</h3><p><img src="https://i.loli.net/2019/05/08/5cd1d47d84f95.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d47f8d14e.jpg"></p>
<p>由于每一个客户端都是需要登录才能使用的，所以第一步自然是注册。</p>
<p>这里就设计的比较简单，直接利用 <code>Redis</code> 来存储用户信息；用户信息也只有 <code>ID</code> 和 <code>userName</code> 而已。</p>
<p>只是为了方便查询在 <code>Redis</code> 中的 <code>KV</code> 又反过来存储了一份 <code>VK</code>，这样 <code>ID</code> 和 <code>userName</code> 都必须唯一。</p>
<h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>这里的登录和 <code>cim-server</code> 中的登录不一样，具有业务性质，</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d482bed42.jpg"></p>
<ul>
<li>登录成功之后需要判断是否是重复登录（一个用户只能运行一个客户端）。</li>
<li>登录成功后需要从 <code>Zookeeper</code> 中获取服务列表（<code>cim-server</code>）并根据某种算法选择一台服务返回给客户端。</li>
<li>登录成功之后还需要保存路由信息，也就是当前用户分配的服务实例保存到 <code>Redis</code> 中。</li>
</ul>
<p>为了实现只能一个用户登录，使用了 <code>Redis</code> 中的 <code>set</code> 来保存登录信息；利用 <code>userID</code> 作为 <code>key</code> ，重复的登录就会写入失败。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d48746c86.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d491ca18f.jpg"></p>
<blockquote>
<p>类似于 Java 中的 HashSet，只能去重保存。</p>
</blockquote>
<p>获取一台可用的路由实例也比较简单：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d494cd7b8.jpg"></p>
<ul>
<li>先从 <code>Zookeeper</code> 获取所有的服务实例做一个内部缓存。</li>
<li>轮询选择一台服务器（目前只有这一种算法，后续会新增）。</li>
</ul>
<p>当然要获取 <code>Zookeeper</code> 中的服务实例前自然是需要监听 <code>cim-server</code> 之前注册上去的那个节点。</p>
<p>具体代码如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4965f2d4.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d497d0c5e.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d49a7324f.jpg"></p>
<p>也是在应用启动之后监听 <code>Zookeeper</code> 中的路由节点，一旦发生变化就会更新内部缓存。</p>
<blockquote>
<p>这里使用的是 Guava 的 cache，它基于 <code>ConcurrentHashMap</code>，所以可以保证<code>清除、新增缓存</code>的原子性。</p>
</blockquote>
<h3 id="群聊接口"><a href="#群聊接口" class="headerlink" title="群聊接口"></a>群聊接口</h3><p>这是一个真正发消息的接口，实现的效果就是其中一个客户端发消息，其余所有客户端都能收到！</p>
<p>流程肯定是客户端发送一条消息到服务端，服务端收到后在上文介绍的 <code>SessionSocketHolder</code> 中遍历所有 <code>Channel</code>（通道）然后下发消息即可。</p>
<p>服务端是单机倒也可以，但现在是集群设计。所以所有的客户端会根据之前的轮询算法分配到不同的 <code>cim-server</code> 实例中。</p>
<p>因此就需要路由层来发挥作用了。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d49d80933.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d4a6cb618.jpg"></p>
<p>路由接口收到消息后首先遍历出所有的客户端和服务实例的关系。</p>
<p>路由关系在 <code>Redis</code> 中的存放如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4a96d129.jpg"></p>
<p>由于 <code>Redis</code> 单线程的特质，当数据量大时；一旦使用 keys 匹配所有 <code>cim-route:*</code> 数据，会导致 Redis 不能处理其他请求。</p>
<p>所以这里改为使用 scan 命令来遍历所有的 <code>cim-route:*</code>。</p>
<hr>
<p>接着会挨个调用每个客户端所在的服务端的 <code>HTTP</code> 接口用于推送消息。</p>
<p>在 <code>cim-server</code> 中的实现如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4adabe52.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d4b0e45a5.jpg"></p>
<p><code>cim-server</code> 收到消息后会在内部缓存中查询该 userID 的通道，接着只需要发消息即可。</p>
<h3 id="在线用户接口"><a href="#在线用户接口" class="headerlink" title="在线用户接口"></a>在线用户接口</h3><p>这是一个辅助接口，可以查询出当前在线用户信息。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4b261364.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d4b3cb598.jpg"></p>
<p>实现也很简单，也就是查询之前保存 ”用户登录状态的那个去重 <code>set</code> “即可。</p>
<h3 id="私聊接口"><a href="#私聊接口" class="headerlink" title="私聊接口"></a>私聊接口</h3><p>之所以说获取在线用户是一个辅助接口，其实就是用于辅助私聊使用的。</p>
<p>一般我们使用私聊的前提肯定得知道当前哪些用户在线，接着你才会知道你要和谁进行私聊。</p>
<p>类似于这样：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4f69c577.jpg"></p>
<p>在我们这个场景中，私聊的前提就是需要获得在线用户的 <code>userID</code>。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4c2d3e73.jpg"></p>
<p>所以私聊接口在收到消息后需要查询到接收者所在的 <code>cim-server</code> 实例信息，后续的步骤就和群聊一致了。调用接收者所在实例的 <code>HTTP</code> 接口下发信息。</p>
<p>只是群聊是遍历所有的在线用户，私聊只发送一个的区别。</p>
<h3 id="下线接口"><a href="#下线接口" class="headerlink" title="下线接口"></a>下线接口</h3><p>一旦客户端下线，我们就需要将之前存放在 <code>Redis</code> 中的一些信息删除掉（路由信息、登录状态）。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4c5cf651.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d4c71c667.jpg"></p>
<h2 id="IM-客户端"><a href="#IM-客户端" class="headerlink" title="IM 客户端"></a>IM 客户端</h2><p>客户端中的一些逻辑其实在上文已经谈到一些了。</p>
<h3 id="登录-1"><a href="#登录-1" class="headerlink" title="登录"></a>登录</h3><p>第一步也就是登录，需要在启动时调用 <code>route</code> 的登录接口，获得 <code>cim-server</code> 信息再创建连接。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4c84d0e2.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4d0bfa7c.jpg" alt="image-20190102001525565"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4d476d56.jpg"></p>
<p>登录过程中 <code>route</code> 接口会判断是否为重复登录，重复登录则会直接退出程序。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4d76b21b.jpg"></p>
<p>接下来是利用 <code>route</code> 接口返回的 <code>cim-server</code> 实例信息（<code>ip+port</code>）创建连接。</p>
<p>最后一步就是发送一个登录标志的信息到服务端，让它保持客户端和 <code>Channel</code> 的关系。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4da37851.jpg"></p>
<h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><p>上文提到的一些<code>登录报文、真正的消息报文</code>这些其实都是在我们自定义协议中可以区别出来的。</p>
<p>由于是使用 <code>Google Protocol Buffer</code> 编解码，所以先看看原始格式。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4dbdbe1b.jpg"></p>
<p>其实这个协议中目前一共就三个字段：</p>
<ul>
<li><code>requestId</code> 可以理解为 <code>userId</code>。</li>
<li><code>reqMsg</code> 就是真正的消息。</li>
<li><code>type</code> 也就是上文提到的消息类别。</li>
</ul>
<p>目前主要是三种类型，分别对应不同的业务：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4e11fc29.jpg"></p>
<h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><p>为了保持客户端和服务端的连接，每隔一段时间没有发送消息都需要自动的发送心跳。</p>
<p>目前的策略是每隔一分钟就是发送一个心跳包到服务端：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4e3939e7.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d4e548d0d.jpg"></p>
<p>这样服务端每隔一分钟没有收到业务消息时就会收到 <code>ping</code> 的心跳包：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4e98f743.jpg"></p>
<h3 id="内置命令"><a href="#内置命令" class="headerlink" title="内置命令"></a>内置命令</h3><p>客户端也内置了一些基本命令来方便使用。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>:q</code></td>
<td>退出客户端</td>
</tr>
<tr>
<td><code>:olu</code></td>
<td>获取所有在线用户信息</td>
</tr>
<tr>
<td><code>:all</code></td>
<td>获取所有命令</td>
</tr>
<tr>
<td><code>:</code></td>
<td>更多命令正在开发中。。</td>
</tr>
</tbody></table>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4f69c577.jpg"></p>
<p>比如输入 <code>:q</code> 就会退出客户端，同时会关闭一些系统资源。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4f937820.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d4fc115ec.jpg"></p>
<p>当输入 <code>:olu</code>(<code>onlineUser</code> 的简写)就会去调用 <code>route</code> 的获取所有在线用户接口。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d4feb1f12.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d500549c1.jpg"></p>
<h3 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h3><p>群聊的使用非常简单，只需要在控制台输入消息回车即可。</p>
<p>这时会去调用 <code>route</code> 的群聊接口。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d503006a2.jpg"></p>
<h3 id="私聊"><a href="#私聊" class="headerlink" title="私聊"></a>私聊</h3><p>私聊也是同理，但前提是需要触发关键字；使用 <code>userId;;消息内容</code> 这样的格式才会给某个用户发送消息，所以一般都需要先使用 <code>:olu</code> 命令获取所以在线用户才方便使用。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d505b390e.jpg"></p>
<h3 id="消息回调"><a href="#消息回调" class="headerlink" title="消息回调"></a>消息回调</h3><p>为了满足一些定制需求，比如消息需要保存之类的。</p>
<p>所以在客户端收到消息之后会回调一个接口，在这个接口中可以自定义实现。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d50760f85.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1d50e16d1c.jpg"></p>
<p>因此先创建了一个 <code>caller</code> 的 <code>bean</code>，这个 <code>bean</code> 中包含了一个 <code>CustomMsgHandleListener</code> 接口，需要自行处理只需要实现此接口即可。</p>
<h3 id="自定义界面"><a href="#自定义界面" class="headerlink" title="自定义界面"></a>自定义界面</h3><p>由于我自己不怎么会写界面，但保不准有其他大牛会写。所以客户端中的群聊、私聊、获取在线用户、消息回调等业务(以及之后的业务)都是以接口形式提供。</p>
<p>也方便后面做页面集成，只需要调这些接口就行了；具体实现不用怎么关心。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>cim</code> 目前只是第一版，BUG 多，功能少（只拉了几个群友做了测试）；不过后续还会接着完善，至少这一版会给那些没有相关经验的朋友带来一些思路。</p>
<p>后续计划：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d51115075.jpg"></p>
<p>完整源码：</p>
<p><a href="https://github.com/crossoverJie/cim">https://github.com/crossoverJie/cim</a></p>
<p>如果这篇对你有所帮助还请不吝转发。</p>
]]></content>
      <categories>
        <category>Netty</category>
        <category>cim</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Zookeeper</tag>
        <tag>推送</tag>
        <tag>IM</tag>
        <tag>IOT</tag>
      </tags>
  </entry>
  <entry>
    <title>为自己搭建一个分布式 IM 系统二【从查找算法聊起】</title>
    <url>/2019/01/14/netty/cim02-v1.0.1/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1c30496c13.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>最近这段时间确实有点忙，这篇的目录还是在飞机上敲出来了的。</p>
</blockquote>
<p>言归正传，上周更新了 <a href="https://github.com/crossoverJie/cim">cim</a> 第一版：<a href="https://crossoverjie.top/2019/01/02/netty/cim01-started/">为自己搭建一个分布式 IM(即时通讯) 系统</a>；没想到反响热烈，最高时上了 <code>GitHub Trending  Java</code> 版块的首位，一天收到了 300+ 的 star。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c30806550.jpg"></p>
<span id="more"></span>

<p>现在总共也有 1.3K+ 的 star，有几十个朋友参加了测试，非常感谢大家的支持。</p>
<p>在这过程中也收到一些 <code>bug</code> 反馈，<code>feature</code> 建议；因此这段时间我把一些影响较大的 bug 以及需求比较迫切的 <code>feature</code> 调整了，本次更新的 <code>v1.0.1</code> 版本：</p>
<ul>
<li>客户端超时自动下线。</li>
<li>新增 <code>AI</code> 模式。</li>
<li>聊天记录查询。</li>
<li>在线用户前缀模糊匹配。</li>
</ul>
<p>下面谈下几个比较重点的功能。</p>
<p><code>客户端超时自动下线</code> 这个功能涉及到客户端和服务端的心跳设计，比较有意思，也踩了几个坑；所以准备留到下次单独来聊。</p>
<h1 id="AI-模式"><a href="#AI-模式" class="headerlink" title="AI 模式"></a>AI 模式</h1><p>大家应该还记得这个之前刷爆朋友圈的 <code>估值两个一个亿的 AI 核心代码</code>。</p>
<p>和我这里的场景再合适不过了。</p>
<p>于是我新增了一个命令用于一键开启 AI 模式，使用情况大概如下。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c30e47d95.jpg"></p>
<p>欢迎大家更新源码体验，融资的请私聊我🤣。</p>
<h1 id="聊天记录"><a href="#聊天记录" class="headerlink" title="聊天记录"></a>聊天记录</h1><p>聊天记录也是一个比较迫切的功能。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c310cb796.jpg"></p>
<p>使用命令 <code>:q 关键字</code> 即可查询与个人相关的聊天记录。</p>
<p>这个功能其实比较简单，只需要在消息发送及接收消息时保存即可。</p>
<p>但要考虑的一点是，这个保存消息是 IO 操作，不可避免的会有耗时；需要尽量避免对消息发送、接收产生影响。</p>
<h2 id="异步写入消息"><a href="#异步写入消息" class="headerlink" title="异步写入消息"></a>异步写入消息</h2><p>因此我把消息写入的过程异步完成，可以不影响真正的业务。</p>
<p>实现起来也挺简单，就是一个典型的生产者消费者模式。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3128f910.jpg"></p>
<p>主线程收到消息之后直接写入队列，另外再有一个线程一直源源不断的从队列中取出数据后保存聊天记录。</p>
<p>大概的代码如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3143be05.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1c315b6c17.jpg"></p>
<hr>
<p>写入消息的同时会把消费消息的线程打开：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c317b8636.jpg"></p>
<p>而最终存放消息记录的策略，考虑后还是以最简单的方式存放在客户端，可以降低复杂度。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c31d716d4.jpg"></p>
<p>简单来说就是根据当前日期+用户名写入到磁盘里。</p>
<p>当客户端关闭时利用线程中断的方式停止了消费队列的线程。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c31f4438c.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1c320d9a62.jpg"></p>
<p>这点的设计其实和 <code>logback</code> 写日志的方式比较类似，感兴趣的可以去翻翻 <code>logback</code> 的源码，更加详细。</p>
<h2 id="回调接口"><a href="#回调接口" class="headerlink" title="回调接口"></a>回调接口</h2><p>至于收到其他客户端发来的消息时则是利用之前预留的消息回调接口来写入日志。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c323439df.jpg"></p>
<p>收到消息后会执行自定义的回调接口。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c32569b6e.jpg"></p>
<p>于是在这个回调方法中实现写入逻辑即可，当后续还有其他的消息处理逻辑时也能在这里直接添加。</p>
<blockquote>
<p>当处理逻辑增多时最好是改为责任链模式，更加清晰易维护。</p>
</blockquote>
<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><p>接下来是本文着重要讨论的一个查找算法，准确的说是一个前缀模糊匹配的算法。</p>
<p>实现的效果如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c32ac3397.jpg"></p>
<p>使用命令 <code>:qu prefix</code> 可以按照前缀的方式搜索用户信息。</p>
<p>当然在命令行中其实意义不大，但是在移动端中确是比较有用的。类似于微信按照用户名匹配：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c331b88d5.jpg"></p>
<blockquote>
<p>因为后期打算出一个移动端 APP，所以就先把这个功能实现了。</p>
</blockquote>
<p>从效果也看得出来：就是按照输入的前缀匹配字符串（目前只支持英文）。</p>
<p>在没有任何限制的条件下最快、最简单的实现方式可以直接把所有的字符串存放在一个容器中 （List、Set），查询时则挨个遍历；利用 <code>String.startsWith(&quot;prefix&quot;)</code> 进行匹配。</p>
<p>但这样会有几个问题：</p>
<ul>
<li>存储资源比较浪费，不管是 list 还是 Set 都会有额外的损耗。</li>
<li>查询效率较低，需要遍历集合后再遍历字符串的 <code>char</code> 数组（<code>String.startsWith</code> 的实现方式）。</li>
</ul>
<h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><p>基于以上的问题我们可以考虑下：</p>
<p>假设我需要存放 <code>java,javascript,jsp,php</code> 这些字符串时在 ArrayList 中会怎么存放？</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c333b6dad.jpg"></p>
<p>很明显，会是这样完整的存放在一个数组中；同时这个数组还可能存在浪费，没有全部使用完。</p>
<p>但其实仔细观察这些数据会发现有一些共同特点，比如 <code>java,javascript</code> 有共同的前缀 <code>java</code>;和 <code>jsp</code> 有共同的前缀 <code>j</code>。</p>
<p>那是否可以把这些前缀利用起来呢？这样就可以少存储一份。</p>
<p>比如写入 <code>java,javascript</code> 这两个字符串时存放的结构如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c33583002.jpg"></p>
<p>当再存入一个 <code>jsp</code> 时：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c33edb7ef.jpg"></p>
<p>最后再存入 <code>jsf</code> 时：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c340d4dd9.jpg"></p>
<p>相信大家应该已经看明白了，按照这样的存储方式可以节省很多内存，同时查询效率也比较高。</p>
<p>比如查询以 <code>jav</code> 开头的数据，只需要从头结点 <code>j</code> 开始往下查询，最后会查询到 <code>ava</code> 以及 <code>script</code> 这两个个结点，所以整个查询路径所经历的字符拼起来就是查询到的结果<code>java+javascript</code>。</p>
<p>如果以 <code>b</code> 开头进行查询，那第一步就会直接返回，这样比在 <code>list</code> 中的效率高很多。</p>
<p>但这个图还不完善，因为不知道查询到啥时候算是匹配到了一个之前写入的字符串。</p>
<blockquote>
<p>比如在上图中怎么知道 <code>j+ava</code> 是一个我们之前写入的 <code>java</code> 这个字符呢。</p>
</blockquote>
<p>因此我们需要对这种是一个<strong>完整字符串</strong>的数据打上一个标记：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c34277179.jpg"></p>
<p>比如这样，我们将 <code>ava、script、p、f</code> 这几个节点都换一个颜色表示。表明查询到这个字符时就算是匹配到了一个结果。</p>
<p>而查到 <code>s</code> 这个字符颜色不对，代表还需要继续往下查。</p>
<p>比如输入关键字 <code>js</code> 进行匹配时，当它的查询路径走到 <code>s</code> 这里时判断到 s 的颜色不对，所以不会把 <code>js</code> 作为一个匹配结果。而是继续往下查，发现有两个子节点 p、f 颜色都正确，于是把查询的路径 <code>jsp</code> 和 <code>jsf</code> 都作为一个匹配结果。</p>
<p>而只输入 j，则会把下面所有有色的字符拼起来作为结果集合。</p>
<blockquote>
<p>这其实就一个典型的字典树。</p>
</blockquote>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>下面则是具体的代码实现，其实算法不像是实现一个业务功能这样好用文字分析；具体还是看源码多调试就明白了。</p>
<p>谈下几个重点的地方吧：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c349dd2bb.jpg"></p>
<p>字典树的节点实现，其中的 <code>isEnd</code> 相当于图中的上色。</p>
<p>利用一个 <code>Node[] children</code> 来存放子节点。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c34d8ea29.jpg"></p>
<p>为了可以区分大小写查询，所以子节点的长度相当于是 <code>26*2</code>。</p>
<h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><p><img src="https://i.loli.net/2019/05/08/5cd1c350b56da.jpg"></p>
<p>这里以一个单测为例，写入了三个字符串，那最终形成的数据结构如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c356cb710.jpg"></p>
<p>图中有与上图有几点不同：</p>
<ul>
<li>每个节点都是一个字符，这样树的高度最高为52。</li>
<li>每个节点的子节点都是长度为 52 的数组；所以可以利用数组的下标表示他代表的字符值。比如 0 就是大 A,26 则是小 a，以此类推。</li>
<li>有点类似于之前提到的<a href="https://crossoverjie.top/2018/11/26/guava/guava-bloom-filter/">布隆过滤器</a>，可以节省内存。</li>
</ul>
<p><code>debug</code> 时也能看出符合上图的数据结构：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3646e24c.jpg"></p>
<p>所以真正的写入步骤如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3699d6da.jpg"></p>
<ol>
<li>把字符串拆分为 char 数组，并判断大小写计算它所存放在数组中的位置 <code>index</code>。</li>
<li>将当前节点的子节点数组的 index 处新增一个节点。</li>
<li>如果是最后一个字符就将新增的节点置为最后一个节点，也就是上文的改变节点颜色。</li>
<li>最后将当前节点指向下一个节点方便继续写入。</li>
</ol>
<hr>
<p><img src="https://i.loli.net/2019/05/08/5cd1c36e26b18.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1c3740223e.jpg"></p>
<p>查询总的来说要麻烦一些，其实就是对树进行深度遍历；最终的思想看图就能明白。</p>
<p>所以在 cim 中进行模糊匹配时就用到了这个结构。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c37724b46.jpg"></p>
<p>字典树的源码在此处：</p>
<p><a href="https://github.com/crossoverJie/cim/blob/master/cim-common/src/main/java/com/crossoverjie/cim/common/data/construct/TrieTree.java">https://github.com/crossoverJie/cim/blob/master/cim-common/src/main/java/com/crossoverjie/cim/common/data/construct/TrieTree.java</a></p>
<blockquote>
<p>其实利用这个结构还能实现判断某个前缀的单词是否在某堆数据里、某个前缀的单词出现的次数等。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>目前 <a href="https://github.com/crossoverJie/cim">cim</a> 还在火热内测中（虽然群里只有20几人）,感兴趣的朋友可以私聊我拉你入伙☺️ </p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3816b687.jpg"></p>
<p>再没有新的 <code>BUG</code> 产生前会着重把这些功能完成了，不出意外下周更新 <code>cim</code> 的心跳重连等机制。</p>
<p>完整源码：</p>
<p><a href="https://github.com/crossoverJie/cim">https://github.com/crossoverJie/cim</a></p>
<p>如果这篇对你有所帮助还请不吝转发。</p>
]]></content>
      <categories>
        <category>Netty</category>
        <category>cim</category>
      </categories>
      <tags>
        <tag>IM</tag>
        <tag>TrieTree</tag>
      </tags>
  </entry>
  <entry>
    <title>长连接的心跳及重连设计</title>
    <url>/2019/01/23/netty/cim03-heartbeat/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1bed3512ca.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说道“心跳”这个词大家都不陌生，当然不是指男女之间的心跳，而是和长连接相关的。</p>
<p>顾名思义就是证明是否还活着的依据。</p>
<p>什么场景下需要心跳呢？</p>
<p>目前我们接触到的大多是一些基于长连接的应用需要心跳来“保活”。</p>
<p>由于在长连接的场景下，客户端和服务端并不是一直处于通信状态，如果双方长期没有沟通则双方都不清楚对方目前的状态；所以需要发送一段很小的报文告诉对方<code>“我还活着”</code>。</p>
<span id="more"></span>

<p>同时还有另外几个目的：</p>
<ul>
<li>服务端检测到某个客户端迟迟没有心跳过来可以主动关闭通道，让它下线。</li>
<li>客户端检测到某个服务端迟迟没有响应心跳也能重连获取一个新的连接。</li>
</ul>
<p>正好借着在 <a href="https://github.com/crossoverJie/cim">cim</a>有这样两个需求来聊一聊。</p>
<h1 id="心跳实现方式"><a href="#心跳实现方式" class="headerlink" title="心跳实现方式"></a>心跳实现方式</h1><p>心跳其实有两种实现方式：</p>
<ul>
<li><code>TCP</code> 协议实现（<code>keepalive</code> 机制）。</li>
<li>应用层自己实现。</li>
</ul>
<p>由于 <code>TCP</code> 协议过于底层，对于开发者来说维护性、灵活度都比较差同时还依赖于操作系统。</p>
<p>所以我们这里所讨论的都是应用层的实现。</p>
<hr>
<p><img src="https://i.loli.net/2019/05/08/5cd1beda71e1a.jpg"></p>
<p>如上图所示，在应用层通常是由客户端发送一个心跳包 <code>ping</code> 到服务端，服务端收到后响应一个 <code>pong</code> 表明双方都活得好好的。</p>
<p>一旦其中一端延迟 N 个时间窗口没有收到消息则进行不同的处理。</p>
<h1 id="客户端自动重连"><a href="#客户端自动重连" class="headerlink" title="客户端自动重连"></a>客户端自动重连</h1><p>先拿客户端来说吧，每隔一段时间客户端向服务端发送一个心跳包，同时收到服务端的响应。</p>
<p>常规的实现应当是：</p>
<ul>
<li>开启一个定时任务，定期发送心跳包。</li>
<li>收到服务端响应后更新本地时间。</li>
<li>再有一个定时任务定期检测这个<code>“本地时间”</code>是否超过阈值。</li>
<li>超过后则认为服务端出现故障，需要重连。</li>
</ul>
<p>这样确实也能实现心跳，但并不友好。</p>
<p>在正常的客户端和服务端通信的情况下，定时任务依然会发送心跳包；这样就显得没有意义，有些多余。</p>
<p>所以理想的情况应当是客户端收到的写消息空闲时才发送这个心跳包去确认服务端是否健在。</p>
<p>好消息是 <code>Netty</code> 已经为我们考虑到了这点，自带了一个开箱即用的 <code>IdleStateHandler</code> 专门用于心跳处理。</p>
<p>来看看 <code>cim</code> 中的实现：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bedb0c84f.jpg"></p>
<p>在 <code>pipeline</code> 中加入了一个 10秒没有收到写消息的 <code>IdleStateHandler</code>，到时他会回调 <code>ChannelInboundHandler</code> 中的 <code>userEventTriggered</code> 方法。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bedba4a5f.jpg"></p>
<p>所以一旦写超时就立马向服务端发送一个心跳（做的更完善应当在心跳发送失败后有一定的重试次数）；</p>
<p>这样也就只有在空闲时候才会发送心跳包。</p>
<p>但一旦间隔许久没有收到服务端响应进行重连的逻辑应当写在哪里呢？</p>
<p>先来看这个示例：</p>
<p>当收到服务端响应的 pong 消息时，就在当前 Channel 上记录一个时间，也就是说后续可以在定时任务中取出这个时间和当前时间的差额来判断是否超过阈值。</p>
<p>超过则重连。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bedc32bf5.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1bedcce886.jpg"></p>
<p>同时在每次心跳时候都用当前时间和之前服务端响应绑定到 <code>Channel</code> 上的时间相减判断是否需要重连即可。</p>
<p>也就是  <code>heartBeatHandler.process(ctx);</code> 的执行逻辑。</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">heartBeatTime</span> <span class="operator">=</span> appConfiguration.getHeartBeatTime() * <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Long</span> <span class="variable">lastReadTime</span> <span class="operator">=</span> NettyAttrUtil.getReaderTime(ctx.channel());</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (lastReadTime != <span class="literal">null</span> &amp;&amp; now - lastReadTime &gt; heartBeatTime)&#123;</span><br><span class="line">        reconnect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IdleStateHandler-误区"><a href="#IdleStateHandler-误区" class="headerlink" title="IdleStateHandler 误区"></a>IdleStateHandler 误区</h2><p>一切看起来也没毛病，但实际上却没有这样实现重连逻辑。</p>
<p>最主要的问题还是对 <code>IdleStateHandler</code> 理解有误。</p>
<p>我们假设下面的场景：</p>
<ol>
<li>客户端通过登录连上了服务端并保持长连接，一切正常的情况下双方各发心跳包保持连接。</li>
<li>这时服务端突入出现 down 机，那么理想情况下应当是客户端迟迟没有收到服务端的响应从而 <code>userEventTriggered</code> 执行定时任务。</li>
<li>判断<code>当前时间 - UpdateWriteTime &gt; 阈值</code> 时进行重连。</li>
</ol>
<p>但却事与愿违，并不会执行 2、3两步。</p>
<p>因为一旦服务端 <code>down</code> 机、或者是与客户端的网络断开则会回调客户端的 <code>channelInactive</code> 事件。</p>
<p><code>IdleStateHandler</code> 作为一个 <code>ChannelInbound</code> 也重写了 <code>channelInactive()</code> 方法。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bedd54026.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1bee341616.jpg"></p>
<p>这里的 <code>destroy()</code> 方法会把之前开启的定时任务都给取消掉。</p>
<p><strong>所以就不会再有任何的定时任务执行了，也就不会有机会执行这个重连业务</strong>。</p>
<h2 id="靠谱实现"><a href="#靠谱实现" class="headerlink" title="靠谱实现"></a>靠谱实现</h2><p>因此我们得有一个单独的线程来判断是否需要重连，不依赖于 <code>IdleStateHandler</code>。</p>
<p>于是 <code>cim</code> 在客户端感知到网络断开时就会开启一个定时任务：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bee3cc343.jpg"></p>
<blockquote>
<p>之所以不在客户端启动就开启，是为了节省一点线程消耗。网络问题虽然不可避免，但在需要的时候开启更能节省资源。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/08/5cd1bee453e8c.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bee4d34ba.jpg"></p>
<p>在这个任务重其实就是执行了重连，限于篇幅具体代码就不贴了，感兴趣的可以自行查阅。</p>
<p>同时来验证一下效果。</p>
<blockquote>
<p>启动两个服务端，再启动客户端连接上一台并保持长连接。这时突然手动关闭一台服务，客户端可以自动重连到可用的那台服务节点。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/08/5cd1bee585fbb.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1beeac9619.jpg"></p>
<p>启动客户端后服务端也能收到正常的 <code>ping</code> 消息。</p>
<p>利用 <code>:info</code> 命令查看当前客户端的链接状态发现连的是 <code>9000</code>端口。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beeb441d9.jpg"></p>
<blockquote>
<p>:info 是一个新增命令，可以查看一些客户端信息。</p>
</blockquote>
<p>这时我关掉连接上的这台节点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -9 2142</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/05/08/5cd1beec116ff.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1beecdc01a.jpg"></p>
<p>这时客户端会自动重连到可用的那台节点。<br>这个节点也收到了上线日志以及心跳包。</p>
<h1 id="服务端自动剔除离线客户端"><a href="#服务端自动剔除离线客户端" class="headerlink" title="服务端自动剔除离线客户端"></a>服务端自动剔除离线客户端</h1><p>现在来看看服务端，它要实现的效果就是延迟 N 秒没有收到客户端的 <code>ping</code> 包则认为客户端下线了，在 <code>cim</code> 的场景下就需要把他踢掉置于离线状态。</p>
<h2 id="消息发送误区"><a href="#消息发送误区" class="headerlink" title="消息发送误区"></a>消息发送误区</h2><p>这里依然有一个误区，在调用 <code>ctx.writeAndFlush()</code> 发送消息获取回调时。</p>
<p>其中是 <code>isSuccess</code> 并不能作为消息发送成功与否的标准。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beed63443.jpg"></p>
<p>也就是说即便是客户端直接断网，服务端这里发送消息后拿到的 <code>success</code> 依旧是 <code>true</code>。</p>
<p><strong>这是因为这里的 <code>success</code> 只是告知我们消息写入了 <code>TCP</code> 缓冲区成功了而已。</strong></p>
<p>和我之前有着一样错误理解的不在少数，这是 <code>Netty</code> 官方给的回复。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beedd6b0d.jpg"></p>
<p>相关 <code>issue</code>：</p>
<p><a href="https://github.com/netty/netty/issues/4915">https://github.com/netty/netty/issues/4915</a></p>
<blockquote>
<p>同时感谢 95老徐以及闪电侠的一起排查。</p>
</blockquote>
<p>所以我们不能依据此来关闭客户端的连接，而是要像上文一样判断 <code>Channel</code> 上绑定的时间与当前时间只差是否超过了阈值。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beee61f44.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1c2fec4fde.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1c301a72b1.jpg"></p>
<p>以上则是 <code>cim</code> 服务端的实现，逻辑和开头说的一致，也和 <code>Dubbo</code> 的心跳机制有些类似。</p>
<p>于是来做个试验：正常通信的客户端和服务端，当我把客户端直接断网时，服务端会自动剔除客户端。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c304b7104.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1c3070e236.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这样就实现了文初的两个要求。</p>
<ul>
<li>服务端检测到某个客户端迟迟没有心跳过来可以主动关闭通道，让它下线。</li>
<li>客户端检测到某个服务端迟迟没有响应心跳也能重连获取一个新的连接。</li>
</ul>
<p>同时也踩了两个误区，坑一个人踩就可以了，希望看过本文的都有所收获避免踩坑。</p>
<p>本文所有相关代码都在此处，感兴趣的可以自行查看：</p>
<p><a href="https://github.com/crossoverJie/cim">https://github.com/crossoverJie/cim</a></p>
<p>如果本文对你有所帮助还请不吝转发。</p>
]]></content>
      <categories>
        <category>Netty</category>
        <category>cim</category>
      </categories>
      <tags>
        <tag>Heartbeat</tag>
        <tag>IM</tag>
      </tags>
  </entry>
  <entry>
    <title>设计一个百万级的消息推送系统</title>
    <url>/2018/09/25/netty/million-sms-push/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/09/23/5ba7ae180e8eb.jpg" alt="business-communication-computer-261706.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先迟到的祝大家中秋快乐。</p>
<p>最近一周多没有更新了。其实我一直想憋一个大招，分享一些大家感兴趣的干货。</p>
<p>鉴于最近我个人的工作内容，于是利用这三天小长假憋了一个出来（其实是玩了两天🤣）。</p>
<hr>
<p>先简单说下本次的主题，由于我最近做的是物联网相关的开发工作，其中就不免会遇到和设备的交互。</p>
<p>最主要的工作就是要有一个系统来支持设备的接入、向设备推送消息；同时还得满足大量设备接入的需求。</p>
<p>所以本次分享的内容不但可以满足物联网领域同时还支持以下场景：</p>
<ul>
<li>基于 <code>WEB</code> 的聊天系统（点对点、群聊）。</li>
<li><code>WEB</code> 应用中需求服务端推送的场景。</li>
<li>基于 SDK 的消息推送平台。</li>
</ul>
<h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><p>要满足大量的连接数、同时支持双全工通信，并且性能也得有保障。</p>
<p>在 Java 技术栈中进行选型首先自然是排除掉了传统 <code>IO</code>。</p>
<p>那就只有选 NIO 了，在这个层面其实选择也不多，考虑到社区、资料维护等方面最终选择了 Netty。</p>
<p>最终的架构图如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1370be06.jpg"></p>
<span id="more"></span>

<p>现在看着蒙没关系，下文一一介绍。</p>
<h1 id="协议解析"><a href="#协议解析" class="headerlink" title="协议解析"></a>协议解析</h1><p>既然是一个消息系统，那自然得和客户端定义好双方的协议格式。</p>
<p>常见和简单的是 HTTP 协议，但我们的需求中有一项需要是双全工的交互方式，同时 HTTP 更多的是服务于浏览器。我们需要的是一个更加精简的协议，减少许多不必要的数据传输。</p>
<p>因此我觉得最好是在满足业务需求的情况下定制自己的私有协议，在我这个场景下其实有标准的物联网协议。</p>
<p>如果是其他场景可以借鉴现在流行的 <code>RPC</code> 框架定制私有协议，使得双方通信更加高效。</p>
<p>不过根据这段时间的经验来看，不管是哪种方式都得在协议中预留安全相关的位置。</p>
<p>协议相关的内容就不过讨论了，更多介绍具体的应用。</p>
<h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><p>首先考虑如何实现功能，再来思考百万连接的情况。</p>
<h2 id="注册鉴权"><a href="#注册鉴权" class="headerlink" title="注册鉴权"></a>注册鉴权</h2><p>在做真正的消息上、下行之前首先要考虑的就是鉴权问题。</p>
<p>就像你使用微信一样，第一步怎么也得是登录吧，不能无论是谁都可以直接连接到平台。</p>
<p>所以第一步得是注册才行。</p>
<p>如上面架构图中的 <code>注册/鉴权</code> 模块。通常来说都需要客户端通过 <code>HTTP</code> 请求传递一个唯一标识，后台鉴权通过之后会响应一个 <code>token</code>，并将这个 <code>token</code> 和客户端的关系维护到 <code>Redis</code> 或者是 DB 中。</p>
<p>客户端将这个 token 也保存到本地，今后的每一次请求都得带上这个 token。一旦这个 token 过期，客户端需要再次请求获取 token。</p>
<p>鉴权通过之后客户端会直接通过<code>TCP 长连接</code>到图中的 <code>push-server</code> 模块。</p>
<p>这个模块就是真正处理消息的上、下行。</p>
<h2 id="保存通道关系"><a href="#保存通道关系" class="headerlink" title="保存通道关系"></a>保存通道关系</h2><p>在连接接入之后，真正处理业务之前需要将当前的客户端和 Channel 的关系维护起来。</p>
<p>假设客户端的唯一标识是手机号码，那就需要把手机号码和当前的 Channel 维护到一个 Map 中。</p>
<p>这点和之前 <a href="http://t.cn/EPcNHFZ">SpringBoot 整合长连接心跳机制</a> 类似。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d12d78ed4.jpg"></p>
<p>同时为了可以通过 Channel 获取到客户端唯一标识（手机号码），还需要在 Channel 中设置对应的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putClientId</span><span class="params">(Channel channel, String clientId)</span> &#123;</span><br><span class="line">    channel.attr(CLIENT_ID).set(clientId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取时手机号码时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getClientId</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (String)getAttribute(channel, CLIENT_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样当我们客户端下线的时便可以记录相关日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">telNo</span> <span class="operator">=</span> NettyAttrUtil.getClientId(ctx.channel());</span><br><span class="line">NettySocketHolder.remove(telNo);</span><br><span class="line">log.info(<span class="string">&quot;客户端下线，TelNo=&quot;</span> +  telNo);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里有一点需要注意：存放客户端与 Channel 关系的 Map 最好是预设好大小（避免经常扩容），因为它将是使用最为频繁同时也是占用内存最大的一个对象。</p>
</blockquote>
<h2 id="消息上行"><a href="#消息上行" class="headerlink" title="消息上行"></a>消息上行</h2><p>接下来则是真正的业务数据上传，通常来说第一步是需要判断上传消息输入什么业务类型。</p>
<p>在聊天场景中，有可能上传的是文本、图片、视频等内容。</p>
<p>所以我们得进行区分，来做不同的处理；这就和客户端协商的协议有关了。</p>
<ul>
<li>可以利用消息头中的某个字段进行区分。</li>
<li>更简单的就是一个 <code>JSON</code> 消息，拿出一个字段用于区分不同消息。</li>
</ul>
<p>不管是哪种只有可以区分出来即可。</p>
<h3 id="消息解析与业务解耦"><a href="#消息解析与业务解耦" class="headerlink" title="消息解析与业务解耦"></a>消息解析与业务解耦</h3><p>消息可以解析之后便是处理业务，比如可以是写入数据库、调用其他接口等。</p>
<p>我们都知道在 Netty 中处理消息一般是在 <code>channelRead()</code> 方法中。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d12e1b5d7.jpg"></p>
<p>在这里可以解析消息，区分类型。</p>
<p>但如果我们的业务逻辑也写在里面，那这里的内容将是巨多无比。</p>
<p>甚至我们分为好几个开发来处理不同的业务，这样将会出现许多冲突、难以维护等问题。</p>
<p>所以非常有必要将消息解析与业务处理完全分离开来。</p>
<blockquote>
<p>这时面向接口编程就发挥作用了。</p>
</blockquote>
<p>这里的核心代码和 <a href="https://crossoverjie.top/2018/09/03/wheel/cicada1/#%E9%85%8D%E7%BD%AE%E4%B8%9A%E5%8A%A1-Action">「造个轮子」——cicada(轻量级 WEB 框架)</a> 是一致的。</p>
<p>都是先定义一个接口用于处理业务逻辑，然后在解析消息之后通过反射创建具体的对象执行其中的<code>处理函数</code>即可。</p>
<p>这样不同的业务、不同的开发人员只需要实现这个接口同时实现自己的业务逻辑即可。</p>
<p>伪代码如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d12ecbb45.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1350fb4b.jpg"></p>
<p>想要了解 cicada 的具体实现请点击这里：</p>
<p><a href="https://github.com/TogetherOS/cicada">https://github.com/TogetherOS/cicada</a></p>
<p>上行还有一点需要注意；由于是基于长连接，所以客户端需要定期发送心跳包用于维护本次连接。同时服务端也会有相应的检查，N 个时间间隔没有收到消息之后将会主动断开连接节省资源。</p>
<p>这点使用一个 <code>IdleStateHandler</code> 就可实现，更多内容可以查看 <a href="http://t.cn/EPcNHFZ">Netty(一) SpringBoot 整合长连接心跳机制</a>。</p>
<h2 id="消息下行"><a href="#消息下行" class="headerlink" title="消息下行"></a>消息下行</h2><p>有了上行自然也有下行。比如在聊天的场景中，有两个客户端连上了 <code>push-server</code>,他们直接需要点对点通信。</p>
<p>这时的流程是：</p>
<ul>
<li>A 将消息发送给服务器。</li>
<li>服务器收到消息之后，得知消息是要发送给 B，需要在内存中找到 B 的 Channel。</li>
<li>通过 B 的 Channel 将 A 的消息转发下去。</li>
</ul>
<p>这就是一个下行的流程。</p>
<p>甚至管理员需要给所有在线用户发送系统通知也是类似：</p>
<p>遍历保存通道关系的 Map，挨个发送消息即可。这也是之前需要存放到 Map 中的主要原因。</p>
<p>伪代码如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1365b83e.jpg"></p>
<p>具体可以参考：</p>
<p><a href="https://github.com/crossoverJie/netty-action/">https://github.com/crossoverJie/netty-action/</a></p>
<h1 id="分布式方案"><a href="#分布式方案" class="headerlink" title="分布式方案"></a>分布式方案</h1><p>单机版的实现了，现在着重讲讲如何实现百万连接。</p>
<p>百万连接其实只是一个形容词，更多的是想表达如何来实现一个分布式的方案，可以灵活的水平拓展从而能支持更多的连接。</p>
<p>再做这个事前首先得搞清楚我们单机版的能支持多少连接。影响这个的因素就比较多了。</p>
<ul>
<li>服务器自身配置。内存、CPU、网卡、Linux 支持的最大文件打开数等。</li>
<li>应用自身配置，因为 Netty 本身需要依赖于堆外内存，但是 JVM 本身也是需要占用一部分内存的，比如存放通道关系的大 <code>Map</code>。这点需要结合自身情况进行调整。</li>
</ul>
<p>结合以上的情况可以测试出单个节点能支持的最大连接数。</p>
<p>单机无论怎么优化都是有上限的，这也是分布式主要解决的问题。</p>
<h2 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h2><p>在将具体实现之前首先得讲讲上文贴出的整体架构图。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1370be06.jpg"></p>
<p>先从左边开始。</p>
<p>上文提到的 <code>注册鉴权</code> 模块也是集群部署的，通过前置的 Nginx 进行负载。之前也提过了它主要的目的是来做鉴权并返回一个 token 给客户端。</p>
<p>但是 <code>push-server</code> 集群之后它又多了一个作用。那就是得返回一台可供当前客户端使用的 <code>push-server</code>。</p>
<p>右侧的 <code>平台</code> 一般指管理平台，它可以查看当前的实时在线数、给指定客户端推送消息等。</p>
<p>推送消息则需要经过一个推送路由（<code>push-server</code>）找到真正的推送节点。</p>
<p>其余的中间件如：Redis、Zookeeper、Kafka、MySQL 都是为了这些功能所准备的，具体看下面的实现。</p>
<h2 id="注册发现"><a href="#注册发现" class="headerlink" title="注册发现"></a>注册发现</h2><p>首先第一个问题则是 <code>注册发现</code>，<code>push-server</code> 变为多台之后如何给客户端选择一台可用的节点是第一个需要解决的。</p>
<p>这块的内容其实已经在 <a href="https://crossoverjie.top/2018/08/27/distributed/distributed-discovery-zk/">分布式(一) 搞定服务注册与发现</a> 中详细讲过了。</p>
<p>所有的 <code>push-server</code> 在启动时候需要将自身的信息注册到 Zookeeper 中。</p>
<p><code>注册鉴权</code> 模块会订阅 Zookeeper 中的节点，从而可以获取最新的服务列表。结构如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1380b0c9.jpg"></p>
<p>以下是一些伪代码：</p>
<p>应用启动注册 Zookeeper。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d138d15b4.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d139d90f4.jpg"></p>
<p>对于<code>注册鉴权</code>模块来说只需要订阅这个 Zookeeper 节点：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d14032c0d.jpg"></p>
<h3 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h3><p>既然能获取到所有的服务列表，那如何选择一台刚好合适的 <code>push-server</code> 给客户端使用呢？</p>
<p>这个过程重点要考虑以下几点：</p>
<ul>
<li>尽量保证各个节点的连接均匀。</li>
<li>增删节点是否要做 Rebalance。</li>
</ul>
<p>首先保证均衡有以下几种算法：</p>
<ul>
<li>轮询。挨个将各个节点分配给客户端。但会出现新增节点分配不均匀的情况。</li>
<li>Hash 取模的方式。类似于 HashMap，但也会出现轮询的问题。当然也可以像 HashMap 那样做一次 Rebalance，让所有的客户端重新连接。不过这样会导致所有的连接出现中断重连，代价有点大。</li>
<li>由于 Hash 取模方式的问题带来了<a href="https://crossoverjie.top/%2F2018%2F01%2F08%2FConsistent-Hash%2F"><code>一致性 Hash</code>算法</a>，但依然会有一部分的客户端需要 Rebalance。</li>
<li>权重。可以手动调整各个节点的负载情况，甚至可以做成自动的，基于监控当某些节点负载较高就自动调低权重，负载较低的可以提高权重。</li>
</ul>
<p>还有一个问题是：</p>
<blockquote>
<p>当我们在重启部分应用进行升级时，在该节点上的客户端怎么处理？</p>
</blockquote>
<p>由于我们有心跳机制，当心跳不通之后就可以认为该节点出现问题了。那就得重新请求<code>注册鉴权</code>模块获取一个可用的节点。在弱网情况下同样适用。</p>
<p>如果这时客户端正在发送消息，则需要将消息保存到本地等待获取到新的节点之后再次发送。</p>
<h2 id="有状态连接"><a href="#有状态连接" class="headerlink" title="有状态连接"></a>有状态连接</h2><p>在这样的场景中不像是 HTTP 那样是无状态的，我们得明确的知道各个客户端和连接的关系。</p>
<p>在上文的单机版中我们将这个关系保存到本地的缓存中，但在分布式环境中显然行不通了。</p>
<p>比如在平台向客户端推送消息的时候，它得首先知道这个客户端的通道保存在哪台节点上。</p>
<p>借助我们以前的经验，这样的问题自然得引入一个第三方中间件用来存放这个关系。</p>
<p>也就是架构图中的存放<code>路由关系的 Redis</code>，在客户端接入 <code>push-server</code> 时需要将当前客户端唯一标识和服务节点的 <code>ip+port</code> 存进 <code>Redis</code>。</p>
<p>同时在客户端下线时候得在 Redis 中删掉这个连接关系。</p>
<blockquote>
<p>这样在理想情况下各个节点内存中的 map 关系加起来应该正好等于 Redis 中的数据。</p>
</blockquote>
<p>伪代码如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d14187619.jpg"></p>
<p>这里存放路由关系的时候会有并发问题，最好是换为一个 <code>lua</code> 脚本。</p>
<h2 id="推送路由"><a href="#推送路由" class="headerlink" title="推送路由"></a>推送路由</h2><p>设想这样一个场景：管理员需要给最近注册的客户端推送一个系统消息会怎么做？</p>
<blockquote>
<p>结合架构图</p>
</blockquote>
<p>假设这批客户端有 10W 个，首先我们需要将这批号码通过<code>平台</code>下的 <code>Nginx</code> 下发到一个推送路由中。</p>
<p>为了提高效率甚至可以将这批号码再次分散到每个 <code>push-route</code> 中。</p>
<p>拿到具体号码之后再根据号码的数量启动多线程的方式去之前的路由 Redis 中获取客户端所对应的 <code>push-server</code>。</p>
<p>再通过 HTTP 的方式调用 <code>push-server</code> 进行真正的消息下发（Netty 也很好的支持 HTTP 协议）。</p>
<p>推送成功之后需要将结果更新到数据库中，不在线的客户端可以根据业务再次推送等。</p>
<h2 id="消息流转"><a href="#消息流转" class="headerlink" title="消息流转"></a>消息流转</h2><p>也许有些场景对于客户端上行的消息非常看重，需要做持久化，并且消息量非常大。</p>
<p>在 <code>push-sever</code> 做业务显然不合适，这时完全可以选择 Kafka 来解耦。</p>
<p>将所有上行的数据直接往 Kafka 里丢后就不管了。</p>
<p>再由消费程序将数据取出写入数据库中即可。</p>
<p>其实这块内容也很值得讨论，可以先看这篇了解下：<a href="https://crossoverjie.top/2018/08/29/java-senior/OOM-Disruptor/">强如 Disruptor 也发生内存溢出？</a></p>
<p>后续谈到 Kafka 再做详细介绍。</p>
<h1 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h1><p>分布式解决了性能问题但却带来了其他麻烦。</p>
<h2 id="应用监控"><a href="#应用监控" class="headerlink" title="应用监控"></a>应用监控</h2><p>比如如何知道线上几十个 <code>push-server</code> 节点的健康状况？</p>
<p>这时就得监控系统发挥作用了，我们需要知道各个节点当前的内存使用情况、GC。</p>
<p>以及操作系统本身的内存使用，毕竟 Netty 大量使用了堆外内存。</p>
<p>同时需要监控各个节点当前的在线数，以及 Redis 中的在线数。理论上这两个数应该是相等的。</p>
<p>这样也可以知道系统的使用情况，可以灵活的维护这些节点数量。</p>
<h2 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h2><p>日志记录也变得异常重要了，比如哪天反馈有个客户端一直连不上，你得知道问题出在哪里。</p>
<p>最好是给每次请求都加上一个 traceID 记录日志，这样就可以通过这个日志在各个节点中查看到底是卡在了哪里。</p>
<p>以及 ELK 这些工具都得用起来才行。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次是结合我日常经验得出的，有些坑可能在工作中并没有踩到，所有还会有一些遗漏的地方。</p>
<p>就目前来看想做一个稳定的推送系统其实是比较麻烦的，其中涉及到的点非常多，只有真正做过之后才会知道。</p>
<p>看完之后觉得有帮助的还请不吝转发分享。</p>
<p><strong>欢迎关注公众号一起交流：</strong></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>Redis</tag>
        <tag>Zookeeper</tag>
        <tag>推送</tag>
        <tag>路由策略</tag>
        <tag>注册发现</tag>
      </tags>
  </entry>
  <entry>
    <title>如何参与一个顶级开源项目</title>
    <url>/2019/08/19/open%20source/%20how%20to%20contribute%20open-source%20project/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/08/19/baUDOepui5qgKZE.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近个人事情比较多（搬家、换工作、短暂休息）所以一直也没有顾得上博客更新，恰好最近收到一封邮件提醒了我。</p>
<p><img src="https://i.loli.net/2019/08/19/GRemrwT94SFZgq1.jpg"></p>
<p>也是时候写一篇文章来聊聊参与开源项目的事（最近也确实进入了笔荒期）。</p>
<p>ps:第一次收到这样的中秋节礼物，加上 <code>Dubbo</code> 社区的活跃及阿里的重视度，还在做 <code>PRC</code> 或微服务技术选型的朋友可以考虑 <code>Dubbo</code>。</p>
<span id="more"></span>

<h1 id="参与开源"><a href="#参与开源" class="headerlink" title="参与开源"></a>参与开源</h1><p>现在具体来聊聊参与开源的事；</p>
<p>日常几乎所有的开发者都会享受到开源项目所带来的便利甚至是收益，受限于环境早在十几年前甚至几年前开源活动一直都是有国外开发者主导。</p>
<p>但这几年国内互联网公司逐渐国际化扩大影响力也很大程度的提高了我们的开发水平，以 <code>BAT</code> 为首出现了许多优秀的开源项目。</p>
<p>现在甚至参与开源项目还能另辟蹊径的拿到大厂 <code>offer</code>，所以其实不少朋友都想参与其中，可能这事给人的第一感觉就不太容易，所以现在还卡在第一步。</p>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>以下是以我个人经验总结的几大步骤：</p>
<ul>
<li>发现问题或自荐 <code>feature</code> 。</li>
<li>fork 源码。</li>
<li>本地开发、自测。</li>
<li>发起 <code>pull request</code> 。</li>
<li>等待社区 <code>Code Review</code> 。</li>
<li>跟进社区意见调整代码。</li>
<li>审核通过，合并进 <code>master</code> 分支，完成本次贡献。</li>
</ul>
<p>下面我会结合最近一次参与 <code>Dubbo</code> 的流程来具体聊聊。</p>
<h3 id="发现问题或自荐-feature"><a href="#发现问题或自荐-feature" class="headerlink" title="发现问题或自荐 feature"></a>发现问题或自荐 feature</h3><p>首先第一步自然要搞清楚自己本次贡献的内容是什么？通常都是解决某个问题或者是提交一个新的 <code>feature</code> ；前者相对起来更加容易一些。</p>
<p>当然这个问题可以是自己使用过程中发现的，也可以是 Issues 列表中待解决的问题。</p>
<p>以本次为例，就是我在使用过程中所发现的问题，也提交了相关 <a href="https://github.com/apache/dubbo/issues/4556">Issue</a> 并写了一篇文章记录并解决了该问题：<a href="https://crossoverjie.top/2019/07/05/troubleshoot/dubbo-start-slow/">What？一个 Dubbo 服务启动要两个小时！</a></p>
<p>值得注意的是在提交 Issue 之前最好是先在 Issue 列表中通过关键字检索下是否已经有相关问题，避免重复。</p>
<p>同时提交之后也许社区会进行跟进，被打上 <code>invalid</code> 标签认为不是问题，或者是使用姿势不对也是有可能的。</p>
<h3 id="fork-源码，本地开发"><a href="#fork-源码，本地开发" class="headerlink" title="fork 源码，本地开发"></a>fork 源码，本地开发</h3><p>当确定这是一个待修复的问题时就可以着手开发了。</p>
<p>首先第一步自然是将源码拷贝一份到自己仓库中。</p>
<p><img src="https://i.loli.net/2019/08/19/tUyNi3qPdKWAIlT.jpg"></p>
<p>接着只需要 clone 自己仓库中的源码到本地进行开发。</p>
<p>先回顾下我遇到的这个问题。</p>
<p><img src="https://i.loli.net/2019/08/19/QC1X4sTr8B6bquP.jpg"></p>
<p>简单来说就是启动 <code>Dubbo</code> 服务非常缓慢，经过定位是 <code>main</code> 线程阻塞在了获取本机 ip 处。</p>
<p>所以当时我提出的方案是：在获取本机 ip 时加上超时时间，一旦超时便抛出异常或者是再次重试，但起码得有日志方便用户定位问题。</p>
<p>问题是主线程会一直阻塞在此处 <code>InetAddress.getLocalHost().getHostAddress()</code>，但又需要知道它阻塞了多久才好判断是否超时。</p>
<p>所以只能再额外开启一个线程，定时去检测 <code>main</code> 线程是否已经完成任务了，以下便是我第一次 pr 的内容。</p>
<p><img src="https://i.loli.net/2019/08/19/PaOn7wUrXRK8CEV.jpg"><br><img src="https://i.loli.net/2019/08/19/z2r3ghHUtawfJsc.jpg"></p>
<p>这次的重点不是讨论这里具体的技术细节，所以简单说下步骤：</p>
<ul>
<li>额为声明了大小为 1 的线程池。</li>
<li>再声明了一个 <code>volatile</code> 标志用于判断主线程是否有完成任务。</li>
<li>声明了一个 condition 用于新线程做等待。</li>
<li>最后只需要运行这个线程用于判断这个标志即可。</li>
</ul>
<h3 id="如何自测"><a href="#如何自测" class="headerlink" title="如何自测"></a>如何自测</h3><p>开发完成后下一步就是自测，由于这类项目是作为一个基础包依赖于其他的项目才能运行的，所以通常我们还得新建一个项目来配合做全流程测试（单测除外）。</p>
<p>这里我觉得还是有几个小技巧值得注意。</p>
<p>第一个是版本号；因为在本地测试，所以需要使用 <code>mvn clean install</code> 将包安装到本地才能在其他项目中依赖进去进行测试。</p>
<p>但由于我们从官方拉出来的代码版本都已经发布到了 maven 中央仓库中（不管是 release 还是 snapshot），所以我们本地仓库中肯定已经存在这几个版本的 jar 包。</p>
<p>一旦我们执行 <code>mvn clean install</code> 将自己修改的代码安装到本地时，大概率是会出问题的（也可能是我姿势不对），这样就会导致新建的项目中依赖不了自己新增的代码。</p>
<p>所以我通常的做法是修改版本号，这个版本号是从来没有被官方发布到中央仓库中的，可以确保自己新增的代码会以一个全新版本安装到本地，这样我们再依赖这个版本进行测试即可。</p>
<blockquote>
<p>不过再提交时得注意不要把这个版本号提交上去了。</p>
</blockquote>
<h3 id="发起-pull-request"><a href="#发起-pull-request" class="headerlink" title="发起 pull request"></a>发起 pull request</h3><p>自测完成后便可发起 <code>pull request</code> 了，不要大意，这里还得有一个地方需要注意，那就是代码换行符的问题。</p>
<p>一旦换行符与源仓库的不一致时，<code>git</code> 会认为这次修改是删除后重来的，这样会给 <code>code review</code> 带来巨大的麻烦。</p>
<p><img src="https://i.loli.net/2019/08/19/BYQZoROTkPxSazL.jpg"></p>
<p>就像这样，明明我改动的行数并不多，但 <code>git</code> 确认为你是推翻了重来，导致审核起来根本不知道你改了哪些地方。</p>
<p>最简单的方法就是设置自己 <code>git</code> 的全局配置，可以参考<a href="http://kuanghy.github.io/2017/03/19/git-lf-or-crlf">这里</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交时转换为LF，检出时转换为CRLF</span></span><br><span class="line">git config --global core.autocrlf true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交时转换为LF，检出时不转换</span></span><br><span class="line">git config --global core.autocrlf input</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交检出均不转换</span></span><br><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/08/19/8wI71aZvlYzdgOQ.jpg"></p>
<p>确认没问题后便可点击这里发起 pull request，后面按照引导执行即可。</p>
<p>当然各个项目之间还会有自己定制的贡献流程，最好就是查看官方的贡献指南。</p>
<p><a href="http://dubbo.apache.org/en-us/docs/developers/contributor-guide/new-contributor-guide_dev.html">http://dubbo.apache.org/en-us/docs/developers/contributor-guide/new-contributor-guide_dev.html</a></p>
<h3 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h3><p><code>pr</code> 发起后便可等待社区审核了。</p>
<p>在这过程中要充分和社区进行交流，有可能你的方案和社区的想法并不一致。</p>
<p>比如像我这次：</p>
<p><img src="https://i.loli.net/2019/08/19/JQYZb6Lcemw9jaA.jpg"><br><img src="https://i.loli.net/2019/08/19/CqDNrM4IJd8276R.jpg"><br>最终通过沟通加上自己后面的思考觉得还是社区的方案更加轻便合理一些，达成一致之后社区便将这次 pr 合并进 master 中。</p>
<p>其实整个过程我觉得最有意义的便是 <code>code review</code> 的过程，所有人都可以参与其中头脑风暴，其中也不乏技术大牛，不知不觉便能学到不少东西。</p>
<h2 id="类似案例"><a href="#类似案例" class="headerlink" title="类似案例"></a>类似案例</h2><p>虽然我之前的方案没有被采纳，但类似的用法（一个线程监控其他线程）还是不少，正好在 <code>Dubbo</code> 中也有用到。</p>
<p>便是其中核心的服务调用，默认情况下对使用者来说这看起来是一个同步调用，也就是说消费方会等待 PRC 执行完毕后才会执行后续逻辑。</p>
<p>但其实在底层这就是一个 <code>TCP</code> 网络包的发送过程，<strong>本身就是异步的</strong>。</p>
<p>只是 <code>Dubbo</code> 在你不知道的情况下做了异步转同步，这样看起来就像是一个同步方法。</p>
<p><img src="https://i.loli.net/2019/08/19/I1WSzpism3UtkQJ.jpg"></p>
<p>如图中的红框部分，<code>Dubbo</code> 自身调用了 <code>get()</code> 方法用于同步获取服务提供者的返回结果。</p>
<p><img src="https://i.loli.net/2019/08/19/Odr91A6NxH3TUMe.jpg"></p>
<p>逻辑其实也挺简单，和我上文的方案类似，只是这里的 <code>isDone()</code> 函数返回的是是否已经拿到了服务提供者的返回值而已。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次总结了参与开源的具体步骤，其实也挺简单；就如官方所说哪怕是提个 Issue，修改一个错别字都算是参与，所以不要想的太难。</p>
<p>最后还简单分析了 Dubbo 调用过程中的异步转同步的过程，掌握这些操作对自己平时开发也是很有帮助的。</p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>open source</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>thread</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 ChatGPT 碰到的坑</title>
    <url>/2023/07/18/ob/ChatGPT-hole/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/07/14/YtqXVJmfNokCwyE.png"></p>
<p>最近在使用 ChatGPT 的时候碰到一个小坑，因为某些特殊情况我需要使用 <code>syslog</code> 向 <code>logbeat</code> 中发送日志。</p>
<p>由于这是一个比较古老的协议，确实也没接触过，所以就想着让 ChatGPT 帮我生成个例子。</p>
<span id="more"></span>

<p>原本我已经在  Go  中将这个流程跑通，所以其实只需要将代码转换为 Java 就可以了，这个我还是很信任 <code>ChatGPT</code> 的；</p>
<blockquote>
<p>现在我挺多结构化数据的转换都交给了 ChatGPT，省去了不少小工具。</p>
</blockquote>
<p>于是便有了这段对话：<br><img src="https://s2.loli.net/2023/07/17/6MHlRKOtZ2rJocd.png" alt="image.png"><br><img src="https://s2.loli.net/2023/07/17/SzCGBuiN6AvR7Zo.png" alt="image.png"><br>看起来挺正常的，我那过来改改确实也能用。</p>
<hr>
<p>直到快上线的时候，我发现一些元信息丢失了，比如日志生产者的 <code>hostname, PID</code> 等，然而这个信息在 Go 却没有丢失。</p>
<p>于是我反复调试了之前生成的代码，依然没有找到问题。</p>
<p>没办法，就只有去翻翻 Go 源码，想看看最终发出去的数据长什么样子，最后看到这样几行代码：<br><img src="https://s2.loli.net/2023/07/17/kJnoR4stKwYvCg8.png"><br><img src="https://s2.loli.net/2023/07/17/tOHvgx2ZzyrAEh9.png" alt="image.png"></p>
<p>这样一看就很清晰了，只是按照 <code>&lt;%d&gt;%s %s %s[%d]: %s%s</code> 的格式将生成的字符串通过网络发送出去。</p>
<p>既然这样 Java 代码也很好写了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(hostname,port);</span><br><span class="line">socket.setKeepAlive(<span class="literal">true</span>);</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(os, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> String.format(<span class="string">&quot;&lt;%d&gt;%s %s %s[%d]: %s%s&quot;</span>, <span class="number">6</span> , rfc3164DateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()), <span class="string">&quot;test&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="number">0</span>, message, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">pw.println(format);</span><br></pre></td></tr></table></figure>
<p>经过测试数据终于对了。</p>
<p>之后我就在想这么简单的一个问题 Google 上不可能没有吧，于是直接搜索了 <code>Java syslog</code> 关键字，结果直接就有一个现成的库。<br><img src="https://s2.loli.net/2023/07/17/Fm6XBnOdxQ9PAKY.png"></p>
<p><img src="https://s2.loli.net/2023/07/17/c7PCjmZnboReQtp.png"></p>
<p>而且实现也是类似的。</p>
<p>我相信应该有不少朋友也有被 ChatGPT 一本正经的胡说八道误导过，至少在当前的环境下一些简单的东西我还是决定优先 <code>Google</code>。</p>
]]></content>
      <categories>
        <category>ChatGPT</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Syslog</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 基础面试题 01</title>
    <url>/2023/09/12/ob/Golang-interview-01/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/09/12/xJgnyReWs2mp7Pr.png" alt="Golang 面试题合集.png"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在之前的文章中分享了 <a href="https://crossoverjie.top/2023/08/17/ob/k8s-question-01/">k8s</a> 相关的面试题，本文我们重点来讨论和 k8s 密切相关的 Go 语言面试题。</p>
<p>这几年随着云原生的兴起，大部分后端开发者，特别是 Java 开发者都或多或少的想学习一些 Go 相关的技能，所以今天分享的内容比较初级，适合 Go 语言初学者。</p>
<p><img src="https://s2.loli.net/2023/09/12/oheqNwJt3KvsgDM.png" alt="image.png"></p>
<p>本文内容依然来自于这个仓库<br><a href="https://github.com/bregman-arie/devops-exercises">https://github.com/bregman-arie/devops-exercises</a></p>
<span id="more"></span>


<p>以下是具体内容：</p>
<blockquote>
<p>（）的内容是我的补充部分。</p>
</blockquote>
<h1 id="Go-101"><a href="#Go-101" class="headerlink" title="Go 101"></a>Go 101</h1><h2 id="Go-语言有哪些特点"><a href="#Go-语言有哪些特点" class="headerlink" title="Go 语言有哪些特点"></a>Go 语言有哪些特点</h2><ul>
<li>Go 是一种强类型静态语言，变量的类型必须在声明的时候指定（但可以使用类型推导），在运行时不能修改变量类型（与 <code>Python</code> 这类动态类型语言不同）。</li>
<li>足够的简单，通常一个周末就能学会</li>
<li>编译速度够快</li>
<li>内置并发（相对于 Java 的并发来说非常简单）</li>
<li>内置垃圾收集</li>
<li>多平台支持</li>
<li>可以打包到一个二进制文件中，所有运行时需要依赖的库都会被打包进这个二进制文件中，非常适合于分发。</li>
</ul>
<h2 id="Go-是一种编译型的静态类型语言，正确还是错误"><a href="#Go-是一种编译型的静态类型语言，正确还是错误" class="headerlink" title="Go 是一种编译型的静态类型语言，正确还是错误"></a>Go 是一种编译型的静态类型语言，正确还是错误</h2><p>正确✅</p>
<h2 id="为什么有些函数是以大写字母开头的"><a href="#为什么有些函数是以大写字母开头的" class="headerlink" title="为什么有些函数是以大写字母开头的"></a>为什么有些函数是以大写字母开头的</h2><p>这是因为 Go 语言中首字母大写的函数和变量是可以导出的，也就是可以被其他包所引用；类似于 Java 中的 <code>public</code> 和 <code>private</code> 关键字。</p>
<h1 id="变量和数据类型"><a href="#变量和数据类型" class="headerlink" title="变量和数据类型"></a>变量和数据类型</h1><h2 id="简洁和常规声明变量方式"><a href="#简洁和常规声明变量方式" class="headerlink" title="简洁和常规声明变量方式"></a>简洁和常规声明变量方式</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x := <span class="number">2</span> <span class="comment">// 只能在函数内使用，自动类型推导</span></span><br><span class="line">  <span class="keyword">var</span> y <span class="type">int</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">&quot;x: %v. y: %v&quot;</span>, x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="正确✅还是错误❌"><a href="#正确✅还是错误❌" class="headerlink" title="正确✅还是错误❌"></a>正确✅还是错误❌</h2><ul>
<li>可以重复声明变量❌（强类型语言的特性）</li>
<li>变量一旦声明，就必须使用✅（避免声明无效变量，增强代码可读性）</li>
</ul>
<h2 id="下面这段代码的结果是什么？"><a href="#下面这段代码的结果是什么？" class="headerlink" title="下面这段代码的结果是什么？"></a>下面这段代码的结果是什么？</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> userName</span><br><span class="line">    userName = <span class="string">&quot;user&quot;</span></span><br><span class="line">    fmt.Println(userName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译错误，变量 <code>userName</code> 没有声明类型；修改为这样是可以的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> userName <span class="type">string</span></span><br><span class="line">    userName = <span class="string">&quot;user&quot;</span></span><br><span class="line">    fmt.Println(userName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="var-x-int-2-and-x-2-这两种声明变量的区别"><a href="#var-x-int-2-and-x-2-这两种声明变量的区别" class="headerlink" title="var x int = 2 and x := 2 这两种声明变量的区别"></a><code>var x int = 2</code> and <code>x := 2</code> 这两种声明变量的区别</h2><p>结果上来说是相等的，但 <code>x := 2</code>  只能在函数体类声明。</p>
<h2 id="下面这段代码的结果是声明？"><a href="#下面这段代码的结果是声明？" class="headerlink" title="下面这段代码的结果是声明？"></a>下面这段代码的结果是声明？</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">x := <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x = <span class="number">3</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译错误，<code>x := 2</code>  不能在函数体外使用， <code>x = 3</code> 没有指定类型，除非使用 <code>x := 3</code> 进行类型推导。</p>
<h2 id="如何使用变量声明块（至少三个变量）"><a href="#如何使用变量声明块（至少三个变量）" class="headerlink" title="如何使用变量声明块（至少三个变量）"></a>如何使用变量声明块（至少三个变量）</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  x <span class="type">bool</span>   = <span class="literal">false</span></span><br><span class="line">  y <span class="type">int</span>    = <span class="number">0</span></span><br><span class="line">  z <span class="type">string</span> = <span class="string">&quot;false&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;The type of x: %T. The value of x: %v\n&quot;</span>, x, x)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;The type of y: %T. The value of y: %v\n&quot;</span>, y, y)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;The type of z: %T. The value of z: %v\n&quot;</span>, y, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量块配合 <code>go fmt</code> 格式化之后的代码对齐的非常工整，强迫症的福音。</p>
<p>Go 的基础面试题也蛮多的，我们先从基础的开始，今后后继续更新相关面试题，难度也会逐渐提高，感兴趣的朋友请持续关注。<br>#GO #面试 </p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Helm 管理应用的一些 Tips</title>
    <url>/2023/10/07/ob/Helm-tips/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/10/08/9HKS1lNqyGMson5.png" alt="Helm tips.png"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><code>Helm</code> 是一个 <strong>Kubernetes</strong> 的包管理工具，有点类似于 <code>Mac</code> 上的 <code>brew</code>，<code>Python</code> 中的 <code>PIP</code>；可以很方便的帮我们直接在 <code>kubernetes</code> 中安装某个应用。</p>
<p>比如我们可以直接使用以下命令方便的在 k8s 集群安装和卸载 <code>MySQL</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install my-sql oci://registry-1.docker.io/bitnamicharts/mysql -n mysql</span><br><span class="line"></span><br><span class="line">helm uninstall my-mysql -n mysql</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<p>对于一些复杂的应用使用 Helm 一键安装会更简单，以 Pulsar 举例：<br><img src="https://s2.loli.net/2023/10/08/ig4koZIFlUT5Bt1.png" alt="image.png"><br>它有着多个组件，比如 bookkeeper、zookeeper、broker、proxy 等，各个组件还有着依赖关系。</p>
<p>如果我们手动安装流程会比较繁琐，而使用 Helm 时便非常简单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add apache https://pulsar.apache.org/charts</span><br><span class="line"></span><br><span class="line">helm install my-pulsar apache/pulsar --version 3.0.0 -n pulsar</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然他也只是帮我们生成了部署所需要的 yaml 文件，也没有太多黑科技。</p>
</blockquote>
<h1 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h1><p>看似简单的工具我在实际线上使用的时候也踩过一个坑，最大的一个问题就是某次升级 Pulsar 的时候生成的 yaml 文件是空的，导致整个集群被删除了😭。</p>
<p>还好最后使用 <code>helm  rollback version</code> 将集群恢复过来了，我们的持久化数据也还在。</p>
<p>而出现这个问题的原因是我执行了下面这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm upgrade pulsar ./charts/pulsar --version 2.9.2 -f charts/pulsar/values-2.10.3.yaml -n pulsar</span><br></pre></td></tr></table></figure>

<p>我们是将 <code>pulsar</code> 的 <code>Helm-Chart</code> 源码下载到本地，然后修改 <code>value.yaml</code> 的方式执行升级的。</p>
<p>当时执行命令的时候没有注意，在一个没有 <code>values-2.10.3.yaml</code> 文件的目录下执行的，导致生成的 <code>yaml</code> 文件是空的，也就导致 k8s 在 <code>pulsar</code> 这个 <code>namespace</code> 下删除了所有的资源。</p>
<h2 id="模拟升级"><a href="#模拟升级" class="headerlink" title="模拟升级"></a>模拟升级</h2><p>为了避免今后再次出现类似的问题，需要在升级前先模拟升级：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm upgrade pulsar ./charts/pulsar --version 2.9.2 -f charts/pulsar/values-2.10.3.yaml -n pulsar --dry-run --debug &gt; debug.yaml</span><br></pre></td></tr></table></figure>

<p>其中关键的 <code>dry-run</code> 和 <code>debug</code> 参数可以指定模拟升级和输出详细的内容。</p>
<p>这样我们就可以在升级前先查看 <code>debug.yaml</code> 里的内容是不是符合我们的预期。</p>
<h1 id="对比升级"><a href="#对比升级" class="headerlink" title="对比升级"></a>对比升级</h1><p>但这样并不能直观的看出哪些地方是我们修改的，还好社区已经有了相关的插件，可以帮我们高亮显示修改的地方。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm plugin install https://github.com/databus23/helm-diff</span><br></pre></td></tr></table></figure>
<p>我们先安装好这个 helm 插件。</p>
<p>然后在升级前先使用该插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm diff upgrade pulsar ./charts/pulsar --version 2.9.2 -f charts/pulsar/values-2.10.3.yaml -n pulsar</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/10/08/V1k5gdhLASfq9JR.png" alt="image.png"></p>
<p>这样就可以高亮显示出修改的内容。</p>
<blockquote>
<p>不用担心这个命令会直接升级，它会自动加上 –dry-run –debug 参数。</p>
</blockquote>
<p>更多命令可以参考官方文档：<br><a href="https://github.com/databus23/helm-diff">https://github.com/databus23/helm-diff</a></p>
<p>Helm 功能很强，在操作生产环境的时候必须得谨慎，都是血淋淋的教训啊。</p>
]]></content>
      <categories>
        <category>Helm</category>
      </categories>
      <tags>
        <tag>CloudNative</tag>
      </tags>
  </entry>
  <entry>
    <title>从 Pulsar Client 的原理到它的监控面板</title>
    <url>/2023/08/03/ob/Pulsar-Client/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/08/02/GipDPSlbycQxqFd.png" alt="image.png"></p>
<p>#Blog #Pulsar </p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间业务团队偶尔会碰到一些 Pulsar 使用的问题，比如消息阻塞不消费了、生产者消息发送缓慢等各种问题。</p>
<p>虽然我们有个监控页面可以根据 topic 维度查看他的发送状态，比如速率、流量、消费状态等信息。</p>
<span id="more"></span>

<p><img src="https://s2.loli.net/2023/08/02/UNZVawH4QYSu3Ko.png" alt="image.png"></p>
<p>但也有几个问题：</p>
<ul>
<li>无法在应用维度查看他所依赖的所有  topic 的各种状态。</li>
<li>监控的信息还不够，比如发送&#x2F;消费延迟、发送&#x2F;消费失败等数据。</li>
</ul>
<p>总之就是缺少一个全局的监控视角，通过这些指标可以很方便的分析出当时的运行情况。</p>
<p>基于这个需求经过一段时间的折腾，现在已经上线使用几个月，目前比较稳定，效果图如下：<br><img src="https://s2.loli.net/2023/08/02/byv4RDZnruSjo9h.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/TtufOpwHB86PFhK.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/d21IaNzbFQpnrkA.png" alt="image.png"></p>
<p>现在就可以在每个应用的监控面板里看到自己使用了哪些 topic，分别的生产消费情况如何。</p>
<h1 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h1><p>要实现这些功能就得在应用的 <code>metrics</code> 中加入相关的监控信息，但官方的 Java client 是没有暴露出这些指标的。</p>
<p><img src="https://s2.loli.net/2023/08/02/DlfkQo1Lmt8J7Iq.png" alt="image.png"></p>
<blockquote>
<p>但 pulsar-client-go 是自带了这些指标的</p>
</blockquote>
<p>由于 <code>SDK</code> 不支持所以只能自己想办法实现了，为此其实有两种实现方案：</p>
<ul>
<li>魔改 <code>Java client</code>，在需要监控的地方手动埋点指标。</li>
<li>由于我们使用了 <code>SkyWalking</code>，所以可以编写插件，以 <code>agent</code> 的方式获取数据、埋点指标。</li>
</ul>
<p>不过第一种方案有以下一些问题：</p>
<ul>
<li>需要自己维护一个代码分支，还需要定期和官方保持一致，难免会出现代码冲突。</li>
<li>需要推动业务方进行依赖升级，线上有着几百个应用，推动起来时间太慢。</li>
</ul>
<p>第二种方案的好处就不言而喻了：</p>
<ul>
<li>升级无感知，只需要在我们的基础镜像中加上插件即可。</li>
<li>Java client 的版本也更容易统一。</li>
</ul>
<h2 id="Client-原理"><a href="#Client-原理" class="headerlink" title="Client 原理"></a>Client 原理</h2><p>但其实不管是哪种方案我们都得熟悉 Java Client 的实现原理，才能知道哪些数据是我们需要重点关注的，可以帮助我们更好的定位问题。</p>
<p><img src="https://s2.loli.net/2023/08/02/vweWVR8fkJgrSMI.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/S2DNUb768rJRMLm.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/8Byvq4LXtACoIg5.png" alt="image.png"></p>
<blockquote>
<p>本文重点不在于此，具体代码就不仔细分析了。</p>
</blockquote>
<p>从上图可以看出，如果我们想要监控消费是否存在阻塞的情况，这几个内部队列是需要重点监控的，一旦他们出现堆积，那就会出现消费阻塞。</p>
<p>其实这些数据都可以通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.apache.pulsar.client.api.ProducerStats</span><br><span class="line">org.apache.pulsar.client.api.ConsumerStats</span><br></pre></td></tr></table></figure>
<p>这两个接口获取到生产者和消费者的大部分指标，只是这里还有一个小插曲。</p>
<p>那就是在获取消费者队列大小的时候，获取到的数据一直为空。</p>
<p>最终经过源码排查，原来是我们大量使用的 <code>messageListener</code> 在获取队列大小时有 bug，导致获取到的数据一直都为 0.</p>
<p>相关的 issue 和 PR 可以在这两个链接查看，问题原因和修复过程都有具体描述：<br><a href="https://github.com/apache/pulsar/issues/20076">https://github.com/apache/pulsar/issues/20076</a><br><a href="https://github.com/apache/pulsar/pull/20245">https://github.com/apache/pulsar/pull/20245</a></p>
<blockquote>
<p>但这个修复得在新版本才能使用，就导致我们现在的监控页面一直显示为空。</p>
</blockquote>
<h1 id="开发-SkyWalking-插件"><a href="#开发-SkyWalking-插件" class="headerlink" title="开发 SkyWalking 插件"></a>开发 SkyWalking 插件</h1><p>然后就是开发一个 <code>SkyWalking</code> 的插件了，其实直接使用 SW 开发插件是上手 <code>Java-Agent</code> 比较快的方式。</p>
<p><code>SW</code> 的 SDK 封装了许多 <code>agent</code> 原生接口，使得开发起来非常容易；当然缺点也有，就是得集成整个 <code>SW</code> 的 <code>agent</code>。</p>
<p>这里我简单介绍下这个插件的运行流程：<br><img src="https://s2.loli.net/2023/08/02/tW8QSqdU1yZf25A.png" alt="image.png"></p>
<ul>
<li>在创建和删除 consumer 的时候维护 consumerPool</li>
<li>启动一个定时任务，定期从这些 consumer 中获取指标数据。<br><img src="https://s2.loli.net/2023/08/02/ndhi3yH7CzS9FLA.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/WtZNTClh8Y3wj1F.png" alt="image.png"></li>
</ul>
<blockquote>
<p>当消费多分区 topic 时，为了能唯一标志一个 consumer，所以给每个消费者都加了一个 hashcode 的 label。</p>
</blockquote>
<p>因为我们所有的 Java 技术栈都是使用的 <code>Prometheus</code> 的包来生成 <code>metrics</code> ，所以该插件也是使用该包生成的数据。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了兼容一些特殊 Java 应用没有该包时会启动报错，所以在初始化插件的时候需要检测当前 <code>classpath</code> 下是否存在该依赖。</p>
<p><img src="https://s2.loli.net/2023/08/02/IBwdhH9b1tc8aoE.png" alt="image.png"></p>
<p>这些功能 SW 已经封装好了，对我们来说也是开箱即用。</p>
<blockquote>
<p>其实 SW 插件自己也是支持 metrics 的，由于我们只是使用了它的 trace 功能，所以这里就没有使用它的 API。</p>
</blockquote>
<p>关于开发一个 SW 插件的流程也比较简单，可以参考官方文档或者是一些现成的插件源码。<br><a href="https://skywalking.apache.org/docs/skywalking-java/next/en/setup/service-agent/java-agent/java-plugin-development-guide/">https://skywalking.apache.org/docs/skywalking-java/next/en/setup/service-agent/java-agent/java-plugin-development-guide/</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有了这个监控面板后，对于 Pulsar 客户端内部的一些运行情况就不再是黑盒了，还可以基于此做一些报警，比如消费堆积、发送延迟过大等。</p>
<p>当然仅仅只有这个面板依然是不够的，后续我们又开发了可以通过 <code>messageId</code> 查询它的整个生命周期，包括：</p>
<ul>
<li>生产者、消费者信息</li>
<li>消息生产时间</li>
<li>推送时间</li>
<li>ack 时间等</li>
</ul>
<p><img src="https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png" alt="image.png"></p>
<p>同时借助与 Pulsar-SQL 的能力，还能以列表的形式展示当前 topic 的消息列表。<br><img src="https://s2.loli.net/2023/08/02/l9uvSnqAOxfPer7.png" alt="image.png"><br>当然在实现这两个功能的同时也踩了不少坑，提了几个 PR ，后面在抽时间做具体的分享。</p>
]]></content>
      <categories>
        <category>Pulsar</category>
      </categories>
      <tags>
        <tag>Metrics</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 SQL 的方式查询消息队列数据以及踩坑指南</title>
    <url>/2023/08/30/ob/Pulsar-SQL/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/08/30/3iz9yqfuSCn18xk.png" alt="Pulsar-sql.png"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>为了让业务团队可以更好的跟踪自己消息的生产和消费状态，需要一个类似于表格视图的消息列表，用户可以直观的看到发送的消息；同时点击详情后也能查到消息的整个轨迹。</p>
<blockquote>
<p> 消息列表<br><img src="https://s2.loli.net/2023/08/02/l9uvSnqAOxfPer7.png" alt="20230802234405.png"></p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>点击详情后查看轨迹<br><img src="https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png" alt="20230802234058.png"></p>
</blockquote>
<h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p>由于 <code>Pulsar</code> 并没有关系型数据库中表的概念，所有的数据都是存储在 <code>Bookkeeper</code> 中，为了模拟使用 SQL 查询的效果 Pulsar 提供了 <code>Presto</code> (现在已经更名为 <code>Trino</code>)的插件。</p>
<blockquote>
<p>Trino 是一个分布式的 SQL 查询引擎，它也提供了插件能力，如果我们想通过 SQL 从自定义数据源查询数据时，基于它的 SPI 编写一个插件是很方便的。</p>
</blockquote>
<p>这样便可以类似于查询数据库一样查询 <code>Pulsar</code> 数据：<br><img src="https://s2.loli.net/2023/08/30/1YEtorbwaZAXylL.png" alt="image.png"></p>
<hr>
<p><img src="https://s2.loli.net/2023/08/30/u6gc3YxvH94ZDPG.png" alt="image.png"><br>Pulsar 插件的运行流程如上图所示：</p>
<ul>
<li>启动的时候通过 <code>Pulsar-Admin</code> 接口获取一些元数据，比如 Scheme，topic 分区信息等。</li>
<li>然后会创建一个只读的 Bookkeeper 客户端，用于获取数据。</li>
<li>之后根据 SQL 条件过滤数据即可。</li>
</ul>
<p>相关代码：<br><img src="https://s2.loli.net/2023/08/30/vr7ED6BYgOsoqxz.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/30/Np2XD7T9cJAwxQC.png" alt="image.png"></p>
<h1 id="使用-Pulsar-SQL"><a href="#使用-Pulsar-SQL" class="headerlink" title="使用 Pulsar-SQL"></a>使用 Pulsar-SQL</h1><p><img src="https://s2.loli.net/2023/08/30/UBqocsjFvC2yXEe.png" alt="image.png"></p>
<p>使用起来也很简单，官方提供了两个命令：</p>
<ul>
<li>sql-worker: 会启动一个 trino 服务端同时运行了 Pulsar 插件</li>
<li>sql: 就是一个 SQL 命令行终端。</li>
</ul>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>自己在本地运行的时候自然是没问题，可是一旦想在生产运行，同时如果你的 <code>Pulsar</code> 集群是运行再 <code>k8s</code> 环境中时就会碰到一些问题。</p>
<h3 id="无法使用现有-Trino-集群"><a href="#无法使用现有-Trino-集群" class="headerlink" title="无法使用现有 Trino 集群"></a>无法使用现有 Trino 集群</h3><p>首先第一个问题是如果生产环境已经有了一个 <code>Trino</code> 集群想要复用的时候就会碰到问题，常规流程是将 <code>Pulsar</code> 的插件复制到 <code>Trino</code> 的 <code>Plugin</code> 目录，然后重启 <code>Trino</code> 后就能使用该插件。</p>
<p>当然社区也是支持这么做的：<br><img src="https://s2.loli.net/2023/08/30/RqtIvwy5HNsr27M.png" alt="image.png"><br>但是当我将 Pulsar-plugin 复制到 Trino 中运行的时候却失败了，整体的流程可以参考这个 issue：<br><a href="https://github.com/apache/pulsar/discussions/20941">https://github.com/apache/pulsar/discussions/20941</a></p>
<p>简单来说 <code>Trino</code> 的官方镜像和 <code>pulsar-plugin</code> 并不能兼容，这个问题直接影响到我们是否可以在生产环境使用它。</p>
<p>但是手动编译出来的 <code>Trino</code> 服务和插件是兼容的，可以直接运行。</p>
<p><img src="https://s2.loli.net/2023/08/30/MswBlVXi12DICr9.png" alt="image.png"></p>
<p>因此我只能在本地编译出 Trino 服务端和 <code>pulsar-plugin</code> 然后打包成一个镜像来运行了，当然这样的坏处就是无法利用到我们现有的 <code>Trino</code> 集群，又得重新部署一个了。</p>
<p><img src="https://s2.loli.net/2023/08/30/vG83bleTf1EcCPp.png" alt="image.png"></p>
<p>流程也比较麻烦：</p>
<ul>
<li>首先是本地编译 <code>Pulsar-SQL</code> 模块</li>
<li>将生成物复制到当前目录</li>
<li>执行 <code>make docker</code> 打出 docker 镜像并上传到私服</li>
<li>再执行 <code>kubectl</code> 将 trino 部署到 <code>k8s</code> 环境中</li>
</ul>
<p>整个流程做下来加上和社区的沟通，更加确定这个功能应该是很少有人在生产环境使用的，毕竟第一个坑就很麻烦，更别提后续的问题了😂。</p>
<h3 id="Presto-插件不支持-AuthToken"><a href="#Presto-插件不支持-AuthToken" class="headerlink" title="Presto 插件不支持 AuthToken"></a>Presto 插件不支持 AuthToken</h3><p>第二个问题也是个深坑，当我把 Trino 部署好查询数据的时候直接抛了一个调用 <code>pulsar-admin</code>  接口连接超时的异常。</p>
<p>结果排查了半天发现原来是 <code>pulsar-plugin</code> 里没有提供 <code>JWT</code> 的验证方式，而我们的 Pulsar 集群恰好是打开了 <code>JWT</code> 验证的。</p>
<p>为此我只能先在本地修复了这个问题，同时也提交了 PR，预计会在下一个大版本合并吧：<br><a href="https://github.com/apache/pulsar/pull/20860">https://github.com/apache/pulsar/pull/20860</a></p>
<h3 id="新创建的-topic-查询失败"><a href="#新创建的-topic-查询失败" class="headerlink" title="新创建的 topic 查询失败"></a>新创建的 topic 查询失败</h3><p>第二个问题是当查询一个新创建的 topic 时，客户端会直接 block，相关的复现流程在这里：<br><a href="https://github.com/apache/pulsar/issues/20910">https://github.com/apache/pulsar/issues/20910</a></p>
<p><img src="https://s2.loli.net/2023/08/30/nYestcQqRax1NVv.png" alt="image.png"></p>
<p>这个问题还好，不是很致命，是我在本地测试的时候无意间发现的。</p>
<p>本地我已经修复了，后面也提交了一个 PR，目前还在讨论中：<br><a href="https://github.com/apache/pulsar/pull/20911">https://github.com/apache/pulsar/pull/20911</a></p>
<h3 id="查询消息会丢失最后一条"><a href="#查询消息会丢失最后一条" class="headerlink" title="查询消息会丢失最后一条"></a>查询消息会丢失最后一条</h3><p>这个问题也不是很严重，数据量少的时候会发现，就是在指定了消息发送时间的查询条件时，最后一条消息会被过滤掉，相关 issue 在这里：<br><a href="https://github.com/apache/pulsar/issues/20919">https://github.com/apache/pulsar/issues/20919</a><br><img src="https://s2.loli.net/2023/08/30/MPamvyduxrTZRkY.png" alt="image.png"><br>这个我只是定位到了原因，但不太清楚 为什么要这么做(-1)，影响也不是很大，就放在这里搁置了。</p>
<h3 id="Schema-不兼容"><a href="#Schema-不兼容" class="headerlink" title="Schema 不兼容"></a>Schema 不兼容</h3><p>最后发现的一个问题是我们线上某些 topic 查询数据的时候会抛出 <code>Not a record: &quot;string&quot;</code>的异常，但只是部分 topic，也排查了很久，整个源码中没有任何一个地方有这个异常。</p>
<p><a href="!%5B%5D(https://s2.loli.net/2023/08/30/UBl6OPGzASnfqT2.png)">https://github.com/apache/pulsar/issues/20945</a></p>
<p><img src="https://s2.loli.net/2023/08/30/UBl6OPGzASnfqT2.png" alt="image.png"></p>
<p>根本原因是生产者生成的 schema 有问题，类型已经是 JSON 了，但是 schema 却是 string，这样导致 <code>pulsar-plugin</code>  在反序列化 schema 的时候抛出了异常，由于是 pb 反序列化抛出的异常，所以源码中都搜索不到。</p>
<blockquote>
<p>没有问题的 topic 使用了正确的 schema</p>
</blockquote>
<p>后续我也在本地修复了这个问题，当抛出异常后就将 schema 降级为基本类型进行解析。<br><img src="https://s2.loli.net/2023/08/30/XZfWG2EYHpj5QJb.png" alt="image.png"></p>
<p>不过本质问题还是客户端使用有误，如果对 <code>schema</code> 理解不准确的话还是建议使用 <code>byte[]</code> 吧，这样至少兼容性不会有问题。<br>相关 PR：<br><a href="https://github.com/apache/pulsar/pull/20955">https://github.com/apache/pulsar/pull/20955</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Pulsar-SQL</code> 是一个非常有用的功能，只是我们使用过程中确实发现了一些问题，大部分都已经修复了；<br>希望对后续使用该功能的朋友有所帮助。<br>#Pulsar </p>
]]></content>
      <categories>
        <category>Pulsar</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>VictoriaLogs：一款超低占用的 ElasticSearch 替代方案</title>
    <url>/2023/08/23/ob/VictoriaLogs-Intro/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/08/23/t5soejn8vw1aZil.png" alt="image.png"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间我们想实现 <code>Pulsar</code> 消息的追踪流程，追踪实现的效果图如下：<br><img src="https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png" alt="image.png"></p>
<p>实现其实比较简单，其中最重要的就是如何存储消息。</p>
<blockquote>
<p>消息的读取我们是通过 Pulsar 自带的 BrokerInterceptor 实现的，对这个感兴趣的朋友后面会单独做一个分享。</p>
</blockquote>
<span id="more"></span>

<p>根据这里的显示内容我们大概需要存储这些信息：</p>
<ul>
<li>客户端地址</li>
<li>消息发布时间</li>
<li>分发消费者、订阅者名称</li>
<li>ACK 消费者、订阅者名称</li>
<li>消息 ID<br>最终捋了下：<br><img src="https://s2.loli.net/2023/08/23/MWbVcu6dm1NfaAB.png" alt="image.png"></li>
</ul>
<p>都以两个 <code>consumer</code> 计算：<br>一条消息占用内存：<code>140+ 535*2 + 536*2 =2282byte</code><br>存储三天：<code>TPS * 86400 * 3</code>&#x3D;<code>TPS*259200</code> 条<br>总存储：<br><code>2282*TPS*259200≈ 百GB</code></p>
<p>根据我们的 <code>TPS</code> 计算，三天的大概会使用到 上百 G 的存储，这样首先就排除了 <code>Redis</code> 这种内存型数据库。</p>
<p>同样的换成 <code>MySQL</code> 存储也不划算，因为其实这些数据并不算那么重要。</p>
<p>做了几个技术选型都不太满意，不是资源开销太大就是没有相关的运维经验。</p>
<p>后面在领导的提醒下，我们使用的 <code>VictoriaMetrics</code> 开源了一个 <code>VictoriaLogs</code>，虽然当时的版本还是 <code>0.1.0</code>，使用过他们家 Metrics 的应该都会比较信任他们的技术能力，所以就调研了一下。</p>
<p>具体的信息可以查看官方文档：<br><a href="https://docs.victoriametrics.com/VictoriaLogs/">https://docs.victoriametrics.com/VictoriaLogs/</a></p>
<p><img src="https://s2.loli.net/2023/08/23/8LDNOGEC6Aslvzn.png" alt="image.png"></p>
<p>简单来说就是它也是一个日志存储数据库，并且有着极低的资源占有率，相对于 <code>ElasticSearch</code> 来说内存、磁盘、CPU 都是几十倍的下降率。</p>
<p><img src="https://s2.loli.net/2023/08/23/U9v1HCgRDtLsdif.png" alt="image.png"></p>
<p>通过官方的压测对比图会发现确实在各方面对 ES 都是碾压。<br><img src="https://s2.loli.net/2023/08/23/3Epxdzie8q5tVmY.png" alt="image.png"></p>
<p>官方宣传的第一反应是不能全信，于是我自己压测了一下，果然 CPU 内存 磁盘的占用都是极低的。</p>
<blockquote>
<p> 同时也发现运维部署确实简单，直接一个 helm install 就搞定，就是一个二进制文件，不会依赖第二个组件。</p>
</blockquote>
<p>按照刚才同样的数据存储三天，只需要不到 6G 的磁盘空间，我们生产环境已经平稳运行一段时间了。<br><img src="https://s2.loli.net/2023/08/23/kzrxA89EeNnQ7Ro.png" alt="image.png"><br>因为我们是批量写入数据的，所以在最高峰 20K 的 <code>TPS</code> 下 <code>CPU</code> 使用不到 0.1 核，内存使用最高 <code>120M</code>，这点确实是对 ES 碾压了。</p>
<p><img src="https://s2.loli.net/2023/08/23/wn2BduNX63PyYV9.png" alt="image.png"><br>磁盘占用也是非常少。</p>
<p>这些有点得归功于它有些的压缩、编解码算法，以及 <code>Golang</code>  带来的相对于 <code>Java</code> 的极低资源占用。</p>
<h1 id="还存在的问题"><a href="#还存在的问题" class="headerlink" title="还存在的问题"></a>还存在的问题</h1><p>如果一切都这么完美的话那 <code>VictoriaLogs</code>  确实也太变态了， 自然他也有一些不太完美的地方。</p>
<h2 id="分词功能有限"><a href="#分词功能有限" class="headerlink" title="分词功能有限"></a>分词功能有限</h2><p>首先第一个是分词功能有限，只能做简单的搜索，无法做到类似于 ES 的各种分词，插件当然也别想了。</p>
<h2 id="不支持集群"><a href="#不支持集群" class="headerlink" title="不支持集群"></a>不支持集群</h2><p>当前版本不支持集群部署，也就是无法横向扩展了；不过幸好他的的单机性能已经非常强了。</p>
<p>这也是目前阶段部署简单的原因。</p>
<h2 id="过期时间无法混用"><a href="#过期时间无法混用" class="headerlink" title="过期时间无法混用"></a>过期时间无法混用</h2><p><code>VictoriaLogs</code> 支持为数据配置过期时间自动删除，有点类似于 Redis，它会在后台启动一个协程定期判断数据是否过期，但只能对所有数据统一设置。</p>
<p>比如我想在 <code>VictoriaLogs</code> 中存放两种不同类型的数据，同时他们的过期删除时间也不相同；比如一个是三天删除，一个是三月后删除。</p>
<p>这样的需求目前是无法实现的，只能部署两个 <code>VictoriaLogs</code>.</p>
<h2 id="默认无法查询所有字段"><a href="#默认无法查询所有字段" class="headerlink" title="默认无法查询所有字段"></a>默认无法查询所有字段</h2><p><img src="https://s2.loli.net/2023/08/24/2Wk6VUXQoEYvZJ1.png" alt="image.png"></p>
<p>由于 <code>VictoriaLogs</code>  可以存储非结构化数据，默认情况下只能查询内置的三个字段，我们自定义的字段目前没法自动查询，需要我们手动指定。</p>
<p>这个倒不是致命问题，只是使用起来稍微麻烦一些；社区也有一些反馈，相信不久就会优化该功能。<br><img src="https://s2.loli.net/2023/08/24/XYxz8tTDmw6arf9.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/24/pgQCPsLvXfMc7nF.png" alt="image.png"></p>
<ul>
<li><a href="https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4780">https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4780</a></li>
<li><a href="https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4513">https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4513</a></li>
</ul>
<h2 id="没有官方-SDK"><a href="#没有官方-SDK" class="headerlink" title="没有官方 SDK"></a>没有官方 SDK</h2><p><img src="https://s2.loli.net/2023/08/24/bXPKRIy7Ojf1elE.png" alt="image.png"></p>
<p>这也是个有了更好的一个功能，目前只能根据 REST API 自己编写。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当前我们只用来存储 <code>Pulsar</code> 链路追踪数据，目前看来非常稳定，各方面资源占用极少；所以后续我们会陆续讲一些日志类型的数据迁移过来，比如审计日志啥的。</p>
<p>之后再逐步完善功能后，甚至可以将所有应用存放在 <code>ElasticSeach</code> 中的日志也迁移过来，这样确实能省下不少资源。</p>
<p>总得来说 <code>VictoriaLogs</code>  资源占用极少，如果只是拿来存储日志相关的数据，没有很强的分词需求那它将非常合适。</p>
<p>截止到目前最新版也才 <code>0.3.0</code> 还有很大的进步空间，有类似需求的可以持续关注。<br>#Blog #Vlogs #CloudNative </p>
]]></content>
      <categories>
        <category>VictoriaLogs</category>
      </categories>
      <tags>
        <tag>CloudNative</tag>
      </tags>
  </entry>
  <entry>
    <title>Github commit 签名+合并 Commit</title>
    <url>/2023/09/18/ob/git-tips-rebase/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/09/18/gCjw9hZx4Y6cPSn.png" alt="Github的一个奇技淫巧.png"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间给 <code>VictoriaLogs</code> 提交了一个 PR：<br><a href="https://github.com/VictoriaMetrics/VictoriaMetrics/pull/4934">https://github.com/VictoriaMetrics/VictoriaMetrics/pull/4934</a></p>
<p>本来一切都很顺利，只等合并了，但在临门一脚的时候社区维护人员问我可否给 <code>git</code> <code>commit</code> 加上签名。</p>
<blockquote>
<p>于是我就默默的调试到了凌晨四点😭</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/09/18/VXhjU9ypuKP1ZWg.png" alt="image.png"></p>
<span id="more"></span>
<p>以前我也没怎么注意过这个选项，经过 <code>Google</code> 后发现 <code>Idea</code> 在提交的时候可以自行设置。</p>
<p><img src="https://s2.loli.net/2023/09/18/QdTetRSNG5c3KVr.png" alt="image.png"><br>当我勾选了这个提交新的代码后，依然被告知没有正确的签名，这时我才发现理解错误了。</p>
<h1 id="为-GitHub-的提交签名"><a href="#为-GitHub-的提交签名" class="headerlink" title="为 GitHub 的提交签名"></a>为 GitHub 的提交签名</h1><p>结合这位社区大佬给的文档，他所需要的是每次提交的代码都是有签名的，类似于这样：<br><img src="https://s2.loli.net/2023/09/18/26vgVMZmNrPCkqo.png" alt="image.png"></p>
<p>如果我们想要 <code>GitHub</code> 现实 <code>Verified</code> 这个标签，那就需要对 <code>commit</code> 或者是打的 <code>tag</code> 进行签名。</p>
<p>而签名的方式有三种：<code>GPG</code>, <code>SSH</code>, <code>S/MIME</code>，这里我以 GPG 签名为例，整体流程如下：</p>
<p><img src="https://s2.loli.net/2023/09/18/HwDIlL94c51Uz3e.png" alt="image.png"></p>
<p>先在<a href="https://www.gnupg.org/download/">https://www.gnupg.org/download/</a>这里下载安装 GPG 的命令行程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpg --full-generate-key</span><br></pre></td></tr></table></figure>

<p>使用这个命令生成 key，之后会根据提示录入一些信息，包含你的 ID 和邮箱，建议都和 GitHub 的 ID 邮箱保持一致即可，然后一路回车完事。</p>
<p>之后可以使用这个命令查看刚才创建的 Key：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpg --list-secret-keys --keyid-format=long</span><br><span class="line">------------------------------------</span><br><span class="line">sec   4096R/3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]</span><br><span class="line">uid                          Hubot &lt;hubot@example.com&gt;</span><br><span class="line">ssb   4096R/4BB6D45482678BE3 2016-03-10</span><br></pre></td></tr></table></figure>

<p>我们需要将 <code>3AA5C34371567BD2</code> 这个 Key 的 ID 字符串复制，之后执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpg --armor --export 3AA5C34371567BD2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Prints the GPG key ID, <span class="keyword">in</span> ASCII armor format</span></span><br></pre></td></tr></table></figure>

<p>此时会打印出公钥，我们将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PGP PUBLIC KEY BLOCK-----</span><br><span class="line">-----END PGP PUBLIC KEY BLOCK-----</span><br></pre></td></tr></table></figure>
<p>这些数据复制到 GitHub 的个人设置页面：<br><img src="https://s2.loli.net/2023/09/18/zvMgJcqAnRQjYxG.png" alt="image.png"></p>
<p>此时还没完，如果我们直接提交代码的也不会有 <code>Verified</code> 的标签。</p>
<p><img src="https://s2.loli.net/2023/09/18/eST5f1Vad4x8Ou7.png" alt="image.png"></p>
<p>我们还需要打开 git 的 config 设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config commit.gpgsign true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局打开</span></span><br><span class="line">git config --global commit.gpgsign true</span><br><span class="line">git commit -S -m &quot;YOUR_COMMIT_MESSAGE&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>这样提交的 Commit 就会打上验证的标签了。<br><img src="https://s2.loli.net/2023/09/18/HKcvrfMozC9YEnx.png" alt="image.png"></p>
<blockquote>
<p>-S 的效果和在 idea 中选中 Sign-off 的效果一样。</p>
</blockquote>
<p>官方文档也有详细的步骤：<br><a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/about-commit-signature-verification">https://docs.github.com/en/authentication/managing-commit-signature-verification/about-commit-signature-verification</a></p>
<h1 id="Squash-合并提交"><a href="#Squash-合并提交" class="headerlink" title="Squash 合并提交"></a>Squash 合并提交</h1><p>不过在我这个 <code>PR</code> 的背景下还有一个步骤没有完成，就是我之前提交的 <code>Commit</code> 都没要验证，我需要将他们都合并为一个验证的 Commit 然后在强制推送上去，这样整个 <code>git log</code> 看起来才足够简洁。</p>
<p>最终效果如下，只有一个 Commit 存在。<br><img src="https://s2.loli.net/2023/09/18/1OzjkDwhdWuJS8n.png"></p>
<p>这时候就得需要 git rebase 出马了。</p>
<p><img src="https://s2.loli.net/2023/09/18/vaOPw3gQTtVSoxC.png" alt="image.png"><br>以刚才测试的这两个提交为例，我需要将他们合并为一个提交。</p>
<p>我们先使用这个命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~N</span><br><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure>
<p>N 就是我们需要合并几个提交，在我这里就是 2.</p>
<p><img src="https://s2.loli.net/2023/09/18/PN6nUE3BVu48TWF.png" alt="image.png"><br>我们需要将除了第一个 commit 之外的都修改为 s，也就是下面注释里的 <code>squash</code> 的简写（压缩的意思）。</p>
<p>这是一个 vim 的交互编辑模式，编辑完成之后保存退出。</p>
<blockquote>
<p>不会还有程序员不知道如何保存 vim 退出吧🐕。</p>
</blockquote>
<p>保存后又会弹出一个编辑页面，让我们填写这次压缩之后的提交记录，默认会帮我生成好，当然你也可以全部删掉后重写。</p>
<p><img src="https://s2.loli.net/2023/09/18/YCx5ablcrBmsdiD.png" alt="image.png"></p>
<p>我这里就直接使用它生成好的就可以了，依然还是保存退出。</p>
<p>最后再强行推送到我所在的分支即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin test-rebase -f</span><br></pre></td></tr></table></figure>

<p>在这个分支的提交页面也只会看到刚才强行推送的记录了，刚才的两个提交已经合并为这一个了。</p>
<p><img src="https://s2.loli.net/2023/09/18/ULO3kxgSYErPqle.png" alt="image.png"></p>
<h1 id="将修改提交到其他分支"><a href="#将修改提交到其他分支" class="headerlink" title="将修改提交到其他分支"></a>将修改提交到其他分支</h1><p>有时候线上出现问题需要马上修复的时候，我会不下意识的直接就开始改了，等真的提交代码被拒的时候才发现是在主分支上。</p>
<p>我觉得有类似需求的场景还不少，这时候就需要将当前分支的修改提交到一个新的分支上，总不能 revert 之后重新再写吧。</p>
<p>所以通常我的流程是这样的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个分支</span></span><br><span class="line">git branch newbranch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将当前分支的修改临时保存到暂缓区，同时回滚当前分支。</span></span><br><span class="line">git stash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到新的分支</span></span><br><span class="line">git checkout newbranch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从暂缓区中取出刚才的修改</span></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<p>这样之前分支的修改就会同步到新的分支上了，借着便在新的分支上继续开发了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>借着这个机会也了解了 <code>rebase</code> 的骚操作挺多的，不过我平时用的最多的还是 <code>merge</code>，这个倒没有好坏之分，只要同组的开发者都达成一致即可。</p>
<p>#Blog #Github #Git</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>rebase</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言史诗级更新-循环Bug修复</title>
    <url>/2023/09/24/ob/go-loop-fix/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/09/24/rU7IujkPWX1TRQM.png"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前两天 <code>Golang</code> 的官方博客更新了一篇文章：<a href="https://go.dev/blog/loopvar-preview">Fixing For Loops in Go 1.22</a></p>
<p>看这个标题的就是修复了 Go 循环的 bug，这真的是史诗级的更新；我身边接触到的大部分 Go 开发者都犯过这样的错误，包括我自己，所以前两年我也写过类似的博客：<br><a href="https://crossoverjie.top/2021/12/28/go/for-mistake/">简单的 for 循环也会踩的坑</a></p>
<span id="more"></span>

<p>先来简单回顾下使用使用 for 循环会碰到的问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">list := []*Demo&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;&#125;  </span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;  </span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">		fmt.Println(<span class="string">&quot;name=&quot;</span>+v.Name)  </span><br><span class="line">	&#125;()  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Demo <span class="keyword">struct</span> &#123;  </span><br><span class="line">	Name <span class="type">string</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预期的结果应该是打印 <code>a,b</code>，但实际打印的却是<code>b,b</code>。</p>
<p><img src="https://s2.loli.net/2023/09/24/I98GMk5efvNUDbT.png" alt="image.png"></p>
<p><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1619047">Let’s Encrypt: CAA Rechecking bug</a><br>类似的问题连 <code>mozilla</code> 团队也没能幸免，所以也确实是一个非常常见的问题，这样的写法符合大部分的开发者的直觉，毕竟其他语言这么使用也没有问题。</p>
<p>当然在现阶段要解决也很简单，要么就是在使用之前先复制一次，或者使用闭包传参：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复制</span></span><br><span class="line"> list := []*Demo&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;&#125;  </span><br><span class="line"> <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;  </span><br><span class="line">  temp:=v  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   fmt.Println(<span class="string">&quot;name=&quot;</span>+temp.Name)  </span><br><span class="line">  &#125;()  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"> list := []*Demo&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;&#125;  </span><br><span class="line"> <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(temp *Demo)</span></span> &#123;  </span><br><span class="line">   fmt.Println(<span class="string">&quot;name=&quot;</span>+temp.Name)  </span><br><span class="line">  &#125;(v)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>还好官方也意识到了这个问题：<br><img src="https://s2.loli.net/2023/09/24/6NTZSijCofypK54.png" alt="image.png"><br>所以在 1.22 中我们可以不用再写这个 <code>    v:=v</code>这个多余的复制语句了，也不会出现上面的问题。</p>
<p>我们在 1.21 中可以使用环境变量预览这个特性:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">❯ GOEXPERIMENT=loopvar <span class="keyword">go</span> test</span><br><span class="line">name=b</span><br><span class="line">name=a</span><br></pre></td></tr></table></figure>
<p>在 1.22 发布后建议大家都可以升级了，将这种恶心的 bug 扼杀在摇篮里。</p>
<p>1.22 后带来了一个好消息是今后少了一道面试题，坏消息是又新增了一个 1.22 版本带来了哪些变化的面试题😂</p>
<p>更多详情可以参看官方播客：<a href="https://go.dev/blog/loopvar-preview">https://go.dev/blog/loopvar-preview</a></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>loop</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s 入门到实战--部署应用到 k8s</title>
    <url>/2023/08/31/ob/k8s-0-start/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/09/04/ymUpcXZrxfNsT91.png" alt="k8s 入门到实战 01.png"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近这这段时间更新了一些 k8s 相关的博客和视频，也收到了一些反馈；大概分为这几类：</p>
<ul>
<li>公司已经经历过服务化改造了，但还未接触过云原生。</li>
<li>公司部分应用进行了云原生改造，但大部分工作是由基础架构和运维部门推动的，自己只是作为开发并不了解其中的细节，甚至 k8s 也接触不到。</li>
<li>还处于比较传统的以虚拟机部署的传统运维为主。</li>
</ul>
<p>其中以第二种占大多数，虽然公司进行了云原生改造，但似乎和纯业务研发同学来说没有太大关系，自己工作也没有什么变化。</p>
<p>恰好我之前正好从业务研发的角度转换到了基础架构部门，两个角色我都接触过，也帮助过一些业务研发了解公司的云原生架构；</p>
<p>为此所以我想系统性的带大家以<strong>研发</strong>的角度对 k8s 进行实践。</p>
<p>因为 k8s 部分功能其实是偏运维的，对研发来说优先级并不太高；<br>所以我不太会涉及一些 k8s 运维的知识点，比如安装、组件等模块；主要以我们日常开发会使用到的组件讲起。</p>
<span id="more"></span>

<h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul>
<li>部署应用到 k8s</li>
<li>跨服务调用</li>
<li>集群外部访问</li>
</ul>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><ul>
<li>如何使用配置</li>
<li>服务网格实战</li>
</ul>
<h2 id="运维你的应用"><a href="#运维你的应用" class="headerlink" title="运维你的应用"></a>运维你的应用</h2><ul>
<li>应用探针</li>
<li>滚动更新与回滚</li>
<li>优雅采集日志</li>
<li>应用可观测性<ul>
<li>指标可视化</li>
</ul>
</li>
</ul>
<h2 id="k8s-部署常见中间件"><a href="#k8s-部署常见中间件" class="headerlink" title="k8s 部署常见中间件"></a>k8s 部署常见中间件</h2><ul>
<li>helm 一键部署</li>
<li>编写 Operator 自动化应用生命周期</li>
</ul>
<p><img src="https://s2.loli.net/2023/09/02/BtYcF6jp8u3nzJs.png" alt="image.png"><br>这里我整理了一下目录，每个章节都有博客+视频配合观看，大家可以按照喜好选择。</p>
<p>因为还涉及到了视频，所以只能争取一周两更，在两个月内全部更新完毕。</p>
<p>根据我自己的经验，以上内容都掌握的话对 k8s 的掌握会更进一步。</p>
<h1 id="部署应用到-k8s"><a href="#部署应用到-k8s" class="headerlink" title="部署应用到 k8s"></a>部署应用到 k8s</h1><p>首先从第一章【部署应用到 k8s】开始，我会用 Go 写一个简单的 Web 应用，然后打包为一个 Docker 镜像，之后部署到 k8s 中，并完成其中的接口调用。</p>
<h2 id="编写应用"><a href="#编写应用" class="headerlink" title="编写应用"></a>编写应用</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   http.HandleFunc(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">      log.Println(<span class="string">&quot;ping&quot;</span>)  </span><br><span class="line">      fmt.Fprint(w, <span class="string">&quot;pong&quot;</span>)  </span><br><span class="line">   &#125;)  </span><br><span class="line">  </span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, <span class="literal">nil</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 应用非常简单就是提供了一个 <code>ping</code>  接口，然后返回了一个 <code>pong</code>.</p>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一阶段：编译 Go 程序  </span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.19</span> AS dependencies  </span><br><span class="line"><span class="keyword">ENV</span> GOPROXY=https://goproxy.cn,direct  </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/app  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> go.mod .  </span></span><br><span class="line"><span class="comment">#COPY ../../go.sum .  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=ssh go mod download  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 第二阶段：构建可执行文件  </span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.19</span> AS builder  </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/app  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .  </span></span><br><span class="line"><span class="comment">#COPY --from=dependencies /go/pkg /go/pkg  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 第三阶段：部署  </span></span><br><span class="line"><span class="keyword">FROM</span> debian:stable-slim  </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y curl  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /go/src/app/k8s-combat /go/bin/k8s-combat  </span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/go/bin:$&#123;PATH&#125;&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 启动 Go 程序  </span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;k8s-combat&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p> 之后编写了一个 <code>dockerfile</code> 用于构建 <code>docker</code> 镜像。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">docker:  </span></span><br><span class="line">   @echo <span class="string">&quot;Docker Build...&quot;</span>  </span><br><span class="line">   docker build . -t crossoverjie/k8s-combat:v1 &amp;&amp; docker image push crossoverjie/k8s-combat:v1</span><br></pre></td></tr></table></figure>

<p>使用 <code>make docker</code>  会在本地构建镜像并上传到 <code>dockerhub</code></p>
<h2 id="编写-deployment"><a href="#编写-deployment" class="headerlink" title="编写 deployment"></a>编写 deployment</h2><p>下一步便是整个过程中最重要的环节了，也是唯一和 k8s 打交道的地方，那就是编写 deployment。</p>
<iframe src="//player.bilibili.com/player.html?aid=702346697&bvid=BV1Cm4y1n7yG&cid=1235124452&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>在之前的视频《一分钟了解 k8s》中讲过常见的组件：<br><img src="https://s2.loli.net/2023/09/04/hrOUSVsmP2KkNlC.png" alt="image.png"></p>
<p>其中我们最常见的就是 deployment，通常用于部署无状态应用；现在还不太需要了解其他的组件，先看看 deployment 如何编写：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">  <span class="attr">template:</span>  </span><br><span class="line">    <span class="attr">metadata:</span>  </span><br><span class="line">      <span class="attr">labels:</span>  </span><br><span class="line">        <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">    <span class="attr">spec:</span>  </span><br><span class="line">      <span class="attr">containers:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">          <span class="attr">image:</span> <span class="string">crossoverjie/k8s-combat:v1</span>  </span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span>  </span><br><span class="line">          <span class="attr">resources:</span>  </span><br><span class="line">            <span class="attr">limits:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">300Mi</span>  </span><br><span class="line">            <span class="attr">requests:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;0.1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">30Mi</span></span><br></pre></td></tr></table></figure>

<p>开头两行的 <code>apiVersion</code>  和 <code>kind</code> 可以暂时不要关注，就理解为 deployment 的固定写法即可。</p>
<p>metadata：顾名思义就是定义元数据的地方，告诉 <code>Pod</code> 我们这个 <code>deployment</code> 叫什么名字，这里定义为：<code>k8s-combat</code></p>
<p>中间的：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat</span></span><br></pre></td></tr></table></figure>

<p>也很容易理解，就是给这个 <code>deployment</code> 打上标签，通常是将这个标签和其他的组件进行关联使用才有意义，不然就只是一个标签而已。</p>
<blockquote>
<p>标签是键值对的格式，key, value 都可以自定义。</p>
</blockquote>
<p>而这里的  <code>app: k8s-combat</code> 便是和下面的 spec 下的 selector 选择器匹配，表明都使用  <code>app: k8s-combat</code>  进行关联。</p>
<p>而 template 中所定义的标签也是为了让选择器和 template 中的定义的 Pod 进行关联。</p>
<blockquote>
<p>Pod 是 k8s 中相同功能容器的分组，一个 Pod 可以绑定多个容器，这里就只有我们应用容器一个了；后续在讲到 istio 和日志采集时便可以看到其他的容器。</p>
</blockquote>
<p>template 中定义的内容就很容易理解了，指定了我们的容器拉取地址，以及所占用的资源(<code>cpu/ memory</code>)。</p>
<p><code>replicas: 1</code>：表示只部署一个副本，也就是只有一个节点的意思。</p>
<h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><p>之后我们使用命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f deployment/deployment.yaml</span><br></pre></td></tr></table></figure>

<blockquote>
<p>生产环境中往往会使用云厂商所提供的 k8s 环境，我们本地可以使用 <a href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a> minikube 来模拟。</p>
</blockquote>
<p>就会应用这个 deployment 同时将容器部署到 k8s 中，之后使用:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 在后台 k8s 会根据我们填写的资源选择一个合适的节点，将当前这个 Pod 部署过去。</p>
</blockquote>
<p> 就会列出我们刚才部署的 Pod:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ kubectl get pod</span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">k8s-combat-57f794c59b-7k58n         1/1     Running   0          17h</span><br></pre></td></tr></table></figure>

<p>我们使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl exec -it k8s-combat-57f794c59b-7k58n  bash</span><br></pre></td></tr></table></figure>
<p>就会进入我们的容器，这个和使用 docker 类似。</p>
<p>之后执行 curl 命令便可以访问我们的接口了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@k8s-combat-57f794c59b-7k58n:/# curl http://127.0.0.1:8081/ping</span><br><span class="line">pong</span><br><span class="line">root@k8s-combat-57f794c59b-7k58n:/#</span><br></pre></td></tr></table></figure>

<p>这时候我们再开一个终端执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">❯ kubectl logs -f k8s-combat-57f794c59b-7k58n</span><br><span class="line">2023/09/03 09:28:07 ping</span><br></pre></td></tr></table></figure>
<p>便可以打印容器中的日志，当然前提是应用的日志是写入到了标准输出中。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是这一章节的主要内容，重点就是将我们应用程序员打包为 docker 镜像后上传到镜像仓库，再配置好 deployment 由 k8s 进行调度运行。</p>
<p>下一章主要会涉及服务内部的调用，感兴趣的朋友可以先关注起来。</p>
<p>相关的源码和 yaml 资源文件都存在这里：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p>
<p>#Blog #K8s </p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s入门到实战-使用Ingress</title>
    <url>/2023/09/15/ob/k8s-Ingress/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/09/14/Pe7DWCIS2UMKHQ8.png" alt="ingress.png"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前两章中我们将应用<a href="https://crossoverjie.top/2023/08/31/ob/k8s-0-start/">部署</a>到了 k8s 中，同时不同的服务之间也可以通过 <a href="https://crossoverjie.top/2023/09/05/ob/k8s-service/">service</a> 进行调用，现在还有一个步骤就是将我们的应用暴露到公网，并提供域名的访问。</p>
<p>这一步类似于我们以前配置 Nginx 和绑定域名，提供这个能力的服务在 k8s 中成为 Ingress。</p>
<p>通过这个描述其实也能看出 Ingress 是偏运维的工作，但也不妨碍我们作为研发去了解这部分的内容；了解整个系统是如何运转的也是研发应该掌握的技能。</p>
<span id="more"></span>
<h1 id="安装-Ingress-控制器"><a href="#安装-Ingress-控制器" class="headerlink" title="安装 Ingress 控制器"></a>安装 Ingress 控制器</h1><p>在正式使用 Ingress 之前需要给 k8s 安装一个 Ingress 控制器，我们这里安装官方提供的 Ingress-nginx 控制器。</p>
<p>当然还有社区或者企业提供的各种控制器：<br><img src="https://s2.loli.net/2023/09/14/i1ebXQNUjxPkLEZ.png" alt="image.png"></p>
<p>有两种安装方式: helm 或者是直接 apply 一个资源文件。</p>
<p>关于 <code>helm</code> 我们会在后面的章节单独讲解。</p>
<p>这里就直接使用资源文件安装即可，我已经上传到 GitHub 可以在这里访问：<br><a href="https://github.com/crossoverJie/k8s-combat/blob/main/deployment/ingress-nginx.yaml">https://github.com/crossoverJie/k8s-combat/blob/main/deployment/ingress-nginx.yaml</a></p>
<p>其实这个文件也是直接从官方提供的复制过来的，也可以直接使用这个路径进行安装：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/cloud/deploy.yaml</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>yaml 文件的内容是一样的。</p>
</blockquote>
<p>不过要注意安装之后可能容器状态一直处于 Pending 状态，查看容器的事件时会发现镜像拉取失败。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k describe pod ingress-nginx-controller-7cdfb9988c-lbcst -n ingress-nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>describe 是一个用于查看 k8s 对象详细信息的命令。</p>
</blockquote>
<p>在刚才那份 yaml 文件中可以看到有几个镜像需要拉取，我们可以先在本地手动拉取镜像：<br><img src="https://s2.loli.net/2023/09/14/3IsRe2QWcmjTY41.png" alt="image.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull registry.k8s.io/ingress-nginx/controller:v1.8.2</span><br></pre></td></tr></table></figure>

<p>如果依然无法拉取，可以尝试配置几个国内镜像源镜像拉取：</p>
<p><img src="https://s2.loli.net/2023/09/14/uTNDACSWdPp7BVt.png" alt="image.png"></p>
<blockquote>
<p>我这里使用的 docker-desktop 自带的 k8s，推荐读者朋友也使用这个工具。</p>
</blockquote>
<h1 id="创建-Ingress"><a href="#创建-Ingress" class="headerlink" title="创建 Ingress"></a>创建 Ingress</h1><p>使用刚才的 yaml 安装成功之后会在 <code>ingress-nginx</code> 命名空间下创建一个 Pod，通过 get 命令查看状态为 Running 即为安装成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">k get pod -n ingress-nginx</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS      AGE</span><br><span class="line">ingress-nginx-controller-7cdf   1/1     Running   2 (35h ago)   3d</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Namespace 也是 k8s 内置的一个对象，可以简单理解为对资源进行分组管理，我们通常可以使用它来区分各个不同的环境，比如 dev&#x2F;test&#x2F;prod 等，不同命名空间下的资源不会互相干扰，且相互独立。</p>
</blockquote>
<p>之后便可以创建 Ingress 资源了：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-ingress</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span>  </span><br><span class="line">  <span class="attr">rules:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.service1.io</span>  </span><br><span class="line">      <span class="attr">http:</span>  </span><br><span class="line">        <span class="attr">paths:</span>  </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">backend:</span>  </span><br><span class="line">              <span class="attr">service:</span>  </span><br><span class="line">                <span class="attr">name:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line">                <span class="attr">port:</span>  </span><br><span class="line">                  <span class="attr">number:</span> <span class="number">8081</span>  </span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span>  </span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.service2.io</span>  </span><br><span class="line">      <span class="attr">http:</span>  </span><br><span class="line">        <span class="attr">paths:</span>  </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">backend:</span>  </span><br><span class="line">              <span class="attr">service:</span>  </span><br><span class="line">                <span class="attr">name:</span> <span class="string">k8s-combat-service-2</span>  </span><br><span class="line">                <span class="attr">port:</span>  </span><br><span class="line">                  <span class="attr">number:</span> <span class="number">8081</span>  </span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span>  </span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br></pre></td></tr></table></figure>

<p>看这个内容也很容易理解，创建了一个 <code>Ingress</code> 的对象，其中的重点就是这里的规则是如何定义的。</p>
<blockquote>
<p>在 k8s 中今后还会接触到各种不同的 Kind</p>
</blockquote>
<p>这里的 <code>ingressClassName: nginx</code>   也是在刚开始安装的控制器里定义的名字，由这个资源定义。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">IngressClass</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app.kubernetes.io/component:</span> <span class="string">controller</span>  </span><br><span class="line">    <span class="attr">app.kubernetes.io/instance:</span> <span class="string">ingress-nginx</span>  </span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span>  </span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span>  </span><br><span class="line">    <span class="attr">app.kubernetes.io/version:</span> <span class="number">1.8</span><span class="number">.2</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<p>咱们这个规则很简单，就是将两个不同的域名路由到两个不同的 service。</p>
<blockquote>
<p>这里为了方便测试又创建了一个 <code>k8s-combat-service-2</code> 的 service，和 <code>k8s-combat-service</code> 是一样的，只是改了个名字而已。</p>
</blockquote>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>也是为了方便测试，我在应用镜像中新增了一个接口，用于返回当前 Pod 的 hostname。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">   name, _ := os.Hostname()  </span><br><span class="line">   fmt.Fprint(w, name)  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>由于我实际并没有 <code>www.service1.io/www.service2.io</code> 这两个域名，所以只能在本地配置 host 进行模拟。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.0.0.37 www.service1.io</span><br><span class="line">10.0.0.37 www.service2.io</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我测试所使用的 k8s 部署在我家里一台限制的 Mac 上，所以这里的 IP 它的地址。</p>
</blockquote>
<p>当我们反复请求两次这个接口，会拿到两个不同的 hostname，也就是将我们的请求轮训负载到了这两个 service 所代理的两个 Pod 中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ curl http://www.service1.io/</span><br><span class="line"><span class="meta prompt_">k8s-combat-service-79c5579587-b6nlj%</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">❯ curl http://www.service1.io/</span></span><br><span class="line"><span class="meta prompt_">k8s-combat-service-79c5579587-bk7nw%</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">❯ curl http://www.service2.io/</span></span><br><span class="line"><span class="meta prompt_">k8s-combat-service-2-7bbf56b4d9-dkj9b%</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">❯ curl http://www.service2.io/</span></span><br><span class="line">k8s-combat-service-2-7bbf56b4d9-t5l4g</span><br></pre></td></tr></table></figure>

<p>我们也可以直接使用 describe 查看我们的 ingress 定义以及路由规则：<br><img src="https://s2.loli.net/2023/09/14/pgZzVb1L4aQTMwn.png" alt="image.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">k describe ingress k8s-combat-ingress</span></span><br><span class="line">Name:             k8s-combat-ingress</span><br><span class="line">Labels:           &lt;none&gt;</span><br><span class="line">Namespace:        default</span><br><span class="line">Address:          localhost</span><br><span class="line">Ingress Class:    nginx</span><br><span class="line">Default backend:  &lt;default&gt;</span><br><span class="line">Rules:</span><br><span class="line">  Host             Path  Backends</span><br><span class="line">  ----             ----  --------</span><br><span class="line">  www.service1.io</span><br><span class="line">                   /   k8s-combat-service:8081 (10.1.0.65:8081,10.1.0.67:8081)</span><br><span class="line">  www.service2.io</span><br><span class="line">                   /   k8s-combat-service-2:8081 (10.1.0.63:8081,10.1.0.64:8081)</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>如果我们手动新增一个域名解析：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10.0.0.37 www.service3.io</span><br><span class="line">❯ curl http://www.service3.io/</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>会直接 404，这是因为没有找到这个域名的规则。</p>
<h1 id="访问原理"><a href="#访问原理" class="headerlink" title="访问原理"></a>访问原理</h1><p><img src="https://s2.loli.net/2023/09/14/9JTfp6GP24VmzAK.png" alt="image.png"><br>整个的请求路径如上图所示，其实我们的 Ingress 本质上也是一个 service（所以它也可以启动多个副本来进行负载），只是他的类型是 <code>LoadBalancer</code>，通常这种类型的 service 会由云厂商绑定一个外部 IP，这样就可以通过这个外部 IP 访问 Ingress 了。</p>
<blockquote>
<p>而我们应用的 service 是 ClusterIP，只能在应用内部访问</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/09/14/Bu67SlMLak1hirc.png" alt="image.png"></p>
<p>通过 service 的信息也可以看到，我们 ingress 的 service 绑定的外部 IP 是 <code>localhost</code>（本地的原因）</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Ingress 通常是充当网关的作用，后续我们在使用 Istio 时，也可以使用 Istio 所提供的控制器来替换掉 Ingress-nginx，可以更方便的管理内外网流量。</p>
<p>本文的所有源码在这里可以访问：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>Ingress</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s入门到实战-应用配置</title>
    <url>/2023/09/26/ob/k8s-configmap/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/09/26/b9N2AufHMpqWRKs.png" alt="ConfigMap.png"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在前面<a href="https://crossoverjie.top/categories/k8s/">三节中</a>已经讲到如何将我们的应用部署到 k8s 集群并提供对外访问的能力，x现在可以满足基本的应用开发需求了。</p>
<p>现在我们需要更进一步，使用 k8s 提供的一些其他对象来标准化我的应用开发。<br>首先就是 <code>ConfigMap</code>，从它的名字也可以看出这是用于管理配置的对象。</p>
<span id="more"></span>
<h1 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h1><p>不管我们之前是做 <code>Java</code>、<code>Go</code> 还是 <code>Python</code> 开发都会使用到配置文件，而 <code>ConfigMap</code> 的作用可以将我们原本写在配置文件里的内容转存到 <code>k8s</code> 中，然后和我们的 <code>Container</code> 进行绑定。</p>
<h2 id="存储到环境变量"><a href="#存储到环境变量" class="headerlink" title="存储到环境变量"></a>存储到环境变量</h2><p>绑定的第一种方式就是将配置直接写入到环境变量，这里我先定义一个 <code>ConfigMap</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-configmap</span>  </span><br><span class="line"><span class="attr">data:</span>  </span><br><span class="line">  <span class="attr">PG_URL:</span> <span class="string">&quot;postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable&quot;</span></span><br></pre></td></tr></table></figure>

<p>重点是 <code>data</code> 部分，存储的是一个 <code>KV</code> 结构的数据，这里存储的是一个数据库连接。</p>
<blockquote>
<p>需要注意，KV 的大小不能超过 1MB</p>
</blockquote>
<p>接着可以在容器定义中绑定这个 <code>ConfigMap</code> 的所有 <code>KV</code> 到容器的环境变量：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Define all the ConfigMap&#x27;s data as container environment variables </span></span><br><span class="line"><span class="attr">envFrom:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">configMapRef:</span>  </span><br><span class="line">      <span class="attr">name:</span> <span class="string">k8s-combat-configmap</span></span><br></pre></td></tr></table></figure>

<p>我将 <code>ConfigMap</code> 的定义也放在了同一个 <a href="https://github.com/crossoverJie/k8s-combat/blob/main/deployment/deployment.yaml">deployment</a> 中，直接 apply:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ k apply -f deployment/deployment.yaml</span><br><span class="line">deployment.apps/k8s-combat created</span><br><span class="line">configmap/k8s-combat-configmap created</span><br></pre></td></tr></table></figure>

<p>此时 <code>ConfigMap</code> 也会被创建，我们可以使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ k get configmap</span><br><span class="line">NAME                   DATA   AGE</span><br><span class="line">k8s-combat-configmap   1      3m17s</span><br><span class="line"></span><br><span class="line">❯ k describe configmap k8s-combat-configmap</span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">PG_URL:</span><br><span class="line">----</span><br><span class="line">postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable</span><br></pre></td></tr></table></figure>
<p>拿到刚才声明的配置信息。</p>
<hr>
<p>同时我在代码中也读取了这个环境变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">   name, _ := os.Hostname()  </span><br><span class="line">   url := os.Getenv(<span class="string">&quot;PG_URL&quot;</span>)   </span><br><span class="line">   fmt.Fprint(w, fmt.Sprintf(<span class="string">&quot;%s-%s&quot;</span>, name, url))  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>访问这个接口便能拿到这个环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@k8s-combat-7b987bb496-pqt9s:/# curl http://127.0.0.1:8081</span><br><span class="line">k8s-combat-7b987bb496-pqt9s-postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable</span><br><span class="line"></span><br><span class="line">root@k8s-combat-7b987bb496-pqt9s:/# echo $PG_URL</span><br><span class="line">postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable</span><br></pre></td></tr></table></figure>

<h2 id="存储到文件"><a href="#存储到文件" class="headerlink" title="存储到文件"></a>存储到文件</h2><p>有些时候我们也需要将这些配置存储到一个文件中，比如在 Java 中可以使用 <code>spring</code> 读取，<code>Go</code> 也可以使用 <code>configor</code> 这些第三方库来读取，所有配置都在一个文件中也更方便维护。</p>
<p><img src="https://s2.loli.net/2023/09/26/g2IhktH7iwWb8LT.png" alt="image.png"><br>在 <code>ConfigMap</code> 中新增了一个 <code>key:APP</code> 存放了一个 <code>yaml</code> 格式的数据，然后在容器中使用 <code>volumes</code> 和 <code>volumeMounts</code> 将数据挂载到容器中的指定路径<code>/go/bin/app.yaml</code></p>
<p>apply 之后我们可以在容器中查看这个文件是否存在：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@k8s-combat-7b987bb496-pqt9s:/# cat /go/bin/app.yaml</span><br><span class="line">name: k8s-combat</span><br><span class="line">pulsar:</span><br><span class="line">  url: &quot;pulsar://localhost:6650&quot;</span><br><span class="line">  token: &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<p>配置已经成功挂载到了这个路径，我们便可以在代码中读取这些数据。</p>
<h1 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h1><p>可以看到 <code>ConfigMap</code> 中是明文存储数据的；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k describe configmap k8s-combat-configmap</span><br></pre></td></tr></table></figure>
<p>可以直接查看。</p>
<p>对一些敏感数据就不够用了，这时我们可以使用 <code>Secret</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-secret</span>  </span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span>  </span><br><span class="line"><span class="attr">data:</span>  </span><br><span class="line">  <span class="attr">PWD:</span> <span class="string">YWJjCg==</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">env:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PG_PWD</span>  </span><br><span class="line">    <span class="attr">valueFrom:</span>  </span><br><span class="line">      <span class="attr">secretKeyRef:</span>  </span><br><span class="line">        <span class="attr">name:</span> <span class="string">k8s-combat-secret</span>  </span><br><span class="line">        <span class="attr">key:</span> <span class="string">PWD</span></span><br></pre></td></tr></table></figure>

<p>这里我新增了一个 <code>Secret</code> 用于存储密码，并在 <code>container</code> 中也将这个 <code>key</code> 写入到环境变量中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ echo &#x27;abc&#x27; | base64</span><br><span class="line">YWJjCg==</span><br></pre></td></tr></table></figure>
<p><code>Secret</code> 中的数据需要使用 <code>base64</code> 进行编码，所以我这里存储的是 abc.</p>
<p>apply 之后我们再查看这个 <code>Secret</code> 是不能直接查看原始数据的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ k describe secret k8s-combat-secret</span><br><span class="line">Name:         k8s-combat-secret</span><br><span class="line">Type:  Opaque</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">PWD:  4 bytes</span><br></pre></td></tr></table></figure>

<p><code>Secret</code> 相比 <code>ConfigMap</code> 多了一个 <code>Type</code> 选项。<br><img src="https://s2.loli.net/2023/09/26/G25TRcSzCbIVDQ3.png"></p>
<p>我们现阶段在应用中用的最多的就是这里的 <code>Opaque</code>，其他的暂时还用不上。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在实际开发过程中研发人员基本上是不会直接接触 <code>ConfigMap</code>，一般会给开发者在管理台提供维护配置的页面进行 CRUD。</p>
<p>由于 <code>ConfigMap</code> 依赖于 k8s 与我们应用的语言无关，所以一些高级特性，比如实时更新就无法实现，每次修改后都得重启应用才能生效。</p>
<p>类似于 Java 中常见的配置中心：<code>Apollo,Nacos</code> 使用上会有不小的区别，但这些是应用语言强绑定的，如果业务对这些配置中心特性有强烈需求的话也是可以使用的。</p>
<p>但如果团队本身就是多语言研发，想要降低运维复杂度 <code>ConfigMap</code> 还是不二的选择。</p>
<p>下一章节会更新大家都很感兴趣的服务网格 <code>Istio</code>，感兴趣的朋友多多点赞转发🙏🏻。</p>
<p>本文的所有源码和资源文件在这里可以访问：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>ConfigMap</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s 常见面试题 01</title>
    <url>/2023/08/17/ob/k8s-question-01/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/08/17/hnWciw54ml6oPdg.jpg"></p>
<p>前段时间在这个视频中分享了 <a href="https://github.com/bregman-arie/devops-exercises">https://github.com/bregman-arie/devops-exercises</a> 这个知识仓库。</p>
<iframe src="//player.bilibili.com/player.html?aid=532004472&bvid=BV1Wu411n7U7&cid=1227759877&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>这次继续分享里面的内容，本次主要以 k8s 相关的问题为主。</p>
<span id="more"></span>

<h2 id="k8s-是什么，为什么企业选择使用它"><a href="#k8s-是什么，为什么企业选择使用它" class="headerlink" title="k8s 是什么，为什么企业选择使用它"></a>k8s 是什么，为什么企业选择使用它</h2><p>k8s 是一个开源应用，给用户提供了管理、部署、扩展容器的能力，以下几个例子更容易理解：</p>
<ul>
<li>你可以将容器运行在不同的机器或节点中，并且可以将一些变化同步给这些容器，简单来说我们只需要编写 <code>yaml</code> 文件，告诉 <code>k8s</code> 我的预期是什么，其中同步变化的过程全部都交给 k8s 去完成。<blockquote>
<p>其实就是我们常说的声明式 API</p>
</blockquote>
</li>
<li>第二个特点刚才已经提到了，它可以帮我们一键管理多个容器，同步所有的变更。</li>
<li>可以根据当前的负载调整应用的副本数，负载高就新创建几个应用实例，低就降低几个，这个可以手动或自动完成。</li>
</ul>
<h2 id="什么时候使用或者不使用-k8s"><a href="#什么时候使用或者不使用-k8s" class="headerlink" title="什么时候使用或者不使用 k8s"></a>什么时候使用或者不使用 k8s</h2><ul>
<li>如果主要还是使用物理机这种低级别的基础设施的话，不太建议使用 <code>k8s</code>，这种情况通常是比较传统的业务，没有必要使用 <code>k8s</code>。</li>
<li>第二种情况是如果是小团队，或者容器规模较小时也不建议使用，除非你想使用 k8s 的滚动发布和自扩容能力，<blockquote>
<p>不过这些功能运维自己写工具也能实现。</p>
</blockquote>
</li>
</ul>
<h2 id="k8s-有哪些特性"><a href="#k8s-有哪些特性" class="headerlink" title="k8s 有哪些特性"></a>k8s 有哪些特性</h2><ul>
<li>是自我修复，<code>k8s</code> 对容器有着健康检测，比如使用启动探针、存活探针等，或者是容器 <code>OOM</code> 后也会重启应用尝试修复。</li>
<li>自带负载均衡，使用 <code>service</code> 可以将流量自动负载到后续 Pod 中，如果 Pod 提供的是 http 服务这个够用了，但如果是 grpc 这样的长链接，就需要使用 istio 这类服务网格，他可以识别出协议类型，从而做到请求级别的负载均衡。</li>
<li><code>Operator</code> 自动运维能力：k8s 可以根据应用的运行情况自动调整当前集群的 Pod 数量、存储等，拿 <code>Pulsar</code> 举例，当流量激增后自动新增 <code>broker</code>，磁盘不足时自动扩容等。</li>
<li>滚动更新能力：当我们发版或者是回滚版本的时候，k8s 会等待新的容器启动之后才会将流量切回来，同时逐步停止老的实例。</li>
<li>水平扩展能力：可以灵活的新增或者是减少副本的数量，当然也可以自动控制。</li>
<li>数据加密：使用 <code>secret</code> 可以保存一些敏感的配置或者文件。</li>
</ul>
<h2 id="k8s-有着哪些对象"><a href="#k8s-有着哪些对象" class="headerlink" title="k8s 有着哪些对象"></a>k8s 有着哪些对象</h2><p>这个就是考察我们对 <code>k8s</code> 是否是熟悉了，常用的有：</p>
<ul>
<li>Pod</li>
<li>Service</li>
<li>ReplicationController</li>
<li>DaemonSet</li>
<li>namespace</li>
<li>ConfigMap<br>这个其实知道没有太多作用，主要还是得知道在不同场景如何使用不同的组件。</li>
</ul>
<h2 id="哪些字段是必须的"><a href="#哪些字段是必须的" class="headerlink" title="哪些字段是必须的"></a>哪些字段是必须的</h2><p>这个问题我也觉得意义不大，只要写过 <code>yaml</code> 就会知道了，<code>metadata, kind, apiVersion</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">app</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app</span></span><br></pre></td></tr></table></figure>

<h2 id="kubectl-是什么"><a href="#kubectl-是什么" class="headerlink" title="kubectl 是什么"></a>kubectl 是什么</h2><p>其实就是一个 k8s 的 命令行客户端。</p>
<h2 id="当你部署应用的时候哪些对象用的比较多"><a href="#当你部署应用的时候哪些对象用的比较多" class="headerlink" title="当你部署应用的时候哪些对象用的比较多"></a>当你部署应用的时候哪些对象用的比较多</h2><ul>
<li>第一个肯定是 <code>deployment</code>，这应该是最常见的部署方式。</li>
<li><code>service</code>: 可以将流量负载到 Pod 中。</li>
<li><code>Ingress</code>: 如果需要从集群外访问 Pod 就得需要 <code>Ingress</code> 然后 配合域名访问。</li>
</ul>
<h2 id="为什么没有-k-get-containers-这个命令"><a href="#为什么没有-k-get-containers-这个命令" class="headerlink" title="为什么没有 k get containers 这个命令"></a>为什么没有 <code>k get containers</code> 这个命令</h2><p>这个问题主要是看对 <code>Pod</code> 的理解，因为在 <code>k8s</code> 中 <code>Pod</code> 就是最小的单位了，如果想要访问容器可以在 Pod 中访问。</p>
<p>我们可以加上 <code>-c</code> 参数进入具体的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl exec -it app -c istio-proxy</span><br></pre></td></tr></table></figure>

<h2 id="你认为使用使用-k8s-的最佳实践是什么"><a href="#你认为使用使用-k8s-的最佳实践是什么" class="headerlink" title="你认为使用使用 k8s 的最佳实践是什么"></a>你认为使用使用 k8s 的最佳实践是什么</h2><p>这个主要是看日常使用时有没有遇到什么坑了：</p>
<ul>
<li>第一个就是要验证 <code>yaml</code> 内容是否正确，这个确实很重要，一旦执行错了后果很严重，比如使用 helm 的时候最好岂容 <code>dry-run</code> 和 <code>debug</code>，先看看生成的 <code>yaml</code> 是否是预期想要的。<blockquote>
<p>helm upgrade app –dry-run –debug</p>
</blockquote>
</li>
<li>第二个限制资源的使用，比如 CPU 和 内存，这个也很重要，如果不设置一旦应用出现 bug 可能导致整个 k8s 集群都受到影响。</li>
<li>为 Pod，deployment 指定标签，用于分组。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 资源限制</span></span><br><span class="line"><span class="attr">resources:</span>  </span><br><span class="line">  <span class="attr">limits:</span>  </span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">200m</span>  </span><br><span class="line">    <span class="attr">memory:</span> <span class="string">200Mi</span>  </span><br><span class="line">  <span class="attr">requests:</span>  </span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">100m</span>  </span><br><span class="line">    <span class="attr">memory:</span> <span class="string">100Mi</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考来源：<a href="https://github.com/bregman-arie/devops-exercises/blob/master/topics/kubernetes/README.md#kubernetes-101">https://github.com/bregman-arie/devops-exercises/blob/master/topics/kubernetes/README.md#kubernetes-101</a></p>
</blockquote>
<p>后续部分内容也有出视频版，强烈建议大家关注我的 B 站或者是视频号：<br><img src="https://s2.loli.net/2023/08/17/joO3wpCAEMtY2yW.jpg" alt="image.png"><br><img src="https://s2.loli.net/2023/08/17/2gcNDC4M3x91Sbh.jpg" alt="image.png"></p>
<p>#Blog #K8s </p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s入门到实战--跨服务调用</title>
    <url>/2023/09/05/ob/k8s-service/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/09/05/GbZ1vKQNHY32wzD.png" alt="service.png"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在做传统业务开发的时候，当我们的服务提供方有多个实例时，往往我们需要将对方的服务列表保存在本地，然后采用一定的算法进行调用；当服务提供方的列表变化时还得及时通知调用方。</p>
<span id="more"></span>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">student:</span>  </span><br><span class="line">   <span class="attr">url:</span>     </span><br><span class="line">   <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span><span class="string">:8081</span>     </span><br><span class="line">   <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.2</span><span class="string">:8081</span></span><br></pre></td></tr></table></figure>

<p>这样自然是对双方都带来不少的负担，所以后续推出的服务调用框架都会想办法解决这个问题。</p>
<p>以 <code>spring cloud</code> 为例：<br><img src="https://s2.loli.net/2023/09/06/IW1jaidQ25Xk9u4.png" alt="image.png"></p>
<p>服务提供方会向一个服务注册中心注册自己的服务（名称、IP等信息），客户端每次调用的时候会向服务注册中心获取一个节点信息，然后发起调用。</p>
<p>但当我们切换到 <code>k8s</code> 后，这些基础设施都交给了 <code>k8s</code> 处理了，所以 <code>k8s</code> 自然得有一个组件来解决服务注册和调用的问题。</p>
<p>也就是我们今天重点介绍的 <code>service</code>。</p>
<h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p>在介绍 <code>service</code> 之前我先调整了源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   http.HandleFunc(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">      name, _ := os.Hostname()  </span><br><span class="line">      log.Printf(<span class="string">&quot;%s ping&quot;</span>, name)  </span><br><span class="line">      fmt.Fprint(w, <span class="string">&quot;pong&quot;</span>)  </span><br><span class="line">   &#125;)  </span><br><span class="line">   http.HandleFunc(<span class="string">&quot;/service&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">      resp, err := http.Get(<span class="string">&quot;http://k8s-combat-service:8081/ping&quot;</span>)  </span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         log.Println(err)  </span><br><span class="line">         fmt.Fprint(w, err)  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">      fmt.Fprint(w, resp.Status)  </span><br><span class="line">   &#125;)  </span><br><span class="line">  </span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, <span class="literal">nil</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增了一个 <code>/service</code> 的接口，这个接口会通过 service 的方式调用服务提供者的服务，然后重新打包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make docker</span><br></pre></td></tr></table></figure>

<p>同时也新增了一个 <code>deployment-service.yaml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat-service</span> <span class="comment"># 通过标签选择关联  </span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line">  <span class="attr">template:</span>  </span><br><span class="line">    <span class="attr">metadata:</span>  </span><br><span class="line">      <span class="attr">labels:</span>  </span><br><span class="line">        <span class="attr">app:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line">    <span class="attr">spec:</span>  </span><br><span class="line">      <span class="attr">containers:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line">          <span class="attr">image:</span> <span class="string">crossoverjie/k8s-combat:v1</span>  </span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span>  </span><br><span class="line">          <span class="attr">resources:</span>  </span><br><span class="line">            <span class="attr">limits:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">100Mi</span>  </span><br><span class="line">            <span class="attr">requests:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;0.1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">10Mi</span>  </span><br><span class="line"><span class="meta">---  </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat-service</span> <span class="comment"># 通过标签选择关联  </span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span>  </span><br><span class="line">  <span class="attr">ports:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8081</span>        <span class="comment"># 本 Service 的端口  </span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8081</span>  <span class="comment"># 容器端口  </span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">app</span></span><br></pre></td></tr></table></figure>

<p>使用相同的镜像部署一个新的 deployment，名称为 <code>k8s-combat-service</code>，重点是新增了一个<code>kind: Service</code> 的对象。</p>
<p>这个就是用于声明 <code>service</code> 的组件，在这个组件中也是使用 <code>selector</code> 标签和 <code>deployment</code> 进行了关联。</p>
<p>也就是说这个 <code>service</code> 用于服务于名称等于 <code>k8s-combat-service</code> 的 <code>deployment</code>。</p>
<p>下面的两个端口也很好理解，一个是代理的端口， 另一个是  service 自身提供出去的端口。</p>
<p>至于 <code>type: ClusterIP</code> 是用于声明不同类型的 <code>service</code>，除此之外的类型还有：</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport"><code>NodePort</code></a></li>
<li><a href="https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer"><code>LoadBalancer</code></a></li>
<li><a href="https://kubernetes.io/docs/concepts/services-networking/service/#externalname"><code>ExternalName</code></a><br>等类型，默认是 <code>ClusterIP</code>，现在不用纠结这几种类型的作用，后续我们在讲到 <code>Ingress</code> 的时候会具体介绍。</li>
</ul>
<h2 id="负载测试"><a href="#负载测试" class="headerlink" title="负载测试"></a>负载测试</h2><p>我们先分别将这两个 <code>deployment</code> 部署好：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k apply -f deployment/deployment.yaml</span><br><span class="line">k apply -f deployment/deployment-service.yaml</span><br><span class="line"></span><br><span class="line">❯ k get pod</span><br><span class="line">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">k8s-combat-7867bfb596-67p5m           1/1     Running   0          3h22m</span><br><span class="line">k8s-combat-service-5b77f59bf7-zpqwt   1/1     Running   0          3h22m</span><br></pre></td></tr></table></figure>

<p>由于我新增了一个 <code>/service</code> 的接口，用于在 <code>k8s-combat</code> 中通过 <code>service</code> 调用 <code>k8s-combat-service</code> 的接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://k8s-combat-service:8081/ping&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>其中 <code>k8s-combat-service</code> 服务的域名就是他的服务名称。</p>
<blockquote>
<p>如果是跨 namespace 调用时，需要指定一个完整名称，在后续的章节会演示。</p>
</blockquote>
<p>我们整个的调用流程如下：<br><img src="https://s2.loli.net/2023/09/06/i12pR3DjC6wnIXQ.png" alt="image.png"></p>
<p>相信大家也看得出来相对于 <code>spring cloud</code> 这类微服务框架提供的客户端负载方式，<code>service</code> 是一种服务端负载，有点类似于 <code>Nginx</code> 的反向代理。</p>
<p>为了更直观的验证这个流程，此时我将 <code>k8s-combat-service</code> 的副本数增加到 2：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>只需要再次执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ k apply -f deployment/deployment-service.yaml</span><br><span class="line">deployment.apps/k8s-combat-service configured</span><br><span class="line">service/k8s-combat-service unchanged</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/09/06/ZC8UrjEz6ia1Qgo.png" alt="image.png"></p>
<blockquote>
<p>不管我们对 <code>deployment</code> 的做了什么变更，都只需要 <code>apply</code> 这个 <code>yaml</code>  文件即可， k8s 会自动将当前的 <code>deployment</code> 调整为我们预期的状态（比如这里的副本数量增加为 2）；这也就是 <code>k8s</code> 中常说的<strong>声明式 API</strong>。</p>
</blockquote>
<p>可以看到此时 <code>k8s-combat-service</code> 的副本数已经变为两个了。<br>如果我们此时查看这个 <code>service</code> 的描述时：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ k describe svc k8s-combat-service |grep Endpoints</span><br><span class="line">Endpoints:         192.168.130.133:8081,192.168.130.29:8081</span><br></pre></td></tr></table></figure>
<p>会发现它已经代理了这两个 <code>Pod</code> 的 IP。</p>
<p><img src="https://s2.loli.net/2023/09/06/HbjyEcnaeCK6uMJ.png" alt="image.png"><br>此时我进入了 <code>k8s-combat-7867bfb596-67p5m</code> 的容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k exec -it k8s-combat-7867bfb596-67p5m bash</span><br><span class="line">curl http://127.0.0.1:8081/service</span><br></pre></td></tr></table></figure>

<p>并执行两次 <code>/service</code> 接口，发现请求会轮训进入 <code>k8s-combat-service</code> 的代理的 IP 中。</p>
<p>由于 <code>k8s service</code> 是基于 <code>TCP/UDP</code> 的四层负载，所以在 <code>http1.1</code>  中是可以做到请求级的负载均衡，但如果是类似于 <code>gRPC</code> 这类长链接就无法做到请求级的负载均衡。</p>
<p>换句话说 <code>service</code> 只支持连接级别的负载。</p>
<p>如果要支持 <code>gRPC</code>，就得使用 Istio 这类服务网格，相关内容会在后续章节详解。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说 <code>k8s service</code> 提供了简易的服务注册发现和负载均衡功能，当我们只提供 http 服务时是完全够用的。</p>
<p>相关的源码和 yaml 资源文件都存在这里：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>新手如何快速参与开源项目</title>
    <url>/2023/08/05/ob/novice-contribute-open-source/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/08/05/5mXrStCDVHNxF7f.png" alt="image.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开源这件事情在软件开发领域一直是一个高频话题，我们工作中不管是使用到的工具还是第三方库都离不开开源的支持。</p>
<p>近期由于工作的原因，我需要经常和 <code>Apache Pulsar</code> 社区沟通，同时也会将日常碰到的问题反馈给社区，包括一些 <code>bug</code> ，一些我能修的也是顺带就提了一些 <code>PR</code>。</p>
<span id="more"></span>

<p>之前或多或少我也参与过其他的开源社区，但和现在的还是有些许的不同：</p>
<ul>
<li>以前我更多的是个人开源项目，偶尔也会有其他开发者向我的仓库贡献代码。</li>
<li>也参与过其他个人作者或者是社区性质的项目，但流程上没有那么正规或者是<code>标准</code>。</li>
</ul>
<p>简单来说就是以前就是小打小闹，<code>Pulsar</code> 毕竟是 <code>Apache</code> 社区的顶级项目，参与的整个流程要求也会比较复杂，当然学到的知识也会更多。</p>
<p><img src="https://s2.loli.net/2023/08/05/uSRKlvh8q4sTpWj.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2023/08/05/DJm145yigIhEvwe.png" alt="image.png"><br>这半年时间大大小小提了十几个 PR ，也逐渐捋清楚了一些上手的方法和套路，所以如果你也想参与开源，但苦于不知道如何入门，看完后希望对你有所帮助。</p>
<h1 id="为什么参与开源"><a href="#为什么参与开源" class="headerlink" title="为什么参与开源"></a>为什么参与开源</h1><p>首先还是来聊聊参与开源的好处，了解之后也许会让你有路转粉。</p>
<p>首先最明显的一点就是让你对贡献的这个项目更加深入的了解，我们常常都在面试的时候被问到对 XX 框架的熟悉程度，哪怕你在简历里写的天花乱坠也没有是这个项目  <code>Contributor</code> 更具有说服力。</p>
<p>其次是沟通交流能力也会得到锻炼，开源社区往往都是以 <code>github issue/PR</code>，或者是 <code>Mailing List</code> 的方式沟通交流，这样的沟通方式和我们常用的微信、QQ 这类及时通讯工具有着本质的区别。</p>
<p>往往需要我们有了冷静的思考加上清晰的描述才会将自己的观点发布出去，这样不自觉的就会养成自己的总结能力，这个能力对于<code>内容创意内容工作者</code>来说非常重要。</p>
<p>还有一个更明显的好处就是对个人的能力背书，大家常说的 <code>show me the code</code>，而 <code>GitHub</code> 就是最好的方式。</p>
<p>当你是某个知名开源项目的 <code>Contributor</code> 甚至是 <code>Committer/PMC</code> 就已经足够证明自己的能力了。</p>
<h1 id="如何参与"><a href="#如何参与" class="headerlink" title="如何参与"></a>如何参与</h1><p>如何参与呢，其实也很简单，不外乎有以下几种方式（由易到难）：</p>
<ul>
<li>一些 <code>typo</code> 类的修复。</li>
<li>回答社区中用户的问题。</li>
<li>使用过程中遇到 <code>bug</code>，直接反馈，有兴趣的话最好是自己能修复。</li>
<li>修复现有 <code>issue</code> 列表中未解决的 <code>bug</code>。</li>
<li>软件不具备自己需要的功能时提交 <code>feature</code> 提案并实现。</li>
</ul>
<p>不管是哪种方式我的建议是在准备贡献之前都应该先看看官方提供的贡献指南，通常在官网就能查看。</p>
<blockquote>
<p>即便是最简单的修复 typo，因为越是专业的项目每个 PR 的合并都是严谨的，提前了解后可以避免犯一些基本错误从而影响积极性。</p>
</blockquote>
<p>这里我以 <code>Pulsar</code> 为例：<br><img src="https://s2.loli.net/2023/08/05/8TGyjSXChsaoPc6.png" alt="image.png"><br>官网有着详细的贡献指南，包括环境搭建、代码约定、<code>PR/git commit</code> 语义等各种规范。</p>
<p>这里我重点强调 PR 的语义，一个好的 PR 规范更容易引起社区成员的注意，毕竟我们每一次提交都需要 <code>Committer</code> 的同意才能合并。</p>
<p><img src="https://s2.loli.net/2023/08/05/gfbEBjc4dXVLPtw.png" alt="image.png"><br>还是以 <code>Pulsar</code> 为例，在提交 PR 前一定得先看看这里的规范要求，不然很可能第一步就会吃瘪。</p>
<h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><p>下面讲讲贡献过程中可能会碰到的问题。</p>
<p>在上面讲到的难度排序中将修复个人 issue 排在了其他 issue 之前了，这是因为往往对自己提交的 bug 更熟悉，而社区其他人反馈的问题大概率会被老手认领。</p>
<p>加上自己也不熟悉，可能在自己研究复现的过程中就把自己劝退了。</p>
<h3 id="认领-issue"><a href="#认领-issue" class="headerlink" title="认领 issue"></a>认领 issue</h3><p>这里还有个小技巧，当我们准备修复一个不是自己提交的 issue 时，最好是在评论区让 <code>Committer</code> 将这个任务分配给你，这样社区成员就不会做重复工作了。</p>
<p><img src="https://s2.loli.net/2023/08/05/KBh1HRd8EyziuQP.png" alt="image.png"><br>类似于这样。</p>
<p>同时我们在查找可以修复的 <code>issue</code> 时也要注意这个 issue 有没有被认领以及是否有 PR 关联。</p>
<p><img src="https://s2.loli.net/2023/08/05/pOPybK7lmX1v8oU.png" alt="image.png"></p>
<p>有时候 <code>issue</code> 并没有被指定但也有相关 <code>PR</code> 在处理该问题了，这时我们就可以过滤掉这个 <code>issue</code>。</p>
<h3 id="help-want"><a href="#help-want" class="headerlink" title="help want"></a>help want</h3><p><img src="https://s2.loli.net/2023/08/05/QMwDlTWd3iFPU7c.png" alt="image.png"><br>也可以找找带有  <code>help want</code> 标签的 <code>issue</code>，这类问题往往会相对简单，修复起来也更容易。</p>
<h3 id="社区反馈较慢"><a href="#社区反馈较慢" class="headerlink" title="社区反馈较慢"></a>社区反馈较慢</h3><p>还有一个比较常见的问题是自己提交的 issue 或者是 PR 迟迟没有人处理。</p>
<p>我们可以先看看这个 issue 对应的代码最近主要是哪些人在维护，这个在 IDE 中配合 <code>GitToolBox</code> 插件就很容易看出来。</p>
<p><img src="https://s2.loli.net/2023/08/05/ojErZnigXbqFvam.png" alt="image.png"><br>后面的 ID 往往是 <code>PR</code> 号，我们可以通过这个 <code>PR</code> 找到对应的作者，然后尝试在 <code>issue</code> 评论区艾特对方。</p>
<p>如果依然没有回复，那我们也可以给开发组发送邮件。<br><img src="https://s2.loli.net/2023/08/05/SuT5Fb4wG2BnrV1.png" alt="image.png"><br>如果还是没有回复，比如我这个😂</p>
<p>那也还有一个办法，就是尝试在社交媒体（GitHub 首页、技术群）上找到 Committer 的微信，直接私聊的方式让对方帮忙推进。<br><img src="https://s2.loli.net/2023/08/05/J8r6lBbhMgziFGv.png" alt="image.png"></p>
<p>当然也有一些项目长期没有维护了，这种 PR 要做好心里准备，很有可能对方不会理你；这点在国内某个企业的开源项目中比较常见。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说想要做好开源得有耐心和长期坚持，同时给自己带来的好处也是物超所值的，<code>Apache</code> 这类专业的社区我也才参与了半年，后续也会长期坚持下去，也希望哪天可以积累到成为 <code>Committer</code> 后再和大家分享。</p>
<p>#Pulsar #OpenSource</p>
]]></content>
      <categories>
        <category>OpenSource</category>
      </categories>
      <tags>
        <tag>Pulsar</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着播客学英语-Why I use vim ? part one.</title>
    <url>/2023/10/02/ob/podcasts-english-0-vim/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/10/03/kheL1o68m2IyXbU.png" alt="why-use-vim-01.png"></p>
<p>最近这段时间在学英语，在网上看到有网友推荐可以听英文播客提高听力水平。</p>
<p>正好我自己也有听播客的习惯，只不过几乎都是中文，但现在我已经尝试听了一段时间的英文播客，觉得效果还不错。</p>
<p>大部分都是和 IT 相关的内容，所以一些关键词还能听懂，同时也是自己的感兴趣的内容，如果是一次听不懂我就会反复收听。<br>视频版：</p>
<iframe src="//player.bilibili.com/player.html?aid=961634958&bvid=BV1TH4y1Z77L&cid=1287992721&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<span id="more"></span>


<p>今天来听第一期内容，这位作者是一位资深工程师，讲述他为什么使用 Vim 的过程。<br><a href="https://www.healthyhacker.com/2014/07/29/why-i-use-vim/">https://www.healthyhacker.com/2014/07/29/why-i-use-vim/</a></p>
<p>以下是我通过语音转文字的内容</p>
<blockquote>
<p>我会精简翻译比较重要的部分，还是推荐大家去收听原始播客。</p>
</blockquote>
<p>Healthy hacker episode one. Welcome to the healthy hacker, where we talk about programming, puzzles, memory, fitness, diet, and everything else that you a healthy hacker , find Interesting. I’m Chris Hunt, and on the very first episode episode one, I’m going to answer a question? I get all the time, every conference I go to, every time I start a new job, every time I pair with somebody new. And that is: Chris, why do you use Vim? At of all the text editor on the planet, why do you choose to use Vim?</p>
<blockquote>
<p>作者在各种会议和新同事的接触中都会被问到这个问题：为什么你会使用 vim</p>
</blockquote>
<p>It’s so old it looks like <code>crap</code>. Why do you do it? So I’m totally going to tell you I have many various reasons why I love using Vim really excited about it, going to answer that question before we do though, we are going to talk about the workout of the week , all right. The workout of the week is a section that, uh, basically, I’m just going to take a workout I’ve done recently, and tell you about it, and hopefully you find the time this week to try it yourself, because every single one of these workouts you can do, I promise you. </p>
<blockquote>
<p>在开始之前先聊聊本周的锻炼</p>
</blockquote>
<p>Okay, so this week’s workout is a workout that I’ve been doing for several years. You need <code>barely</code> no equipment. All you need is a floor. I do it at least once, when I travel, sometimes twice, sometimes three times. I think there was a point in my life where I was doing this. Work out, like three or four times a day. This is the only thing I was doing. I don’t recommend that, but you should totally give it a shot at least once this week and let me know how you do, because I’m <code>curious</code>,</p>
<blockquote>
<p>这个锻炼已经进行了许多年了，几乎不需要额外的设备，只需要一块地板。旅行的时候也会继续坚持，建议你本周至少得尝试一次。</p>
</blockquote>
<p>so let’s get right into it this is  A ten rep pyramid, and I’ll I’ll explain what that means. Basically, you want to do each exercise, one time, then two times, then three times, then four times, all the way up to ten, the top of the pyramid ten times, and then you go back down again to one, so nine, a seven until you finally end with one rep of each exercise, so the two exercises are going to do for this workout is a pushup and a shoulder press with no weight on each of these, you’re just doing body weight.</p>
<blockquote>
<p>做一个递增组和递减组，从每组一个动作增加到每组 10 个动作，再由十个动作一组减少到一个动作一组；<br>每组做两个动作，俯卧撑，和坐姿推肩，都不用负重，只需要自重即可。</p>
</blockquote>
<p>So I’m sure, everybody knows what a pushup is. If you don’t check out the show notes, or just do a Google image search, shoulder press you may or may not be as familiar with, but it’s just like it sounds. You take your hands, put them by your shoulders, and then press your hands up into the air again, just to Google. Im in search, you’ll totally get what this is. So the workout is one pushup. One shoulder press, then two pushups, two shoulder presses, then three pushups, then three shoulder presses,</p>
<blockquote>
<p>应该都知道俯卧撑怎么做，如果推肩不知道怎么做的话可以去 Google，都是比较简单动作；<br>所以这个训练是一次俯卧撑，一次推肩为一个动作；然后增加到两个俯卧撑+推肩+然后是三个俯卧撑+三个推肩。</p>
</blockquote>
<p>then four, five, six, seven, eight 910, and then go back down again, nine, eight, seven, six, and you finish with one push up, one shoulder, press. Now. The goal with this is to go as fast as you possibly can, but take breaks as necessary. I <code>definitely</code> can’t do this without stopping, especially on the pushups part. So do as fast as you can. When I did this this morning, I did it in seven minutes and 28 seconds, so let me know how you do. I’m super curious if you’ve never done this before, it’s going to seem crazy hard,</p>
<blockquote>
<p>以此类推做到十次，再递减到 1 一次，目标是尽可能的快速完成。<br>休息也是非常有必要的，我无法做到不休息全部完成，特别是在俯卧撑这个部分。<br>非常好奇你做完的感受，如果你从来没做过的话，还是比较困难的。</p>
</blockquote>
<p>but I know you can do it. By the time you finished this workout, you will have done 100 pushups and 100 shoulder presses. If it really Really Really is out of your <code>reach</code>, even with breaks, then you can scale this workout, decreasing your pyramid. So instead of doing a ten rep pyramid, do like a six rep pyramid or a Five Rep Pyramid, but with brakes, I know that everybody can do 100 pushups in 100 shoulder presses. It might take you a while, but you can do it, so give it a shot. All right. </p>
<blockquote>
<p>但超过你的承受范围时，可以适当减少组数。</p>
</blockquote>
<p>So now it’s time to answer that question: why do I use Vim? Well, for starters, if you’re going to learn any editor vim is a pretty good <code>investment</code>. It’s been around for a long time over 20 years. It’s open source, it runs on everything it’s not like there’s, a company vested in its future you know it doesn’t cost you money, it’s for as long as I’m programming, vim is going to be around, so if I’m going to waste time trying to master a text editor, vim is probably a good choice because it’s not going anywhere</p>
<p>I’m not going to have to forget everything I’ve learned and start learning a different text editor. I can use vim for the rest of my life for all my text editor so it’s a good <code>investment</code> of your time. Now if you do a Google search, you start looking for books for Vim, you might see Vi and Vi is actually an older editor that Vim is based on Vim stands for Vi improved, and most of them’s functionality comes from Vi, so most of us, don’t use Vi, some of the things I really like about vim, that Vi doesn’t have is improved syntax,</p>
<p>highlighting for the languages I like to use mostly Ruby and Javascript. Nowadays, they’re spell-checking, so when you use it for typing an emails or typing up a poll request that comes in handy, there’s splits, so you can view maybe your test and your code at the same time, without having to go back and forth, you have multiple levels of undo and redo them can do diffs, or, as vi can’t do diff, so you can open up two of the same files that are edited at different points of time, and see that diff in red and green it’s pretty nice,</p>
<blockquote>
<p>学习 vim 是一个很好的投资，它是开源的免费的，值得花时间去学习。<br>vi 是 vim 的前身，vim 在此基础上进行了改进，比如语法高亮、输入检测等。<br>vim 还可以分屏，可视化对比等</p>
</blockquote>
<p>and then you also have scripting Vim script itself, which is, the native script language for Vim is not pretty, but you can also do scripting with other languages, like Perl, Ruby, python and Vim also has a really awesome help system with which vi does not have there’s also some improvements that Vim ads that I don’t really care about, I mean I took notes, obviously because I don’t have all this stuff memorized, and I’ve titled this section dumb <code>stuff</code>, because it’s kind of du I don’t care linefolding is one editing of compressed files I don’t really care about that.</p>
<blockquote>
<p>Vim 还内置了脚本语言 vimscript，很好用的帮助系统，这些 vi 都没有。</p>
</blockquote>
<p>You can edit files over network connections like ssh ftp http. I could say how that would be useful, but I’ve never wanted or had to do that, and then them also provides a graphical user interface. Usually you open this up using Gvim for graphical Vim, and that provides mouse integration, again, things I don’t care about. One of the main reasons I use Vim is for speed, and not having to touch the mouse, so it’s kind of silly to for me to get excited about that kind of <code>stuff</code>, okay So so that’s the kind of the differences between Vim and Vi and why everybody uses Vim most computers now.</p>
<blockquote>
<p>vim 可以通过网络连接来编辑文件，同时也提供了 GUI 界面，可以使用鼠标来操作。<br>不过我对这个并不感兴趣，使用 vim 的主要原因就是因为速度，不需要在去触摸鼠标了（这确实也是大部分人使用 vim 的原因）</p>
</blockquote>
<h1 id="生词"><a href="#生词" class="headerlink" title="生词"></a>生词</h1><p>It’s so old it looks like <code>crap</code>:  它已经很老了，看起来是垃圾。<br><code>crap</code>:<br><img src="https://s2.loli.net/2023/10/03/3RZontYrVcDTFGq.png" alt="image.png"></p>
<p>if you’re going to learn any editor, vim is a pretty good <code>investment</code>：<br>如果你想学习一个编辑器，Vim 是一个不错的投资。<br><code>investment</code>:<br><img src="https://s2.loli.net/2023/10/03/PjR97l2iYNLtU3g.png" alt="image.png"></p>
<p>I <code>definitely</code> can’t do this without stopping<br>我绝对不能不停下来<br><code>definitely</code>:<br><img src="https://s2.loli.net/2023/10/03/saTHywQgdti5ePA.png" alt="image.png"></p>
<p>let me know how you do, because I’m <code>curious</code>:<br>告诉我你是怎么做的，我很好奇。<br><code>curious</code><br><img src="https://s2.loli.net/2023/10/03/vWz9ZR6MdLVSrUu.png" alt="image.png"></p>
<p>You need <code>barely</code> no equipment.<br>你几乎不需要设备<br><code>barely</code><br><img src="https://s2.loli.net/2023/10/03/9rcKYjITGQgUB4n.png" alt="image.png"></p>
<p>I don’t have all this <code>stuff</code> memorized:<br>我没有记住所有这些东西<br><code>stuff</code><br><img src="https://s2.loli.net/2023/10/03/nP8SpO2DTdHLj31.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>OB</category>
        <category>Podcasts</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着播客学英语-Why I use vim ? part two.</title>
    <url>/2023/10/06/ob/podcasts-english-1-vim/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/10/05/lx4a2h1KcUyIoHd.png"></p>
<p>在上一期作者讲到了他使用 Vim 的主要原因是提高效率，不需要再去使用鼠标，今天我们继续上次未听完的内容：</p>
<span id="more"></span>
<p>if you type Vi, that’s going to be alias to Vim anyway by default there’s, not really a good reason for you to use vi that I can think of. The reason I first started using Vim is kind of a <code>silly</code> one, and that is because my brother used it, uh, my brother, Nick, he climbs mountains for a living. Right now, he lives in Seattle and goes up and down rain near when it gets too cold to climb. Rainer? He goes to the other side of the world and leads, climbs up mountains over there, and then comes back again and starts climb a rain air over and over and over again.</p>
<p>Before he did that, though, he used to do quite a bit of programming, and I remember when I would watch him program because he started programming before me, he looked like a real hacker. He looked like the hackers you see on TV. He never touched the mouse. There was text flying out all over the screen files, opening, closing splits. It was awesome. It was like I wanted to be that person you. Know and He was using vim. I didn’t know it was Vim, but that’s what he was using. So I opened Vim. I tried to edit some files I was using Eclipse at the time and doing Java.</p>
<blockquote>
<p>作者首次使用 Vim 的 原因有点傻，因为他的哥哥 Nick 做了很长时间的编程，一直使用的都是 Vim，看起来就行是电视里真正的黑客那样，他从不使用鼠标，文字也在屏幕里乱飞，看起来非常酷。<br>而那个时候作者还在使用 eclipse 编写 Java</p>
</blockquote>
<p>This is like my first year of college, I was taking an introductory to programming class. It’s the first programming I’ve ever done, and I thought Eclipse was great. It compiled my code for me. It had buttons for everything, but I didn’t feel like a real hacker when I looked at nick. I mean, granted, he was writing C, which already looks way cooler. He was using Vim as well, and it just <code>impressed</code> me, so I try to start opening up some of my Java files, and I have no idea how to do it. No idea how to edit a file I have no idea how to save a file I have no idea how to type in the document for crying out loud.</p>
<p>If I press keys, it does nothing. Sometimes a delete words, sometimes at pacewords, <code>it&#39;s a mess</code>, and this is probably the first experience that everybody has when they start using Vim, because Vim operates completely different than any other text editor I’ve ever used it’s <code>weird</code> them has modes, it has a language, it has objects, subjects, counts, verbs. All that stuff is, like, really weird when you first get started, but once you understand it, it’s a lot of learning upfront everything, just kind of clicks and you’re instantly faster than you’ve ever been before,</p>
<blockquote>
<p>eclipse 很好用，但看起来没有 Nick 使用 Vim 那么酷，使得作者印象深刻。</p>
<p>因此他尝试使用 Vim 来打开 Java 文件，但却不知道如何编辑、删除、保存等基本操作，大部分初次使用 Vim 应该都会碰到这些问题，它和我们使用的其他编辑器完全不同，看起来比较奇怪。</p>
<p>不过一旦你掌握它，那么使用效率将会飞速提高。</p>
</blockquote>
<p>for example, let’s say, we wanted to copy a method from one ruby file and put it in another. If I was using sublime text, I would take my mouse. I would select that method I’d press command c to copy it, and then I’d click over to where I want the method to be, and I’d press command v to paste it. Not very bad that’s pretty fast probably doesn’t take very long, but in Vim, you can do it even faster and without touching your mouse, them has a verb for yanking text it’s not called copying it’s, called yanking.</p>
<p>It has a movement called inside, so you can yank inside something, and then it has subjects called text blocks, which, in Ruby, those are methods. Vim understands blocks of text if you’re editing a markdown document like, say, a read me, them’ll know where a paragraph starts and where a paragraph ends, if we’re editing a ruby file it’s going to know where a method begins and where a method ends, or where your class begins or where your class ends, so using the Verb Yank, which happens to be the key Y,</p>
<blockquote>
<p>如果我们使用 sublime 这样的编辑器复制一个方法时会比较麻烦，首先要用鼠标选中文本，然后复制再粘贴。<br>但使用 Vim 时不需要使用鼠标，而是被称为 Yanking，当编辑  Markdown 时 Vim 会知道段落的开始和结尾，编辑 Ruby 时可以方法的开始和结尾。</p>
</blockquote>
<p>and then the movement inside, which happens to be the key I, and then the subject paragraph, which is vim’s word for a block of text, you can yank a method. So if I put my cursor inside a ruby method and I type Y I P. For yank inside paragraph, it’s going to copy that method to the clipboard. So by understanding the verb, yank the movement inside and the subject paragraph, we can perform actions really, really quickly, and then if we want to pace it somewhere else, we press the peaky for paste,</p>
<p>and it’ll stick that text down, so everything in Vim is based on those concepts of verbs, movements and subjects. You also have one more thing you can play with, and that is counts, so if you want to perform something multiple times, in most cases, you can stick a number in front of it like one, two, three, five, and it’s going to do it that many times, understanding those basic concepts, gets you a really long way, and then it’s just a matter of understanding which keys correspond to which verbs and which movements and which subjects,</p>
<blockquote>
<p>在 vim 中只需要将光标移动到方法中，然后使用 YIP 就可以复制整个方法。<br>所以只要理解了这些基本概念就可以快速提高效率。</p>
</blockquote>
<p>and that just comes with time, which is the third reason I like to use Vim. Is there so much stuff to learn whenever I get bored? All I got to do is pull up them help, and I could start learning stuff in every little thing, I learn, every little keyboard shortcut, every movement, every subject, gets me a little bit faster, and it doesn’t seem like a lot like the example I gave earlier, of copying and pasting text and sublime with a mouse that doesn’t take very long. But if you add up all those little bits,</p>
<p>you’re saving a ton of time, a good <code>analogy</code> I like to use is <code>lifting</code> weights if I’m <code>squatting</code> 100 pounds, and I take a little, teeny, tiny two and a half pound plate, and I put it on each side of the barbell I probably won’t, even notice it, I mean, I’ll be squatting 105 pounds now, right, that’s not really that big of a difference, but if I add those two and a half pound plates 60 more times, going in once a day, and doing that, I’m now squatting 400 pounds, which is a pretty big difference, so those little changes don’t seem like a lot,</p>
<blockquote>
<p>我喜欢使用 Vim 的一个原因是可以学到许多东西，每学一些都可以让自己的效率提高一点。<br>就像是我们深蹲一样，慢慢的加重量，反复尝试最终就能得到巨大的提升。</p>
</blockquote>
<p>but taken as a whole, you’re editing text way faster than people who aren’t using vim. The last reason I like to use Vim is because it runs in the terminal, and this may not seem like a big deal, but it really is <code>cosmetically</code>, it’s nice because you can just pop a terminal open, full screen and have no chrome I use mac os, so I’ve got that big menu bar on top, it’s really nice to just full screen a terminal and not see anything at all, and have your command line tools and your text editor all running in the same window I happen to use tmucks to manage that stuff I won’t talk about Tmux and now,</p>
<p>but I definitely will talk about it in another episode, but even out of the <code>cosmetic</code> reasons, it’s nice to have a text editor that runs in the terminal because you’re not always using your own machine right as web developers, I’m a web developer, we’re always connecting to remote machines to edit files. Now, why is it that we should be forced to use a different text editor? The nice thing about Vim is it runs in the terminal, so every machine you connect to will likely already have Vim installed, but even if it doesn’t you can install it,</p>
<p>and you can put your config files over there and you can make it so that no matter where you’re editing text you’re always in the same environment, which is awesome. Before I started using Vim out, connect a remote machines, and, and be forced to use some textset or I’m not familiar with, and it drove me nuts, but now I sometimes forget I’m on a remote machine because it’s exactly the same as the machine I use at home, so if you’ve never tried them, or maybe you tried it in the past, and it was super confusing or really turned you off.</p>
<blockquote>
<p>最后一个使用 Vim 的 原因是它可以在终端中运行，不仅可以使用自己的设备，还可以连接到远程设备去编辑文件，还可以使用相同的配置文件，使得所有的环境配置都是相同的</p>
</blockquote>
<p>Give it a second shot there’s, a great stack overflow article that just kind of rehashs a lot of the things I said here, but it’s just it’s also just fun to read it talks about the core concepts of vi, the editor that Vim is based on, and I put a link to that in the shownotes there’s, also, them casts by Drew Neil, which is a screencast series that’s totally free, and he covers a lot of advanced concepts he’s got a little bit of beginner stuff in there as well. You can also just open up a terminal and type vim tutor and Vim’s going to give you a little lesson in how to use Vim,</p>
<p>give it a shot that’s all I’ve got for this week, you can find the shownotes at healthy hacker Dot Com, slash one, if you have any questions or feedback, send me a voicemail healthy hacker, Dot Com Slash Voicemail.</p>
<blockquote>
<p>在 stack overflow 中有着各种教程，大家可以尝试一下。</p>
</blockquote>
<h1 id="生词"><a href="#生词" class="headerlink" title="生词"></a>生词</h1><p>The reason I first started using Vim is kind of a <code>silly</code> one<br>我第一次使用 Vim 的原因有点傻。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://s2.loli.net/2023/10/06/WKxpPUNT5wZr983.png" alt="image.png"></h2><p><code>it&#39;s a mess</code><br>搞砸了<br><img src="https://s2.loli.net/2023/10/06/Cl6pKGR7e8A54mk.png" alt="image.png"></p>
<p>a good <code>analogy</code> I like to use is <code>lifting</code> weights if I’m <code>squatting</code> 100 pounds,<br>but it really is <code>cosmetically</code>,<br><img src="https://s2.loli.net/2023/10/06/8DxnNGwmMiyzCbJ.png"></p>
<p><img src="https://s2.loli.net/2023/10/06/68yEronuJUpm9wW.png" alt="image.png"><br><img src="https://s2.loli.net/2023/10/06/2O86HijZufx9eVW.png"></p>
]]></content>
      <categories>
        <category>OB</category>
        <category>Podcasts</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>1.6W star 的 JCSprout 阅读体验大提升</title>
    <url>/2018/11/06/personal/1W-star-update/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1c66de1a6d.jpg"></p>
<hr>
<p>万万没想到 <a href="https://github.com/crossoverJie/JCSprout">JCSprout</a> 截止目前居然有将近<code>1.6W star</code>。真的非常感谢各位大佬的支持。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c67179a40.jpg"></p>
<p>年初时创建这个 <code>repo</code> 原本只是想根据自己面试与被面试的经历记录一些核心知识点，结果却是越写越多。</p>
<span id="more"></span>



<p>在我自己宣传和其他技术大佬(包括阮大)的助攻之下连续两个月都在 <code>GitHub trending Java</code>片区的榜首。</p>
<p>甚至有一次还一跃到整个 <code>GitHub</code> 的第一，同时还有帮助一些同学拿到了大厂 <code>offer</code>。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c674953cd.jpg"></p>
<p>扯了这么多进入这次的正题。</p>
<p>之前有一朋友建议将文档以 <code>gitbook</code> 的形式查看，一直没有时间弄。直到有一天我看到了 <a href="https://docsify.js.org/#/">docsify</a> 这个项目，瞬间被它的外观，阅读方式所吸引。于是抽了一晚上把所有的文章全部迁移过去。</p>
<p>现在打开 <a href="https://crossoverjie.top/JCSprout/">https://crossoverjie.top/JCSprout/</a> 即可看到全新的主页，大概长这样：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c679a9a01.jpg"></p>
<hr>
<p><img src="https://i.loli.net/2019/05/08/5cd1c67c0db08.jpg"></p>
<p>确实不管从颜值还是阅读方式来说都非常不错；希望新的界面能让更多的人看的进去学到点东西。</p>
<blockquote>
<p> 同时也更新完善了其中的一些内容。比如有些写的早的内容其实并不完善，也优化的处理了。</p>
</blockquote>
<p>同时欢迎更多朋友参与进来，不管是提新的点子、修改 <code>bug</code> 都是可以。</p>
<p>之前的文章也留了不少坑，包括 <code>cicada</code> 还有好几个 <code>bug</code> 待处理、推送的示例代码以及 <code>Kafka</code> 源码的后续更新。</p>
<p>突然有点像写长篇小说的感觉，还好没有多少人催更🤣。</p>
<p>不出意外本周会再更新一篇，请持续关注。</p>
<p><strong>你的点赞与转发是最大的支持。</strong></p>
]]></content>
      <categories>
        <category>Person</category>
        <category>GitHub</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub 1W star 成就达成！</title>
    <url>/2018/08/17/personal/1W-star/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d25b1f39e.jpg"></p>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>感谢各位大佬的支持收获了人生第一个（很有可能也是唯一一个）<code>1W star</code> 项目。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d25f5280d.jpg"></p>
<p>从今年一月份创建项目至今 8 个月时间。</p>
<p>一共关闭了 27 个 <code>issue</code>，47 个 <code>RP</code>，总共有 11 位小伙伴参与维护。</p>
<p>神奇般的连续两个月上了 GitHub Java 热门榜首。</p>
<span id="more"></span>

<p><img src="https://i.loli.net/2019/05/08/5cd1d260b9c1e.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d262c6582.jpg"></p>
<p>整个热度走势图也是一路向北：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2638a052.jpg"></p>
<p>过程中也有许多朋友反馈得到了帮助，自己确实没想到能起到这么好的作用。</p>
<h2 id="更名"><a href="#更名" class="headerlink" title="更名"></a>更名</h2><p>趁这机会我想给项目重新换个名字，因为我发现做到现在这里面并不仅仅包含面试的内容。</p>
<p>我们也不应该只为了面试而使用该项目，里面所有的技术内容我认为都应该对实际开发起到帮助，让大家少走弯路。</p>
<p>所有我把项目重命名为：</p>
<p><code>JCSprout : Java Core Sprout：处于萌芽阶段的 Java 核心知识库。</code></p>
<p>还创建了 logo。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d26412262.jpg"></p>
<p>整个技术道路非常漫长，这一点小成就只是一颗小萌芽，希望最后能生根发芽。</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>今后我依然会持续维护，也希望更多的朋友参与进来。</p>
<p>还要把之前给自己挖的坑填好：</p>
<ul>
<li>HTTP </li>
<li>SpringBoot</li>
<li>Tomcat 等</li>
</ul>
<p>后期还会继续添加一些源码解析、最佳实践等内容。</p>
<p>还没有关注的朋友难道不想进来看看嘛？最新地址：</p>
<p><a href="https://github.com/crossoverJie/JCSprout">https://github.com/crossoverJie/JCSprout</a></p>
<p><strong>你的点赞与转发是最大的支持。</strong></p>
]]></content>
      <categories>
        <category>Person</category>
        <category>GitHub</category>
      </categories>
  </entry>
  <entry>
    <title>一个学渣的阿里之路</title>
    <url>/2018/06/21/personal/Interview-experience/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d5207237e.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近有些朋友在面试阿里，加上 <a href="https://github.com/crossoverJie/Java-Interview">Java-Interview</a> 项目的原因也有小伙伴和我讨论，近期也在负责部门的招聘，这让我想起年初那段长达三个月的奇葩面试经历🤣。</p>
<p>本来没想拿出来说的，毕竟最后也没成。</p>
<p>但由于那几个月的经历让我了解到了大厂的工作方式、对候选同学的考察重点以及面试官的套路等都有了全新的认识。</p>
<p>当然最重要的是这段时间的查漏补缺也让自己精进不少。</p>
<p>先交代下背景吧：</p>
<p>从去年 12 月到今年三月底，我前前后后面了阿里三个部门。</p>
<p>其中两个部门通过了技术面试，还有一个跪在了三面。</p>
<p>光看结果还不错，但整个流程堪称曲折。</p>
<p>下面我会尽量描述流程以及大致的面试题目大纲，希望对想要跳槽、正在面试的同学带来点灵感，帮助可能谈不上，但启发还是能有。</p>
<p>以下内容较长，请再次备好瓜子板凳。</p>
<span id="more"></span>


<h2 id="A-部门"><a href="#A-部门" class="headerlink" title="A 部门"></a>A 部门</h2><p>首先是第一次机会，去年 12 月份有位大佬加我，后来才知道是一个部门的技术 Leader 在网上看到我的博客，问我想不想来阿里试试。</p>
<p>这时距离上次面阿里也过去一年多了，也想看看现在几斤几两，于是便同意了。</p>
<p>在推荐一周之后收到了杭州打来的电话，说来也巧，那时候我正在机场候机，距离登记还有大概一个小时，心想时间肯定够了。</p>
<p>那是我时隔一年多第一次面试，还是在机场这样嘈杂的环境里。多多少少还是有些紧张。</p>
<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>以下是我印象比较深刻的内容：</p>
<p><strong>面试官：</strong></p>
<p>谈谈你做过项目中印象较深或自认为做的比较好的地方？</p>
<p><strong>博主：</strong></p>
<p>我觉得我在 XX 做的不错，用了 XX 需求实现 XX 功能，性能提高了 N 倍。</p>
<p><strong>面试官：</strong></p>
<p>你说使用到了 AOP ，能谈谈它的实现原理嘛？</p>
<p><strong>博主：</strong></p>
<p>它是依靠动态代理实现的，动态代理又分为 JDK 自身的以及 CGLIB 。。。。</p>
<p><strong>面试官：</strong></p>
<p>嗯，能说说他们的不同及优缺点嘛？</p>
<p><strong>博主：</strong></p>
<p>JDK 是基于接口实现，而 CGLIB 继承代理类。。。</p>
<p>就是这样会一直问下去，如果聊的差不多了就开始问一些零散的问题：</p>
<ul>
<li>JMM 内存模型，如何划分的？分别存储什么内容？线程安全与否？</li>
<li>类加载机制，谈到双亲委派模型后会问到哪些违反了双亲委派模型？为什么？为什么要双亲委派？好处是什么？</li>
<li>平时怎么使用多线程？有哪些好处？线程池的几个核心参数的意义？</li>
<li>线程间通信的方式？</li>
<li>HashMap 的原理？当谈到线程不安全时自然引申出 ConcurrentHashMap ，它的实现原理？</li>
<li>分库分表如何设计？垂直拆分、水平拆分？</li>
<li>业务 ID 的生成规则，有哪些方式？</li>
<li>SQL 调优？平时使用数据库有哪些注意点？</li>
<li>当一个应用启动缓慢如何优化？</li>
</ul>
<p>大概是以上这些，当聊到倒数第二个时我已经登机了。最后不得不提前挂断，结束之前告诉我之后会换一个同事和我沟通，听到这样的回复一面应该是过了，<br>后面也确实证实了这点。</p>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>大概过了一周，二面如期而至。</p>
<p>我听声音很熟，就尝试问下是不是之前一面的面试官，结果真是。</p>
<p>由于二面的面试官临时有事所以他来替一下。于是我赶紧问他能否把之前答的不好的再说说？的到了肯定的答复后开始了我的表演。</p>
<p>有了第一次的经验这一次自然也轻车熟路，原本感觉一切尽在掌握却被告知需要笔试突然被激醒。</p>
<p>笔试是一个在线平台，需要在网页中写代码，会有一个明确的题目：</p>
<blockquote>
<p>从一个日志文件中根据关键字读取日志，记录出现的次数，最后按照次数排序打印。</p>
</blockquote>
<p>在这过程中切记要和面试官多多交流，因为笔试有时间限制，别到最后发现题目理解错了，这就和高考作文写完发现方向错了一样要命。</p>
<p>而且在沟通过程中体现出你解题的思路，即使最终结果不对，但说不定思考的过程很符合面试官的胃口哦。这也和今年的高考改卷一样；过程正确得高分，只有结果得低分。</p>
<h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>又过了差不多一周的时间接到了三面的电话，一般到了三面会是技术 Leader 之类的角色。</p>
<p>这个过程中不会过多强调技术细节，更多的考察软件能，比如团队协作、学习能力等。</p>
<p>但我记得也问了以下一些技术问题：</p>
<ul>
<li>谈谈你所理解的 HTTP 协议？</li>
<li>对 TCP 的理解？三次握手？滑动窗口？</li>
<li>基本算法，Base64 等。</li>
<li>Java 内存模型，Happen Before 的理解。</li>
</ul>
<p>一周之后我接到了 HR 助理的电话约了和 HRBP 以及产品技术负责人的视频面试。</p>
<p>但是我却没有面下去，具体原因得往下看。</p>
<h2 id="B-部门"><a href="#B-部门" class="headerlink" title="B 部门"></a>B 部门</h2><p>在 A 部门三面完成后，我等了差不多一星期，这期间我却收到了一封邮件。</p>
<p>大概内容是他在 GitHub 上看到的我，他们的技术总监对我很感兴趣（我都不敢相信我的眼镜），问我想不想来阿里试试。</p>
<p>我对比了 A B 部门的区别发现 B 部门在做的事情上确实更加有诱惑力，之后我表达了有一个面试正在流程中的顾虑；对方表示可以私下和我快速的进行三面，如果一切没问题再交由我自行选择。至少对双方都是一个双赢嘛。</p>
<p>我想也不亏，并且对方很有诚意，就答应试试；于是便有了下面的面试：</p>
<h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p><strong>面试官：</strong></p>
<p>对 Java 锁的理解？</p>
<p><strong>博主：</strong></p>
<p>我谈到了 synchronize，Lock 接口的应用。</p>
<p><strong>面试官：</strong></p>
<p>他们两者的区别以及优缺点呢？</p>
<p><strong>博主：</strong></p>
<p><code>synchronize</code> 在 JDK1.6 之前称为重量锁，是通过进出对象监视器来实现同步的；1.6 之后做了 XX 优化。。。</p>
<p>而 <code>ReentrantLock</code> 是利用了一个巧妙数据结构实现的，并且加锁解锁是显式的。。。</p>
<p>之后又引申到<a href="https://crossoverjie.top/%2F2018%2F03%2F29%2Fdistributed-lock%2Fdistributed-lock-redis%2F">分布式锁</a>，光这块就聊了差不多半个小时。</p>
<p>之后又聊到了我的<a href="https://github.com/crossoverJie">开源项目</a>：</p>
<ul>
<li>是如何想做这个项目的？</li>
<li>已经有一些关注了后续是如何规划的？</li>
<li>你今后的学习计划是什么？</li>
<li>平时看哪些书？</li>
</ul>
<p>之后技术聊的不是很多，但对于个人发展却聊了不少。</p>
<blockquote>
<p>关于锁相关的内容可以参考这里：<a href="https://crossoverjie.top/%2F2018%2F01%2F25%2FReentrantLock%2F">ReentrantLock 实现原理</a> <a href="https://crossoverjie.top/%2F2018%2F01%2F14%2FSynchronize%2F">synchronize 关键字原理</a></p>
</blockquote>
<h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>隔了差不多一天的时间，二面很快就来了。</p>
<p>内容不是很多：</p>
<ul>
<li><a href="https://crossoverjie.top/%2F2018%2F03%2F16%2Fjava-senior%2Fthread-communication%2F">线程间通信的多种方式</a>？</li>
<li>限流算法？单机限流？分布式限流？</li>
<li>提到了 Guava Cache ,了解它的<a href="https://crossoverjie.top/2018/06/13/guava/guava-cache/">实现原理</a>嘛？</li>
<li>如何定位一个线上问题？</li>
<li>CPU 高负载？OOM 排查等？</li>
</ul>
<p>聊完之后表示第二天应该会有三面。</p>
<h3 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h3><p>三面的面试官应该是之前邮件中提到的那位总监大佬，以前应该也是一线的技术大牛；聊的问题不是很多：</p>
<ul>
<li>谈谈对 Netty 的理解？</li>
<li>Netty 的线程模型？</li>
<li><a href="https://crossoverjie.top/2018/04/07/algorithm/LRU-cache/">写一个 LRU 缓存</a>。</li>
</ul>
<h3 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h3><p>本以为技术面试完了，结果后面告知所有的面试流程都得有笔试了，于是又参与了一次笔试：</p>
<blockquote>
<p><a href="https://github.com/crossoverJie/Java-Interview/blob/master/src/main/java/com/crossoverjie/actual/TwoThread.java">交替打印奇偶数</a></p>
</blockquote>
<p>这个相对比较简单，基于锁、等待唤醒机制都是可以的。最后也告知笔试通过。</p>
<p>之后在推荐我的那位大佬的帮助下戏剧般的通过了整个技术轮（真的很感谢他的认可），并且得知这个消息是在我刚好和 A 部门约好视频面试时间之后。</p>
<p>也就意味着我必须<strong>拒掉一个部门！</strong></p>
<p>没看错，是我要拒掉一个。这对我来说确实太难了，我压根没想过还有两个机会摆在我面前。</p>
<p>最后凭着个人的爱好以及 B 部门的热情我很不好意思的拒掉了 A 部门。。。</p>
<h3 id="HR-面"><a href="#HR-面" class="headerlink" title="HR 面"></a>HR 面</h3><p>在面这之前我从来没有面过这样大厂的 HR 流程，于是疯狂搜索，希望能弥补点经验。</p>
<p>也许这就是乐极生悲吧，我确实猜中了 HR 问的大部分问题，但遗憾的是最终依然没能通过。</p>
<p>后来我在想如果我没有拒掉 A ，会不会结局不一样了？</p>
<p>但现实就是如此，没有那么多假设，并且每个人也得为自己的选择负责！</p>
<p>大概的问题是：</p>
<ul>
<li>为什么想来阿里？</li>
<li>个人做的最成功最有挑战的事情是什么？</li>
<li>工作中最难忘的经历？</li>
<li>对加入我们团队有何期待？</li>
</ul>
<h2 id="C-部门"><a href="#C-部门" class="headerlink" title="C 部门"></a>C 部门</h2><p>HR 这关被 Pass 之后没多久我居然又收到了第三个部门的邀约。</p>
<p>说实话当时我是拒绝的，之前经历了将近两个月的时间却没能如愿我内心是崩溃的。</p>
<p>我向联系我的大佬表达了我的想法，他倒觉得我最后被 pass 的原因是个小问题，再尝试的话会有很大的几率通过。</p>
<p>我把这事给朋友说了之后也支持我再试试，反正也没啥损失嘛，而且面试的状态还在。</p>
<p>所以我又被打了鸡血，才有了下面的面试经过：</p>
<h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><p><strong>面试官：</strong></p>
<p>服务化框架的选型和差异？</p>
<p><strong>博主：</strong></p>
<p>一起探讨了 SpringCloud、Dubbo、Thrift 的差异，优缺点等。</p>
<p><strong>面试官：</strong></p>
<p><a href="https://crossoverjie.top/2018/01/08/Consistent-Hash/">一致性 Hash 算法的原理</a>？</p>
<p><strong>博主：</strong></p>
<p>将数据 Hash 之后落到一个 <code>0 ~ 2^32-1</code> 构成的一个环上。。。。</p>
<p><strong>面试官：</strong></p>
<p>谈谈你理解的 Zookeeper？</p>
<p><strong>博主：</strong></p>
<p>作为一个分布式协调器。。。</p>
<p><strong>面试官：</strong></p>
<p>如何处理 MQ 重复消费？</p>
<p><strong>博主：</strong></p>
<p>业务幂等处理。。。。</p>
<p><strong>面试官：</strong></p>
<p>客户端负载算法？</p>
<p><strong>博主：</strong></p>
<p>轮询、随机、一致性 Hash、故障转移、LRU 等。。</p>
<p><strong>面试官：</strong></p>
<p>long 类型的赋值是否是原子的？</p>
<p><strong>博主：</strong></p>
<p>不是。。。</p>
<p><strong>面试官：</strong></p>
<p><a href="https://crossoverjie.top/2018/03/09/volatile/">volatile 关键字的原理及作用？happen Before？</a></p>
<p><strong>博主：</strong></p>
<p>可见性、一致性。。</p>
<h3 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h3><p>一面之后大概一周的时间接到了二面的电话：</p>
<p>原以为会像之前一样直接进入笔试，这次上来先简单聊了下：</p>
<ul>
<li>谈谈对微服务的理解，好处以及弊端？</li>
<li>分布式缓存的设计？热点缓存？</li>
</ul>
<p>之后才正式进入笔试流程：</p>
<blockquote>
<p>这次主要考察设计能力，其实就是对设计模式的理解？能否应对后续的扩展性。</p>
</blockquote>
<p>笔试完了之后也和面试官交流，原以为会是算法之类的测试，后来得知他能看到前几轮的笔试情况，特地挑的没有做过的方向。</p>
<p>所以大家也不用刻意去押题，总有你想不到的，平时多积累才是硬道理。</p>
<h3 id="三面-2"><a href="#三面-2" class="headerlink" title="三面"></a>三面</h3><p>又过了两周左右，得到 HR 通知；希望能过去杭州参加现场面试。并且阿里包了来回的机票酒店等。</p>
<p>可见阿里对人才渴望还是舍得下成本的。</p>
<p>既然都这样了，就当成一次旅游所以去了一趟杭州。</p>
<p>现场面的时候有别于其他面试，是由两个面试官同时参与：</p>
<blockquote>
<p>给一个场景，谈谈你的架构方式。</p>
</blockquote>
<p>这就对平时的积累要求较高了。</p>
<p>还有一个印象较深的是：</p>
<blockquote>
<p>在网页上点击一个按钮到服务器的整个流程，尽量完整。</p>
</blockquote>
<p>其实之前看过，好像是 Google 的一个面试题。</p>
<p>完了之后让我回去等通知，没有见到 HR 我就知道凉了，果不其然。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看到这里的朋友应该都是老铁了，我也把上文提到的大多数面试题整理在了 GitHub：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d52297635.jpg"></p>
<p>厂库地址：</p>
<p><a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
<p>最后总结下这将近四个月的面试心得：</p>
<ul>
<li>一定要积极的推销自己，像在 A 部门的三面时，由于基础答得不是很好；所以最后我表达了自己的态度，对工作、技术的积极性。让面试官看到你的潜力值得一个 HC 名额。</li>
<li>面试过程中遇到自己的不会的可以主动提出，切不可不懂装懂，这一问就露馅。可以将面试官引导到自己擅长的领域。比如当时我正好研究了锁，所以和面试官一聊就是半小时这就是加分项。</li>
<li>平时要主动积累知识。写博客和参与开源项目就是很好的方式。</li>
<li>博客可以记录自己踩过的坑，加深印象，而且在写的过程中可以查漏补缺，最后把整个知识体系巩固的比较牢固，良好的内容还可以得到意想不到的收获，比如我第一次面试的机会。</li>
<li>GitHub 是开发者的一张名片，积极参与开源项目可以和全球大佬头脑风暴，并且在面试过程中绝对是一个加分利器。</li>
<li>面试官一般最后都会问你有什么要问我的？千万不要问一些公司福利待遇之类的问题。可以问下本次面试的表现？还有哪些需要完善的？从而知道自己答得如何也能补全自己。</li>
</ul>
<p>还有一点：不要在某次面试失利后否定自己，有时真的不是自己能力不行。这个也讲缘分。</p>
<p><strong>塞翁失马焉知非福</strong></p>
<p>我就是个例子，虽然最后没能去成阿里，现在在公司也是一个部门的技术负责人，在我们城市还有个窝，温馨的家，和女朋友一起为想要的生活努力奋斗。</p>
<blockquote>
<p>欢迎关注作者公众号于我交流🤗。</p>
</blockquote>
]]></content>
      <categories>
        <category>Interview</category>
        <category>Person</category>
      </categories>
  </entry>
  <entry>
    <title>在这个大环境下我是如何找工作的</title>
    <url>/2023/06/20/personal/find-job-experience/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/06/19/SQP9LxtXNhGwyev.png"><br>蛮久没更新了，本次我想聊聊找工作的事情，相信大家都能感受到从去年开始到现在市场是一天比一天差，特别是在我们互联网 IT 行业。<br>已经过了 18 年之前的高速发展的红利期，能做的互联网应用几乎已经被各大公司做了个遍，现在已经进入稳定的存量市场，所以在这样的大背景下再加上全世界范围内的经济不景气我想每个人都能感受到寒意。</p>
<p>我还记得大约在 20 年的时候看到网上经常说的一句话：今年将是未来十年最好的一年。</p>
<p>由于当时我所在的公司业务发展还比较顺利，丝毫没有危机意识，对这种言论总是嗤之以鼻，直到去年国庆节附近。</p>
<span id="more"></span>

<p>虽然我们做的是海外业务，但是当时受到各方面的原因公司的业务也极速收缩（被收购，资本不看好），所以公司不得不进行裁员；<br>其实到我这里的时候前面已经大概有 2～3 波的优化，我们是最后一波，几乎等于是全军覆没，只留下少数的人维护现有系统。</p>
<p>这家公司也是我工作这么多年来少数能感受到人情味的公司，虽有不舍，但现实的残酷并不是由我们个人所决定的。</p>
<p>之后便开始漫长的找工作之旅，到现在也已经入职半年多了；最近看到身边朋友以及网上的一些信息，往往是坏消息多于好消息。</p>
<p>市场经历半年多的时间，裁员的公司反而增多，岗位也越来越少，所以到现在不管是在职还是离职的朋友或多或少都有所焦虑，我也觉得有必要分享一下我的经历。</p>
<h1 id="我的预期目标"><a href="#我的预期目标" class="headerlink" title="我的预期目标"></a>我的预期目标</h1><p>下面重点聊聊找工作的事情；其实刚开始得知要找工作的时候我并不是特别慌，因为当时手上有部分积蓄加上公司有 N+1 的赔偿，同时去年 10 月份的时候岗位相对于现在还是要多一些。</p>
<p>所以我当时的目标是花一个月的时间找一个我觉得靠谱的工作，至少能长期稳定的工作 3 年以上。</p>
<p>工作性质可以是纯研发或者是偏管理岗都可以，结合我个人的兴趣纯研发岗的话我希望是可以做纯技术性质的工作，相信大部分做业务研发的朋友都希望能做一些看似“高大上”的内容。<br>这一点我也不例外，所以中间件就和云相关的内容就是我的目标。</p>
<p>不过这点在重庆这个大洼地中很难找到对口工作，所以我的第二目标是技术 leader，或者说是核心主程之类的，毕竟考虑到 3 年后我也 30+ 了，如果能再积累几年的管理经验后续的路会更好走一些。</p>
<p>当然还有第三个选项就是远程，不过远程的岗位更少，大部分都是和 web3，区块链相关的工作；我对这块一直比较谨慎所以也没深入了解。</p>
<h1 id="找工作流水账"><a href="#找工作流水账" class="headerlink" title="找工作流水账"></a>找工作流水账</h1><p>因为我从入职这家公司到现在其实还没出来面试过，也不太知道市场行情，所以我的想法是先找几家自己不是非去不可的公司练练手。</p>
<blockquote>
<p>有一个我个人的偏好忘记讲到，因为最近的一段时间写 Go 会多一些，所以我优先看的是 Go 相关的岗位。</p>
</blockquote>
<h2 id="第一家"><a href="#第一家" class="headerlink" title="第一家"></a>第一家</h2><p>首先第一家是一个 ToB 教育行业的公司，大概的背景是在重庆新成立的研发中心，技术栈也是 Go；</p>
<p>我现在还记得最后一轮我问研发负责人当初为啥选 Go，他的回答是：</p>
<blockquote>
<p>Java 那种臃肿的语言我们首先就不考虑，PHP 也日落西山，未来一定会是 Go 的天下。</p>
</blockquote>
<p>由于是新成立的团队，对方发现我之前有管理相关的经验，加上面试印象，所以是期望我过去能做重庆研发 Leader。</p>
<p>为此还特地帮我申请了薪资调整，因为我之前干过 ToB 业务，所以我大概清楚其中的流程，这种确实得领导特批，所以最后虽然没成但依然很感谢当时的 HR 帮我去沟通。</p>
<h2 id="第二家"><a href="#第二家" class="headerlink" title="第二家"></a>第二家</h2><p>第二家主要是偏年轻人的 C 端产品，技术栈也是 Go；给我印象比较深的是，去到公司怎么按电梯都不知道🤣</p>
<blockquote>
<p>他们办公室在我们这里的 CBD，我长期在政府赞助的产业园里工作确实受到了小小的震撼，办公环境比较好。</p>
</blockquote>
<p>当然面试过程给我留下的印象依然非常深刻，我现在依然记得我坐下后面试官也就是 CTO 给我说的第一句话：</p>
<blockquote>
<p>我看过你的简历后就决定今天咱们不聊技术话题了，直接聊聊公司层面和业务上是否感兴趣，以及解答我的疑虑，因为我已经看过你写的很多博客和 GitHub，技术能力方面比较放心。</p>
</blockquote>
<p>之后就是常规流程，聊聊公司情况个人意愿等。</p>
<p>最后我也问了为什么选 Go，这位 CTO 给我的回答和上一家差不多😂</p>
<p>虽然最终也没能去成，但也非常感谢这位 CTO，他是我碰到为数不多会在面试前认真看你的简历，博客和 GitHub 都会真的点进去仔细阅读👍🏼。</p>
<blockquote>
<p>其实这两家我都没怎么讲技术细节，因为确实没怎么聊这部分内容；这时就突出维护自己的技术博客和 GitHub 的优势了，技术博客我从 16 年到现在写了大约 170 篇，GitHub 上开源过一些高 star 项目，也参与过一些开源项目，这些都是没有大厂经历的背书，对招聘者来说也是节约他的时间。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/06/19/Hixaf5ZLTrS6EoR.png"><br><img src="https://s2.loli.net/2023/06/19/wRELfbKx5TYkB7z.png"></p>
<p>当然有好处自然也有“坏处”，这个后续会讲到。</p>
<h2 id="第三家"><a href="#第三家" class="headerlink" title="第三家"></a>第三家</h2><p>第三家是找朋友推荐的，在业界算是知名的云原生服务提供商，主要做 ToB 业务；因为主要是围绕着 k8s 社区生态做研发，所以就是纯技术的工作，面试的时候也会问一些技术细节。</p>
<blockquote>
<p>我还记得有一轮 leader 面，他说你入职后工作内容和之前完全不同，甚至数据库都不需要安装了。</p>
</blockquote>
<p>整体大概 5、6 轮，后面两轮都是 BOSS 面，几乎没有问技术问题，主要是聊聊我的个人项目。</p>
<p>我大概记得一些技术问题：</p>
<ul>
<li>k8s 相关的一些组件、Operator</li>
<li>Go 相关的放射、接口、如何动态修改类实现等等。</li>
<li>Java 相关就是一些常规的，主要是一些常用特性和 Go 做比较，看看对这两门语言的理解。</li>
</ul>
<p>其实这家公司是比较吸引我的，几乎就是围绕着开源社区做研发，工作中大部分时间也是在做开源项目，所以可以说是把我之前的业余爱好和工作结合起来了。</p>
<p>在贡献开源社区的同时还能收到公司的现金奖励，不可谓是双赢。</p>
<p>对我不太友好的是工作地在成都，入职后得成渝两地跑；而且在最终发 offer 的前两小时，公司突然停止 HC 了，这点确实没想到，所以阴差阳错的我也没有去成。</p>
<h2 id="第四家"><a href="#第四家" class="headerlink" title="第四家"></a>第四家</h2><p>第四家也就是我现在入职的公司，当时是我在招聘网站上看到的唯一一家做中间件的岗位，抱着试一试的态度我就投了。<br>面试过程也比较顺利，一轮同事面，一轮 Leader 面。</p>
<p>技术上也没有聊太多，后来我自己猜测大概率也和我的博客和 Github 有关。</p>
<hr>
<p>当然整个过程也有不太友好的经历，比如有一家成都的“知名”旅游公司；面试的时候那个面试官给我的感觉是压根没有看我的简历，所有的问题都是在读他的稿子，根本没有上下文联系。</p>
<p>还有一家更离谱，直接在招聘软件上发了一个加密相关的算法，让我解释下；因为当时我在外边逛街，所以没有注意到消息；后来加上微信后说我为什么没有回复，然后整个面试就在微信上打字进行。</p>
<p>其中问了一个很具体的问题，我记得好像是 MD5 的具体实现，说实话我不知道，从字里行间我感觉对方的态度并不友好，也就没有必要再聊下去；最后给我说之所以问这些，是因为看了我的博客后觉得我技术实力不错，所以对我期待较高；我只能是地铁老人看手机。</p>
<p>最终看来八股文确实是绕不开的，我也花了几天时间整理了 Java 和 Go 的相关资料；不过我觉得也有应对的方法。</p>
<p>首先得看你面试的岗位，如果是常见的业务研发，从招聘的 JD 描述其实是可以看出来的，比如有提到什么 Java 并发、锁、Spring等等，大概率是要问八股的；这个没办法，别人都在背你不背就落后一截了。</p>
<p>之后我建议自己平时在博客里多记录八股相关的内容，并且在简历上着重标明博客的地址，尽量让面试官先看到；这样先发制人，你想问的我已经总结好了😂。</p>
<p>但这个的前提是要自己长期记录，不能等到面试的时候才想起去更新，长期维护也能加深自己的印象，按照 “艾宾浩斯遗忘曲线” 进行复习。</p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p><img src="https://s2.loli.net/2023/06/19/haAR4PYjzFGlde2.png"><br>这是我当时记录的面试情况，最终根据喜好程度选择了现在这家公司。</p>
<p>不过也有一点我现在觉得但是考虑漏了，那就是行业前景。</p>
<p>现在的 C 端业务真的不好做，相对好做的是一些 B 端，回款周期长，同时不太吃现金流；这样的业务相对来说活的会久一些，我现在所在的公司就是纯做 C 端，在我看来也没有形成自己的护城河，只要有人愿意砸钱随时可以把你干下去。</p>
<p>加上现在的资本也不敢随意投钱，公司哪天不挣钱的话首先就是考虑缩减产研的成本，所以裁员指不定就会在哪一天到来。</p>
<p>现在庆幸的是入职现在这家公司也没有选错，至少短期内看来不会再裁员，同时我做的事情也是比较感兴趣的；和第三家有些许类似，只是做得是内部的基础架构，也需要经常和开源社区交流。</p>
<h1 id="面对裁员能做的事情"><a href="#面对裁员能做的事情" class="headerlink" title="面对裁员能做的事情"></a>面对裁员能做的事情</h1><p>说到裁员，这也是我第一次碰上，只能分享为数不多的经验。</p>
<h2 id="避免裁员"><a href="#避免裁员" class="headerlink" title="避免裁员"></a>避免裁员</h2><p>当然第一条是尽量避免进入裁员名单，这个我最近在播客 <a href="https://www.xiaoyuzhoufm.com/episode/647d43b41672628240e2187d">作为曾经的老板，我们眼中的裁员和那些建议</a> 讲到在当下的市场情况下哪些人更容易进入裁员名单：</p>
<ul>
<li>年纪大的，这类收入不低，同时收益也没年轻人高，确实更容易进入名单。</li>
<li>未婚女性，这点确实有点政治不正确，但确实就是现在的事实，这个需要整个社会，政府来一起解决。</li>
<li>做事本本分分，没有贡献也没出啥事故。</li>
<li>边缘业务，也容易被优化缩减成本。</li>
</ul>
<p>那如何避免裁员呢，当然首先尽量别和以上特征重合，一些客观情况避免不了，但我们可以在第三点上主动“卷”一下，当然这个的前提是你还想在这家公司干。</p>
<p>还有一个方法是提前向公司告知降薪，这点可能很多人不理解，因为我们大部分人的收入都是随着跳槽越来越高的；但这些好处是否是受到前些年互联网过于热门的影响呢？</p>
<p>当然个人待遇是由市场决定的，现在互联网不可否认的降温了，如果你觉得各方面呆在这家公司都比出去再找一个更好，那这也不失为一个方法；除非你有信心能找到一个更好的，那就另说了。</p>
<h1 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h1><p>我觉得只要一家公司只要有裁员的风声传出来后，即便是没被裁，你也会处于焦虑之中；要想避免这种焦虑确实也很简单，只要有稳定的被动收入那就无所谓了。</p>
<p>这个确实也是说起来轻松做起来难，我最近也一直在思考能不能在工作之余做一些小的 side project，这话题就大了，只是我觉得我们程序员先天就有自己做一个产品的机会和能力，与其把生杀大权给别人，不如握在自己手里。</p>
<p>当然这里得提醒下，在国内的企业，大部分老板都认为签了合同你的 24 小时都是他的，所以这些业务项目最好是保持低调，同时不能影响到本职工作。</p>
<blockquote>
<p>欢迎关注作者公众号于我交流🤗。</p>
</blockquote>
]]></content>
      <categories>
        <category>Interview</category>
        <category>Person</category>
      </categories>
  </entry>
  <entry>
    <title>如何成为一位「不那么差」的程序员</title>
    <url>/2018/08/12/personal/how-to-be-developer/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d23cabfaf.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已经记不清有多少读者问过：</p>
<blockquote>
<p>博主，你是怎么学习的？像我这样的情况有啥好的建议嘛？</p>
</blockquote>
<p>也不知道啥时候我居然成人生导师了。当然我不排斥这些问题，和大家交流都是学习的过程。</p>
<p>因此也许诺会准备一篇关于学习方面的文章；所以本文其实准备了很久，篇幅较长，大家耐心看完希望能有收获。</p>
<blockquote>
<p>以下内容仅代表我从业以来所积累的相关经验，我会从硬技能、软实力这些方面尽量阐述我所认为的 <code>“不那么差的程序员”</code> 应当做到哪些技能。</p>
</blockquote>
<span id="more"></span>

<h2 id="技能树"><a href="#技能树" class="headerlink" title="技能树"></a>技能树</h2><p>作为一名码代码的技术工人，怎么说干的还是技术活。</p>
<p>既然是技术活那专业实力就得过硬，下面我会按照相关类别谈谈我们应该掌握哪些。</p>
<h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><p>一名和电脑打交道的工种，计算机是我们赖以生存的工具。所以一些基础技能是我们应该和必须掌握的。</p>
<blockquote>
<p>比如网络相关的知识。</p>
</blockquote>
<p>其中就包含了 TCP 协议，它和 UDP 的差异。需要理解 TCP 三次握手的含义，<a href="http://t.cn/RDYBny8">拆、粘包</a>等问题。</p>
<p>当然上层最常见的 HTTP 也需要了解，甚至是熟悉。</p>
<p>这块推荐<a href="https://book.douban.com/subject/25863515/">《图解 HTTP》</a>一书。</p>
<blockquote>
<p>接着是操作系统相关知识。</p>
</blockquote>
<p>由于工作后你写的大部分代码都是运行在 Linux 服务器上，所以对于这个看它脸色行事主你也得熟悉才行。</p>
<p>比如进程、线程、内存等概念；服务器常见的命令使用，这个没啥窍门就是得平时多敲敲多总结。</p>
<p>我也是之前兼职了半年运维才算是对这一块比较熟悉。</p>
<p>Linux 这个自然是推荐业界非常出名的<a href="https://book.douban.com/subject/4889838/">《鸟哥的 Linux 私房菜》</a>。</p>
<p>当作为一个初学者学习这些东西时肯定会觉得枯燥乏味，大学一般在讲专业课之前都会有这些基础学科。我相信大部分同学应该都没怎么仔细听讲，因为确实这些东西就算是学会了记熟了也没有太多直接的激励。</p>
<p>但当你工作几年之后会发现，只要你还在做计算机相关的工作，这些都是绕不开的，当哪天这些知识不经意的帮助到你时你会庆幸当初正确的选择。</p>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p>接下来会谈到另一门枯燥的课程：数据结构。</p>
<p>这块当初在大学时也是最不受待见的一门课程，也是我唯一挂过的科目。</p>
<p>记得当时每次上课老师就让大家用 C 语言练习书上的习题，看着一个个拆开都认识的字母组合在一起就六亲不认我果断选择了放弃。</p>
<p>这也造成现在的我每隔一段时间就要看二叉树、红黑树、栈、队列等知识，加深印象。</p>
<p>算法这个东西我确实没有啥发言权，之前坚持刷了部分 <a href="https://github.com/crossoverJie/leetcode">LeetCode</a> 的题目也大多停留在初中级。</p>
<p>但像基本的查找、排序算法我觉得还是要会的，不一定要手写出来但要理解其思路。</p>
<p>所以<strong>强烈建议</strong>还在大学同学们积极参与一些 ACM 比赛，绝对是今后的加分利器。</p>
<p>这一块内容可能会在应届生校招时发挥较大作用，在工作中如果你的本职工作是 <code>Java Web</code> 开发的话，这一块涉猎的几率还是比较低。</p>
<p>不过一旦你接触到了模型设计、中间件、高效存储、查询等内容这些也是绕不过的坎。</p>
<p>这块内容和上面的计算机基础差不多，对于我们 Java 开发来说我觉得平时除了多刷刷 LeetCode 加深印象之外，在日常开发中每选择一个容器存放数据时想想为什么选它？有没有更好的存储方式？写入、查询效率如何？</p>
<p>同样的坚持下去，今后肯定收货颇丰。</p>
<p>同时推荐<a href="https://book.douban.com/subject/19952400/">《算法（第4版）》</a></p>
<h3 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h3><p>这里大部分的读者都是 Java 相关，所以这个强相关的技能非常重要。</p>
<p>Java 基础则是走向 Java 高级的必经之路。</p>
<p>这里抛开基本语法不谈，重点讨论实际工作中高频次的东西。</p>
<ul>
<li>基本容器，如：HashMap、ArrayList、HashSet、LinkedList 等，不但要会用还得了解其中的原理。这样才能在不同的场景选择最优的设计。</li>
<li>IO、NIO 也是需要掌握。日常开发中大部分是在和磁盘、网络（写日志、数据库、Redis）打交道，这些都是 IO 的过程。</li>
<li>常见的设计模式如：代理、工厂、回调、构建者模式，这对开发灵活、扩展性强的应用有很大帮助。</li>
<li>Java 多线程是非常重要的特性，日常开发很多。能理解线程模型、多线程优缺点、以及如何避免。</li>
<li>良好的单测习惯，很多人觉得写单测浪费时间没有意义。但正是有了单测可以提前暴露出许多问题，减少测试返工几率，提高代码质量。</li>
<li>良好的编程规范，这个可以参考《阿里巴巴 Java 开发手册》以及在它基础上优化的<a href="https://vipshop.github.io/vjtools/#/standard/">《唯品会 Java 手册》</a></li>
</ul>
<blockquote>
<p>　<a href="https://book.douban.com/subject/26880667/">《Java核心技术·卷 I》</a>值得推荐。</p>
</blockquote>
<h3 id="多线程应用"><a href="#多线程应用" class="headerlink" title="多线程应用"></a>多线程应用</h3><p>有了扎实的基础之后来谈谈多线程、并发相关的内容。</p>
<p>想让自己的 title 里加上“高级”两字肯定得经过并发的洗礼。</p>
<blockquote>
<p>这里谈论的并发主要是指单应用里的场景，多应用的可以看后文的分布式内容。</p>
</blockquote>
<p>多线程的出现主要是为了提高 CPU 的利用率、任务的执行效率。但并不是用了多线程就一定能达到这样的效果，因为它同时也带来了一些问题：</p>
<ul>
<li>上下文切换</li>
<li>共享资源</li>
<li>可见性、原子性、有序性等。</li>
</ul>
<p>一旦使用了多线程那肯定会比单线程的程序要变得复杂和不可控，甚至使用不当还会比单线程慢。所以要考虑清楚是否真的需要多线程。</p>
<p>会用了之后也要考虑为啥多线程会出现那样的问题，这时就需要理解内存模型、可见性之类的知识点。</p>
<p>同样的解决方式又有哪些？各自的优缺点也需要掌握。</p>
<p>谈到多线程就不得不提并发包下面的内容 <code>java.util.concurrent</code>。</p>
<p>最常用及需要掌握的有：</p>
<ul>
<li>原子类：用于并发场景的原子操作。</li>
<li>队列。常用于解耦，需要了解其实现原理。</li>
<li>并发工具，如 <a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/">ConcurrentHashMap</a>、<a href="https://crossoverjie.top/%2F2018%2F03%2F16%2Fjava-senior%2Fthread-communication%2F#CountDownLatch-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7">CountDownLatch</a> 之类的工具使用以及原理。</li>
<li><a href="https://crossoverjie.top/2018/07/29/java-senior/ThreadPool/">线程池使用</a>，以及相关原理。</li>
<li>锁相关内容：<a href="https://crossoverjie.top/2018/01/14/Synchronize/">synchronized</a>、<a href="https://crossoverjie.top/2018/01/25/ReentrantLock/">ReentrantLock</a> 的使用及原理。</li>
</ul>
<p>这一块的内容可以然我们知道写 JDK 大牛处理并发的思路，对我们自己编写高质量的多线程程序也有很多帮助。</p>
<p>推荐<a href="https://book.douban.com/subject/26591326/">《Java 并发编程的艺术》</a>很好的并发入门书籍。</p>
<h3 id="JVM-虚拟机"><a href="#JVM-虚拟机" class="headerlink" title="JVM 虚拟机"></a>JVM 虚拟机</h3><p>想要深入 Java ，JVM 是不可或缺的。对于大部分工作 1~3 年的开发者来说直接接触这一些内容是比较少的。</p>
<p>到了 3~5 年这个阶段就必须得了解了，以下内容我觉得是必须要掌握的：</p>
<ul>
<li>JVM 内存划分，<a href="https://crossoverjie.top/%2F2018%2F01%2F18%2FnewObject%2F">知道哪块内存存放哪些内容</a>；线程安全与否；内存不够怎么处理等。</li>
<li>不同情况的<a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/OOM-analysis.md#oom-%E5%88%86%E6%9E%90">内存溢出、栈溢出</a>，以及定位解决方案。</li>
<li><a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/GarbageCollection.md">分代的垃圾回收策略。</a></li>
<li><a href="https://crossoverjie.top/2018/07/08/java-senior/JVM-Troubleshoot/">线上问题定位及相关解决方案</a>。</li>
<li>一个类的加载、创建对象、垃圾回收、类卸载的整个过程。</li>
</ul>
<p>掌握这些内容真的对实际分析问题起到巨大帮助。</p>
<blockquote>
<p>　对此强力推荐<a href="https://book.douban.com/subject/24722612/">《深入理解Java虚拟机</a>》，这本书反反复复看过好几遍，每个阶段阅读都有不同的收获。</p>
</blockquote>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>做 WEB 应用开发的同学肯定要和数据库打不少交道，而且通常来说一个系统最先出现瓶颈往往都是数据库，说数据库是压到系统的最后一根稻草一点也不为过。</p>
<p>所以对数据库的掌握也是非常有必要。拿互联网用的较多的 MySQL 数据库为例，一些必须掌握的知识点：</p>
<ul>
<li>索引的数据结构及原理、哪些字段应当创建索引。</li>
<li>针对于一个慢 SQL 的优化思路。</li>
<li>数据库水平垂直拆分的方案，需要了解业界常用的 MyCAT、sharding-sphere 等中间件。</li>
</ul>
<p>常规使用可以参考《阿里巴巴 Java 开发手册》中的数据库章节，想要深入了解 MySQL 那肯定得推荐经典的<a href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a>一书了。</p>
<h3 id="分布式技术"><a href="#分布式技术" class="headerlink" title="分布式技术"></a>分布式技术</h3><p>随着互联网的发展，传统的单体应用越来越不适合现有场景。</p>
<p>因此分布式技术出现了，这块涵盖的内容太多了，经验有限只能列举我日常使用到的一些内容：</p>
<ul>
<li>首先是一些基础理论如：CAP 定理，知道分布式系统会带来的一些问题以及各个应用权衡的方式。</li>
<li>了解近些年大热的微服务相关定义、来源以及对比，有条件的可以阅读 <code>martin fowler</code> 的原文 <a href="https://martinfowler.com/articles/microservices.html">Microservices</a>，或者也可以搜索相关的国内翻译。</li>
<li>对 Dubbo、SpringCloud 等分布式框架的使用，最好是要了解原理。</li>
<li>接着要对分布式带来的问题提出解决方案。如<a href="https://crossoverjie.top/2018/03/29/distributed-lock/distributed-lock-redis/">分布式锁</a>、<a href="https://crossoverjie.top/2018/04/28/sbc/sbc7-Distributed-Limit/">分布式限流</a>、分布式事务、<a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/Cache-design.md">分布式缓存</a>、分布式 ID、消息中间件等。</li>
<li>也要了解一些分布式中的负载算法：权重、Hash、一致性 Hash、故障转移、<a href="https://crossoverjie.top/2018/04/07/algorithm/LRU-cache/">LRU</a> 等。</li>
<li>最好能做一个实践如：<a href="https://crossoverjie.top/%2F2018%2F05%2F07%2Fssm%2FSSM18-seconds-kill%2F">秒杀架构实践
</a></li>
</ul>
<p>之前有开源一个分布式相关解决组件：</p>
<p><a href="https://github.com/crossoverJie/distributed-redis-tool">https://github.com/crossoverJie/distributed-redis-tool</a></p>
<p>同时推荐一本入门科普<a href="https://book.douban.com/subject/25723064/">《大型网站技术架构》</a>，出版时间有点早，从中可以学习一些思路。</p>
<h3 id="懂点架构"><a href="#懂点架构" class="headerlink" title="懂点架构"></a>懂点架构</h3><p>相信大家都有一个架构师的梦想。</p>
<p>架构师给人的感觉就是画画图纸，搭好架子，下面的人员来添砖加瓦最终产出。</p>
<p>但其实需要的内功也要非常深厚，就上面列举的样样需要掌握，底层到操作系统、算法；上层到应用、框架都需要非常精通。（PPT 架构师除外）</p>
<p>我自身参与架构经验也不多，所以只能提供有限的建议。</p>
<p>首先分布式肯定得掌握，毕竟现在大部分的架构都是基于分布式的。</p>
<p>这其中就得根据 CAP 理论结合项目情况来选择一致性还是可用性，同时如何做好适合现有团队的技术选型。 </p>
<p>这里推荐下开涛老师的<a href="https://book.douban.com/subject/26999243/">《亿级流量网站架构核心技术》</a>，列举了很多架构实例，不过网上褒贬不一，但对于刚入门架构的能科普不少知识。</p>
<h2 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h2><p>谈完了技能树，现在来聊聊如何学习，这也是被问的最多的一个话题。</p>
<p>而关于学习讨论的最多的也是看视频还是看书？</p>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>不得不承认视频是获取知识最便捷的来源，毕竟包含了图、文、声。</p>
<p>大学几年时间其实我也没好好上专业课，我记得真正入门 Java 还是一个暑假花了两个月的时间天天在家里看 ”马士兵“ 老师的视频教程，当时的资源也很老了，记得好像是 07 年出的视频（用的还是 Google ）。</p>
<p>那段时间早起晚睡，每天学到东西之后马上实践，心里也很有成就感。后来开学之后一度成为同学们眼中的”学霸“人物。</p>
<blockquote>
<p>　现在打开我 12 年的电脑，硬盘里还躺着好几十 G 的教学视频。</p>
</blockquote>
<h3 id="看书"><a href="#看书" class="headerlink" title="看书"></a>看书</h3><p>工作后时间真的很宝贵，完全没有了学生生涯的想学就学的自由。所以现在我主要知识来源还是书籍。</p>
<p>这些是我最近看的书：</p>
<p><img src="https://i.loli.net/2018/08/12/5b6fd28576e0b.jpg" alt="IMG_2387.JPG"></p>
<p>看书又会涉及到电子书和纸质书的区别，我个人比较喜欢纸质书。毕竟我可以方便的记笔记以及可以随时切换章节。最主要的还是从小养成的闻书香的习惯。</p>
<h3 id="知识付费"><a href="#知识付费" class="headerlink" title="知识付费"></a>知识付费</h3><p>近几年知识付费越来越流行，许多大佬也加入了这个行列，人们也逐渐在习惯为知识去付费。</p>
<p>说实话写一好篇文章出一份视频都非常不容易，能有正向的激励，作者才能持续输出更好的内容。</p>
<p>这块我觉得国内做的比较好我也为之付费的有极客时间、大佬的知识星球等。</p>
<p>这三点没有绝对的好坏之分，其实可以看出我刚入门的时候看视频，工作之后看书及知识付费内容。</p>
<p>视频的好处是可以跟着里面老师的思路一步一步往下走，比较有音视频代入感强，就像学校老师讲课一样。</p>
<p>但由于内容较长使读者没法知晓其中的重点，甚至都不敢快进生怕错过了哪个重要知识，现在由于 IT 越来越火，网上的视频也很多导致质量参差不齐也不成体系。</p>
<p>而看书可以选择性的浏览自己感兴趣的章节，费解的内容也方便反复阅读</p>
<p>所以建议刚入门的同学可以看看视频跟着学，参与工作一段时间后可以尝试多看看书。</p>
<p>当然这不是绝对的，找到适合自己的学习方式就好。但不管是视频还是看书都要多做多实践。</p>
<h2 id="打造个人品牌"><a href="#打造个人品牌" class="headerlink" title="打造个人品牌"></a>打造个人品牌</h2><p>个人品牌看似很程序员这个职业不怎么沾边，但在现今的互联网时代对于每个人来说都很重要。</p>
<p>以往我们在写简历或是评估他人简历的时候往往不会想到去网络搜索他的个人信息，但在这个信息爆炸的时代你在网上留下的一点印记都能被发现。</p>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>因此我们需要维护好自己的名片，比如先搭建自己的个人博客。</p>
<p>博客的好处我也谈过几次了，前期关注人少没关系，重要的是坚持，当你写到 50、100篇文章后你会发现自己在这过程中一定是的到了提高。</p>
<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p>第二点就和技术人比较相关了：参与维护好自己的 GitHub。</p>
<p>由于 GitHub 的特殊属性，维护好后可以更好的打造个人品牌。</p>
<p><code>Talk is cheap. Show me the code</code> 可不是随便说说的。</p>
<p>想要维护好可以从几个方面着手：</p>
<ul>
<li>参与他人的项目，不管是代码库还是知识库都可以，先融入进社区。</li>
<li>发起自己的开源项目，不管是平时开发过程中的小痛点，还是精心整理的知识点都可以。</li>
</ul>
<p>但这过程中有几点还是要注意：</p>
<ul>
<li>我们需要遵守 GitHub 的社交礼仪。能用英文尽量就用英文，特别是在国外厂库中。</li>
<li>尽量少 push 一些与代码工作无关的内容，我认为这并不能提高自己的品牌。</li>
<li><code>别去刷 star</code>。这也是近期才流行起来，不知道为什么总有一些人会钻这种空子，刷起来的热度对自己并没有任何提高。</li>
</ul>
<p>这里有一篇国外大佬写的 <code>How to build your personal brand as a new developer</code> :</p>
<p><a href="https://medium.freecodecamp.org/building-your-personal-brand-as-a-new-web-developer-f6d4150fd217">https://medium.freecodecamp.org/building-your-personal-brand-as-a-new-web-developer-f6d4150fd217</a></p>
<h2 id="English-挺重要"><a href="#English-挺重要" class="headerlink" title="English 挺重要"></a>English 挺重要</h2><p>再来谈谈英语的重要性，我记得刚上大学时老师以及一些培训机构都会说：</p>
<blockquote>
<p>别怕自己英语差就学不了编程，真正常用的就那些词语。</p>
</blockquote>
<p>这句话虽没错，但英语在对 IT 这行来说还是有着极大的加分能力。</p>
<p>拿常见的 JDK 里的源码注释也是纯英文的，如果英语还不错的话，一些 Spring 的东西完全可以自学，直接去 Spring 官网就可以查看，甚至后面出的 SpringCloud，官方资料就是最好的教程。</p>
<p>再有就是平时查资料时，有条件的可以尝试用 <code>Google + 英文</code> 搜索，你会发现新的世界。</p>
<p>不然也不会有面向 <code>Google/Stack Overflow</code> 编程。</p>
<p>对于英语好的同学自然不怕，那不怎么好的咋办呢？</p>
<p>比如我，但我在坚持以下几点：</p>
<ul>
<li>所有的手机、电脑系统统统换成英语语言，养成习惯（不过也有尴尬的连菜单都找不到的情况）。</li>
<li>订阅一些英语周刊，比如 ”湾区日报“。</li>
<li>定期去类似于 <a href="https://medium.com/">https://medium.com/</a> 这样具有影响力的国外社区阅读文章。</li>
</ul>
<p>虽然现在我也谈不上多好，但目前我也在努力，希望大家也一起坚持。</p>
<p>推荐一本近期在看的书《程序员的英语》。</p>
<h2 id="保持竞争力"><a href="#保持竞争力" class="headerlink" title="保持竞争力"></a>保持竞争力</h2><p>技术这个行业发展迅速、变化太快，每年也都有无数相关行业毕业生加入竞争，稍不留神就会被赶上甚至超越。</p>
<p>所以我们无时无刻都得保持竞争力。</p>
<p>多的谈不上，我只能谈下目前我在做的事情：</p>
<ul>
<li><strong>打好基础</strong>。不是学了之后就忘了，需要不停的去看，巩固，基础是万变不离其宗的。</li>
<li>多看源码，了解原理，不要停留在调参侠的境界。</li>
<li>关注行业发展、新技术、新动态至少不能落伍了。</li>
<li>争取每周产出一篇技术相关文章。</li>
<li>积极参与开源项目。</li>
</ul>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://i.loli.net/2019/05/08/5cd1d24484825.jpg"></p>
<p>结合上文产出了一个思维导图更直观些。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文结合了自身的一些经验列举了一些方法，不一定对每位都有效需要自行判断。</p>
<p>也反反复复写了差不多一周的时间，希望对在这条路上和正在路上的朋友们起到一些作用。</p>
<p>大部分都只是谈了个思路，其实每一项单聊都能写很多。每个点都有推荐一本书籍，有更好建议欢迎留言讨论。</p>
<p>上文大部分的知识点都有维护在 GitHub 上，感兴趣的朋友可以自行查阅：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d24c1e913.jpg"></p>
<p><a href="https://github.com/crossoverJie/JCSprout">https://github.com/crossoverJie/JCSprout</a></p>
]]></content>
      <categories>
        <category>Person</category>
      </categories>
  </entry>
  <entry>
    <title>一个诡异的 Pulsar InterruptedException 异常</title>
    <url>/2023/02/23/pulsar/pulsar-interrupted/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/02/22/mQaCJMopS1WAjVN.png"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><img src="https://s2.loli.net/2023/02/22/Lw3UbtiJ1GKyg6x.png"><br>今天收到业务团队反馈线上有个应用往 Pulsar 中发送消息失败了，经过日志查看得知是发送消息时候抛出了 <code>java.lang.InterruptedException</code> 异常。</p>
<p>和业务沟通后得知是在一个 <code>gRPC</code> 接口中触发的消息发送，大约持续了半个小时的异常后便恢复正常了，这是整个问题的背景。</p>
<span id="more"></span>

<h1 id="前置排查"><a href="#前置排查" class="headerlink" title="前置排查"></a>前置排查</h1><p>拿到该问题后首先排查下是否是共性问题，查看了其他的应用没有发现类似的异常；同时也查看了 Pulsar broker 的监控大盘，在这个时间段依然没有波动和异常；</p>
<p>这样可以初步排除是 Pulsar 服务端的问题。</p>
<p>接着便是查看应用那段时间的负载情况，从应用 QPS 到 JVM 的各个内存情况依然没发现有什么明显的变化。</p>
<h1 id="Pulsar-源码排查"><a href="#Pulsar-源码排查" class="headerlink" title="Pulsar 源码排查"></a>Pulsar 源码排查</h1><p>既然看起来应用本身和 Pulsar broker 都没有问题的话那就只能从异常本身来排查了。</p>
<p>首先第一步要得知具体使用的是 <code>Pulsar-client</code> 是版本是多少，因为业务使用的是内部基于官方 SDK 封装 <code>springboot starter</code> 所以第一步还得排查这个 <code>starter</code> 是否有影响。</p>
<p>通过查看源码基本排除了 <code>starter</code> 的嫌疑，里面只是简单的封装了 <code>SDK</code> 的功能而已。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.apache.pulsar.client.api.PulsarClientException: java.util.concurrent.ExecutionException: org.apache.pulsar.client.api.PulsarClientException: java.lang.InterruptedException at org.apache.pulsar.client.api.PulsarClientException.unwrap(PulsarClientException.java:<span class="number">1027</span>) at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.send(TypedMessageBuilderImpl.java:<span class="number">91</span>) at </span><br><span class="line">java.base/java.lang.Thread.run(Thread.java:<span class="number">834</span>) Caused by: java.util.concurrent.ExecutionException: org.apache.pulsar.client.api.PulsarClientException: java.lang.InterruptedException at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:<span class="number">395</span>) </span><br><span class="line">at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:<span class="number">1999</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.send(TypedMessageBuilderImpl.java:<span class="number">89</span>) ... <span class="number">49</span> common frames omitted Caused by: org.apache.pulsar.client.api.PulsarClientException: java.lang.InterruptedException </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.canEnqueueRequest(ProducerImpl.java:<span class="number">775</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.sendAsync$original$BWm7PPlZ(ProducerImpl.java:<span class="number">393</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.sendAsync$original$BWm7PPlZ$accessor$i7NYMN6i(ProducerImpl.java) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl$auxiliary$EfuVvJLT.call(Unknown Source) </span><br><span class="line">at org.apache.skywalking.apm.agent.core.plugin.interceptor.enhance.InstMethodsInter.intercept(InstMethodsInter.java:<span class="number">86</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.sendAsync(ProducerImpl.java) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.internalSendAsync(ProducerImpl.java:<span class="number">292</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.internalSendWithTxnAsync(ProducerImpl.java:<span class="number">363</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.PartitionedProducerImpl.internalSendWithTxnAsync(PartitionedProducerImpl.java:<span class="number">191</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.PartitionedProducerImpl.internalSendAsync(PartitionedProducerImpl.java:<span class="number">167</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.sendAsync(TypedMessageBuilderImpl.java:<span class="number">103</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.send(TypedMessageBuilderImpl.java:<span class="number">82</span>) ... <span class="number">49</span> common frames omitted Caused by: java.lang.InterruptedException: <span class="literal">null</span></span><br><span class="line">at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">1343</span>) </span><br><span class="line">at java.base/java.util.concurrent.Semaphore.acquire(Semaphore.java:<span class="number">318</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.canEnqueueRequest(ProducerImpl.java:<span class="number">758</span>)</span><br></pre></td></tr></table></figure>

<p>接下来便只能是分析堆栈了，因为 Pulsar-client 的部分实现源码是没有直接打包到依赖中的，反编译的话许多代码行数对不上，所以需要将官方的源码拉到本地，切换到对于的分支进行查看。</p>
<blockquote>
<p>这一步稍微有点麻烦，首先是代码库还挺大的，加上之前如果没有准备好 Pulsar 的开发环境的话估计会劝退一部分人；但其实大部分问题都是网络造成的，只要配置一些 Maven 镜像多试几次总会编译成功。</p>
</blockquote>
<p>我这里直接将分支切换到 <code>branch-2.8</code>。</p>
<p>从堆栈的顶部开始排查 <code>TypedMessageBuilderImpl.java:91</code>：<br><img src="https://s2.loli.net/2023/02/23/Q53Vm1Fkau9Yn2c.png"><br>看起来是内部异步发送消息的时候抛了异常。</p>
<p>接着往下看到这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.InterruptedException </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.canEnqueueRequest(ProducerImpl.java:<span class="number">775</span>) at</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/02/23/LdJspv5CfaRm3EW.png"><br>看起来是这里没错，但是代码行数明显不对；因为 2.8 这个分支也是修复过几个版本，所以中间有修改导致代码行数与最新代码对不上也正常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">semaphore.get().acquire();</span><br></pre></td></tr></table></figure>
<p>不过初步来看应该是这行代码抛出的线程终端异常，这里看起来只有他最有可能了。</p>
<p><img src="https://s2.loli.net/2023/02/23/V3mFAuRKzgWnN5T.png"><br>为了确认是否是真的是这行代码，这个文件再往前翻了几个版本最终确认了就是这行代码没错了。</p>
<p>我们点开<code>java.util.concurrent.Semaphore#acquire()</code>的源码，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;has its interrupted status set on entry to this method; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while waiting</span></span><br><span class="line"><span class="comment"> * for a permit,</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread&#x27;s</span></span><br><span class="line"><span class="comment"> * interrupted status is cleared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted() ||</span><br><span class="line">        (tryAcquireShared(arg) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         acquire(<span class="literal">null</span>, arg, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0L</span>) &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>通过源码会发现 <code>acquire()</code> 函数确实会响应中断，一旦检测到当前线程被中断后便会抛出 <code>InterruptedException</code> 异常。</p>
<h1 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h1><p>所以问题的原因基本确定了，就是在 Pulsar 的发送消息线程被中断了导致的，但为啥会被中断还需要继续排查。</p>
<p>我们知道线程中断是需要调用 <code>Thread.currentThread().interrupt();</code> API的，首先猜测是否 Pulsar 客户端内部有个线程中断了这个发送线程。</p>
<p>于是我在 <code>pulsar-client</code> 这个模块中搜索了相关代码：<br><img src="https://s2.loli.net/2023/02/23/w6USaRvMqAIjCfm.png"><br>排除掉和 producer 不相关的地方，其余所有中断线程的代码都是在有了该异常之后继续传递而已；所以初步来看 pulsar-client 内部没有主动中断的操作。</p>
<p>既然 Pulsar 自己没有做，那就只可能是业务做的了？</p>
<p>于是我在业务代码中搜索了一下：<br><img src="https://s2.loli.net/2023/02/23/lVzJPf9ZWBGmuti.png"></p>
<p>果然在业务代码中搜到了唯一一处中断的地方，而且通过调用关系得知这段代码是在消息发送前执行的，并且和 Pulsar 发送函数处于同一线程。</p>
<p>大概的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).stream().map(e -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    ).collect(Collectors.toList()).forEach(f -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> f.get();</span><br><span class="line">            log.info(<span class="string">&quot;====&quot;</span> + integer);</span><br><span class="line">            <span class="keyword">if</span> (integer==<span class="number">3</span>)&#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="type">MessageId</span> <span class="variable">send</span> <span class="operator">=</span> producer.newMessage().value(msg.getBytes()).send();</span><br></pre></td></tr></table></figure>

<p>执行这段代码可以完全复现同样的堆栈。</p>
<p>幸好中断这里还打得有日志：</p>
<p><img src="https://s2.loli.net/2023/02/23/nHE4WcfaKD8iqSb.png"><br><img src="https://s2.loli.net/2023/02/23/4df5ehMBwj9DyQV.png"></p>
<p>通过日志搜索发现异常的时间和这个中断的日志时间点完全重合，这样也就知道根本原因了。</p>
<p>因为业务线程和消息发送线程是同一个，在某些情况下会执行 <code>Thread.currentThread().interrupt();</code>，其实单纯执行这行函数并不会发生什么，只要没有去响应这个中断，也就是 <code>Semaphore</code> 源码中的判断了线程中断的标记：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted() ||</span><br><span class="line">        (tryAcquireShared(arg) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         acquire(<span class="literal">null</span>, arg, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0L</span>) &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但恰好这里业务中断后自己并没有去判断这个标记，导致 Pulsar 内部去判断了，最终抛出了这个异常。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以归根结底还是这里的代码不合理导致的，首先是自己中断了线程但也没使用，从而导致有被其他基础库使用的可能，所以会造成了一些不可预知的后果。</p>
<p>再一个是不建议在业务代码中使用 <code>Thread.currentThread().interrupt();</code> 这类代码，第一眼根本不知道是要干啥，也不易维护。</p>
<p>其实本质上线程中断也是线程间通信的一种手段，有这类需求完全可以换为内置的 <code>BlockQueue</code> 这类函数来实现。</p>
]]></content>
      <categories>
        <category>Pulsar</category>
      </categories>
      <tags>
        <tag>InterruptedException</tag>
      </tags>
  </entry>
  <entry>
    <title>Pulsar负载均衡原理及优化</title>
    <url>/2023/02/07/pulsar/pulsar-load-banance/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/02/04/d4NqxaoulEXnr5s.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间我们在升级 Pulsar 版本的时候发现升级后最后一个节点始终没有流量。<br><img src="https://s2.loli.net/2023/02/07/ZwQ7sfVhuzb4tyv.jpg"></p>
<blockquote>
<p>虽然对业务使用没有任何影响，但负载不均会导致资源的浪费。</p>
</blockquote>
<p>和同事沟通后得知之前的升级也会出现这样的情况，最终还是人工调用 Pulsar 的 <code>admin API</code> 完成的负载均衡。</p>
<p>这个问题我尝试在 Google 和 Pulsar 社区都没有找到类似的，不知道是大家都没碰到还是很少升级集群。</p>
<blockquote>
<p>我之前所在的公司就是一个版本走到黑😂</p>
</blockquote>
<span id="more"></span>

<h1 id="Pulsar-负载均衡原理"><a href="#Pulsar-负载均衡原理" class="headerlink" title="Pulsar 负载均衡原理"></a>Pulsar 负载均衡原理</h1><p>当一个集群可以水平扩展后负载均衡就显得非常重要，根本目的是为了让每个提供服务的节点都能均匀的处理请求，不然扩容就没有意义了。</p>
<p>在分析这个问题的原因之前我们先看看 Pulsar 负载均衡的实现方案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Enable load balancer</span><br><span class="line">loadBalancerEnabled=true</span><br></pre></td></tr></table></figure>

<p>我们可以通过这个 broker 的这个配置来控制负载均衡器的开关，默认是打开。</p>
<p>但具体使用哪个实现类来作为负载均衡器也可以在配置文件中指定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Name of load manager to use</span><br><span class="line">loadManagerClassName=org.apache.pulsar.broker.loadbalance.impl.ModularLoadManagerImpl</span><br></pre></td></tr></table></figure>
<p>默认使用的是 <code>ModularLoadManagerImpl</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> LoadManager <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> PulsarService pulsar)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServiceConfiguration</span> <span class="variable">conf</span> <span class="operator">=</span> pulsar.getConfiguration();</span><br><span class="line">        <span class="comment">// Assume there is a constructor with one argument of PulsarService.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">loadManagerInstance</span> <span class="operator">=</span> Reflections.createInstance(conf.getLoadManagerClassName(),</span><br><span class="line">                Thread.currentThread().getContextClassLoader());</span><br><span class="line">        <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> LoadManager) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> (LoadManager) loadManagerInstance;</span><br><span class="line">            casted.initialize(pulsar);</span><br><span class="line">            <span class="keyword">return</span> casted;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> ModularLoadManager) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModularLoadManagerWrapper</span>((ModularLoadManager) loadManagerInstance);</span><br><span class="line">            casted.initialize(pulsar);</span><br><span class="line">            <span class="keyword">return</span> casted;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Error when trying to create load manager: &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If we failed to create a load manager, default to SimpleLoadManagerImpl.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleLoadManagerImpl</span>(pulsar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>broker</code> 启动时会从配置文件中读取配置进行加载，如果加载失败会使用 <code>SimpleLoadManagerImpl</code> 作为兜底策略。</p>
<p>当 broker 是一个集群时，只有 leader 节点的 broker 才会执行负载均衡器的逻辑。</p>
<blockquote>
<p>Leader 选举是通过 Zookeeper 实现的。</p>
</blockquote>
<p>默然情况下成为 Leader 节点的 broker 会每分钟读取各个 broker 的数据来判断是否有节点负载过高需要做重平衡。</p>
<p>而是否重平衡的判断依据是由 <code>org.apache.pulsar.broker.loadbalance.LoadSheddingStrategy</code> 接口提供的，它其实只有一个函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadSheddingStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Recommend that all of the returned bundles be unloaded.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A map from all selected bundles to the brokers on which they reside.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Multimap&lt;String, String&gt; <span class="title function_">findBundlesForUnloading</span><span class="params">(LoadData loadData, ServiceConfiguration conf)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据所有 broker 的负载信息计算出一个需要被 unload 的 broker 以及 bundle。</p>
<p>这里解释下 unload 和 bundle 的概念：</p>
<ul>
<li><code>bundle</code> 是一批 <code>topic</code> 的抽象，将 <code>bundle</code> 和 <code>broker</code> 进行关联后客户端才能知道应当连接哪个 broker；而不是直接将 topic 与 <code>broker</code> 绑定，这样才能实现海量 topic 的管理。</li>
<li>unload 则是将已经与 broker 绑定的 bundle 手动解绑，从而触发负载均衡器选择一台合适的 broker 重新进行绑定；通常是整个集群负载不均的时候触发。</li>
</ul>
<h2 id="ThresholdShedder-原理"><a href="#ThresholdShedder-原理" class="headerlink" title="ThresholdShedder 原理"></a>ThresholdShedder 原理</h2><p><code>LoadSheddingStrategy</code> 接口目前有三个实现，这里以官方默认的 <code>ThresholdShedder</code> 为例：<br><img src="https://s2.loli.net/2023/02/07/9xqNPs31RtHOC2u.jpg"></p>
<p>它的实现算法是根据带宽、内存、流量等各个指标的权重算出每个节点的负载值，之后为整个集群计算出一个平均负载值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 阈值</span><br><span class="line">loadBalancerBrokerThresholdShedderPercentage=10</span><br></pre></td></tr></table></figure>
<p>当集群中有某个节点的负载值超过平均负载值达到一定程度（可配置的阈值）时，就会触发 unload，以上图为例就会将最左边节点中红色部分的 bundle 卸载掉，然后再重新计算一个合适的 broker 进行绑定。</p>
<blockquote>
<p>阈值存在的目的是为了避免频繁的 unload，从而影响客户端的连接。</p>
</blockquote>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>当某些 topic 的流量突然爆增的时候这种负载策略确实可以处理的很好，但在我们集群升级的情况就不一定了。</p>
<p>假设我这里有三个节点：</p>
<ul>
<li>broker0</li>
<li>broker1</li>
<li>broker2</li>
</ul>
<p><img src="https://s2.loli.net/2023/02/07/9fpusPqY8BmkGdl.png"><br>集群升级时会从 <code>broker2-&gt;0</code> 进行镜像替换重启，假设在升级前每个 broker 的负载值都是 10。</p>
<ul>
<li>重启 broker2 时，它所绑定的 bundle 被 broker0&#x2F;1 接管。</li>
<li>升级 broker1 时，它所绑定的 bundle 又被 broker0&#x2F;2 接管。</li>
<li>最后升级 broker0, 它所绑定的 bundle 会被broker1&#x2F;2 接管。</li>
</ul>
<p>只要在这之后没有发生流量激增到触发负载的阈值，那么当前的负载情况就会一直保留下去，也就是 <code>broker0</code> 会一直没有流量。</p>
<p>经过我反复测试，现象也确实如此。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./pulsar-perf monitor-brokers --connect-string pulsar-test-zookeeper:2181</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/02/07/nDaOlsMprJ1hCwg.png"><br>通过这个工具也可以查看各个节点的负载情况</p>
<h1 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h1><p>这种场景是当前 <code>ThresholdShedder</code> 所没有考虑到的，于是我在我们所使用的版本 2.10.3 的基础上做了简单的优化：<br><img src="https://s2.loli.net/2023/02/07/iRkm2FaBz4wtbG6.png"></p>
<ul>
<li>当原有逻辑走完之后也没有获取需要需要卸载的 bundle，同时也存在一个负载极低的 broker 时(<code>emptyBundle</code>)，再触发一次 bundle 查询。</li>
<li>按照 broker 所绑定的数量排序，选择一个数量最多的 broker 的 第一个 bundle 进行卸载。</li>
</ul>
<p>修改后打包发布，再走一遍升级流程后整个集群负载就是均衡的了。<br><img src="https://s2.loli.net/2023/02/07/oCYzJBj7xavkLub.jpg"></p>
<p>但其实这个方案并不严谨，第二步选择的重点是筛选出负载最高的集群中负载最高的 bundle；这里只是简单的根据数量来判断，并不够准确。</p>
<p>正当我准备持续优化时，鬼使神差的我想看看 master 上有人修复这个问题没，结果一看还真有人修复了；只是还没正式发版。</p>
<p><a href="https://github.com/apache/pulsar/pull/17456">https://github.com/apache/pulsar/pull/17456</a></p>
<p><img src="https://s2.loli.net/2023/02/07/7TKxPv8BfblngRc.png"></p>
<p>整体思路是类似的，只是筛选负载需要卸载 bundle 时是根据 bundle 自身的流量来的，这样会更加精准。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不过看社区的进度等这个优化最终能用还不知道得多久，于是我们就自己参考这个思路在管理台做了类似的功能，当升级后出现负载不均衡时人工触发一个逻辑：</p>
<ul>
<li>系统根据各个节点的负载情况计算出一个负载最高的节点和 bundle 在页面上展示。</li>
<li>人工二次确认是否要卸载，确认无误后进行卸载。</li>
</ul>
<p>本质上只是将上述优化的自动负载流程改为人工处理了，经过测试效果是一样的。</p>
<p>Pulsar 整个项目其实非常庞大，有着几十上百个模块，哪怕每次我只改动一行代码准备发布测试时都得经过漫长的编译+ Docker镜像打包+上传私服这些流程，通常需要1~2个小时；但总的来说收获还是很大的，最近也在提一些 issue 和 PR，希望后面能更深入的参与进社区。</p>
]]></content>
      <categories>
        <category>Pulsar</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>Pulsar压测及优化</title>
    <url>/2023/01/16/pulsar/pulsar-perf-test/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/01/12/tpk3aXFYZ9BPJb8.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这段时间在做 MQ（Pulsar）相关的治理工作，其中一个部分内容关于消息队列的升级，比如：</p>
<ul>
<li>一键创建一个测试集群。</li>
<li>运行一批测试用例，覆盖我们线上使用到的功能，并输出测试报告。</li>
<li>模拟压测，输出测试结果。</li>
</ul>
<p>本质目的就是想直到新版本升级过程中和升级后对现有业务是否存在影响。</p>
<span id="more"></span>

<p>一键创建集群和执行测试用例比较简单，利用了 <code>helm</code> 和 <code>k8s client</code> 的 SDK 把整个流程串起来即可。</p>
<h1 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h1><p>其实稍微麻烦一点的是压测，<code>Pulsar</code> 官方本身是有提供一个压测工具；只是功能相对比较单一，只能对某批 topic 极限压测，最后输出测试报告。<br>最后参考了官方的压测流程，加入了一些实时监控数据，方便分析整个压测过程中性能的变化。</p>
<h2 id="客户端-timeout"><a href="#客户端-timeout" class="headerlink" title="客户端 timeout"></a>客户端 timeout</h2><p>随着压测过程中的压力增大，比如压测时间和线程数的提高，客户端会抛出发送消息 timeout 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.apache.pulsar.client.api.PulsarClientException$TimeoutException: </span><br><span class="line">The producer pulsar-test-<span class="number">212</span>-<span class="number">20</span> can not send message to the topic persistent:<span class="comment">//my-tenant/my-ns/perf-topic-0 within given timeout : createdAt 82.964 seconds ago, firstSentAt 8.348 seconds ago, lastSentAt 8.348 seconds ago, retryCount 1</span></span><br></pre></td></tr></table></figure>

<p>而这个异常在生产业务环境的高峰期偶尔也出现过，这会导致业务数据的丢失；所以正好这次被我复现出来后想着分析下产生的原因以及解决办法。</p>
<h2 id="源码分析客户端"><a href="#源码分析客户端" class="headerlink" title="源码分析客户端"></a>源码分析客户端</h2><p>既然是客户端抛出的异常所以就先看从异常点开始看起，其实整个过程和产生的原因并不复杂，如下图：</p>
<p><img src="https://s2.loli.net/2023/01/15/UvNGXC3iz9DjT5k.png"></p>
<p>客户端流程：</p>
<ol>
<li>客户端 producer 发送消息时先将消息发往本地的一个 pending 队列。</li>
<li>待 broker 处理完（写入 bookkeeper) 返回 ACK 时删除该 pending 队列头的消息。</li>
<li>后台启动一个定时任务，定期扫描队列头（头部的消息是最后写入的）的消息是否已经过期（过期时间可配置，默认30s)。</li>
<li>如果已经过期（头部消息过期，说明所有消息都已过期）则遍历队列内的消息依次抛出 <code>PulsarClientException$TimeoutException</code> 异常，最后清空该队列。</li>
</ol>
<p>服务端 broker 流程：</p>
<ol>
<li>收到消息后调用 bookkeeper API 写入消息。</li>
<li>写入消息时同时写入回调函数。</li>
<li>写入成功后执行回调函数，这时会记录一条消息的写入延迟，并通知客户端 ACK。</li>
<li>通过 broker metric 指标 <code>pulsar_broker_publish_latency</code> 可以获取写入延迟。</li>
</ol>
<p>从以上流程可以看出，如果客户端不做兜底措施则在第四步会出现消息丢失，这类本质上不算是 broker 丢消息，而是客户端认为当时 broker 的处理能力达到上限，考虑到消息的实时性从而丢弃了还未发送的消息。</p>
<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>通过上述分析，特别是 broker 的写入流程得知，整个写入的主要操作便是写入 bookkeeper，所以 bookkeeper 的写入性能便关系到整个集群的写入性能。</p>
<p>极端情况下，假设不考虑网络的损耗，如果 <code>bookkeeper</code> 的写入延迟是 0ms，那整个集群的写入性能几乎就是无上限；所以我们重点看看在压测过程中 <code>bookkeeper</code> 的各项指标。</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>首先是 CPU：<br><img src="https://s2.loli.net/2023/01/15/Et5urHVQ2xhP6Ja.png"></p>
<p>从图中可以看到压测过程中 CPU 是有明显增高的，所以我们需要找到压测过程中 bookkeeper 的 CPU 大部分损耗在哪里？</p>
<p>这里不得不吹一波阿里的 arthas 工具，可以非常方便的帮我们生成火焰图。</p>
<p><img src="https://s2.loli.net/2023/01/15/QCUTiXjcYeHG3LV.png"></p>
<p>分析火焰图最简单的一个方法便是查看顶部最宽的函数是哪个，它大概率就是性能的瓶颈。</p>
<p>在这个图中的顶部并没有明显很宽的函数，大家都差不多，所以并没有明显损耗 CPU 的函数。</p>
<p>此时在借助云厂商的监控得知并没有得到 CPU 的上限（limit 限制为 8核）。<br><img src="https://s2.loli.net/2023/01/15/8HAkq9ijQNdcFJX.png"></p>
<hr>
<p>使用 arthas 过程中也有个小坑，在 k8s 环境中有可能应用启动后没有成功在磁盘写入 pid ，导致查询不到 Java 进程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java -jar arthas-boot.jar</span><br><span class="line">[INFO] arthas-boot version: <span class="number">3.6</span><span class="number">.7</span></span><br><span class="line">[INFO] Can not find java process. Try to pass &lt;pid&gt; in command line.</span><br><span class="line">Please select an available pid.</span><br></pre></td></tr></table></figure>
<p>此时可以直接 <code>ps</code> 拿到进程 <code>ID</code>，然后在启动的时候直接传入 <code>pid</code> 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java -jar arthas-boot.jar <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>通常情况下这个 <code>pid</code> 是 1。</p>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>既然 CPU 没有问题，那就再看看磁盘是不是瓶颈；</p>
<p><img src="https://s2.loli.net/2023/01/15/PmMFyefXx23gDwC.png"></p>
<p>可以看到压测时的 IO 等待时间明显是比日常请求高许多，为了最终确认是否是磁盘的问题，再将磁盘类型换为 SSD 进行测试。</p>
<p><img src="https://s2.loli.net/2023/01/15/pqnFjJH3zbRkxIV.png"><br>果然即便是压测，SSD磁盘的 IO 也比普通硬盘的正常请求期间延迟更低。</p>
<p>既然磁盘 IO 延迟降低了，根据前文的分析理论上整个集群的性能应该会有明显的上升，因此对比了升级前后的消息 TPS 写入指标：</p>
<p><img src="https://s2.loli.net/2023/01/15/xofeW98vVnUzskY.png"></p>
<p>升级后每秒的写入速率由 40k 涨到 80k 左右，几乎是翻了一倍（果然用钱是最快解决问题的方式）；</p>
<blockquote>
<p>但即便是这样，极限压测后依然会出现客户端 timeout，这是因为无论怎么提高服务端的处理性能，依然没法做到没有延迟的写入，各个环节都会有损耗。</p>
</blockquote>
<h1 id="升级过程中的-timeout"><a href="#升级过程中的-timeout" class="headerlink" title="升级过程中的 timeout"></a>升级过程中的 timeout</h1><p>还有一个关键的步骤必须要覆盖：模拟生产现场有着大量的生产者和消费者接入收发消息时进行集群升级，对客户端业务的影响。</p>
<p>根据官方推荐的升级步骤，流程如下：</p>
<ul>
<li>Upgrade Zookeeper.</li>
<li>Disable autorecovery.</li>
<li>Upgrade Bookkeeper.</li>
<li>Upgrade Broker.</li>
<li>Upgrade Proxy.</li>
<li>Enable autorecovery.</li>
</ul>
<p>其中最关键的是升级 Broker 和 Proxy，因为这两个是客户端直接交互的组件。</p>
<p>本质上升级的过程就是优雅停机，然后使用新版本的 docker 启动；所以客户端一定会感知到 Broker 下线后进行重连，如果能快速自动重连那对客户端几乎没有影响。</p>
<p><img src="https://s2.loli.net/2023/01/15/1WjaiXs24dTwZ3S.png"><br>在我的测试过程中，2000左右的 producer 以 1k 的发送速率进行消息发送，在 30min 内完成所有组件升级，整个过程客户端会自动快速重连，并不会出现异常以及消息丢失。</p>
<p>而一旦发送频率增加时，在重启 Broker 的过程中便会出现上文提到的 timeout 异常；初步看起来是在默认的 30s 时间内没有重连成功，导致积压的消息已经超时。</p>
<p>经过分析源码发现关键的步骤如下：<br><img src="https://s2.loli.net/2023/01/15/V3lZeALxF7vhYHf.png"></p>
<p>客户端在与 Broker 的长连接状态断开后会自动重连，而重连到具体哪台 Broker 节点是由 <code>LookUpService</code> 处理的，它会根据使用的 topic 获取到它的元数据。</p>
<blockquote>
<p>理论上这个过程如果足够快，对客户端就会越无感。</p>
</blockquote>
<p>在元数据中包含有该 topic 所属的 bundle 所绑定的  Broker 的具体 IP+端口，这样才能重新连接然后发送消息。</p>
<blockquote>
<p>bundle 是一批 topic 的抽象，用来将一批 topic 与 Broker 绑定。</p>
</blockquote>
<p>而在一个 Broker 停机的时会自动卸载它所有的 bundle，并由负载均衡器自动划分到在线的 Broker 中，交由他们处理。</p>
<p>这里会有两种情况降低 LookUpSerive 获取元数据的速度：</p>
<p>因为所有的 Broker 都是 stateful 有状态节点，所以升级时是从新的节点开始升级，假设是<code>broker-5</code>，假设升级的那个节点的 bundle 切好被转移 <code>broker-4</code>中，客户端此时便会自动重连到 4 这个Broker 中。</p>
<p>此时客户端正在讲堆积的消息进行重发，而下一个升级的节点正好是 4，那客户端又得等待 bundle 成功 unload 到新的节点，如果恰好是 3 的话那又得套娃了，这样整个消息的重发流程就会被拉长，直到超过等待时间便会超时。</p>
<p>还有一种情况是 bundle 的数量比较多，导致上面讲到的 unload 时更新元数据到 zookeeper 的时间也会增加。</p>
<blockquote>
<p>所以我在考虑 Broker 在升级过程中时，是否可以将 unload 的 bundle 优先与 <code>Broker-0</code>进行绑定，最后全部升级成功后再做一次负载均衡，尽量减少客户端重连的机会。</p>
</blockquote>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>如果我们想要解决这个 timeout 的异常，也有以下几个方案：</p>
<ol>
<li>将 bookkeeper 的磁盘换为写入时延更低的 SSD，提高单节点性能。</li>
<li>增加 bookkeeper 节点，不过由于 bookkeeper 是有状态的，水平扩容起来比较麻烦，而且一旦扩容再想缩容也比较困难。</li>
<li>增加客户端写入的超时时间，这个可以配置。</li>
<li>客户端做好兜底措施，捕获异常、记录日志、或者入库都可以，后续进行消息重发。</li>
<li>为 bookkeeper 的写入延迟增加报警。</li>
<li>Spring 官方刚出炉的 Pulsar-starter 已经内置了 producer 相关的 metrics，客户端也可以对这个进行监控报警。</li>
</ol>
<p>以上最好实现的就是第四步了，效果好成本低，推荐还没有实现的都尽快 <code>try catch</code> 起来。</p>
<p>整个测试流程耗费了我一两周的时间，也是第一次全方位的对一款中间件进行测试，其中也学到了不少东西；不管是源码还是架构都对 <code>Pulsar</code> 有了更深入的理解。</p>
]]></content>
      <categories>
        <category>Pulsar</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 Pulsar 源码彻底解决重复消费问题</title>
    <url>/2023/02/27/pulsar/pulsar-repeat-consume/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/02/26/Oz94bQasM2Einok.png"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近真是和 <code>Pulsar</code> 杠上了，业务团队反馈说是线上有个应用消息重复消费。</p>
<p><img src="https://s2.loli.net/2023/02/26/c2eZuTPUvrlB1YF.png"></p>
<p>而且在测试环境是可以稳定复现的，根据经验来看一般能稳定复现的都比较好解决。</p>
<span id="more"></span>

<h1 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h1><p>接着便是定位问题了，根据之前的经验让业务按照这几种情况先排查一下：<br><img src="https://s2.loli.net/2023/02/26/IrvxGDQuaSt7AOE.png"></p>
<p>通过排查：1,2可以排除了。</p>
<ol>
<li>没有相关日志</li>
<li>存在异常，但最外层也捕获了，所以不管有无异常都会 ACK。</li>
</ol>
<p>第三个也在消费的入口和提交消息出计算了时间，最终发现都是在2s左右 ACK 的。</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> client.newConsumer()</span><br><span class="line">        .subscriptionType(SubscriptionType.Shared)</span><br><span class="line">        .enableRetry(<span class="literal">true</span>)</span><br><span class="line">        .topic(topic)</span><br><span class="line">        .ackTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">        .subscriptionName(<span class="string">&quot;my-sub&quot;</span>)</span><br><span class="line">        .messageListener(<span class="keyword">new</span> <span class="title class_">MessageListener</span>&lt;<span class="type">byte</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@SneakyThrows</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">received</span><span class="params">(Consumer&lt;<span class="type">byte</span>[]&gt; consumer, Message&lt;<span class="type">byte</span>[]&gt; msg)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;msg_id&#123;&#125;&quot;</span>,msg.getMessageId().toString());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                consumer.acknowledge(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure>

<p>那这就很奇怪了，因为代码里配置的 ackTimeout 是 30s，理论上来说是不会存在超时导致消息重发的。</p>
<p>为了排除是否是超时引起的，直接将业务代码注释掉了，等于是消息收到后立即就 ACK，经过测试发现这样确实就没有重复消费了。</p>
<p>为了再次确认是不是和 ackTimeout 有关，直接将 <code>.ackTimeout(30, TimeUnit.SECONDS)</code> 注释掉后测试，发现也没有重复消费了。</p>
<h1 id="确认原因"><a href="#确认原因" class="headerlink" title="确认原因"></a>确认原因</h1><p>既然如此那一定是和这个配置有关了，但看代码确实没有超时，为了定位具体原因只有去看 client 的源码了。</p>
<p>这里简单梳理下消息的消费的流程：</p>
<ol>
<li>根据 <code>.receiverQueueSize(1000)</code> 的配置，默认情况下 broker 会直接给客户端推送 1000 条消息。</li>
<li>客户端将这 1000 条消息保存到内部队列中。</li>
<li>如果使用同步消费 <code>receive()</code> 时，本质上就是去 <code>take</code> 这个内部队列。</li>
<li>如果是使用的是 <code>messageListener</code> 异步消费并配置 <code>ackTimeout</code>，每当从队列里获得一条消息后便会把这条消息加入 <code>UnAckedMessageTracker</code> 内部的一个时间轮中，定时检测顶部是否存在消息，如果存在则会触发重新投递。<br>4.1 加入时间轮后，<code>异步</code>调用我们自定义的事件，这个异步操作是提交到一个无界队列中由单个线程依次排队执行（这点是这次问题的关键）</li>
<li>业务 ACK 的时候会从时间轮中删除消息，所以如果消息 ACK 的足够快，在第四步就不会获取到消息进行重新投递。</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/26/2PuOadlU6oRqHVN.png"></p>
<p>整体流程如上图，代码细节如下图：<br><img src="https://s2.loli.net/2023/02/26/jMOqBUe912cdEWg.png"></p>
<p>所以问题的根本原因就是写入时间轮（<code>UnAckedMessageTracker</code>）开始倒计时的线程和回调业务逻辑的不是同一个线程。</p>
<p>如果业务执行耗时，等到消息从那个单线程的无界队列中取出来的时候很有可能已经过了 ackTimeou 的时间，从而导致了超时重发。</p>
<p>也就是用户所理解的 <code>ackTimeout</code> 周期（应该进入回调时候开始计时）和 SDK 实现的不一致造成的。</p>
<p>之后我再次确认同样的代码换为同步消费是没有问题的，不会导致重复消费：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> consumer.receive();</span><br><span class="line">            log.info(</span><br><span class="line">                    <span class="string">&quot;consumer Message received: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(msg.getData()) + msg.getMessageId().toString());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            consumer.acknowledge(msg);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看代码后发现同步代码的获取消息和加入 <code>UnAckedMessageTracker</code> 时间轮是同步的，也就不会出现超时的问题。<br><img src="https://s2.loli.net/2023/02/26/AUiDgXYO7QvINTF.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以其实 是<code>messageListener</code> 异步消费的 ackTimeout 的语义是有问题的，需要将加入 <code>UnAckedMessageTracker</code> 处移动到回调函数中同步调用。</p>
<p>我查看了最新的 <code>2.11.x</code> 版本的代码依然没有修复，正准备提个 PR 切换到 master 时才发现已经有相关的 PR 了，只是还没有发版。</p>
<p>修复的背景和思路也是类似的，具体参考：</p>
<p><a href="https://github.com/apache/pulsar/pull/18911">https://github.com/apache/pulsar/pull/18911</a></p>
<p>其实业务中并不推荐使用 ackTimeout 这个配置了，不好预估时间从而导致超时，而且我相信大部分业务配置好 <code>ackTImeout</code> 后直到后续出问题的时候才想起来要改。<br>所以干脆一开始就不要使用。</p>
<p>在 go 版本的 SDK 中直接废弃掉了这个参数，推荐使用 nack API 替换。</p>
<p><img src="https://s2.loli.net/2023/02/26/kQaZAcJi6WjNDXq.png"></p>
]]></content>
      <categories>
        <category>Pulsar</category>
      </categories>
      <tags>
        <tag>Consumer</tag>
      </tags>
  </entry>
  <entry>
    <title>Pulsar 入门及介绍</title>
    <url>/2021/04/18/pulsar/pulsar-start/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/04/22/u6VKbdFmzW4P8vD.jpg"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们最近在做新业务的技术选型，其中涉及到了对消息中间件的选择；结合我们的实际情况希望它能满足以下几个要求：</p>
<ul>
<li>友好的云原生支持：因为现在的主力语言是 <code>Go</code>，同时在运维上能够足够简单。</li>
<li>官方支持多种语言的 <code>SDK</code>：还有一些 <code>Python</code>、<code>Java</code> 相关的代码需要维护。</li>
<li>最好是有一些方便好用的特性，比如：延时消息、死信队列、多租户等。</li>
</ul>
<span id="more"></span>


<p>当然还有一些水平扩容、吞吐量、低延迟这些特性就不用多说了，几乎所有成熟的消息中间件都能满足这些要求。</p>
<p>基于以上的筛选条件，<code>Pulsar</code> 进入了我们的视野。</p>
<p>作为 <code>Apache</code> 下的顶级项目，以上特性都能很好的支持。</p>
<p>下面我们来它有什么过人之处。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="https://i.loli.net/2021/04/22/w5yoNzm1lCPQtgZ.jpg"></p>
<p>从官方的架构图中可以看出 <code>Pulsar</code> 主要有以下组件组成：</p>
<ol>
<li><code>Broker</code> 无状态组件，可以水平扩展，主要用于生产者、消费者连接；与 Kafka 的 broker 类似，但没有数据存储功能，因此扩展更加轻松。</li>
<li><code>BookKeeper</code> 集群：主要用于数据的持久化存储。</li>
<li><code>Zookeeper</code> 用于存储 <code>broker</code> 与 <code>BookKeeper</code> 的元数据。</li>
</ol>
<p>整体一看似乎比 Kafka 所依赖的组件还多，这样确实会提供系统的复杂性；但同样的好处也很明显。</p>
<p><code>Pulsar</code> 的存储于计算是分离的，当需要扩容时会非常简单，直接新增 <code>broker</code> 即可，没有其他的心智负担。</p>
<p>当存储成为瓶颈时也只需要扩容 <code>BookKeeper</code>，不需要人为的做重平衡，<code>BookKeeper</code> 会自动负载。</p>
<p>同样的操作，<code>Kafka</code> 就要复杂的多了。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="多租户"><a href="#多租户" class="headerlink" title="多租户"></a>多租户</h3><p>多租户也是一个刚需功能，可以在同一个集群中对不同业务、团队的数据进行隔离。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">persistent://core/order/create-order</span><br></pre></td></tr></table></figure>

<p>以这个 topic 名称为例，在 <code>core</code> 这个租户下有一个 <code>order</code> 的 <code>namespace</code>，最终才是 <code>create-order</code> 的 <code>topic</code> 名称。</p>
<p>在实际使用中租户一般是按照业务团队进行划分，<code>namespace</code> 则是当前团队下的不同业务；这样便可以很清晰的对 topic 进行管理。</p>
<p>通常有对比才会有伤害，在没有多租户的消息中间件中是如何处理这类问题的呢：</p>
<ol>
<li>干脆不分这么细，所有业务线混着用，当团队较小时可能问题不大；一旦业务增加，管理起来会非常麻烦。</li>
<li>自己在 topic 之前做一层抽象，但其实本质上也是在实现多租户。</li>
<li>各个业务团队各自维护自己的集群，这样当然也能解决问题，但运维复杂度自然也就提高了。</li>
</ol>
<p>以上就很直观的看出多租户的重要性了。</p>
<h3 id="Function-函数计算"><a href="#Function-函数计算" class="headerlink" title="Function 函数计算"></a>Function 函数计算</h3><p><code>Pulsar</code> 还支持轻量级的函数计算，例如需要对某些消息进行数据清洗、转换，然后再发布到另一个 topic 中。</p>
<p>这类需求就可以编写一个简单的函数，<code>Pulsar</code> 提供了 <code>SDK</code> 可以方便的对数据进行处理，最后使用官方工具发布到 <code>broker</code> 中。</p>
<p>在这之前这类简单的需求可能也需要自己处理流处理引擎。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>除此之外的上层应用，比如生产者、消费者这类概念与使用大家都差不多。</p>
<p>比如 <code>Pulsar</code> 支持四种消费模式：</p>
<ul>
<li><code>Exclusive</code>：独占模式，同时只有一个消费者可以启动并消费数据；通过 <code>SubscriptionName</code> 标明是同一个消费者），适用范围较小。</li>
<li><code>Failover</code> 故障转移模式：在独占模式基础之上可以同时启动多个 <code>consumer</code>，一旦一个 <code>consumer</code>  挂掉之后其余的可以快速顶上，但也只有一个 <code>consumer</code> 可以消费；部分场景可用。</li>
<li><code>Shared</code> 共享模式：可以有 N 个消费者同时运行，消息按照 <code>round-robin</code> 轮询投递到每个 <code>consumer</code> 中；当某个 <code>consumer</code> 宕机没有 <code>ack</code> 时，该消息将会被投递给其他消费者。这种消费模式可以提高消费能力，但消息无法做到有序。</li>
<li><code>KeyShared</code> 共享模式：基于共享模式；相当于对同一个<code>topic</code>中的消息进行分组，同一分组内的消息只能被同一个消费者有序消费。</li>
</ul>
<p>第三种共享消费模式应该是使用最多的，当对消息有顺序要求时可以使用 <code>KeyShared</code> 模式。</p>
<h2 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h2><p><img src="https://i.loli.net/2021/04/22/y4XQL2kOSgxojRT.jpg"></p>
<p>官方支持的 <code>SDK</code> 非常丰富；我也在官方的 <code>SDK</code> 的基础之上封装了一个内部使用的 <code>SDK</code>。</p>
<p>因为我们使用了 <a href="https://pkg.go.dev/go.uber.org/dig">dig</a> 这样的轻量级依赖注入库，所以使用起来大概是这个样子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">SetUpPulsar(lookupURL)</span><br><span class="line">container := dig.New()</span><br><span class="line">container.Provide(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> ConsumerConfigInstance &#123;</span><br><span class="line">	<span class="keyword">return</span> NewConsumer(&amp;pulsar.ConsumerOptions&#123;</span><br><span class="line">		Topic:            <span class="string">&quot;persistent://core/order/create-order&quot;</span>,</span><br><span class="line">		SubscriptionName: <span class="string">&quot;order-sub&quot;</span>,</span><br><span class="line">		Type:             pulsar.Shared,</span><br><span class="line">		Name:             <span class="string">&quot;consumer01&quot;</span>,</span><br><span class="line">	&#125;, ConsumerOrder)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">container.Provide(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> ConsumerConfigInstance &#123;</span><br><span class="line">	<span class="keyword">return</span> NewConsumer(&amp;pulsar.ConsumerOptions&#123;</span><br><span class="line">		Topic:            <span class="string">&quot;persistent://core/order/update-order&quot;</span>,</span><br><span class="line">		SubscriptionName: <span class="string">&quot;order-sub&quot;</span>,</span><br><span class="line">		Type:             pulsar.Shared,</span><br><span class="line">		Name:             <span class="string">&quot;consumer02&quot;</span>,</span><br><span class="line">	&#125;, ConsumerInvoice)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">container.Invoke(StartConsumer)</span><br></pre></td></tr></table></figure>

<p>其中的两个 <code>container.Provide()</code> 函数用于注入 <code>consumer</code> 对象。</p>
<p><code>container.Invoke(StartConsumer)</code>  会从容器中取出所有的 <code>consumer</code> 对象，同时开始消费。</p>
<p>这时以我有限的 <code>Go</code> 开发经验也在思考一个问题，在 <code>Go</code> 中是否需要依赖注入？</p>
<p>先来看看使用 <code>Dig</code> 这类库所带来的好处：</p>
<ul>
<li>对象交由容器管理，很方便的实现单例。</li>
<li>当各个对象之前依赖关系复杂时，可以减少许多创建、获取对象的代码，依赖关系更清晰。</li>
</ul>
<p>同样的坏处也有：</p>
<ul>
<li>跟踪阅读代码时没有那么直观，不能一眼看出某个依赖对象是如何创建的。</li>
<li>与 Go 所推崇的简洁之道不符。</li>
</ul>
<p>对于使用过 <code>Spring</code> 的 <code>Java</code> 开发者来说肯定直呼真香，毕竟还是熟悉的味道；但对于完全没有接触过类似需求的 <code>Gopher</code> 来说貌似也不是刚需。</p>
<p>目前市面上各式各样的 Go 依赖注入库层出不穷，也不乏许多大厂出品，可见还是很有市场的。</p>
<p>我相信有很多 <code>Gopher</code> 非常反感将 <code>Java</code> 中的一些复杂概念引入到 <code>Go</code>，但我觉得依赖注入本身是不受语言限制，各种语言也都有自己的实现，只是 Java 中的 Spring 不仅仅只是一个依赖注入框架，还有许多复杂功能，让许多开发者望而生畏。</p>
<p>如果只是依赖注入这个细分需求，实现起来并不复杂，并不会给带来太多复杂度。如果花时间去看源码，在理解概念的基础上很快就能掌握。</p>
<p>回到 <code>SDK</code> 本身来说，<code>Go</code> 的 <code>SDK</code> 现阶段要比 <code>Java</code> 版本的功能少（准确来说只有 <code>Java</code> 版的功能最丰富），但核心的都有了，并不影响日常使用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了 <code>Pulsar</code> 的一些基本概念与优点，同时顺便讨论一下 <code>Go</code> 的依赖注入；如果大家和我们一样在做技术选型，不妨考虑一下 <code>Pulsar</code>。</p>
<p>后续会继续分享 Pulsar 的相关内容，有相关经验的朋友也可以在评论区留下自己的见解。</p>
]]></content>
      <categories>
        <category>Pulsar</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>sbc(七)分布式限流</title>
    <url>/2018/04/28/sbc/sbc7-Distributed-Limit/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d53453d1c.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文接着上文<a href="http://crossoverjie.top/2017/08/11/sbc4/">应用限流</a>进行讨论。</p>
<p>之前谈到的限流方案只能针对于单个 JVM 有效，也就是单机应用。而对于现在普遍的分布式应用也得有一个分布式限流的方案。</p>
<p>基于此尝试写了这个组件：</p>
<p><a href="https://github.com/crossoverJie/distributed-redis-tool">https://github.com/crossoverJie/distributed-redis-tool</a></p>
<h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><p>以下采用的是</p>
<p><a href="https://github.com/crossoverJie/springboot-cloud">https://github.com/crossoverJie/springboot-cloud</a></p>
<p>来做演示。</p>
<p>在 Order 应用提供的接口中采取了限流。首先是配置了限流工具的 Bean:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLimitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;redis.limit&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JedisConnectionFactory jedisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisLimit <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RedisClusterConnection</span> <span class="variable">clusterConnection</span> <span class="operator">=</span> jedisConnectionFactory.getClusterConnection();</span><br><span class="line">        <span class="type">JedisCluster</span> <span class="variable">jedisCluster</span> <span class="operator">=</span> (JedisCluster) clusterConnection.getNativeConnection();</span><br><span class="line">        <span class="type">RedisLimit</span> <span class="variable">redisLimit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisLimit</span>.Builder&lt;&gt;(jedisCluster)</span><br><span class="line">                .limit(limit)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisLimit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在 Controller 使用组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisLimit redisLimit ;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CheckReqNo</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;OrderNoResVO&gt; <span class="title function_">getOrderNo</span><span class="params">(<span class="meta">@RequestBody</span> OrderNoReqVO orderNoReq)</span> &#123;</span><br><span class="line">    BaseResponse&lt;OrderNoResVO&gt; res = <span class="keyword">new</span> <span class="title class_">BaseResponse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//限流</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">limit</span> <span class="operator">=</span> redisLimit.limit();</span><br><span class="line">    <span class="keyword">if</span> (!limit)&#123;</span><br><span class="line">        res.setCode(StatusEnum.REQUEST_LIMIT.getCode());</span><br><span class="line">        res.setMessage(StatusEnum.REQUEST_LIMIT.getMessage());</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.setReqNo(orderNoReq.getReqNo());</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == orderNoReq.getAppId())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SBCException</span>(StatusEnum.FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">OrderNoResVO</span> <span class="variable">orderNoRes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderNoResVO</span>() ;</span><br><span class="line">    orderNoRes.setOrderId(DateUtil.getLongTime());</span><br><span class="line">    res.setCode(StatusEnum.SUCCESS.getCode());</span><br><span class="line">    res.setMessage(StatusEnum.SUCCESS.getMessage());</span><br><span class="line">    res.setDataBody(orderNoRes);</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了方便使用，也提供了注解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@ControllerLimit</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;OrderNoResVO&gt; <span class="title function_">getOrderNoLimit</span><span class="params">(<span class="meta">@RequestBody</span> OrderNoReqVO orderNoReq)</span> &#123;</span><br><span class="line">    BaseResponse&lt;OrderNoResVO&gt; res = <span class="keyword">new</span> <span class="title class_">BaseResponse</span>();</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该注解拦截了 http 请求，会再请求达到阈值时直接返回。</p>
<p>普通方法也可使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CommonLimit</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>会在调用达到阈值时抛出异常。</p>
<p>为了模拟并发，在 <a href="https://github.com/crossoverJie/springboot-cloud/blob/master/sbc-user/user/src/main/java/com/crossoverJie/sbcuser/controller/UserController.java#L72-L91">User</a> 应用中开启了 10 个线程调用 Order(<strong>限流次数为5</strong>) 接口(也可使用专业的并发测试工具 JMeter 等)。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;UserResVO&gt; <span class="title function_">getUserByFeign</span><span class="params">(<span class="meta">@RequestBody</span> UserReqVO userReq)</span> &#123;</span><br><span class="line">    <span class="comment">//调用远程服务</span></span><br><span class="line">    <span class="type">OrderNoReqVO</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderNoReqVO</span>();</span><br><span class="line">    vo.setAppId(<span class="number">1L</span>);</span><br><span class="line">    vo.setReqNo(userReq.getReqNo());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">Worker</span>(vo, orderServiceClient));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">UserRes</span> <span class="variable">userRes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserRes</span>();</span><br><span class="line">    userRes.setUserId(<span class="number">123</span>);</span><br><span class="line">    userRes.setUserName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">    userRes.setReqNo(userReq.getReqNo());</span><br><span class="line">    userRes.setCode(StatusEnum.SUCCESS.getCode());</span><br><span class="line">    userRes.setMessage(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userRes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OrderNoReqVO vo;</span><br><span class="line">    <span class="keyword">private</span> OrderServiceClient orderServiceClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(OrderNoReqVO vo, OrderServiceClient orderServiceClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vo = vo;</span><br><span class="line">        <span class="built_in">this</span>.orderServiceClient = orderServiceClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        BaseResponse&lt;OrderNoResVO&gt; orderNo = orderServiceClient.getOrderNoCommonLimit(vo);</span><br><span class="line">        logger.info(<span class="string">&quot;远程返回:&quot;</span> + JSON.toJSONString(orderNo));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了验证分布式效果启动了两个 Order 应用。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/08/5cd1d5375dfa5.jpg"></p>
<p>效果如下：<br><img src="https://i.loli.net/2019/05/08/5cd1d539c6b86.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d54041832.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d5431f7dd.jpg"></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>实现原理其实很简单。既然要达到分布式全局限流的效果，那自然需要一个第三方组件来记录请求的次数。</p>
<p>其中 Redis 就非常适合这样的场景。</p>
<ul>
<li>每次请求时将当前时间(精确到秒)作为 Key 写入到 Redis 中，超时时间设置为 2 秒，Redis 将该 Key 的值进行自增。</li>
<li>当达到阈值时返回错误。</li>
<li>写入 Redis 的操作用 Lua 脚本来完成，利用 Redis 的单线程机制可以保证每个 Redis 请求的原子性。</li>
</ul>
<p>Lua 脚本如下:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--lua 下标从 1 开始</span></span><br><span class="line"><span class="comment">-- 限流 key</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 限流大小</span></span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取当前流量大小</span></span><br><span class="line"><span class="keyword">local</span> curentLimit = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, key) <span class="keyword">or</span> <span class="string">&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> curentLimit + <span class="number">1</span> &gt; limit <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 达到限流大小 返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 没有达到阈值 value + 1</span></span><br><span class="line">    redis.call(<span class="string">&quot;INCRBY&quot;</span>, key, <span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">&quot;EXPIRE&quot;</span>, key, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> curentLimit + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>Java 中的调用逻辑:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.valueOf(System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (jedis <span class="keyword">instanceof</span> Jedis) &#123;</span><br><span class="line">        result = ((Jedis) <span class="built_in">this</span>.jedis).eval(script, Collections.singletonList(key), Collections.singletonList(String.valueOf(limit)));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jedis <span class="keyword">instanceof</span> JedisCluster) &#123;</span><br><span class="line">        result = ((JedisCluster) <span class="built_in">this</span>.jedis).eval(script, Collections.singletonList(key), Collections.singletonList(String.valueOf(limit)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//throw new RuntimeException(&quot;instance is error&quot;) ;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FAIL_CODE != (Long) result) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以只需要在需要限流的地方调用该方法对返回值进行判断即可达到限流的目的。</p>
<p>当然这只是利用 Redis 做了一个粗暴的计数器，如果想实现类似于上文中的令牌桶算法可以基于 Lua 自行实现。</p>
<h3 id="Builder-构建器"><a href="#Builder-构建器" class="headerlink" title="Builder 构建器"></a>Builder 构建器</h3><p>在设计这个组件时想尽量的提供给使用者清晰、可读性、不易出错的 API。</p>
<blockquote>
<p>比如第一步，如何构建一个限流对象。</p>
</blockquote>
<p>最常用的方式自然就是构造函数，如果有多个域则可以采用重叠构造器的方式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> a)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>缺点也是显而易见的：如果参数过多会导致难以阅读，甚至如果参数类型一致的情况下客户端颠倒了顺序，但不会引起警告从而出现难以预测的结果。</p>
<p>第二种方案可以采用 JavaBean 模式，利用 <code>setter</code> 方法进行构建:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">a.setA(a);</span><br><span class="line">a.setB(b);</span><br></pre></td></tr></table></figure>

<p>这种方式清晰易读，但却容易让对象处于不一致的状态，使对象处于线程不安全的状态。</p>
<p>所以这里采用了第三种创建对象的方式，构建器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLimit</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JedisCommands jedis;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FAIL_CODE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lua script</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String script;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">RedisLimit</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = builder.limit ;</span><br><span class="line">        <span class="built_in">this</span>.jedis = builder.jedis ;</span><br><span class="line">        buildScript();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * limit traffic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> if true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.valueOf(System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (jedis <span class="keyword">instanceof</span> Jedis) &#123;</span><br><span class="line">            result = ((Jedis) <span class="built_in">this</span>.jedis).eval(script, Collections.singletonList(key), Collections.singletonList(String.valueOf(limit)));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jedis <span class="keyword">instanceof</span> JedisCluster) &#123;</span><br><span class="line">            result = ((JedisCluster) <span class="built_in">this</span>.jedis).eval(script, Collections.singletonList(key), Collections.singletonList(String.valueOf(limit)));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//throw new RuntimeException(&quot;instance is error&quot;) ;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FAIL_CODE != (Long) result) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * read lua script</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildScript</span><span class="params">()</span> &#123;</span><br><span class="line">        script = ScriptUtil.getScript(<span class="string">&quot;limit.lua&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  the builder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&lt;T <span class="keyword">extends</span> <span class="title class_">JedisCommands</span>&gt;&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">T</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(T jedis)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.jedis = jedis ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">limit</span><span class="params">(<span class="type">int</span> limit)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.limit = limit ;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> RedisLimit <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisLimit</span>(<span class="built_in">this</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样客户端在使用时:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RedisLimit</span> <span class="variable">redisLimit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisLimit</span>.Builder&lt;&gt;(jedisCluster)</span><br><span class="line">                .limit(limit)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>

<p>更加的简单直接，并且避免了将创建过程分成了多个子步骤。</p>
<p>这在有多个构造参数，但又不是必选字段时很有作用。</p>
<p>因此顺便将分布式锁的构建器方式也一并更新了：</p>
<p><a href="https://github.com/crossoverJie/distributed-redis-tool#features">https://github.com/crossoverJie/distributed-redis-tool#features</a></p>
<blockquote>
<p>更多内容可以参考 Effective Java</p>
</blockquote>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>从上文可以看出，使用过程就是调用 <code>limit</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//限流</span></span><br><span class="line"> <span class="type">boolean</span> <span class="variable">limit</span> <span class="operator">=</span> redisLimit.limit();</span><br><span class="line"> <span class="keyword">if</span> (!limit)&#123;</span><br><span class="line">    <span class="comment">//具体限流逻辑</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>为了减少侵入性，也为了简化客户端提供了两种注解方式。</p>
<h4 id="ControllerLimit"><a href="#ControllerLimit" class="headerlink" title="@ControllerLimit"></a>@ControllerLimit</h4><p>该注解可以作用于 <code>@RequestMapping</code> 修饰的接口中，并会在限流后提供限流响应。</p>
<p>实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebIntercept</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(WebIntercept.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisLimit redisLimit;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">CustomInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CustomInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                 Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (redisLimit == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;redisLimit is null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">                <span class="type">HandlerMethod</span> <span class="variable">method</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line"></span><br><span class="line">                <span class="type">ControllerLimit</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getMethodAnnotation(ControllerLimit.class);</span><br><span class="line">                <span class="keyword">if</span> (annotation == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//skip</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">limit</span> <span class="operator">=</span> redisLimit.limit();</span><br><span class="line">                <span class="keyword">if</span> (!limit) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;request has bean limit&quot;</span>);</span><br><span class="line">                    response.sendError(<span class="number">500</span>, <span class="string">&quot;request limit&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是实现了 SpringMVC 中的拦截器，并在拦截过程中判断是否有使用注解，从而调用限流逻辑。</p>
<p><strong>前提是应用需要扫描到该类，让 Spring 进行管理。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value = &quot;com.crossoverjie.distributed.intercept&quot;)</span></span><br></pre></td></tr></table></figure>

<h4 id="CommonLimit"><a href="#CommonLimit" class="headerlink" title="@CommonLimit"></a>@CommonLimit</h4><p>当然也可以在普通方法中使用。实现原理则是 Spring AOP (SpringMVC 的拦截器本质也是 AOP)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(CommonAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisLimit redisLimit ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.crossoverjie.distributed.annotation.CommonLimit)&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;check()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (redisLimit == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;redisLimit is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">limit</span> <span class="operator">=</span> redisLimit.limit();</span><br><span class="line">        <span class="keyword">if</span> (!limit) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;request has bean limit&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;request has bean limit&quot;</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，也是在拦截过程中调用限流。</p>
<p>当然使用时也得扫描到该包:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value = &quot;com.crossoverjie.distributed.intercept&quot;)</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>限流</strong>在一个高并发大流量的系统中是保护应用的一个利器，成熟的方案也很多，希望对刚了解这一块的朋友提供一些思路。</p>
<p>以上所有的源码：</p>
<ul>
<li><a href="https://github.com/crossoverJie/distributed-redis-tool">https://github.com/crossoverJie/distributed-redis-tool</a></li>
<li><a href="https://github.com/crossoverJie/springboot-cloud">https://github.com/crossoverJie/springboot-cloud</a></li>
</ul>
<p>感兴趣的朋友可以点个 Star 或是提交 PR。</p>
<h3 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h3><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
]]></content>
      <categories>
        <category>sbc</category>
        <category>Distributed Tools</category>
      </categories>
      <tags>
        <tag>Distributed Limited</tag>
      </tags>
  </entry>
  <entry>
    <title>1K star+ 的项目是如何炼成的？</title>
    <url>/2018/05/15/skill/1Kstar/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/05/14/5af935ddc27e1.jpg" alt="alarm-clock-art-background-1037993.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先标题党一下，其实这篇文章主要是记录我的第二个过 <code>1K star</code> 的项目 <a href="https://github.com/crossoverJie/Java-Interview">Java-Interview</a>，顺便分享下其中的过程及经验。</p>
<p><img src="https://i.loli.net/2018/05/15/5af9b89e8bff8.png" alt="4.png"></p>
<h1 id="需求选择"><a href="#需求选择" class="headerlink" title="需求选择"></a>需求选择</h1><h2 id="Java-Interview"><a href="#Java-Interview" class="headerlink" title="Java-Interview"></a><a href="https://github.com/crossoverJie/Java-Interview">Java-Interview</a></h2><p>之所以要做这个项目主要是当时我正在面阿里的两个部门，非常幸运的是技术面都过了。其中的过程真是让我受益匪浅更是印象深刻，所以就想把期间的问题记录下来，加上自己的理解希望能对其他朋友起到帮助。</p>
<p>正好那段时间也是传说中的<code>金三银四</code>，所以无形中也叫顺势而为吧😏。</p>
<span id="more"></span>

<h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a><a href="https://github.com/crossoverJie/SSM">SSM</a></h2><p>这个项目的历史就比较悠久了，我看了下第一次提交差不多是两年前。</p>
<p>从这个名字也可以看出当初还是一个刚入行没多久的小菜鸟，因为之前在学 Java 的时候真的走了很多冤枉路，所以从头开始记录到现在整个过程所学到的东西，踩过的坑。</p>
<p>由于是面向小白，入门简单，上手较快也取的了一定的关注。</p>
<p>其实从这两个项目可以看出选择一个<strong>方向是很重要的</strong>。</p>
<p>以及该项目解决了什么问题，长期的规划，受众是哪些都要考虑清楚(怎么有点像做产品😅，其实这就是你自己的产品)。</p>
<p>比如这两个项目的目标：</p>
<ul>
<li>Java-Interview：持续更新面试问题，希望能让面试者知其然也知其所以然。</li>
<li>SSM：博主从小白到现在实际开发所遇到的问题记录，以及实战经验，现在逐渐会分享一些难点以及底层。受众大多是小白。</li>
</ul>
<h1 id="文档很重要"><a href="#文档很重要" class="headerlink" title="文档很重要"></a>文档很重要</h1><p>既然项目做出来是给人用的，那文档就显得至关重要了。</p>
<p>就像日常和前端怼接口时，有一个标准的文档输出比在白板上折腾半天要高的多。</p>
<p><img src="https://i.loli.net/2018/05/14/5af9491b5b119.png" alt="C0DA2F29-C334-46BC-8BED-14CD6B6C5349.png"></p>
<p>其实仔细观察 GitHub 上热门的项目，会发现他们的文档几乎都有一些共同结构：</p>
<ul>
<li>简单描述项目是干什么的。</li>
<li>快速启动。</li>
<li>最近更新。</li>
<li>Q&#x2F;A 答疑。</li>
<li>项目截图。</li>
</ul>
<p>主要目的就是要简单易读，快速上手。</p>
<p>然后把一些复杂的如系统设计、开发指南等可以放到 wiki 中。</p>
<blockquote>
<p>切记不要什么东西都往 README.MD 中写，保持一个简洁的文档可以加分哦。</p>
</blockquote>
<p>当然也可以在首页加入一些徽章如：</p>
<p><img src="https://i.loli.net/2018/05/15/5af9b66c55453.png" alt="3.png"></p>
<p>也能起到一些积极作用。</p>
<h1 id="积极推荐"><a href="#积极推荐" class="headerlink" title="积极推荐"></a>积极推荐</h1><p>代码质量这个就不多说了，这应该是最基本的要求。</p>
<p>俗话说：酒香不怕巷子深。</p>
<p>但对于做开源项目来说就不太适应了，当你幸辛苦苦做了一个自认为很不错的项目，结果一年过去了都无人问津，这不免会有点打击积极性。</p>
<p>所以适当的自我推荐就很有必要了。</p>
<p><img src="https://i.loli.net/2018/05/14/5af94d4c99929.png" alt="7D819139-647F-43E3-9DB2-AB80A3E6BC7B.png"></p>
<p><img src="https://i.loli.net/2018/05/14/5af94dd69c3ef.jpg" alt="1.jpg"></p>
<p><img src="https://i.loli.net/2018/05/14/5af94ea82ab5d.png" alt="2.png"></p>
<p>上图是我博客、项目的主要流量来源。</p>
<p>下面是我自身体验比较优质的推荐渠道：</p>
<ul>
<li><a href="https://toutiao.io/u/257810/">开发者头条</a>：由于截图的时候没有新发文章，之前那篇<a href="https://toutiao.io/posts/zavy6s">秒杀架构实践</a>发了之后博客 80% 的流量都是从头条过来的，而且质量很高，不得不点个赞。</li>
<li><a href="http://ifeve.com/author/crossoverjie/">并发编程网</a>: 并发编程网是由阿里大牛清英(买了那本《并发编程的艺术》就被圈粉了)创办的，其中的文章质量普遍较高(导致也会有一点写作门槛)。由于网站的流量也比较高，只要你的文章质量不错肯定会得到好处。</li>
<li><a href="https://juejin.im/user/576d4aaf7db2a20054ea4544">掘金</a>：掘金这两年也比较火，是专门做开发者内容的，也是网站流量不错。</li>
<li><a href="https://my.oschina.net/crossoverjie/blog">开源中国</a>：开源中国的博客也不错，自己也有代码托管，但我还是更喜欢用 GitHub，一般上了编辑推荐都会有不错的访问量。</li>
<li><a href="https://www.v2ex.com/member/crossoverJie">V2EX</a>：大名鼎鼎的 V 站，其实受众较少，正因为如此也形成了独有的文化，因此也是我每天比逛(摸鱼)的网站，由于受众大多是开发者所以也能得到很多有用的反馈。</li>
<li>大佬推荐：最快捷的方式其实就是口口相传，其中当然是大佬的效率最高。之前有个<a href="http://www.ityouknow.com/">纯洁的微笑</a>、<a href="http://blog.didispace.com/">程序猿DD</a> 都投过稿，也能带来不错的流量。</li>
<li><a href="https://www.jianshu.com/u/e2d07947c112">简书</a>:本来不想推荐简书的（之前的事件以及现在鸡汤太多），但是流量还可以，现在就纯粹当做博客备份的工具了。</li>
</ul>
<blockquote>
<p>坚持下来之后会发现：只要自己坚持、保证质量最后会形成自己的阅读圈子，到后面甚至会有其他朋友主动来找你分享，这些都是自我提升的过程。</p>
</blockquote>
<h1 id="不忘初心"><a href="#不忘初心" class="headerlink" title="不忘初心"></a>不忘初心</h1><p>当初做的第一个开源项目就是 <a href="https://github.com/crossoverJie/SSM">SSM</a>，完全受够学习时找资料的痛苦，也得到了很多人的帮助，所以才有了该项目。</p>
<p>平时工作中或多或少都会用到开源项目，其实我们大部分人也写不出 Spring、Guava 这样的项目，只是再这过程中可以参与进去，收获也是非常丰富的。</p>
<p>两年前参与开源到现在有收到面试邀请、物质奖励这些都是正面积极的，可以鼓励我们接着做下去。</p>
<p>但最多的还是在这过程中结识了很多朋友，技术能力提升也很明显，这些都是保持自我可持续发展的必要条件。</p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>年轻人的第一篇博客</title>
    <url>/2019/05/24/skill/first-blog/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/24/5ce6cbbd948a368011.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这篇文章的前因是有位读者留言提到了相关的话题，其实在之前有一篇《<a href="https://crossoverjie.top/2018/08/12/personal/how-to-be-developer/#%E5%8D%9A%E5%AE%A2">如何成为一位「不那么差」的程序员》</a>时有简要提到但没有细说；这次就借这个机会好好聊聊这个事情的前因后果。</p>
<span id="more"></span>

<p><img src="https://i.loli.net/2019/05/24/5ce6cbbe1ef4736486.jpg"></p>
<h1 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h1><p><code>为什么要写博客？</code> 我觉得大部分人应该都知道<code>标准</code>答案。</p>
<p><img src="https://i.loli.net/2019/05/24/5ce6cbbe5808321527.jpg"><br><img src="https://i.loli.net/2019/05/24/5ce6cbbe8f38783046.jpg"></p>
<p>翻了下记录，我从 16 年四月份至今写了三年的博客，产出了 100 多篇；现在让我回忆当初为啥要写博客，我还记得那时作为一个初入职场的小菜鸟有许多问题、资料都要在网上查找；那时候我就发现不少答案网上已经有现成的了，而且有些大牛还有着酷炫的个人网站。</p>
<p>这事对我冲击挺大的，主要有以下几点：</p>
<ul>
<li>我能在别人博客上查到我想要的东西，那是否我也可以输出一些东西被被人搜到呢？</li>
<li>这样是否对方便记录我自己的问题（高中时的错题本）甚至对今后面试有好处？</li>
<li>酷炫的博客页面又是一个展示（装B）自己的机会。</li>
</ul>
<p>我相信大部分人无非也是这几个原因吧，具体是哪个原因我觉得大家首先要想清楚。</p>
<p>因为如果是前面两个原因，也许后面会因为博客内容帮助到自己的同时也帮助到他人，让自己更有坚持下去的动力。</p>
<p>如果是最后一个，大概率的会因为自己不想折腾而慢慢放弃。</p>
<p>我现在主要还是前面两个原因而继续坚持，毕竟我的博客外观已经几年没更新了🤣。</p>
<h1 id="你适合写博客嘛？"><a href="#你适合写博客嘛？" class="headerlink" title="你适合写博客嘛？"></a>你适合写博客嘛？</h1><p>目的搞清楚之后再来看看<code>你适合写博客嘛</code>？不过我觉得这个问题改为 <code>你会坚持写博客嘛？</code> 可能更直接一些。</p>
<p>因为我认为写博客最大的阻碍就是【<strong>坚持</strong>】二字了。</p>
<p>我见过不少博客写的很棒的大牛突然之间停更，至今也没有恢复，其实挺可惜的。</p>
<p>再讨论这个问题之前首先看两个问题：</p>
<ul>
<li>做什么事情自己坚持的最久？</li>
<li>什么原因导致没有坚持下去？</li>
</ul>
<p>我还记得大学期间我和另外两个小伙伴组建了一个篮球小团伙，每天中午、晚上都会自觉的约上一起练球直到后来毕业。</p>
<p>现在想想当初为啥会坚持呢？我觉得核心要求有几个：</p>
<ul>
<li>一个是【<strong>热爱</strong>】，当初我们是真的热爱这个运动，每天不打场球真的浑身不舒服。</li>
<li>二是有【<strong>产出</strong>】，大学那阵由于每天我们都训练进步还是非常明显的，在学校球场基本上是横着走；以致于在球场的知名度也越来越高，当然在虚荣心的驱使下更会拼命练球。</li>
</ul>
<p>所以回归到写博客这件事情上来，我觉得只要你对这件事是喜欢的，有激情，同时写出的东西对你有正向激励就会让自己有坚持下去的理由。</p>
<hr>
<p>第二个问题：什么原因导致没有坚持下去？</p>
<p>就像我去年立下的健身 flag 一样，现在也放弃了。</p>
<p>归根到底还是因为太懒了，锻炼多麻烦，站着不如坐着，坐着不如躺着；同时效果也不明显导致非常容易放弃。</p>
<p>换到写博客这事上来也是一样的。</p>
<p>写一篇不吹水的文章并没有想象那么容易，需要找资料、论证、写提纲、码字等一系列过程。</p>
<p>和健身一样也是一个长期同时效果不明显的工程，所以弃坑率很高。</p>
<p>鉴于这些，我觉得你具备这几点作为一个<code>长更</code>（长期更新）型选手是没有问题的。</p>
<ul>
<li>热爱技术、文字表达，而不是短时间的头脑发热。</li>
<li>写的过程中自己能得到积累提高，而不是每天记录<strong>流水账</strong>。</li>
<li>要有毅力坚持下去，这个就比较玄学了；通常前面两项做的好这个毅力就会随之增强。</li>
</ul>
<p>所以自己是否适合写博客应该有自己的判断了。</p>
<h1 id="会遇到哪些问题"><a href="#会遇到哪些问题" class="headerlink" title="会遇到哪些问题"></a>会遇到哪些问题</h1><p>我还得要给大家泼盆凉水，现在来聊聊写博客过程中可能会碰到哪些问题，不一定都对但至少都是我遇到过的。</p>
<h2 id="原创、抄袭"><a href="#原创、抄袭" class="headerlink" title="原创、抄袭"></a>原创、抄袭</h2><p>首先第一个就是 <strong>抄袭</strong> 问题；</p>
<p>随着这几年互联网的发展，自媒体也越来越多，这也包括了大量的技术自媒体。</p>
<p>也许哪天你会收到某平台向你发出申请，想要转载你的文章；自己在得意之余还得要谨慎对待以下几件事情：</p>
<ul>
<li>对方是否标明出处，包括但不限于二维码、用户ID、网站地址等。</li>
<li>是否<strong>明显</strong>标注出处；不要小瞧这个，很多鸡贼的作者确实也会标明出处，但你不拿出<code>老花镜</code>来看是根本发现不了的。（这类撕 B 事件不止听说一两次）</li>
<li>对于自己（这里的自己指申请者）需要声明原创的要求是否提供了稿费？写一篇原创文章是很费精力的，该拿的一定不能亏了自己。</li>
</ul>
<p>这些其实都还好，还有一些不知名的平台或作者会神不知鬼不觉的转载你的内容，完全不提出处这件事。</p>
<p>甚至有些还会修改你的部分内容，转换为他自己的一部分然后发表在一些类似于“头条号、百家号”之类的自媒体平台上；也就是大家常说的“洗搞”。</p>
<p>我就不止遇到过一次，刚开始还很气愤上去理论；态度好的会道个歉然后删除文章，态度不好的甚至还会和你互喷让你拿出证据证明这是你写的。</p>
<p><img src="https://i.loli.net/2019/05/24/5ce6cbbf0079381378.jpg"></p>
<p>经过 N 多次的斗智斗勇后现在即便是有朋友给我说 XX 平台上好像有你的内容，我也非常淡定，啥大风大浪没有见过。</p>
<p>换个角度想，别人转载不注明出处、甚至抄袭不也侧面证明自己写的还不错嘛？开个玩笑，其实主要原因还是当前的写作环境复杂，没有某一个大的平台来约束所有的产出内容；在这样的客观条件下我们能做的也只有产出优质的内容扩大自己的影响力从而让某些抄袭者不敢轻举乱动。</p>
<h2 id="产出瓶颈"><a href="#产出瓶颈" class="headerlink" title="产出瓶颈"></a>产出瓶颈</h2><p>还有一个问题也挺突出，那就是产出问题。</p>
<p>有段时间我甚至能做到一个月 6 篇原创，当然也有一个月憋出一篇的尴尬。</p>
<p>这也是没办法的事情，内容产出不像是工地搬砖，花时间就会有效果。</p>
<p>这个问题我相信 99% 写原创的作者都会碰到，根据我目前的经验还是有几个小 <code>tips</code> 可以提供给大家：</p>
<ul>
<li>平时一定要多积累，不管是工作中的案例还是业余学到的小技巧都可以；这样不用等到想写点什么的时候没有灵感的尴尬。</li>
<li>实在不知道写啥时切莫强行输出，也许这一篇文章就能把你之前积累的口碑破坏。</li>
<li>没有题材时不如多翻翻之前写的东西，也许就有了新的灵感。</li>
</ul>
<h1 id="能赚钱嘛？"><a href="#能赚钱嘛？" class="headerlink" title="能赚钱嘛？"></a>能赚钱嘛？</h1><p>问题讲了这么多来看看现实的问题，这事能赚钱嘛？</p>
<p>有这个想法也没错，毕竟要花费自己大量的业余时间及精力。</p>
<p>首先可以很明确的告诉大家：<strong>做的好</strong>是可以有收入的。</p>
<p>怎么来定义这个做的好呢？直接点说就是有流量，一天多少 PV、UV。</p>
<p>现在只要有流量那就自然能有转化，我想大家应该也猜到了，这样的转化通常是指推广、广告的转化。</p>
<p>比如当某天你的个人博客的 PV 达到 1000 或者某个数值后被搜索引擎录入，自然就会有人找你投放广告。</p>
<p>我这个博客做了三年多现在也才 2000 多点的 PV，虽说也有人找我投放推广，不过我一直觉得博客比较私人还是单纯点，所以一直也没接。</p>
<p>但是像阮一峰这样的个人博客流量是非常大的，所以也会有专门的广告位出售。</p>
<p>所以归根结底的问题是如何才能获取到足够多的流量，我觉得还是两点：</p>
<ul>
<li>足够靠谱的质量，有了好的产出后才会吸引更多人从而形成裂变效应。</li>
<li>足够的曝光，酒香也怕巷子深；这点会在后面详细说到。</li>
</ul>
<h1 id="博客平台的选择"><a href="#博客平台的选择" class="headerlink" title="博客平台的选择"></a>博客平台的选择</h1><p>万事俱备，博客也写好了，如何来发布增加我们刚才提到的曝光呢？</p>
<p>这时就要看如何选择博客平台了，目前我收集到的有以下方案：</p>
<ul>
<li>第三方博客平台，如博客园、CSDN、简书、掘金等。</li>
<li>自建博客 Hexo、Ghost、Wordpress。</li>
<li>GitHub Issue。</li>
<li>公众号</li>
</ul>
<p>下面总结了各自的优缺点：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第三方平台</td>
<td align="center">通常都有良好的曝光率以及完整的审核体系，优秀的博客官方推荐后可以增加曝光量。</td>
<td align="center">内容会有审查，同时某些平台的机制比较恶心，有些平台还不支持 <code>Markdown</code>，这里就不点名了。（其实也不算啥缺点）</td>
</tr>
<tr>
<td align="center">自建博客</td>
<td align="center">内容随意，自己管控，不受限制。</td>
<td align="center">除非已经很知名了，不然很难获取到曝光量，自己不做备份数据还容易丢失。同时可能还需要额外的服务器维护费用（GitHub Pages 服务除外）。</td>
</tr>
<tr>
<td align="center">GitHub Issues</td>
<td align="center">这个也受到广大开发者的喜欢，对于 GitHub 重度使用者来说没有任何使用负担，符合开发者平时讨论 Issues 的逻辑，同时数据安全可以得到 GitHub 的保证，内容也比较自由。</td>
<td align="center">毕竟依赖于 GitHub，一旦它除了什么问题那就惨了，同时访问速度也有限制，国内的搜索引擎难以收录。</td>
</tr>
<tr>
<td align="center">公众号</td>
<td align="center">这个单独放一类，其实也属于第三方平台；但这几年公众号确实太火了，已经形成了独立的生态圈子。好处：自带流量主，可以对号主带来一些额外收入，同时接推广的几率会高很多</td>
<td align="center">本身平台是封闭的，很难传播到圈外，不过如果已经在公众号有足够影响力了也不在乎这些。</td>
</tr>
</tbody></table>
<p>对比了四种方案来看看我是如何使用的。</p>
<p>其实这几种都用到了。</p>
<h2 id="第三方平台"><a href="#第三方平台" class="headerlink" title="第三方平台"></a>第三方平台</h2><p>比如第三方平台，几乎目前市面上叫得上号可以写博客的地方我都会去掺和一下，这样有几个好处：</p>
<ul>
<li>相当于数据异地容灾了，互相备份。</li>
<li>曝光率也会得到提升。</li>
<li>也能降低被抄袭盗版的可能，可以直接在平台举报他。</li>
</ul>
<p>下面就是我常用的一些平台。</p>
<p><img src="https://i.loli.net/2019/05/24/5ce6cbbf4c47d38383.jpg"></p>
<h2 id="自建博客"><a href="#自建博客" class="headerlink" title="自建博客"></a>自建博客</h2><p>自建博客目前是使用的是 Hexo,用它来生成静态页面还是非常方便的，依赖于 <code>GitHub Pages</code> 服务甚至都不要额外的服务器，只是访问速度在国内确实有点捉急。</p>
<p><code>Hexo</code> 其实也有着丰富的主题，现在确实懒得折腾，我这主题都用了几年了。</p>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>其实我并没有用 <code>GitHub Issues</code> 来搭博客，只是将博客的原始文件用 <code>GitHub</code> 来备份了，由于内容是采用 Markdown 编写的，所以 GitHub 可以直接解析，这样在这个仓库里其实也可以直接当做博客查看。</p>
<p>类似于这样：</p>
<p><img src="https://i.loli.net/2019/05/24/5ce6cbbf9f54d88838.jpg"></p>
<p>所以也非常推荐大家博文都用 <code>Markdown</code> 来书写，这样还可以一键复制到不同的平台。</p>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>我大概是从去年 3 月份开始做公众号的，其实前期也就是把博客同步一份过来，几乎没怎么运营。</p>
<p>到现在也算是从 0 到 1 ，不过经验还是比较少，这个要做好还是要花费许多精力，我这刚入门的菜鸟还不能给大家分享太多。</p>
<p>不过有一说一，公众号做好后接到推广的概率会比其他平台大的多，我也见过好几个大佬离职后专心做公号的（当然自身量得起来）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>扯了这么多，有困难也有好处。</p>
<p>我也知道不少人都想着下周我一定要写一篇，往往这事在下周还会想一遍；所以别再做死循环递归了，总有一天会 <code>StackOverFlow</code> 的。</p>
<p>赶紧拿起键盘开码吧，欢迎大家在评论区留下自己的博客😏。</p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>什么样的简历不会被丢进回收站</title>
    <url>/2018/08/21/skill/resume/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d24dd66d9.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从去年校招开始到现在负责部门的面试，从我手上流走的简历多多少少也有上百封了。</p>
<p>同时最近秋招又要开始了，就想着把我这一年来筛选简历的经验分享给大家，多少还是能提高一些命中率。</p>
<h2 id="突出优势"><a href="#突出优势" class="headerlink" title="突出优势"></a>突出优势</h2><p><strong>「简历」</strong>自然是突出<strong>简单</strong>的好，相信大部分面试官都不是全职做面试工作；多数都是工作之余筛选简历。</p>
<p>就我的情况来说，每天都需要在工作中挤出一部分时间从 10 几份简历中挑选出比较靠谱的。</p>
<p>总共大概花费 5 分钟的时间，平均算下来差不多一份简历只有 30S。现在我终于相信当初语文老师说：“高考语文作文阅卷只有几十秒的时间”。</p>
<p>既然时间很短，就需要像写作文一样突出亮点。</p>
<span id="more"></span>


<h3 id="博客、GitHub"><a href="#博客、GitHub" class="headerlink" title="博客、GitHub"></a>博客、GitHub</h3><p>举个例子，如果我在简历开头的个人介绍栏有看到个人博客、GitHub 链接等，一般都会点进去瞧瞧。</p>
<p>不知道是否是城市原因，我这里几乎 10 份简历中有两份贴有个人博客、1 份贴有 GitHub 链接。</p>
<p>哪怕里面的内容不是非常吸引人，但相比来说这样的简历会比其他多花上一些阅读时间，自然印象就更加深刻。</p>
<p>如果同时内容还非常不错，那就更是加分项了。</p>
<p>这就和上篇<a href="https://crossoverjie.top/2018/08/12/personal/how-to-be-developer/">《如何成为一位「不那么差」的程序员》</a>不谋而合：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d24f5692a.jpg"></p>
<h3 id="项目特色"><a href="#项目特色" class="headerlink" title="项目特色"></a>项目特色</h3><p>通常简历的核心区域就是项目介绍。</p>
<p>这块我觉得可以适当减少项目具体的业务描述（自然不是不写），因为具体的项目了解一般会在简历评估通过后在面试中详聊。</p>
<p>所以这里我建议重点描述下自己解决了什么问题，优化了什么地方；比如：</p>
<ul>
<li>解决了 XX 服务请求超时的问题。</li>
<li>优化了接口，将 QPS 由 1000 提升到了 5000 等等。</li>
</ul>
<p>大概是这个方向的介绍。</p>
<h2 id="需要避免"><a href="#需要避免" class="headerlink" title="需要避免"></a>需要避免</h2><p>同时简历中也有许多需要注意的地方。</p>
<p>首先是少用精通的字眼，真的精通也就算了，不然一定会被仔细询问。</p>
<p>再一个是基本错误尽量少出，比如这样的：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2503aa95.jpg"></p>
<p>这是当时难得看到贴了 GitHub 地址，名字居然还写错。不过我还是点进去看了，也是没啥营养。</p>
<p>甚至之前还收到一封简历，最近一次的工作经历竟然是公司 <code>CEO</code>，但一看工作年纪也才 25 岁工作三年而已。</p>
<p>这样的描述就非常尴尬，建议如果是创业者的身份没什么问题。但这么大一个 <code>title</code> 显然不适合拿来面试。</p>
<p>还有就是附件格式，建议最好使用 <code>PDF</code> 这样通用的格式在所有的操作系统打开都没问题。</p>
<p>word 就非常容易出现变形，比如下面这样的我只能看到身高。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d2510311a.jpg"></p>
<h2 id="1-3-年"><a href="#1-3-年" class="headerlink" title="1~3 年"></a>1~3 年</h2><p>由于现阶段我主要关注的是 1~5 年这个范围，通常也会分为两个阶段。</p>
<p>1~3 年多数是初中级岗位，这部分朋友我觉得应当把简历重心放在学习能力、积极主动性上面。</p>
<p>因为在项目经验并没有那么丰富，所有需要从其他方面体现出自己的优势。比如说扎实的基础。</p>
<h2 id="3-5-年"><a href="#3-5-年" class="headerlink" title="3~5 年"></a>3~5 年</h2><p>3~5 年一般是中高级岗位，这时我觉得需要突出自己解决问题的能力、设计产出方案这些技能表现出来。</p>
<p>同时最好在简历中体现出并发、多线程、分布式相关的经验。</p>
<p>最怕的就是这个阶段给人的感觉还是 1~3 年的水平，但要的薪资可是 N 倍。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后推荐一个在线简历模板：<a href="http://cv.ftqq.com/">http://cv.ftqq.com/</a> 。（不是广告，我个人也在用。easy 大佬看到了记得给我广告费。）</p>
<p>以上全是我个人主观感受，欢迎留言讨论。</p>
<p><strong>你的点赞与转发是最大的支持。</strong></p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean 生命周期</title>
    <url>/2018/03/21/spring/spring-bean-lifecycle/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d7c8810e7.jpg"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Spring Bean 的生命周期在整个 Spring 中占有很重要的位置，掌握这些可以加深对 Spring 的理解。</p>
<p>首先看下生命周期图：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d7d0416f5.jpg"></p>
<p>再谈生命周期之前有一点需要先明确：</p>
<blockquote>
<p>Spring 只帮我们管理单例模式 Bean 的<strong>完整</strong>生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p>
</blockquote>
<span id="more"></span>


<h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>在 bean 初始化时会经历几个阶段，首先可以使用注解 <code>@PostConstruct</code>, <code>@PreDestroy</code> 来在 bean 的创建和销毁阶段进行调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(AnnotationBean.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;AnnotationBean start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;AnnotationBean destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InitializingBean-DisposableBean-接口"><a href="#InitializingBean-DisposableBean-接口" class="headerlink" title="InitializingBean, DisposableBean 接口"></a>InitializingBean, DisposableBean 接口</h3><p>还可以实现 <code>InitializingBean,DisposableBean</code> 这两个接口，也是在初始化以及销毁阶段调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringLifeCycleService</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>,DisposableBean&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(SpringLifeCycleService.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;SpringLifeCycleService start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;SpringLifeCycleService destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义初始化和销毁方法"><a href="#自定义初始化和销毁方法" class="headerlink" title="自定义初始化和销毁方法"></a>自定义初始化和销毁方法</h3><p>也可以自定义方法用于在初始化、销毁阶段调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifeCycleConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;start&quot;, destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SpringLifeCycle <span class="title function_">create</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">SpringLifeCycle</span> <span class="variable">springLifeCycle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringLifeCycle</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> springLifeCycle ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringLifeCycle</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(SpringLifeCycle.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;SpringLifeCycle start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;SpringLifeCycle destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是在 SpringBoot 中可以这样配置，如果是原始的基于 XML 也是可以使用:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.crossoverjie.spring.SpringLifeCycle&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;start&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>来达到同样的效果。</p>
<h3 id="实现-Aware-接口"><a href="#实现-Aware-接口" class="headerlink" title="实现 *Aware 接口"></a>实现 *Aware 接口</h3><p><code>*Aware</code> 接口可以用于在初始化 bean 时获得 Spring 中的一些对象，如获取 <code>Spring 上下文</code>等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringLifeCycleAware</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(SpringLifeCycleAware.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext ;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;SpringLifeCycleAware start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在 <code>springLifeCycleAware</code> 这个 bean 初始化会就会调用 <code>setApplicationContext</code> 方法，并可以获得 <code>applicationContext</code> 对象。</p>
<h3 id="BeanPostProcessor-增强处理器"><a href="#BeanPostProcessor-增强处理器" class="headerlink" title="BeanPostProcessor 增强处理器"></a>BeanPostProcessor 增强处理器</h3><p>实现 BeanPostProcessor 接口，Spring 中所有 bean 在做初始化时都会调用该接口中的两个方法，可以用于对一些特殊的 bean 进行处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringLifeCycleProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(SpringLifeCycleProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预初始化 初始化之前调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;annotationBean&quot;</span>.equals(beanName))&#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;SpringLifeCycleProcessor start beanName=&#123;&#125;&quot;</span>,beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后初始化  bean 初始化完成调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;annotationBean&quot;</span>.equals(beanName))&#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;SpringLifeCycleProcessor end beanName=&#123;&#125;&quot;</span>,beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行之后观察结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">018-03-21 00:40:24.856 [restartedMain] INFO  c.c.s.p.SpringLifeCycleProcessor - SpringLifeCycleProcessor start beanName=annotationBean</span><br><span class="line">2018-03-21 00:40:24.860 [restartedMain] INFO  c.c.spring.annotation.AnnotationBean - AnnotationBean start</span><br><span class="line">2018-03-21 00:40:24.861 [restartedMain] INFO  c.c.s.p.SpringLifeCycleProcessor - SpringLifeCycleProcessor end beanName=annotationBean</span><br><span class="line">2018-03-21 00:40:24.864 [restartedMain] INFO  c.c.s.aware.SpringLifeCycleAware - SpringLifeCycleAware start</span><br><span class="line">2018-03-21 00:40:24.867 [restartedMain] INFO  c.c.s.service.SpringLifeCycleService - SpringLifeCycleService start</span><br><span class="line">2018-03-21 00:40:24.887 [restartedMain] INFO  c.c.spring.SpringLifeCycle - SpringLifeCycle start</span><br><span class="line">2018-03-21 00:40:25.062 [restartedMain] INFO  o.s.b.d.a.OptionalLiveReloadServer - LiveReload server is running on port 35729</span><br><span class="line">2018-03-21 00:40:25.122 [restartedMain] INFO  o.s.j.e.a.AnnotationMBeanExporter - Registering beans for JMX exposure on startup</span><br><span class="line">2018-03-21 00:40:25.140 [restartedMain] INFO  com.crossoverjie.Application - Started Application in 2.309 seconds (JVM running for 3.681)</span><br><span class="line">2018-03-21 00:40:25.143 [restartedMain] INFO  com.crossoverjie.Application - start ok!</span><br><span class="line">2018-03-21 00:40:25.153 [Thread-8] INFO  o.s.c.a.AnnotationConfigApplicationContext - Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@3913adad: startup date [Wed Mar 21 00:40:23 CST 2018]; root of context hierarchy</span><br><span class="line">2018-03-21 00:40:25.155 [Thread-8] INFO  o.s.j.e.a.AnnotationMBeanExporter - Unregistering JMX-exposed beans on shutdown</span><br><span class="line">2018-03-21 00:40:25.156 [Thread-8] INFO  c.c.spring.SpringLifeCycle - SpringLifeCycle destroy</span><br><span class="line">2018-03-21 00:40:25.156 [Thread-8] INFO  c.c.s.service.SpringLifeCycleService - SpringLifeCycleService destroy</span><br><span class="line">2018-03-21 00:40:25.156 [Thread-8] INFO  c.c.spring.annotation.AnnotationBean - AnnotationBean destroy</span><br></pre></td></tr></table></figure>

<p>直到 Spring 上下文销毁时则会调用自定义的销毁方法以及实现了 <code>DisposableBean</code> 的 <code>destroy()</code> 方法。</p>
<h3 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h3><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM(十八) 秒杀架构实践</title>
    <url>/2018/05/07/ssm/SSM18-seconds-kill/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d713e19ed.jpg"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在 <a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/Spike.md">Java-Interview</a> 中提到过秒杀架构的设计，这次基于其中的理论简单实现了一下。</p>
<blockquote>
<p>本次采用循序渐进的方式逐步提高性能达到并发秒杀的效果，文章较长请准备好瓜子板凳(liushuizhang😂)。</p>
</blockquote>
<p>本文所有涉及的代码：</p>
<ul>
<li><a href="https://github.com/crossoverJie/SSM">https://github.com/crossoverJie/SSM</a></li>
<li><a href="https://github.com/crossoverJie/distributed-redis-tool">https://github.com/crossoverJie/distributed-redis-tool</a></li>
</ul>
<p>最终架构图：</p>
<p><img src="https://i.loli.net/2018/05/08/5af079ea8618b.png" alt="系统架构设计.png"></p>
<span id="more"></span>

<p>先简单根据这个图谈下请求的流转，因为后面不管怎么改进这个都是没有变的。</p>
<ul>
<li>前端请求进入 <code>web</code> 层，对应的代码就是 <code>controller</code>。</li>
<li>之后将真正的库存校验、下单等请求发往 <code>Service</code> 层（其中 RPC 调用依然采用的 <code>dubbo</code>，只是更新为最新版本，本次不会过多讨论 dubbo 相关的细节，有兴趣的可以查看 <a href="https://crossoverjie.top/%2F2017%2F04%2F07%2FSSM11%2F">基于dubbo的分布式架构</a>）。</li>
<li><code>Service</code> 层再对数据进行落地，下单完成。</li>
</ul>
<h2 id="无限制"><a href="#无限制" class="headerlink" title="无限制"></a>无限制</h2><p>其实抛开秒杀这个场景来说正常的一个下单流程可以简单分为以下几步：</p>
<ul>
<li>校验库存</li>
<li>扣库存</li>
<li>创建订单</li>
<li>支付</li>
</ul>
<p>基于上文的架构所以我们有了以下实现：</p>
<p>先看看实际项目的结构：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d71693bb0.jpg"></p>
<p>还是和以前一样：</p>
<ul>
<li>提供出一个 <code>API</code> 用于 <code>Service</code> 层实现，以及 <code>web</code> 层消费。</li>
<li>web 层简单来说就是一个 <code>SpringMVC</code>。</li>
<li><code>Service</code> 层则是真正的数据落地。</li>
<li><code>SSM-SECONDS-KILL-ORDER-CONSUMER</code> 则是后文会提到的 <code>Kafka</code> 消费。</li>
</ul>
<p>数据库也是只有简单的两张表模拟下单：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `stock` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">  `count` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;库存&#x27;</span>,</span><br><span class="line">  `sale` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;已售&#x27;</span>,</span><br><span class="line">  `version` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;乐观锁，版本号&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `stock_order` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `sid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;库存ID&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">55</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>web 层 <code>controller</code> 实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StockService stockService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/createWrongOrder/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">createWrongOrder</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> sid)</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;sid=[&#123;&#125;]&quot;</span>, sid);</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        id = orderService.createWrongOrder(sid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 web 作为一个消费者调用看 <code>OrderService</code> 提供出来的 dubbo 服务。</p>
<p>Service 层，<code>OrderService</code> 实现：</p>
<p>首先是对 API 的实现(会在 API 提供出接口)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;DBOrderService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> com.crossoverJie.seconds.kill.service.OrderService orderService ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">createWrongOrder</span><span class="params">(<span class="type">int</span> sid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> orderService.createWrongOrder(sid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是简单调用了 <code>DBOrderService</code> 中的实现，DBOrderService 才是真正的数据落地，也就是写数据库了。</p>
<p>DBOrderService 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transactional(rollbackFor = Exception.class)</span><br><span class="line"><span class="meta">@Service(value = &quot;DBOrderService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;DBStockService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> com.crossoverJie.seconds.kill.service.StockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockOrderMapper orderMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">createWrongOrder</span><span class="params">(<span class="type">int</span> sid)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//校验库存</span></span><br><span class="line">        <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> checkStock(sid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//扣库存</span></span><br><span class="line">        saleStock(stock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> createOrder(stock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Stock <span class="title function_">checkStock</span><span class="params">(<span class="type">int</span> sid)</span> &#123;</span><br><span class="line">        <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> stockService.getStockById(sid);</span><br><span class="line">        <span class="keyword">if</span> (stock.getSale().equals(stock.getCount())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stock;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">saleStock</span><span class="params">(Stock stock)</span> &#123;</span><br><span class="line">        stock.setSale(stock.getSale() + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> stockService.updateStockById(stock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">createOrder</span><span class="params">(Stock stock)</span> &#123;</span><br><span class="line">        <span class="type">StockOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StockOrder</span>();</span><br><span class="line">        order.setSid(stock.getId());</span><br><span class="line">        order.setName(stock.getName());</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> orderMapper.insertSelective(order);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;        </span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 预先初始化了 10 条库存。</p>
</blockquote>
<p>手动调用下 <code>createWrongOrder/1</code> 接口发现：</p>
<p>库存表：<br><img src="https://i.loli.net/2019/05/08/5cd1d7189c72f.jpg"></p>
<p>订单表：<br><img src="https://i.loli.net/2019/05/08/5cd1d721e9fd4.jpg"></p>
<p>一切看起来都没有问题，数据也正常。</p>
<p>但是当用 <code>JMeter</code> 并发测试时：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d7243c657.jpg"></p>
<p>测试配置是：300个线程并发，测试两轮来看看数据库中的结果：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d726cee79.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d72816d67.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d72b9f26a.jpg"></p>
<p>请求都响应成功，库存确实也扣完了，但是订单却生成了 <strong>124</strong> 条记录。</p>
<p>这显然是典型的超卖现象。</p>
<blockquote>
<p>其实现在再去手动调用接口会返回库存不足，但为时晚矣。</p>
</blockquote>
<h2 id="乐观锁更新"><a href="#乐观锁更新" class="headerlink" title="乐观锁更新"></a>乐观锁更新</h2><p>怎么来避免上述的现象呢？</p>
<p>最简单的做法自然是乐观锁了，这里不过多讨论这个，不熟悉的朋友可以看下<a href="http://crossoverjie.top/%2F2017%2F07%2F09%2FSSM15%2F">这篇</a>。</p>
<p>来看看具体实现：</p>
<blockquote>
<p>其实其他的都没怎么改，主要是 Service 层。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">createOptimisticOrder</span><span class="params">(<span class="type">int</span> sid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验库存</span></span><br><span class="line">    <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> checkStock(sid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乐观锁更新库存</span></span><br><span class="line">    saleStockOptimistic(stock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建订单</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> createOrder(stock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saleStockOptimistic</span><span class="params">(Stock stock)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stockService.updateStockByOptimistic(stock);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;并发更新库存失败&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的 XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByOptimistic&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.crossoverJie.seconds.kill.pojo.Stock&quot;</span>&gt;</span></span><br><span class="line">    update stock</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        sale = sale + 1,</span><br><span class="line">        version = version + 1,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    WHERE id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">    AND version = #&#123;version,jdbcType=INTEGER&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同样的测试条件，我们再进行上面的测试 <code>/createOptimisticOrder/1</code>：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d72dab853.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d730800b1.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d73324dd2.jpg"></p>
<p>这次发现无论是库存订单都是 OK 的。</p>
<p>查看日志发现：</p>
<p><img src="https://i.loli.net//2019//05//08//5cd1daafb70bc.jpg"></p>
<p>很多并发请求会响应错误，这就达到了效果。</p>
<h3 id="提高吞吐量"><a href="#提高吞吐量" class="headerlink" title="提高吞吐量"></a>提高吞吐量</h3><p>为了进一步提高秒杀时的吞吐量以及响应效率，这里的 web 和 Service 都进行了横向扩展。</p>
<ul>
<li>web 利用 Nginx 进行负载。</li>
<li>Service 也是多台应用。</li>
</ul>
<p><img src="https://i.loli.net/2019/05/08/5cd1d752909b9.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d758c7714.jpg"></p>
<p>再用 JMeter 测试时可以直观的看到效果。</p>
<blockquote>
<p>由于我是在阿里云的一台小水管服务器进行测试的，加上配置不高、应用都在同一台，所以并没有完全体现出性能上的优势（ <code>Nginx</code> 做负载转发时候也会增加额外的网络消耗）。</p>
</blockquote>
<h3 id="shell-脚本实现简单的-CI"><a href="#shell-脚本实现简单的-CI" class="headerlink" title="shell 脚本实现简单的 CI"></a>shell 脚本实现简单的 CI</h3><p>由于应用多台部署之后，手动发版测试的痛苦相信经历过的都有体会。</p>
<p>这次并没有精力去搭建完整的 CI CD，只是写了一个简单的脚本实现了自动化部署，希望对这方面没有经验的同学带来一点启发：</p>
<h4 id="构建-web"><a href="#构建-web" class="headerlink" title="构建 web"></a>构建 web</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建 web 消费者</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">read</span> appname</span></span><br><span class="line"></span><br><span class="line">appname=&quot;consumer&quot;</span><br><span class="line">echo &quot;input=&quot;$appname</span><br><span class="line"></span><br><span class="line">PID=$(ps -ef | grep $appname | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">遍历杀掉 pid</span></span><br><span class="line">for var in $&#123;PID[@]&#125;;</span><br><span class="line">do</span><br><span class="line">    echo &quot;loop pid= $var&quot;</span><br><span class="line">    kill -9 $var</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;kill $appname success&quot;</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line">cd SSM-SECONDS-KILL</span><br><span class="line"></span><br><span class="line">mvn -Dmaven.test.skip=true clean package</span><br><span class="line"></span><br><span class="line">echo &quot;build war success&quot;</span><br><span class="line"></span><br><span class="line">cp /home/crossoverJie/SSM/SSM-SECONDS-KILL/SSM-SECONDS-KILL-WEB/target/SSM-SECONDS-KILL-WEB-2.2.0-SNAPSHOT.war /home/crossoverJie/tomcat/tomcat-dubbo-consumer-8083/webapps</span><br><span class="line">echo &quot;cp tomcat-dubbo-consumer-8083/webapps ok!&quot;</span><br><span class="line"></span><br><span class="line">cp /home/crossoverJie/SSM/SSM-SECONDS-KILL/SSM-SECONDS-KILL-WEB/target/SSM-SECONDS-KILL-WEB-2.2.0-SNAPSHOT.war /home/crossoverJie/tomcat/tomcat-dubbo-consumer-7083-slave/webapps</span><br><span class="line">echo &quot;cp tomcat-dubbo-consumer-7083-slave/webapps ok!&quot;</span><br><span class="line"></span><br><span class="line">sh /home/crossoverJie/tomcat/tomcat-dubbo-consumer-8083/bin/startup.sh</span><br><span class="line">echo &quot;tomcat-dubbo-consumer-8083/bin/startup.sh success&quot;</span><br><span class="line"></span><br><span class="line">sh /home/crossoverJie/tomcat/tomcat-dubbo-consumer-7083-slave/bin/startup.sh</span><br><span class="line">echo &quot;tomcat-dubbo-consumer-7083-slave/bin/startup.sh success&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;start $appname success&quot;</span><br></pre></td></tr></table></figure>

<h4 id="构建-Service"><a href="#构建-Service" class="headerlink" title="构建 Service"></a>构建 Service</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建服务提供者</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">read</span> appname</span></span><br><span class="line"></span><br><span class="line">appname=&quot;provider&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;input=&quot;$appname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PID=$(ps -ef | grep $appname | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">echo</span> <span class="string">&quot;process id:<span class="variable">$PID</span>&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">else</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">echo</span> <span class="string">&quot;process <span class="variable">$appname</span> not exit&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">exit</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">fi</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">遍历杀掉 pid</span></span><br><span class="line">for var in $&#123;PID[@]&#125;;</span><br><span class="line">do</span><br><span class="line">    echo &quot;loop pid= $var&quot;</span><br><span class="line">    kill -9 $var</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;kill $appname success&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line">cd SSM-SECONDS-KILL</span><br><span class="line"></span><br><span class="line">mvn -Dmaven.test.skip=true clean package</span><br><span class="line"></span><br><span class="line">echo &quot;build war success&quot;</span><br><span class="line"></span><br><span class="line">cp /home/crossoverJie/SSM/SSM-SECONDS-KILL/SSM-SECONDS-KILL-SERVICE/target/SSM-SECONDS-KILL-SERVICE-2.2.0-SNAPSHOT.war /home/crossoverJie/tomcat/tomcat-dubbo-provider-8080/webapps</span><br><span class="line"></span><br><span class="line">echo &quot;cp tomcat-dubbo-provider-8080/webapps ok!&quot;</span><br><span class="line"></span><br><span class="line">cp /home/crossoverJie/SSM/SSM-SECONDS-KILL/SSM-SECONDS-KILL-SERVICE/target/SSM-SECONDS-KILL-SERVICE-2.2.0-SNAPSHOT.war /home/crossoverJie/tomcat/tomcat-dubbo-provider-7080-slave/webapps</span><br><span class="line"></span><br><span class="line">echo &quot;cp tomcat-dubbo-provider-7080-slave/webapps ok!&quot;</span><br><span class="line"></span><br><span class="line">sh /home/crossoverJie/tomcat/tomcat-dubbo-provider-8080/bin/startup.sh</span><br><span class="line">echo &quot;tomcat-dubbo-provider-8080/bin/startup.sh success&quot;</span><br><span class="line"></span><br><span class="line">sh /home/crossoverJie/tomcat/tomcat-dubbo-provider-7080-slave/bin/startup.sh</span><br><span class="line">echo &quot;tomcat-dubbo-provider-8080/bin/startup.sh success&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;start $appname success&quot;</span><br></pre></td></tr></table></figure>

<p>之后每当我有更新，只需要执行这两个脚本就可以帮我自动构建。</p>
<p>都是最基础的 Linux 命令，相信大家都看得明白。</p>
<h2 id="乐观锁更新-分布式限流"><a href="#乐观锁更新-分布式限流" class="headerlink" title="乐观锁更新 + 分布式限流"></a>乐观锁更新 + 分布式限流</h2><p>上文的结果看似没有问题，其实还差得远呢。</p>
<p>这里只是模拟了 300 个并发没有问题，但是当请求达到了 3000 ，3W，300W 呢？</p>
<p>虽说可以横向扩展可以支撑更多的请求。</p>
<p>但是能不能利用最少的资源解决问题呢？</p>
<p>其实仔细分析下会发现：</p>
<blockquote>
<p>假设我的商品一共只有 10 个库存，那么无论你多少人来买其实最终也最多只有 10 人可以下单成功。</p>
</blockquote>
<p>所以其中会有 <code>99%</code> 的请求都是无效的。</p>
<p>大家都知道：大多数应用数据库都是压倒骆驼的最后一根稻草。</p>
<p>通过 <code>Druid</code> 的监控来看看之前请求数据库的情况：</p>
<p>因为 Service 是两个应用。<br><img src="https://i.loli.net/2019/05/08/5cd1d764221b5.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d7676e1d2.jpg"></p>
<p><img src="https://i.loli.net//2019//05//08//5cd1daeb0c306.jpg"></p>
<p>数据库也有 20 多个连接。</p>
<p>怎么样来优化呢？<br>其实很容易想到的就是<a href="http://crossoverjie.top/2018/04/28/sbc/sbc7-Distributed-Limit/">分布式限流</a>。</p>
<p>我们将并发控制在一个可控的范围之内，然后快速失败这样就能最大程度的保护系统。</p>
<h3 id="distributed-redis-tool-⬆️v1-0-3"><a href="#distributed-redis-tool-⬆️v1-0-3" class="headerlink" title="distributed-redis-tool ⬆️v1.0.3"></a>distributed-redis-tool ⬆️v1.0.3</h3><p>为此还对 <a href="https://github.com/crossoverJie/distributed-redis-tool">https://github.com/crossoverJie/distributed-redis-tool</a> 进行了小小的升级。</p>
<p>因为加上该组件之后所有的请求都会经过 Redis，所以对 Redis 资源的使用也是要非常小心。</p>
<h4 id="API-更新"><a href="#API-更新" class="headerlink" title="API 更新"></a>API 更新</h4><p>修改之后的 API 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLimitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(RedisLimitConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;redis.limit&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JedisConnectionFactory jedisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisLimit <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RedisLimit</span> <span class="variable">redisLimit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisLimit</span>.Builder(jedisConnectionFactory, RedisToolsConstant.SINGLE)</span><br><span class="line">                .limit(limit)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisLimit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里构建器改用了 <code>JedisConnectionFactory</code>，所以得配合 Spring 来一起使用。</p>
<p>并在初始化时显示传入 Redis 是以集群方式部署还是单机（强烈建议集群，限流之后对 Redis 还是有一定的压力）。</p>
<h5 id="限流实现"><a href="#限流实现" class="headerlink" title="限流实现"></a>限流实现</h5><p>既然 API 更新了，实现自然也要修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * limit traffic</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> if true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get connection</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">connection</span> <span class="operator">=</span> getConnection();</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> limitRequest(connection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FAIL_CODE != (Long) result) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">limitRequest</span><span class="params">(Object connection)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.valueOf(System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span> (connection <span class="keyword">instanceof</span> Jedis)&#123;</span><br><span class="line">        result = ((Jedis)connection).eval(script, Collections.singletonList(key), Collections.singletonList(String.valueOf(limit)));</span><br><span class="line">        ((Jedis) connection).close();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        result = ((JedisCluster) connection).eval(script, Collections.singletonList(key), Collections.singletonList(String.valueOf(limit)));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((JedisCluster) connection).close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;IOException&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">    Object connection ;</span><br><span class="line">    <span class="keyword">if</span> (type == RedisToolsConstant.SINGLE)&#123;</span><br><span class="line">        <span class="type">RedisConnection</span> <span class="variable">redisConnection</span> <span class="operator">=</span> jedisConnectionFactory.getConnection();</span><br><span class="line">        connection = redisConnection.getNativeConnection();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">RedisClusterConnection</span> <span class="variable">clusterConnection</span> <span class="operator">=</span> jedisConnectionFactory.getClusterConnection();</span><br><span class="line">        connection = clusterConnection.getNativeConnection() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是原生的 Spring 应用得采用 <code>@SpringControllerLimit(errorCode = 200)</code> 注解。</p>
<p>实际使用如下：</p>
<p>web 端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 乐观锁更新库存 限流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringControllerLimit(errorCode = 200)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/createOptimisticLimitOrder/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">createOptimisticLimitOrder</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> sid)</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;sid=[&#123;&#125;]&quot;</span>, sid);</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        id = orderService.createOptimisticOrder(sid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service 端就没什么更新了，依然是采用的乐观锁更新数据库。</p>
<p>再压测看下效果 <code>/createOptimisticLimitOrderByRedis/1</code>：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d776c39b7.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d77ba16d2.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d780d5aa2.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d784644d5.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d787b3e49.jpg"></p>
<p>首先是看结果没有问题，再看数据库连接以及并发请求数都有<strong>明显的下降</strong>。</p>
<h2 id="乐观锁更新-分布式限流-Redis-缓存"><a href="#乐观锁更新-分布式限流-Redis-缓存" class="headerlink" title="乐观锁更新 + 分布式限流 + Redis 缓存"></a>乐观锁更新 + 分布式限流 + Redis 缓存</h2><p>其实仔细观察 Druid 监控数据发现这个 SQL 被多次查询：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d78b3896a.jpg"></p>
<p>其实这是实时查询库存的 SQL，主要是为了在每次下单之前判断是否还有库存。</p>
<p><strong>这也是个优化点</strong>。</p>
<p>这种数据我们完全可以放在内存中，效率比在数据库要高很多。</p>
<p>由于我们的应用是分布式的，所以堆内缓存显然不合适，Redis 就非常适合。</p>
<p>这次主要改造的是 Service 层：</p>
<ul>
<li>每次查询库存时走 Redis。</li>
<li>扣库存时更新 Redis。</li>
<li>需要提前将库存信息写入 Redis（手动或者程序自动都可以）。</li>
</ul>
<p>主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">createOptimisticOrderUseRedis</span><span class="params">(<span class="type">int</span> sid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//检验库存，从 Redis 获取</span></span><br><span class="line">    <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> checkStockByRedis(sid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乐观锁更新库存 以及更新 Redis</span></span><br><span class="line">    saleStockOptimisticByRedis(stock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建订单</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> createOrder(stock);</span><br><span class="line">    <span class="keyword">return</span> id ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Stock <span class="title function_">checkStockByRedis</span><span class="params">(<span class="type">int</span> sid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> Integer.parseInt(redisTemplate.opsForValue().get(RedisKeysConstant.STOCK_COUNT + sid));</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">sale</span> <span class="operator">=</span> Integer.parseInt(redisTemplate.opsForValue().get(RedisKeysConstant.STOCK_SALE + sid));</span><br><span class="line">    <span class="keyword">if</span> (count.equals(sale))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;库存不足 Redis currentCount=&quot;</span> + sale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">version</span> <span class="operator">=</span> Integer.parseInt(redisTemplate.opsForValue().get(RedisKeysConstant.STOCK_VERSION + sid));</span><br><span class="line">    <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stock</span>() ;</span><br><span class="line">    stock.setId(sid);</span><br><span class="line">    stock.setCount(count);</span><br><span class="line">    stock.setSale(sale);</span><br><span class="line">    stock.setVersion(version);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stock;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 乐观锁更新数据库 还要更新 Redis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saleStockOptimisticByRedis</span><span class="params">(Stock stock)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stockService.updateStockByOptimistic(stock);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;并发更新库存失败&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自增</span></span><br><span class="line">    redisTemplate.opsForValue().increment(RedisKeysConstant.STOCK_SALE + stock.getId(),<span class="number">1</span>) ;</span><br><span class="line">    redisTemplate.opsForValue().increment(RedisKeysConstant.STOCK_VERSION + stock.getId(),<span class="number">1</span>) ;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>压测看看实际效果 <code>/createOptimisticLimitOrderByRedis/1</code>：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d78d659b6.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d790607a1.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d79307676.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d7973de43.jpg"></p>
<p>最后发现数据没问题，数据库的请求与并发也都下来了。</p>
<h2 id="乐观锁更新-分布式限流-Redis-缓存-Kafka-异步"><a href="#乐观锁更新-分布式限流-Redis-缓存-Kafka-异步" class="headerlink" title="乐观锁更新 + 分布式限流 + Redis 缓存 + Kafka 异步"></a>乐观锁更新 + 分布式限流 + Redis 缓存 + Kafka 异步</h2><p>最后的优化还是想如何来再次提高吞吐量以及性能的。</p>
<p>我们上文所有例子其实都是同步请求，完全可以利用同步转异步来提高性能啊。</p>
<p>这里我们将写订单以及更新库存的操作进行异步化，利用 <code>Kafka</code> 来进行解耦和队列的作用。</p>
<p>每当一个请求通过了限流到达了 Service 层通过了库存校验之后就将订单信息发给 Kafka ，这样一个请求就可以直接返回了。</p>
<p>消费程序再对数据进行入库落地。</p>
<p>因为异步了，所以最终需要采取回调或者是其他提醒的方式提醒用户购买完成。</p>
<p>这里代码较多就不贴了，消费程序其实就是把之前的 Service 层的逻辑重写了一遍，不过采用的是 SpringBoot。</p>
<p>感兴趣的朋友可以看下。</p>
<p><a href="https://github.com/crossoverJie/SSM/tree/master/SSM-SECONDS-KILL/SSM-SECONDS-KILL-ORDER-CONSUMER">https://github.com/crossoverJie/SSM/tree/master/SSM-SECONDS-KILL/SSM-SECONDS-KILL-ORDER-CONSUMER</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实经过上面的一顿优化总结起来无非就是以下几点：</p>
<ul>
<li>尽量将请求拦截在上游。</li>
<li>还可以根据 UID 进行限流。</li>
<li>最大程度的减少请求落到 DB。</li>
<li>多利用缓存。</li>
<li>同步操作异步化。</li>
<li>fail fast，尽早失败，保护应用。</li>
</ul>
<p>码字不易，这应该是我写过字数最多的了，想想当年高中 800 字的作文都憋不出来😂，可想而知是有多难得了。</p>
<p><strong>以上内容欢迎讨论</strong>。</p>
<h3 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h3><p>最近在总结一些 Java 相关的知识点，感兴趣的朋友可以一起维护。</p>
<blockquote>
<p>地址: <a href="https://github.com/crossoverJie/Java-Interview">https://github.com/crossoverJie/Java-Interview</a></p>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
        <category>Distributed Tools</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Kafka</tag>
        <tag>Redis</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>图床失效了？也许你应该试试这个工具</title>
    <url>/2019/05/08/tools/blog-toolbox/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1cbf638ec7.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经过几个小伙伴的提醒，发现个人博客中的许多图片都裂了无法访问；原因就不多说，既然出现问题就得要解决。</p>
<span id="more"></span>

<p><img src="https://i.loli.net/2019/05/08/5cd1c6bfd8ff2.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1cc4598afb.jpg"></p>
<p>原本我的处理方式非常简单粗暴：找到原有的图片重新下载下来上传到新的可用图床再把图片地址替换。</p>
<p>这样搞了一两篇之后我就绝望了。。。</p>
<p>之前为了代码能在公众号里也有好的阅读体验，所以能截图的我绝不贴代码，导致一篇文章多的得有十几张图片。</p>
<p>好在哪位大佬说过“以人肉XX为耻”，这种重复劳动力完全可自动化；于是便有了本次的这个工具。</p>
<p>它可以一行命令把你所有 <code>Markdown</code> 写的内容中的图片全部替换为新的图床。</p>
<p>运行效果如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1cc7612c25.gif"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1cd6062d2a.png"></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>可以直接在这个地址下载 jar 包运行：<a href="https://github.com/crossoverJie/blog.toolbox/releases/download/v0.0.1/blog.toolbox-0.0.1-SNAPSHOT.jar">https://github.com/crossoverJie/blog.toolbox/releases/download/v0.0.1/blog.toolbox-0.0.1-SNAPSHOT.jar</a></p>
<p>当然也可以下载源码编译运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/crossoverJie/blog.toolbox</span><br><span class="line">mvn clean package</span><br><span class="line">java -jar nows-0.0.1-SNAPSHOT.jar --app.downLoad.path=/xx/img /xx/xx/path 100</span><br></pre></td></tr></table></figure>

<p>看运行方式也知道，其实就是用 <code>SpringBoot</code> 写了一个工具用于批量下载文中出现的图片同时上传后完成替换。</p>
<ul>
<li>其中 <code>app.downLoad.path</code> 是用于将下载的图片保存到本地磁盘的目录。</li>
<li><code>/xx/xx/path</code> 则是扫描 <code>.md</code> 文件的目录，会递归扫描所有出所有文件。</li>
<li>100 则是需要替换文件的数量，默认是按照文件修改时间排序。</li>
</ul>
<p>如果自己的图片较多的话还是有几个坑需要注意下。</p>
<h2 id="线程数量"><a href="#线程数量" class="headerlink" title="线程数量"></a>线程数量</h2><p>默认是启动了两个线程去遍历文件、上传下载图片、更新文本等内容，其中的网络 IO 其实挺耗时的，所以其实可以适当的多开些线程来提高任务的执行效率。</p>
<p>但线程过多也许会触发图床的保护机制，同时也和自己电脑配置有关，这个得结合实际情况考虑了。</p>
<p>所以可以通过 <code>--app.thread=6</code> 这样的参数来调整线程数量。</p>
<h2 id="图床限制"><a href="#图床限制" class="headerlink" title="图床限制"></a>图床限制</h2><p>这个是图片过多一定是大概率出现的，上传请求的频次过高很容易被限流封 IP。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;error&quot;</span><span class="punctuation">,</span><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;Upload file count limit. Time left 1027 second.&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>目前来看是封 IP 居多，所以可以通过走代理、换网络的方式来解决。</p>
<p>当然如果是自搭图床可以无视。</p>
<h2 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h2><p>由于我使用的是免费图床，上传过程中偶尔也会出现上传失败的情况，因此默认是有 5 次重试机制的；如果五次都失败了那么大概率是 IP 被封了。</p>
<blockquote>
<p>即便是 ip 被封后只要换了新的 ip 重新执行程序它会自动过滤掉已经替换的图片，不会再做无用功，这点可以放心。</p>
</blockquote>
<h2 id="图片保存"><a href="#图片保存" class="headerlink" title="图片保存"></a>图片保存</h2><p><img src="https://i.loli.net/2019/05/08/5cd1d002b6cff.jpg"></p>
<p>默认情况下,下载的图片会保存在本地，我也建议借此机会自己本地都缓存一份，同时名字还和文中的名字一样，避免今后图床彻底挂掉后连恢复的机会都没有。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个程序的代码就没怎么讲了，确实也挺简单，感兴趣的可以自己下来看看。</p>
<p>目前功能也很单一，自用完全够了；看后续大家是否还有其他需求再逐渐完善吧，比如：</p>
<ul>
<li>图床上传失败自动切换到可用图床。</li>
<li>整体处理效率提升。</li>
<li>任务执行过程中更好的进度展现等。</li>
</ul>
<p>再次贴一下源码地址：</p>
<p><a href="https://github.com/crossoverJie/blog.toolbox">https://github.com/crossoverJie/blog.toolbox</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Goland 中的隐藏宝石</title>
    <url>/2022/07/28/translation/hidden-gems-goland/</url>
    <content><![CDATA[<p><strong><a href="https://blog.jetbrains.com/go/2022/07/21/hidden-gems-in-goland/">原文链接</a></strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4lrsooqqjj212w0k6t9k.jpg"></p>
<p>在日常使用 <code>Goland</code> 时，团队收集了一些可以帮助我们专注于创造的同时减少重复工作的小技巧。<br>如果你是在 <code>IDEA</code> 中使用的 <code>Go</code> 插件，或者其他 <code>IntelliJ</code> 的产品，同样也有这些特性。</p>
<span id="more"></span>

<h1 id="行排序"><a href="#行排序" class="headerlink" title="行排序"></a>行排序</h1><p>当你在查看文本文件时，行排序非常有用；按照字母排序后能够帮我们更好的阅读，同时也容易找到重复的行。</p>
<p>在菜单栏中使用 <code>Edit | Sort Lines or Edit | Reverse Lines</code>可以帮我们快速的对选中的代码或者是整个文件进行排序；或者也可以使用快速命令执行这个操作。</p>
<p><img src="https://lh4.googleusercontent.com/G6g_eIinHwfZchGFPW9cBWYqYzrLuDTQYFafJZ0U0XlibbgANGVZwfgu7UM7bdN1Kr5tiPxk1ELV5F6sgQILyJKyDiziwUGqBOZxUWugfxNvZ9kw4KQBbl9zv-Z4oj8Uxru3Y12glEkhvWAqXxy0R-Q"></p>
<h1 id="打开对比窗口"><a href="#打开对比窗口" class="headerlink" title="打开对比窗口"></a>打开对比窗口</h1><p>打开一个对比窗口可以帮助我们对比任何文件、文件夹、文本；举个例子，将复制的内容粘贴到对比窗口中，IDE 会类似于版本控制系统那样展示两者的差异。</p>
<p>当然也可以用快速指令打开对比窗口（double shift)。</p>
<p><img src="https://lh4.googleusercontent.com/2GtGBX33TZw7WEyVgSYwYcRozVp4AYp8xNYUp4fXtjWXiwolR5ikJdf-AoROpJw1A2HKyolrLR5HAdYUYWbIgJydX01FBOlUQ54BMHh7KS9Jda1Slc0QQp_N-uGwYsBBKAr-yhtsiVWTNrSB6PpYeIA"></p>
<p>此外你也可以在 IDE 编辑器的任何地方右键鼠标选择与当前粘贴板数据进行对比。</p>
<blockquote>
<p>这个功能很棒，可以替换掉以前大部分用 BeyondCompare 的场景了。</p>
</blockquote>
<h1 id="暂存文件"><a href="#暂存文件" class="headerlink" title="暂存文件"></a>暂存文件</h1><p>有时候你需要一个随意的地方来编写一段文本，与当前工作相关的一些记录，也或是与当前项目上下文无关的草稿代码；这时候就需要用到暂存文件了。</p>
<p>暂存文件可不只是简单的笔记，它支持语法高亮、代码提示以及所有和这个文件类型相关的特性。</p>
<p>暂存文件与当前项目无关，你可以在任意项目中访问到这些文件，这样你就不需要离开 IDE 到其他地方来保存这些文件了。</p>
<p>可以在菜单栏中新建暂存文件<code>File | New | Scratch File or</code>，也可以使用快捷键 <code>⇧ ⌘ N</code>.</p>
<p><img src="https://lh4.googleusercontent.com/d-HxnmVYaZOJq8mqJzCMagroGVpg6i7E2VF2j44MhGsqluWKRXENxgZI4sy8pLNaYex6hxSD9Yg0hNM06PgKvKjifGNYYfbA21C4mCiQAN0GctH2SK2fW9DFg1boZ3G2gZyradsaGVH08clG96s1KnY"></p>
<blockquote>
<p>通常使用这个功能来存放和运行一些测试或者是实例代码。</p>
</blockquote>
<h1 id="多行光标"><a href="#多行光标" class="headerlink" title="多行光标"></a>多行光标</h1><p>多行光标可以让你快速在多个地方同时修改代码，同时它也支持代码提示以及实时模板。</p>
<p>开启多行光标可以双击 <code>⌥/Ctrl</code> 后不要释放，然后点击上下箭头键。使用 <code>Escape</code> 键可以退出多行光标。</p>
<p><img src="https://lh3.googleusercontent.com/Zb_1_CiZAP0_6rvAKurH-LsP3OOXqUufkLeeOTWtsCj2EtHAgPZ7sJq3_39oLwwT8bL8gH1eLynMLCQoBI73pUi5STUozXcCOBFry4lGLI-XVEAQYSrQ-opyFv1S_HKt56jYwDAimcFWskDbPpp85nQ"></p>
<blockquote>
<p>这个在批量修改代码时非常有用。</p>
</blockquote>
<h1 id="批量折叠和展开"><a href="#批量折叠和展开" class="headerlink" title="批量折叠和展开"></a>批量折叠和展开</h1><p>在阅读复杂长篇代码的过程中有时候很难弄懂代码结构，即便是代码是我们自己写的。</p>
<p>这也容易解决，批量折叠和展开可以快速帮我们浏览代码，快捷键是：macOS:<code>⇧⌘- /⇧⌘+</code>,Windows&#x2F;Linux: <code>Ctrl+Shift+NumPad + / Ctrl+Shift+NumPad</code>。</p>
<p>IDE 可以帮我们折叠&#x2F;展开选中的代码，如果没有选中则是处理整个文件。</p>
<p>也可以使用 macOS:<code> ⌥⌘- / ⌥⌘+</code>, Windows&#x2F;Linux:<code>Ctrl+Alt+NumPad + / Ctrl+Alt+NumPad</code> 来递归的处理代码，IDE 将会折叠&#x2F;展开当前代码片段或者是他们包含的片段。</p>
<p><img src="https://lh5.googleusercontent.com/cYtEgj2G98zshGwM-1a91f6_kqP1ZjLdWA_yQOCsXOo_0KQC4O9HL1Lphs-vdN71kiD_XjZ_Rh5oDo8zhuh9u7KuSacMFqfv6U1F0kXd8zJT3uF3f0GkZgu1P-OgAPGrG77ByWn5UmcK-uIdZ0Iahqo"></p>
<h1 id="最近文件"><a href="#最近文件" class="headerlink" title="最近文件"></a>最近文件</h1><p>最近文件可以帮助我们快速跳转到最近经常打开的文件，当我们使用 macOS:<code>⌘+E</code> Windows&#x2F;Linux:<code>Ctrl + E</code> 打开最近文件对话框的时，再使用<code>⌘+E</code>可以再次过滤只显示已经修改过的文件，这样可以帮我们更精准的查找。</p>
<p><img src="https://lh5.googleusercontent.com/dfCbbr1RJYJGM12VmuNf7ebgvi01W3yseLvHLELhaMSyTy_MK2N3VmgXxJqcgJ3NVlYzsX9PV3_qiUA9cy_T8_Z5HGY9FDYyn6AwT9Xk6wTieDHl89hKf0JsCeV3XNZEgPcB9TgjbM8CH4o12RyRhfQ"></p>
<p>这些特性可能有些并不常用，一旦用上一次解决问题后会发现 <code>IntelliJ</code> 的 <code>IDE</code> 功能非常强大，如果你还发现了一些其他有用的特性请在留言区分享。</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】如何高效的使用 Git</title>
    <url>/2018/09/07/translation/how-to-use-git-efficiently/</url>
    <content><![CDATA[<p><strong><a href="https://medium.freecodecamp.org/how-to-use-git-efficiently-54320a236369">原文链接</a></strong></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1659a42a.jpg"></p>
<blockquote>
<p>代码昨天还是运行好好的今天就不行了。</p>
</blockquote>
<blockquote>
<p>代码被删了。</p>
</blockquote>
<blockquote>
<p>突然出现了一个奇怪的 bug，但是没人知道怎么回事。</p>
</blockquote>
<p>如果你出现过上面的任何一种情况，那本篇文章就是为你准备的。</p>
<p>除了知道 <code>git add</code>, <code>git commit</code> , <code>git push</code> 之外，Git 中还需要其他重要的技术需要掌握。长远来看对我们是有帮助的。这里我将向你展示 Git 的最佳实践。</p>
<span id="more"></span>

<h1 id="Git-工作流"><a href="#Git-工作流" class="headerlink" title="Git 工作流"></a>Git 工作流</h1><p>当有多个开发者同时涉及到一个项目时那么就非常有必要正确使用 Git 工作流。</p>
<p>这里我将介绍一种工作流，它在一个多人大型项目中将非常有用。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d16785c42.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>突然有一天，你成为了一个项目的技术 Leader 并计划做出下一个 Facebook。在这个项目中你有三个开发人员。</p>
<ol>
<li>Alice：一个开发小白。</li>
<li>Bob：拥有一年工作经验，了解基本开发。</li>
<li>John：三年开发经验，熟练开发技能。</li>
<li>你：该项目的技术负责人。</li>
</ol>
<h1 id="Git-开发流程"><a href="#Git-开发流程" class="headerlink" title="Git 开发流程"></a>Git 开发流程</h1><h2 id="Master-分支"><a href="#Master-分支" class="headerlink" title="Master 分支"></a>Master 分支</h2><ol>
<li>Master 分支应该始终和生产环境保持一致。</li>
<li>由于 master 和生产代码是一致的，所以没有人包括技术负责人能在 master 上直接开发。</li>
<li>真正的开发代码应当写在其他分支上。</li>
</ol>
<h2 id="Release-发布-分支"><a href="#Release-发布-分支" class="headerlink" title="Release(发布) 分支"></a>Release(发布) 分支</h2><ol>
<li>当项目开始时，第一件事情就是创建发布分支。发布分支是基于 master 分支创建而来。</li>
<li>所有与本项目相关的代码都在发布分支中，这个分支也是一个以 <code>release/</code> 开头的普通分支。</li>
<li>比如这次的发布分支名为 <code>release/fb</code>。</li>
<li>可能有多个项目都基于同一份代码运行，因此对于每一个项目来说都需要创建一个独立的发布分支。假设现在还有一个项目正在并行运行，那就得为这个项目创建一个单独的发布分支比如 <code>release/messenger</code>。</li>
<li>需要单独的发布分支的原因是：多个并行项目是基于同一份代码运行的，但是项目之间不能有冲突。</li>
</ol>
<h2 id="Feature-功能分支-branch"><a href="#Feature-功能分支-branch" class="headerlink" title="Feature(功能分支) branch"></a>Feature(功能分支) branch</h2><ol>
<li>对于应用中的每一个功能都应该创建一个独立的功能分支，这会确保这些功能能被单独构建。</li>
<li>功能分支也和其他分支一样，只是以 <code>feature/</code> 开头。</li>
<li>现在作为技术 Leader，你要求 Alice 去做 Facebook 的登录页面。因此他创建了一个新的功能分支。把他命名为 <code>feature/login</code>。Alice 将会在这个分支上编写所有的登录代码。</li>
<li>这个功能分支通常是基于 Release(发布) 分支 创建而来。</li>
<li>Bob 的任务为创建添加好友页面，因此他创建了一个名为 <code>feature/friendrequest</code> 的功能分支。</li>
<li>John 则被安排构建消息流，因此创建了一个 <code>feature/newsfeed</code> 的功能分支。</li>
<li>所有的开发人员都在自己的分支上进行开发，目前为止都很正常。</li>
<li>现在当 Alice 完成了他的登录开发，他需要将他的功能分支 <code>feature/login</code> 发送给 Release(发布) 分支。这个过程是通过发起一个 <code>pull request</code> 完成的。</li>
</ol>
<h2 id="Pull-request"><a href="#Pull-request" class="headerlink" title="Pull request"></a>Pull request</h2><p>首先 <code>pull request</code> 不能和 <code>git pull</code> 搞混了。</p>
<p>开发人员不能直接向 Release(发布) 分支推送代码，技术 Leader 需要在功能分支合并到 Release(发布) 分支之前做好代码审查。这也是通过 <code>pull request</code> 完成的。</p>
<p>Alice 能够按照如下 GitHub 方式提交 <code>pull request</code>。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d16833c7d.jpg"></p>
<p>在分支名字的旁边有一个 “New pull request” 按钮，点击之后将会显示如下界面：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d168da700.jpg"></p>
<ul>
<li>比较分支是 Alice 的功能分支 <code>feature/login</code>。</li>
<li>base 分支则应该是发布分支 <code>release/fb</code>。</li>
</ul>
<p>点击之后 Alice 需要为这个 <code>pull request</code> 输入名称和描述，最后再点击 “Create Pull Request” 按钮。</p>
<p>同时 Alice 需要为这个 <code>pull request</code> 指定一个 reviewer。作为技术 Leader 的你被选为本次 <code>pull request</code> 的 reviewer。</p>
<p>你完成代码审查之后就需要把这个功能分支合并到 Release(发布) 分支。</p>
<p>现在你已经把 <code>feature/login</code> 分支合并到 <code>release/fb</code>，并且 Alice 非常高兴他的代码被合并了。</p>
<h2 id="代码冲突-😠"><a href="#代码冲突-😠" class="headerlink" title="代码冲突 😠"></a>代码冲突 😠</h2><ol>
<li>Bob 完成了他的编码工作，同时向 <code>release/fb</code> 分支发起了一个 <code>pull request</code>。</li>
<li>因为发布分支已经合并了登录的代码，这时代码冲突发生了。解决冲突和合并代码是 reviewer 的责任。在这样的情况下，作为技术 Leader 就需要解决冲突和合并代码了。</li>
<li>现在 John 也已经完成了他的开发，同时也想把代码合并到发布分支。但 John 非常擅长于解决代码冲突。他将 <code>release/fb</code> 上最新的代码合并到他自己的功能分支 <code>feature/newsfeed</code> （通过 git pull 或 git merge 命令）。同时他解决了所有存在的冲突，现在 <code>feature/newsfeed</code> 已经有了所有发布分支 <code>release/fb</code> 的代码。</li>
<li>最后 John 创建了一个 <code>pull request</code>，由于 John 已经解决了所有问题，所以本次 <code>pull request</code> 不会再有冲突了。</li>
</ol>
<p>因此通常有两种方式来解决代码冲突：</p>
<ul>
<li><code>pull request</code> 的 reviewer 需要解决所有的代码冲突。</li>
<li>开发人员需要确保将发布分支的最新代码合并到功能分支，并且解决所有的冲突。</li>
</ul>
<h1 id="还是-Master-分支"><a href="#还是-Master-分支" class="headerlink" title="还是 Master 分支"></a>还是 Master 分支</h1><p>一旦项目完成，发布分支的代码需要合并回 master 分支，同时需要发布到生产环境。</p>
<p>因此生产环境中的代码总是和 master 分支保持一致。同时对于今后的任何项目来说都是要确保 master 代码是最新的。</p>
<blockquote>
<p>我们现在团队就是按照这样的方式进行开发，确实可以尽可能的减少代码管理上的问题。</p>
</blockquote>
<h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>像之前那篇<a href="https://crossoverjie.top/2018/08/12/personal/how-to-be-developer/#English-%E6%8C%BA%E9%87%8D%E8%A6%81">《如何成为一位「不那么差」的程序员》</a>说的那样，建议大家都多看看国外的优质博客。</p>
<p>甚至尝试和作者交流，经过沟通原作者也会在原文中贴上我的翻译链接。大家互惠互利使好的文章转播的更广。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d16a1159d.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d16b0f8c8.jpg"></p>
<p><strong>你的点赞与转发是最大的支持。</strong></p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Java8 之后对新开发者非常友好的特性盘点</title>
    <url>/2022/02/07/translation/new-developer-friendly-features-after-java-8/</url>
    <content><![CDATA[<p><strong><a href="https://piotrminkowski.com/2021/02/01/new-developer-friendly-features-after-java-8/">原文链接</a></strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz3vzlzrs6j30qo0f0dhz.jpg"></p>
<p>在这篇文章中，我将描述自 Java8 依赖对开发者来说最重要也最友好的特性，之所以选择 Java8 ，那是因为它依然是目前使用最多的版本。</p>
<p>具体可见这个调查报告：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz3w509h16j30sg0ao74v.jpg"></p>
<span id="more"></span>


<h1 id="Switch-表达式-JDK-12"><a href="#Switch-表达式-JDK-12" class="headerlink" title="Switch 表达式 (JDK 12)"></a>Switch 表达式 (JDK 12)</h1><p>使用 switch 表达式，你可以定义多个 case 条件，并使用箭头 <code>-&gt;</code> 符号返回值，这个特性在 JDK12 之后启用，它使得 switch 表达式更容易理解了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">newMultiSwitch</span><span class="params">(<span class="type">int</span> day)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> -&gt; <span class="string">&quot;workday&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span> -&gt; <span class="string">&quot;weekend&quot;</span>;</span><br><span class="line">      <span class="keyword">default</span> -&gt; <span class="string">&quot;invalid&quot;</span>;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 JDK12 之前，同样的例子要复杂的多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">oldMultiSwitch</span><span class="params">(<span class="type">int</span> day)</span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;workday&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;weekend&quot;</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;invalid&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文本块-JDK-13"><a href="#文本块-JDK-13" class="headerlink" title="文本块 (JDK 13)"></a>文本块 (JDK 13)</h1><p>文本块是一个多行字符串，可以避免使用转移字符；从 Java13 之后它成为了预览特性，使用 <code>&quot;&quot;&quot;</code> 符号定义。接下来看看使用它声明一个 JSON 字符串有多简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getNewPrettyPrintJson</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">          &#123;</span></span><br><span class="line"><span class="string">             &quot;firstName&quot;: &quot;Piotr&quot;,</span></span><br><span class="line"><span class="string">             &quot;lastName&quot;: &quot;Mińkowski&quot;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">          &quot;&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java13 之前的版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getOldPrettyPrintJson</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">          <span class="string">&quot;     \&quot;firstName\&quot;: \&quot;Piotr\&quot;,\n&quot;</span> +</span><br><span class="line">          <span class="string">&quot;     \&quot;lastName\&quot;: \&quot;Mińkowski\&quot;\n&quot;</span> +</span><br><span class="line">          <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="新的-Optional-Methods-JDK-9-x2F-JDK-10"><a href="#新的-Optional-Methods-JDK-9-x2F-JDK-10" class="headerlink" title="新的 Optional Methods (JDK 9&#x2F; JDK 10)"></a>新的 Optional Methods (JDK 9&#x2F; JDK 10)</h1><p>Java 9&#x2F;10 版本之后新增了几种可选方法，有意思的是这两个：</p>
<ul>
<li><code>orElseThrow</code></li>
<li><code>ifPresentOrElse</code></li>
</ul>
<p>使用 <code>orElseThrow</code> 当数据不存在时你能抛出 <code>NoSuchElementException</code> 异常，相反会返回数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Person <span class="title function_">getPersonById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">   Optional&lt;Person&gt; personOpt = repository.findById(id);</span><br><span class="line">   <span class="keyword">return</span> personOpt.orElseThrow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正因为如此，可以避免在 isPresent 中使用 if 条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Person <span class="title function_">getPersonByIdOldWay</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">   Optional&lt;Person&gt; personOpt = repository.findById(id);</span><br><span class="line">   <span class="keyword">if</span> (personOpt.isPresent())</span><br><span class="line">      <span class="keyword">return</span> personOpt.get();</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个有趣的方法是 <code>ifPresentOrElse</code> ,当数据存在时，会执行带数据参数的函数，相反会执行参数为空的函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printPersonById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">   Optional&lt;Person&gt; personOpt = repository.findById(id);</span><br><span class="line">   personOpt.ifPresentOrElse(</span><br><span class="line">      System.out::println,</span><br><span class="line">      () -&gt; System.out.println(<span class="string">&quot;Person not found&quot;</span>)</span><br><span class="line">   );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在 Java8 中，你需要在 isPresent 方法中使用 if else 语句。</p>
<h1 id="集合工厂方法-JDK-9"><a href="#集合工厂方法-JDK-9" class="headerlink" title="集合工厂方法(JDK 9)"></a>集合工厂方法(JDK 9)</h1><p>使用 Java9 中的集合工厂方法可以简单的使用预定义数据创建不可变集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; fruits = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>);</span><br><span class="line">Map&lt;Integer, String&gt; numbers = Map.of(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>, <span class="number">2</span>,<span class="string">&quot;two&quot;</span>, <span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在 Java9 之前，你可以使用 Collections ，但肯定是更复杂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">fruits</span><span class="params">()</span> &#123;</span><br><span class="line">   List&lt;String&gt; fruitsTmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   fruitsTmp.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">   fruitsTmp.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">   fruitsTmp.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> Collections.unmodifiableList(fruitsTmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Map&lt;Integer, String&gt; <span class="title function_">numbers</span><span class="params">()</span> &#123;</span><br><span class="line">   Map&lt;Integer, String&gt; numbersTmp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   numbersTmp.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">   numbersTmp.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">   numbersTmp.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> Collections.unmodifiableMap(numbersTmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Records-JDK-14"><a href="#Records-JDK-14" class="headerlink" title="Records (JDK 14)"></a>Records (JDK 14)</h1><p>使用 <code>Records</code> 你可以定义一个不可变、只能访问数据（只有 getter 方法) 的类，它可以自动创建 <code>toString，equals，hashcode</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>以下效果与  <code>Records</code>  类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonOld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonOld</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">PersonOld</span> <span class="variable">personOld</span> <span class="operator">=</span> (PersonOld) o;</span><br><span class="line">        <span class="keyword">return</span> age == personOld.age &amp;&amp; name.equals(personOld.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PersonOld&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="接口中的私有方法-JDK-9"><a href="#接口中的私有方法-JDK-9" class="headerlink" title="接口中的私有方法 (JDK 9)"></a>接口中的私有方法 (JDK 9)</h1><p>从 Java8 之后你就可以为接口创建默认方法，但从 Java9 的私有方法你就能充分使用该特性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExampleInterface</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printMsg</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Calling interface&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Interface method: &quot;</span> + methodName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">      printMsg(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">      printMsg(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="局部变量类型推导-JDK-10-x2F-JDK-11"><a href="#局部变量类型推导-JDK-10-x2F-JDK-11" class="headerlink" title="局部变量类型推导 (JDK 10 &#x2F; JDK 11)"></a>局部变量类型推导 (JDK 10 &#x2F; JDK 11)</h1><p>从 Java10 之后你就能使用局部变量类型推导了，只需要使用 var 关键字来代替具体类型；在 Java11 之后你就能在 lambda 表达式中使用类型推导了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">sumOfString</span><span class="params">()</span> &#123;</span><br><span class="line">   BiFunction&lt;String, String, String&gt; func = (<span class="keyword">var</span> x, <span class="keyword">var</span> y) -&gt; x + y;</span><br><span class="line">   <span class="keyword">return</span> func.apply(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;efg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】对于初学者什么是最好的编程语言？</title>
    <url>/2018/04/12/translation/translation-What%20Is%20The%20Best%20Programming%20Language%20to%20Start/</url>
    <content><![CDATA[<h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://hackernoon.com/what-is-the-best-programming-language-to-start-8ca8fb5e9a60">原文链接</a></h3><p>Python？Java？Ruby？JavaScript？有非常多的选择。选择一种编程语言开始你的编码之旅不应该是一件艰巨的任务。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d7b300f5c.jpg"></p>
<p>事实上：你将要学习的语言并不是特别重要，更重要的是学习编程的理念。对于任何编程语言来说知识的可传递性都是至关重要的。</p>
<p>我学习的第一门语言是 Java，学习了循环，while 循环，条件，函数，面向对象编程和许多编程理念。</p>
<p>然而，选择一门能在编程领域轻松找到工作的语言是更好的选择。对于初学者来说，我这里有一份列表推荐给你：</p>
<span id="more"></span>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python 在美国大学里是最受欢迎的入门型语言。</p>
<p>就像 JavaScript 一样，Python 也非常灵活，现在被用于构建生物信息学的 web 应用。我强烈推荐你学习 Python，它是很棒的入门选择。</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>Java 是企业环境中使用最多的语言，根据 TIOBE 统计 Java 长年占据编程语言榜首。同时 Java 是强类型地静态语言，可以更容易地去描述一些编程理念。</p>
<p>Java 作为最常使用的语言，你可以很轻松地在这段编程之旅中找到 Java 的相关课程和指南来获得帮助。你还可以使用 Java 构建服务端应用、Android APP 等应用程序。</p>
<h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><p>Ruby 是我最喜欢的编程语言，它编写简单，容易理解并且使用顺手。</p>
<p>就像 JavaScript 一样，它学起来简单但是不易掌握。Ruby 在很多公司中被广泛应用，比如 Airbnb, EBANX, Shopify, Twitter, GitHub 等等。它还有一个超赞的 7*24 小时的在线社区随时提供帮助。<br>Ruby 以  Ruby on Rails 框架著称，它可以帮你很轻松的构建整个 web 应用。</p>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>JavaScript 是我用过的最灵活的语言之一。</p>
<p>你能用它构建控制台程序，桌面软件，手机 APP，前端开发，后端开发等等。它是一个很不错的编程语言，简单易学但难以掌握。</p>
<p>我建议你学习并掌握 JavaScript ，但不是作为第一门语言。</p>
<p>对于初学者来说 JavaScript 很难调试并且不容易学习编程理念比如异步，原型，面向对象等等。</p>
<h3 id="不要纠结语言"><a href="#不要纠结语言" class="headerlink" title="不要纠结语言"></a>不要纠结语言</h3><p>你需要通过选择一门语言来学习编程理念，当你学完之后你将花费较小的学习曲线来学习任何其他的语言。</p>
<p>如果你想要学习如何学习一门新语言的话，可以阅读我的文章 “<a href="https://hackernoon.com/what-is-the-best-programming-language-to-start-8ca8fb5e9a60">How to Learn a New Programming Language or Framework</a>”，将会非常有用。</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
  </entry>
  <entry>
    <title>【译】你可能不知道但却很有用的 Java 特性</title>
    <url>/2022/01/18/translation/useful-unknown-java-features/</url>
    <content><![CDATA[<p><strong><a href="https://piotrminkowski.com/2022/01/05/useful-unknown-java-features/#2-period-of-days-in-time-format-7b240340-e2be-42dd-ae04-607d3a539d1b">原文链接</a></strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycijo0cdzj31hf0u0jy1.jpg"></p>
<p>在这篇文章中你将会学习到一些你可能没听过但有用的 Java 特性，这些是我个人常用的一些特性或者是从其他文章中学习到的，重点是关注 API 而不是语言本身。</p>
<span id="more"></span>

<h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1><p>众所周知，在 Java 中有许多类型的集合可以使用，但你听说过 <code>DelayQueue</code> 吗？它是一个特定类型的集合，允许我们基于延时时间对数据排序，这是一个非常有意思的类，它实现了 <code>BlockingQueue</code> 接口，只有当数据过期后才能从队列里取出。</p>
<p>使用它的第一步，你的 class 需要实现 <code>Delayed</code> 接口中的 <code>getDelay</code> 方法，当然也可以不用声明一个 class，使用 Record 也是可以的。</p>
<blockquote>
<p>这是 Java14 的新特性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">DelayedEvent</span><span class="params">(<span class="type">long</span> startTime, String msg)</span> <span class="keyword">implements</span> <span class="title class_">Delayed</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span> startTime - System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> unit.convert(diff, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (<span class="built_in">this</span>.startTime - ((DelayedEvent) o).startTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们需要一个延时 10s 取出的数据，我们只需要放入一个比当前时间多 10s 的任务即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> DelayQueue&lt;DelayedEvent&gt; delayQueue = <span class="keyword">new</span> <span class="title class_">DelayQueue</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">timeFirst</span> <span class="operator">=</span> System.currentTimeMillis() + <span class="number">10000</span>;</span><br><span class="line">delayQueue.offer(<span class="keyword">new</span> <span class="title class_">DelayedEvent</span>(timeFirst, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">log.info(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">log.info(delayQueue.take().msg());</span><br></pre></td></tr></table></figure>

<p>最终输出如下：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyd5q8ndpuj30sg04s0t3.jpg"></p>
<h1 id="时间格式的日期"><a href="#时间格式的日期" class="headerlink" title="时间格式的日期"></a>时间格式的日期</h1><p>这个特性可能对大部分人来说没什么用，但老实说我个人非常喜欢；不管怎么说 Java 8 在时间 API 上改进了许多。从这个版本开始或许你不再需要其他任何扩展库了。</p>
<p>你能想到嘛，从 Java 16 中你甚至可以用标准库表示一天内的日期了，比如 “in the morning” “in the afternoon” ，这是一个新的格式语句 <strong>B</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> DateTimeFormatter</span><br><span class="line">  .ofPattern(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">  .format(LocalDateTime.now());</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>以下是我的输出，具体和你当前时间有关。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyd5yop8a2j30gq02uaa0.jpg"></p>
<p>你可能会想为什么会是调用 “B” 呢，这确实看起来不太直观，通过下表也许能解答疑惑：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyflhuzlugj30va0q20vw.jpg"></p>
<h1 id="Stamped-Lock"><a href="#Stamped-Lock" class="headerlink" title="Stamped Lock"></a>Stamped Lock</h1><p>在我看来，并发包是 Java 中最有意思的包之一，同时又很少被开发者熟练掌握，特别是长期使用 web 开发框架的开发者。</p>
<p>有多少人曾经使用过 Lock 呢？相对于 <code>synchronized</code> 来说这是一种更灵活的线程同步机制。</p>
<p>从 Java8 开始你可以使用一种新的锁：<code>StampedLock.StampedLock</code>，能够替代 <code>ReadWriteLock</code>。</p>
<p>假设现在有两个线程，一个线程更新金额、一个线程读取余额；更新余额的线程首先需要读取金额，再多线程的情况下需要某种同步机制（不然更新数据会发生错误），第二个线程用乐观锁的方式读取余额。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="type">Balance</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Balance</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">w</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">   <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">   b.setAmount(b.getAmount() + <span class="number">1000</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;Write: &quot;</span> + b.getAmount());</span><br><span class="line">   lock.unlockWrite(stamp);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">   <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">   <span class="keyword">if</span> (!lock.validate(stamp)) &#123;</span><br><span class="line">      stamp = lock.readLock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Read: &quot;</span> + b.getAmount());</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlockRead(stamp);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Optimistic read fails&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在更新和读取的都用 50 个线程来进行测试，最终的余额将会等于 60000.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">   executor.submit(w);</span><br><span class="line">   executor.submit(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并发累加器"><a href="#并发累加器" class="headerlink" title="并发累加器"></a>并发累加器</h1><p>锁并并不是并发包中唯一有意思的特性，并发累加器也同样有趣；它可以根据我们提供的函数更新数据；再多线程更新数据的场景下，<code>LongAccumulator</code> 是比 <code>AtomicLong</code> 更优的选择。</p>
<p>现在让我们来看看具体如何使用，我们需要两个参数进行初始化；第一个是用于累加计算的函数，通常是一个 sum 函数，第二个参数则是累加计算的初始化值。</p>
<p>接下来我们用 10000 作为初始值来创建一个 <code>LongAccumulator</code>，最终结果是多少？其实结果与上文相同，都是 60000，但这次我们并没有使用锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LongAccumulator</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>(Long::sum, <span class="number">10000L</span>);</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">w</span> <span class="operator">=</span> () -&gt; balance.accumulate(<span class="number">1000L</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">   executor.submit(w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executor.shutdown();</span><br><span class="line"><span class="keyword">if</span> (executor.awaitTermination(<span class="number">1000L</span>, TimeUnit.MILLISECONDS))</span><br><span class="line">   System.out.println(<span class="string">&quot;Balance: &quot;</span> + balance.get());</span><br><span class="line"><span class="keyword">assert</span> balance.get() == <span class="number">60000L</span>;</span><br></pre></td></tr></table></figure>


<h1 id="数组的二分查找"><a href="#数组的二分查找" class="headerlink" title="数组的二分查找"></a>数组的二分查找</h1><p>假设我们想在一个排序列表中插入一个新元素，可以使用 <code>Arrays.binarySearch()</code> 函数，当这个 key 存在时将会返回 key 所在的索引，如果不存在时将会返回插入的位置<code>-(insertion point)-1</code>。</p>
<p>binarySearch 是 Java 中非常简单且有效的查询方法。</p>
<p>下面的这个例子中，对返回结果取反便能的到索引位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] t = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Arrays.binarySearch(t, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> ~x == <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>负数的二进制是以正数的补码表示，对一个数取反+1 就等于补码，所以这里直接取反就等于 Arrays.binarySearch() 不存在时的返回值了。</p>
</blockquote>
<h1 id="Bit-Set"><a href="#Bit-Set" class="headerlink" title="Bit Set"></a>Bit Set</h1><p>如果你需要对二进制数组进行操作你会怎么做？用 <code>boolean[]</code>  布尔数组?</p>
<p>有一种更高效又更省内存的方式，那就是 <code>BitSet</code>。它允许我们存储和操作 bit 数组，与 <code>boolean[]</code> 相比可省 8 倍的内存；也可以使用 <code>and/or/xor</code> 等逻辑操作。</p>
<p>假设我们现在有两个 bit 数组，我们需要对他们进行 <code>xor</code> 运算；我们需要创建两个 BitSet 实例，然后调用 xor 函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BitSet</span> <span class="variable">bs1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>();</span><br><span class="line">bs1.set(<span class="number">0</span>);</span><br><span class="line">bs1.set(<span class="number">2</span>);</span><br><span class="line">bs1.set(<span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;bs1 : &quot;</span> + bs1);</span><br><span class="line"></span><br><span class="line"><span class="type">BitSet</span> <span class="variable">bs2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>();</span><br><span class="line">bs2.set(<span class="number">1</span>);</span><br><span class="line">bs2.set(<span class="number">2</span>);</span><br><span class="line">bs2.set(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;bs2 : &quot;</span> + bs2);</span><br><span class="line"></span><br><span class="line">bs2.xor(bs1);</span><br><span class="line">System.out.println(<span class="string">&quot;xor: &quot;</span> + bs2);</span><br></pre></td></tr></table></figure>

<p>最终的输出结果如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyfqb8umowj30iy05qdfx.jpg"></p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud Feign 实现动态 URL</title>
    <url>/2022/05/23/troubleshoot/SpringCloud-Feign-dynamic-url/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hksgjbitj21hc0u0ajs.jpg"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间同事碰到一个问题，需要在 <code>SpringCloud</code> 的 Feign 调用中使用自定义的 URL；通常情况下是没有这个需求的；毕竟都用了 <code>SpringCloud</code> 的了，那服务之间的调用都是走注册中心的，不会需要自定义 URL 的情况。</p>
<span id="more"></span>

<p>但也有特殊的，比如我们这里碰到 <code>ToB</code> 场景，需要对每个商户自定义的 <code>URL</code> 进行调用。</p>
<p>虽说也可以使用原生的 <code>Feign</code> 甚至是自定义一个 <code>OKHTTP Client</code> 实现，但这些方案都得换一种写法；</p>
<p>打算利用现有的 <code>SpringCloud</code> <code>OpenFeign</code> 来实现，毕竟原生的 Feign 其实是支持该功能的，而 <code>SpringCloud OpenFeign</code> 也只是在这基础上封装了一层。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hmgcpmg5j21aa0bsjtl.jpg"></p>
<p>只需要在接口声明处加上一个 <code>URI</code> 参数即可，这样就可以在每次调用时传递不同的 <code>URI</code> 来实现动态 <code>URL</code> 的目的。</p>
<hr>
<p>想法很简单，但实践起来却不是那么回事了。<br>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;dynamic&quot;)</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DynamicClient</span> &#123;</span><br><span class="line">	<span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">	String <span class="title function_">get</span><span class="params">(URI uri)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dynamicClient.get(URI.create(<span class="string">&quot;https://github.com&quot;</span>));	</span><br></pre></td></tr></table></figure>

<p>执行后会抛出负载均衡的异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.RuntimeException: com.netflix.client.ClientException:</span><br><span class="line">Load balancer does not have available server <span class="keyword">for</span> client: github.com</span><br></pre></td></tr></table></figure>

<p>这个异常也能理解，就是找不到 github 这个服务；找不到也是合理的，毕竟也不是一个内部注册的服务。</p>
<p>但按照 <code>Feign</code> 的官方介绍，只要接口中声明了 <code>URI</code> 这个参数就能自定义，同时我自己也用原生的 Feign 测试过确实没什么问题。</p>
<h1 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h1><p>那问题只能出在 <code>SpringCloud OpenFeign</code> 的封装上了；经过同事的搜索在网上找到一篇博客解决了这个问题。</p>
<p><a href="https://www.cnblogs.com/syui-terra/p/14386188.html">https://www.cnblogs.com/syui-terra/p/14386188.html</a></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hmzxmu68j20xg0u0n16.jpg"></p>
<p>按照文中的说法，确实只需要加上 URL 参数同时有值就可以了，但原因不明。</p>
<p>本着打破砂锅问到底的精神，我个人也想知道 <code>OpenFeign</code> 是如何处理的，只要 url 有值就可以，这完全是个黑盒，而且在官方的注释中并没有对这种情况有特殊说明。</p>
<p>所以我准备从源码中找到答案。</p>
<p>既然是 url 有值就能正常运行，那一定是在运行过程中获取了这个值；</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hn5b81vtj211o0ds763.jpg"><br>但我在源码中查看 url 所使用的地方，并没有在单测之外找到哪里有所应用，说明源码中并没有直接调用 <code>url()</code> 这个函数来获取值。</p>
<p>但 <code>org.springframework.cloud.openfeign.FeignClient</code> 这个注解总会使用吧，于是我又查询这个注解的使用情况。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hnamym3tj22sh0u0tl4.jpg"><br>最终在这里查到了使用的痕迹。</p>
<blockquote>
<p>这里查阅源码时也有一些小技巧，比如如果我们直接查询时，IDEA 默认的查询范围是整个项目和所有依赖库，会有许多干扰信息。</p>
</blockquote>
<p>比如我这里就需要只看项目源码，单测这些都不用看；所以在查询的时候可以过滤一下，这样干扰信息就会少很多。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hndgadtzj22mo0u0wou.jpg"></p>
<p>左边的工具栏还有许多过滤条件，大家可以自行研究一下。</p>
<hr>
<p>接着从源码中进行阅读，会发现是将 <code>@FeignClient</code> 中的所有数据都写到一个 <code>Map</code> 里进行使用的。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hnfkwg9dj21920u0jyh.jpg"><br>最终会发现这个 url 被写入到了 <code>FeignClientFactoryBean</code> 中的 url 成员变量中了。</p>
<p>查看哪里在使用这个 url 就知道背后的原理了。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hnkav8hgj21l20rsdlb.jpg"></p>
<p>在这里打个断点会发现：当 url 为空时会返回一个 <code>LoadBalance</code> 的 <code>client</code>，也就是会从注册中心获取 <code>url</code> 的客户端，而 <code>url</code> 有值时则会获取一个默认的客户端，这样就不会走负载均衡了。</p>
<blockquote>
<p>所以我们如果想在 OpenFeign 中使用动态 url 时就得让 @Feign 的 url 有值才行，无论是什么都可以。</p>
</blockquote>
<h2 id="Feign-的实现"><a href="#Feign-的实现" class="headerlink" title="Feign 的实现"></a>Feign 的实现</h2><p>既然已经看到这一步了，我也比较好奇 Feign 是如何做到只要有 URI 参数就使用指定的 URL 呢？</p>
<blockquote>
<p>这里也分享一个读源码的小技巧，如果我们跟着程序执行的思路去一步步 <code>debug</code> 的话会非常消耗时间，毕竟这类成熟库的代码量也不小。</p>
</blockquote>
<p>这里我们从官方文档中可以得知只要在接口参数中使用了 <code>java.net.URI</code> 便会走自定义的 url，所以我们反过来只要在源码中找到哪里在使用 <code>java.net.URI</code> 便能知道关键源码。</p>
<p>毕竟使用 <code>java.net.URI</code> 的场景也不会太多。</p>
<hr>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hnw6rwq1j225408idia.jpg"><br>所以只需要在这个依赖的地方 <code>cmd+shift+f</code> 全局搜索 <code>java.net.URI</code> 就能查到结果，果然不多，只有两处使用。</p>
<hr>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hnzg6tcvj21r60sgjxn.jpg"><br>再结合使用场景猜测大概率是判断参数中是否是有 <code>URL.class</code> 这样的条件，或者是 url 对象；总之我们先用<br><code>URL</code> 这样关键字在这两个文件中搜索一下，记得勾选匹配大小写；最后会发现的确是判断了参数中是否有 <code>URL</code> 这个类，同时将这个索引位置记录了下来。</p>
<p>想必后续会通过这个索引位置读取最终的 <code>url</code> 信息。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ho2auls1j21v20daq7r.jpg"></p>
<p>最终通过这个索引的使用地方查询到了核心源码，如果有值时就取这个 URI 中所指定的地址作为 <code>target</code>。</p>
<p>到此为止这个问题的背后原理都已经分析完毕了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实本文重点是分析了一些 <code>debug</code> 和阅读源码的一些小技巧，特别是在读关于 <code>Spring</code> 相关的代码时一定不能 debug 跟踪到细节中，因为调用链通常是很长的，稍不留神就把自己都绕晕了，只需要知道核心、关键源码是如何处理的即可。</p>
<p>最后对于 OpenFeign 处理动态 url 的方案确实也有些疑惑，是一个典型的<code>约定大于配置</code>的场景，但问题就在于我们并不知道这个约定是 <code>@Feign</code>  的 url 得有值。</p>
<p>所以我也提了一个 <code>PR</code> 给 <code>OpenFeign</code>，感兴趣的朋友也可以查看一下：</p>
<p><a href="https://github.com/spring-cloud/spring-cloud-openfeign/pull/713">https://github.com/spring-cloud/spring-cloud-openfeign/pull/713</a></p>
]]></content>
      <categories>
        <category>问题排查</category>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>又一次生产 CPU 高负载排查实践</title>
    <url>/2019/06/18/troubleshoot/cpu-percent-100-02/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/06/18/5d07c34d2973a58018.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几日早上打开邮箱收到一封监控报警邮件：某某 ip 服务器 CPU 负载较高，请研发尽快排查解决，发送时间正好是凌晨。</p>
<p>其实早在去年我也处理过类似的问题，并记录下来：<a href="https://crossoverjie.top/2018/12/17/troubleshoot/cpu-percent-100/">《一次生产 CPU 100% 排查优化实践》</a></p>
<p>不过本次问题产生的原因却和上次不太一样，大家可以接着往下看。</p>
<span id="more"></span>

<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>收到邮件后我马上登陆那台服务器，看了下案发现场还在（负载依然很高）。</p>
<p>于是我便利用这类问题的排查套路定位一遍。</p>
<hr>
<p>首先利用 <code>top -c</code> 将系统资源使用情况实时显示出来 （<code>-c</code> 参数可以完整显示命令）。</p>
<p>接着输入<code>大写 P</code> 将应用按照 <code>CPU</code> 使用率排序，第一个就是使用率最高的程序。</p>
<p>果不其然就是我们的一个 <code>Java</code> 应用。</p>
<p>这个应用简单来说就是定时跑一些报表使的，每天凌晨会触发任务调度，正常情况下几个小时就会运行完毕。</p>
<hr>
<p>常规操作第二步自然是得知道这个应用中最耗 <code>CPU</code> 的线程到底再干嘛。</p>
<p>利用 <code>top -Hp pid</code> 然后输入 <code>P</code> 依然可以按照 <code>CPU</code> 使用率将线程排序。</p>
<p>这时我们只需要记住线程的 ID 将其转换为 16 进制存储起来，通过 <code>jstack pid &gt;pid.log</code> 生成日志文件，利用刚才保存的 16 进制进程 <code>ID</code> 去这个线程快照中搜索即可知道消耗 <code>CPU</code> 的线程在干啥了。</p>
<p>如果你嫌麻烦，我也强烈推荐阿里开源的问题定位神器 <code>arthas</code> 来定位问题。</p>
<p>比如上述操作便可精简为一个命令 <code>thread -n 3</code> 即可将最忙碌的三个线程快照打印出来，非常高效。</p>
<blockquote>
<p>更多关于 arthas 使用教程请参考<a href="https://alibaba.github.io/">官方文档</a>。</p>
</blockquote>
<p>由于之前忘记截图了，这里我直接得出结论吧：</p>
<p>最忙绿的线程是一个 <code>GC</code> 线程，也就意味着它在忙着做垃圾回收。</p>
<h2 id="GC-查看"><a href="#GC-查看" class="headerlink" title="GC 查看"></a>GC 查看</h2><p>排查到这里，有经验的老司机一定会想到：多半是应用内存使用有问题导致的。</p>
<p>于是我通过 <code>jstat -gcutil pid 200 50</code> 将内存使用、gc 回收状况打印出来（每隔 200ms 打印 50次）。</p>
<p><img src="https://i.loli.net/2019/06/18/5d07c3505157663161.jpg"></p>
<p>从图中可以得到以下几个信息：</p>
<ul>
<li><code>Eden</code> 区和 <code>old</code> 区都快占满了，可见内存回收是有问题的。</li>
<li><code>fgc</code> 回收频次很高，10s 之内发生了 8 次回收（<code>(866493-866485)/ (200 *5)</code>）。</li>
<li>持续的时间较长，fgc 已经发生了 8W 多次。</li>
</ul>
<h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><p>既然是初步定位是内存问题，所以还是得拿一份内存快照分析才能最终定位到问题。</p>
<p>通过命令 <code>jmap -dump:live,format=b,file=dump.hprof pid</code> 可以导出一份快照文件。</p>
<p>这时就得借助 <code>MAT</code> 这类的分析工具出马了。</p>
<h1 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h1><p><img src="https://i.loli.net/2019/06/18/5d07c351bb18f94417.jpg"></p>
<p>通过这张图其实很明显可以看出，在内存中存在一个非常大的字符串，而这个字符串正好是被这个定时任务的线程引用着。</p>
<p><img src="https://i.loli.net/2019/06/18/5d07c3533538b39583.jpg"></p>
<p>大概算了一下这个字符串所占的内存为 258m 左右，就一个字符串来说已经是非常大的对象了。</p>
<p>那这个字符串是咋产生的呢？</p>
<p>其实看上图中的引用关系及字符串的内容不难看出这是一个 <code>insert</code> 的 <code>SQL</code> 语句。</p>
<p>这时不得不赞叹 <code>MAT</code> 这个工具，他还能帮你预测出这个内存快照可能出现问题地方同时给出线程快照。</p>
<p><img src="https://i.loli.net/2019/06/18/5d07c353d3d2114320.jpg"></p>
<p><img src="https://i.loli.net/2019/06/18/5d07c3546d13811049.jpg"></p>
<p>最终通过这个线程快照找到了具体的业务代码：</p>
<p>他调用一个写入数据库的方法，而这个方法会拼接一个 <code>insert</code> 语句，其中的 <code>values</code> 是循环拼接生成，大概如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span>&gt;</span></span><br><span class="line">    insert into xx (files)</span><br><span class="line">    values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        xxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以一旦这个 list 非常大时，这个拼接的 SQL 语句也会很长。</p>
<p><img src="https://i.loli.net/2019/06/18/5d07c35504bf848706.jpg"></p>
<p>通过刚才的内存分析其实可以看出这个 <code>List</code> 也是非常大的，也就导致了最终的这个 <code>insert</code> 语句占用的内存巨大。</p>
<h1 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h1><p>既然找到问题原因那就好解决了，有两个方向：</p>
<ul>
<li>控制源头 <code>List</code> 的大小，这个 <code>List</code> 也是从某张表中获取的数据，可以分页获取；这样后续的 <code>insert</code> 语句就会减小。</li>
<li>控制批量写入数据的大小，其实本质还是要把这个拼接的 <code>SQL</code> 长度降下来。</li>
<li>整个的写入效率需要重新评估。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次问题从分析到解决花的时间并不长，也还比较典型，其中的过程再总结一下：</p>
<ul>
<li>首先定位消耗 <code>CPU</code> 进程。</li>
<li>再定位消耗 <code>CPU</code> 的具体线程。</li>
<li>内存问题 <code>dump</code> 出快照进行分析。</li>
<li>得出结论，调整代码，测试结果。</li>
</ul>
<p>最后愿大家都别接到生产告警。</p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>问题排查</category>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>一次生产 CPU 100% 排查优化实践</title>
    <url>/2018/12/17/troubleshoot/cpu-percent-100/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1c380ee196.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>到了年底果然都不太平，最近又收到了运维报警：表示有些服务器负载非常高，让我们定位问题。</p>
<p>还真是想什么来什么，前些天还故意把某些服务器的负载提高（<a href="https://crossoverjie.top/2018/12/12/java-senior/java-memary-allocation/">没错，老板让我写个 BUG！</a>），不过还好是不同的环境互相没有影响。</p>
<span id="more"></span>

<h1 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h1><p>拿到问题后首先去服务器上看了看，发现运行的只有我们的 Java 应用。于是先用 <code>ps</code> 命令拿到了应用的 <code>PID</code>。</p>
<p>接着使用 <code>top -Hp pid</code> 将这个进程的线程显示出来。输入大写的 P 可以将线程按照 CPU 使用比例排序，于是得到以下结果。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c38c19186.jpg"></p>
<p>果然某些线程的 CPU 使用率非常高。</p>
<p>为了方便定位问题我立马使用 <code>jstack pid &gt; pid.log</code> 将线程栈 <code>dump</code> 到日志文件中。</p>
<p>我在上面 100% 的线程中随机选了一个 <code>pid=194283</code> 转换为 16 进制（2f6eb）后在线程快照中查询：</p>
<blockquote>
<p>因为线程快照中线程 ID 都是16进制存放。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3910d043.jpg"></p>
<p>发现这是 <code>Disruptor</code> 的一个堆栈，前段时间正好解决过一个由于 Disruptor 队列引起的一次 <a href="">OOM</a>：<a href="https://crossoverjie.top/2018/08/29/java-senior/OOM-Disruptor/">强如 Disruptor 也发生内存溢出？</a></p>
<p>没想到又来一出。</p>
<p>为了更加直观的查看线程的状态信息，我将快照信息上传到专门分析的平台上。</p>
<p><a href="http://fastthread.io/">http://fastthread.io/</a></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3ab0f5ff.jpg"></p>
<p>其中有一项菜单展示了所有消耗 CPU 的线程，我仔细看了下发现几乎都是和上面的堆栈一样。</p>
<p>也就是说都是 <code>Disruptor</code> 队列的堆栈，同时都在执行 <code>java.lang.Thread.yield</code> 函数。</p>
<p>众所周知 <code>yield</code> 函数会让当前线程让出 <code>CPU</code> 资源，再让其他线程来竞争。</p>
<p>根据刚才的线程快照发现处于 <code>RUNNABLE</code> 状态并且都在执行 <code>yield</code> 函数的线程大概有 30几个。</p>
<p>因此初步判断为大量线程执行 <code>yield</code> 函数之后互相竞争导致 CPU 使用率增高，而通过对堆栈发现是和使用 <code>Disruptor</code> 有关。</p>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>而后我查看了代码，发现是根据每一个业务场景在内部都会使用 2 个 <code>Disruptor</code> 队列来解耦。</p>
<p>假设现在有 7 个业务类型，那就等于是创建 <code>2*7=14</code> 个 <code>Disruptor</code> 队列，同时每个队列有一个消费者，也就是总共有 14 个消费者（生产环境更多）。</p>
<p>同时发现配置的消费等待策略为 <code>YieldingWaitStrategy</code> 这种等待策略确实会执行 yield 来让出 CPU。</p>
<p>代码如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3ae66cc2.jpg"></p>
<blockquote>
<p>初步看来和这个等待策略有很大的关系。</p>
</blockquote>
<h2 id="本地模拟"><a href="#本地模拟" class="headerlink" title="本地模拟"></a>本地模拟</h2><p>为了验证，我在本地创建了 15 个 <code>Disruptor</code> 队列同时结合监控观察 CPU 的使用情况。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3b0d6d5a.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1c3b3ef165.jpg"></p>
<p>创建了 15 个 <code>Disruptor</code> 队列，同时每个队列都用线程池来往 <code>Disruptor队列</code> 里面发送 100W 条数据。</p>
<p>消费程序仅仅只是打印一下。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3b66fafb.jpg"></p>
<p>跑了一段时间发现 CPU 使用率确实很高。</p>
<hr>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3c197591.jpg"></p>
<p>同时 <code>dump</code> 线程发现和生产的现象也是一致的：消费线程都处于 <code>RUNNABLE</code> 状态，同时都在执行 <code>yield</code>。</p>
<p>通过查询 <code>Disruptor</code> 官方文档发现：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3cc50d2b.jpg"></p>
<blockquote>
<p>YieldingWaitStrategy 是一种充分压榨 CPU 的策略，使用<code>自旋 + yield</code>的方式来提高性能。<br>当消费线程（Event Handler threads）的数量小于 CPU 核心数时推荐使用该策略。</p>
</blockquote>
<hr>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3cfde11c.jpg"></p>
<p>同时查阅到其他的等待策略 <code>BlockingWaitStrategy</code> （也是默认的策略），它使用的是锁的机制，对 CPU 的使用率不高。</p>
<p>于是在和之前同样的条件下将等待策略换为 <code>BlockingWaitStrategy</code>。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3d7796af.jpg"></p>
<hr>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3d9e7670.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1c3dd370af.jpg"></p>
<p>和刚才的 CPU 对比会发现到后面使用率的会有明显的降低；同时 dump 线程后会发现大部分线程都处于 waiting 状态。</p>
<h2 id="优化解决"><a href="#优化解决" class="headerlink" title="优化解决"></a>优化解决</h2><p>看样子将等待策略换为 <code>BlockingWaitStrategy</code> 可以减缓 CPU 的使用，</p>
<p>但留意到官方对 <code>YieldingWaitStrategy</code> 的描述里谈道：<br>当消费线程（Event Handler threads）的数量小于 CPU 核心数时推荐使用该策略。</p>
<p>而现有的使用场景很明显消费线程数已经大大的超过了核心 CPU 数了，因为我的使用方式是一个 <code>Disruptor</code> 队列一个消费者，所以我将队列调整为只有 1 个再试试(策略依然是 <code>YieldingWaitStrategy</code>)。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3e03d6b7.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c3e2eaafb.jpg"></p>
<p>跑了一分钟，发现 CPU 的使用率一直都比较平稳而且不高。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以排查到此可以有一个结论了，想要根本解决这个问题需要将我们现有的业务拆分；现在是一个应用里同时处理了 N 个业务，每个业务都会使用好几个 <code>Disruptor</code> 队列。</p>
<p>由于是在一台服务器上运行，所以 CPU 资源都是共享的，这就会导致 CPU 的使用率居高不下。</p>
<p>所以我们的调整方式如下：</p>
<ul>
<li>为了快速缓解这个问题，先将等待策略换为 <code>BlockingWaitStrategy</code>，可以有效降低 CPU 的使用率（业务上也还能接受）。</li>
<li>第二步就需要将应用拆分（上文模拟的一个 <code>Disruptor</code> 队列），一个应用处理一种业务类型；然后分别单独部署，这样也可以互相隔离互不影响。</li>
</ul>
<p>当然还有其他的一些优化，因为这也是一个老系统了，这次 dump 线程居然发现创建了 800+ 的线程。</p>
<p>创建线程池的方式也是核心线程数、最大线程数是一样的，导致一些空闲的线程也得不到回收；这样会有很多无意义的资源消耗。</p>
<p>所以也会结合业务将创建线程池的方式调整一下，将线程数降下来，尽量的物尽其用。</p>
<p>本文的演示代码已上传至 GitHub：</p>
<p><a href="https://github.com/crossoverJie/JCSprout/tree/master/src/main/java/com/crossoverjie/disruptor">https://github.com/crossoverJie/JCSprout</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>问题排查</category>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>concurrent</tag>
        <tag>JVM</tag>
        <tag>disruptor</tag>
      </tags>
  </entry>
  <entry>
    <title>What？一个 Dubbo 服务启动要两个小时！</title>
    <url>/2019/07/05/troubleshoot/dubbo-start-slow/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/07/04/5d1e14ea0052047268.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几天在测试环境碰到一个非常奇怪的与 <code>dubbo</code> 相关的问题，事后我在网上搜索了一圈并没有发现类似的帖子或文章，于是便有了这篇。</p>
<p>希望对还未碰到或正在碰到的朋友有所帮助。</p>
<span id="more"></span>

<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>现象是这样的，有一天测试在测试环境重新部署一个 <code>dubbo</code> 应用的时候发现应用<code>“启动不起来”</code>。</p>
<p>但过几个小时候之后又能自己慢慢恢复，并能够对外提供 <code>dubbo</code> 服务。</p>
<blockquote>
<p>但其实经过我后续排查发现刚开始其实并不是启动不起来，而是启动速度非常缓慢，所以当应用长时间启动后才会对外提供服务。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/07/04/5d1e14eb2d3b613329.jpg"></p>
<p>而这个速度慢到居然要花费 <code>2 个小时</code>。</p>
<p>导致的一个结果是测试完全不敢在测试环境发版验证了，每验证一个功能修复一个 <code>bug</code> 就得等上两个小时，这谁受得了😂。</p>
<blockquote>
<p>而且经过多次观察，确实每次都是花费两小时左右应用才能启动起来。</p>
</blockquote>
<h1 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h1><p>最后测试顶不住了，只能让我这个<code>“事故报告撰写专家”</code>来看看。</p>
<p>当我得知这个问题的现象时其实完全没当一回事：</p>
<blockquote>
<p>都不用想，这不就是主线程阻塞了嘛，先看看是否在初始化的时候数据库、Zookeeper 之类的连不上导致阻塞了——-来之多次事故处理的经验告诉我。</p>
</blockquote>
<p>于是我把这事打回给测试让他先找运维排查下，不到万不得已不要影响我 <code>Touch fish</code>🐳。</p>
<p>第二天一早看到测试同学的微信头像跳动时我都已经准备接受又一句 <code>“膜拜大佬👍”</code> 的回复时，却收到 “网络一切正常，没人动过，再不解决就要罢工了🤬”。</p>
<p>好吧，忽悠不过去了。</p>
<p>首先这类问题的排查方向应该不会错，就是主线程阻塞了，至于是啥导致的阻塞就不能像之前那样瞎猜了。</p>
<p>我将应用重启后用 <code>jstack pid</code> 将线程快照打印到终端，直接拉到最后看看 <code>main</code> 线程到底在干啥。</p>
<p>前几次的快照都是很正常：</p>
<p>加载 <code>Spring</code> —-&gt;连接 <code>Zookeeper</code> —&gt; 连接 <code>Redis</code>，都是依次执行下来没有阻塞。</p>
<p>隔了一段后应用确实还没起来，我再次 <code>jstack</code> 后得到如下信息：</p>
<p><img src="https://i.loli.net/2019/07/04/5d1e14ec2185426171.jpg"></p>
<h2 id="翻源码"><a href="#翻源码" class="headerlink" title="翻源码"></a>翻源码</h2><p>我一直等了十几分钟再多次 <code>jstack</code> 得到的快照得到的信息都是一样的。</p>
<p><img src="https://i.loli.net/2019/07/04/5d1e14ec2185426171.jpg"></p>
<p>如图所示可见主线程是卡在了 dubbo 的某个方法 <code>ServiceConfig.java</code> 的 303 行中。</p>
<p>于是我找到此处的源码：</p>
<p><img src="https://i.loli.net/2019/07/04/5d1e14ec68e8259933.jpg"></p>
<p>简单来说这里的逻辑就是要获取本机的 <code>IP</code> 将其注册到 <code>Zookeeper</code> 中用于其他服务调用。</p>
<p><img src="https://i.loli.net/2019/07/04/5d1e14eca624d69950.jpg"></p>
<p>再往下跟就如堆栈中一样是卡在了 <code>Inet4AddressImpl.getLocalHostName</code> 处。</p>
<p>但这是一个 <code>native</code> 方法，我们应用也根本干涉不了，最终的现象就是调用这个本地方法非常耗时。</p>
<p>于是这问题貌似也阻塞在这儿了，没有太多办法。</p>
<h1 id="最终解决"><a href="#最终解决" class="headerlink" title="最终解决"></a>最终解决</h1><p>既然这是一个 native 方法，那说明和应用本身没有啥关系（确实也是这样，这个问题是突然间出现的。）</p>
<p>那是否是服务器本身的问题呢，想到在 <code>native</code> 方法里是获取本机的 <code>hostname</code>，那是否和这个 <code>hostname</code> 有关系呢。</p>
<p><img src="https://i.loli.net/2019/07/04/5d1e14ecd59a795394.jpg"></p>
<blockquote>
<p>这是在我自己的阿里云服务器上测试，真正的测试环境不是这个名字。</p>
</blockquote>
<p>拿到服务器 <code>hostname</code> 后再尝试 <code>ping</code> 这个 <code>hostname</code>，奇怪的现象发生了：</p>
<p>命令刚开始会卡住一段时间（大概几十秒），然后才会输出 <code>hostname</code> 对应的 <code>ip</code> 以及对应的延迟。</p>
<p>而当我直接 <code>ping</code> 这个 <code>ip</code> 时却能快速响应后面的输出。</p>
<p>最后我尝试在 &#x2F;etc&#x2F;hosts 配置文件中加入了对应的 host 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xx.xx.xx.xx(ip) hostname</span><br></pre></td></tr></table></figure>

<p>再次 <code>ping hostname</code> 的效果就和直接 <code>ping ip</code> 一样了。</p>
<p><strong>于是我再次重启应用，一切都正常了。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后根据我调整的内容尝试分析下本次问题的原因：</p>
<ul>
<li>当 <code>Dubbo</code> 在启动获取本地 ip 时，是通过服务器 <code>hostname</code> 从 <code>dns</code> 服务器返回当前的 ip 地址。</li>
<li>由于 <code>dns</code> 服务器或者是本地服务器与 dns 服务器之间存在网络问题，导致这个过程的时间被拉长（猜测）。</li>
<li>我在本地的 <code>host</code> 文件中配置后，就相当于本地有一个缓存，优先取本地配置的 ip ，避免了和 dns 服务器交互的过程，所以速度提升了。</li>
</ul>
<p>虽然问题得到解决了，但还是有几个疑问：</p>
<p>第一个是为什么和 <code>DNS</code> 服务器的交互会这么慢，即便是慢也没有像应用那样需要 2 个小时才能返回，这里我也没搞得太清楚，有相关经验的朋友可以留言讨论。</p>
<p>第二就是 Dubbo 在这个依赖外部获取资源时健壮性是否可以做的更好，虽说我这问题估计也几人碰到。</p>
<p>对于这种长时间没有启动成功的问题是否可以加上提示，比如直接抛出异常退出程序，将问题可能的原因告诉开发者，方便排查问题。</p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>问题排查</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Pulsar 重复消费?</title>
    <url>/2022/03/18/troubleshoot/pulsar-repeat-consume/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h09wy1o5v8j20rs0rs408.jpg"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>许久没有分享 Java 相关的问题排查了，最近帮同事一起排查了一个问题：</p>
<blockquote>
<p>在使用 <code>Pulsar</code> 消费时，发生了同一条消息反复消费的情况。</p>
</blockquote>
<span id="more"></span>

<h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>当他告诉我这个现象的时候我就持怀疑态度，根据之前使用的经验 Pulsar 在官方文档以及 API 中都解释过：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0c6a9vzvuj216y05gdhd.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0c6apssrmj21t00o8afc.jpg"><br>只有当设置了消费的 <code>ackTimeout</code> 并超时消费时才会重复投递消息，默认情况下是关闭的，查看代码也确实没有开启。</p>
<p>那会不会是调用了 <code>negativeAcknowledge()</code> 方法呢（调用该方法也会触发重新投递），因为我们使了一个第三方库 <a href="https://github.com/majusko/pulsar-java-spring-boot-starter">https://github.com/majusko/pulsar-java-spring-boot-starter</a> 只有当抛出异常时才会调用该方法。</p>
<p>查阅代码之后也没有地方抛出异常，甚至整个过程中都没看到异常产生；这就有点诡异了。</p>
<h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>为了捋清楚整个事情的来龙去脉，详细了解了他的使用流程；</p>
<p>其实也就是业务出现了 <code>bug</code>，他在消息消费时 <code>debug</code> 然后进行单步调试，当走完一次调试后，没多久马上又收到了同样的消息。</p>
<p>但奇怪的是也不是每次 <code>debug</code> 后都能重复消费，我们都说如果一个 <code>bug</code> 能 100% 完全复现，那基本上就解决一大半了。</p>
<p>所以我们排查的第一步就是完全复现这个问题。</p>
<hr>
<p>为了排除掉是 IDEA 的问题（虽然极大概率不太可能）既然是 <code>debug</code> 的时候产生的问题，那其实转换到代码也就是 <code>sleep</code> 嘛，所以我们打算在消费逻辑里直接 <code>sleep</code> 一段时间看能否复现。</p>
<p>经过测试，<code>sleep</code> 几秒到几十秒都无法复现，最后索性 <code>sleep</code> 一分钟，神奇的事情发生了，每次都成功复现！</p>
<p>既然能成功复现那就好说了，因为我自己的业务代码也有使用到 <code>Pulsar</code> 的地方，为了方便调试就准备在自己的项目里再复现一次。</p>
<p>结果诡异的事情再次发生，我这里又不能复现了。</p>
<blockquote>
<p>虽然这才是符合预期的，但这就没法调了呀。</p>
</blockquote>
<p>本着相信现代科学的前提，我们俩唯一的区别就是项目不一样了，为此我对比了两边的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PulsarConsumer(</span></span><br><span class="line"><span class="meta">        topic = xx,</span></span><br><span class="line"><span class="meta">        clazz = Xx.class,</span></span><br><span class="line"><span class="meta">        subscriptionType = SubscriptionType.Shared</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(Data msg)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;consume msg:&#123;&#125;&quot;</span>, msg.getOrderId());</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> redisLockRegistry.obtain(msg.getOrderId());</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            orderService.<span class="keyword">do</span>(msg.getOrderId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;consumer msg:&#123;&#125; err:&quot;</span>, msg.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果不出所料，同事那边的代码加了锁；一个基于 Redis 的分布式锁，这时我一拍大腿不会是解锁的时候超时了导致抛了异常吧。</p>
<p>为了验证这个问题，在能复现的基础上我在框架的 <code>Pulsar</code> 消费处打了断点：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0c4tmq9dhj22zg0hon4e.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0c5xve3qaj21ss070q4u.jpg"><br>果然破案了，异常提示已经非常清楚了：加锁已经过了超时时间。</p>
<p>进入异常后直接 <code>negative</code> 消息，同时异常也被吃掉了，所以之前没有发现。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0dckg14crj21l60maq88.jpg"><br>查阅了 <code>RedisLockRegistry</code> 的源码，默认超时时间正好是一分钟，所以之前我们 <code>sleep</code> 几十秒也无法复现这个问题。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>事后我向同事了解了下为啥这里要加锁，因为我看下来完全没有加锁的必要；结果他是因为从别人那里复制的代码才加上的，压根没想那么多。</p>
<p>所以这事也能得出一些教训：</p>
<ul>
<li>ctrl C&#x2F;V 虽然方便，但也得充分考虑自己的业务场景。</li>
<li>使用一些第三方 API 时，需要充分了解其作用、参数。</li>
</ul>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>问题排查</category>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Pulsar</tag>
        <tag>Consumer</tag>
      </tags>
  </entry>
  <entry>
    <title>一个线程罢工的诡异事件</title>
    <url>/2019/03/12/troubleshoot/thread-gone/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/04/29/5cc656743cc4f.jpg"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>事情（事故）是这样的，突然收到报警，线上某个应用里业务逻辑没有执行，导致的结果是数据库里的某些数据没有更新。</p>
<p>虽然是前人写的代码，但作为 <code>Bug maker&amp;killer</code> 只能咬着牙上了。</p>
<span id="more"></span>

<p>因为之前没有接触过出问题这块的逻辑，所以简单理了下如图：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1be99551d0.jpg"></p>
<ol>
<li>有一个生产线程一直源源不断的往队列写数据。</li>
<li>消费线程也一直不停的取出数据后写入后续的业务线程池。</li>
<li>业务线程池里的线程会对每个任务进行入库操作。</li>
</ol>
<p>整个过程还是比较清晰的，就是一个典型的生产者消费者模型。</p>
<h1 id="尝试定位"><a href="#尝试定位" class="headerlink" title="尝试定位"></a>尝试定位</h1><p>接下来便是尝试定位这个问题，首先例行检查了以下几项：</p>
<ul>
<li>是否内存有内存溢出？</li>
<li>应用 GC 是否有异常？</li>
</ul>
<p>通过日志以及监控发现以上两项都是正常的。</p>
<p>紧接着便 dump 了线程快照查看业务线程池中的线程都在干啥。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1be9a3cd7f.jpg"></p>
<p>结果发现所有业务线程池都处于 <code>waiting</code> 状态，队列也是空的。</p>
<p>同时生产者使用的队列却已经满了，没有任何消费迹象。</p>
<p>结合上面的流程图不难发现应该是消费队列的 <code>Consumer</code> 出问题了，导致上游的队列不能消费，下有的业务线程池没事可做。</p>
<h2 id="review-代码"><a href="#review-代码" class="headerlink" title="review 代码"></a>review 代码</h2><p>于是查看了消费代码的业务逻辑，同时也发现消费线程是一个<strong>单线程</strong>。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1be9c9d525.jpg"></p>
<p>结合之前的线程快照，我发现这个消费线程也是处于 waiting 状态，和后面的业务线程池一模一样。</p>
<p>他做的事情基本上就是对消息解析，之后丢到后面的业务线程池中，没有发现什么特别的地方。</p>
<blockquote>
<p>但是由于里面的分支特别多（switch case），看着有点头疼；所以我与写这个业务代码的同学沟通后他告诉我确实也只是入口处解析了一下数据，后续所有的业务逻辑都是丢到线程池中处理的，于是我便带着这个前提去排查了（埋下了伏笔）。</p>
</blockquote>
<p>因为这里消费的队列其实是一个 <code>disruptor</code> 队列；它和我们常用的 <code>BlockQueue</code> 不太一样，不是由开发者自定义一个消费逻辑进行处理的；而是在初始化队列时直接丢一个线程池进去，它会在内部使用这个线程池进行消费，同时回调一个方法，在这个方法里我们写自己的消费逻辑。</p>
<p>所以对于开发者而言，这个消费逻辑其实是一个黑盒。</p>
<p>于是在我反复 <code>review</code> 了消费代码中的数据解析逻辑发现不太可能出现问题后，便开始疯狂怀疑是不是 <code>disruptor</code> 自身的问题导致这个消费线程罢工了。</p>
<p>再翻了一阵 <code>disruptor</code> 的源码后依旧没发现什么问题后我咨询对 <code>disruptor</code> 较熟的@咖啡拿铁，在他的帮助下在本地模拟出来和生产一样的情况。</p>
<h1 id="本地模拟"><a href="#本地模拟" class="headerlink" title="本地模拟"></a>本地模拟</h1><p><img src="https://i.loli.net/2019/05/08/5cd1bea23336f.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1bea2971ea.jpg"></p>
<p>本地也是创建了一个单线程的线程池，分别执行了两个任务。</p>
<ul>
<li>第一个任务没啥好说的，就是简单的打印。</li>
<li>第二个任务会对一个数进行累加，加到 10 之后就抛出一个未捕获的异常。</li>
</ul>
<p>接着我们来运行一下。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bea331666.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1bea3dd8de.jpg"></p>
<p>发现当任务中抛出一个没有捕获的异常时，线程池中的线程就会处于 <code>waiting</code> 状态，同时所有的堆栈都和生产相符。</p>
<blockquote>
<p>细心的朋友会发现正常运行的线程名称和异常后处于 waiting 状态的线程名称是不一样的，这个后续分析。</p>
</blockquote>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p><img src="https://i.loli.net/2019/05/08/5cd1bea429f43.jpg"></p>
<p>当加入异常捕获后又如何呢？</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beaa83375.jpg"></p>
<p>程序肯定会正常运行。</p>
<blockquote>
<p>同时会发现所有的任务都是由一个线程完成的。</p>
</blockquote>
<p>虽说就是加了一行代码，但我们还是要搞清楚这里面的门门道道。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>于是只有直接 <code>debug</code> 线程池的源码最快了；</p>
<hr>
<p><img src="https://i.loli.net/2019/05/08/5cd1beab1d59c.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beac3a696.jpg"></p>
<p>通过刚才的异常堆栈我们进入到 <code>ThreadPoolExecutor.java:1142</code> 处。</p>
<ul>
<li>发现线程池已经帮我们做了异常捕获，但依然会往上抛。</li>
<li>在 <code>finally</code> 块中会执行 <code>processWorkerExit(w, completedAbruptly)</code> 方法。</li>
</ul>
<p><img src="https://i.loli.net/2019/05/08/5cd1beb4cde74.jpg"></p>
<p>看过之前<a href="https://crossoverjie.top/2018/07/29/java-senior/ThreadPool/">《如何优雅的使用和理解线程池》</a>的朋友应该还会有印象。</p>
<p>线程池中的任务都会被包装为一个内部 <code>Worker</code> 对象执行。</p>
<p><code>processWorkerExit</code> 可以简单的理解为是把当前运行的线程销毁（<code>workers.remove(w)</code>）、同时新增（<code>addWorker()</code>）一个 <code>Worker</code> 对象接着处理；</p>
<blockquote>
<p>就像是哪个零件坏掉后重新换了一个新的接着工作，但是旧零件负责的任务就没有了。</p>
</blockquote>
<p>接下来看看 <code>addWorker()</code> 做了什么事情：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beb58e9f7.jpg"></p>
<p>只看这次比较关心的部分；添加成功后会直接执行他的 <code>start()</code> 的方法。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beb65d907.jpg"></p>
<p>由于 <code>Worker</code> 实现了 <code>Runnable</code> 接口，所以本质上就是调用了 <code>runWorker()</code> 方法。</p>
<hr>
<p>在 <code>runWorker()</code> 其实就是上文 <code>ThreadPoolExecutor</code> 抛出异常时的那个方法。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bebd51313.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1bebe2496b.jpg"></p>
<p>它会从队列里一直不停的获取待执行的任务，也就是 <code>getTask()</code>；在 <code>getTask</code> 也能看出它会一直从内置的队列取出任务。</p>
<p>而一旦队列是空的，它就会 <code>waiting</code> 在 <code>workQueue.take()</code>，也就是我们从堆栈中发现的 1067 行代码。</p>
<h2 id="线程名字的变化"><a href="#线程名字的变化" class="headerlink" title="线程名字的变化"></a>线程名字的变化</h2><p><img src="https://i.loli.net/2019/05/08/5cd1bebf2cded.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1bec02c9a8.jpg"><br><img src="https://i.loli.net/2019/05/08/5cd1bec0c4ffe.jpg"></p>
<p>上文还提到了异常后的线程名称发生了改变，其实在 <code>addWorker()</code> 方法中可以看到 <code>new Worker()</code>时就会重新命名线程的名称，默认就是把后缀的计数+1。</p>
<p>这样一切都能解释得通了，真相只有一个：</p>
<blockquote>
<p>在单个线程的线程池中一但抛出了未被捕获的异常时，线程池会回收当前的线程并创建一个新的 <code>Worker</code>；<br>它也会一直不断的从队列里获取任务来执行，但由于这是一个消费线程，根本没有生产者往里边丢任务，所以它会一直 waiting 在从队列里获取任务处，所以也就造成了线上的队列没有消费，业务线程池没有执行的问题。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以之后线上的那个问题加上异常捕获之后也变得正常了，但我还是有点纳闷的是：</p>
<blockquote>
<p>既然后续所有的任务都是在线程池中执行的，也就是纯异步了，那即便是出现异常也不会抛到消费线程中啊。</p>
</blockquote>
<p>这不是把我之前储备的知识点推翻了嘛？不信邪！之后我让运维给了加上异常捕获后的线上错误日志。</p>
<p>结果发现在上文提到的众多 <code>switch case</code> 中，最后一个竟然是直接操作的数据库，导致一个非空字段报错了🤬！！</p>
<p>这事也给我个教训，还是得眼见为实啊。</p>
<p>虽然这个问题改动很小解决了，但复盘整个过程还是有许多需要改进的：</p>
<ol>
<li>消费队列的线程名称竟然和业务线程的前缀一样，导致我光找它就花了许多时间，命名必须得调整。</li>
<li>开发规范，防御式编程大家需要养成习惯。</li>
<li>未知的技术栈需要谨慎，比如 <code>disruptor</code>，之前的团队应该只是看了个高性能的介绍就直接使用，并没有深究其原理；导致出现问题后对它拿不准。</li>
</ol>
<p>实例代码：</p>
<p><a href="https://github.com/crossoverJie/JCSprout/blob/master/src/main/java/com/crossoverjie/thread/ThreadExceptionTest.java">https://github.com/crossoverJie/JCSprout/blob/master/src/main/java/com/crossoverjie/thread/ThreadExceptionTest.java</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>问题排查</category>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>concurrent</tag>
        <tag>disruptor</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池中你不容错过的一些细节</title>
    <url>/2019/03/26/troubleshoot/thread-gone2/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/04/29/5cc655fb0f18c.jpg"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>上周分享了一篇<a href="https://crossoverjie.top/2019/03/12/troubleshoot/thread-gone/">《一个线程罢工的诡异事件》</a>，最近也在公司内部分享了这个案例。</p>
<p>无独有偶，在内部分享的时候也有小伙伴问了之前分享时所提出的一类问题：</p>
<span id="more"></span>

<p><img src="https://i.loli.net/2019/05/08/5cd1bec753b00.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bec8136a7.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bec8ca8f7.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bec980288.jpg"></p>
<p>这其实是一类共性问题，我认为主要还是两个原因：</p>
<ul>
<li>我自己确实也没讲清楚，之前画的那张图还需要再完善，有些误导。</li>
<li>第二还是大家对线程池的理解不够深刻，比如今天要探讨的内容。</li>
</ul>
<h1 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h1><p>首先还是来复习下线程池的基本原理。</p>
<p>我认为线程池它就是一个<strong>调度任务</strong>的工具。</p>
<p>众所周知在初始化线程池会给定线程池的大小，假设现在我们有 1000 个线程任务需要运行，而线程池的大小为 10<del>20，在真正运行任务的过程中他肯定不会创建这1000个线程同时运行，而是充分利用线程池里这 10</del>20 个线程来调度这1000个任务。</p>
<p>而这里的 10~20 个线程最后会由线程池封装为 <code>ThreadPoolExecutor.Worker</code> 对象，而这个 <code>Worker</code> 是实现了 Runnable 接口的，所以他自己本身就是一个线程。</p>
<h1 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h1><p><img src="https://i.loli.net/2019/05/08/5cd1bec9eea43.jpg"></p>
<p>这里我们来做一个模拟，创建了一个核心线程、最大线程数、阻塞队列都为2的线程池。</p>
<p>这里假设线程池已经完成了预热，也就是线程池内部已经创建好了两个线程 <code>Worker</code>。</p>
<p>当我们往一个线程池丢一个任务会发生什么事呢？</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bed130c18.jpg"></p>
<ul>
<li>第一步是生产者，也就是任务提供者他执行了一个 execute() 方法，本质上就是往这个内部队列里放了一个任务。</li>
<li>之前已经创建好了的 Worker 线程会执行一个 <code>while</code> 循环 —&gt; 不停的从这个<code>内部队列</code>里获取任务。(这一步是竞争的关系，都会抢着从队列里获取任务，由这个队列内部实现了线程安全。)</li>
<li>获取得到一个任务后，其实也就是拿到了一个 <code>Runnable</code> 对象(也就是 <code>execute(Runnable task)</code> 这里所提交的任务)，接着执行这个 <code>Runnable</code> 的 **run() 方法，而不是 start()**，这点需要注意后文分析原因。</li>
</ul>
<p>结合源码来看：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bed1e2402.jpg"></p>
<p>从图中其实就对应了刚才提到的二三两步：</p>
<ul>
<li><code>while</code> 循环，从 <code>getTask()</code> 方法中一直不停的获取任务。</li>
<li>拿到任务后，执行它的 run() 方法。</li>
</ul>
<p>这样一个线程就调度完毕，然后再次进入循环从队列里取任务并不断的进行调度。</p>
<h1 id="再次解释之前的问题"><a href="#再次解释之前的问题" class="headerlink" title="再次解释之前的问题"></a>再次解释之前的问题</h1><p>接下来回顾一下我们上一篇文章所提到的，导致一个线程没有运行的根本原因是：</p>
<blockquote>
<p>在单个线程的线程池中一但抛出了未被捕获的异常时，线程池会回收当前的线程并创建一个新的 <code>Worker</code>；<br>它也会一直不断的从队列里获取任务来执行，但由于这是一个消费线程，<strong>根本没有生产者往里边丢任务</strong>，所以它会一直 waiting 在从队列里获取任务处，所以也就造成了线上的队列没有消费，业务线程池没有执行的问题。</p>
</blockquote>
<p>结合之前的那张图来看：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bed23cd35.jpg"></p>
<p>这里大家问的最多的一个点是，为什么会没有是<code>根本没有生产者往里边丢任务</code>，图中不是明明画的有一个 <code>product</code> 嘛？</p>
<p>这里确实是有些不太清楚，再次强调一次：</p>
<p><strong>图中的 product 是往内部队列里写消息的生产者，并不是往这个 Consumer 所在的线程池中写任务的生产者。</strong></p>
<p>因为即便 <code>Consumer</code> 是一个单线程的线程池，它依然具有一个常规线程池所具备的所有条件：</p>
<ul>
<li>Worker 调度线程，也就是线程池运行的线程；虽然只有一个。</li>
<li>内部的阻塞队列；虽然长度只有1。</li>
</ul>
<p>再次结合图来看：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1bed2bd074.jpg"></p>
<p>所以之前提到的【没有生产者往里边丢任务】是指右图放大后的那一块，也就是内部队列并没有其他线程往里边丢任务执行 <code>execute()</code> 方法。</p>
<p>而一旦发生未捕获的异常后，<code>Worker1</code> 被回收，顺带的它所调度的线程 <code>task1</code>（这个task1 也就是在执行一个 while 循环消费左图中的那个队列） 也会被回收掉。</p>
<p>新创建的 <code>Worker2</code> 会取代 <code>Worker1</code> 继续执行 <code>while</code> 循环从内部队列里获取任务，但此时这个队列就一直会是空的，所以也就是处于 <code>Waiting</code> 状态。</p>
<blockquote>
<p>我觉得这波解释应该还是讲清楚了，欢迎还没搞明白的朋友留言讨论。</p>
</blockquote>
<h1 id="为什是-run-而不是-start"><a href="#为什是-run-而不是-start" class="headerlink" title="为什是 run() 而不是 start()"></a>为什是 run() 而不是 start()</h1><p>问题搞清楚后来想想为什么线程池在调度的时候执行的是 <code>Runnable</code> 的 <code>run()</code> 方法，而不是 <code>start()</code> 方法呢？</p>
<p>我相信大部分没有看过源码的同学心中第一个印象就应该是执行的 <code>start()</code> 方法；</p>
<p>因为不管是学校老师，还是网上大牛讲的都是只有执行了<code> start()</code> 方法后操作系统才会给我们创建一个独立的线程来运行，而 <code>run()</code> 方法只是一个普通的方法调用。</p>
<p>而在线程池这个场景中却恰好就是要利用它<strong>只是一个普通方法调用</strong>。</p>
<p>回到我在文初中所提到的：我认为线程池它就是一个<strong>调度任务</strong>的工具。</p>
<p>假设这里是调用的 <code>Runnable</code> 的 <code>start</code> 方法，那会发生什么事情。</p>
<p>如果我们往一个核心、最大线程数为 2 的线程池里丢了 1000 个任务，<strong>那么它会额外的创建 1000 个线程，同时每个任务都是异步执行的，一下子就执行完毕了</strong>。</p>
<p>从而没法做到由这两个 <code>Worker</code> 线程来调度这 1000 个任务，而只有当做一个同步阻塞的 <code>run()</code> 方法调用时才能满足这个要求。</p>
<blockquote>
<p>这事也让我发现一个奇特的现象：就是网上几乎没人讲过为什么在线程池里是 run 而不是 start，不知道是大家都觉得这是基操还是没人仔细考虑过。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>针对之前线上事故的总结上次已经写得差不多了，感兴趣的可以翻回去看看。</p>
<p>这次呢可能更多是我自己的总结，比如写一篇技术博客时如果大部分人对某一个知识点讨论的比较热烈时，那一定是作者要么讲错了，要么没讲清楚。</p>
<p>这点确实是要把自己作为一个读者的角度来看，不然很容易出现之前的一些误解。</p>
<p>在这之外呢，我觉得对于线程池把这两篇都看完同时也理解后对于大家理解线程池，利用线程池完成工作也是有很大好处的。</p>
<p>如果有在面试中加分的记得回来点赞、分享啊。</p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>问题排查</category>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>VLOG-008:Basketball Day One</title>
    <url>/2019/04/21/vlog/Basketball%20Day%20one/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/04/29/5cc652f48e019.jpg"></p>
<p>周末轻松一下。</p>
<iframe src="//player.bilibili.com/player.html?aid=49988049&cid=87514626&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" width="560" height="315" allowfullscreen="true"> </iframe>

]]></content>
      <categories>
        <category>VLOG</category>
      </categories>
  </entry>
  <entry>
    <title>VLOG-004：国产程序员的一天</title>
    <url>/2019/02/20/vlog/Chinese-coder-daily/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/04/29/5cc656ede2e8e.jpg"></p>
<p><code>VLOG</code> 近些年非常流行，最近这段时间我也拍了一些来记录生活。</p>
<p>之前一直想记录自己上班生活的一天；至于为什么标题要加上一个<code>国产</code>两字，是因为之前看到一位国外女程序媛的一天（视频链接见底部），这次是想让大家看看在天朝国情下的反差。</p>
<p><code>a day in the life of a software engineer:https://www.youtube.com/watch?v=rqX8PFcOpxA</code></p>
<h1 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h1><iframe src="//player.bilibili.com/player.html?aid=44234003&cid=77463016&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="560" height="315"> </iframe>

<span id="more"></span>

<h2 id="08-00"><a href="#08-00" class="headerlink" title="08:00"></a>08:00</h2><blockquote>
<p>起床洗漱。</p>
</blockquote>
<h2 id="8-20"><a href="#8-20" class="headerlink" title="8:20"></a>8:20</h2><blockquote>
<p>出门到轻轨站。</p>
</blockquote>
<h2 id="8-30"><a href="#8-30" class="headerlink" title="8:30"></a>8:30</h2><blockquote>
<p>到达轻轨站。</p>
</blockquote>
<h2 id="9-00"><a href="#9-00" class="headerlink" title="9:00"></a>9:00</h2><blockquote>
<p>到达公司开始干活。</p>
</blockquote>
<h2 id="10-00"><a href="#10-00" class="headerlink" title="10:00"></a>10:00</h2><blockquote>
<p>一个电话远程面试。</p>
</blockquote>
<h2 id="11-00"><a href="#11-00" class="headerlink" title="11:00"></a>11:00</h2><blockquote>
<p>一个电话远程面试。</p>
</blockquote>
<p>中间有一段对自己这些天来面试经历的一些分享，视频加快了但是重点内容都打有字幕。</p>
<h2 id="12-00"><a href="#12-00" class="headerlink" title="12:00"></a>12:00</h2><blockquote>
<p>午饭时间。</p>
</blockquote>
<h2 id="15-00"><a href="#15-00" class="headerlink" title="15:00"></a>15:00</h2><blockquote>
<p>部门内部会议到 16 点。</p>
</blockquote>
<h2 id="17-00"><a href="#17-00" class="headerlink" title="17:00"></a>17:00</h2><blockquote>
<p>一个电话远程面试。</p>
</blockquote>
<h2 id="19-00"><a href="#19-00" class="headerlink" title="19:00"></a>19:00</h2><blockquote>
<p>有时间做自己的撸码工作。</p>
</blockquote>
<h2 id="20-00"><a href="#20-00" class="headerlink" title="20:00"></a>20:00</h2><blockquote>
<p>准备回家。</p>
</blockquote>
<h2 id="22-00"><a href="#22-00" class="headerlink" title="22:00"></a>22:00</h2><blockquote>
<p>接女朋友下班。</p>
</blockquote>
<h2 id="00-30"><a href="#00-30" class="headerlink" title="00:30"></a>00:30</h2><blockquote>
<p>完成一个算法，收工睡觉。</p>
</blockquote>
<p>下一次录工作 VLOG 应该是等我当老板咯，希望别是有生之年系列。。。</p>
]]></content>
      <categories>
        <category>VLOG</category>
      </categories>
  </entry>
  <entry>
    <title>VLOG-006:一个程序员的周末（上）</title>
    <url>/2019/03/21/vlog/Chinese-coder-weekends-01/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/04/29/5cc6563f56b0c.jpg"></p>
<p>上次发了一个<a href="https://crossoverjie.top/2019/02/20/vlog/Chinese-coder-daily">《VLOG-004：国产程序员的一天》</a>评论和播放量都还不错，这次趁热打铁更新了周末业余生活是怎么样的。</p>
<p>在这个视频中你将看到：</p>
<ul>
<li>作为一个居家好男人是如何体现自我价值的？</li>
<li>我是如何产出一份技术博客？</li>
<li>女朋友不在家如何正规消遣时间？</li>
<li>如何撸得代码、下得厨房讨女朋友开心？</li>
</ul>
<h1 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h1><iframe src="//player.bilibili.com/player.html?aid=46786725&cid=81949011&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="560" height="315" > </iframe>

<span id="more"></span>


<p>这个视频是上部分，主要记录的是在家里的生活。</p>
<h1 id="起床"><a href="#起床" class="headerlink" title="起床"></a>起床</h1><p>可能是由于平时早起习惯了，我居然快改掉了多年懒床的毛病，近期周末都是8、9点的样子就会起床。</p>
<p>起床后磨蹭半天一不小心就到了饭点，由于女朋友上早班一个人的话就点了外卖。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1beb5b9f63.jpg"><br>吃饭的同时会看看一部下饭神剧《武林外传》。</p>
<h1 id="家务"><a href="#家务" class="headerlink" title="家务"></a>家务</h1><p>开始洗衣服，洗衣服的同时需要收衣服、叠衣服从而实现个人价值。</p>
<h1 id="周报"><a href="#周报" class="headerlink" title="周报"></a>周报</h1><p><img src="https://i.loli.net/2019/05/08/5cd1bebc05aa7.jpg"></p>
<p>准备开始写周报，结果一不小心沉浸于电视。。。</p>
<p>2个小时后周报完成。</p>
<h1 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h1><p><img src="https://i.loli.net/2019/05/08/5cd1bebcb7a89.jpg"></p>
<p>完成下周技术分享的 PPT，但受限于设计细胞整个 PPT 将比较难看。</p>
<h1 id="技术博客"><a href="#技术博客" class="headerlink" title="技术博客"></a>技术博客</h1><p><img src="https://i.loli.net/2019/05/08/5cd1bebe980fd.jpg"></p>
<p>开始写一篇技术博客，分享了我个人的一些习惯：</p>
<ul>
<li>先在本子上打好提纲。</li>
<li>加上一个二次元配图。</li>
<li>写博客时需要注意的点。</li>
</ul>
<h1 id="消遣"><a href="#消遣" class="headerlink" title="消遣"></a>消遣</h1><p><img src="https://i.loli.net/2019/05/08/5cd1bec0065b2.jpg"></p>
<p>玩 <code>switch</code> ，买游戏花的钱已经都可以再买一个 <code>switch</code> 了，果真是买游戏送主机；主要玩：</p>
<ul>
<li>马里奥赛车8</li>
<li>喷射乌贼娘</li>
<li>塞尔达传说</li>
<li>任天堂明星大乱斗</li>
</ul>
<h1 id="晚饭"><a href="#晚饭" class="headerlink" title="晚饭"></a>晚饭</h1><p><img src="https://i.loli.net/2019/05/08/5cd1bec0ae362.jpg"></p>
<p>作为王刚师傅的在线弟子，深的宽油真传，必将料理出感动人心的美味；本次为大家带来的是<code>口味猪肝</code>。</p>
<p>全程高能，请大家饭前观看（吃完饭后会忍不住想吃）。</p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>看到这里想必你已经对开始的几个问题有了答案了吧，来核对下我的标准答案吧。</p>
<ul>
<li>作为一个居家好男人是如何体现自我价值的？—-&gt;你的价值就是洗碗、洗衣服收拾家务。</li>
<li>我是如何产出一份技术博客？—-&gt;提前构思目录、文章配图。</li>
<li>女朋友不在家如何正规消遣时间？—-&gt;必须是 <code>switch</code> 啊，不然你以为是啥。。</li>
<li>如何撸得代码、下得厨房讨女朋友开心？—-&gt;看 20 遍王刚师傅的视频自学成才。</li>
</ul>
<p>下一期将会为大家带来室外篇，作为一个大学毕业到现在成功长膘 20 斤的篮球爱好者，如何科学运动长肉，你值得期待🤫。</p>
]]></content>
      <categories>
        <category>VLOG</category>
      </categories>
  </entry>
  <entry>
    <title>VLOG-007:一个程序员的周末（中）</title>
    <url>/2019/03/30/vlog/Chinese-coder-weekends-02/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/04/29/5cc655bdd866b.jpg"></p>
<p>承接上期<a href="https://crossoverjie.top/2019/03/21/vlog/Chinese-coder-weekends-01/">《VLOG-006:一个程序员的周末（上）》</a></p>
<p>本次是周末日常的中篇，也是我每周做的最频繁的一件事情【陪女朋友逛街】。</p>
<span id="more"></span>

<p>导致的结果是我已经清楚的知道所在商圈里大部分门店里的休息位置。</p>
<p>哪里坐着舒服、哪里的信号比较好、哪家店逛不久会马上走，所以最好是不要坐下。</p>
<p>可谓是“旱的旱死，涝的涝死”</p>
<h1 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h1><iframe src="//player.bilibili.com/player.html?aid=47715858&cid=83580442&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="560" height="315"> </iframe>



]]></content>
      <categories>
        <category>VLOG</category>
      </categories>
  </entry>
  <entry>
    <title>「造个轮子」——cicada(轻量级 WEB 框架)</title>
    <url>/2018/09/03/wheel/cicada1/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d1720ab7a.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>俗话说 「不要重复造轮子」，关于是否有必要不再本次讨论范围。</p>
<p>创建这个项目的主要目的还是提升自己，看看和知名类开源项目的差距以及学习优秀的开源方式。</p>
<p>好了，现在着重来谈谈 <a href="https://github.com/crossoverJie/cicada">cicada</a> 这个项目的核心功能。</p>
<p>我把他定义为一个快速、轻量级 WEB 框架；没有过多的依赖，核心 jar 包仅 30KB。</p>
<p>也仅需要一行代码即可启动一个 <code>HTTP</code> 服务。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d17354c8b.jpg"></p>
<span id="more"></span>

<hr>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1741f0cb.jpg"></p>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>现在来谈谈重要的几个特性。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d175166b9.jpg"></p>
<p>当前版本主要实现了基本的请求、响应、自定义参数以及拦截器功能。</p>
<blockquote>
<p>功能虽少，但五脏俱全。</p>
</blockquote>
<p>在今后的迭代过程中会逐渐完善上图功能，有好的想法也欢迎提 <a href="https://github.com/crossoverJie/cicada/issues">https://github.com/crossoverJie/cicada/issues</a>。</p>
<h1 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h1><p>下面来看看如何快速启动一个 HTTP 服务。</p>
<p>只需要创建一个 Maven 项目，并引入核心包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.crossoverjie.opensource<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cicada-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上图所示，再配置一个启动类即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainStart</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        CicadaServer.start(MainStart.class,<span class="string">&quot;/cicada-example&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="配置业务-Action"><a href="#配置业务-Action" class="headerlink" title="配置业务 Action"></a>配置业务 Action</h2><p>当然我们还需要一个实现业务逻辑的地方。<code>cicada</code> 提供了一个接口，只需要实现该接口即可实现具体逻辑。</p>
<p>创建业务 Action 实现 <code>top.crossoverjie.cicada.server.action.WorkAction</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CicadaAction(value = &quot;demoAction&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoAction</span> <span class="keyword">implements</span> <span class="title class_">WorkAction</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerBuilder.getLogger(DemoAction.class) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicLong</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>() ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> WorkRes&lt;DemoResVO&gt; <span class="title function_">execute</span><span class="params">(Param paramMap)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> paramMap.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> paramMap.getInteger(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        LOGGER.info(<span class="string">&quot;name=[&#123;&#125;],id=[&#123;&#125;]&quot;</span> , name,id);</span><br><span class="line"></span><br><span class="line">        <span class="type">DemoResVO</span> <span class="variable">demoResVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoResVO</span>() ;</span><br><span class="line">        demoResVO.setIndex(index.incrementAndGet());</span><br><span class="line">        WorkRes&lt;DemoResVO&gt; res = <span class="keyword">new</span> <span class="title class_">WorkRes</span>();</span><br><span class="line">        res.setCode(StatusEnum.SUCCESS.getCode());</span><br><span class="line">        res.setMessage(StatusEnum.SUCCESS.getMessage());</span><br><span class="line">        res.setDataBody(demoResVO) ;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时需要再自定义类中加上 <code>@CicadaAction</code> 注解，并需要指定一个 <code>value</code>，该 value 主要是为了在请求路由时能找到业务类。</p>
<p>这样启动应用并访问 </p>
<p><code>http://127.0.0.1:7317/cicada-example/demoAction?name=12345&amp;id=10</code> </p>
<p>便能执行业务逻辑同时得到服务端的返回。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d21b836c2.jpg"></p>
<p>目前默认支持的是 <code>json</code> 响应，后期也会加上模板解析。</p>
<p>服务中也会打印相关日志。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d21c7ebc4.jpg"></p>
<h2 id="灵活的参数配置"><a href="#灵活的参数配置" class="headerlink" title="灵活的参数配置"></a>灵活的参数配置</h2><p>这里所有的请求参数都封装在 <code>Param</code> 中，可以利用其中的各种 API 获取请求数据。</p>
<p>之所以是灵活的：我们甚至可以这样请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:7317/cicada-example/demoAction?jsonData=&quot;info&quot;: &#123;</span><br><span class="line">    &quot;age&quot;: 22,</span><br><span class="line">    &quot;name&quot;: &quot;zhangsan&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以传递任意结构的数据，只要业务处理时进行解析即可。</p>
<h1 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h1><p>拦截器是一个框架的基本功能，可以利用拦截器实现日志记录、事务提交等通用工作。</p>
<p>为此 <code>cicada</code> 提供一个接口: <code>top.crossoverjie.cicada.server.intercept.CicadaInterceptor</code>。</p>
<p>我们只需要实现该接口即可编写拦截功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Interceptor(value = &quot;executeTimeInterceptor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecuteTimeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">CicadaInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerBuilder.getLogger(ExecuteTimeInterceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long end;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Param param)</span> &#123;</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(Param param)</span> &#123;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;cast [&#123;&#125;] times&quot;</span>, end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里演示的是记录所有 action 的执行时间。</p>
<p>目前默认只实现了 action 的拦截，后期也会加入自定义拦截器。</p>
<h2 id="拦截适配器"><a href="#拦截适配器" class="headerlink" title="拦截适配器"></a>拦截适配器</h2><p>虽说在拦截器中提供了 <code>before/after</code> 两个方法，但也不是所有的方法都需要实现。</p>
<p>因此 <code>cicada</code> 提供了一个适配器：</p>
<p><code>top.crossoverjie.cicada.server.intercept.AbstractCicadaInterceptorAdapter</code></p>
<p>我们需要继承他便可按需实现其中的某个方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Interceptor(value = &quot;loggerInterceptor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerInterceptorAbstract</span> <span class="keyword">extends</span> <span class="title class_">AbstractCicadaInterceptorAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerBuilder.getLogger(LoggerInterceptorAbstract.class) ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Param param)</span> &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;logger param=[&#123;&#125;]&quot;</span>,param.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><p>既然是一个 HTTP 服务框架，那性能自然也得保证。</p>
<p>在测试条件为：<code>300 并发连续压测两轮；1G 内存、单核 CPU、1Mbps。</code>用 Jmeter 压测情况如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d21d32a5f.jpg"></p>
<p>同样的服务器用 Tomcat 来压测看看结果。</p>
<p>Tomcat 的线程池配置:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">&quot;tomcatThreadPool&quot;</span> <span class="attr">namePrefix</span>=<span class="string">&quot;consumer-exec-&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxThreads</span>=<span class="string">&quot;510&quot;</span> <span class="attr">minSpareThreads</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/05/08/5cd1d220bbdbf.jpg"></p>
<p>我这里请求的是 Tomcat 的一个 doc 目录，虽说结果看似 <code>cicada</code> 的性能比 Tomcat  还强。</p>
<p>但其实这个对比过程中的变量并没有完全控制好，Tomcat 所返回的是 HTML，而 <code>cicada</code> 仅仅返回了 json，当然问题也不止这些。</p>
<p>但还是能说明 <code>cicada</code> 目前的性能还是不错的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文没有过多讨论 <code>cicada</code> 实现原理，感兴趣的可以看看源码，都比较简单。</p>
<p>在后续的更新中会仔细探讨这块内容。</p>
<p>同时不出意外 <code>cicada</code> 会持续更新，未来也会加入更多实用的功能。</p>
<p>甚至我会在适当的时机将它应用于我的生产项目，也希望更多朋友能参与进来一起把这个「轮子」做的更好。</p>
<p>项目地址：<a href="https://github.com/crossoverJie/cicada">https://github.com/crossoverJie/cicada</a></p>
<p><strong>你的点赞与转发是最大的支持。</strong></p>
]]></content>
      <categories>
        <category>cicada</category>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTTP</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>「造个轮子」——cicada 源码分析</title>
    <url>/2018/09/05/wheel/cicada2/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d14f1f2b1.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>两天前写了文章<a href="https://crossoverjie.top/2018/09/03/wheel/cicada1/">《「造个轮子」——cicada(轻量级 WEB 框架)》
</a> 向大家介绍了 <code>cicada</code> 之后收到很多反馈，也有许多不错的建议。</p>
<p>同时在 GitHub 也收获了 100 多颗 小♥♥（绝对不是刷的。。）</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d15189c70.jpg"></p>
<p>也有朋友希望能出一个源码介绍，本文就目前的 <code>v1.0.1</code> 版本来一起分析分析。</p>
<blockquote>
<p>没有看错，刚发布就修复了一个 bug，想要试用的请升级到 <code>1.0.1</code> 吧。</p>
</blockquote>
<span id="more"></span>

<h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><p>一般在做一个新玩意之前都会有技术选型的过程，但这点在做 <code>cicada</code> 的时候却异常简单。</p>
<p>因为我的需求是想提供一个高性能的 HTTP 服务，纵观整个开源界其实选择不多。</p>
<p>加上最近我在做 Netty 相关的开发，所以自然而然就选择了它。</p>
<p>同时 Netty 自带了对 HTTP 协议的编解码器，可以非常简单快速的开发一个 HTTP 服务器。我只需要把精力放在参数处理、路由等业务处理上即可。</p>
<p>同时 Netty 也是基于 NIO 实现，性能上也有保证。关于 Netty 相关内容可以参考<a href="https://crossoverjie.top/categories/Netty/">这里</a>。</p>
<p>下面来重点分析其中的各个过程。</p>
<h1 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h1><p>最核心的自然就是 HTTP 的处理 <code>handle</code>，对应的就是 <code>HttpHandle</code> 类。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d15386288.jpg"></p>
<p>查看源码其实很容易看出具体的步骤，注释也很明显。</p>
<p>这里只分析重点功能。</p>
<p>先来考虑下需求。</p>
<p>首先作为一个 HTTP 框架，自然是得让使用者能有地方来实现业务代码；就像咱们现在使用 SpringMVC 时写的 <code>controller</code> 一样。</p>
<p>其实当时考虑过三种方案：</p>
<ul>
<li>像 SpringMVC 一样定义注解，只要声明了对应注解我就认为这是一个业务类。</li>
<li>用过 Struts2 的同学应该有印象，它的业务类 Action 都是配置到一个 XML 中；在里面配置接口对应的业务处理类。</li>
<li>同样的思路，只是把 XML 文件换成 <code>properties</code> 配置文件，在里面编写 JSON 格式的对应关系。</li>
</ul>
<p>这时就得分析各个方案的优缺点了。</p>
<p>方案二和三其实就是 XML 和 json 的对比了；XML 会让维护者感到结构清晰，同时便于维护和新增。</p>
<p>JSON 就不太方便处理了，并且在这样的场景并不用于传输自然也发挥不出优势。</p>
<p>最后考虑到现在流行的 SpringBoot 都在去 XML，要是再搞一个依赖于 XML 的东西也跟不上大家的使用习惯。</p>
<p>于是就采用类似于 SpringMVC 这样的注解形式。</p>
<p>既然采用了注解，那框架怎么知道用户访问某个接口时能对应到业务类呢？</p>
<p>所以首先第一步自然是需要将加有注解的类全部扫描一遍，放到一个本地缓存中。</p>
<p>这样才能方便后续的路由定位。</p>
<h1 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h1><p>其中核心的源码在 <code>routeAction</code> 方法中。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d15aa7f17.jpg"></p>
<p>首先会全局扫描使用了 <code>@CicadaAction</code> 的注解，然后再根据请求地址找到对应的业务类。</p>
<p>全局扫描代码：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d15ca2e73.jpg"></p>
<p>首先是获取到项目中自定义的所有类，然后判断是否加有 <code>@CicadaAction</code> 注解。</p>
<p>是目标类则把他缓存到一个本地 Map 中，方便下次访问时可以不再扫描直接从缓存中获取即可（反射很耗性能）。</p>
<p>执行完 <code>routeAction</code> 后会获得真正的业务类类型。</p>
<p><code>Class&lt;?&gt; actionClazz = routeAction(queryStringDecoder, appConfig);</code></p>
<h1 id="传参方式"><a href="#传参方式" class="headerlink" title="传参方式"></a>传参方式</h1><p>拿到业务类的类类型之后就成功一大半了，只需要反射生成它的对象然后执行方法即可。</p>
<p>在执行方法之前又要涉及到一个问题，参数我该怎么传递呢？</p>
<p>考虑到灵活性我采用了最简答 Map 方式。</p>
<p>因此定义了一个通用的 Param 接口并继承了 Map 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Param</span> <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;String, Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getString</span><span class="params">(String param)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get Integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Integer <span class="title function_">getInteger</span><span class="params">(String param)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get Long</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Long <span class="title function_">getLong</span><span class="params">(String param)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get Double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Double <span class="title function_">getDouble</span><span class="params">(String param)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get Float</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Float <span class="title function_">getFloat</span><span class="params">(String param)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get Boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Boolean <span class="title function_">getBoolean</span><span class="params">(String param)</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中封装了几种基本类型的获取方式。</p>
<p>同时在 <code>buildParamMap()</code> 方法中，将接口中的参数封装到这个 Map 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Param</span> <span class="variable">paramMap</span> <span class="operator">=</span> buildParamMap(queryStringDecoder);</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/05/08/5cd1d15e4425b.jpg"></p>
<h1 id="业务执行"><a href="#业务执行" class="headerlink" title="业务执行"></a>业务执行</h1><p>最后只需要执行业务即可；由于在上文已经获取到业务类的类类型，所以这里通过反射即可调用。</p>
<p>同时也定义了一个业务类需要实现的一个通用接口 <code>WorkAction</code>，想要实现具体业务只要实现它就行。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d15f63262.jpg"></p>
<p>而这里的方法参数自然就是刚才定义的参数接口 <code>Param</code>。</p>
<p>由于所有的业务类都是实现了 <code>WorkAction</code>，所以在反射时都可以定义为 <code>WorkAction</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">WorkAction</span> <span class="variable">action</span> <span class="operator">=</span> (WorkAction) actionClazz.newInstance();</span><br><span class="line"><span class="type">WorkRes</span> <span class="variable">execute</span> <span class="operator">=</span> action.execute(paramMap);</span><br></pre></td></tr></table></figure>

<p>最后将构建好的参数 map 传入即可。</p>
<h1 id="响应返回"><a href="#响应返回" class="headerlink" title="响应返回"></a>响应返回</h1><p>有了请求那自然也得有响应，观察刚才定义的 <code>WorkAction</code> 接口可以发现其实定义了一个 <code>WorkRes</code> 响应类。</p>
<p>所有的响应数据都需要封装到这个对象中。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d160649b6.jpg"></p>
<p>这个没啥好说的，都是一些基本数据。</p>
<p>最后在 <code>responseMsg()</code> 方法中将响应数据编码为 JSON 输出即可。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d16783d38.jpg"></p>
<h1 id="拦截器设计"><a href="#拦截器设计" class="headerlink" title="拦截器设计"></a>拦截器设计</h1><p>拦截器也是一个框架基本的功能，用处非常多。</p>
<p><code>cicada</code> 的实现原理非常简单，就是在 <code>WorkAction</code> 接口执行业务逻辑之前调用一个方法、执行完毕之后调用另一个方法。</p>
<p>也是同样的思路需要定义一个接口 <code>CicadaInterceptor</code>，其中有两个方法。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d168565eb.jpg"></p>
<p>看方法名字自然也能看出具体作用。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1694b1c1.jpg"></p>
<p>同时在这两个方法中执行具体的调用。</p>
<p>这里重点要看看 <code>interceptorBefore</code> 方法。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d16a97d32.jpg"></p>
<p>其中也是加入了一个缓存，尽量的减少反射操作。</p>
<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p>就这样的拦截器接口是够用了，但并不是所有的业务都需要实现两个接口。</p>
<p>因此也提供了一个适配器 <code>AbstractCicadaInterceptorAdapter</code>。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d17122767.jpg"></p>
<p>它作为一个抽象类实现了 <code>CicadaInterceptor</code> 接口，这样后续的拦截业务也可继承该接口选择性的实现方法即可。</p>
<p>类似于这样：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d17301847.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>v1.0.1</code> 版本的 <code>cicada</code> 就介绍完毕了，其中的原理和源码都比较简单。</p>
<p>大量使用了反射和一些设计模式、多态等应用，这方面经验较少的朋友可以参考下。</p>
<p>同时也有很多不足；比如传参后续会考虑更加优雅的方式、拦截器目前写的比较死，后续会利用动态代理实现自定义拦截。</p>
<p>其实 <code>cicada</code> 只是利用周末两天时间做的，bug 肯定少不了；也欢迎大家在 GitHub 上提 <a href="https://github.com/TogetherOS/cicada/issues">issue</a> 参与。</p>
<p>最后贴下项目地址：</p>
<p><a href="https://github.com/TogetherOS/cicada">https://github.com/TogetherOS/cicada</a></p>
<p><strong>你的点赞与转发是最大的支持。</strong></p>
]]></content>
      <categories>
        <category>cicada</category>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTTP</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>「造个轮子」——cicada 设计一个配置模块</title>
    <url>/2018/09/14/wheel/cicada3/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d143dc8ff.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前两次的 <a href="https://github.com/TogetherOS/cicada">cicada</a> 版本中其实还不支持读取配置文件，比如对端口、路由的配置。</p>
<p>因此我按照自己的想法创建了一个 <a href="https://github.com/TogetherOS/cicada/issues/6">issue</a> ，也收集到了一些很不错的建议。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d145eb213.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d14b5ec72.jpg"></p>
<p>最终其实还是按照我之前的想法来做了这个配置管理。</p>
<blockquote>
<p>同时将 <code>cicada</code> 升级到了 <code>v1.0.2</code>。</p>
</blockquote>
<span id="more"></span> 


<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>在做之前是要把需求想好，到底怎样的一个配置管理是对开发人员来说比较友好的？</p>
<p>我认为有以下几点:</p>
<ul>
<li>可以自定义配置，并且支持不同的环境（开发、测试、生产）。</li>
<li>使用灵活。对使用者来说不要有太多的束缚。</li>
</ul>
<p>理论上来说配置这个东西应当完全独立出来，由一个配置中心来负责管理并且这样可以与应用解耦。</p>
<p>不过这样的实现和当前 <code>cicada</code> 的定义有些冲突，我想尽量小的依赖第三方组件并可以完全独立运行。</p>
<p>因此基于这样的情况便有了以下的实现。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>在看实现之前先看看基于目前的配置管理如何在业务中使用起来。</p>
<p>结合现在大家使用 <code>SpringBoot</code> 的习惯，<code>cicada</code> 默认会读取 <code>classpath</code> 下的 <code>application.properties</code> 配置文件。并且会默认读取其中的应用端口以及初始路由地址。</p>
<p>同时也新增了一个 api。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainStart</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        CicadaServer.start(MainStart.class,<span class="string">&quot;/cicada-example&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainStart</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        CicadaServer.start(MainStart.class) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样在不传默认地址的时候 <code>cicada</code> 会从 <code>application.properties</code> 中读取。</p>
<p>考虑到后面可维护的情况，<code>cicada</code> 也支持配置各种不同的配置文件。</p>
<p>使用也比较简单，只需要继承 <code>cicada</code> 提供的一个抽象类即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConfiguration</span> <span class="keyword">extends</span> <span class="title class_">AbstractCicadaConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KafkaConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setPropertiesName(<span class="string">&quot;kafka.properties&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> <span class="keyword">extends</span> <span class="title class_">AbstractCicadaConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setPropertiesName(<span class="string">&quot;redis.properties&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/05/08/5cd1d14d192b4.jpg"></p>
<p>按照这样的配置也会默认从 <code>classpath</code> 读取这两个配置文件。</p>
<blockquote>
<p>当然这里有个前提：代码里配置的文件名必须得和配置文件名称相同。</p>
</blockquote>
<p>那如何在业务中读取这两个配置文件的内容呢？</p>
<p>这也简单，代码一看就懂：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d14eb04b2.jpg"></p>
<ul>
<li>首先需要通过 <code>ConfigurationHolder</code> 获取各自不同配置的管理对象（需要显式指定类类型）。</li>
<li>通过 <code>get()</code> 方法直接获取配置。</li>
<li>同时也支持获取 <code>application.properties</code> 里的配置。</li>
</ul>
<p>同时为了支持在不同环境的使用，当配置了启动参数将会优先读取。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dapplication.properties=/xx/application.properties</span><br><span class="line">-Dkafka.properties=/xx/kakfa.properties</span><br><span class="line">-Dredis.properties=/xx/redis.properties</span><br></pre></td></tr></table></figure>

<p>这样算是基本实现了上述的配置要求。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>要实现以上的功能有几个核心点：</p>
<ol>
<li>加载所有配置文件。</li>
<li>将不同的配置文件用不同的对象进行管理。</li>
<li>提供简易的接口使用。</li>
</ol>
<p>由于 <code>cicada</code> 需要支持多个配置文件，所有需要定义一个抽象类供所有的配置管理实现。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d150763bd.jpg"></p>
<p>定义比较简单，其中有两个重要的成员变量：</p>
<ul>
<li>文件名称：用于初始化时通过名称加载配置文件。</li>
<li><code>Properties</code> 其实就是一个 Map 结构的缓存，用于存放所有的配置。当然对外提供的查询是基于它的。</li>
</ul>
<p>接着就是在初始化时需要找出所有继承了 <code>AbstractCicadaConfiguration</code> 的类。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d152ac101.jpg"></p>
<p>查询出来之后自然是要进行遍历同时反射创建对象。</p>
<p>由于之前已经调用了 </p>
<p><code>super.setPropertiesName(&quot;redis.properties&quot;);</code> </p>
<p>来赋值配置文件名称，所以还需要在遍历过程中将 <code>Properties</code> 进行赋值。</p>
<p>同时在这里也体现出优先读取的是 VM 启动参数中的配置文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">systemProperty</span> <span class="operator">=</span> System.getProperty(conf.getPropertiesName());</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/05/08/5cd1d15444720.jpg"></p>
<p>需要额外提一点的是：在查找所有用户自定义的配置管理类时需要手动将 <code>cicada</code> 内置的<br><code>ApplicationConfiguration</code> 加入其中。</p>
<p>因为使用应用的包名通过反射是查询不出该类的。</p>
<h2 id="保存自定义配置管理"><a href="#保存自定义配置管理" class="headerlink" title="保存自定义配置管理"></a>保存自定义配置管理</h2><p>为了方便用户在使用时候可以随意的读取各个配置文件，所以还需要将反射创建的对象保存到一个内部缓存中，核心代码就是上上图中的这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add configuration cache</span></span><br><span class="line">ConfigurationHolder.addConfiguration(aClass.getName(), conf);</span><br></pre></td></tr></table></figure>

<p>其中 <code>ConfigurationHolder</code> 的定义如下。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d15b7604e.jpg"></p>
<p>其实也是利用一个 Map 来存放这些对象。</p>
<p>这样在使用时候只需要取出即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">KafkaConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> (KafkaConfiguration) getConfiguration(KafkaConfiguration.class);</span><br><span class="line"><span class="type">String</span> <span class="variable">brokerList</span> <span class="operator">=</span> configuration.get(<span class="string">&quot;kafka.broker.list&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><p>本次升级同时还重构了部分代码，比如启动类。</p>
<p>现在看上去要清爽和直接的多：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d15c784dc.jpg"></p>
<p>其中也有一点需要注意的地方。</p>
<p>大家如果查看日志的话会发现应用启动之后会打印本次的耗时，自然就是在启动时候记录一个时间，初始化完毕之后记录一个即可。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d15e10f42.jpg"></p>
<p>在之前的实现中由于都是在一个方法内，所以直接使用就行了。</p>
<p>但现在优化之后跨越了不同的方法和类，难道要把时间作为参数在各个方法之前传递嘛？</p>
<blockquote>
<p>那未免太不优雅了。</p>
</blockquote>
<p>所以 <code>ThreadLocal</code> 就有了发挥余地。</p>
<p>在初始化的方法中我将当前时间写入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalHolder.setLocalTime(System.currentTimeMillis());</span><br></pre></td></tr></table></figure>

<p>在最后记录日志的地方直接取出比较即可：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d15f2b6db.jpg"></p>
<p>这样使用起来就完全不需要管什么参数传递了。</p>
<p>同时 <code>ThreadLocalHolder</code> 的定义：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d16035ab1.jpg"></p>
<p>这里还是有一点需要注意，在这种长生命周期的容器中一定得要记得<strong>及时清除</strong>。</p>
<p>我这里的时间在查询一次之后就不用了，所以完全放心的在 <code>getLocalTime()</code> 方法中删掉。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这就是本次 <code>v1.0.2</code> 中的升级内容，包含了配置支持以及代码重构。其中有些内容我觉得对接触少的同学来说还是挺有帮助的。</p>
<p>关于上两次的版本介绍请查看这里：</p>
<ul>
<li><a href="https://crossoverjie.top/2018/09/03/wheel/cicada1/">「造个轮子」——cicada(轻量级 WEB 框架)</a></li>
<li><a href="https://crossoverjie.top/2018/09/05/wheel/cicada2/">「造个轮子」——cicada 源码分析</a></li>
</ul>
<p>还没点关注的朋友可以点波关注：</p>
<p><a href="https://github.com/TogetherOS/cicada">https://github.com/TogetherOS/cicada</a></p>
<p>也欢迎大家参与一起维护！。</p>
<p>同时后续关于 <code>cicada</code> 的更新会放慢一些。会介绍一些平时实战相关的内容，比如 Kafka 之类的，请持续关注。</p>
<p><strong>你的点赞与转发是最大的支持。</strong></p>
]]></content>
      <categories>
        <category>cicada</category>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTTP</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>「造个轮子」——cicada 设计全局上下文</title>
    <url>/2018/10/09/wheel/cicada4/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1d11a5612f.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本次 <a href="https://github.com/TogetherOS/cicada">Cicada</a> 已经更新到了 <a href="https://maven-badges.herokuapp.com/maven-central/top.crossoverjie.opensource/cicada-core/"><img src="https://maven-badges.herokuapp.com/maven-central/top.crossoverjie.opensource/cicada-core/badge.svg"></a> <code>v1.0.3</code>。</p>
<p>主要是解决了两个 issue，<a href="https://github.com/TogetherOS/cicada/issues/9">#9</a> <a href="https://github.com/TogetherOS/cicada/issues/8">#8</a>。</p>
<p>所以本次的主要更新为：</p>
<ul>
<li><a href="https://github.com/TogetherOS/cicada">Cicada</a> 采用合理的线程分配来处理接入请求线程以及 IO 线程。</li>
<li>支持多种响应方式（以前只有 json，现在支持 text）。</li>
<li>为了满足上者引入了 <code>context</code>。</li>
<li>优雅停机。</li>
</ul>
<p>其中我觉得最核心也最有用的就是这个 <code>Context</code>，并为此重构了大部分代码。</p>
<span id="more"></span>

<h1 id="多种响应方式"><a href="#多种响应方式" class="headerlink" title="多种响应方式"></a>多种响应方式</h1><p>在起初 <code>Cicada</code> 默认只能响应 <code>json</code>，这一点确实不够灵活。加上后续也打算支持模板解析，所以不如直接在 API 中加入可让用户自行选择不同的响应方式。</p>
<p>因此调整后的 API 如下。</p>
<blockquote>
<p>想要输出 <code>text/plain</code> 时。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CicadaAction(&quot;textAction&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextAction</span> <span class="keyword">implements</span> <span class="title class_">WorkAction</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(CicadaContext context, Param param)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> context.request().getUrl();</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> context.request().getMethod();</span><br><span class="line">        context.text(<span class="string">&quot;hello world url=&quot;</span> + url + <span class="string">&quot; method=&quot;</span> + method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而响应输出 <code>application/json</code> 时只需要把需要响应的对象写入到 <code>json()</code> 方法中.</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/08/5cd1d121092ea.jpg"></p>
<p>因此原有的业务 action 中也加入了一个上下文的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * abstract execute method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context current context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param request params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception throw exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(CicadaContext context ,Param param)</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>

<p>下面就来看看这个 <code>Context</code> 是如何完成的。</p>
<h1 id="Cicada-Context"><a href="#Cicada-Context" class="headerlink" title="Cicada Context"></a>Cicada Context</h1><p>先看看有了这个上下文之后可以做什么。</p>
<p>比如有些场景下我们需要拿到本次请求中的头信息，这时就可以通过这个 <code>Context</code> 对象直接获取。</p>
<p>当然不止是头信息：</p>
<ul>
<li>获取请求头。</li>
<li>设置响应头。</li>
<li>设置 <code>cookie</code>。</li>
<li>获取请求 <code>URL</code>。</li>
<li>获取请求的 <code>method</code>（get&#x2F;post）等。</li>
</ul>
<p>其实通过这些特点可以看出这些信息其实都和一次 <code>请求、响应</code> 密切相关，并且各个请求之间的信息应互不影响。</p>
<p>这样的特性是不是非常熟悉，没错那就是 <code>ThreadLocal</code>，它可以将每个线程的信息存储起来互不影响。</p>
<blockquote>
<p>ThreadLocal 的原理本次不做过多分析，只谈它在 Cicada 中的应用。</p>
</blockquote>
<h2 id="CicadaContext-class"><a href="#CicadaContext-class" class="headerlink" title="CicadaContext.class"></a>CicadaContext.class</h2><p>先来看看 <code>CicadaContext</code> 这个类的主要成员变量以及方法。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1220f5c8.jpg"></p>
<p>成员变量是两个接口 <code>CicadaRequest、CicadaResponse</code>，名称就能看出肯定是存放请求和响应数据的。</p>
<h2 id="HttpDispatcher-class"><a href="#HttpDispatcher-class" class="headerlink" title="HttpDispatcher.class"></a>HttpDispatcher.class</h2><p>想要存放本次请求的上下文自然是在真正请求分发的地方 <code>HttpDispatcher</code>。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d1239db85.jpg"></p>
<p>这里改的较大的就是两个红框处，第一部分是做上下文初始化及赋值。</p>
<p>第二部分自然就是卸载上下文。</p>
<blockquote>
<p>先看初始化。</p>
</blockquote>
<p><code>CicadaRequest cicadaRequest = CicadaHttpRequest.init(defaultHttpRequest) ;</code></p>
<p>首先是将 request 初始化：</p>
<p><code>CicadaHttpRequest</code> 自然是实现了 <code>CicadaRequest</code> 接口：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d124968a4.jpg"></p>
<p>这里只保存了请求的 URL、method 等信息，后续要加的请求头也存放在此处即可。</p>
<p><code>Response</code> 也是同理的。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d125bda8d.jpg"></p>
<blockquote>
<p>这两个具体的实现类都私有化了构造函数，防止外部破坏了整体性。</p>
</blockquote>
<p>接着将当前请求的上下文保存到了 <code>CicadaContext</code> 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CicadaContext.setContext(<span class="keyword">new</span> <span class="title class_">CicadaContext</span>(cicadaRequest,cicadaResponse));</span><br></pre></td></tr></table></figure>

<p>而这个函数本质使用的则是 <code>ThreadLocal</code> 来存放 <code>CicadaContext</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(CicadaContext context)</span>&#123;</span><br><span class="line">    ThreadLocalHolder.setCicadaContext(context) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;CicadaContext&gt; CICADA_CONTEXT= <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>() ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set cicada context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context current context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCicadaContext</span><span class="params">(CicadaContext context)</span>&#123;</span><br><span class="line">    CICADA_CONTEXT.set(context) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理业务及响应"><a href="#处理业务及响应" class="headerlink" title="处理业务及响应"></a>处理业务及响应</h2><p>接着就是处理业务，调用不同的 API 做不同响应。</p>
<p>拿 <code>context.text()</code> 来说：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d12b3778f.jpg"></p>
<p>其实就是设置了对应的响应方式、以及把响应内容写入了 <code>CicadaResponse</code> 的 <code>httpContent</code> 中。</p>
<p>业务处理完后调用 <code>responseContent()</code> 进行响应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">responseContent(ctx,CicadaContext.getResponse().getHttpContent());</span><br></pre></td></tr></table></figure>

<p>其实就是在上下文中拿到的响应方式及响应内容返回给客户端。</p>
<h2 id="卸载上下文"><a href="#卸载上下文" class="headerlink" title="卸载上下文"></a>卸载上下文</h2><p>最后有点非常重要，那就是 <strong>卸载上下文</strong>。</p>
<p>如果这里不做处理，之后随着请求的增多，<code>ThreadLocal</code> 里存放的数据也越来越多，最终肯定会导致内存溢出。</p>
<p>所以 <code>CicadaContext.removeContext()</code> 就是为了及时删除当前上下文。</p>
<h1 id="优雅停机"><a href="#优雅停机" class="headerlink" title="优雅停机"></a>优雅停机</h1><p>最后还新增了一个停机的方法。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d12c18a0f.jpg"></p>
<p>其实也就是利用 <code>Hook</code> 函数实现的。</p>
<p>由于目前 <code>Cicada</code> 开的线程，占用的资源都不是特别多，所以只是关闭了 Netty 所使用的线程。</p>
<p>如果后续新增了自身的线程等资源，那也可以全部放到这里来进行释放。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Cicada</code> 已经更新了 4 个版本，雏形都有了。</p>
<p>后续会重点实现模板解析和注解请求路由完成，把 <code>MVC</code> 中的 <code>view</code> 完成就差不多了。</p>
<p>还没有了解的朋友可以点击下面链接进入主页了解下😋。</p>
<p><a href="https://github.com/TogetherOS/cicada">https://github.com/TogetherOS/cicada</a></p>
]]></content>
      <categories>
        <category>cicada</category>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTTP</tag>
        <tag>Netty</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>利用责任链模式设计一个拦截器</title>
    <url>/2018/10/22/wheel/cicada5/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1c6a7aaad8.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近期在做 <a href="https://github.com/TogetherOS/cicada">Cicada</a> 的拦截器功能，正好用到了责任链模式。</p>
<p>这个设计模式在日常使用中频率还是挺高的，借此机会来分析分析。</p>
<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p>先来看看什么是责任链模式。</p>
<p>引用一段维基百科对其的解释：</p>
<blockquote>
<p>责任链模式在面向对象程式设计里是一种软件设计模式，它包含了一些命令对象和一系列的处理对象。每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。该模式还描述了往该处理链的末尾添加新的处理对象的方法。</p>
</blockquote>
<p>光看这段描述可能大家会觉得懵，简单来说就是该设计模式用于对某个对象或者请求进行一系列的处理，这些处理逻辑正好组成一个链条。</p>
<p>下面来简单演示使用与不使用责任链模式有什么区别和优势。</p>
<span id="more"></span>

<h1 id="责任链模式的应用"><a href="#责任链模式的应用" class="headerlink" title="责任链模式的应用"></a>责任链模式的应用</h1><h2 id="传统实现"><a href="#传统实现" class="headerlink" title="传统实现"></a>传统实现</h2><p>假设这样的场景：传入了一段内容，需要对这段文本进行加工；比如过滤敏感词、错别字修改、最后署上版权等操作。</p>
<p>常见的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;内容内容内容&quot;</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Process.sensitiveWord()</span><br><span class="line">                .typo()</span><br><span class="line">                .copyright();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样看似没啥问题也能解决需求，但如果我还需要为为内容加上一个统一的标题呢？在现有的方式下就不得不新增处理方法，并且是在这个客户端（<code>Process</code>）的基础上进行新增。</p>
<p>显然这样的扩展性不好。</p>
<h2 id="责任链模式实现"><a href="#责任链模式实现" class="headerlink" title="责任链模式实现"></a>责任链模式实现</h2><p>这时候就到了责任链模式发挥作用了。</p>
<p>该需求非常的符合对某一个对象、请求进行一系列处理的特征。</p>
<p>于是我们将代码修改：</p>
<p>这时 <code>Process</code> 就是一个接口了，用于定义真正的处理函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Process</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doProcess</span><span class="params">(String msg)</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时之前对内容的各种处理只需要实现该接口即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveWordProcess</span> <span class="keyword">implements</span> <span class="title class_">Process</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doProcess</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(msg + <span class="string">&quot;敏感词处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyrightProcess</span> <span class="keyword">implements</span> <span class="title class_">Process</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doProcess</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(msg + <span class="string">&quot;版权处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyrightProcess</span> <span class="keyword">implements</span> <span class="title class_">Process</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doProcess</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(msg + <span class="string">&quot;版权处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后只需要给客户端提供一个执行入口以及添加责任链的入口即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgProcessChain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Process&gt; chains = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;() ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加责任链</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> process</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> MsgProcessChain <span class="title function_">addChain</span><span class="params">(Process process)</span>&#123;</span><br><span class="line">        chains.add(process) ;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Process chain : chains) &#123;</span><br><span class="line">            chain.doProcess(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样使用起来就非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;内容内容内容==&quot;</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="type">MsgProcessChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MsgProcessChain</span>()</span><br><span class="line">                .addChain(<span class="keyword">new</span> <span class="title class_">SensitiveWordProcess</span>())</span><br><span class="line">                .addChain(<span class="keyword">new</span> <span class="title class_">TypoProcess</span>())</span><br><span class="line">                .addChain(<span class="keyword">new</span> <span class="title class_">CopyrightProcess</span>()) ;</span><br><span class="line"></span><br><span class="line">        chain.process(msg) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我需要再增加一个处理逻辑时只需要添加一个处理单元即可（<code>addChain(Process process)</code>），并对客户端 <code>chain.process(msg)</code> 是无感知的，不需要做任何的改动。</p>
<p>可能大家没有直接写过责任链模式的相关代码，但不经意间使用到的却不少。</p>
<p>比如 <code>Netty</code> 中的 <code>pipeline</code> 就是一个典型的责任链模式，它可以让一个请求在整个管道中进行流转。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6ac3bb76.jpg"></p>
<p>通过官方图就可以非常清楚的看出是一个责任链模式：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6afdad1d.jpg"></p>
<h1 id="用责任链模式设计一个拦截器"><a href="#用责任链模式设计一个拦截器" class="headerlink" title="用责任链模式设计一个拦截器"></a>用责任链模式设计一个拦截器</h1><p>对于拦截器来说使用责任链模式再好不过了。</p>
<p>下面来看看在 <code>Cicada</code> 中的实现：</p>
<p>首先是定义了和上文 <code>Process</code> 接口类似的 <code>CicadaInterceptor</code> 抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CicadaInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">before</span><span class="params">(CicadaContext context,Param param)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(CicadaContext context,Param param)</span> <span class="keyword">throws</span> Exception&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时定义了一个 <code>InterceptProcess</code> 的客户端：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6b4dc66d.jpg"></p>
<p>其中的 <code>loadInterceptors()</code> 会将所有的拦截器加入到责任链中。</p>
<p>再提供了两个函数分别对应了拦截前和拦截后的入口：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6bb7ea9e.jpg"></p>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>现在来看看具体是怎么使用的吧。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6bff1876.jpg"></p>
<p>在请求的 <code>handle</code> 中首先进行加载（<code>loadInterceptors(AppConfig appConfig)</code>），也就是初始化责任链。</p>
<p>接下来则是客户端的入口；调用拦截前后的入口方法即可。</p>
<blockquote>
<p>由于是拦截器，那么在 <code>before</code> 函数中是可以对请求进行拦截的。只要返回 <code>false</code> 就不会继续向后处理。所以这里做了一个返回值的判断。</p>
</blockquote>
<p>同时对于使用者来说只需要创建拦截器类继承 <code>CicadaInterceptor</code> 类即可。</p>
<p>这里做了一个演示，分别有两个拦截器：</p>
<ol>
<li>记录一个业务 <code>handle</code> 的执行时间。</li>
<li>在 <code>after</code> 里打印了请求参数。</li>
<li>同时可在第一个拦截器中返回 <code>false</code> 让请求被拦截。</li>
</ol>
<p>先来做前两个试验：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6c2b3ab4.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6c693e9c.jpg"></p>
<hr>
<p>这样当我请求其中一个接口时会将刚才的日志打印出来：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6cf51a77.jpg"></p>
<hr>
<p>接下来我让打印执行时间的拦截器中拦截请求，同时输入向前端输入一段文本：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6d354832.jpg"></p>
<hr>
<p>请求接口可以看到如下内容：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d108d5254.jpg"></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d10a698d8.jpg"></p>
<p>同时后面的请求参数也没有打印出来，说明请求确实被拦截下来。</p>
<hr>
<p>同时我也可以调整拦截顺序，只需要在<code> @Interceptor(order = 1)</code> 注解中定义这个 <code>order</code> 属性即可（默认值是 0，越小越先执行）。</p>
<p>之前是打印请求参数的拦截器先执行，这次我手动将它的 order 调整为 2，而打印时间的 order 为 1 。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d10cc646d.jpg"></p>
<p>再次请求接口观察后台日志：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d10f1cb35.jpg"></p>
<p>发现打印执行时间的拦截器先执行。</p>
<p>那这个执行执行顺序如何实现自定义配置的呢？</p>
<p>其实也比较简单，有以下几步：</p>
<ul>
<li>在加载拦截器时将注解里的 <code>order</code> 保存起来。</li>
<li>设置拦截器到责任链中时通过反射将 <code>order</code> 的值保存到各个拦截器中。</li>
<li>最终通过排序重新排列这个责任链的顺序。</li>
</ul>
<p>贴一些核心代码。</p>
<p>扫描拦截器时保存 <code>order</code> 值：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d116ac586.jpg"></p>
<hr>
<p>保存 <code>order</code> 值到拦截器中：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d11869eac.jpg"></p>
<hr>
<p>重新对责任链排序：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1d11967bfd.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个责任链模式已经讲完，希望对这个设计模式还不了解的朋友带来些帮助。</p>
<p>上文中的源码如下：</p>
<ul>
<li><a href="https://github.com/TogetherOS/cicada">https://github.com/TogetherOS/cicada:一个高性能、轻量 HTTP 框架</a></li>
<li><a href="https://git.io/fxKid">https://git.io/fxKid</a></li>
</ul>
<p><strong>欢迎关注公众号一起交流：</strong></p>
]]></content>
      <categories>
        <category>cicada</category>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTTP</tag>
        <tag>Netty</tag>
        <tag>责任链</tag>
      </tags>
  </entry>
  <entry>
    <title>设计一个可拔插的 IOC 容器</title>
    <url>/2018/11/15/wheel/cicada6/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/08/5cd1c63f1bd4a.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>磨了许久，借助最近的一次通宵上线 <a href="https://github.com/TogetherOS/cicada">cicada</a> 终于更新了 <code>v2.0.0</code> 版本。</p>
<p>之所以大的版本号变为 2，确实是向下不兼容了；主要表现为：</p>
<ul>
<li>修复了几个反馈的 <code>bug</code>。</li>
<li>灵活的路由方式。</li>
<li>可拔插的 <code>IOC</code> 容器选择。</li>
</ul>
<p>其中重点是后面两个。</p>
<span id="more"></span>

<h1 id="新的路由方式"><a href="#新的路由方式" class="headerlink" title="新的路由方式"></a>新的路由方式</h1><p>先来看第一个：路由方式的更新。</p>
<p>在之前的版本想要写一个接口必须的实现一个 <code>WorkAction</code>；而且最麻烦的是一个实现类只能做一个接口。</p>
<p>因此也有朋友给我提过这个 <a href="https://github.com/TogetherOS/cicada/issues/12">issue</a>。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c64216f7d.jpg"></p>
<hr>
<p>于是改进后的使用方式如下：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c647f3a27.jpg"></p>
<blockquote>
<p>是否有点似曾相识的感觉😊。</p>
</blockquote>
<p>如上图所示，不需要实现某个特定的接口；只需要使用不同的注解即可。</p>
<p>同时也支持自定义 <code>pojo</code>, <code>cicada</code> 会在调用过程中对参数进行实例化。</p>
<p>拿这个 <code>getUser</code> 接口为例，当这样请求时这些参数就会被封装进 <code>DemoReq</code> 中.</p>
<p><a href="http://127.0.0.1:5688/cicada-example/routeAction/getUser?id=1234&name=zhangsan">http://127.0.0.1:5688/cicada-example/routeAction/getUser?id=1234&name=zhangsan</a></p>
<p>同时得到响应：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;hello =zhangsan&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>实现过程也挺简单，大家查看源码便会发现；这里贴一点比较核心的步骤。</p>
<ul>
<li>扫描所有使用 <code>@CicadaAction</code> 注解的类。</li>
<li>扫描所有使用 <code>@CicadaRoute</code> 注解的方法。</li>
<li>将他们的映射关系存入 <code>Map</code> 中。</li>
<li>请求时根据 <code>URL</code> 去 <code>Map</code> 中查找这个关系。</li>
<li>反射构建参数及方法调用。</li>
</ul>
<p><strong>扫描类以及写入映射关系</strong></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c64971c37.jpg"></p>
<hr>
<p><strong>请求时查询映射关系</strong></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c64ade749.jpg"></p>
<hr>
<p><strong>反射调用这些方法</strong></p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c64d6e772.jpg"></p>
<h1 id="是否需要-IOC-容器"><a href="#是否需要-IOC-容器" class="headerlink" title="是否需要 IOC 容器"></a>是否需要 IOC 容器</h1><p>上面那几个步骤其实我都是一把梭写完的，但当我写到执行具体方法时感觉<code>有点意思</code>了。</p>
<p>大家都知道反射调用方法有两个重要的参数：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c65023d49.jpg"></p>
<ul>
<li><code>obj</code> 方法执行的实例。</li>
<li><code>args..</code> 自然是方法的参数。</li>
</ul>
<p>我第一次写的时候是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method.invoke(method.getDeclaringClass().newInstance(), object);</span><br></pre></td></tr></table></figure>

<p>然后一测试，也没问题。</p>
<p>当我写完之后 <code>review</code> 代码时发现不对：这样这里每次都会创建一个新的实例，而且反射调用 <code>newInstance()</code> 效率也不高。</p>
<p>这时我不自觉的想到了 Spring 中 IOC 容器，和这里场景也非常的类似。</p>
<blockquote>
<p>在应用初始化时将所有的接口实例化并保存到 bean 容器中，当需要使用时只需要从容器中获取即可。</p>
</blockquote>
<p>这样只是会在启动时做很多加载工作，但造福后代啊。</p>
<h1 id="可拔插的-IOC-容器"><a href="#可拔插的-IOC-容器" class="headerlink" title="可拔插的 IOC 容器"></a>可拔插的 IOC 容器</h1><p>于是我打算自己实现一个这样的 bean 容器。</p>
<p>但在实现之前又想到一个 feature:</p>
<blockquote>
<p>不如把实现 bean 容器的方案交给使用者选择，可以选择使用 bean 容器，也可以就用之前的每次都创建新的实例，就像 Spring 中的 prototype 作用域一样。</p>
</blockquote>
<p>甚至可以自定义容器实现，比如将 bean 存放到数据库、Redis 都行；当然一般人也不会这么干。</p>
<p>和 <code>SPI</code> 的机制也有点类似。</p>
<p>要实现上述的需求大致需要以下步骤：</p>
<ul>
<li>一个通用的接口，包含了注册容器、从容器中获取实例等方法。</li>
<li><code>BeanManager</code> 类，由它来管理具体使用哪种 <code>IOC</code> 容器。</li>
</ul>
<p>所以首先定义了一个接口；<code>CicadaBeanFactory</code>:</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c651de476.jpg"></p>
<p>包含了注册和获取实例的接口。</p>
<p>同时分别有两个不同的容器实现方案。</p>
<p>默认实现；<code>CicadaDefaultBean</code>：<br><img src="https://i.loli.net/2019/05/08/5cd1c65811e8e.jpg"></p>
<p>也就是文中说道的，每次都会创建实例；由于这种方式其实根本就没有 bean 容器，所以也不存在注册了。</p>
<p>接下来是真正的 IOC 容器；<code>CicadaIoc</code>：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c65b97711.jpg"></p>
<blockquote>
<p>它将所有的实例都存放在一个 Map 中。</p>
</blockquote>
<p>当然也少不了刚才提到的 <code>CicadaBeanManager</code>，它会在应用启动的时候将所有的实例注册到 <code>bean</code> 容器中。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c65e91a11.jpg"></p>
<p>重点是图中标红的部分：</p>
<ul>
<li>需要根据用户的选择实例化 <code>CicadaBeanFactory</code> 接口。</li>
<li>将所有的实例注册到 CicadaBeanFactory 接口中。</li>
</ul>
<p>同时也提供了一个获取实例的方法：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c65f98cbb.jpg"></p>
<p>就是直接调用 <code>CicadaBeanFactory</code> 接口的方法。</p>
<hr>
<p>然后在上文提到的反射调用方法处就变为：</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c666b4ec4.jpg"></p>
<p>从 <code>bean</code> 容器中获取实例了；获取的过程可以是每次都创建一个新的对象，也可以是直接从容器中获取实例。这点对于这里的调用者来说<strong>并不关心</strong>。</p>
<p>所以这也实现了标题所说的：<code>可拔插</code>。</p>
<p>为了实现这个目的，我将 <code>CicadaIoc</code> 的实现单独放到一个模块中，以 jar 包的形式提供实现。</p>
<p><img src="https://i.loli.net/2019/05/08/5cd1c6680a66b.jpg"></p>
<p>所以如果你想要使用 <code>IOC</code> 容器的方式获取实例时只需要在你的应用中额外加入这个 jar 包即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.crossoverjie.opensource<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cicada-ioc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果不使用则是默认的 <code>CicadaDefaultBean</code> 实现，也就是每次都会创建对象。</p>
<p>这样有个好处：</p>
<p>当你自己想实现一个 <code>IOC</code> 容器时；只需要实现 <code>cicada</code> 提供的 <code>CicadaBeanFactory</code> 接口，并在你的应用中只加入你的 <code>jar</code> 包即可。</p>
<p><strong>其余所有的代码都不需要改变，便可随意切换不的容器。</strong></p>
<blockquote>
<p>当然我是推荐大家使用 <code>IOC</code> 容器的（其实就是单例），牺牲一点应用启动时间带来后续性能的提升是值得的。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>cicada</code> 的大坑填的差不多了，后续也会做一些小功能的迭代。</p>
<p>还没有关注的朋友赶紧关注一波：</p>
<p><a href="https://github.com/TogetherOS/cicada">https://github.com/TogetherOS/cicada</a></p>
<blockquote>
<p>PS：虽然没有仔细分析 Spring IOC 的实现，但相信看完此篇的朋友应该对 Spring IOC 以及 SpringMVC 会有一些自己的理解。</p>
</blockquote>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>cicada</category>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTTP</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>设计一个全局异常处理器</title>
    <url>/2019/07/15/wheel/cicada7-exception-handle/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/07/14/5d2b4a7010e6815837.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近稍微闲了一点于是把这个半年都没更新的开源项目 <a href="https://github.com/TogetherOS/cicada">cicada</a> 重新捡了起来。</p>
<p>一些新关注的朋友应该还不知道这项目是干啥的？先来看看官方介绍吧（其实就我自己写的😀）</p>
<blockquote>
<p>cicada: 基于 Netty4 实现的快速、轻量级 WEB 框架；没有过多的依赖，核心 jar 包仅 <code>30KB</code>。</p>
</blockquote>
<span id="more"></span>

<p><img src="https://i.loli.net/2019/07/14/5d2b4a70635d532624.jpg"></p>
<p>针对这个轮子以前也写过相关的介绍，感兴趣的可以再翻回去看看：</p>
<ul>
<li><a href="https://crossoverjie.top/2018/09/03/wheel/cicada1/">「造个轮子」——cicada(轻量级 WEB 框架)</a></li>
<li><a href="https://crossoverjie.top/2018/09/05/wheel/cicada2/">「造个轮子」——cicada 源码分析</a></li>
<li><a href="https://crossoverjie.top/2018/09/14/wheel/cicada3/">「造个轮子」——cicada 设计一个配置模块</a></li>
<li><a href="https://crossoverjie.top/2018/10/09/wheel/cicada4/">「造个轮子」——cicada 设计全局上下文</a></li>
<li><a href="https://crossoverjie.top/2018/10/22/wheel/cicada5/">利用责任链模式设计一个拦截器</a></li>
<li><a href="https://crossoverjie.top/2018/11/15/wheel/cicada6/">设计一个可拔插的 IOC 容器</a></li>
</ul>
<p>这些都看完了相信对这个小玩意应该会有更多的想法。</p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>广告打完了，回到正题；大家平时最常用的 <code>MVC</code> 框架当属 <code>SpringMVC</code> 了，而在搭建脚手架的时候相信全局异常处理是必不可少的。</p>
<h2 id="Spring-用法"><a href="#Spring-用法" class="headerlink" title="Spring 用法"></a>Spring 用法</h2><p>通常我们的做法如下：</p>
<p>传统 <code>Spring</code> 版本：</p>
<ul>
<li>实现一个 <code>Spring</code> 自带的接口，重写其中的方法，最后的异常处理便在此处。</li>
<li>将这个类配置在 <code>Spring</code> 的 <code>xml</code> ，当做一个 bean 注册到 <code>Spring</code> 容器中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">            HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">	<span class="comment">//自定义处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;ssm.exception.CustomExceptionResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<hr>
<p>当然现在流行的 <code>SpringBoot</code> 也有对应的简化版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">defaultErrorHandler</span><span class="params">(HttpServletRequest req, Exception e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//自定义处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全部都换为注解形式，但本质上还是一样的。</p>
<blockquote>
<p>都是要在容器中创建一个特殊的 bean，这个 bean 专门用于处理异常，当系统运行时出现异常，就从容器中找到该 bean，并执行其中的方法即可。</p>
</blockquote>
<p>至于这个特殊的 <code>bean</code> 如何标识出来，无非就是实现某个特定接口或者用注解声明，也就对应了传统 <code>Spring</code> 和 <code>SpringBoot</code> 的用法。</p>
<h2 id="cicada-用法"><a href="#cicada-用法" class="headerlink" title="cicada 用法"></a>cicada 用法</h2><p><code>cicada</code> 在设计自己的全局异常处理器时也参考了 Spring 的相关设计，所以最终用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CicadaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionHandle</span> <span class="keyword">implements</span> <span class="title class_">GlobalHandelException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerBuilder.getLogger(ExceptionHandle.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resolveException</span><span class="params">(CicadaContext context, Exception e)</span> &#123;</span><br><span class="line">        LOGGER.error(<span class="string">&quot;Exception&quot;</span>, e);</span><br><span class="line">        <span class="type">WorkRes</span> <span class="variable">workRes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkRes</span>();</span><br><span class="line">        workRes.setCode(<span class="string">&quot;500&quot;</span>);</span><br><span class="line">        workRes.setMessage(e.getClass().getName() + <span class="string">&quot;系统运行出现异常&quot;</span>);</span><br><span class="line">        context.json(workRes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义一个实现了 <code>GlobalHandelException</code> 接口的类，当请求出现异常时，页面和后台将会如下输出：</p>
<p><img src="https://i.loli.net/2019/07/14/5d2b4a708987b32808.jpg"><br><img src="https://i.loli.net/2019/07/14/5d2b4a70e668052739.jpg"></p>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>看得出用法和 <code>Spring</code> 非常类似，也是需要实现一个接口 <code>GlobalHandelException</code>，同时使用 <code>@CicadaBean</code> 注解该类将他加载到 <code>cicada</code> 内置的 <code>IOC</code> 容器内。</p>
<p>当出现异常时则在这个 <code>IOC</code> 容器中找到该对象调用它的 <code>resolveException</code> 即可。</p>
<p>其中还可以通过 <code>CicadaContext</code> 全局上下文响应不同的输出（<code>json/text/html</code>）。</p>
<h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><p><img src="https://i.loli.net/2019/07/14/5d2b4a712df5717670.jpg"></p>
<p>简单画了下流程图，步骤如下：</p>
<ul>
<li>初始化时会找到实现了 <code>GlobalHandelException</code> 接口的类，将它实例化并注册到 <code>IOC</code> 容器中。</li>
<li>当发生异常时从容器中获取到异常处理器的对象，执行其中的处理函数即可。</li>
</ul>
<p>说了半天原理来看看源码是如何实现的。</p>
<p><img src="https://i.loli.net/2019/07/14/5d2b4a716caeb94532.jpg"></p>
<p>在初始化 <code>bean</code> 时，如果是一个异常处理器则会将他单独存放（也就相当于前文说的打标识）。</p>
<p>其中的 <code>GlobalHandelException</code> 本身的定义也非常简单：</p>
<p><img src="https://i.loli.net/2019/07/14/5d2b4a7198bb390309.jpg"></p>
<hr>
<p>接下来是运行时：</p>
<p><img src="https://i.loli.net/2019/07/14/5d2b4a71bc98986729.jpg"><br><img src="https://i.loli.net/2019/07/14/5d2b4a71f27d495514.jpg"><br><img src="https://i.loli.net/2019/07/14/5d2b4a7221b4f38396.jpg"></p>
<p>而当出现异常时则会通过之前的保存的异常处理 <code>bean</code> 进行异常处理，在调用的同时将全局上下文及异常信息传递过去就齐活了。</p>
<p>这样就可以在这个实现类中实现我们自己的异常处理逻辑了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>万一今后面试官问你们 <code>SpringMVC</code> 的异常处理是如何实现的？你该知道怎么回答了吧😏。</p>
<p>同时也可以发散一下，是否可以配置一个针对于某一个 <code>controller</code> 的异常处理，这样每个 <code>controller</code> 产生的异常可以单独处理，如果没有配置则进入全局异常；原理也差不多，感兴趣的朋友可以提个 <code>PR</code> 完成该 <code>feature</code>。</p>
<p>项目源码：</p>
<p><a href="https://github.com/TogetherOS/cicada">https://github.com/TogetherOS/cicada</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>cicada</category>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTTP</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SPI 的原理与应用</title>
    <url>/2020/02/24/wheel/cicada8-spi/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/24/JxoDiHGdOK5q7Nj.jpg" alt="cicada8-spi.md---0082zybply1gc6rp5ur8fj30u00u0tf7.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不知大家现在有没有去公司复工，我已经在家办公将近 3 周了，同时也在家呆了一个多月；还好工作并没有受到任何影响，我个人一直觉得远程工作和 IT 行业是非常契合的，这段时间的工作效率甚至比在办公室还高，同时由于我们公司的业务在海外，所以疫情几乎没有造成太多影响。</p>
<p>扯远了，这次主要是想和大家分享一下 <code>Java</code> 的 <code>SPI</code> 机制。周末没啥事，我翻了翻我之前的写的博客 <a href="https://crossoverjie.top/2018/11/15/wheel/cicada6/">《设计一个可拔插的 IOC 容器》</a>，发现当时的实现并不那么优雅。</p>
<p>还没看过的朋友的我先做个前景提要，当时的需求：</p>
<blockquote>
<p>我实现了一个类似于的 SpringMVC 但却很轻量的 http 框架 <a href="https://github.com/TogetherOS/cicada/">cicada</a>，其中当然也需要一个 IOC 容器，可以存放所有的单例 bean。</p>
</blockquote>
<blockquote>
<p>这个 IOC 容器的实现我希望可以有多种方式，甚至可以提供一个接口供其他人实现；当然切换这个 IOC 容器的过程肯定是不能存在硬编码的，也就是这里所提到的<strong>可拔插</strong>。<br>当我想使用 A 的实现方式时，我就引入 A 的 jar 包，使用 B 时就引入 B 的包。</p>
</blockquote>
<span id="more"></span>

<p><img src="https://i.loli.net/2020/02/24/n7QkNmv5t2r4HOy.jpg" alt="cicada8-spi.md---0082zybply1gc6sqv3gp4j30zm0u0n8c.jpg"></p>
<p>先给大家看看两次实现的区别，先从代码简洁程度来说就是 <code>SPI</code> 更胜一筹。</p>
<h1 id="什么是-SPI"><a href="#什么是-SPI" class="headerlink" title="什么是 SPI"></a>什么是 SPI</h1><p>在具体分析之前还是先了解下 <code>SPI</code> 是什么？</p>
<p>首先它其实是 <code>Service provider interface</code> 的简写，翻译成中文就是服务提供发现接口。</p>
<p>不过这里不要被这个名词搞混了，这里的<code>服务发现</code>和我们常听到的微服务中的服务发现并不能划等号。</p>
<p>就如同上文提到的对 <code>IOC</code> 容器的多种实现方式 A、B、C（可以把它们理解为服务），我需要在运行时知道应该使用哪一种具体的实现。</p>
<p>其实本质上来说这就是一种典型的面向接口编程，这一点在我们刚开始学习编程的时候就被反复强调了。</p>
<h1 id="SPI-实践"><a href="#SPI-实践" class="headerlink" title="SPI 实践"></a>SPI 实践</h1><p>接下来我们来如何来利用 SPI 实现刚才提到的可拔插 IOC 容器。</p>
<p>既然刚才都提到了 SPI 的本质就是面向接口编程，所以自然我们首先需要定义一个接口：</p>
<p><img src="https://i.loli.net/2020/02/24/DVBJez2YtwiKs9S.jpg" alt="cicada8-spi.md---0082zybply1gc6tlhql39j31490u0wjj.jpg"></p>
<p>其中包含了一些 <code>Bean</code> 容器所必须的操作：注册、获取、释放 bean。</p>
<p>为了让其他人也能实现自己的 <code>IOC</code> 容器，所以我们将这个接口单独放到一个 <code>Module</code> 中，可供他人引入实现。</p>
<p><img src="https://i.loli.net/2020/02/24/CASm2MdYGj7IZRl.jpg" alt="cicada8-spi.md---0082zybply1gc6tobsdgwj30u40ewdh1.jpg"></p>
<p>所以当我要实现一个单例的 <code>IOC</code> 容器时，我只需要新建一个 <code>Module</code> 然后引入刚才的模块并实现 <code>CicadaBeanFactory</code> 接口即可。</p>
<p>当然其中最重要的则是需要在 <code>resources</code> 目录下新建一个 <code>META-INF/services/top.crossoverjie.cicada.base.bean.CicadaBeanFactory</code> 文件，文件名必须得是我们之前定义接口的全限定名（SPI 规范）。</p>
<p><img src="https://i.loli.net/2020/02/24/AR8zJs5QrV1W2yE.jpg" alt="cicada8-spi.md---0082zybply1gc6ts164zlj30uk0amq3x.jpg"></p>
<p>其中的内容便是我们自己实现类的全限定名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">top.crossoverjie.cicada.bean.ioc.CicadaIoc</span><br></pre></td></tr></table></figure>

<p>可以想象最终会通过这里的全限定名来反射创建对象。</p>
<p>只不过这个过程 Java 已经提供 API 屏蔽掉了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CicadaBeanFactory <span class="title function_">getCicadaBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    ServiceLoader&lt;CicadaBeanFactory&gt; cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);</span><br><span class="line">    <span class="keyword">if</span> (cicadaBeanFactories.iterator().hasNext())&#123;</span><br><span class="line">        <span class="keyword">return</span> cicadaBeanFactories.iterator().next() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CicadaDefaultBean</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>classpath</code> 中存在我们刚才的实现类（引入实现类的 jar 包），便可以通过 <code>java.util.ServiceLoader</code> 工具类来找到所有的实现类（可以有多个实现类同时存在，只不过通常我们只需要一个）。</p>
<hr>
<p>一些都准备好之后，使用自然就非常简单了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.crossoverjie.opensource<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cicada-ioc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们只需要引入这个依赖便能使用它的实现，当我们想换一种实现方式时只需要更换一个依赖即可。</p>
<p>这样就做到了不修改一行代码灵活的<code>可拔插</code>选择 <code>IOC</code> 容器了。</p>
<h1 id="SPI-的一些其他应用"><a href="#SPI-的一些其他应用" class="headerlink" title="SPI 的一些其他应用"></a>SPI 的一些其他应用</h1><p>虽然平时并不会直接使用到 SPI 来实现业务，但其实我们使用过的绝大多数框架都会提供 SPI 接口方便使用者扩展自己的功能。</p>
<p>比如 <code>Dubbo</code> 中提供一系列的扩展：<br><img src="https://i.loli.net/2020/02/24/L3hFlJO9bX7IAd1.jpg" alt="cicada8-spi.md---0082zybply1gc6ue6zubvj30gq0pymyq.jpg"></p>
<p>同类型的 <code>RPC</code> 框架 <code>motan</code> 中也提供了响应的扩展：<br><img src="https://i.loli.net/2020/02/24/5WxzwG8Q9ZeIY3r.jpg" alt="cicada8-spi.md---0082zybply1gc6ufacqt5j30lm0j8q5j.jpg"></p>
<p>他们的使用方式都和 Java SPI 非常类似，只不过原理略有不同，同时也新增了一些功能。</p>
<p>比如 <code>motan</code> 的 <code>spi</code> 允许是否为单例等等。</p>
<p>再比如 MySQL 的驱动包也是利用 SPI 来实现自己的连接逻辑。</p>
<p><img src="https://i.loli.net/2020/02/24/TJLCI2yEn8WV9MX.jpg" alt="cicada8-spi.md---0082zybply1gc6uqg2ga2j30ii0bmdgz.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> <code>Java</code> 自身的 <code>SPI</code> 其实也有点小毛病，比如：</p>
<ul>
<li>遍历加载所有实现类效率较低。</li>
<li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时会有并发问题（虽然没人这么干）。</li>
</ul>
<p>最后总结一下，<code>SPI</code> 并不是某项高深的技术，本质就是面向接口编程，而面向接口本身在我们日常开发中也是必备技能，所以了解使用 <code>SPI</code> 也是很用处的。</p>
<p>本文所有源码：</p>
<p><a href="https://github.com/TogetherOS/cicada">https://github.com/TogetherOS/cicada</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>cicada</category>
        <category>spi</category>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTTP</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理的实际应用</title>
    <url>/2020/03/30/wheel/cicada9-proxy/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/03/30/Rvbcd2soy3KWgAI.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在用 <code>Python</code> 的 <code>SQLAlchemy</code> 库时（一个类似于 <code>Hibernate</code> 的 <code>ORM</code> 框架），发现它的 <code>Events</code> 事件还挺好用。</p>
<p>简单说就是当某张表的数据发生变化（曾、删、改）时会有一个事件回调，这样一些埋点之类的需求都可以实现在这里，同时和业务代码完全解耦，维护起来也很方便。</p>
<p>例如当订单状态发生变化需要发异步通知这样的需求也可以利用这个实现。</p>
<p>根据我之前使用 <code>Mybatis</code> 的经验，好像没怎么注意有这个功能，查阅了下发现 <code>Hibernate</code> 是支持的，只是我用得也少，所以也没怎么在意。</p>
<span id="more"></span>


<blockquote>
<p> 逐渐偏离主题。。。</p>
</blockquote>
<p>说这些的主要原因是我打算为之前写的 <a href="https://github.com/TogetherOS/cicada">cicada</a> (轻量的 http 框架)加一个数据库操作包，也实现类似的功能。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>最终的使用效果如下：</p>
<blockquote>
<p>第一版本还比较粗糙，但功能都具备。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/30/6pZshMtufPGWECK.jpg"></p>
<p>第一步：需要实现一个初始化接口，该接口会在应用初始化的时候执行。</p>
<hr>
<p>紧接着我们需要定义一个 <code>Model</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@OriginName(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="meta">@PrimaryId</span></span><br><span class="line">    <span class="keyword">private</span> Integer id ;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> String password ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FieldName(value = &quot;city_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer cityId ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它所对应的表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `description` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `roleId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">  `city_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<p>当需要查询数据时：<br><img src="https://i.loli.net/2020/03/30/gIyDvedEM5oPGXV.jpg"><br><img src="https://i.loli.net/2020/03/30/PeTi685t7HQpDE3.jpg"></p>
<p>便可以这样访问数据库。</p>
<hr>
<p>当需要更新数据时：<br><img src="https://i.loli.net/2020/03/30/Z8G5w6O3ML7EmNJ.jpg"><br><img src="https://i.loli.net/2020/03/30/uJxo1vNPUcLIiZn.jpg"></p>
<p>在初始化 <code>DBHandle</code> 时指定一个回调接口(也就是这里的 <code>UserUpdateListener</code>)，便可以在修改数据的时候拿到本次修改的数据实体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserUpdateListener</span> <span class="keyword">implements</span> <span class="title class_">DataChangeListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;user update data=&#123;&#125;&quot;</span>, obj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时我们可以在控制台看到数据修改时的回调结果：</p>
<p><img src="https://i.loli.net/2020/03/30/mpoH9shziTjkfW5.jpg"></p>
<p>这样就实现了文初所提到的功能，便可以实现一些数据变化后需要执行的业务逻辑。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>下面重点来看看这个功能的实现过程；其实通过生成 <code>DBHandle</code>（数据库增删改的接口）实例的 <code>API</code> 便可以看出些端倪。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DBHandle</span> <span class="variable">handle</span> <span class="operator">=</span> (DBHandle) <span class="keyword">new</span> <span class="title class_">HandleProxy</span>(DBHandle.class).getInstance(<span class="keyword">new</span> <span class="title class_">UserSaveListener</span>());</span><br></pre></td></tr></table></figure>

<p><code>DBHandel</code> 虽然是个接口，但是它并不是使用一个实现类来实现的，而是通过代理生成。</p>
<p>那通过代理生成比直接实例化实现类有啥好处呢？</p>
<p>举个例子，比如现在你想买一个新手机。</p>
<p><img src="https://i.loli.net/2020/03/30/S34Zyn8WtpbgoiX.jpg"></p>
<p>第一种方式可以直接在官方旗舰店买一个标配的手机，没有额外的东西只有一个手机。</p>
<p>当然你也可以在某些第三方经销商那里购买带套餐的，比如<code>套餐一</code>在标配的基础上多了<code>保护壳、贴膜</code>之类的附加属性。</p>
<p>这个经销商就类似于我们这里的代理类，他可以在原有实现的基础上新增一些东西，至于新增什么全看你自己的需要了。</p>
<p>而之所以叫<strong>动态</strong>代理，也是因为这个代理类是在程序运行过程中动态创建的，在编译过程中并不能确定这个类的全限定名。</p>
<hr>
<p>下面来看看这个代理类是如何生成的：</p>
<p><img src="https://i.loli.net/2020/03/30/4zhFiUrMO8Iu7cl.jpg"><br>主要利用 <code>JDK</code> 自带的 <code>API</code> 实现的，具体参数可以直接参考官方文档：<br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html">https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html</a></p>
<p>总之这样便可以创建一个 <code>DBHandler</code> 接口的代理对象，而真正的代理过程是在 <code>InvocationHandler#invoke()</code> 函数中实现的：</p>
<p><img src="https://i.loli.net/2020/03/30/finMduc76swtCN5.jpg"></p>
<p>这里的实现也是非常简单，在实现完代理对象的业务逻辑后便回调我们传入的事件接口，其中的参数便是当前的数据库 <code>Model</code> 实体对象。</p>
<blockquote>
<p> 不过需要注意的是，这个事件回调和业务线程是同一个，所以写在这里的逻辑建议都为异步(Hibernate 和 SQLAlchemy 都存在这个情况)。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上便是整个动态代理实现 <code>ORM</code> 监听机制的全过程，其实可以看出并没有它名称那样看起来高大上，当然本身实现也比较简单。</p>
<p>同时也不止这一种实现方式，例如:</p>
<ul>
<li>cglib</li>
<li>javassist</li>
<li>ASM</li>
</ul>
<p>etc..</p>
<p>他们的具体实现及优劣就不在本文探讨了，感兴趣的后续我会将这个功能用这几种方式实现一遍。</p>
<p>同时动态代理的应用也不止于此，比如：</p>
<ul>
<li><code>RPC</code> 中无感知的远程调用。</li>
<li><code>Spring</code> 中的 <code>AOP</code>、拦截器等。</li>
</ul>
<p>后续会继续完善这个 <code>ORM</code> 库，甚至可以独立出来作为一个小巧的数据库工具也未尝不可。</p>
<p>相关源码见此处：<br><a href="https://github.com/TogetherOS/cicada/blob/17dc61e419dd7fb9690cfe29859c792893598c5f/cicada-example/src/main/java/top/crossoverjie/cicada/example/action/RouteAction.java#L62">https://github.com/TogetherOS/cicada</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>cicada</category>
        <category>动态代理</category>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTTP</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>撸了一个 Feign 增强包</title>
    <url>/2020/07/28/wheel/feign-plus/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/07/28/uA1BmwnQNs3GXHS.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近准备将公司的一个核心业务系统用 <code>Java</code> 进行重构，大半年没写 <code>Java</code> ，<code>JDK</code> 都更新到 14 了，考虑到稳定性等问题最终还是选择的 <code>JDK11</code>。</p>
<p>在整体架构选型时，由于是一个全新的系统，所以没有历史包袱，同时团队中也有多位大牛坐镇，因此我们的选项便大胆起来。</p>
<p>最终结果就是直接一把梭，直接上未来的大趋势：<code>Service Mesh</code>，直接把什么 <code>SpringCloud</code>、<code>Dubbo</code> 这类分布式框架全部干掉。</p>
<p>本次的重点不是讨论 <code>Service Mesh</code> 是什么、能解决什么问题、为什么选择它，毕竟我也在学习阶段，啥时候整明白线上也稳定了再和大家来交流。</p>
<span id="more"></span>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>既然方向定了就开始实际撸码了，不过刚一开始就验证了”理想很丰满、现实很骨感“；</p>
<p>由于我们去掉了 <code>SpringCloud</code> 和 <code>Dubbo</code> 这类框架，服务的注册、发现、负载均衡等需求全部都下沉到 <code>Service Mesh</code> 中提供了。</p>
<p>但对于开发来说依然希望可以调用本地方法的方式来调用远程服务，这在 <code>SpringCloud</code> 这类框架中是很容易实现的，框架本身就有很好的支持。</p>
<p>回到我们这个场景，需求其实很简单，就是想达到 <code>SpringCloud</code> 中的 <code>Feign</code> 这样的声明式+注解的方式调用。</p>
<p><img src="https://i.loli.net/2020/07/28/xnIo8mQbjHfURZg.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StoreClient client ;</span><br><span class="line"></span><br><span class="line"><span class="type">Store</span> <span class="variable">store</span> <span class="operator">=</span> client.update(<span class="number">1</span>, store)</span><br></pre></td></tr></table></figure>

<p>使用 <code>spring-cloud-openfeign</code> 这个包其实就能实现上述的需求了，但这样会引入一些我们根本不会使用的 <code>SpringCloud</code> 的相关依赖，让人感觉”不干净了“；同时也和 <code>Service Mesh</code> 的理念相反，其中的一大目的就是要降低这类框架的侵入性。</p>
<hr>
<p>其实 <code>spring-cloud-openfeign</code> 的核心就是 <a href="https://github.com/OpenFeign/feign">Feign</a>，本身它也是可以开箱即用的，所以便尝试看 <code>Feign</code> 自己是否支持这样的用法。</p>
<p><img src="https://i.loli.net/2020/07/28/TXLH9rFSNyp1x4I.jpg"></p>
<p>通过官方文档可以得知：是可以定义接口的形式来调用远程接口的，但它本质上是不依赖其他库便可以使用，所以它本身是没有和 <code>Spring</code> 整合也是合情合理，但也就造成了没有现成库可供我们使用。</p>
<blockquote>
<p>我们自然是不想写上图红框处的代码的，希望所有接口直接注入就可以使用。</p>
</blockquote>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>因此结合以上的需求便有了这个库 <a href="https://github.com/crossoverJie/feign-plus">feign-plus</a></p>
<p>它的使用流程其实就是翻版的 <code>spring-cloud-openfeign</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignPlusClient(name = &quot;github&quot;, url = &quot;$&#123;github.url&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Github</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestLine(&quot;GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span></span><br><span class="line">    List&lt;GitHubRes&gt; <span class="title function_">contributors</span><span class="params">(<span class="meta">@Param(&quot;owner&quot;)</span> String owner, <span class="meta">@Param(&quot;repo&quot;)</span> String repo)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>SpringBoot</code> 入口进行扫描：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignPlusClients(basePackages = &quot;top.crossoverjie.feign.test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>Spring</code> 上下文中直接注入使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Github github ;</span><br><span class="line"></span><br><span class="line">List&lt;GitHubRes&gt; contributors = github.contributors(<span class="string">&quot;crossoverJie&quot;</span>, <span class="string">&quot;feign-plus&quot;</span>);</span><br><span class="line">logger.info(<span class="string">&quot;contributors=&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(contributors));    </span><br></pre></td></tr></table></figure>

<p>所以当我们需要调用一些外部第三方接口时（比如支付宝、外部 OpenAPI）便可类似于这样定义一个接口，把所有 HTTP 请求的细节屏蔽掉。</p>
<p>当然也适合公司内部之间的服务调用，和咱们以前写 <code>SpringCloud</code> 或 <code>Dubbo</code> 时类似；服务提供方提供一个 <code>Client</code> 包，消费方直接依赖便可以调用。其他的负载均衡、容错之类的由 <code>Service Mesh</code> 替我们完成。</p>
<p>对于内部接口，也可以加上 <code>@RequestMapping(&quot;/path&quot;)</code> 注解：</p>
<p><img src="https://i.loli.net/2020/07/28/XetQ4EgyqiRhJdB.jpg"></p>
<p>在请求时便会在 url 后拼接上 <code>/order</code>，这样在配置 <code>feign.order.service.url</code> 时只需要填入服务提供方的域名或 IP 即可。</p>
<hr>
<p><code>feign-plus</code> 也支持切换具体的 httpclient，默认是 <code>okhttp3</code>，通过以下配置便可更改。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># default(okhttp3)</span></span><br><span class="line"><span class="attr">feign.httpclient</span>=<span class="string">http2Client</span></span><br></pre></td></tr></table></figure>

<p>当然也有其他相关配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign.plus.max-idle-connections</span> = <span class="string">520</span></span><br><span class="line"><span class="attr">feign.plus.connect-timeout</span> = <span class="string">11000</span></span><br><span class="line"><span class="attr">feign.plus.read-timeout</span> = <span class="string">12000</span></span><br></pre></td></tr></table></figure>



<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>最后简单聊聊是如何完成的吧，其实本质上就是 <code>spring-cloud-openfeign</code> 的浓缩版。</p>
<p>其中最为核心的便是 <code>top.crossoverjie.feign.plus.factory.FeignPlusBeanFactory</code> 类。</p>
<p><img src="https://i.loli.net/2020/07/28/N3yep2SP1zniu6T.jpg"></p>
<p>该类实现了 <code>org.springframework.beans.factory.FactoryBean</code>接口，并重写了 <code>getObject()</code> 方法返回一个对象。</p>
<blockquote>
<p>这段代码是不是似曾相识，其实就是 <code>Feign</code> 的官方 <code>demo</code>。</p>
</blockquote>
<p>这里所返回的对象其实就是我们定义的接口的代理对象，而这个对象本身则是 <code>Feign</code> ，所以再往里说：我们的 <code>http</code> 请求编解码、发起请求等逻辑又被这个 <code>feign</code> 对象所代理了。</p>
<p><img src="https://i.loli.net/2020/07/28/joLesbxGQrEkK37.jpg"></p>
<p>这个 <code>HardCodedTarget</code> 则是 <code>Feign</code> 内部用于代理最终请求的对象。</p>
<blockquote>
<p>有一个小难受的地方：这样的自己定义 Bean 然后注入对象 Idea 是识别不了的，认为当前上下文没有该 Bean，但是 spring-cloud-openfeign 却可以识别。</p>
</blockquote>
<hr>
<p>由于 <code>Feign</code> 支持多个客户端，所以这里的客户端可以通过配置文件动态指定。</p>
<p><img src="https://i.loli.net/2020/07/28/q74soVAQbl5NyK6.jpg"></p>
<p>利用 <code>SpringBoot</code> 提供的 <code>@ConditionalOnExpression</code> 注解可以根据配置动态的选择使用哪个 <code>httpclient</code>,也就是动态选择生成哪个 <code>Bean</code>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个库的逻辑非常简单，本质上就是封装了 <code>Feign</code> 并提供了 <code>SpringBoot</code> 的支持，欢迎有类似需求的朋友下载使用。</p>
<p><code>feign-plus</code>源码：<a href="https://github.com/crossoverJie/feign-plus">https://github.com/crossoverJie/feign-plus</a></p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>撸了一个 Feign 增强包 V2.0 升级版</title>
    <url>/2022/05/06/wheel/feign-plus2/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/10/05/sKN6abRExi9wj1X.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大概在两年前我写过一篇 <a href="https://crossoverjie.top/2020/07/28/wheel/feign-plus/">撸了一个 Feign 增强包</a>，当时准备是利用 <code>SpringBoot + K8s</code> 构建应用，这个库可以类似于 <code>SpringCloud</code> 那样结合 <code>SpringBoot</code> 使用声明式接口来达到服务间通讯的目的。</p>
<span id="more"></span>

<p>但后期由于技术栈发生变化（改为 Go），导致该项目只实现了基本需求后就搁置了。</p>
<p>巧合的时最近内部有部分项目又计划采用 <code>SpringBoot + K8s</code> 开发，于是便着手继续维护；现已经内部迭代了几个版本比较稳定了，也增加了一些实用功能，在此分享给大家。</p>
<p><a href="https://github.com/crossoverJie/feign-plus">https://github.com/crossoverJie/feign-plus</a></p>
<p>首先是新增了一些 <code>features</code>:</p>
<ul>
<li>更加统一的 API。</li>
<li>统一的请求、响应、异常日志记录。</li>
<li>自定义拦截器。</li>
<li>Metric 支持。</li>
<li>异常传递。</li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>结合上面提到的一些特性做一些简单介绍，统一的 API 主要是在使用层面：</p>
<p>在上一个版本中声明接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignPlusClient(name = &quot;github&quot;, url = &quot;$&#123;github.url&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Github</span> &#123;</span><br><span class="line">    <span class="meta">@RequestLine(&quot;GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span></span><br><span class="line">    List&lt;GitHubRes&gt; <span class="title function_">contributors</span><span class="params">(<span class="meta">@Param(&quot;owner&quot;)</span> String owner, <span class="meta">@Param(&quot;repo&quot;)</span> String repo)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的 <code>@RequestLine</code> 等注解都是使用 feign 包所提供的。</p>
<p>这次更新后改为如下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/v1/demo&quot;)</span></span><br><span class="line"><span class="meta">@FeignPlusClient(name = &quot;demo&quot;, url = &quot;$&#123;feign.demo.url&#125;&quot;, port = &quot;$&#123;feign.demo.port&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DemoApi</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/id&quot;)</span></span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">(<span class="meta">@RequestParam(value = &quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/id/&#123;id&#125;&quot;)</span></span><br><span class="line">    String <span class="title function_">id</span><span class="params">(<span class="meta">@PathVariable(value = &quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/create&quot;)</span></span><br><span class="line">    Order <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span> OrderCreateReq req)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line">    Order <span class="title function_">query</span><span class="params">(<span class="meta">@SpringQueryMap</span> OrderQueryDTO dto)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟悉的味道，基本都是 <code>Spring</code> 自带的注解，这样在使用上学习成本更低，同时与项目中原本的接口写法保持一致。</p>
<blockquote>
<p>@SpringQueryMap(top.crossoverjie.feign.plus.contract.SpringQueryMap) 是由 feign-plus 提供，其实就是从 SpringCloud 中 copy 过来的。</p>
</blockquote>
<p>我这里写了两个 demo 来模拟调用：<br><img src="https://s2.loli.net/2023/10/05/bSk2Gt3lghTOHdB.png"></p>
<p><code>provider</code>： 作为服务提供者提供了一系列接口供消费方调用，并对外提供了一个 api 模块。<br><img src="https://s2.loli.net/2023/10/05/sOX7FkmSH183VNf.png"></p>
<hr>
<p><code>demo</code>：作为服务消费者依赖 <code>provider-api</code> 模块，根据其中声明的接口进行远程调用。<br><img src="https://s2.loli.net/2023/10/05/Y5yVQFf6jlTqPKW.png"><br>配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8181</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">demo:</span></span><br><span class="line">    <span class="attr">url :</span> <span class="string">http://127.0.0.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">top:</span></span><br><span class="line">      <span class="attr">crossoverjie:</span> <span class="string">debug</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">base-path:</span> <span class="string">/actuator</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">distribution:</span></span><br><span class="line">      <span class="attr">percentiles:</span></span><br><span class="line">        <span class="attr">all:</span> <span class="number">0.5</span><span class="string">,0.75,0.95,0.99</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">prometheus:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">step:</span> <span class="string">1m</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo</span></span><br></pre></td></tr></table></figure>

<p>当我们访问 <code>http://127.0.0.1:8181/hello/2</code> 接口时从控制台可以看到调用结果：<br><img src="https://s2.loli.net/2023/10/05/yM7INlJECUberOY.png"></p>
<h1 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h1><p>从上图中可以看出 <code>feign-plus</code> 会用 debug 记录请求&#x2F;响应结果，如果需要打印出来时需要将该包下的日志级别调整为 debug：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">top:</span></span><br><span class="line">      <span class="attr">crossoverjie:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p>由于内置了拦截器，也可以自己继承 <code>top.crossoverjie.feign.plus.log.DefaultLogInterceptor</code> 来实现自己的日志拦截记录，或者其他业务逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomFeignInterceptor</span> <span class="keyword">extends</span> <span class="title class_">DefaultLogInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">(String target, String url, String body)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.request(target, url, body);</span><br><span class="line">        log.info(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exception</span><span class="params">(String target, String url, FeignException feignException)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.exception(target, url, feignException);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">response</span><span class="params">(String target, String url, Object response)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.response(target, url, response);</span><br><span class="line">        log.info(<span class="string">&quot;response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="监控-metric"><a href="#监控-metric" class="headerlink" title="监控 metric"></a>监控 metric</h1><p><code>feign-plus</code> 会自行记录每个接口之间的调用耗时、异常等情况。<br><img src="https://s2.loli.net/2023/10/05/iouq18vmefGQbXM.png"><br>访问 <code>http://127.0.0.1:8181/actuator/prometheus</code> 会看到相关埋点信息，通过 <code>feign_call*</code> 的 key 可以自行在 <code>Grafana</code> 配置相关面板，类似于下图：<br><img src="https://s2.loli.net/2023/10/05/qFjrXtoM3lVY4CZ.png"></p>
<h1 id="异常传递"><a href="#异常传递" class="headerlink" title="异常传递"></a>异常传递</h1><p><code>rpc</code>（远程调用）要使用起来真的类似于本地调用，异常传递必不可少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// provider</span></span><br><span class="line">	<span class="keyword">public</span> Order <span class="title function_">query</span><span class="params">(OrderQueryDTO dto)</span> &#123;</span><br><span class="line">		log.info(<span class="string">&quot;dto = &#123;&#125;&quot;</span>, dto);</span><br><span class="line">		<span class="keyword">if</span> (dto.getId().equals(<span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DemoException</span>(<span class="string">&quot;provider test exception&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Order</span>(dto.getId());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// consumer</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            demoApi.query(<span class="keyword">new</span> <span class="title class_">OrderQueryDTO</span>(id, <span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DemoException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;feignCall:&#123;&#125;, sourceApp:[&#123;&#125;], sourceStackTrace:&#123;&#125;&quot;</span>, e.getMessage(), e.getAppName(), e.getDebugStackTrace(), e);</span><br><span class="line">        &#125;	</span><br></pre></td></tr></table></figure>
<p>比如 <code>provider</code> 中抛出了一个自定义的异常，在 <code>consumer</code> 中可以通过 <code>try/catch</code> 捕获到该异常。</p>
<p>为了在 feign-plus 中实现该功能需要几个步骤：</p>
<ol>
<li>自定义一个通用异常。</li>
<li>服务提供方需要实现一个全局拦截器，当发生异常时统一对外响应数据。</li>
<li>服务消费方需要自定义一个异常解码器的 bean。</li>
</ol>
<p>这里我在 <code>provider</code> 中自定义了一个 <code>DemoException</code>：<br><img src="https://s2.loli.net/2023/10/05/GuoaDLpC7JNR48n.png"></p>
<blockquote>
<p>通常这个类应该定义在公司内部的通用包中，这里为了演示方便。</p>
</blockquote>
<p>接着定义了一个 <code>HttpStatus</code> 的类用于统一对外响应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpStatus</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> String debugStackTrace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个也应该放在通用包中。</p>
</blockquote>
<p>然后在 <code>provider</code> 中定义全局异常处理：<br><img src="https://s2.loli.net/2023/10/05/F1CqAt5V2WlkxOQ.png"></p>
<p>当出现异常时便会返回一个 http_code&#x3D;500 的数据：<br><img src="https://s2.loli.net/2023/10/05/gPt4nIdQ7hV6Xr2.png"></p>
<p>到这一步又会出现一个引战话题：HTTP 接口返回到底是全部返回 200 然后通过 code 来来判断，还是参考 http_code 进行返回?</p>
<p>这里不做过多讨论，具体可以参考耗子叔的文章：<br><a href="https://coolshell.cn/articles/22173.html">“一把梭：REST API 全用 POST”</a></p>
<p><code>feign-plus</code> 默认采用的 http_code !&#x3D;200 才会认为发生了异常。</p>
<p>而这里的 http_status 也是参考了 Google 的 api 设计：<br><img src="https://s2.loli.net/2023/10/05/WcpTqtlwsfI9NaY.png"><br>具体可以参考这个链接：<br><a href="https://cloud.google.com/apis/design/errors#propagating_errors">https://cloud.google.com/apis/design/errors#propagating_errors</a></p>
<p>然后定义一个异常解析器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignExceptionConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FeignErrorDecoder <span class="title function_">feignExceptionDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (methodName, response, e) -&gt; &#123;</span><br><span class="line">            <span class="type">HttpStatus</span> <span class="variable">status</span> <span class="operator">=</span> JSONUtil.toBean(response, HttpStatus.class);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DemoException</span>(status.getAppName(), status.getCode(), status.getMessage(), status.getDebugStackTrace());</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通常这块代码也是放在基础包中。</p>
</blockquote>
<hr>
<p>这样当服务提供方抛出异常时，消费者便能成功拿到该异常：<br><img src="https://s2.loli.net/2023/10/05/EpNwAof1GrFBCUV.png"></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>实现原理其实也比较简单，了解 <code>rpc</code> 原理的话应该会知道，服务提供者返回的异常调用方是不可能接收到的，这和是否由一种语言实现也没关系。</p>
<p>毕竟两个进程之间的栈是完全不同的，不在一台服务器上，甚至都不在一个地区。</p>
<p>所以 <code>provider</code> 抛出异常后，消费者只能拿到一串报文，我们只能根据这段报文解析出其中的异常信息，然后再重新创建一个内部自定义的异常（比如这里的 <code>DemoException</code>），也就是我们自定义异常解析器所干的事情。</p>
<p>下图就是这个异常传递的大致流程：<br><img src="https://s2.loli.net/2023/10/05/2NracUKAhSX5ZJD.png"></p>
<h2 id="code-message-模式"><a href="#code-message-模式" class="headerlink" title="code message 模式"></a>code message 模式</h2><p>由于 feign-plus 默认是采用 <code>http_code != 200</code> 的方式来抛出异常的，所以采用 <code>http_code=200, code message</code> 的方式响应数据将不会传递异常，依然会任务是一次正常调用。</p>
<p>不过基于该模式传递异常也是可以实现的，但没法做到统一，比如有些团队习惯 <code>code !=0</code> 表示异常，甚至字段都不是 code；再或者异常信息有些是放在 message 或 msg 字段中。</p>
<p>每个团队、个人习惯都不相同，所以没法抽象出一个标准，因此也就没做相关适配。</p>
<blockquote>
<p>这也印证了使用国际标准所带来的好处。</p>
</blockquote>
<p>限于篇幅，如果有相关需求的朋友也可以在评论区沟通，实现上会比现在稍微复杂一点点🤏🏻。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>项目源码：<br><a href="https://github.com/crossoverJie/feign-plus">https://github.com/crossoverJie/feign-plus</a></p>
<p>基于2022年云原生这个背景，当然更推荐大家使用 <code>gRPC</code> 来做服务间通信，这样也不需要维护类似于这样的库了。</p>
<p>不过在一些调用第三方接口而对方也没有提供 SDK 时，这个库也有一定用武之地，虽然使用原生 feign 也能达到相同目的，但使用该库可以使得与 <code>Spring</code> 开发体验一致，同时内置了日志、<code>metric</code> 等功能，避免了重复开发。</p>
<p><strong>你的点赞与分享是对我最大的支持</strong></p>
]]></content>
      <categories>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>技术阅读周刊第一期</title>
    <url>/2023/10/13/ob/newsletter/Newsletter01-20231013/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/10/13/qHMR6zDI529ZsEf.png" alt="Newsletter01.png"></p>
<p>我自己平时有每天阅读文章的习惯，也会将这些文章保存起来并做一些记录，今天在看阮一峰的科技爱好者周刊时突然想到我也可以将这些看过的觉得不错的内容分享出来。<br><img src="https://s2.loli.net/2023/10/13/TaQZ2MyX4xEIedR.png" alt="image.png"></p>
<p>顺便也可以让大伙参与留下自己觉得不错的内容，互相学习。</p>
<span id="more"></span>

<p>以下便是第一期的内容：</p>
<h1 id="Istio-中的负载均衡详解及多集群路由实践-🌟🌟🌟"><a href="#Istio-中的负载均衡详解及多集群路由实践-🌟🌟🌟" class="headerlink" title="Istio 中的负载均衡详解及多集群路由实践 🌟🌟🌟"></a><a href="https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/">Istio 中的负载均衡详解及多集群路由实践</a> 🌟🌟🌟</h1><p>1. 介绍了客户端负载均衡和服务端负载均衡的特点和应用场景。<br>2. 引申出 Istio 使用 Envoy 做客户端负载均衡的方案。<br>3. 介绍 Istio 支持的一些负载均衡算法。<br>4. 如何为具体的服务配置负载均衡，以及如何编写 <code>DestinationRule</code> <code>和VirtualService</code></p>
<h1 id="理解-gRPC-协议🌟🌟🌟🌟"><a href="#理解-gRPC-协议🌟🌟🌟🌟" class="headerlink" title="理解 gRPC 协议🌟🌟🌟🌟"></a><a href="https://taoshu.in/grpc.html">理解 gRPC 协议</a>🌟🌟🌟🌟</h1><p>1. 首先是介绍了 JSON 编码的缺点，可读性高，但性能差。<br>2. PB 性能好，但可读性差，同时还需要配套工具，比如 .proto 格式 IDL 文件来做额外的接口描述。<br>3. 接口请求是底层依然是 http 协议，不过是 http&#x2F;2 协议，但是请求的映射是直接使用 .proto 文件的描述。<br>4. 消息格式描述了消息体前有五个字节，第一个字节描述了是否压缩，后续四个字节描述了消息大小。<br>5. 因为是 stream 协议的关系，才加了这五个字节，因为每次请求都是同一个连接，为了要区分不同的请求就需要在这五个字节来区分了。</p>
<h1 id="Protocol-Buffers-编码🌟🌟🌟🌟"><a href="#Protocol-Buffers-编码🌟🌟🌟🌟" class="headerlink" title="Protocol Buffers 编码🌟🌟🌟🌟"></a><a href="https://taoshu.in/pb-encoding.html">Protocol Buffers 编码</a>🌟🌟🌟🌟</h1><blockquote>
<p>配合上一篇一起阅读更加</p>
</blockquote>
<p>详细讲解了 PB 编码的原理。<br>1. 定长数据都比较简单，主要是解决变长字符串的问题。<br>2. 以 <code>websocket</code> 为例，<code>websocket</code> 的是三挡变速，而 PB 引入了  VarInts 实现了无级变速，<strong>但前提是字段不能太多</strong>。<br>3. 使用了 Tag 代替了字段名，但坏处就是解码必须需要 PB 文件，也就是需要通过 PB 文件生成目标语言。<br>4. 同时 Tag 也不能更改，更改后解码端得同步更新。</p>
<p><a href="https://careercutler.substack.com/p/the-top-7-software-engineering-workflow?ref=dailydev"># The top 7 software engineering workflow tips I wish I knew earlier 🧰</a>🌟🌟🌟🌟</p>
<blockquote>
<p>作者使用多年的提高工作效率的七个习惯<br>1. Git 相关，别名，我觉得对我来说是自动补全+历史记录更好用<br>2. 编码相关，别直接使用查找，可以多使用 IDE 快捷键+AI 编程<br>3. 记录学到的知识，比如 Notion，现在我使用 Obsidian<br>4. 使用 Todo 记录自己的灵感，脑子不是拿来存储这些东西的，是拿来做创造力相关的事情（这个我也是使用的 Obsidian 插件 Memos）。<br>5. 可视化沟通，比如使用截图 App，写文档等。<br>6. 使用密码 App，比如 1Password<br>7. 使用窗口管理 App</p>
</blockquote>
<h1 id="conc：Go-语言的并发工具库🌟🌟🌟🌟"><a href="#conc：Go-语言的并发工具库🌟🌟🌟🌟" class="headerlink" title="conc：Go 语言的并发工具库🌟🌟🌟🌟"></a><a href="https://github.com/sourcegraph/conc">conc</a>：Go 语言的并发工具库🌟🌟🌟🌟</h1><blockquote>
<p>Better structured concurrency for go</p>
</blockquote>
<p>这是项目的介绍，简单来说就是封装了一些使用  goroutine 的常用操作：</p>
<ul>
<li>使用 <code>conc.WaitGroup</code> 替代标准的 <code>sync.WaitGroup</code>，并提供了安全运行的特性，不用担心 panic。</li>
<li>使用 <code>pool.ResultPool</code> 可以拿到执行的结果，<code>Javaer</code> 是不是似曾相识。</li>
<li><code>iter.Map/iter.ForEach</code> 可以直接并发 Map 或者是迭代 slice。</li>
</ul>
<p><img src="https://s2.loli.net/2023/10/13/iwhN8qW5MmpXfQV.png" alt="image.png"><br>这里举了个例子，如果我们想要写出一个安全的 <code>goroutine</code> 程序，大概需要写左边那么多的代码，而使用 <code>conc</code> 会简单很多，也更加易读。</p>
<p>其实从这里就不难看出，<code>conc</code> 只是将这些代码封装好了，感兴趣的也可以看看源码，代码不多，很快就可以看完。</p>
<blockquote>
<p>以上内容和评分纯主观参考，均没有使用类似于 ChatGPT 这类 AI 工具进行总结，绝对是传统人肉阅读归纳，匠心工艺。</p>
<p>上榜文章都很不错，推荐大家去阅读原文。</p>
</blockquote>
<p>文章链接：</p>
<ul>
<li><a href="https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/">https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/</a></li>
<li><a href="https://github.com/sourcegraph/conc">https://github.com/sourcegraph/conc</a></li>
<li><a href="https://taoshu.in/pb-encoding.html">https://taoshu.in/pb-encoding.html</a></li>
<li><a href="https://taoshu.in/grpc.html">https://taoshu.in/grpc.html</a></li>
<li><a href="https://careercutler.substack.com/p/the-top-7-software-engineering-workflow?ref=dailydev">https://careercutler.substack.com/p/the-top-7-software-engineering-workflow?ref=dailydev</a></li>
</ul>
]]></content>
      <categories>
        <category>OB</category>
        <category>Newsletter</category>
      </categories>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
</search>
