<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverJie&#39;s Blog</title>
  
  <subtitle>baller</subtitle>
  <link href="http://crossoverjie.top/atom.xml" rel="self"/>
  
  <link href="http://crossoverjie.top/"/>
  <updated>2023-09-04T13:33:36.686Z</updated>
  <id>http://crossoverjie.top/</id>
  
  <author>
    <name>crossoverJie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k8s 入门到实战--部署应用到 k8s</title>
    <link href="http://crossoverjie.top/2023/08/31/ob/k8s-0-start/"/>
    <id>http://crossoverjie.top/2023/08/31/ob/k8s-0-start/</id>
    <published>2023-08-31T14:42:32.000Z</published>
    <updated>2023-09-04T13:33:36.686Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/04/ymUpcXZrxfNsT91.png" alt="k8s 入门到实战 01.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近这这段时间更新了一些 k8s 相关的博客和视频，也收到了一些反馈；大概分为这几类：</p><ul><li>公司已经经历过服务化改造了，但还未接触过云原生。</li><li>公司部分应用进行了云原生改造，但大部分工作是由基础架构和运维部门推动的，自己只是作为开发并不了解其中的细节，甚至 k8s 也接触不到。</li><li>还处于比较传统的以虚拟机部署的传统运维为主。</li></ul><p>其中以第二种占大多数，虽然公司进行了云原生改造，但似乎和纯业务研发同学来说没有太大关系，自己工作也没有什么变化。</p><p>恰好我之前正好从业务研发的角度转换到了基础架构部门，两个角色我都接触过，也帮助过一些业务研发了解公司的云原生架构；</p><p>为此所以我想系统性的带大家以<strong>研发</strong>的角度对 k8s 进行实践。</p><p>因为 k8s 部分功能其实是偏运维的，对研发来说优先级并不太高；<br>所以我不太会涉及一些 k8s 运维的知识点，比如安装、组件等模块；主要以我们日常开发会使用到的组件讲起。</p><h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul><li>部署应用到 k8s</li><li>跨服务调用</li><li>集群外部访问</li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><ul><li>如何使用配置</li><li>服务网格实战</li></ul><h2 id="运维你的应用"><a href="#运维你的应用" class="headerlink" title="运维你的应用"></a>运维你的应用</h2><ul><li>应用探针</li><li>滚动更新与回滚</li><li>优雅采集日志</li><li>应用可观测性<ul><li>指标可视化</li></ul></li></ul><h2 id="k8s-部署常见中间件"><a href="#k8s-部署常见中间件" class="headerlink" title="k8s 部署常见中间件"></a>k8s 部署常见中间件</h2><ul><li>helm 一键部署</li><li>编写 Operator 自动化应用生命周期</li></ul><p><img src="https://s2.loli.net/2023/09/02/BtYcF6jp8u3nzJs.png" alt="image.png"><br>这里我整理了一下目录，每个章节都有博客+视频配合观看，大家可以按照喜好选择。</p><p>因为还涉及到了视频，所以只能争取一周两更，在两个月内全部更新完毕。</p><p>根据我自己的经验，以上内容都掌握的话对 k8s 的掌握会更进一步。</p><h1 id="部署应用到-k8s"><a href="#部署应用到-k8s" class="headerlink" title="部署应用到 k8s"></a>部署应用到 k8s</h1><p>首先从第一章【部署应用到 k8s】开始，我会用 Go 写一个简单的 Web 应用，然后打包为一个 Docker 镜像，之后部署到 k8s 中，并完成其中的接口调用。</p><h2 id="编写应用"><a href="#编写应用" class="headerlink" title="编写应用"></a>编写应用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   http.HandleFunc(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">      log.Println(<span class="string">&quot;ping&quot;</span>)  </span><br><span class="line">      fmt.Fprint(w, <span class="string">&quot;pong&quot;</span>)  </span><br><span class="line">   &#125;)  </span><br><span class="line">  </span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, <span class="literal">nil</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 应用非常简单就是提供了一个 <code>ping</code>  接口，然后返回了一个 <code>pong</code>.</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一阶段：编译 Go 程序  </span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.19</span> AS dependencies  </span><br><span class="line"><span class="keyword">ENV</span> GOPROXY=https://goproxy.cn,direct  </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/app  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> go.mod .  </span></span><br><span class="line"><span class="comment">#COPY ../../go.sum .  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=ssh go mod download  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 第二阶段：构建可执行文件  </span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.19</span> AS builder  </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/app  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .  </span></span><br><span class="line"><span class="comment">#COPY --from=dependencies /go/pkg /go/pkg  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 第三阶段：部署  </span></span><br><span class="line"><span class="keyword">FROM</span> debian:stable-slim  </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y curl  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /go/src/app/k8s-combat /go/bin/k8s-combat  </span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/go/bin:$&#123;PATH&#125;&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 启动 Go 程序  </span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;k8s-combat&quot;</span>]</span></span><br></pre></td></tr></table></figure><p> 之后编写了一个 <code>dockerfile</code> 用于构建 <code>docker</code> 镜像。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">docker:  </span></span><br><span class="line">   @echo <span class="string">&quot;Docker Build...&quot;</span>  </span><br><span class="line">   docker build . -t crossoverjie/k8s-combat:v1 &amp;&amp; docker image push crossoverjie/k8s-combat:v1</span><br></pre></td></tr></table></figure><p>使用 <code>make docker</code>  会在本地构建镜像并上传到 <code>dockerhub</code></p><h2 id="编写-deployment"><a href="#编写-deployment" class="headerlink" title="编写 deployment"></a>编写 deployment</h2><p>下一步便是整个过程中最重要的环节了，也是唯一和 k8s 打交道的地方，那就是编写 deployment。</p><iframe src="//player.bilibili.com/player.html?aid=702346697&bvid=BV1Cm4y1n7yG&cid=1235124452&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>在之前的视频《一分钟了解 k8s》中讲过常见的组件：<br><img src="https://s2.loli.net/2023/09/04/hrOUSVsmP2KkNlC.png" alt="image.png"></p><p>其中我们最常见的就是 deployment，通常用于部署无状态应用；现在还不太需要了解其他的组件，先看看 deployment 如何编写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">  <span class="attr">template:</span>  </span><br><span class="line">    <span class="attr">metadata:</span>  </span><br><span class="line">      <span class="attr">labels:</span>  </span><br><span class="line">        <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">    <span class="attr">spec:</span>  </span><br><span class="line">      <span class="attr">containers:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">          <span class="attr">image:</span> <span class="string">crossoverjie/k8s-combat:v1</span>  </span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span>  </span><br><span class="line">          <span class="attr">resources:</span>  </span><br><span class="line">            <span class="attr">limits:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">300Mi</span>  </span><br><span class="line">            <span class="attr">requests:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;0.1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">30Mi</span></span><br></pre></td></tr></table></figure><p>开头两行的 <code>apiVersion</code>  和 <code>kind</code> 可以暂时不要关注，就理解为 deployment 的固定写法即可。</p><p>metadata：顾名思义就是定义元数据的地方，告诉 <code>Pod</code> 我们这个 <code>deployment</code> 叫什么名字，这里定义为：<code>k8s-combat</code></p><p>中间的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat</span></span><br></pre></td></tr></table></figure><p>也很容易理解，就是给这个 <code>deployment</code> 打上标签，通常是将这个标签和其他的组件进行关联使用才有意义，不然就只是一个标签而已。</p><blockquote><p>标签是键值对的格式，key, value 都可以自定义。</p></blockquote><p>而这里的  <code>app: k8s-combat</code> 便是和下面的 spec 下的 selector 选择器匹配，表明都使用  <code>app: k8s-combat</code>  进行关联。</p><p>而 template 中所定义的标签也是为了让选择器和 template 中的定义的 Pod 进行关联。</p><blockquote><p>Pod 是 k8s 中相同功能容器的分组，一个 Pod 可以绑定多个容器，这里就只有我们应用容器一个了；后续在讲到 istio 和日志采集时便可以看到其他的容器。</p></blockquote><p>template 中定义的内容就很容易理解了，指定了我们的容器拉取地址，以及所占用的资源(<code>cpu/ memory</code>)。</p><p><code>replicas: 1</code>：表示只部署一个副本，也就是只有一个节点的意思。</p><h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><p>之后我们使用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f deployment/deployment.yaml</span><br></pre></td></tr></table></figure><blockquote><p>生产环境中往往会使用云厂商所提供的 k8s 环境，我们本地可以使用 <a href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a> minikube 来模拟。</p></blockquote><p>就会应用这个 deployment 同时将容器部署到 k8s 中，之后使用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure><blockquote><p> 在后台 k8s 会根据我们填写的资源选择一个合适的节点，将当前这个 Pod 部署过去。</p></blockquote><p> 就会列出我们刚才部署的 Pod:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ kubectl get pod</span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">k8s-combat-57f794c59b-7k58n         1/1     Running   0          17h</span><br></pre></td></tr></table></figure><p>我们使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it k8s-combat-57f794c59b-7k58n  bash</span><br></pre></td></tr></table></figure><p>就会进入我们的容器，这个和使用 docker 类似。</p><p>之后执行 curl 命令便可以访问我们的接口了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-combat-57f794c59b-7k58n:/# curl http://127.0.0.1:8081/ping</span><br><span class="line">pong</span><br><span class="line">root@k8s-combat-57f794c59b-7k58n:/#</span><br></pre></td></tr></table></figure><p>这时候我们再开一个终端执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ kubectl logs -f k8s-combat-57f794c59b-7k58n</span><br><span class="line">2023/09/03 09:28:07 ping</span><br></pre></td></tr></table></figure><p>便可以打印容器中的日志，当然前提是应用的日志是写入到了标准输出中。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是这一章节的主要内容，重点就是将我们应用程序员打包为 docker 镜像后上传到镜像仓库，再配置好 deployment 由 k8s 进行调度运行。</p><p>下一章主要会涉及服务内部的调用，感兴趣的朋友可以先关注起来。</p><p>#Blog #K8s </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/04/ymUpcXZrxfNsT91.png&quot; alt=&quot;k8s 入门到实战 01.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/k8s/"/>
    
    
    <category term="Go" scheme="http://crossoverjie.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>使用 SQL 的方式查询消息队列数据以及踩坑指南</title>
    <link href="http://crossoverjie.top/2023/08/30/ob/Pulsar-SQL/"/>
    <id>http://crossoverjie.top/2023/08/30/ob/Pulsar-SQL/</id>
    <published>2023-08-30T01:31:53.000Z</published>
    <updated>2023-08-30T10:06:26.994Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/30/3iz9yqfuSCn18xk.png" alt="Pulsar-sql.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>为了让业务团队可以更好的跟踪自己消息的生产和消费状态，需要一个类似于表格视图的消息列表，用户可以直观的看到发送的消息；同时点击详情后也能查到消息的整个轨迹。</p><blockquote><p> 消息列表<br><img src="https://s2.loli.net/2023/08/02/l9uvSnqAOxfPer7.png" alt="20230802234405.png"></p></blockquote><span id="more"></span><blockquote><p>点击详情后查看轨迹<br><img src="https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png" alt="20230802234058.png"></p></blockquote><h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p>由于 <code>Pulsar</code> 并没有关系型数据库中表的概念，所有的数据都是存储在 <code>Bookkeeper</code> 中，为了模拟使用 SQL 查询的效果 Pulsar 提供了 <code>Presto</code> (现在已经更名为 <code>Trino</code>)的插件。</p><blockquote><p>Trino 是一个分布式的 SQL 查询引擎，它也提供了插件能力，如果我们想通过 SQL 从自定义数据源查询数据时，基于它的 SPI 编写一个插件是很方便的。</p></blockquote><p>这样便可以类似于查询数据库一样查询 <code>Pulsar</code> 数据：<br><img src="https://s2.loli.net/2023/08/30/1YEtorbwaZAXylL.png" alt="image.png"></p><hr><p><img src="https://s2.loli.net/2023/08/30/u6gc3YxvH94ZDPG.png" alt="image.png"><br>Pulsar 插件的运行流程如上图所示：</p><ul><li>启动的时候通过 <code>Pulsar-Admin</code> 接口获取一些元数据，比如 Scheme，topic 分区信息等。</li><li>然后会创建一个只读的 Bookkeeper 客户端，用于获取数据。</li><li>之后根据 SQL 条件过滤数据即可。</li></ul><p>相关代码：<br><img src="https://s2.loli.net/2023/08/30/vr7ED6BYgOsoqxz.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/30/Np2XD7T9cJAwxQC.png" alt="image.png"></p><h1 id="使用-Pulsar-SQL"><a href="#使用-Pulsar-SQL" class="headerlink" title="使用 Pulsar-SQL"></a>使用 Pulsar-SQL</h1><p><img src="https://s2.loli.net/2023/08/30/UBqocsjFvC2yXEe.png" alt="image.png"></p><p>使用起来也很简单，官方提供了两个命令：</p><ul><li>sql-worker: 会启动一个 trino 服务端同时运行了 Pulsar 插件</li><li>sql: 就是一个 SQL 命令行终端。</li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>自己在本地运行的时候自然是没问题，可是一旦想在生产运行，同时如果你的 <code>Pulsar</code> 集群是运行再 <code>k8s</code> 环境中时就会碰到一些问题。</p><h3 id="无法使用现有-Trino-集群"><a href="#无法使用现有-Trino-集群" class="headerlink" title="无法使用现有 Trino 集群"></a>无法使用现有 Trino 集群</h3><p>首先第一个问题是如果生产环境已经有了一个 <code>Trino</code> 集群想要复用的时候就会碰到问题，常规流程是将 <code>Pulsar</code> 的插件复制到 <code>Trino</code> 的 <code>Plugin</code> 目录，然后重启 <code>Trino</code> 后就能使用该插件。</p><p>当然社区也是支持这么做的：<br><img src="https://s2.loli.net/2023/08/30/RqtIvwy5HNsr27M.png" alt="image.png"><br>但是当我将 Pulsar-plugin 复制到 Trino 中运行的时候却失败了，整体的流程可以参考这个 issue：<br><a href="https://github.com/apache/pulsar/discussions/20941">https://github.com/apache/pulsar/discussions/20941</a></p><p>简单来说 <code>Trino</code> 的官方镜像和 <code>pulsar-plugin</code> 并不能兼容，这个问题直接影响到我们是否可以在生产环境使用它。</p><p>但是手动编译出来的 <code>Trino</code> 服务和插件是兼容的，可以直接运行。</p><p><img src="https://s2.loli.net/2023/08/30/MswBlVXi12DICr9.png" alt="image.png"></p><p>因此我只能在本地编译出 Trino 服务端和 <code>pulsar-plugin</code> 然后打包成一个镜像来运行了，当然这样的坏处就是无法利用到我们现有的 <code>Trino</code> 集群，又得重新部署一个了。</p><p><img src="https://s2.loli.net/2023/08/30/vG83bleTf1EcCPp.png" alt="image.png"></p><p>流程也比较麻烦：</p><ul><li>首先是本地编译 <code>Pulsar-SQL</code> 模块</li><li>将生成物复制到当前目录</li><li>执行 <code>make docker</code> 打出 docker 镜像并上传到私服</li><li>再执行 <code>kubectl</code> 将 trino 部署到 <code>k8s</code> 环境中</li></ul><p>整个流程做下来加上和社区的沟通，更加确定这个功能应该是很少有人在生产环境使用的，毕竟第一个坑就很麻烦，更别提后续的问题了😂。</p><h3 id="Presto-插件不支持-AuthToken"><a href="#Presto-插件不支持-AuthToken" class="headerlink" title="Presto 插件不支持 AuthToken"></a>Presto 插件不支持 AuthToken</h3><p>第二个问题也是个深坑，当我把 Trino 部署好查询数据的时候直接抛了一个调用 <code>pulsar-admin</code>  接口连接超时的异常。</p><p>结果排查了半天发现原来是 <code>pulsar-plugin</code> 里没有提供 <code>JWT</code> 的验证方式，而我们的 Pulsar 集群恰好是打开了 <code>JWT</code> 验证的。</p><p>为此我只能先在本地修复了这个问题，同时也提交了 PR，预计会在下一个大版本合并吧：<br><a href="https://github.com/apache/pulsar/pull/20860">https://github.com/apache/pulsar/pull/20860</a></p><h3 id="新创建的-topic-查询失败"><a href="#新创建的-topic-查询失败" class="headerlink" title="新创建的 topic 查询失败"></a>新创建的 topic 查询失败</h3><p>第二个问题是当查询一个新创建的 topic 时，客户端会直接 block，相关的复现流程在这里：<br><a href="https://github.com/apache/pulsar/issues/20910">https://github.com/apache/pulsar/issues/20910</a></p><p><img src="https://s2.loli.net/2023/08/30/nYestcQqRax1NVv.png" alt="image.png"></p><p>这个问题还好，不是很致命，是我在本地测试的时候无意间发现的。</p><p>本地我已经修复了，后面也提交了一个 PR，目前还在讨论中：<br><a href="https://github.com/apache/pulsar/pull/20911">https://github.com/apache/pulsar/pull/20911</a></p><h3 id="查询消息会丢失最后一条"><a href="#查询消息会丢失最后一条" class="headerlink" title="查询消息会丢失最后一条"></a>查询消息会丢失最后一条</h3><p>这个问题也不是很严重，数据量少的时候会发现，就是在指定了消息发送时间的查询条件时，最后一条消息会被过滤掉，相关 issue 在这里：<br><a href="https://github.com/apache/pulsar/issues/20919">https://github.com/apache/pulsar/issues/20919</a><br><img src="https://s2.loli.net/2023/08/30/MPamvyduxrTZRkY.png" alt="image.png"><br>这个我只是定位到了原因，但不太清楚 为什么要这么做(-1)，影响也不是很大，就放在这里搁置了。</p><h3 id="Schema-不兼容"><a href="#Schema-不兼容" class="headerlink" title="Schema 不兼容"></a>Schema 不兼容</h3><p>最后发现的一个问题是我们线上某些 topic 查询数据的时候会抛出 <code>Not a record: &quot;string&quot;</code>的异常，但只是部分 topic，也排查了很久，整个源码中没有任何一个地方有这个异常。</p><p><a href="!%5B%5D(https://s2.loli.net/2023/08/30/UBl6OPGzASnfqT2.png)">https://github.com/apache/pulsar/issues/20945</a></p><p><img src="https://s2.loli.net/2023/08/30/UBl6OPGzASnfqT2.png" alt="image.png"></p><p>根本原因是生产者生成的 schema 有问题，类型已经是 JSON 了，但是 schema 却是 string，这样导致 <code>pulsar-plugin</code>  在反序列化 schema 的时候抛出了异常，由于是 pb 反序列化抛出的异常，所以源码中都搜索不到。</p><blockquote><p>没有问题的 topic 使用了正确的 schema</p></blockquote><p>后续我也在本地修复了这个问题，当抛出异常后就将 schema 降级为基本类型进行解析。<br><img src="https://s2.loli.net/2023/08/30/XZfWG2EYHpj5QJb.png" alt="image.png"></p><p>不过本质问题还是客户端使用有误，如果对 <code>schema</code> 理解不准确的话还是建议使用 <code>byte[]</code> 吧，这样至少兼容性不会有问题。<br>相关 PR：<br><a href="https://github.com/apache/pulsar/pull/20955">https://github.com/apache/pulsar/pull/20955</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Pulsar-SQL</code> 是一个非常有用的功能，只是我们使用过程中确实发现了一些问题，大部分都已经修复了；<br>希望对后续使用该功能的朋友有所帮助。<br>#Pulsar </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/30/3iz9yqfuSCn18xk.png&quot; alt=&quot;Pulsar-sql.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;为了让业务团队可以更好的跟踪自己消息的生产和消费状态，需要一个类似于表格视图的消息列表，用户可以直观的看到发送的消息；同时点击详情后也能查到消息的整个轨迹。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 消息列表&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/02/l9uvSnqAOxfPer7.png&quot; alt=&quot;20230802234405.png&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="SQL" scheme="http://crossoverjie.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>VictoriaLogs：一款超低占用的 ElasticSearch 替代方案</title>
    <link href="http://crossoverjie.top/2023/08/23/ob/VictoriaLogs-Intro/"/>
    <id>http://crossoverjie.top/2023/08/23/ob/VictoriaLogs-Intro/</id>
    <published>2023-08-23T07:46:25.000Z</published>
    <updated>2023-08-24T03:14:32.390Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/23/t5soejn8vw1aZil.png" alt="image.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间我们想实现 <code>Pulsar</code> 消息的追踪流程，追踪实现的效果图如下：<br><img src="https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png" alt="image.png"></p><p>实现其实比较简单，其中最重要的就是如何存储消息。</p><blockquote><p>消息的读取我们是通过 Pulsar 自带的 BrokerInterceptor 实现的，对这个感兴趣的朋友后面会单独做一个分享。</p></blockquote><span id="more"></span><p>根据这里的显示内容我们大概需要存储这些信息：</p><ul><li>客户端地址</li><li>消息发布时间</li><li>分发消费者、订阅者名称</li><li>ACK 消费者、订阅者名称</li><li>消息 ID<br>最终捋了下：<br><img src="https://s2.loli.net/2023/08/23/MWbVcu6dm1NfaAB.png" alt="image.png"></li></ul><p>都以两个 <code>consumer</code> 计算：<br>一条消息占用内存：<code>140+ 535*2 + 536*2 =2282byte</code><br>存储三天：<code>TPS * 86400 * 3</code>&#x3D;<code>TPS*259200</code> 条<br>总存储：<br><code>2282*TPS*259200≈ 百GB</code></p><p>根据我们的 <code>TPS</code> 计算，三天的大概会使用到 上百 G 的存储，这样首先就排除了 <code>Redis</code> 这种内存型数据库。</p><p>同样的换成 <code>MySQL</code> 存储也不划算，因为其实这些数据并不算那么重要。</p><p>做了几个技术选型都不太满意，不是资源开销太大就是没有相关的运维经验。</p><p>后面在领导的提醒下，我们使用的 <code>VictoriaMetrics</code> 开源了一个 <code>VictoriaLogs</code>，虽然当时的版本还是 <code>0.1.0</code>，使用过他们家 Metrics 的应该都会比较信任他们的技术能力，所以就调研了一下。</p><p>具体的信息可以查看官方文档：<br><a href="https://docs.victoriametrics.com/VictoriaLogs/">https://docs.victoriametrics.com/VictoriaLogs/</a></p><p><img src="https://s2.loli.net/2023/08/23/8LDNOGEC6Aslvzn.png" alt="image.png"></p><p>简单来说就是它也是一个日志存储数据库，并且有着极低的资源占有率，相对于 <code>ElasticSearch</code> 来说内存、磁盘、CPU 都是几十倍的下降率。</p><p><img src="https://s2.loli.net/2023/08/23/U9v1HCgRDtLsdif.png" alt="image.png"></p><p>通过官方的压测对比图会发现确实在各方面对 ES 都是碾压。<br><img src="https://s2.loli.net/2023/08/23/3Epxdzie8q5tVmY.png" alt="image.png"></p><p>官方宣传的第一反应是不能全信，于是我自己压测了一下，果然 CPU 内存 磁盘的占用都是极低的。</p><blockquote><p> 同时也发现运维部署确实简单，直接一个 helm install 就搞定，就是一个二进制文件，不会依赖第二个组件。</p></blockquote><p>按照刚才同样的数据存储三天，只需要不到 6G 的磁盘空间，我们生产环境已经平稳运行一段时间了。<br><img src="https://s2.loli.net/2023/08/23/kzrxA89EeNnQ7Ro.png" alt="image.png"><br>因为我们是批量写入数据的，所以在最高峰 20K 的 <code>TPS</code> 下 <code>CPU</code> 使用不到 0.1 核，内存使用最高 <code>120M</code>，这点确实是对 ES 碾压了。</p><p><img src="https://s2.loli.net/2023/08/23/wn2BduNX63PyYV9.png" alt="image.png"><br>磁盘占用也是非常少。</p><p>这些有点得归功于它有些的压缩、编解码算法，以及 <code>Golang</code>  带来的相对于 <code>Java</code> 的极低资源占用。</p><h1 id="还存在的问题"><a href="#还存在的问题" class="headerlink" title="还存在的问题"></a>还存在的问题</h1><p>如果一切都这么完美的话那 <code>VictoriaLogs</code>  确实也太变态了， 自然他也有一些不太完美的地方。</p><h2 id="分词功能有限"><a href="#分词功能有限" class="headerlink" title="分词功能有限"></a>分词功能有限</h2><p>首先第一个是分词功能有限，只能做简单的搜索，无法做到类似于 ES 的各种分词，插件当然也别想了。</p><h2 id="不支持集群"><a href="#不支持集群" class="headerlink" title="不支持集群"></a>不支持集群</h2><p>当前版本不支持集群部署，也就是无法横向扩展了；不过幸好他的的单机性能已经非常强了。</p><p>这也是目前阶段部署简单的原因。</p><h2 id="过期时间无法混用"><a href="#过期时间无法混用" class="headerlink" title="过期时间无法混用"></a>过期时间无法混用</h2><p><code>VictoriaLogs</code> 支持为数据配置过期时间自动删除，有点类似于 Redis，它会在后台启动一个协程定期判断数据是否过期，但只能对所有数据统一设置。</p><p>比如我想在 <code>VictoriaLogs</code> 中存放两种不同类型的数据，同时他们的过期删除时间也不相同；比如一个是三天删除，一个是三月后删除。</p><p>这样的需求目前是无法实现的，只能部署两个 <code>VictoriaLogs</code>.</p><h2 id="默认无法查询所有字段"><a href="#默认无法查询所有字段" class="headerlink" title="默认无法查询所有字段"></a>默认无法查询所有字段</h2><p><img src="https://s2.loli.net/2023/08/24/2Wk6VUXQoEYvZJ1.png" alt="image.png"></p><p>由于 <code>VictoriaLogs</code>  可以存储非结构化数据，默认情况下只能查询内置的三个字段，我们自定义的字段目前没法自动查询，需要我们手动指定。</p><p>这个倒不是致命问题，只是使用起来稍微麻烦一些；社区也有一些反馈，相信不久就会优化该功能。<br><img src="https://s2.loli.net/2023/08/24/XYxz8tTDmw6arf9.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/24/pgQCPsLvXfMc7nF.png" alt="image.png"></p><ul><li><a href="https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4780">https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4780</a></li><li><a href="https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4513">https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4513</a></li></ul><h2 id="没有官方-SDK"><a href="#没有官方-SDK" class="headerlink" title="没有官方 SDK"></a>没有官方 SDK</h2><p><img src="https://s2.loli.net/2023/08/24/bXPKRIy7Ojf1elE.png" alt="image.png"></p><p>这也是个有了更好的一个功能，目前只能根据 REST API 自己编写。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当前我们只用来存储 <code>Pulsar</code> 链路追踪数据，目前看来非常稳定，各方面资源占用极少；所以后续我们会陆续讲一些日志类型的数据迁移过来，比如审计日志啥的。</p><p>之后再逐步完善功能后，甚至可以将所有应用存放在 <code>ElasticSeach</code> 中的日志也迁移过来，这样确实能省下不少资源。</p><p>总得来说 <code>VictoriaLogs</code>  资源占用极少，如果只是拿来存储日志相关的数据，没有很强的分词需求那它将非常合适。</p><p>截止到目前最新版也才 <code>0.3.0</code> 还有很大的进步空间，有类似需求的可以持续关注。<br>#Blog #Vlogs #CloudNative </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/23/t5soejn8vw1aZil.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间我们想实现 &lt;code&gt;Pulsar&lt;/code&gt; 消息的追踪流程，追踪实现的效果图如下：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;实现其实比较简单，其中最重要的就是如何存储消息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;消息的读取我们是通过 Pulsar 自带的 BrokerInterceptor 实现的，对这个感兴趣的朋友后面会单独做一个分享。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="VictoriaLogs" scheme="http://crossoverjie.top/categories/VictoriaLogs/"/>
    
    
    <category term="CloudNative" scheme="http://crossoverjie.top/tags/CloudNative/"/>
    
  </entry>
  
  <entry>
    <title>k8s 常见面试题 01</title>
    <link href="http://crossoverjie.top/2023/08/17/ob/k8s-question-01/"/>
    <id>http://crossoverjie.top/2023/08/17/ob/k8s-question-01/</id>
    <published>2023-08-17T14:33:43.000Z</published>
    <updated>2023-08-17T15:17:11.003Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/17/hnWciw54ml6oPdg.jpg"></p><p>前段时间在这个视频中分享了 <a href="https://github.com/bregman-arie/devops-exercises">https://github.com/bregman-arie/devops-exercises</a> 这个知识仓库。</p><iframe src="//player.bilibili.com/player.html?aid=532004472&bvid=BV1Wu411n7U7&cid=1227759877&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>这次继续分享里面的内容，本次主要以 k8s 相关的问题为主。</p><span id="more"></span><h2 id="k8s-是什么，为什么企业选择使用它"><a href="#k8s-是什么，为什么企业选择使用它" class="headerlink" title="k8s 是什么，为什么企业选择使用它"></a>k8s 是什么，为什么企业选择使用它</h2><p>k8s 是一个开源应用，给用户提供了管理、部署、扩展容器的能力，以下几个例子更容易理解：</p><ul><li>你可以将容器运行在不同的机器或节点中，并且可以将一些变化同步给这些容器，简单来说我们只需要编写 <code>yaml</code> 文件，告诉 <code>k8s</code> 我的预期是什么，其中同步变化的过程全部都交给 k8s 去完成。<blockquote><p>其实就是我们常说的声明式 API</p></blockquote></li><li>第二个特点刚才已经提到了，它可以帮我们一键管理多个容器，同步所有的变更。</li><li>可以根据当前的负载调整应用的副本数，负载高就新创建几个应用实例，低就降低几个，这个可以手动或自动完成。</li></ul><h2 id="什么时候使用或者不使用-k8s"><a href="#什么时候使用或者不使用-k8s" class="headerlink" title="什么时候使用或者不使用 k8s"></a>什么时候使用或者不使用 k8s</h2><ul><li>如果主要还是使用物理机这种低级别的基础设施的话，不太建议使用 <code>k8s</code>，这种情况通常是比较传统的业务，没有必要使用 <code>k8s</code>。</li><li>第二种情况是如果是小团队，或者容器规模较小时也不建议使用，除非你想使用 k8s 的滚动发布和自扩容能力，<blockquote><p>不过这些功能运维自己写工具也能实现。</p></blockquote></li></ul><h2 id="k8s-有哪些特性"><a href="#k8s-有哪些特性" class="headerlink" title="k8s 有哪些特性"></a>k8s 有哪些特性</h2><ul><li>是自我修复，<code>k8s</code> 对容器有着健康检测，比如使用启动探针、存活探针等，或者是容器 <code>OOM</code> 后也会重启应用尝试修复。</li><li>自带负载均衡，使用 <code>service</code> 可以将流量自动负载到后续 Pod 中，如果 Pod 提供的是 http 服务这个够用了，但如果是 grpc 这样的长链接，就需要使用 istio 这类服务网格，他可以识别出协议类型，从而做到请求级别的负载均衡。</li><li><code>Operator</code> 自动运维能力：k8s 可以根据应用的运行情况自动调整当前集群的 Pod 数量、存储等，拿 <code>Pulsar</code> 举例，当流量激增后自动新增 <code>broker</code>，磁盘不足时自动扩容等。</li><li>滚动更新能力：当我们发版或者是回滚版本的时候，k8s 会等待新的容器启动之后才会将流量切回来，同时逐步停止老的实例。</li><li>水平扩展能力：可以灵活的新增或者是减少副本的数量，当然也可以自动控制。</li><li>数据加密：使用 <code>secret</code> 可以保存一些敏感的配置或者文件。</li></ul><h2 id="k8s-有着哪些对象"><a href="#k8s-有着哪些对象" class="headerlink" title="k8s 有着哪些对象"></a>k8s 有着哪些对象</h2><p>这个就是考察我们对 <code>k8s</code> 是否是熟悉了，常用的有：</p><ul><li>Pod</li><li>Service</li><li>ReplicationController</li><li>DaemonSet</li><li>namespace</li><li>ConfigMap<br>这个其实知道没有太多作用，主要还是得知道在不同场景如何使用不同的组件。</li></ul><h2 id="哪些字段是必须的"><a href="#哪些字段是必须的" class="headerlink" title="哪些字段是必须的"></a>哪些字段是必须的</h2><p>这个问题我也觉得意义不大，只要写过 <code>yaml</code> 就会知道了，<code>metadata, kind, apiVersion</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">app</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app</span></span><br></pre></td></tr></table></figure><h2 id="kubectl-是什么"><a href="#kubectl-是什么" class="headerlink" title="kubectl 是什么"></a>kubectl 是什么</h2><p>其实就是一个 k8s 的 命令行客户端。</p><h2 id="当你部署应用的时候哪些对象用的比较多"><a href="#当你部署应用的时候哪些对象用的比较多" class="headerlink" title="当你部署应用的时候哪些对象用的比较多"></a>当你部署应用的时候哪些对象用的比较多</h2><ul><li>第一个肯定是 <code>deployment</code>，这应该是最常见的部署方式。</li><li><code>service</code>: 可以将流量负载到 Pod 中。</li><li><code>Ingress</code>: 如果需要从集群外访问 Pod 就得需要 <code>Ingress</code> 然后 配合域名访问。</li></ul><h2 id="为什么没有-k-get-containers-这个命令"><a href="#为什么没有-k-get-containers-这个命令" class="headerlink" title="为什么没有 k get containers 这个命令"></a>为什么没有 <code>k get containers</code> 这个命令</h2><p>这个问题主要是看对 <code>Pod</code> 的理解，因为在 <code>k8s</code> 中 <code>Pod</code> 就是最小的单位了，如果想要访问容器可以在 Pod 中访问。</p><p>我们可以加上 <code>-c</code> 参数进入具体的容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it app -c istio-proxy</span><br></pre></td></tr></table></figure><h2 id="你认为使用使用-k8s-的最佳实践是什么"><a href="#你认为使用使用-k8s-的最佳实践是什么" class="headerlink" title="你认为使用使用 k8s 的最佳实践是什么"></a>你认为使用使用 k8s 的最佳实践是什么</h2><p>这个主要是看日常使用时有没有遇到什么坑了：</p><ul><li>第一个就是要验证 <code>yaml</code> 内容是否正确，这个确实很重要，一旦执行错了后果很严重，比如使用 helm 的时候最好岂容 <code>dry-run</code> 和 <code>debug</code>，先看看生成的 <code>yaml</code> 是否是预期想要的。<blockquote><p>helm upgrade app –dry-run –debug</p></blockquote></li><li>第二个限制资源的使用，比如 CPU 和 内存，这个也很重要，如果不设置一旦应用出现 bug 可能导致整个 k8s 集群都受到影响。</li><li>为 Pod，deployment 指定标签，用于分组。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 资源限制</span></span><br><span class="line"><span class="attr">resources:</span>  </span><br><span class="line">  <span class="attr">limits:</span>  </span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">200m</span>  </span><br><span class="line">    <span class="attr">memory:</span> <span class="string">200Mi</span>  </span><br><span class="line">  <span class="attr">requests:</span>  </span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">100m</span>  </span><br><span class="line">    <span class="attr">memory:</span> <span class="string">100Mi</span></span><br></pre></td></tr></table></figure><blockquote><p>参考来源：<a href="https://github.com/bregman-arie/devops-exercises/blob/master/topics/kubernetes/README.md#kubernetes-101">https://github.com/bregman-arie/devops-exercises/blob/master/topics/kubernetes/README.md#kubernetes-101</a></p></blockquote><p>后续部分内容也有出视频版，强烈建议大家关注我的 B 站或者是视频号：<br><img src="https://s2.loli.net/2023/08/17/joO3wpCAEMtY2yW.jpg" alt="image.png"><br><img src="https://s2.loli.net/2023/08/17/2gcNDC4M3x91Sbh.jpg" alt="image.png"></p><p>#Blog #K8s </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/17/hnWciw54ml6oPdg.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;前段时间在这个视频中分享了 &lt;a href=&quot;https://github.com/bregman-arie/devops-exercises&quot;&gt;https://github.com/bregman-arie/devops-exercises&lt;/a&gt; 这个知识仓库。&lt;/p&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=532004472&amp;bvid=BV1Wu411n7U7&amp;cid=1227759877&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;

&lt;p&gt;这次继续分享里面的内容，本次主要以 k8s 相关的问题为主。&lt;/p&gt;</summary>
    
    
    
    <category term="Interview" scheme="http://crossoverjie.top/categories/Interview/"/>
    
    
    <category term="k8s" scheme="http://crossoverjie.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>新手如何快速参与开源项目</title>
    <link href="http://crossoverjie.top/2023/08/05/ob/novice-contribute-open-source/"/>
    <id>http://crossoverjie.top/2023/08/05/ob/novice-contribute-open-source/</id>
    <published>2023-08-05T05:37:58.000Z</published>
    <updated>2023-08-06T07:04:21.299Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/05/5mXrStCDVHNxF7f.png" alt="image.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开源这件事情在软件开发领域一直是一个高频话题，我们工作中不管是使用到的工具还是第三方库都离不开开源的支持。</p><p>近期由于工作的原因，我需要经常和 <code>Apache Pulsar</code> 社区沟通，同时也会将日常碰到的问题反馈给社区，包括一些 <code>bug</code> ，一些我能修的也是顺带就提了一些 <code>PR</code>。</p><span id="more"></span><p>之前或多或少我也参与过其他的开源社区，但和现在的还是有些许的不同：</p><ul><li>以前我更多的是个人开源项目，偶尔也会有其他开发者向我的仓库贡献代码。</li><li>也参与过其他个人作者或者是社区性质的项目，但流程上没有那么正规或者是<code>标准</code>。</li></ul><p>简单来说就是以前就是小打小闹，<code>Pulsar</code> 毕竟是 <code>Apache</code> 社区的顶级项目，参与的整个流程要求也会比较复杂，当然学到的知识也会更多。</p><p><img src="https://s2.loli.net/2023/08/05/uSRKlvh8q4sTpWj.png" alt="image.png"></p><p><img src="https://s2.loli.net/2023/08/05/DJm145yigIhEvwe.png" alt="image.png"><br>这半年时间大大小小提了十几个 PR ，也逐渐捋清楚了一些上手的方法和套路，所以如果你也想参与开源，但苦于不知道如何入门，看完后希望对你有所帮助。</p><h1 id="为什么参与开源"><a href="#为什么参与开源" class="headerlink" title="为什么参与开源"></a>为什么参与开源</h1><p>首先还是来聊聊参与开源的好处，了解之后也许会让你有路转粉。</p><p>首先最明显的一点就是让你对贡献的这个项目更加深入的了解，我们常常都在面试的时候被问到对 XX 框架的熟悉程度，哪怕你在简历里写的天花乱坠也没有是这个项目  <code>Contributor</code> 更具有说服力。</p><p>其次是沟通交流能力也会得到锻炼，开源社区往往都是以 <code>github issue/PR</code>，或者是 <code>Mailing List</code> 的方式沟通交流，这样的沟通方式和我们常用的微信、QQ 这类及时通讯工具有着本质的区别。</p><p>往往需要我们有了冷静的思考加上清晰的描述才会将自己的观点发布出去，这样不自觉的就会养成自己的总结能力，这个能力对于<code>内容创意内容工作者</code>来说非常重要。</p><p>还有一个更明显的好处就是对个人的能力背书，大家常说的 <code>show me the code</code>，而 <code>GitHub</code> 就是最好的方式。</p><p>当你是某个知名开源项目的 <code>Contributor</code> 甚至是 <code>Committer/PMC</code> 就已经足够证明自己的能力了。</p><h1 id="如何参与"><a href="#如何参与" class="headerlink" title="如何参与"></a>如何参与</h1><p>如何参与呢，其实也很简单，不外乎有以下几种方式（由易到难）：</p><ul><li>一些 <code>typo</code> 类的修复。</li><li>回答社区中用户的问题。</li><li>使用过程中遇到 <code>bug</code>，直接反馈，有兴趣的话最好是自己能修复。</li><li>修复现有 <code>issue</code> 列表中未解决的 <code>bug</code>。</li><li>软件不具备自己需要的功能时提交 <code>feature</code> 提案并实现。</li></ul><p>不管是哪种方式我的建议是在准备贡献之前都应该先看看官方提供的贡献指南，通常在官网就能查看。</p><blockquote><p>即便是最简单的修复 typo，因为越是专业的项目每个 PR 的合并都是严谨的，提前了解后可以避免犯一些基本错误从而影响积极性。</p></blockquote><p>这里我以 <code>Pulsar</code> 为例：<br><img src="https://s2.loli.net/2023/08/05/8TGyjSXChsaoPc6.png" alt="image.png"><br>官网有着详细的贡献指南，包括环境搭建、代码约定、<code>PR/git commit</code> 语义等各种规范。</p><p>这里我重点强调 PR 的语义，一个好的 PR 规范更容易引起社区成员的注意，毕竟我们每一次提交都需要 <code>Committer</code> 的同意才能合并。</p><p><img src="https://s2.loli.net/2023/08/05/gfbEBjc4dXVLPtw.png" alt="image.png"><br>还是以 <code>Pulsar</code> 为例，在提交 PR 前一定得先看看这里的规范要求，不然很可能第一步就会吃瘪。</p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><p>下面讲讲贡献过程中可能会碰到的问题。</p><p>在上面讲到的难度排序中将修复个人 issue 排在了其他 issue 之前了，这是因为往往对自己提交的 bug 更熟悉，而社区其他人反馈的问题大概率会被老手认领。</p><p>加上自己也不熟悉，可能在自己研究复现的过程中就把自己劝退了。</p><h3 id="认领-issue"><a href="#认领-issue" class="headerlink" title="认领 issue"></a>认领 issue</h3><p>这里还有个小技巧，当我们准备修复一个不是自己提交的 issue 时，最好是在评论区让 <code>Committer</code> 将这个任务分配给你，这样社区成员就不会做重复工作了。</p><p><img src="https://s2.loli.net/2023/08/05/KBh1HRd8EyziuQP.png" alt="image.png"><br>类似于这样。</p><p>同时我们在查找可以修复的 <code>issue</code> 时也要注意这个 issue 有没有被认领以及是否有 PR 关联。</p><p><img src="https://s2.loli.net/2023/08/05/pOPybK7lmX1v8oU.png" alt="image.png"></p><p>有时候 <code>issue</code> 并没有被指定但也有相关 <code>PR</code> 在处理该问题了，这时我们就可以过滤掉这个 <code>issue</code>。</p><h3 id="help-want"><a href="#help-want" class="headerlink" title="help want"></a>help want</h3><p><img src="https://s2.loli.net/2023/08/05/QMwDlTWd3iFPU7c.png" alt="image.png"><br>也可以找找带有  <code>help want</code> 标签的 <code>issue</code>，这类问题往往会相对简单，修复起来也更容易。</p><h3 id="社区反馈较慢"><a href="#社区反馈较慢" class="headerlink" title="社区反馈较慢"></a>社区反馈较慢</h3><p>还有一个比较常见的问题是自己提交的 issue 或者是 PR 迟迟没有人处理。</p><p>我们可以先看看这个 issue 对应的代码最近主要是哪些人在维护，这个在 IDE 中配合 <code>GitToolBox</code> 插件就很容易看出来。</p><p><img src="https://s2.loli.net/2023/08/05/ojErZnigXbqFvam.png" alt="image.png"><br>后面的 ID 往往是 <code>PR</code> 号，我们可以通过这个 <code>PR</code> 找到对应的作者，然后尝试在 <code>issue</code> 评论区艾特对方。</p><p>如果依然没有回复，那我们也可以给开发组发送邮件。<br><img src="https://s2.loli.net/2023/08/05/SuT5Fb4wG2BnrV1.png" alt="image.png"><br>如果还是没有回复，比如我这个😂</p><p>那也还有一个办法，就是尝试在社交媒体（GitHub 首页、技术群）上找到 Committer 的微信，直接私聊的方式让对方帮忙推进。<br><img src="https://s2.loli.net/2023/08/05/J8r6lBbhMgziFGv.png" alt="image.png"></p><p>当然也有一些项目长期没有维护了，这种 PR 要做好心里准备，很有可能对方不会理你；这点在国内某个企业的开源项目中比较常见。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说想要做好开源得有耐心和长期坚持，同时给自己带来的好处也是物超所值的，<code>Apache</code> 这类专业的社区我也才参与了半年，后续也会长期坚持下去，也希望哪天可以积累到成为 <code>Committer</code> 后再和大家分享。</p><p>#Pulsar #OpenSource</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/05/5mXrStCDVHNxF7f.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;开源这件事情在软件开发领域一直是一个高频话题，我们工作中不管是使用到的工具还是第三方库都离不开开源的支持。&lt;/p&gt;
&lt;p&gt;近期由于工作的原因，我需要经常和 &lt;code&gt;Apache Pulsar&lt;/code&gt; 社区沟通，同时也会将日常碰到的问题反馈给社区，包括一些 &lt;code&gt;bug&lt;/code&gt; ，一些我能修的也是顺带就提了一些 &lt;code&gt;PR&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenSource" scheme="http://crossoverjie.top/categories/OpenSource/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>从 Pulsar Client 的原理到它的监控面板</title>
    <link href="http://crossoverjie.top/2023/08/03/ob/Pulsar-Client/"/>
    <id>http://crossoverjie.top/2023/08/03/ob/Pulsar-Client/</id>
    <published>2023-08-03T03:47:52.000Z</published>
    <updated>2023-08-02T16:00:12.107Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/02/GipDPSlbycQxqFd.png" alt="image.png"></p><p>#Blog #Pulsar </p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间业务团队偶尔会碰到一些 Pulsar 使用的问题，比如消息阻塞不消费了、生产者消息发送缓慢等各种问题。</p><p>虽然我们有个监控页面可以根据 topic 维度查看他的发送状态，比如速率、流量、消费状态等信息。</p><span id="more"></span><p><img src="https://s2.loli.net/2023/08/02/UNZVawH4QYSu3Ko.png" alt="image.png"></p><p>但也有几个问题：</p><ul><li>无法在应用维度查看他所依赖的所有  topic 的各种状态。</li><li>监控的信息还不够，比如发送&#x2F;消费延迟、发送&#x2F;消费失败等数据。</li></ul><p>总之就是缺少一个全局的监控视角，通过这些指标可以很方便的分析出当时的运行情况。</p><p>基于这个需求经过一段时间的折腾，现在已经上线使用几个月，目前比较稳定，效果图如下：<br><img src="https://s2.loli.net/2023/08/02/byv4RDZnruSjo9h.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/TtufOpwHB86PFhK.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/d21IaNzbFQpnrkA.png" alt="image.png"></p><p>现在就可以在每个应用的监控面板里看到自己使用了哪些 topic，分别的生产消费情况如何。</p><h1 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h1><p>要实现这些功能就得在应用的 <code>metrics</code> 中加入相关的监控信息，但官方的 Java client 是没有暴露出这些指标的。</p><p><img src="https://s2.loli.net/2023/08/02/DlfkQo1Lmt8J7Iq.png" alt="image.png"></p><blockquote><p>但 pulsar-client-go 是自带了这些指标的</p></blockquote><p>由于 <code>SDK</code> 不支持所以只能自己想办法实现了，为此其实有两种实现方案：</p><ul><li>魔改 <code>Java client</code>，在需要监控的地方手动埋点指标。</li><li>由于我们使用了 <code>SkyWalking</code>，所以可以编写插件，以 <code>agent</code> 的方式获取数据、埋点指标。</li></ul><p>不过第一种方案有以下一些问题：</p><ul><li>需要自己维护一个代码分支，还需要定期和官方保持一致，难免会出现代码冲突。</li><li>需要推动业务方进行依赖升级，线上有着几百个应用，推动起来时间太慢。</li></ul><p>第二种方案的好处就不言而喻了：</p><ul><li>升级无感知，只需要在我们的基础镜像中加上插件即可。</li><li>Java client 的版本也更容易统一。</li></ul><h2 id="Client-原理"><a href="#Client-原理" class="headerlink" title="Client 原理"></a>Client 原理</h2><p>但其实不管是哪种方案我们都得熟悉 Java Client 的实现原理，才能知道哪些数据是我们需要重点关注的，可以帮助我们更好的定位问题。</p><p><img src="https://s2.loli.net/2023/08/02/vweWVR8fkJgrSMI.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/S2DNUb768rJRMLm.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/8Byvq4LXtACoIg5.png" alt="image.png"></p><blockquote><p>本文重点不在于此，具体代码就不仔细分析了。</p></blockquote><p>从上图可以看出，如果我们想要监控消费是否存在阻塞的情况，这几个内部队列是需要重点监控的，一旦他们出现堆积，那就会出现消费阻塞。</p><p>其实这些数据都可以通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.apache.pulsar.client.api.ProducerStats</span><br><span class="line">org.apache.pulsar.client.api.ConsumerStats</span><br></pre></td></tr></table></figure><p>这两个接口获取到生产者和消费者的大部分指标，只是这里还有一个小插曲。</p><p>那就是在获取消费者队列大小的时候，获取到的数据一直为空。</p><p>最终经过源码排查，原来是我们大量使用的 <code>messageListener</code> 在获取队列大小时有 bug，导致获取到的数据一直都为 0.</p><p>相关的 issue 和 PR 可以在这两个链接查看，问题原因和修复过程都有具体描述：<br><a href="https://github.com/apache/pulsar/issues/20076">https://github.com/apache/pulsar/issues/20076</a><br><a href="https://github.com/apache/pulsar/pull/20245">https://github.com/apache/pulsar/pull/20245</a></p><blockquote><p>但这个修复得在新版本才能使用，就导致我们现在的监控页面一直显示为空。</p></blockquote><h1 id="开发-SkyWalking-插件"><a href="#开发-SkyWalking-插件" class="headerlink" title="开发 SkyWalking 插件"></a>开发 SkyWalking 插件</h1><p>然后就是开发一个 <code>SkyWalking</code> 的插件了，其实直接使用 SW 开发插件是上手 <code>Java-Agent</code> 比较快的方式。</p><p><code>SW</code> 的 SDK 封装了许多 <code>agent</code> 原生接口，使得开发起来非常容易；当然缺点也有，就是得集成整个 <code>SW</code> 的 <code>agent</code>。</p><p>这里我简单介绍下这个插件的运行流程：<br><img src="https://s2.loli.net/2023/08/02/tW8QSqdU1yZf25A.png" alt="image.png"></p><ul><li>在创建和删除 consumer 的时候维护 consumerPool</li><li>启动一个定时任务，定期从这些 consumer 中获取指标数据。<br><img src="https://s2.loli.net/2023/08/02/ndhi3yH7CzS9FLA.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/WtZNTClh8Y3wj1F.png" alt="image.png"></li></ul><blockquote><p>当消费多分区 topic 时，为了能唯一标志一个 consumer，所以给每个消费者都加了一个 hashcode 的 label。</p></blockquote><p>因为我们所有的 Java 技术栈都是使用的 <code>Prometheus</code> 的包来生成 <code>metrics</code> ，所以该插件也是使用该包生成的数据。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了兼容一些特殊 Java 应用没有该包时会启动报错，所以在初始化插件的时候需要检测当前 <code>classpath</code> 下是否存在该依赖。</p><p><img src="https://s2.loli.net/2023/08/02/IBwdhH9b1tc8aoE.png" alt="image.png"></p><p>这些功能 SW 已经封装好了，对我们来说也是开箱即用。</p><blockquote><p>其实 SW 插件自己也是支持 metrics 的，由于我们只是使用了它的 trace 功能，所以这里就没有使用它的 API。</p></blockquote><p>关于开发一个 SW 插件的流程也比较简单，可以参考官方文档或者是一些现成的插件源码。<br><a href="https://skywalking.apache.org/docs/skywalking-java/next/en/setup/service-agent/java-agent/java-plugin-development-guide/">https://skywalking.apache.org/docs/skywalking-java/next/en/setup/service-agent/java-agent/java-plugin-development-guide/</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有了这个监控面板后，对于 Pulsar 客户端内部的一些运行情况就不再是黑盒了，还可以基于此做一些报警，比如消费堆积、发送延迟过大等。</p><p>当然仅仅只有这个面板依然是不够的，后续我们又开发了可以通过 <code>messageId</code> 查询它的整个生命周期，包括：</p><ul><li>生产者、消费者信息</li><li>消息生产时间</li><li>推送时间</li><li>ack 时间等</li></ul><p><img src="https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png" alt="image.png"></p><p>同时借助与 Pulsar-SQL 的能力，还能以列表的形式展示当前 topic 的消息列表。<br><img src="https://s2.loli.net/2023/08/02/l9uvSnqAOxfPer7.png" alt="image.png"><br>当然在实现这两个功能的同时也踩了不少坑，提了几个 PR ，后面在抽时间做具体的分享。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/02/GipDPSlbycQxqFd.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;#Blog #Pulsar &lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间业务团队偶尔会碰到一些 Pulsar 使用的问题，比如消息阻塞不消费了、生产者消息发送缓慢等各种问题。&lt;/p&gt;
&lt;p&gt;虽然我们有个监控页面可以根据 topic 维度查看他的发送状态，比如速率、流量、消费状态等信息。&lt;/p&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="Metrics" scheme="http://crossoverjie.top/tags/Metrics/"/>
    
  </entry>
  
  <entry>
    <title>使用 ChatGPT 碰到的坑</title>
    <link href="http://crossoverjie.top/2023/07/18/ob/ChatGPT-hole/"/>
    <id>http://crossoverjie.top/2023/07/18/ob/ChatGPT-hole/</id>
    <published>2023-07-18T03:47:52.000Z</published>
    <updated>2023-07-18T06:18:02.072Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/07/14/YtqXVJmfNokCwyE.png"></p><p>最近在使用 ChatGPT 的时候碰到一个小坑，因为某些特殊情况我需要使用 <code>syslog</code> 向 <code>logbeat</code> 中发送日志。</p><p>由于这是一个比较古老的协议，确实也没接触过，所以就想着让 ChatGPT 帮我生成个例子。</p><span id="more"></span><p>原本我已经在  Go  中将这个流程跑通，所以其实只需要将代码转换为 Java 就可以了，这个我还是很信任 <code>ChatGPT</code> 的；</p><blockquote><p>现在我挺多结构化数据的转换都交给了 ChatGPT，省去了不少小工具。</p></blockquote><p>于是便有了这段对话：<br><img src="https://s2.loli.net/2023/07/17/6MHlRKOtZ2rJocd.png" alt="image.png"><br><img src="https://s2.loli.net/2023/07/17/SzCGBuiN6AvR7Zo.png" alt="image.png"><br>看起来挺正常的，我那过来改改确实也能用。</p><hr><p>直到快上线的时候，我发现一些元信息丢失了，比如日志生产者的 <code>hostname, PID</code> 等，然而这个信息在 Go 却没有丢失。</p><p>于是我反复调试了之前生成的代码，依然没有找到问题。</p><p>没办法，就只有去翻翻 Go 源码，想看看最终发出去的数据长什么样子，最后看到这样几行代码：<br><img src="https://s2.loli.net/2023/07/17/kJnoR4stKwYvCg8.png"><br><img src="https://s2.loli.net/2023/07/17/tOHvgx2ZzyrAEh9.png" alt="image.png"></p><p>这样一看就很清晰了，只是按照 <code>&lt;%d&gt;%s %s %s[%d]: %s%s</code> 的格式将生成的字符串通过网络发送出去。</p><p>既然这样 Java 代码也很好写了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(hostname,port);</span><br><span class="line">socket.setKeepAlive(<span class="literal">true</span>);</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(os, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> String.format(<span class="string">&quot;&lt;%d&gt;%s %s %s[%d]: %s%s&quot;</span>, <span class="number">6</span> , rfc3164DateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()), <span class="string">&quot;test&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="number">0</span>, message, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">pw.println(format);</span><br></pre></td></tr></table></figure><p>经过测试数据终于对了。</p><p>之后我就在想这么简单的一个问题 Google 上不可能没有吧，于是直接搜索了 <code>Java syslog</code> 关键字，结果直接就有一个现成的库。<br><img src="https://s2.loli.net/2023/07/17/Fm6XBnOdxQ9PAKY.png"></p><p><img src="https://s2.loli.net/2023/07/17/c7PCjmZnboReQtp.png"></p><p>而且实现也是类似的。</p><p>我相信应该有不少朋友也有被 ChatGPT 一本正经的胡说八道误导过，至少在当前的环境下一些简单的东西我还是决定优先 <code>Google</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/07/14/YtqXVJmfNokCwyE.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在使用 ChatGPT 的时候碰到一个小坑，因为某些特殊情况我需要使用 &lt;code&gt;syslog&lt;/code&gt; 向 &lt;code&gt;logbeat&lt;/code&gt; 中发送日志。&lt;/p&gt;
&lt;p&gt;由于这是一个比较古老的协议，确实也没接触过，所以就想着让 ChatGPT 帮我生成个例子。&lt;/p&gt;</summary>
    
    
    
    <category term="ChatGPT" scheme="http://crossoverjie.top/categories/ChatGPT/"/>
    
    
    <category term="Go" scheme="http://crossoverjie.top/tags/Go/"/>
    
    <category term="Syslog" scheme="http://crossoverjie.top/tags/Syslog/"/>
    
  </entry>
  
  <entry>
    <title>Grafana 变量转义处理</title>
    <link href="http://crossoverjie.top/2023/06/26/k8s/grafana-variable/"/>
    <id>http://crossoverjie.top/2023/06/26/k8s/grafana-variable/</id>
    <published>2023-06-26T00:08:08.000Z</published>
    <updated>2023-07-09T15:07:30.908Z</updated>
    
    <content type="html"><![CDATA[<p>Grafana 是一款强大的可视化工具，不止是用于 Prometheus 做数据源，还可以集成数据库、日志等作为数据源整体使用。</p><p>最近我在配置一个监控面板，其中的数据由 Prometheus 和 MySQL 组成；简单来说就是一个指标的查询条件是从数据库中来的。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pulsar_subscription_back_log_no_delayed&#123;topic=~&quot;$topic&quot;,subscription=~&quot;$subscription&quot;&#125;</span><br></pre></td></tr></table></figure><p>其中的 topic 数据是从  MySQL 中来的，其实就是在 Grafana 声明一个变量，从数据库返回了一个列表。</p><p><img src="https://s2.loli.net/2023/06/25/OE37acurFIQjVNH.png"></p><p>因为我们的查询条件是 <code>topic=~&quot;$topic&quot;</code>是正则匹配，所以理论上应该把所有的 <code>topic</code> 关联的数据都查询出来。</p><p><img src="https://s2.loli.net/2023/06/25/WMetKBAvg24hzZk.png"></p><p>但实际情况是任何数据都查不到。</p><p>查看发出去的原始请求后才发现问题出在哪里：</p><p><img src="https://s2.loli.net/2023/06/25/AUXs9lnHoYMQjhO.png"></p><p>原来是选择所有 topic 后 grafana 会~~~~自动对参数转义，这个我查了好多资料包括咨询 ChatGPT 都没有得到解决。</p><p>经过多次测试，发现只要开启多选 grafana 就会自动转义。<br><img src="https://s2.loli.net/2023/06/25/ao51AysPEeiTQNr.png"></p><p>最后我只能想到一个不需要生成多行记录的办法：将所有数据合并成一条记录。</p><p><img src="https://s2.loli.net/2023/06/25/o7Xaf3NKD1rystn.png"></p><p>这样的话就只会生成一条数据，其中包含了所有的 topic，也就避免了被转义。</p><blockquote><p>SQL 中的 CONCAT 函数其实我也不知道怎么使用，还是 ChatGPT 告诉我的。</p></blockquote><p><img src="https://s2.loli.net/2023/06/25/InPYWyiqAL1xRfK.png"></p><p>最后便能完美的查询出数据了。</p><p>有碰到类似问题的朋友可以尝试这个方法，我估计用到这个场景的并不多，不然 ChatGPT 也不会不知道。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Grafana 是一款强大的可视化工具，不止是用于 Prometheus 做数据源，还可以集成数据库、日志等作为数据源整体使用。&lt;/p&gt;
&lt;p&gt;最近我在配置一个监控面板，其中的数据由 Prometheus 和 MySQL 组成；简单来说就是一个指标的查询条件是从数据库中来的。&lt;/p&gt;</summary>
    
    
    
    <category term="cloudnative" scheme="http://crossoverjie.top/categories/cloudnative/"/>
    
    
    <category term="Grafana" scheme="http://crossoverjie.top/tags/Grafana/"/>
    
  </entry>
  
  <entry>
    <title>在这个大环境下我是如何找工作的</title>
    <link href="http://crossoverjie.top/2023/06/20/personal/find-job-experience/"/>
    <id>http://crossoverjie.top/2023/06/20/personal/find-job-experience/</id>
    <published>2023-06-19T17:10:12.000Z</published>
    <updated>2023-06-19T14:44:17.838Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/06/19/SQP9LxtXNhGwyev.png"><br>蛮久没更新了，本次我想聊聊找工作的事情，相信大家都能感受到从去年开始到现在市场是一天比一天差，特别是在我们互联网 IT 行业。<br>已经过了 18 年之前的高速发展的红利期，能做的互联网应用几乎已经被各大公司做了个遍，现在已经进入稳定的存量市场，所以在这样的大背景下再加上全世界范围内的经济不景气我想每个人都能感受到寒意。</p><p>我还记得大约在 20 年的时候看到网上经常说的一句话：今年将是未来十年最好的一年。</p><p>由于当时我所在的公司业务发展还比较顺利，丝毫没有危机意识，对这种言论总是嗤之以鼻，直到去年国庆节附近。</p><span id="more"></span><p>虽然我们做的是海外业务，但是当时受到各方面的原因公司的业务也极速收缩（被收购，资本不看好），所以公司不得不进行裁员；<br>其实到我这里的时候前面已经大概有 2～3 波的优化，我们是最后一波，几乎等于是全军覆没，只留下少数的人维护现有系统。</p><p>这家公司也是我工作这么多年来少数能感受到人情味的公司，虽有不舍，但现实的残酷并不是由我们个人所决定的。</p><p>之后便开始漫长的找工作之旅，到现在也已经入职半年多了；最近看到身边朋友以及网上的一些信息，往往是坏消息多于好消息。</p><p>市场经历半年多的时间，裁员的公司反而增多，岗位也越来越少，所以到现在不管是在职还是离职的朋友或多或少都有所焦虑，我也觉得有必要分享一下我的经历。</p><h1 id="我的预期目标"><a href="#我的预期目标" class="headerlink" title="我的预期目标"></a>我的预期目标</h1><p>下面重点聊聊找工作的事情；其实刚开始得知要找工作的时候我并不是特别慌，因为当时手上有部分积蓄加上公司有 N+1 的赔偿，同时去年 10 月份的时候岗位相对于现在还是要多一些。</p><p>所以我当时的目标是花一个月的时间找一个我觉得靠谱的工作，至少能长期稳定的工作 3 年以上。</p><p>工作性质可以是纯研发或者是偏管理岗都可以，结合我个人的兴趣纯研发岗的话我希望是可以做纯技术性质的工作，相信大部分做业务研发的朋友都希望能做一些看似“高大上”的内容。<br>这一点我也不例外，所以中间件就和云相关的内容就是我的目标。</p><p>不过这点在重庆这个大洼地中很难找到对口工作，所以我的第二目标是技术 leader，或者说是核心主程之类的，毕竟考虑到 3 年后我也 30+ 了，如果能再积累几年的管理经验后续的路会更好走一些。</p><p>当然还有第三个选项就是远程，不过远程的岗位更少，大部分都是和 web3，区块链相关的工作；我对这块一直比较谨慎所以也没深入了解。</p><h1 id="找工作流水账"><a href="#找工作流水账" class="headerlink" title="找工作流水账"></a>找工作流水账</h1><p>因为我从入职这家公司到现在其实还没出来面试过，也不太知道市场行情，所以我的想法是先找几家自己不是非去不可的公司练练手。</p><blockquote><p>有一个我个人的偏好忘记讲到，因为最近的一段时间写 Go 会多一些，所以我优先看的是 Go 相关的岗位。</p></blockquote><h2 id="第一家"><a href="#第一家" class="headerlink" title="第一家"></a>第一家</h2><p>首先第一家是一个 ToB 教育行业的公司，大概的背景是在重庆新成立的研发中心，技术栈也是 Go；</p><p>我现在还记得最后一轮我问研发负责人当初为啥选 Go，他的回答是：</p><blockquote><p>Java 那种臃肿的语言我们首先就不考虑，PHP 也日落西山，未来一定会是 Go 的天下。</p></blockquote><p>由于是新成立的团队，对方发现我之前有管理相关的经验，加上面试印象，所以是期望我过去能做重庆研发 Leader。</p><p>为此还特地帮我申请了薪资调整，因为我之前干过 ToB 业务，所以我大概清楚其中的流程，这种确实得领导特批，所以最后虽然没成但依然很感谢当时的 HR 帮我去沟通。</p><h2 id="第二家"><a href="#第二家" class="headerlink" title="第二家"></a>第二家</h2><p>第二家主要是偏年轻人的 C 端产品，技术栈也是 Go；给我印象比较深的是，去到公司怎么按电梯都不知道🤣</p><blockquote><p>他们办公室在我们这里的 CBD，我长期在政府赞助的产业园里工作确实受到了小小的震撼，办公环境比较好。</p></blockquote><p>当然面试过程给我留下的印象依然非常深刻，我现在依然记得我坐下后面试官也就是 CTO 给我说的第一句话：</p><blockquote><p>我看过你的简历后就决定今天咱们不聊技术话题了，直接聊聊公司层面和业务上是否感兴趣，以及解答我的疑虑，因为我已经看过你写的很多博客和 GitHub，技术能力方面比较放心。</p></blockquote><p>之后就是常规流程，聊聊公司情况个人意愿等。</p><p>最后我也问了为什么选 Go，这位 CTO 给我的回答和上一家差不多😂</p><p>虽然最终也没能去成，但也非常感谢这位 CTO，他是我碰到为数不多会在面试前认真看你的简历，博客和 GitHub 都会真的点进去仔细阅读👍🏼。</p><blockquote><p>其实这两家我都没怎么讲技术细节，因为确实没怎么聊这部分内容；这时就突出维护自己的技术博客和 GitHub 的优势了，技术博客我从 16 年到现在写了大约 170 篇，GitHub 上开源过一些高 star 项目，也参与过一些开源项目，这些都是没有大厂经历的背书，对招聘者来说也是节约他的时间。</p></blockquote><p><img src="https://s2.loli.net/2023/06/19/Hixaf5ZLTrS6EoR.png"><br><img src="https://s2.loli.net/2023/06/19/wRELfbKx5TYkB7z.png"></p><p>当然有好处自然也有“坏处”，这个后续会讲到。</p><h2 id="第三家"><a href="#第三家" class="headerlink" title="第三家"></a>第三家</h2><p>第三家是找朋友推荐的，在业界算是知名的云原生服务提供商，主要做 ToB 业务；因为主要是围绕着 k8s 社区生态做研发，所以就是纯技术的工作，面试的时候也会问一些技术细节。</p><blockquote><p>我还记得有一轮 leader 面，他说你入职后工作内容和之前完全不同，甚至数据库都不需要安装了。</p></blockquote><p>整体大概 5、6 轮，后面两轮都是 BOSS 面，几乎没有问技术问题，主要是聊聊我的个人项目。</p><p>我大概记得一些技术问题：</p><ul><li>k8s 相关的一些组件、Operator</li><li>Go 相关的放射、接口、如何动态修改类实现等等。</li><li>Java 相关就是一些常规的，主要是一些常用特性和 Go 做比较，看看对这两门语言的理解。</li></ul><p>其实这家公司是比较吸引我的，几乎就是围绕着开源社区做研发，工作中大部分时间也是在做开源项目，所以可以说是把我之前的业余爱好和工作结合起来了。</p><p>在贡献开源社区的同时还能收到公司的现金奖励，不可谓是双赢。</p><p>对我不太友好的是工作地在成都，入职后得成渝两地跑；而且在最终发 offer 的前两小时，公司突然停止 HC 了，这点确实没想到，所以阴差阳错的我也没有去成。</p><h2 id="第四家"><a href="#第四家" class="headerlink" title="第四家"></a>第四家</h2><p>第四家也就是我现在入职的公司，当时是我在招聘网站上看到的唯一一家做中间件的岗位，抱着试一试的态度我就投了。<br>面试过程也比较顺利，一轮同事面，一轮 Leader 面。</p><p>技术上也没有聊太多，后来我自己猜测大概率也和我的博客和 Github 有关。</p><hr><p>当然整个过程也有不太友好的经历，比如有一家成都的“知名”旅游公司；面试的时候那个面试官给我的感觉是压根没有看我的简历，所有的问题都是在读他的稿子，根本没有上下文联系。</p><p>还有一家更离谱，直接在招聘软件上发了一个加密相关的算法，让我解释下；因为当时我在外边逛街，所以没有注意到消息；后来加上微信后说我为什么没有回复，然后整个面试就在微信上打字进行。</p><p>其中问了一个很具体的问题，我记得好像是 MD5 的具体实现，说实话我不知道，从字里行间我感觉对方的态度并不友好，也就没有必要再聊下去；最后给我说之所以问这些，是因为看了我的博客后觉得我技术实力不错，所以对我期待较高；我只能是地铁老人看手机。</p><p>最终看来八股文确实是绕不开的，我也花了几天时间整理了 Java 和 Go 的相关资料；不过我觉得也有应对的方法。</p><p>首先得看你面试的岗位，如果是常见的业务研发，从招聘的 JD 描述其实是可以看出来的，比如有提到什么 Java 并发、锁、Spring等等，大概率是要问八股的；这个没办法，别人都在背你不背就落后一截了。</p><p>之后我建议自己平时在博客里多记录八股相关的内容，并且在简历上着重标明博客的地址，尽量让面试官先看到；这样先发制人，你想问的我已经总结好了😂。</p><p>但这个的前提是要自己长期记录，不能等到面试的时候才想起去更新，长期维护也能加深自己的印象，按照 “艾宾浩斯遗忘曲线” 进行复习。</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p><img src="https://s2.loli.net/2023/06/19/haAR4PYjzFGlde2.png"><br>这是我当时记录的面试情况，最终根据喜好程度选择了现在这家公司。</p><p>不过也有一点我现在觉得但是考虑漏了，那就是行业前景。</p><p>现在的 C 端业务真的不好做，相对好做的是一些 B 端，回款周期长，同时不太吃现金流；这样的业务相对来说活的会久一些，我现在所在的公司就是纯做 C 端，在我看来也没有形成自己的护城河，只要有人愿意砸钱随时可以把你干下去。</p><p>加上现在的资本也不敢随意投钱，公司哪天不挣钱的话首先就是考虑缩减产研的成本，所以裁员指不定就会在哪一天到来。</p><p>现在庆幸的是入职现在这家公司也没有选错，至少短期内看来不会再裁员，同时我做的事情也是比较感兴趣的；和第三家有些许类似，只是做得是内部的基础架构，也需要经常和开源社区交流。</p><h1 id="面对裁员能做的事情"><a href="#面对裁员能做的事情" class="headerlink" title="面对裁员能做的事情"></a>面对裁员能做的事情</h1><p>说到裁员，这也是我第一次碰上，只能分享为数不多的经验。</p><h2 id="避免裁员"><a href="#避免裁员" class="headerlink" title="避免裁员"></a>避免裁员</h2><p>当然第一条是尽量避免进入裁员名单，这个我最近在播客 <a href="https://www.xiaoyuzhoufm.com/episode/647d43b41672628240e2187d">作为曾经的老板，我们眼中的裁员和那些建议</a> 讲到在当下的市场情况下哪些人更容易进入裁员名单：</p><ul><li>年纪大的，这类收入不低，同时收益也没年轻人高，确实更容易进入名单。</li><li>未婚女性，这点确实有点政治不正确，但确实就是现在的事实，这个需要整个社会，政府来一起解决。</li><li>做事本本分分，没有贡献也没出啥事故。</li><li>边缘业务，也容易被优化缩减成本。</li></ul><p>那如何避免裁员呢，当然首先尽量别和以上特征重合，一些客观情况避免不了，但我们可以在第三点上主动“卷”一下，当然这个的前提是你还想在这家公司干。</p><p>还有一个方法是提前向公司告知降薪，这点可能很多人不理解，因为我们大部分人的收入都是随着跳槽越来越高的；但这些好处是否是受到前些年互联网过于热门的影响呢？</p><p>当然个人待遇是由市场决定的，现在互联网不可否认的降温了，如果你觉得各方面呆在这家公司都比出去再找一个更好，那这也不失为一个方法；除非你有信心能找到一个更好的，那就另说了。</p><h1 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h1><p>我觉得只要一家公司只要有裁员的风声传出来后，即便是没被裁，你也会处于焦虑之中；要想避免这种焦虑确实也很简单，只要有稳定的被动收入那就无所谓了。</p><p>这个确实也是说起来轻松做起来难，我最近也一直在思考能不能在工作之余做一些小的 side project，这话题就大了，只是我觉得我们程序员先天就有自己做一个产品的机会和能力，与其把生杀大权给别人，不如握在自己手里。</p><p>当然这里得提醒下，在国内的企业，大部分老板都认为签了合同你的 24 小时都是他的，所以这些业务项目最好是保持低调，同时不能影响到本职工作。</p><blockquote><p>欢迎关注作者公众号于我交流🤗。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/06/19/SQP9LxtXNhGwyev.png&quot;&gt;&lt;br&gt;蛮久没更新了，本次我想聊聊找工作的事情，相信大家都能感受到从去年开始到现在市场是一天比一天差，特别是在我们互联网 IT 行业。&lt;br&gt;已经过了 18 年之前的高速发展的红利期，能做的互联网应用几乎已经被各大公司做了个遍，现在已经进入稳定的存量市场，所以在这样的大背景下再加上全世界范围内的经济不景气我想每个人都能感受到寒意。&lt;/p&gt;
&lt;p&gt;我还记得大约在 20 年的时候看到网上经常说的一句话：今年将是未来十年最好的一年。&lt;/p&gt;
&lt;p&gt;由于当时我所在的公司业务发展还比较顺利，丝毫没有危机意识，对这种言论总是嗤之以鼻，直到去年国庆节附近。&lt;/p&gt;</summary>
    
    
    
    <category term="Interview" scheme="http://crossoverjie.top/categories/Interview/"/>
    
    <category term="Person" scheme="http://crossoverjie.top/categories/Interview/Person/"/>
    
    
  </entry>
  
  <entry>
    <title>云原生背景下如何配置 JVM 内存</title>
    <link href="http://crossoverjie.top/2023/05/15/k8s/cloudnative-java/"/>
    <id>http://crossoverjie.top/2023/05/15/k8s/cloudnative-java/</id>
    <published>2023-05-15T00:08:08.000Z</published>
    <updated>2023-05-20T15:24:19.501Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/05/12/IAxSF3oZ1j8GHbi.png" alt="image.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间业务研发反馈说是他的应用内存使用率很高，导致频繁的重启，让我排查下是怎么回事；</p><p>在这之前我也没怎么在意过这个问题，正好这次排查分析的过程做一个记录。</p><span id="more"></span><p>首先我查看了监控面板里的 Pod 监控：<br><img src="https://s2.loli.net/2023/05/14/wyYu8SI7eGprqmQ.png" alt="WeChatWorkScreenshot_ac6f8d80-bdb4-469e-af1a-b2199c9ee288.png"></p><p>发现确实是快满了，而此时去查看应用的 JVM 占用情况却只有30%左右；说明并不是应用内存满了导致 JVM 的 OOM，而是 Pod 的内存满了，导致 Pod 的内存溢出，从而被 k8s 杀掉了。</p><p>而 <code>k8s</code> 为了维持应用的副本数量就得重启一个 Pod，所以看起来就是应用运行一段时间后就被重启。</p><hr><p><img src="https://s2.loli.net/2023/05/14/Lhkjys1TEQUKV86.png" alt="WeChatWorkScreenshot_6213e2f8-c429-4d33-acdd-e639275dd92b.png"><br>而这个应用配置的是 JVM 8G，容器申请的内存是16G，所以 Pod 的内存占用看起来也就 50% 左右。</p><h1 id="容器的原理"><a href="#容器的原理" class="headerlink" title="容器的原理"></a>容器的原理</h1><p>在解决这个问题之前还是先简单了解下容器的运行原理，因为在 k8s 中所有的应用都是运行在容器中的，而容器本质上也是运行在宿主机上的一个个进程而已。</p><p>但我们使用 Docker 的时候会感觉每个容器启动的应用之间互不干扰，从文件系统、网络、CPU、内存这些都能完全隔离开来，就像两个运行在不同的服务器中的应用。</p><p>其实这一点也不是啥黑科技，Linux 早就支持 2.6.x 的版本就已经支持 <code>namespace</code> 隔离了，使用 <code>namespace</code> 可以将两个进程完全隔离。</p><p>仅仅将资源隔离还不够，还需要限制对资源的使用，比如 CPU、内存、磁盘、带宽这些也得做限制；这点也可以使用 <code>cgroups</code> 进行配置。</p><p>它可以限制某个进程的资源，比如宿主机是 4 核 CPU，8G 内存，为了保护其他容器，必须给这个容器配置使用上限：1核 CPU，2G内存。</p><p><img src="https://s2.loli.net/2023/05/14/dzcHK6G8VZQuFC5.png" alt="image.png"></p><p>这张图就很清晰的表示了 <code>namespace</code>  和 <code>cgroups</code> 在容器技术中的作用，简单来说就是：</p><ul><li>namespace 负责隔离</li><li>cgroups 负责限制</li></ul><p>在 k8s 中也有对应的提现：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="number">0.1</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这个资源清单表示该应用至少需要为一个容器分配一个 0.1 核和 1024M 的资源，CPU 的最高上限为 4 个核心。</p><h1 id="不同的OOM"><a href="#不同的OOM" class="headerlink" title="不同的OOM"></a>不同的OOM</h1><p>回到本次的问题，可以确认是容器发生了 OOM 从而导致被 k8s 重启，这也是我们配置 limits 的作用。</p><blockquote><p>k8s 内存溢出导致容器退出会出现 exit code 137 的一个 event 日志。</p></blockquote><p>因为该应用的 JVM 内存配置和容器的配置大小是一样的，都是8GB，但 Java 应用还有一些非 JVM 管理的内存，比如堆外内存之类的，这样很容易就导致容器内存大小超过了限制的 8G 了，也就导致了容器内存溢出。</p><h1 id="云原生背景的优化"><a href="#云原生背景的优化" class="headerlink" title="云原生背景的优化"></a>云原生背景的优化</h1><p>因为这个应用本身使用的内存不多，所以建议将堆内存限制到 4GB，这样就避免了容器内存超限，从而解决了问题。</p><p>当然之后我们也会在应用配置栏里加上建议：推荐 JVM 的配置小于容器限制的 2&#x2F;3，预留一些内存。</p><p>其实本质上还是开发模式没有转变过来，以传统的 Java 应用开发模式甚至都不会去了解容器的内存大小，因为以前大家的应用都是部署在一个内存较大的虚拟机上，所以感知不到容器内存的限制。</p><p>从而误以为将两者画了等号，这一点可能在 Java 应用中尤为明显，毕竟多了一个 JVM；甚至在老版本的 JDK 中如果没有设置堆内存大小，无法感知到容器的内存限制，从而自动生成的 Xmx 大于了容器的内存大小，以致于 OOM。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/05/12/IAxSF3oZ1j8GHbi.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间业务研发反馈说是他的应用内存使用率很高，导致频繁的重启，让我排查下是怎么回事；&lt;/p&gt;
&lt;p&gt;在这之前我也没怎么在意过这个问题，正好这次排查分析的过程做一个记录。&lt;/p&gt;</summary>
    
    
    
    <category term="cloudnative" scheme="http://crossoverjie.top/categories/cloudnative/"/>
    
    
    <category term="Java" scheme="http://crossoverjie.top/tags/Java/"/>
    
    <category term="JVM" scheme="http://crossoverjie.top/tags/JVM/"/>
    
    <category term="K8s" scheme="http://crossoverjie.top/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>从源码彻底理解 Prometheus/VictoriaMetrics 中的 relabel_configs/metric_relabel_configs 配置</title>
    <link href="http://crossoverjie.top/2023/03/13/metrics/relabel_configs_%20metric_relabel_configs/"/>
    <id>http://crossoverjie.top/2023/03/13/metrics/relabel_configs_%20metric_relabel_configs/</id>
    <published>2023-03-13T00:08:08.000Z</published>
    <updated>2023-03-12T10:44:16.552Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/03/11/Xxp5yNTH1ASBk3Z.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近接手维护了公司的指标监控系统，之后踩到坑就没站起来过。。<br><img src="https://s2.loli.net/2023/03/11/UwBJ28ZafziRsQS.png"></p><span id="more"></span><p>本次问题的起因是我们配置了一些指标的删除策略没有生效：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">action:</span> <span class="string">drop_metrics</span></span><br><span class="line">  <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br></pre></td></tr></table></figure><p>与这两个容易引起误解的配置<code>relabel_configs/metric_relabel_configs</code>有关。</p><p>他们都是对抓取的数据进行重命名、过滤、新增、删除等操作，但应用场景却完全不同。</p><blockquote><p>我们使用了 VictoriaMetrics 替换了 Prometheus，VM 完全兼容 Prometheus ，所以本文也对 Prometheus 同样适用。</p></blockquote><h1 id="理解错误1"><a href="#理解错误1" class="headerlink" title="理解错误1"></a>理解错误1</h1><p><img src="https://s2.loli.net/2023/03/12/9oYRlCGTZaNuc5j.png" alt="image.png"><br>但这里其实是有一个错误理解的，我是通过 VM 的服务发现页面的指标响应页面查询指标的，打开之后确实能搜到需要被删除的相关指标。</p><p>但其实即便是真的删除了数据这个页面也会有数据存在，删除的数据只是不会写入 VM 的时序数据库中。</p><blockquote><p>这一点是在后续查源码时才发现；后面我配置对了依然在这里查看数据，发现还是没有删除，这个错误理解浪费了不少时间😂。</p></blockquote><h1 id="理解错误2"><a href="#理解错误2" class="headerlink" title="理解错误2"></a>理解错误2</h1><p>为了解决问题，通过 <code>drop metrics</code> 这类关键字在 VM 的官方文档中查询，最终找到一篇文章。<br><a href="https://www.robustperception.io/dropping-metrics-at-scrape-time-with-prometheus/">https://www.robustperception.io/dropping-metrics-at-scrape-time-with-prometheus/</a><br><img src="https://s2.loli.net/2023/03/12/oRQKnf7u6j3Ulq5.png"></p><p>按照这里的介绍，将删除的配置加入到 <code>metric_relabel_configs</code> 配置下，经过测试确实有效。</p><p>不过为啥将同样的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">drop_metrics</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br></pre></td></tr></table></figure><p>加入到 <code>relabel_configs</code> 未能生效呢？</p><p>估计确实容易令人误导，在文档中也找到了相关的解释：<br><a href="https://www.robustperception.io/relabel_configs-vs-metric_relabel_configs/">https://www.robustperception.io/relabel_configs-vs-metric_relabel_configs&#x2F;</a><br><img src="https://s2.loli.net/2023/03/12/xyaqKjkf85YZzeA.png"><br>这篇文章主要是表达几个重点：</p><ul><li><code>relabel_configs</code> 用于配置哪个目标需要被抓取，发生在指标抓取之前。</li><li><code>metric_relabel_configs</code> 发生在指标抓取之后，写入存储之前。</li><li>如果其中一个没生效，就换一个（这句话很容易让人犯迷糊）</li></ul><p>但说实话当时我看到这里还是一脸懵，为了彻底了解两则的区别还是看源码来的直接。</p><h2 id="阅读源码理解本质原因"><a href="#阅读源码理解本质原因" class="headerlink" title="阅读源码理解本质原因"></a>阅读源码理解本质原因</h2><h3 id="metric-relabel-configs"><a href="#metric-relabel-configs" class="headerlink" title="metric_relabel_configs"></a>metric_relabel_configs</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metric_relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">drop_metrics</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br></pre></td></tr></table></figure><p>首先看下<code>metric_relabel_configs</code>配置生效的原因。</p><p><img src="https://s2.loli.net/2023/03/12/dWA4a3kzGPIxFEX.png"></p><p><code>metric_relabel_configs</code> 配置的整体流程如上图：</p><ul><li>启动 VM 时加载配置到内存</li><li>根据配置的抓取间隔时间(<code>scrape_interval</code>)抓取数据，拿到的每一条数据都需要通过 <code>metric_relabel_configs</code> 的应用。</li><li>针对于这里的 <code>drop_metrics</code> 来说，就是判断是否需要删除掉所有的 <code>Label</code>。</li><li>如果可以匹配删除，那就不会写入存储。</li></ul><p>其中的关键代码如下：<br><img src="https://s2.loli.net/2023/03/12/ZlIKFDbhLVpx8Om.png"></p><p>这里还有一个小细节，源码里判断的 <code>action</code> 是 <code>drop</code>，而我们配置的是 <code>drop_metrics</code>，其实 <code>drop_metrics</code> 也是 drop 的一个封装而已。</p><p><img src="https://s2.loli.net/2023/03/12/2kQ9rSBsJ3IuAwm.png"><br>在解析配置的时候会进行转换。</p><p>与这个写法是等价的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">source_labels:</span> [ <span class="string">__name__</span> ]</span><br><span class="line">  <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br><span class="line">  <span class="attr">action:</span> <span class="string">drop</span></span><br></pre></td></tr></table></figure><h3 id="relabel-configs"><a href="#relabel-configs" class="headerlink" title="relabel_configs"></a>relabel_configs</h3><p>然后来看看 <code>relabel_configs</code> 没有按照预期生效的原因。</p><p><img src="https://s2.loli.net/2023/03/12/itlzeXC8DNhpQf4.png"></p><p>其实核心的应用配置就是同一份代码，只是触发点不一样。</p><p><code>relabel_configs</code> 是在应用启动的时候根据我们配置的抓取目标的数据当做数据源，所以这里的 <code>action: drop</code> 删除的是抓取目标，而不是真正的抓取数据。<br><img src="https://s2.loli.net/2023/03/12/qXbwjh5e3uRds4z.png"></p><p>而且它的目的是在应用启动的时候，用于生成抓取目标的任务，<strong>只会运行一次</strong>。</p><p>假设我这里改写为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [ <span class="string">__address__</span> ]</span><br><span class="line">      <span class="attr">regex:</span> <span class="string">&#x27;192.xx.xx.xx:443&#x27;</span></span><br><span class="line">      <span class="attr">action:</span> <span class="string">drop</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/12/SfJnMP547ltQohW.png"><br>那么我这个抓取任务就会被删除掉，而不是删除这个指标了。</p><p>因此之前我在这里配置的是一些业务指标 <code>regex: &quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</code>，在所有元数据里自然是没有任何一个可以匹配了，所以也就无事发生。</p><blockquote><p>元数据都是以 <code>__</code> 开头。</p></blockquote><hr><p>其实 VM 也有提供一个 Debug 页面用于调试 <code>relabel_configs</code>，但如果知道怎么用这个调试页面其实也理解了他的运行原理😂<br><img src="https://s2.loli.net/2023/03/12/q8KAwpOsBMIEXT3.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://www.robustperception.io/relabelling-can-discard-targets-timeseries-and-alerts/">https://www.robustperception.io/relabelling-can-discard-targets-timeseries-and-alerts/</a> </p><p><img src="https://s2.loli.net/2023/03/12/lJsntMyoCruRYi7.png"><br>后面我查到这篇文章也有相关解释，理解了两者的区别后再看这里的分析会更加容易理解。</p><p>总的来说：</p><ul><li><code>relabel_configs</code> 用于对抓取目标元数据的增删改；如果删除后连后续的抓取任务也会被取消。</li><li><code>metric_relabel_configs</code> 用于对抓取到的数据增删改，对于不需要的业务指标可以在这里配置。</li></ul><p>也就是前文讲到的 <code>relabel_configs</code> 应用于指标抓取前，<code>metric_relabel_configs</code> 应用于指标抓取后。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/03/11/Xxp5yNTH1ASBk3Z.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近接手维护了公司的指标监控系统，之后踩到坑就没站起来过。。&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/03/11/UwBJ28ZafziRsQS.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="metrics" scheme="http://crossoverjie.top/categories/metrics/"/>
    
    
    <category term="K8s" scheme="http://crossoverjie.top/tags/K8s/"/>
    
    <category term="Prometheus" scheme="http://crossoverjie.top/tags/Prometheus/"/>
    
    <category term="VictoriaMetrics" scheme="http://crossoverjie.top/tags/VictoriaMetrics/"/>
    
  </entry>
  
  <entry>
    <title>通过 Pulsar 源码彻底解决重复消费问题</title>
    <link href="http://crossoverjie.top/2023/02/27/pulsar/pulsar-repeat-consume/"/>
    <id>http://crossoverjie.top/2023/02/27/pulsar/pulsar-repeat-consume/</id>
    <published>2023-02-27T00:08:08.000Z</published>
    <updated>2023-02-26T13:42:52.831Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/02/26/Oz94bQasM2Einok.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近真是和 <code>Pulsar</code> 杠上了，业务团队反馈说是线上有个应用消息重复消费。</p><p><img src="https://s2.loli.net/2023/02/26/c2eZuTPUvrlB1YF.png"></p><p>而且在测试环境是可以稳定复现的，根据经验来看一般能稳定复现的都比较好解决。</p><span id="more"></span><h1 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h1><p>接着便是定位问题了，根据之前的经验让业务按照这几种情况先排查一下：<br><img src="https://s2.loli.net/2023/02/26/IrvxGDQuaSt7AOE.png"></p><p>通过排查：1,2可以排除了。</p><ol><li>没有相关日志</li><li>存在异常，但最外层也捕获了，所以不管有无异常都会 ACK。</li></ol><p>第三个也在消费的入口和提交消息出计算了时间，最终发现都是在2s左右 ACK 的。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> client.newConsumer()</span><br><span class="line">        .subscriptionType(SubscriptionType.Shared)</span><br><span class="line">        .enableRetry(<span class="literal">true</span>)</span><br><span class="line">        .topic(topic)</span><br><span class="line">        .ackTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">        .subscriptionName(<span class="string">&quot;my-sub&quot;</span>)</span><br><span class="line">        .messageListener(<span class="keyword">new</span> <span class="title class_">MessageListener</span>&lt;<span class="type">byte</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@SneakyThrows</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">received</span><span class="params">(Consumer&lt;<span class="type">byte</span>[]&gt; consumer, Message&lt;<span class="type">byte</span>[]&gt; msg)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;msg_id&#123;&#125;&quot;</span>,msg.getMessageId().toString());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                consumer.acknowledge(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure><p>那这就很奇怪了，因为代码里配置的 ackTimeout 是 30s，理论上来说是不会存在超时导致消息重发的。</p><p>为了排除是否是超时引起的，直接将业务代码注释掉了，等于是消息收到后立即就 ACK，经过测试发现这样确实就没有重复消费了。</p><p>为了再次确认是不是和 ackTimeout 有关，直接将 <code>.ackTimeout(30, TimeUnit.SECONDS)</code> 注释掉后测试，发现也没有重复消费了。</p><h1 id="确认原因"><a href="#确认原因" class="headerlink" title="确认原因"></a>确认原因</h1><p>既然如此那一定是和这个配置有关了，但看代码确实没有超时，为了定位具体原因只有去看 client 的源码了。</p><p>这里简单梳理下消息的消费的流程：</p><ol><li>根据 <code>.receiverQueueSize(1000)</code> 的配置，默认情况下 broker 会直接给客户端推送 1000 条消息。</li><li>客户端将这 1000 条消息保存到内部队列中。</li><li>如果使用同步消费 <code>receive()</code> 时，本质上就是去 <code>take</code> 这个内部队列。</li><li>如果是使用的是 <code>messageListener</code> 异步消费并配置 <code>ackTimeout</code>，每当从队列里获得一条消息后便会把这条消息加入 <code>UnAckedMessageTracker</code> 内部的一个时间轮中，定时检测顶部是否存在消息，如果存在则会触发重新投递。<br>4.1 加入时间轮后，<code>异步</code>调用我们自定义的事件，这个异步操作是提交到一个无界队列中由单个线程依次排队执行（这点是这次问题的关键）</li><li>业务 ACK 的时候会从时间轮中删除消息，所以如果消息 ACK 的足够快，在第四步就不会获取到消息进行重新投递。</li></ol><p><img src="https://s2.loli.net/2023/02/26/2PuOadlU6oRqHVN.png"></p><p>整体流程如上图，代码细节如下图：<br><img src="https://s2.loli.net/2023/02/26/jMOqBUe912cdEWg.png"></p><p>所以问题的根本原因就是写入时间轮（<code>UnAckedMessageTracker</code>）开始倒计时的线程和回调业务逻辑的不是同一个线程。</p><p>如果业务执行耗时，等到消息从那个单线程的无界队列中取出来的时候很有可能已经过了 ackTimeou 的时间，从而导致了超时重发。</p><p>也就是用户所理解的 <code>ackTimeout</code> 周期（应该进入回调时候开始计时）和 SDK 实现的不一致造成的。</p><p>之后我再次确认同样的代码换为同步消费是没有问题的，不会导致重复消费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> consumer.receive();</span><br><span class="line">            log.info(</span><br><span class="line">                    <span class="string">&quot;consumer Message received: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(msg.getData()) + msg.getMessageId().toString());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            consumer.acknowledge(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看代码后发现同步代码的获取消息和加入 <code>UnAckedMessageTracker</code> 时间轮是同步的，也就不会出现超时的问题。<br><img src="https://s2.loli.net/2023/02/26/AUiDgXYO7QvINTF.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以其实 是<code>messageListener</code> 异步消费的 ackTimeout 的语义是有问题的，需要将加入 <code>UnAckedMessageTracker</code> 处移动到回调函数中同步调用。</p><p>我查看了最新的 <code>2.11.x</code> 版本的代码依然没有修复，正准备提个 PR 切换到 master 时才发现已经有相关的 PR 了，只是还没有发版。</p><p>修复的背景和思路也是类似的，具体参考：</p><p><a href="https://github.com/apache/pulsar/pull/18911">https://github.com/apache/pulsar/pull/18911</a></p><p>其实业务中并不推荐使用 ackTimeout 这个配置了，不好预估时间从而导致超时，而且我相信大部分业务配置好 <code>ackTImeout</code> 后直到后续出问题的时候才想起来要改。<br>所以干脆一开始就不要使用。</p><p>在 go 版本的 SDK 中直接废弃掉了这个参数，推荐使用 nack API 替换。</p><p><img src="https://s2.loli.net/2023/02/26/kQaZAcJi6WjNDXq.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/26/Oz94bQasM2Einok.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近真是和 &lt;code&gt;Pulsar&lt;/code&gt; 杠上了，业务团队反馈说是线上有个应用消息重复消费。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/26/c2eZuTPUvrlB1YF.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;而且在测试环境是可以稳定复现的，根据经验来看一般能稳定复现的都比较好解决。&lt;/p&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="Consumer" scheme="http://crossoverjie.top/tags/Consumer/"/>
    
  </entry>
  
  <entry>
    <title>一个诡异的 Pulsar InterruptedException 异常</title>
    <link href="http://crossoverjie.top/2023/02/23/pulsar/pulsar-interrupted/"/>
    <id>http://crossoverjie.top/2023/02/23/pulsar/pulsar-interrupted/</id>
    <published>2023-02-23T00:08:08.000Z</published>
    <updated>2023-02-22T17:11:31.775Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/02/22/mQaCJMopS1WAjVN.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><img src="https://s2.loli.net/2023/02/22/Lw3UbtiJ1GKyg6x.png"><br>今天收到业务团队反馈线上有个应用往 Pulsar 中发送消息失败了，经过日志查看得知是发送消息时候抛出了 <code>java.lang.InterruptedException</code> 异常。</p><p>和业务沟通后得知是在一个 <code>gRPC</code> 接口中触发的消息发送，大约持续了半个小时的异常后便恢复正常了，这是整个问题的背景。</p><span id="more"></span><h1 id="前置排查"><a href="#前置排查" class="headerlink" title="前置排查"></a>前置排查</h1><p>拿到该问题后首先排查下是否是共性问题，查看了其他的应用没有发现类似的异常；同时也查看了 Pulsar broker 的监控大盘，在这个时间段依然没有波动和异常；</p><p>这样可以初步排除是 Pulsar 服务端的问题。</p><p>接着便是查看应用那段时间的负载情况，从应用 QPS 到 JVM 的各个内存情况依然没发现有什么明显的变化。</p><h1 id="Pulsar-源码排查"><a href="#Pulsar-源码排查" class="headerlink" title="Pulsar 源码排查"></a>Pulsar 源码排查</h1><p>既然看起来应用本身和 Pulsar broker 都没有问题的话那就只能从异常本身来排查了。</p><p>首先第一步要得知具体使用的是 <code>Pulsar-client</code> 是版本是多少，因为业务使用的是内部基于官方 SDK 封装 <code>springboot starter</code> 所以第一步还得排查这个 <code>starter</code> 是否有影响。</p><p>通过查看源码基本排除了 <code>starter</code> 的嫌疑，里面只是简单的封装了 <code>SDK</code> 的功能而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">org.apache.pulsar.client.api.PulsarClientException: java.util.concurrent.ExecutionException: org.apache.pulsar.client.api.PulsarClientException: java.lang.InterruptedException at org.apache.pulsar.client.api.PulsarClientException.unwrap(PulsarClientException.java:<span class="number">1027</span>) at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.send(TypedMessageBuilderImpl.java:<span class="number">91</span>) at </span><br><span class="line">java.base/java.lang.Thread.run(Thread.java:<span class="number">834</span>) Caused by: java.util.concurrent.ExecutionException: org.apache.pulsar.client.api.PulsarClientException: java.lang.InterruptedException at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:<span class="number">395</span>) </span><br><span class="line">at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:<span class="number">1999</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.send(TypedMessageBuilderImpl.java:<span class="number">89</span>) ... <span class="number">49</span> common frames omitted Caused by: org.apache.pulsar.client.api.PulsarClientException: java.lang.InterruptedException </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.canEnqueueRequest(ProducerImpl.java:<span class="number">775</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.sendAsync$original$BWm7PPlZ(ProducerImpl.java:<span class="number">393</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.sendAsync$original$BWm7PPlZ$accessor$i7NYMN6i(ProducerImpl.java) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl$auxiliary$EfuVvJLT.call(Unknown Source) </span><br><span class="line">at org.apache.skywalking.apm.agent.core.plugin.interceptor.enhance.InstMethodsInter.intercept(InstMethodsInter.java:<span class="number">86</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.sendAsync(ProducerImpl.java) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.internalSendAsync(ProducerImpl.java:<span class="number">292</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.internalSendWithTxnAsync(ProducerImpl.java:<span class="number">363</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.PartitionedProducerImpl.internalSendWithTxnAsync(PartitionedProducerImpl.java:<span class="number">191</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.PartitionedProducerImpl.internalSendAsync(PartitionedProducerImpl.java:<span class="number">167</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.sendAsync(TypedMessageBuilderImpl.java:<span class="number">103</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.send(TypedMessageBuilderImpl.java:<span class="number">82</span>) ... <span class="number">49</span> common frames omitted Caused by: java.lang.InterruptedException: <span class="literal">null</span></span><br><span class="line">at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">1343</span>) </span><br><span class="line">at java.base/java.util.concurrent.Semaphore.acquire(Semaphore.java:<span class="number">318</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.canEnqueueRequest(ProducerImpl.java:<span class="number">758</span>)</span><br></pre></td></tr></table></figure><p>接下来便只能是分析堆栈了，因为 Pulsar-client 的部分实现源码是没有直接打包到依赖中的，反编译的话许多代码行数对不上，所以需要将官方的源码拉到本地，切换到对于的分支进行查看。</p><blockquote><p>这一步稍微有点麻烦，首先是代码库还挺大的，加上之前如果没有准备好 Pulsar 的开发环境的话估计会劝退一部分人；但其实大部分问题都是网络造成的，只要配置一些 Maven 镜像多试几次总会编译成功。</p></blockquote><p>我这里直接将分支切换到 <code>branch-2.8</code>。</p><p>从堆栈的顶部开始排查 <code>TypedMessageBuilderImpl.java:91</code>：<br><img src="https://s2.loli.net/2023/02/23/Q53Vm1Fkau9Yn2c.png"><br>看起来是内部异步发送消息的时候抛了异常。</p><p>接着往下看到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.canEnqueueRequest(ProducerImpl.java:<span class="number">775</span>) at</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/23/LdJspv5CfaRm3EW.png"><br>看起来是这里没错，但是代码行数明显不对；因为 2.8 这个分支也是修复过几个版本，所以中间有修改导致代码行数与最新代码对不上也正常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphore.get().acquire();</span><br></pre></td></tr></table></figure><p>不过初步来看应该是这行代码抛出的线程终端异常，这里看起来只有他最有可能了。</p><p><img src="https://s2.loli.net/2023/02/23/V3mFAuRKzgWnN5T.png"><br>为了确认是否是真的是这行代码，这个文件再往前翻了几个版本最终确认了就是这行代码没错了。</p><p>我们点开<code>java.util.concurrent.Semaphore#acquire()</code>的源码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;has its interrupted status set on entry to this method; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while waiting</span></span><br><span class="line"><span class="comment"> * for a permit,</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread&#x27;s</span></span><br><span class="line"><span class="comment"> * interrupted status is cleared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted() ||</span><br><span class="line">        (tryAcquireShared(arg) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         acquire(<span class="literal">null</span>, arg, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0L</span>) &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>通过源码会发现 <code>acquire()</code> 函数确实会响应中断，一旦检测到当前线程被中断后便会抛出 <code>InterruptedException</code> 异常。</p><h1 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h1><p>所以问题的原因基本确定了，就是在 Pulsar 的发送消息线程被中断了导致的，但为啥会被中断还需要继续排查。</p><p>我们知道线程中断是需要调用 <code>Thread.currentThread().interrupt();</code> API的，首先猜测是否 Pulsar 客户端内部有个线程中断了这个发送线程。</p><p>于是我在 <code>pulsar-client</code> 这个模块中搜索了相关代码：<br><img src="https://s2.loli.net/2023/02/23/w6USaRvMqAIjCfm.png"><br>排除掉和 producer 不相关的地方，其余所有中断线程的代码都是在有了该异常之后继续传递而已；所以初步来看 pulsar-client 内部没有主动中断的操作。</p><p>既然 Pulsar 自己没有做，那就只可能是业务做的了？</p><p>于是我在业务代码中搜索了一下：<br><img src="https://s2.loli.net/2023/02/23/lVzJPf9ZWBGmuti.png"></p><p>果然在业务代码中搜到了唯一一处中断的地方，而且通过调用关系得知这段代码是在消息发送前执行的，并且和 Pulsar 发送函数处于同一线程。</p><p>大概的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).stream().map(e -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    ).collect(Collectors.toList()).forEach(f -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> f.get();</span><br><span class="line">            log.info(<span class="string">&quot;====&quot;</span> + integer);</span><br><span class="line">            <span class="keyword">if</span> (integer==<span class="number">3</span>)&#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="type">MessageId</span> <span class="variable">send</span> <span class="operator">=</span> producer.newMessage().value(msg.getBytes()).send();</span><br></pre></td></tr></table></figure><p>执行这段代码可以完全复现同样的堆栈。</p><p>幸好中断这里还打得有日志：</p><p><img src="https://s2.loli.net/2023/02/23/nHE4WcfaKD8iqSb.png"><br><img src="https://s2.loli.net/2023/02/23/4df5ehMBwj9DyQV.png"></p><p>通过日志搜索发现异常的时间和这个中断的日志时间点完全重合，这样也就知道根本原因了。</p><p>因为业务线程和消息发送线程是同一个，在某些情况下会执行 <code>Thread.currentThread().interrupt();</code>，其实单纯执行这行函数并不会发生什么，只要没有去响应这个中断，也就是 <code>Semaphore</code> 源码中的判断了线程中断的标记：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted() ||</span><br><span class="line">        (tryAcquireShared(arg) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         acquire(<span class="literal">null</span>, arg, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0L</span>) &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但恰好这里业务中断后自己并没有去判断这个标记，导致 Pulsar 内部去判断了，最终抛出了这个异常。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以归根结底还是这里的代码不合理导致的，首先是自己中断了线程但也没使用，从而导致有被其他基础库使用的可能，所以会造成了一些不可预知的后果。</p><p>再一个是不建议在业务代码中使用 <code>Thread.currentThread().interrupt();</code> 这类代码，第一眼根本不知道是要干啥，也不易维护。</p><p>其实本质上线程中断也是线程间通信的一种手段，有这类需求完全可以换为内置的 <code>BlockQueue</code> 这类函数来实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/22/mQaCJMopS1WAjVN.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/22/Lw3UbtiJ1GKyg6x.png&quot;&gt;&lt;br&gt;今天收到业务团队反馈线上有个应用往 Pulsar 中发送消息失败了，经过日志查看得知是发送消息时候抛出了 &lt;code&gt;java.lang.InterruptedException&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;和业务沟通后得知是在一个 &lt;code&gt;gRPC&lt;/code&gt; 接口中触发的消息发送，大约持续了半个小时的异常后便恢复正常了，这是整个问题的背景。&lt;/p&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="InterruptedException" scheme="http://crossoverjie.top/tags/InterruptedException/"/>
    
  </entry>
  
  <entry>
    <title>Istio 升级后踩的坑</title>
    <link href="http://crossoverjie.top/2023/02/20/istio/istio1.12-upgrade-fix/"/>
    <id>http://crossoverjie.top/2023/02/20/istio/istio1.12-upgrade-fix/</id>
    <published>2023-02-20T00:08:08.000Z</published>
    <updated>2023-02-19T13:42:29.744Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/02/19/FwgABGdDrhR4a3j.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间我们将 istio 版本升级到 1.12 后导致现有的应用监控有部分数据丢失（页面上显示不出来）。</p><ul><li>一个是应用基础信息丢失。</li><li>再一个是应用 JVM 数据丢失。</li><li>接口维度的监控数据丢失。</li></ul><span id="more"></span><p><img src="https://s2.loli.net/2023/02/19/6eSAIF1Jcjhrp4x.png"></p><hr><p><img src="https://s2.loli.net/2023/02/19/Lyr4cSxVmutjJU6.png"></p><hr><p><img src="https://s2.loli.net/2023/02/19/aPzD9t7L1mGqiJR.png"></p><hr><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p>首先是第一个基础信息丢失的问题，页面上其实显示的是我们的一个聚合指标<code>istio_requests_total:source:rate1m</code>。</p><blockquote><p>聚合后可以将多个指标合并为一个，减少系统压力</p></blockquote><p>具体可以参考 Istio 的最佳实践 <a href="https://istio.io/latest/docs/ops/best-practices/observability/#workload-level-aggregation-via-recording-rules">Observability Best Practices</a> 有详细说明。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">groups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">istio.service.source.istio_requests_total</span></span><br><span class="line">      <span class="attr">rules:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">expr:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            sum(irate(istio_requests_total&#123;reporter=&quot;source&quot;&#125;[1m]))</span></span><br><span class="line"><span class="string">            by (</span></span><br><span class="line"><span class="string">              destination_app,</span></span><br><span class="line"><span class="string">              source_workload_namespace,</span></span><br><span class="line"><span class="string">              response_code,</span></span><br><span class="line"><span class="string">              source_app</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string"></span>          <span class="attr">record:</span> <span class="string">istio_requests_total:source:rate1m</span></span><br></pre></td></tr></table></figure><p>本质上是通过以上四个维度进行统计 <code>istio_requests_total</code>；但在升级之后查看原始数据发现丢失了 <code>destination_app, source_app</code> 这两个 tag。</p><p>至于为啥丢失，查了许久，最后在升级后的资源文件 <code>stats-filter-1.12.yaml</code> 中找到了答案:<br><img src="https://s2.loli.net/2023/02/19/B7a6sH9CYznVGUI.png"><br>升级后新增了 <code>tags_to_remove</code> 标记，将我们所需要的两个 tag 直接删掉了。</p><p>后续在当前 namespace 下重新建一个 <code>EnvoyFilter</code> 资源覆盖掉默认的便能恢复这两个 tag，修复后监控页面也显示正常了。</p><blockquote><p>EnvoyFilter 是实时生效的，并不需要重建应用 Pod。</p></blockquote><h3 id="JVM-监控"><a href="#JVM-监控" class="headerlink" title="JVM 监控"></a>JVM 监控</h3><p><code>JVM</code> 数据丢失的这个应用，直接进入 <code>Pod</code> 查看暴露出的 <code>metric</code>，发现数据都有，一切正常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;Code Cache&quot;,&#125; 1.32126784E8</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;Metaspace&quot;,&#125; 2.74250552E8</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;Compressed Class Space&quot;,&#125; 3.1766024E7</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;G1 Eden Space&quot;,&#125; 1.409286144E9</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;G1 Survivor Space&quot;,&#125; 2.01326592E8</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;G1 Old Gen&quot;,&#125; 2.583691248E9</span><br></pre></td></tr></table></figure><p>说明不是数据源的问题，那就可能是数据采集节点的问题了。</p><p>进入<code>VictoriaMetrics</code> 的 <code>target</code> 页面发现应用确实已经下线，原来是采集的端口不通导致的。</p><blockquote><p>我们使用 VictoriaMetrics 代替了 Prometheus。</p></blockquote><p><img src="https://s2.loli.net/2023/02/19/Hhj6LutlvUsycES.png"></p><p>而这个端口 15020 之前并未使用，我们使用的是另外一个自定义端口和端点来采集数据。</p><p>经过查阅发现 15020 是 istio 默认的端口：<br><img src="https://s2.loli.net/2023/02/19/LjOewSXl5IVPv6q.png"></p><p>原来在默认情况下 Istio 会为所有的数据面 Pod 加上：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">prometheus.io/path:</span> <span class="string">/stats/prometheus</span></span><br><span class="line">    <span class="attr">prometheus.io/port:</span> <span class="string">&quot;15020&quot;</span></span><br></pre></td></tr></table></figure><p>这个注解用于采集数据，由于我们是自定义的端点，所以需要修改默认行为：<br><img src="https://s2.loli.net/2023/02/19/R7v8rG6f2XixlBU.png"></p><p>在控制面将 <code>--set meshConfig.enablePrometheusMerge=false</code> 设置为 false，其实官方文档已经说明，如果不是使用的标准 <code>prometheus.io</code> 注解，需要将这个设置为 false。</p><blockquote><p>修改后需要重建应用 Pod 方能生效。</p></blockquote><p>有了 url 这个 tag 后，接口监控页也恢复了正常。</p><h3 id="接口维度"><a href="#接口维度" class="headerlink" title="接口维度"></a>接口维度</h3><p>接口维度的数据丢失和基本数据丢失的原因类似，本质上也是原始数据中缺少了 url 这个 tag，因为我们所聚合的指标使用了 url：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio.service.source.url.istio_requests_total</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">expr:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        sum(irate(istio_requests_total&#123;reporter=&quot;source&quot;&#125;[1m]))</span></span><br><span class="line"><span class="string">        by (</span></span><br><span class="line"><span class="string">          destination_app,</span></span><br><span class="line"><span class="string">          source_workload_namespace,</span></span><br><span class="line"><span class="string">          response_code,</span></span><br><span class="line"><span class="string">          source_app,</span></span><br><span class="line"><span class="string">          url</span></span><br><span class="line"><span class="string">        )</span></span><br></pre></td></tr></table></figure><p>最终参考了 <a href="https://istio.io/latest/docs/reference/config/proxy_extensions/stats/#MetricConfig">MetricConfig</a> 自定义了 URL 的tag.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;dimensions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;request.url_path&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/19/tERXzV3TI1oe7bJ.png"><br>但这也有个大前提，当我们 tag 的指标没有在默认 tag 列表中时，需要在 Deployment 或者是 Istio 控制面中全局加入我们自定义的 tag 声明。</p><p>比如这里新增了 url 的 tag，那么就需要在控制面中加入：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">meshConfig:</span></span><br><span class="line">  <span class="attr">defaultConfig:</span></span><br><span class="line">    <span class="attr">extraStatTags:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">url</span></span><br></pre></td></tr></table></figure><blockquote><p>修改了控制面后需要重新构建 Pod 后才会生效。</p></blockquote><h2 id="EnvoyFilter的问题"><a href="#EnvoyFilter的问题" class="headerlink" title="EnvoyFilter的问题"></a>EnvoyFilter的问题</h2><p>查看<a href="https://istio.io/latest/docs/reference/config/proxy_extensions/stats/#MetricConfig">MetricConfig</a>的配置后发现是可以直接去掉指标以及去掉指标中的 tag ，这个很有用，能够大大减低指标采集系统 <code>VictoriaMetrics</code> 的系统负载。</p><p>于是参考了官方的示例，去掉了一些 tag，同时还去掉了指标：<code>istio_request_messages_total</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      <span class="attr">&quot;tags_to_remove&quot;:</span> [</span><br><span class="line">        <span class="string">&quot;source_principal&quot;</span>,</span><br><span class="line">        <span class="string">&quot;source_version&quot;</span>,</span><br><span class="line">        <span class="string">&quot;destination_principal&quot;</span>,</span><br><span class="line">        <span class="string">&quot;destination_version&quot;</span>,</span><br><span class="line">        <span class="string">&quot;source_workload&quot;</span>,</span><br><span class="line">        <span class="string">&quot;source_cluster&quot;</span>,</span><br><span class="line">      ]</span><br><span class="line">&#125;<span class="string">,</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;:</span> <span class="string">&quot;istio_request_messages_total&quot;</span>,</span><br><span class="line"><span class="attr">&quot;drop&quot;:</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但并没有生效，于是换成了在 <code>v1.12</code> 中新增的 <code>Telemetry API</code>。</p><h1 id="使用-Telemetry-API"><a href="#使用-Telemetry-API" class="headerlink" title="使用 Telemetry API"></a>使用 Telemetry API</h1><p><img src="https://s2.loli.net/2023/02/19/bN4LiwQZm7rJHXW.png"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">telemetry.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Telemetry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mesh-istio-test</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># no selector specified, applies to all workloads</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">overrides:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">metric:</span> <span class="string">GRPC_REQUEST_MESSAGES</span></span><br><span class="line">            <span class="attr">mode:</span> <span class="string">CLIENT_AND_SERVER</span></span><br><span class="line">          <span class="attr">disabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>但是参考了官方文档后发现依然不能生效，<code>GRPC_REQUEST_MESSAGES</code> 所对应的 <code>istio_request_messages_total</code> 指标依然存在。</p><p>接着在我领导查看 <code>Istio</code> 源码以及相关 <a href="https://github.com/istio/istio/issues/37645">issue</a> 后发现 <code>Telemetry API</code> 和 <code>EnvoyFilter</code> 是不能同时存在的，也就是说会优先使用 <code>EnvoyFilter</code>；这也就是为什么我之前配置没有生效的原因。<br><img src="https://s2.loli.net/2023/02/19/M3uevVscNk5XOTd.png"></p><blockquote><p>后初始化 EnvoyFilter</p></blockquote><p><img src="https://s2.loli.net/2023/02/19/sbkrBdRwULSo9Yg.png"><br>正如这个 issue 中所说，需要删掉现在所有的 EnvoyFilter；删除后果然就生效了。</p><p>新的 <code>Telemetry API</code> 不但语义更加清晰，功能也一样没少，借助他我们依然可以自定义、删除指标、tag 等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">telemetry.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Telemetry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mesh-istio-telemetry-test</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">overrides:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">metric:</span> <span class="string">GRPC_RESPONSE_MESSAGES</span></span><br><span class="line">            <span class="attr">mode:</span> <span class="string">CLIENT_AND_SERVER</span></span><br><span class="line">          <span class="attr">disabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">tagOverrides:</span></span><br><span class="line">            <span class="attr">url:</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;request.url_path&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">metric:</span> <span class="string">ALL_METRICS</span></span><br><span class="line">          <span class="attr">tagOverrides:</span></span><br><span class="line">            <span class="attr">source_workload:</span></span><br><span class="line">              <span class="attr">operation:</span> <span class="string">REMOVE</span></span><br></pre></td></tr></table></figure><p>比如以上配置便可以删除掉 <code>GRPC_RESPONSE_MESSAGES</code> 指标，新增一个 url 的指标，同时在所有指标中删除了 <code>source_workload</code> 这个 tag。</p><p>借助于这一个声明文件便能满足我们多个需求。</p><h2 id="裁剪指标"><a href="#裁剪指标" class="headerlink" title="裁剪指标"></a>裁剪指标</h2><p>后续根据我们实际需求借助于 <code>Telemetry API</code> 裁剪掉了许多指标和 tag，使得指标系统负载下降了一半左右。<br><img src="https://s2.loli.net/2023/02/19/rLqd3lUTgOK9RbS.png"><br>效果相当明显。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次定位修复 <code>Istio</code> 升级后带来的指标系统问题收获巨大，之前对 Istio 一直只停留在理论阶段，只知道他可以实现传统微服务中对接口粒度的控制，完美弥补了 <code>k8s</code> 只有服务层级的粗粒度控制；</p><p>这两周下来对一个现代云原生监控系统也有了系统的认识，从 <code>App-&gt;Pod-&gt;sidecar-&gt;VictoriaMetrics(Prometheus)-&gt;Grafana</code> 这一套流程中每个环节都可能会出错；</p><p>所以学无止境吧，幸好借助公司业务场景后续还有更多机会参与实践。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/19/FwgABGdDrhR4a3j.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间我们将 istio 版本升级到 1.12 后导致现有的应用监控有部分数据丢失（页面上显示不出来）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个是应用基础信息丢失。&lt;/li&gt;
&lt;li&gt;再一个是应用 JVM 数据丢失。&lt;/li&gt;
&lt;li&gt;接口维度的监控数据丢失。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Istio" scheme="http://crossoverjie.top/categories/Istio/"/>
    
    
    <category term="K8s" scheme="http://crossoverjie.top/tags/K8s/"/>
    
    <category term="云原生" scheme="http://crossoverjie.top/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Pulsar负载均衡原理及优化</title>
    <link href="http://crossoverjie.top/2023/02/07/pulsar/pulsar-load-banance/"/>
    <id>http://crossoverjie.top/2023/02/07/pulsar/pulsar-load-banance/</id>
    <published>2023-02-07T00:12:26.000Z</published>
    <updated>2023-02-07T01:38:09.189Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/02/04/d4NqxaoulEXnr5s.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间我们在升级 Pulsar 版本的时候发现升级后最后一个节点始终没有流量。<br><img src="https://s2.loli.net/2023/02/07/ZwQ7sfVhuzb4tyv.jpg"></p><blockquote><p>虽然对业务使用没有任何影响，但负载不均会导致资源的浪费。</p></blockquote><p>和同事沟通后得知之前的升级也会出现这样的情况，最终还是人工调用 Pulsar 的 <code>admin API</code> 完成的负载均衡。</p><p>这个问题我尝试在 Google 和 Pulsar 社区都没有找到类似的，不知道是大家都没碰到还是很少升级集群。</p><blockquote><p>我之前所在的公司就是一个版本走到黑😂</p></blockquote><span id="more"></span><h1 id="Pulsar-负载均衡原理"><a href="#Pulsar-负载均衡原理" class="headerlink" title="Pulsar 负载均衡原理"></a>Pulsar 负载均衡原理</h1><p>当一个集群可以水平扩展后负载均衡就显得非常重要，根本目的是为了让每个提供服务的节点都能均匀的处理请求，不然扩容就没有意义了。</p><p>在分析这个问题的原因之前我们先看看 Pulsar 负载均衡的实现方案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Enable load balancer</span><br><span class="line">loadBalancerEnabled=true</span><br></pre></td></tr></table></figure><p>我们可以通过这个 broker 的这个配置来控制负载均衡器的开关，默认是打开。</p><p>但具体使用哪个实现类来作为负载均衡器也可以在配置文件中指定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Name of load manager to use</span><br><span class="line">loadManagerClassName=org.apache.pulsar.broker.loadbalance.impl.ModularLoadManagerImpl</span><br></pre></td></tr></table></figure><p>默认使用的是 <code>ModularLoadManagerImpl</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> LoadManager <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> PulsarService pulsar)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServiceConfiguration</span> <span class="variable">conf</span> <span class="operator">=</span> pulsar.getConfiguration();</span><br><span class="line">        <span class="comment">// Assume there is a constructor with one argument of PulsarService.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">loadManagerInstance</span> <span class="operator">=</span> Reflections.createInstance(conf.getLoadManagerClassName(),</span><br><span class="line">                Thread.currentThread().getContextClassLoader());</span><br><span class="line">        <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> LoadManager) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> (LoadManager) loadManagerInstance;</span><br><span class="line">            casted.initialize(pulsar);</span><br><span class="line">            <span class="keyword">return</span> casted;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> ModularLoadManager) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModularLoadManagerWrapper</span>((ModularLoadManager) loadManagerInstance);</span><br><span class="line">            casted.initialize(pulsar);</span><br><span class="line">            <span class="keyword">return</span> casted;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Error when trying to create load manager: &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If we failed to create a load manager, default to SimpleLoadManagerImpl.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleLoadManagerImpl</span>(pulsar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>broker</code> 启动时会从配置文件中读取配置进行加载，如果加载失败会使用 <code>SimpleLoadManagerImpl</code> 作为兜底策略。</p><p>当 broker 是一个集群时，只有 leader 节点的 broker 才会执行负载均衡器的逻辑。</p><blockquote><p>Leader 选举是通过 Zookeeper 实现的。</p></blockquote><p>默然情况下成为 Leader 节点的 broker 会每分钟读取各个 broker 的数据来判断是否有节点负载过高需要做重平衡。</p><p>而是否重平衡的判断依据是由 <code>org.apache.pulsar.broker.loadbalance.LoadSheddingStrategy</code> 接口提供的，它其实只有一个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadSheddingStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Recommend that all of the returned bundles be unloaded.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A map from all selected bundles to the brokers on which they reside.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Multimap&lt;String, String&gt; <span class="title function_">findBundlesForUnloading</span><span class="params">(LoadData loadData, ServiceConfiguration conf)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据所有 broker 的负载信息计算出一个需要被 unload 的 broker 以及 bundle。</p><p>这里解释下 unload 和 bundle 的概念：</p><ul><li><code>bundle</code> 是一批 <code>topic</code> 的抽象，将 <code>bundle</code> 和 <code>broker</code> 进行关联后客户端才能知道应当连接哪个 broker；而不是直接将 topic 与 <code>broker</code> 绑定，这样才能实现海量 topic 的管理。</li><li>unload 则是将已经与 broker 绑定的 bundle 手动解绑，从而触发负载均衡器选择一台合适的 broker 重新进行绑定；通常是整个集群负载不均的时候触发。</li></ul><h2 id="ThresholdShedder-原理"><a href="#ThresholdShedder-原理" class="headerlink" title="ThresholdShedder 原理"></a>ThresholdShedder 原理</h2><p><code>LoadSheddingStrategy</code> 接口目前有三个实现，这里以官方默认的 <code>ThresholdShedder</code> 为例：<br><img src="https://s2.loli.net/2023/02/07/9xqNPs31RtHOC2u.jpg"></p><p>它的实现算法是根据带宽、内存、流量等各个指标的权重算出每个节点的负载值，之后为整个集群计算出一个平均负载值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 阈值</span><br><span class="line">loadBalancerBrokerThresholdShedderPercentage=10</span><br></pre></td></tr></table></figure><p>当集群中有某个节点的负载值超过平均负载值达到一定程度（可配置的阈值）时，就会触发 unload，以上图为例就会将最左边节点中红色部分的 bundle 卸载掉，然后再重新计算一个合适的 broker 进行绑定。</p><blockquote><p>阈值存在的目的是为了避免频繁的 unload，从而影响客户端的连接。</p></blockquote><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>当某些 topic 的流量突然爆增的时候这种负载策略确实可以处理的很好，但在我们集群升级的情况就不一定了。</p><p>假设我这里有三个节点：</p><ul><li>broker0</li><li>broker1</li><li>broker2</li></ul><p><img src="https://s2.loli.net/2023/02/07/9fpusPqY8BmkGdl.png"><br>集群升级时会从 <code>broker2-&gt;0</code> 进行镜像替换重启，假设在升级前每个 broker 的负载值都是 10。</p><ul><li>重启 broker2 时，它所绑定的 bundle 被 broker0&#x2F;1 接管。</li><li>升级 broker1 时，它所绑定的 bundle 又被 broker0&#x2F;2 接管。</li><li>最后升级 broker0, 它所绑定的 bundle 会被broker1&#x2F;2 接管。</li></ul><p>只要在这之后没有发生流量激增到触发负载的阈值，那么当前的负载情况就会一直保留下去，也就是 <code>broker0</code> 会一直没有流量。</p><p>经过我反复测试，现象也确实如此。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./pulsar-perf monitor-brokers --connect-string pulsar-test-zookeeper:2181</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/07/nDaOlsMprJ1hCwg.png"><br>通过这个工具也可以查看各个节点的负载情况</p><h1 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h1><p>这种场景是当前 <code>ThresholdShedder</code> 所没有考虑到的，于是我在我们所使用的版本 2.10.3 的基础上做了简单的优化：<br><img src="https://s2.loli.net/2023/02/07/iRkm2FaBz4wtbG6.png"></p><ul><li>当原有逻辑走完之后也没有获取需要需要卸载的 bundle，同时也存在一个负载极低的 broker 时(<code>emptyBundle</code>)，再触发一次 bundle 查询。</li><li>按照 broker 所绑定的数量排序，选择一个数量最多的 broker 的 第一个 bundle 进行卸载。</li></ul><p>修改后打包发布，再走一遍升级流程后整个集群负载就是均衡的了。<br><img src="https://s2.loli.net/2023/02/07/oCYzJBj7xavkLub.jpg"></p><p>但其实这个方案并不严谨，第二步选择的重点是筛选出负载最高的集群中负载最高的 bundle；这里只是简单的根据数量来判断，并不够准确。</p><p>正当我准备持续优化时，鬼使神差的我想看看 master 上有人修复这个问题没，结果一看还真有人修复了；只是还没正式发版。</p><p><a href="https://github.com/apache/pulsar/pull/17456">https://github.com/apache/pulsar/pull/17456</a></p><p><img src="https://s2.loli.net/2023/02/07/7TKxPv8BfblngRc.png"></p><p>整体思路是类似的，只是筛选负载需要卸载 bundle 时是根据 bundle 自身的流量来的，这样会更加精准。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不过看社区的进度等这个优化最终能用还不知道得多久，于是我们就自己参考这个思路在管理台做了类似的功能，当升级后出现负载不均衡时人工触发一个逻辑：</p><ul><li>系统根据各个节点的负载情况计算出一个负载最高的节点和 bundle 在页面上展示。</li><li>人工二次确认是否要卸载，确认无误后进行卸载。</li></ul><p>本质上只是将上述优化的自动负载流程改为人工处理了，经过测试效果是一样的。</p><p>Pulsar 整个项目其实非常庞大，有着几十上百个模块，哪怕每次我只改动一行代码准备发布测试时都得经过漫长的编译+ Docker镜像打包+上传私服这些流程，通常需要1~2个小时；但总的来说收获还是很大的，最近也在提一些 issue 和 PR，希望后面能更深入的参与进社区。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/04/d4NqxaoulEXnr5s.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间我们在升级 Pulsar 版本的时候发现升级后最后一个节点始终没有流量。&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/07/ZwQ7sfVhuzb4tyv.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然对业务使用没有任何影响，但负载不均会导致资源的浪费。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和同事沟通后得知之前的升级也会出现这样的情况，最终还是人工调用 Pulsar 的 &lt;code&gt;admin API&lt;/code&gt; 完成的负载均衡。&lt;/p&gt;
&lt;p&gt;这个问题我尝试在 Google 和 Pulsar 社区都没有找到类似的，不知道是大家都没碰到还是很少升级集群。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我之前所在的公司就是一个版本走到黑😂&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="消息队列" scheme="http://crossoverjie.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="负载均衡" scheme="http://crossoverjie.top/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>2022 年度总结</title>
    <link href="http://crossoverjie.top/2023/01/18/annual-summary/2022/"/>
    <id>http://crossoverjie.top/2023/01/18/annual-summary/2022/</id>
    <published>2023-01-18T00:08:08.000Z</published>
    <updated>2023-01-17T13:00:54.832Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/17/C9tczrjDlwfVqvR.png"></p><p>一转眼 2022 年又过去了，不多不少距离上次写年终总结过去了 365 天；今年的艰难情况想必大家都亲身经历过了；如果要举行卖惨大会的话今年也许我能排的上号。</p><span id="more"></span><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>今年对大家影响最大的事应该都是疫情了，在年底的最后几天家里的老人还是没顶住疫情的冲击离开了，原以为成年后我已经看淡了生老病死，直到我现在敲下这几行字时才发现这么难过。</p><p>悲伤的事暂且不提，还是聊聊今年生活上的好事吧。</p><h2 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h2><p>首先是健身这个我念叨了几年的运动今年终于被我提上了议程。</p><blockquote><p>本质原因是请了私教，果然是花自己的钱才会心疼。</p></blockquote><p><img src="https://s2.loli.net/2023/01/17/ojP8sQXracSHM3u.png"><br><img src="https://s2.loli.net/2023/01/17/LWSkPHGEMf1R2UO.png"></p><p>体重也由巅峰的 75kg 降到了66kg 左右。<br><img src="https://s2.loli.net/2023/01/17/R38tM2FOocjHGxI.png"></p><iframe src="//player.bilibili.com/player.html?aid=685069016&bvid=BV1aU4y1X7Ya&cid=749168314&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>一段视频便能看出差距。</p><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>今年不记得被哪个视频安利了微软的 XGP 服务，冲动下单了 xbox，顺道集齐了御三家的全家桶。<br><img src="https://s2.loli.net/2023/01/17/DzUT7yHYm59iZ2R.jpg"></p><p>不得不说 XGP 服务是真的香，游戏也很多，我玩的最多的就是光环、地平线5、奥日这几款游戏；原以为 xbox 后续会成为我的主力机，直到几个月后我在 tb 奸商那儿购买的 XGP 服务被微软退款后我就没怎么碰了。</p><p>后面老头环上线，也是我唯一一款花钱购买的 xbox 游戏，在被老头环揉拧了几周后手残党也被劝退，一直到现在估计三个月没开过机了。</p><p>不过最近倒还喜欢上玩 Steam 上的一些独立小游戏，特别是肉鸽类型的，比如这个“吸血鬼幸存者”玩着真的非常上头。</p><p><img src="https://s2.loli.net/2023/01/17/6Y7lmhtQRMy2TiU.png"></p><p>当然今年最期待依然是那个带我入主机坑的“塞尔达传说”，恨不得现在马上快进到5月12号发售日。</p><h2 id="世界杯"><a href="#世界杯" class="headerlink" title="世界杯"></a>世界杯</h2><p>今年还有件大事那就是世界杯的召开，真没想到我还会对足球这么感兴趣；因为当时是封控在家远程工作，所以我几乎把凌晨三点场的都看完了。</p><p>那段时间因为离职心情还比较 EMO，感谢世界杯带给了我一个月的快乐时间。</p><p>当然不出意外的在世界杯期间发生了意外。</p><p><img src="https://s2.loli.net/2023/01/17/jUMOHidkxapyRbW.jpg"></p><p>大半夜睡得好好的，眼睛被我老婆的手指甲刨到了，连夜赶往医院，最后就成了“带土”的 cos 低配版。</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>经常都有大佬说三年是在一家公司的敏感时间，如果感觉不到提升那就需要适当的跳出舒适圈，其实我压根没这个打算，但生活总在你没准备好的时候推你一把。</p><p><img src="https://s2.loli.net/2023/01/17/3MGYFZ1fCvLsXBz.png"><br><img src="https://s2.loli.net/2023/01/17/qcZoD2Mr7YX1Ble.jpg"></p><p>由于不可抗力因素，我还是离开了这家我有生以来呆的最开心的一家公司；虽然有许多不舍，但江湖总会相见。</p><p><img src="https://s2.loli.net/2023/01/17/ztTP1F9ChJ23AR8.png"><br><strong>这不我微信里最活跃的依然还是那个群。</strong></p><hr><p>后面我花了一个月的时间把重庆大大小小的公司几乎都看了一遍，甚至还差点去成都工作了；最后阴差阳错的来到了现在的公司做我之前非常向往的基础架构+中间件研发，目前也比较满意。</p><blockquote><p>找工作那段时间也碰到许多有意思的和狗血的事情，年后单独分享。</p></blockquote><h1 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h1><h2 id="GScript"><a href="#GScript" class="headerlink" title="GScript"></a><a href="https://github.com/crossoverJie/gscript">GScript</a></h2><p><img src="https://s2.loli.net/2023/01/17/9O4pzlC6T2ISKkA.png"></p><p>今年个人最满意的就是恶补了编译原理的知识，顺带还做了一个<a href="https://gscript.crossoverjie.top/">脚本语言</a>；现在已经可以拿来编写网站了；也算是一个小目标达成吧。</p><p>回想起开发 gscript 的那段时间，真的是没日没夜的干，每完成一个功能就开心的飞起。</p><h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2><p><img src="https://s2.loli.net/2023/01/17/kHa4Demu15OiytE.png"><br>除此之外在来到现在这家公司后接触了大量 k8s 相关的知识点，也算是把之前学到的理论实践上了；这不昨晚上才在生产环境升级了 Pulsar，这个技能树终于点亮了一些叶子节点。</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p><img src="https://s2.loli.net/2023/01/17/q3CLIhWoM8yEtGY.png"><br><img src="https://s2.loli.net/2023/01/17/hSxHZDsEArRFow1.png"></p><p>今年的技术博客产出居然 23 篇，其中大部分都是和编译原理相关的，也是我一步步学习编译原理到实现脚本语言的过程。</p><hr><p><img src="https://s2.loli.net/2023/01/17/mEPTMByJIAKaiwX.png"><br>同时今年也养成了每日看一篇英文博客的习惯，坚持了几个月效果还是很明显的；比如以前我非常排斥看一些英文资料，要么靠一键翻译，要么就直接只看中文内容。</p><p>现在几乎没有这种排斥的感觉了，大部分英文内容也会耐心的阅读完，这点在我订阅了 Pulsar 的开发组邮件后越发明显，明显的能够知道他们在讲些什么，这点与我多年前订阅 Dubbo 社区邮件的感觉完全不同。</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>以上就是整年的流水账式的回顾，又到了经典的保留立 flag 环节。</p><ul><li>首先是健身保持，都说健身是按年算的，希望到今年四月份为期一年的时候能看到健身的痕迹。</li><li>今年好歹的出去玩一玩，比如港澳地区或是日本，念叨几年了。</li><li>工作技术上能够再提交几个 Pulsar 的 PR，最好是能融入社区；混个脸熟。</li><li>云原生和编译原理相关的继续学起来，下半年把 GScript 实现为编写型语言。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/17/C9tczrjDlwfVqvR.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;一转眼 2022 年又过去了，不多不少距离上次写年终总结过去了 365 天；今年的艰难情况想必大家都亲身经历过了；如果要举行卖惨大会的话今年也许我能排的上号。&lt;/p&gt;</summary>
    
    
    
    <category term="annual-summary" scheme="http://crossoverjie.top/categories/annual-summary/"/>
    
    
  </entry>
  
  <entry>
    <title>Pulsar压测及优化</title>
    <link href="http://crossoverjie.top/2023/01/16/pulsar/pulsar-perf-test/"/>
    <id>http://crossoverjie.top/2023/01/16/pulsar/pulsar-perf-test/</id>
    <published>2023-01-16T00:12:26.000Z</published>
    <updated>2023-01-15T09:56:04.199Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/12/tpk3aXFYZ9BPJb8.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这段时间在做 MQ（Pulsar）相关的治理工作，其中一个部分内容关于消息队列的升级，比如：</p><ul><li>一键创建一个测试集群。</li><li>运行一批测试用例，覆盖我们线上使用到的功能，并输出测试报告。</li><li>模拟压测，输出测试结果。</li></ul><p>本质目的就是想直到新版本升级过程中和升级后对现有业务是否存在影响。</p><span id="more"></span><p>一键创建集群和执行测试用例比较简单，利用了 <code>helm</code> 和 <code>k8s client</code> 的 SDK 把整个流程串起来即可。</p><h1 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h1><p>其实稍微麻烦一点的是压测，<code>Pulsar</code> 官方本身是有提供一个压测工具；只是功能相对比较单一，只能对某批 topic 极限压测，最后输出测试报告。<br>最后参考了官方的压测流程，加入了一些实时监控数据，方便分析整个压测过程中性能的变化。</p><h2 id="客户端-timeout"><a href="#客户端-timeout" class="headerlink" title="客户端 timeout"></a>客户端 timeout</h2><p>随着压测过程中的压力增大，比如压测时间和线程数的提高，客户端会抛出发送消息 timeout 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.apache.pulsar.client.api.PulsarClientException$TimeoutException: </span><br><span class="line">The producer pulsar-test-<span class="number">212</span>-<span class="number">20</span> can not send message to the topic persistent:<span class="comment">//my-tenant/my-ns/perf-topic-0 within given timeout : createdAt 82.964 seconds ago, firstSentAt 8.348 seconds ago, lastSentAt 8.348 seconds ago, retryCount 1</span></span><br></pre></td></tr></table></figure><p>而这个异常在生产业务环境的高峰期偶尔也出现过，这会导致业务数据的丢失；所以正好这次被我复现出来后想着分析下产生的原因以及解决办法。</p><h2 id="源码分析客户端"><a href="#源码分析客户端" class="headerlink" title="源码分析客户端"></a>源码分析客户端</h2><p>既然是客户端抛出的异常所以就先看从异常点开始看起，其实整个过程和产生的原因并不复杂，如下图：</p><p><img src="https://s2.loli.net/2023/01/15/UvNGXC3iz9DjT5k.png"></p><p>客户端流程：</p><ol><li>客户端 producer 发送消息时先将消息发往本地的一个 pending 队列。</li><li>待 broker 处理完（写入 bookkeeper) 返回 ACK 时删除该 pending 队列头的消息。</li><li>后台启动一个定时任务，定期扫描队列头（头部的消息是最后写入的）的消息是否已经过期（过期时间可配置，默认30s)。</li><li>如果已经过期（头部消息过期，说明所有消息都已过期）则遍历队列内的消息依次抛出 <code>PulsarClientException$TimeoutException</code> 异常，最后清空该队列。</li></ol><p>服务端 broker 流程：</p><ol><li>收到消息后调用 bookkeeper API 写入消息。</li><li>写入消息时同时写入回调函数。</li><li>写入成功后执行回调函数，这时会记录一条消息的写入延迟，并通知客户端 ACK。</li><li>通过 broker metric 指标 <code>pulsar_broker_publish_latency</code> 可以获取写入延迟。</li></ol><p>从以上流程可以看出，如果客户端不做兜底措施则在第四步会出现消息丢失，这类本质上不算是 broker 丢消息，而是客户端认为当时 broker 的处理能力达到上限，考虑到消息的实时性从而丢弃了还未发送的消息。</p><h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>通过上述分析，特别是 broker 的写入流程得知，整个写入的主要操作便是写入 bookkeeper，所以 bookkeeper 的写入性能便关系到整个集群的写入性能。</p><p>极端情况下，假设不考虑网络的损耗，如果 <code>bookkeeper</code> 的写入延迟是 0ms，那整个集群的写入性能几乎就是无上限；所以我们重点看看在压测过程中 <code>bookkeeper</code> 的各项指标。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>首先是 CPU：<br><img src="https://s2.loli.net/2023/01/15/Et5urHVQ2xhP6Ja.png"></p><p>从图中可以看到压测过程中 CPU 是有明显增高的，所以我们需要找到压测过程中 bookkeeper 的 CPU 大部分损耗在哪里？</p><p>这里不得不吹一波阿里的 arthas 工具，可以非常方便的帮我们生成火焰图。</p><p><img src="https://s2.loli.net/2023/01/15/QCUTiXjcYeHG3LV.png"></p><p>分析火焰图最简单的一个方法便是查看顶部最宽的函数是哪个，它大概率就是性能的瓶颈。</p><p>在这个图中的顶部并没有明显很宽的函数，大家都差不多，所以并没有明显损耗 CPU 的函数。</p><p>此时在借助云厂商的监控得知并没有得到 CPU 的上限（limit 限制为 8核）。<br><img src="https://s2.loli.net/2023/01/15/8HAkq9ijQNdcFJX.png"></p><hr><p>使用 arthas 过程中也有个小坑，在 k8s 环境中有可能应用启动后没有成功在磁盘写入 pid ，导致查询不到 Java 进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar arthas-boot.jar</span><br><span class="line">[INFO] arthas-boot version: <span class="number">3.6</span><span class="number">.7</span></span><br><span class="line">[INFO] Can not find java process. Try to pass &lt;pid&gt; in command line.</span><br><span class="line">Please select an available pid.</span><br></pre></td></tr></table></figure><p>此时可以直接 <code>ps</code> 拿到进程 <code>ID</code>，然后在启动的时候直接传入 <code>pid</code> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar arthas-boot.jar <span class="number">1</span></span><br></pre></td></tr></table></figure><p>通常情况下这个 <code>pid</code> 是 1。</p><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>既然 CPU 没有问题，那就再看看磁盘是不是瓶颈；</p><p><img src="https://s2.loli.net/2023/01/15/PmMFyefXx23gDwC.png"></p><p>可以看到压测时的 IO 等待时间明显是比日常请求高许多，为了最终确认是否是磁盘的问题，再将磁盘类型换为 SSD 进行测试。</p><p><img src="https://s2.loli.net/2023/01/15/pqnFjJH3zbRkxIV.png"><br>果然即便是压测，SSD磁盘的 IO 也比普通硬盘的正常请求期间延迟更低。</p><p>既然磁盘 IO 延迟降低了，根据前文的分析理论上整个集群的性能应该会有明显的上升，因此对比了升级前后的消息 TPS 写入指标：</p><p><img src="https://s2.loli.net/2023/01/15/xofeW98vVnUzskY.png"></p><p>升级后每秒的写入速率由 40k 涨到 80k 左右，几乎是翻了一倍（果然用钱是最快解决问题的方式）；</p><blockquote><p>但即便是这样，极限压测后依然会出现客户端 timeout，这是因为无论怎么提高服务端的处理性能，依然没法做到没有延迟的写入，各个环节都会有损耗。</p></blockquote><h1 id="升级过程中的-timeout"><a href="#升级过程中的-timeout" class="headerlink" title="升级过程中的 timeout"></a>升级过程中的 timeout</h1><p>还有一个关键的步骤必须要覆盖：模拟生产现场有着大量的生产者和消费者接入收发消息时进行集群升级，对客户端业务的影响。</p><p>根据官方推荐的升级步骤，流程如下：</p><ul><li>Upgrade Zookeeper.</li><li>Disable autorecovery.</li><li>Upgrade Bookkeeper.</li><li>Upgrade Broker.</li><li>Upgrade Proxy.</li><li>Enable autorecovery.</li></ul><p>其中最关键的是升级 Broker 和 Proxy，因为这两个是客户端直接交互的组件。</p><p>本质上升级的过程就是优雅停机，然后使用新版本的 docker 启动；所以客户端一定会感知到 Broker 下线后进行重连，如果能快速自动重连那对客户端几乎没有影响。</p><p><img src="https://s2.loli.net/2023/01/15/1WjaiXs24dTwZ3S.png"><br>在我的测试过程中，2000左右的 producer 以 1k 的发送速率进行消息发送，在 30min 内完成所有组件升级，整个过程客户端会自动快速重连，并不会出现异常以及消息丢失。</p><p>而一旦发送频率增加时，在重启 Broker 的过程中便会出现上文提到的 timeout 异常；初步看起来是在默认的 30s 时间内没有重连成功，导致积压的消息已经超时。</p><p>经过分析源码发现关键的步骤如下：<br><img src="https://s2.loli.net/2023/01/15/V3lZeALxF7vhYHf.png"></p><p>客户端在与 Broker 的长连接状态断开后会自动重连，而重连到具体哪台 Broker 节点是由 <code>LookUpService</code> 处理的，它会根据使用的 topic 获取到它的元数据。</p><blockquote><p>理论上这个过程如果足够快，对客户端就会越无感。</p></blockquote><p>在元数据中包含有该 topic 所属的 bundle 所绑定的  Broker 的具体 IP+端口，这样才能重新连接然后发送消息。</p><blockquote><p>bundle 是一批 topic 的抽象，用来将一批 topic 与 Broker 绑定。</p></blockquote><p>而在一个 Broker 停机的时会自动卸载它所有的 bundle，并由负载均衡器自动划分到在线的 Broker 中，交由他们处理。</p><p>这里会有两种情况降低 LookUpSerive 获取元数据的速度：</p><p>因为所有的 Broker 都是 stateful 有状态节点，所以升级时是从新的节点开始升级，假设是<code>broker-5</code>，假设升级的那个节点的 bundle 切好被转移 <code>broker-4</code>中，客户端此时便会自动重连到 4 这个Broker 中。</p><p>此时客户端正在讲堆积的消息进行重发，而下一个升级的节点正好是 4，那客户端又得等待 bundle 成功 unload 到新的节点，如果恰好是 3 的话那又得套娃了，这样整个消息的重发流程就会被拉长，直到超过等待时间便会超时。</p><p>还有一种情况是 bundle 的数量比较多，导致上面讲到的 unload 时更新元数据到 zookeeper 的时间也会增加。</p><blockquote><p>所以我在考虑 Broker 在升级过程中时，是否可以将 unload 的 bundle 优先与 <code>Broker-0</code>进行绑定，最后全部升级成功后再做一次负载均衡，尽量减少客户端重连的机会。</p></blockquote><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>如果我们想要解决这个 timeout 的异常，也有以下几个方案：</p><ol><li>将 bookkeeper 的磁盘换为写入时延更低的 SSD，提高单节点性能。</li><li>增加 bookkeeper 节点，不过由于 bookkeeper 是有状态的，水平扩容起来比较麻烦，而且一旦扩容再想缩容也比较困难。</li><li>增加客户端写入的超时时间，这个可以配置。</li><li>客户端做好兜底措施，捕获异常、记录日志、或者入库都可以，后续进行消息重发。</li><li>为 bookkeeper 的写入延迟增加报警。</li><li>Spring 官方刚出炉的 Pulsar-starter 已经内置了 producer 相关的 metrics，客户端也可以对这个进行监控报警。</li></ol><p>以上最好实现的就是第四步了，效果好成本低，推荐还没有实现的都尽快 <code>try catch</code> 起来。</p><p>整个测试流程耗费了我一两周的时间，也是第一次全方位的对一款中间件进行测试，其中也学到了不少东西；不管是源码还是架构都对 <code>Pulsar</code> 有了更深入的理解。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/12/tpk3aXFYZ9BPJb8.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这段时间在做 MQ（Pulsar）相关的治理工作，其中一个部分内容关于消息队列的升级，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一键创建一个测试集群。&lt;/li&gt;
&lt;li&gt;运行一批测试用例，覆盖我们线上使用到的功能，并输出测试报告。&lt;/li&gt;
&lt;li&gt;模拟压测，输出测试结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本质目的就是想直到新版本升级过程中和升级后对现有业务是否存在影响。&lt;/p&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="消息队列" scheme="http://crossoverjie.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>模板方法实践</title>
    <link href="http://crossoverjie.top/2022/12/27/desigin-patterns/template-method/"/>
    <id>http://crossoverjie.top/2022/12/27/desigin-patterns/template-method/</id>
    <published>2022-12-27T00:08:08.000Z</published>
    <updated>2023-01-12T06:36:40.276Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/12/TG3RQnjKDOc7vaF.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近不出意外的阳了，加上刚入职新公司不久，所以也没怎么更新；这两天好些后分享一篇前段时间的一个案例：</p><p>最近在设计一个对某个中间件的测试方案，这个测试方案需要包含不同的测试逻辑，但相同的是需要对各个环节进行记录；比如统计耗时、调用通知 API 等相同的逻辑。</p><p>如果每个测试都单独写这些逻辑那无疑是做了许多重复工作了。</p><span id="more"></span><p>基于以上的特征很容易能想到<strong>模板方法</strong>这个设计模式。</p><p>这是一种有上层定义框架，下层提供不同实现的设计模式。</p><p>比如装修房子的时候业主可以按照自己的喜好对不同的房间进行装修，但是整体的户型图不能做修改，比如承重墙是肯定不能打的。</p><p>而这些固定好的条条框框就是上层框架给的约束，下层不同的实现就有业主自己决定；所以对于整栋楼来说框架都是固定好的，让业主在有限的范围内自由发挥也方便物业的管理。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>以我这个案例的背景为例，首先需要定义出上层框架：</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><code>Event</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Event</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增一个任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addJob</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个任务执行完毕</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobName    任务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> finishCost 任务完成耗时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">finishOne</span><span class="params">(String jobName, String finishCost)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**单个任务执行异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobDefine 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">oneException</span><span class="params">(AbstractJobDefine jobDefine, Exception e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有任务执行完毕</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">finishAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    event.addJob();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="type">StopWatch</span> <span class="variable">watch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                watch.start(jobName);</span><br><span class="line">                <span class="comment">// 不同的子业务实现</span></span><br><span class="line">                run(client);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                event.oneException(<span class="built_in">this</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                watch.stop();</span><br><span class="line">                event.finishOne(jobName, StrUtil.format(<span class="string">&quot;cost: &#123;&#125;s&quot;</span>, watch.getTotalTimeSeconds()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, TestCase.EXECUTOR).get(timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        event.oneException(<span class="built_in">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Run busy code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception e</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Client client)</span> <span class="keyword">throws</span> Exception;    </span><br></pre></td></tr></table></figure><p>其中最核心的就是 run 函数，它是一个抽象函数，具体实现交由子类完成；这样不同的测试用例之间也互不干扰，同时整体的流程完全相同：</p><ul><li>记录任务数量</li><li>统计耗时</li><li>异常记录</li></ul><p>等流程。</p><hr><p>接下来看看如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test1</span>(event, <span class="string">&quot;测试1&quot;</span>, client, <span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; c1 = CompletableFuture.runAsync(job1::start, EXECUTOR);</span><br><span class="line"></span><br><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test2</span>(event, <span class="string">&quot;测试2&quot;</span>, client, <span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; c2 = CompletableFuture.runAsync(job2::start, EXECUTOR);</span><br><span class="line"></span><br><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test3</span>(event, <span class="string">&quot;测试3&quot;</span>, client, <span class="number">20</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; c3 = CompletableFuture.runAsync(job3::start, EXECUTOR);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(c1, c2, c3);</span><br><span class="line">all.whenComplete((___, __) -&gt; &#123;</span><br><span class="line">    event.finishAll();</span><br><span class="line">    client.close();</span><br><span class="line">&#125;).get();</span><br></pre></td></tr></table></figure><p>显而易见 <code>Test1~3</code> 都继承了 <code>AbstractJobDefine</code> 同时实现了其中的 <code>run</code> 函数，使用的时候只需要创建不同的实例等待他们都执行完成即可。</p><p>以前在 Java 中也有不同的应用：<br><img src="https://s2.loli.net/2023/01/12/dRl4DEIXj1BfNZ2.png"></p><p><a href="https://crossoverjie.top/2019/03/01/algorithm/consistent-hash/?highlight=%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95">https://crossoverjie.top/2019/03/01/algorithm/consistent-hash/?highlight=%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95</a></p><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><p>同样的示例用 Go 自然也可以实现：</p><p><img src="https://s2.loli.net/2023/01/12/Eu6OUrb7jGtLozN.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJobDefine_start</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">event := NewEvent()</span><br><span class="line">j1 := &amp;JobDefine&#123;</span><br><span class="line">Event:   event,</span><br><span class="line">Run:     &amp;run1&#123;&#125;,</span><br><span class="line">JobName: <span class="string">&quot;job1&quot;</span>,</span><br><span class="line">Param1:  <span class="string">&quot;p1&quot;</span>,</span><br><span class="line">Param2:  <span class="string">&quot;p2&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">j2 := &amp;JobDefine&#123;</span><br><span class="line">Event:   event,</span><br><span class="line">Run:     &amp;run2&#123;&#125;,</span><br><span class="line">JobName: <span class="string">&quot;job2&quot;</span>,</span><br><span class="line">Param1:  <span class="string">&quot;p11&quot;</span>,</span><br><span class="line">Param2:  <span class="string">&quot;p22&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">j1.Start()</span><br><span class="line">j2.Start()</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> event.GetChan() &#123;</span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;finish all&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *run2)</span></span> Run(param1, param2 <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;run3 param1:%s, param2:%s&quot;</span>, param1, param2)</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;test err&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *run1)</span></span> Run(param1, param2 <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;run1 param1:%s, param2:%s&quot;</span>, param1, param2)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用起来也与 Java 类似，创建不同的实例；最后等待所有的任务执行完毕。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>设计模式往往是对某些共性能力的抽象，但也没有一个设计模式可以适用于所有的场景；需要对不同的需求选择不同的设计模式。</p><p>至于在工作中如何进行正确的选择，那就需要自己日常的积累了；比如多去了解不同的设计模式对于的场景，或者多去阅读优秀的代码，Java 中的 <code>InputStream/Reader/Writer</code> 这类 IO 相关的类都有具体的应用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/12/TG3RQnjKDOc7vaF.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近不出意外的阳了，加上刚入职新公司不久，所以也没怎么更新；这两天好些后分享一篇前段时间的一个案例：&lt;/p&gt;
&lt;p&gt;最近在设计一个对某个中间件的测试方案，这个测试方案需要包含不同的测试逻辑，但相同的是需要对各个环节进行记录；比如统计耗时、调用通知 API 等相同的逻辑。&lt;/p&gt;
&lt;p&gt;如果每个测试都单独写这些逻辑那无疑是做了许多重复工作了。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://crossoverjie.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="http://crossoverjie.top/tags/Java/"/>
    
    <category term="Go" scheme="http://crossoverjie.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>深入理解闭包实现原理</title>
    <link href="http://crossoverjie.top/2022/10/24/gscript/gscript11-closure/"/>
    <id>http://crossoverjie.top/2022/10/24/gscript/gscript11-closure/</id>
    <published>2022-10-24T00:08:09.000Z</published>
    <updated>2023-01-14T10:21:02.877Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/14/QnYTwcpIxEH5WOm.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>闭包对于一个长期写 <code>Java</code> 的开发者来说估计鲜有耳闻，我在写 <code>Python</code> 和 <code>Go</code> 之前也是没怎么了解，光这名字感觉就有点”神秘莫测”，这篇文章的主要目的就是从编译器的角度来分析闭包，彻底搞懂闭包的实现原理。</p><span id="more"></span><h1 id="函数一等公民"><a href="#函数一等公民" class="headerlink" title="函数一等公民"></a>函数一等公民</h1><p>一门语言在实现闭包之前首先要具有的特性就是：<code>First class function</code> 函数是第一公民。</p><p>简单来说就是函数可以像一个普通的值一样在函数中传递，也能对变量赋值。</p><p>先来看看在 Go 里是如何编写的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> varExternal <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">varInner := <span class="number">20</span></span><br><span class="line">innerFun := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">varExternal++</span><br><span class="line">varInner++</span><br><span class="line"><span class="keyword">return</span> varInner</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> innerFun</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">varExternal = <span class="number">10</span></span><br><span class="line">f2 := f1()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;varInner=%d, varExternal=%d \n&quot;</span>, f2(i), varExternal)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;======&quot;</span>)</span><br><span class="line"></span><br><span class="line">f3 := f1()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;varInner=%d, varExternal=%d \n&quot;</span>, f3(i), varExternal)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">varInner=<span class="number">21</span>, varExternal=<span class="number">11</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line">varInner=<span class="number">22</span>, varExternal=<span class="number">12</span> </span><br><span class="line">======</span><br><span class="line"><span class="number">0</span></span><br><span class="line">varInner=<span class="number">21</span>, varExternal=<span class="number">13</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line">varInner=<span class="number">22</span>, varExternal=<span class="number">14</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里体现了闭包的两个重要特性，第一个自然就是函数可以作为值返回，同时也能赋值给变量。</p><p>第二个就是在闭包函数 <code>f1()</code> 对闭包变量 <code>varInner</code> 的访问，每个闭包函数的引用都会在自己的函数内部保存一份闭包变量 <code>varInner</code>，这样在调用过程中就不会互相影响。</p><p>从打印的结果中也能看出这个特性。</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>闭包之所以不太好理解的主要原因是它不太符合自觉。</p><p><img src="https://s2.loli.net/2023/01/14/FwMJpUvdPgyhCNY.png"></p><p>本质上就是作用域的关系，当我们调用 <code>f1()</code> 函数的时候，会在栈中分配变量 <code>varInner</code>，正常情况下调用完毕后 <code>f1</code> 的栈会弹出，里面的变量 <code>varInner</code> 自然也会销毁才对。</p><p>但在后续的 <code>f2()</code> 和 <code>f3()</code> 调用的时，却依然能访问到 <code>varInner</code>，就这点不符合我们对函数调用的直觉。</p><p>但其实换个角度来看，对 <code>innerFun</code> 来说，他能访问到 <code>varExternal</code> 和 <code>varInner</code> 变量，最外层的 <code>varExternal</code> 就不用说了，一定是可以访问的。</p><p>但对于 <code>varInner</code> 来说就不一定了，这里得分为两种情况；重点得看该语言是<strong>静态&#x2F;动态</strong>作用域。</p><p>就静态作用域来说，每个符号在编译器就确定好了树状关系，运行时不会发生变化；也就是说 <code>varInner</code> 对于 <code>innerFun</code> 这个函数来说在编译期已经确定可以访问了，在运行时自然也是可以访问的。</p><p>但对于动态作用域来说，完全是在运行时才确定访问的变量是哪一个。</p><p>恰好 <code>Go</code> 就是一个静态作用域的语言，所以返回的 <code>innerFun</code> 函数可以一直访问到 <code>varInner</code> 变量。</p><h1 id="实现闭包"><a href="#实现闭包" class="headerlink" title="实现闭包"></a>实现闭包</h1><p>但 Go 是如何做到在 <code>f1()</code> 函数退出之后依然能访问到 <code>f1()</code> 中的变量呢？</p><p>这里我们不妨大胆假设一下：</p><p>首先在编译期扫描出哪些是闭包变量，也就是这里的 <code>varInner</code>，需要将他保存到函数 <code>innerFun()</code> 中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f2 := f1()</span><br><span class="line">f2()</span><br></pre></td></tr></table></figure><p>运行时需要判断出 <code>f2</code> 是一个函数，而不是一个变量，同时得知道它所包含的函数体是 <code>innerFun()</code> 所定义的。</p><p>接着便是执行函数体的 <code>statement</code> 即可。</p><p>而当 <code>f3 := f1()</code> 重新赋值给 <code>f3</code> 时，在 <code>f2</code> 中累加的 <code>varInner</code> 变量将不会影响到 <code>f3</code>，这就得需要在给 <code>f3</code> 赋值的重新赋值一份闭包变量到  <code>f3</code> 中，这样便能达到互不影响的效果。</p><h2 id="闭包扫描"><a href="#闭包扫描" class="headerlink" title="闭包扫描"></a>闭包扫描</h2><p><code>GScript</code> 本身也是支持闭包的，所以把 Go 的代码翻译过来便长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">varExternal</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f1()&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">varInner</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">innerFun</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">println(a);</span><br><span class="line"><span class="type">int</span> c=<span class="number">100</span>;</span><br><span class="line">varExternal++;</span><br><span class="line">varInner++;</span><br><span class="line"><span class="keyword">return</span> varInner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> innerFun;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f2 = f1();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">println(<span class="string">&quot;varInner=&quot;</span> + f2(i) + <span class="string">&quot;, varExternal=&quot;</span> + varExternal);</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;=======&quot;</span>);</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f3 = f1();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">println(<span class="string">&quot;varInner=&quot;</span> + f3(i) + <span class="string">&quot;, varExternal=&quot;</span> + varExternal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">varInner=<span class="number">21</span>, varExternal=<span class="number">11</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">varInner=<span class="number">22</span>, varExternal=<span class="number">12</span></span><br><span class="line">=======</span><br><span class="line"><span class="number">0</span></span><br><span class="line">varInner=<span class="number">21</span>, varExternal=<span class="number">13</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">varInner=<span class="number">22</span>, varExternal=<span class="number">14</span></span><br></pre></td></tr></table></figure><p>可以看到运行结果和 Go 的一样，所以我们来看看 <code>GScript</code> 是如何实现的便也能理解 Go 的原理了。</p><hr><p>先来看看第一步扫描闭包变量：<br><img src="https://s2.loli.net/2023/01/14/uMxlDhkrs1g9zoT.png"></p><p><code>allVariable := c.allVariable(function)</code><br>查询所有的变量，包括父 <code>scope</code> 的变量。</p><p><code>scopeVariable := c.currentScopeVariable(function)</code><br>查询当前 <code>scope</code> 包含下级所有 <code>scope</code> 中的变量，这样一减之后就能知道闭包变量了，然后将所有的闭包变量存放进闭包函数中。</p><h2 id="闭包赋值"><a href="#闭包赋值" class="headerlink" title="闭包赋值"></a>闭包赋值</h2><p><img src="https://s2.loli.net/2023/01/14/tLBOHCpdwfYj7DX.png"><br>之后在 <code>return innerFun</code> 处，将闭包变量的数据赋值到变量中。</p><p><img src="https://s2.loli.net/2023/01/14/2jf6kYVHXBvbmNo.png"></p><h2 id="闭包函数调用"><a href="#闭包函数调用" class="headerlink" title="闭包函数调用"></a>闭包函数调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f2 = f1();</span><br><span class="line"></span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f3 = f1();</span><br></pre></td></tr></table></figure><p>在这里每一次赋值时，都会把 <code>f1()</code> 返回函数复制到变量 <code>f2/f3</code> 中，这样两者所包含的闭包变量就不会互相影响。</p><hr><p><img src="https://s2.loli.net/2023/01/14/OmlVzJLASZpEP73.png"><br>在调用函数变量时，判断到该变量是一个函数，则直接返回函数。</p><p>之后直接调用该函数即可。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>接下来便可以利用 <code>First class function</code> 来试试函数式编程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="type">int</span> value=<span class="number">0</span>;</span><br><span class="line">Test(<span class="type">int</span> v)&#123;</span><br><span class="line">value=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">map</span><span class="params">(func <span class="type">int</span>(<span class="type">int</span>)</span> f)&#123;</span><br><span class="line"><span class="keyword">return</span> f(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> v*v; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> v++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add2</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">v=v+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> v; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span>Test(<span class="number">100</span>);</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> s= square;</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> a= add;</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> a2= add2;</span><br><span class="line">println(t.map(s));</span><br><span class="line">assertEqual(t.map(s),<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">println(t.map(a));</span><br><span class="line">assertEqual(t.map(a),<span class="number">101</span>);</span><br><span class="line"></span><br><span class="line">println(t.map(a2));</span><br><span class="line">assertEqual(t.map(a2),<span class="number">102</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个有点类似于 Java 中流的 map 函数，将函数作为值传递进去，后续支持匿名函数后会更像是函数式编程，现在必须得先定义一个函数变量再进行传递。</p><hr><p>除此之外在 <code>GScript</code> 中的 <code>http</code> 标准库也利用了函数是一等公民的特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准库：Bind route</span></span><br><span class="line">httpHandle(string method, string path, func (HttpContext) handle)&#123;</span><br><span class="line">    <span class="type">HttpContext</span> <span class="variable">ctx</span> <span class="operator">=</span> HttpContext();</span><br><span class="line">    handle(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在绑定路由时，<code>handle</code> 便是一个函数，使用的时候直接传递业务逻辑的 <code>handle</code> 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (HttpContext) handle (HttpContext ctx)&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> Person();</span><br><span class="line">    p.name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    println(<span class="string">&quot;p.name=&quot;</span> + p.name);</span><br><span class="line">    println(<span class="string">&quot;ctx=&quot;</span> + ctx);</span><br><span class="line">    ctx.JSON(<span class="number">200</span>, p);</span><br><span class="line">&#125;</span><br><span class="line">httpHandle(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;/p&quot;</span>, handle);</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说闭包具有以下特性：</p><ul><li>函数需要作为一等公民。</li><li>编译期扫描出所有的闭包变量。</li><li>在返回闭包函数时，为闭包变量赋值。</li><li>每次创建新的函数变量时，需要将闭包数据复制进去，这样闭包变量才不会互相影响。</li><li>调用函数变量时，需要判断为函数，而不是变量。</li></ul><p><img src="https://s2.loli.net/2023/01/14/y2zhcrXgWJbODju.png"><br>可以在 <a href="https://gscript.crossoverjie.top/">Playground</a> 中体验闭包函数打印裴波那切数列的运用。</p><p>本文相关资源链接</p><ul><li><p>GScript 源码：<a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p></li><li><p>Playground 源码：<a href="https://github.com/crossoverJie/gscript-homepage">https://github.com/crossoverJie/gscript-homepage</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/14/QnYTwcpIxEH5WOm.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;闭包对于一个长期写 &lt;code&gt;Java&lt;/code&gt; 的开发者来说估计鲜有耳闻，我在写 &lt;code&gt;Python&lt;/code&gt; 和 &lt;code&gt;Go&lt;/code&gt; 之前也是没怎么了解，光这名字感觉就有点”神秘莫测”，这篇文章的主要目的就是从编译器的角度来分析闭包，彻底搞懂闭包的实现原理。&lt;/p&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="闭包" scheme="http://crossoverjie.top/tags/%E9%97%AD%E5%8C%85/"/>
    
    <category term="closure" scheme="http://crossoverjie.top/tags/closure/"/>
    
  </entry>
  
  <entry>
    <title>如何为 GScript 编写标准库</title>
    <link href="http://crossoverjie.top/2022/10/15/gscript/gscript10-write-native-lib/"/>
    <id>http://crossoverjie.top/2022/10/15/gscript/gscript10-write-native-lib/</id>
    <published>2022-10-15T00:08:09.000Z</published>
    <updated>2023-01-17T09:10:55.342Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/17/Ig7svqZCcPB9FuU.png"></p><h1 id="版本更新"><a href="#版本更新" class="headerlink" title="版本更新"></a>版本更新</h1><p>最近 <code>GScript</code> 更新了 <code>v0.0.11</code> 版本，重点更新了：</p><ul><li><code>Docker</code> 运行环境</li><li>新增了 byte 原始类型</li><li>新增了一些字符串标准库 <code>Strings/StringBuilder</code></li><li>数组切片语法：<code>int[] b = a[1: len(a)];</code></li></ul><blockquote><p>具体更新内容请看下文。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间发布了 <code>GScript</code> 的在线 <code>playground</code>，<br><img src="https://s2.loli.net/2023/01/17/RmTtoqbxPipOgKj.gif"></p><span id="more"></span><p>这是一个可以在线运行 <code>GScript</code> 脚本的网站，其本质原理是接收用户的输入源码从而在服务器上运行的服务；这简直就是后门大开的 <code>XSS</code> 攻击，为保住服务器我设置了运行 <code>API</code> 的后端服务的用户权限，这样可以避免执行一些恶意的请求。</p><p>但也避免不了一些用户执行了一些耗时操作，比如一个死循环、或者是我提供 <code>demo</code> 里的打印杨辉三角。<br><img src="https://s2.loli.net/2023/01/17/LR7EAtxQnB42Wf9.png"></p><p>这本质上是一个递归函数，当打印的三角层数过高时便会非常耗时，同时也非常消耗 CPU。</p><p>有几次我去检查服务器时发现了几个 CPU 过高的进程，基本上都是这样的耗时操作，不可避免的会影响到服务器的性能。</p><h1 id="使用-Docker"><a href="#使用-Docker" class="headerlink" title="使用 Docker"></a>使用 Docker</h1><p>为了解决这类问题，很自然的就能想到可以使用 <code>Docker</code>，所有的资源都和宿主机是隔离开的，无论怎么瞎折腾也不会影响到宿主机。</p><p>说干就干，最后修改了 API 执行脚本的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> <span class="variable">fileName</span> <span class="operator">=</span> d.unix(<span class="string">&quot;Asia/Shanghai&quot;</span>) + <span class="string">&quot;temp.gs&quot;</span> ;</span><br><span class="line">s.writeFile(fileName, body, <span class="number">438</span>);</span><br><span class="line"><span class="type">string</span> <span class="variable">pwd</span> <span class="operator">=</span> s.getwd();</span><br><span class="line"><span class="comment">// string res = s.command(&quot;gscript&quot;, fileName);</span></span><br><span class="line"><span class="type">string</span> <span class="variable">res</span> <span class="operator">=</span> s.command(<span class="string">&quot;docker&quot;</span>,<span class="string">&quot;run&quot;</span>,<span class="string">&quot;--rm&quot;</span>,<span class="string">&quot;-v&quot;</span>, pwd+<span class="string">&quot;:/usr/src/gscript&quot;</span>,<span class="string">&quot;-w&quot;</span>,<span class="string">&quot;/usr/src/gscript&quot;</span>, <span class="string">&quot;crossoverjie/gscript&quot;</span>,<span class="string">&quot;gscript&quot;</span>, fileName);</span><br><span class="line">s.remove(fileName);</span><br><span class="line">r.body = res;</span><br><span class="line">r.ast = dumpAST(body);</span><br><span class="line">r.symbol=dumpSymbol(body);</span><br><span class="line">ctx.JSON(<span class="number">200</span>, r);</span><br></pre></td></tr></table></figure><p>主要修改的就是将直接执行的 <code>GScript</code> 命令修改为了调用 <code>docker</code> 执行。</p><blockquote><p>但其实也还有改进空间，后续新增协程之后可以便可监控运行时间，超时后便会自动 kill 进程。</p></blockquote><p>我也将该 <code>Docker</code> 上传到了 <code>DockerHub</code>，现在大家想在本地体验 <code>GScript</code> 的 <code>REPL</code> 时也只需要运行<code>Docker</code> 就能使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull crossoverjie/gscript</span><br><span class="line">docker run --rm -it  crossoverjie/gscript:latest gscript</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/17/sg67rJAc4BafouI.png"></p><p>当然也可以执行用 <code>Docker</code> 执行 <code>GScript</code> 脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -v $PWD:/usr/src/gscript -w /usr/src/gscript crossoverjie/gscript gscript &#123;yourpath&#125;/temp.gs</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h76194c45pj320g0ee41b.jpg"></p><h1 id="编写-GScript-标准库"><a href="#编写-GScript-标准库" class="headerlink" title="编写 GScript 标准库"></a>编写 GScript 标准库</h1><p>接下来重点聊聊 <code>GScript</code> 标准库的事情，其实编写标准库是一个费时费力的事情。<br><img src="https://s2.loli.net/2023/01/17/oKnZq5mDPpkF7Ix.png"><br>现在编译器已经提供了一些可用的内置函数，借由这些内置函数写一些常见的工具类是完全没有问题的。</p><p>对写 <code>GScript</code> 标准库感谢的朋友可以当做一个参考，这里我打了一个样，先看下运行效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串工具类</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">b</span> <span class="operator">=</span> StringBuilder();</span><br><span class="line">b.writeString(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">b.writeString(<span class="string">&quot;20&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> b.writeString(<span class="string">&quot;30&quot;</span>);</span><br><span class="line"><span class="type">string</span> <span class="variable">s</span> <span class="operator">=</span> b.String();</span><br><span class="line">printf(<span class="string">&quot;s:%s, len=%d &quot;</span>,s,l);</span><br><span class="line">assertEqual(s,<span class="string">&quot;102030&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] b2 = toByteArray(<span class="string">&quot;40&quot;</span>);</span><br><span class="line">b.WriteBytes(b2);</span><br><span class="line">s = b.String();</span><br><span class="line">assertEqual(s,<span class="string">&quot;10203040&quot;</span>);</span><br><span class="line">println(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Strings 工具类</span></span><br><span class="line"><span class="type">Strings</span> <span class="variable">s</span> <span class="operator">=</span> Strings();</span><br><span class="line">string[] elems = &#123;<span class="string">&quot;name=xxx&quot;</span>,<span class="string">&quot;age=xx&quot;</span>&#125;;</span><br><span class="line"><span class="type">string</span> <span class="variable">ret</span> <span class="operator">=</span> s.join(elems, <span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">println(ret);</span><br><span class="line">assertEqual(ret, <span class="string">&quot;name=xxx&amp;age=xx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="variable">b</span> <span class="operator">=</span> s.hasPrefix(<span class="string">&quot;http://www.xx.com&quot;</span>, <span class="string">&quot;http&quot;</span>);</span><br><span class="line">println(b);</span><br><span class="line">assertEqual(b,<span class="literal">true</span>);</span><br><span class="line">b = s.hasPrefix(<span class="string">&quot;http://www.xx.com&quot;</span>, <span class="string">&quot;https&quot;</span>);</span><br><span class="line">println(b);</span><br><span class="line">assertEqual(b,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>其中的实现源码基本上是借鉴了 Go 的标准库，先来看看 <code>StringBuilder</code> 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringBuilder</span>&#123;</span><br><span class="line">    <span class="type">byte</span>[] buf = [<span class="number">0</span>]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// append contents to buf, it returns the length of s</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">writeString</span><span class="params">(string s)</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] temp = toByteArray(s);</span><br><span class="line">        append(buf, temp);</span><br><span class="line">        <span class="keyword">return</span> len(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// append b to buf, it returns the length of b.</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">WriteBytes</span><span class="params">(<span class="type">byte</span>[] b)</span>&#123;</span><br><span class="line">        append(buf, b);</span><br><span class="line">        <span class="keyword">return</span> len(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copies the buffer to a new.</span></span><br><span class="line">    grow(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// when there is not enough space left.</span></span><br><span class="line">            <span class="keyword">if</span> (cap(buf) - len(buf) &lt; n) &#123;</span><br><span class="line">                <span class="type">byte</span>[] newBuf = [len(buf), <span class="number">2</span>*cap(buf)+n]&#123;&#125;;</span><br><span class="line">                copy(newBuf, buf);</span><br><span class="line">                buf = newBuf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string <span class="title function_">String</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是借助了原始的数组类型以及 <code>toByteArray/toString</code> 字节数组和字符串的转换函数实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Strings</span>&#123;</span><br><span class="line">    <span class="comment">// concatenates the elements of its first argument to create a single string. The separator</span></span><br><span class="line">    <span class="comment">// string sep is placed between elements in the resulting string.</span></span><br><span class="line">    string <span class="title function_">join</span><span class="params">(string[] elems, string sep)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len(elems) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len(elems) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> elems[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">byte</span>[] bs = toByteArray(sep);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> len(bs) * (len(elems) -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; len(elems); i++) &#123;</span><br><span class="line">            <span class="type">string</span> <span class="variable">s</span> <span class="operator">=</span> elems[i];</span><br><span class="line">            <span class="type">byte</span>[] bs = toByteArray(s);</span><br><span class="line">            n = n + len(bs);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> StringBuilder();</span><br><span class="line">        sb.grow(n);</span><br><span class="line">        <span class="type">string</span> <span class="variable">first</span> <span class="operator">=</span> elems[<span class="number">0</span>];</span><br><span class="line">        sb.writeString(first);</span><br><span class="line"></span><br><span class="line">        string[] remain = elems[<span class="number">1</span>:len(elems)];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; len(remain); i++)&#123;</span><br><span class="line">            sb.writeString(sep);</span><br><span class="line">            <span class="type">string</span> <span class="variable">r</span> <span class="operator">=</span> remain[i];</span><br><span class="line">            sb.writeString(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.String();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// tests whether the string s begins with prefix.</span></span><br><span class="line">    bool <span class="title function_">hasPrefix</span><span class="params">(string s, string prefix)</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toByteArray(s);</span><br><span class="line">        <span class="type">byte</span>[] bp = toByteArray(prefix);    </span><br><span class="line">        <span class="keyword">return</span> len(bs) &gt;= len(bp) &amp;&amp; toString(bs[<span class="number">0</span>:len(bp)]) == prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Strings</code> 工具类也是类似的，都是一些内置函数的组合运用；</p><p>在写标准库的过程中还会有额外收获，可以再次阅读一遍 Go 标准库的实现流程，换了一种语法实现出来，会加深对 Go 标准库的理解。</p><p>所以欢迎感兴趣的朋友向 <code>GScript</code> 贡献标准库，由于我个人精力有限，实现过程中可能会发现缺少某些内置函数或数据结构，这也没关系，反馈 <code>issue</code> 后我会尽快处理。</p><blockquote><p>由于目前 <code>GScript</code> 还不支持包管理，所以新增的函数可以创建 <code>Class</code> 来实现，后续支持包或者是 <code>namespace</code> 之后直接将该 <code>Class</code> 迁移过去即可。</p></blockquote><hr><p>本文相关资源链接</p><ul><li>GScript 源码：<a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></li><li>Playground 源码：<a href="https://github.com/crossoverJie/gscript-homepage">https://github.com/crossoverJie/gscript-homepage</a></li><li>GScript Docker地址：<a href="https://hub.docker.com/r/crossoverjie/gscript">https://hub.docker.com/r/crossoverjie/gscript</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/17/Ig7svqZCcPB9FuU.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;版本更新&quot;&gt;&lt;a href=&quot;#版本更新&quot; class=&quot;headerlink&quot; title=&quot;版本更新&quot;&gt;&lt;/a&gt;版本更新&lt;/h1&gt;&lt;p&gt;最近 &lt;code&gt;GScript&lt;/code&gt; 更新了 &lt;code&gt;v0.0.11&lt;/code&gt; 版本，重点更新了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Docker&lt;/code&gt; 运行环境&lt;/li&gt;
&lt;li&gt;新增了 byte 原始类型&lt;/li&gt;
&lt;li&gt;新增了一些字符串标准库 &lt;code&gt;Strings/StringBuilder&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数组切片语法：&lt;code&gt;int[] b = a[1: len(a)];&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;具体更新内容请看下文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间发布了 &lt;code&gt;GScript&lt;/code&gt; 的在线 &lt;code&gt;playground&lt;/code&gt;，&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/17/RmTtoqbxPipOgKj.gif&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
  </entry>
  
</feed>
