<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverJie&#39;s Blog</title>
  
  <subtitle>baller</subtitle>
  <link href="http://crossoverjie.top/atom.xml" rel="self"/>
  
  <link href="http://crossoverjie.top/"/>
  <updated>2024-07-15T14:03:51.478Z</updated>
  <id>http://crossoverjie.top/</id>
  
  <author>
    <name>crossoverJie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式系统如何做负载均衡</title>
    <link href="http://crossoverjie.top/2024/07/15/ob/Pulsar-loadbalance/"/>
    <id>http://crossoverjie.top/2024/07/15/ob/Pulsar-loadbalance/</id>
    <published>2024-07-15T02:22:14.000Z</published>
    <updated>2024-07-15T14:03:51.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Pulsar 有提供一个查询 Broker 负载的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get load for this broker.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> PulsarAdminException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">LoadManagerReport <span class="title function_">getLoadReport</span><span class="params">()</span> <span class="keyword">throws</span> PulsarAdminException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadManagerReport</span> <span class="keyword">extends</span> <span class="title class_">ServiceLookupData</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getCpu</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getMemory</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getDirectMemory</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getBandwidthIn</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getBandwidthOut</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以返回一些 broker 的负载数据，比如 CPU、内存、流量之类的数据。</p><span id="more"></span><blockquote><p>我目前碰到的问题是目前会遇到部分节点的负债不平衡，导致资源占用不均衡，所以想要手动查询所有节点的负载数据，然后人工进行负载。</p></blockquote><p>理论上这些数据是在运行时实时计算的数据，如果对于单机的倒还好说，每次请求这个接口直接实时计算一次就可以了。</p><p>但对于集群的服务来说会有多个节点，目前 Pulsar 提供的这个接口只能查询指定节点的负载数据，也就是说每次得传入目标节点的 IP 和端口。</p><p><img src="https://s2.loli.net/2024/06/07/ephIgndx54sFlLa.png"></p><p>所以我的预期是可以提供一个查询所有节点负载的接口，已经提了 <code>issue</code>，最近准备写 Purpose 把这个需求解决了。</p><p>实现这个需求的方案有两种：</p><ol><li>拿到所有 broker 也就是服务节点信息，依次遍历调用接口，然后自己组装信息。</li><li>从 zookeeper 中获取负载信息。</li></ol><p>理论上第二种更好，第一种实现虽然更简单，但每次都发起一次 http 请求，多少有些浪费。</p><p>第二种方案直接从源头获取负载信息，只需要请求一次就可以了。</p><p>而正好社区提供了一个命令行工具可以直接打印所有的 <code>broker</code> 负载数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pulsar-perf monitor-brokers --connect-string &lt;zookeeper host:port&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/06/07/UN8gpW915RfcODb.png"></p><h1 id="分布式系统常用组件"><a href="#分布式系统常用组件" class="headerlink" title="分布式系统常用组件"></a>分布式系统常用组件</h1><p>提供的命令行工具其实就是直接从 zookeeper 中查询的数据。</p><p>在分布式系统中需要一个集中的组件来管理各种数据，比如：</p><ol><li>可以利用该组件来选举 leader 节点</li><li>使用该组件来做分布式锁</li><li>为分布式系统同步数据</li><li>统一的存放和读取某些数据</li></ol><p>可以提供该功能的组件其实也不少：</p><ul><li><a href="https://zookeeper.apache.org/">zookeeper</a></li><li><a href="https://etcd.io/">etcd</a></li><li><a href="https://github.com/streamnative/oxia">oxia</a></li></ul><p>Zookeeper 是老牌的分布式协调组件，可以做 leader 选举、配置中心、分布式锁、服务注册与发现等功能。</p><p>在许多中间件和系统中都有应用，比如：</p><ul><li><a href="https://github.com/apache/pulsar">Apache Pulsar</a> 中作为协调中心</li><li><a href="https://github.com/apache/kafka">Kafka</a> 中也有类似的作用。</li><li>在 <a href="https://github.com/apache/dubbo">Dubbo</a> 中作为服务注册发现组件。</li></ul><hr><p>etcd 的功能与 zookeeper 类似，可以用作服务注册发现，也可以作为 Key Value 键值对存储系统；在 kubernetes 中扮演了巨大作用，经历了各种考验，稳定性已经非常可靠了。</p><hr><p><a href="https://github.com/streamnative/oxia">Oxia</a> 则是 StreamNative 开发的一个用于替换 Zookeeper 的中间件，功能也与 Zookeeper 类似；目前已经可以在 Pulsar 中替换 Zookeeper，只是还没有大规模的使用。</p><h1 id="Pulsar-中的应用"><a href="#Pulsar-中的应用" class="headerlink" title="Pulsar 中的应用"></a>Pulsar 中的应用</h1><p>下面以 Pulsar 为例（使用 zookeeper），看看在这类大型分布式系统中是如何处理负载均衡的。</p><p>再开始之前先明确下负载均衡大体上会做哪些事情。</p><ol><li>首先上报自己节点的负载数据</li><li>Leader 节点需要定时收集所有节点的负载数据。<ol><li>这些负载数据中包括：<ol><li><code>CPU</code>、堆内存、堆外内存等通用数据的使用量</li><li>流出、流入流量</li><li>一些系统特有的数据，比如在 <code>Pulsar</code> 中就是：<ol><li>每个 <code>broker</code> 中的 <code>topic</code>、<code>consumer</code>、<code>producer</code>、<code>bundle</code> 等数据。</li></ol></li></ol></li></ol></li><li>再由 leader 节点读取到这些数据后选择负载较高的节点，将数据迁移到负载较低的节点。</li></ol><p>以上就是一个完整的负载均衡的流程，下面我们依次看看在 <code>Pulsar</code> 中是如何实现这些逻辑的。</p><p>在 Pulsar 中提供了多种负载均衡策略，以下是加载负载均衡器的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> LoadManager <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> PulsarService pulsar)</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServiceConfiguration</span> <span class="variable">conf</span> <span class="operator">=</span> pulsar.getConfiguration();  </span><br><span class="line">        <span class="comment">// Assume there is a constructor with one argument of PulsarService.  </span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">loadManagerInstance</span> <span class="operator">=</span> Reflections.createInstance(conf.getLoadManagerClassName(),  </span><br><span class="line">                Thread.currentThread().getContextClassLoader());  </span><br><span class="line">        <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> LoadManager) &#123;  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> (LoadManager) loadManagerInstance;  </span><br><span class="line">            casted.initialize(pulsar);  </span><br><span class="line">            <span class="keyword">return</span> casted;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> ModularLoadManager) &#123;  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModularLoadManagerWrapper</span>((ModularLoadManager) loadManagerInstance);  </span><br><span class="line">            casted.initialize(pulsar);  </span><br><span class="line">            <span class="keyword">return</span> casted;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        LOG.warn(<span class="string">&quot;Error when trying to create load manager: &quot;</span>, e);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// If we failed to create a load manager, default to SimpleLoadManagerImpl.  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleLoadManagerImpl</span>(pulsar);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认使用的是 <code>ModularLoadManagerImpl</code>， 如果出现异常那就会使用 <code>SimpleLoadManagerImpl</code> 作为兜底。</p><p>他们两个的区别是 <code>ModularLoadManagerImpl</code> 的功能更全，可以做更为细致的负载策略。</p><p>接下来以默认的 <code>ModularLoadManagerImpl</code> 为例讲解上述的流程。</p><h2 id="上报负载数据"><a href="#上报负载数据" class="headerlink" title="上报负载数据"></a>上报负载数据</h2><p>在负载均衡器启动的时候就会收集节点数据然后进行上报：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> PulsarServerException &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="type">String</span> <span class="variable">brokerId</span> <span class="operator">=</span> pulsar.getBrokerId();</span><br><span class="line">         brokerZnodePath = LoadManager.LOADBALANCE_BROKERS_ROOT + <span class="string">&quot;/&quot;</span> + brokerId;</span><br><span class="line">         <span class="comment">// 收集本地负载数据</span></span><br><span class="line">         updateLocalBrokerData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上报 zookeeper</span></span><br><span class="line">         brokerDataLock = brokersData.acquireLock(brokerZnodePath, localData).join();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         log.error(<span class="string">&quot;Unable to acquire lock for broker: [&#123;&#125;]&quot;</span>, brokerZnodePath, e);</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PulsarServerException</span>(e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先获取到当前 broker 的 Id 然后拼接一个 zookeeper 节点的路径，将生成的 localData 上传到 zookeeper 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 存放 broker 的节点信息</span><br><span class="line">ls /loadbalance/brokers</span><br><span class="line"></span><br><span class="line">[broker-1:8080, broker-2:8080]</span><br><span class="line"></span><br><span class="line">// 根据节点信息查询负载数据</span><br><span class="line">get /loadbalance/brokers/broker-1:8080</span><br></pre></td></tr></table></figure><p>上报的数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;webServiceUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://broker-1:8080&quot;</span><span class="punctuation">,</span><span class="attr">&quot;pulsarServiceUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;pulsar://broker-1:6650&quot;</span><span class="punctuation">,</span><span class="attr">&quot;persistentTopicsEnabled&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="attr">&quot;nonPersistentTopicsEnabled&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">7.311714728372232</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">800.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;memory&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">124.0</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">2096.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;directMemory&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">36.0</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">256.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;bandwidthIn&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">0.8324254085661579</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">1.0E7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;bandwidthOut&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">0.7155446715644209</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">1.0E7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgRateIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgRateOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;lastUpdate&quot;</span><span class="punctuation">:</span><span class="number">1690979816792</span><span class="punctuation">,</span><span class="attr">&quot;lastStats&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;my-tenant/my-namespace/0x4ccccccb_0x66666664&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;msgRateIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgRateOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;consumerCount&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;producerCount&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;topics&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;cacheSize&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;numTopics&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;numBundles&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;numConsumers&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;numProducers&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;bundles&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;my-tenant/my-namespace/0x4ccccccb_0x66666664&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;lastBundleGains&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;lastBundleLosses&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;brokerVersionString&quot;</span><span class="punctuation">:</span><span class="string">&quot;3.1.0-SNAPSHOT&quot;</span><span class="punctuation">,</span><span class="attr">&quot;protocols&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;advertisedListeners&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;internal&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;brokerServiceUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;pulsar://broker-1:6650&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;loadManagerClassName&quot;</span><span class="punctuation">:</span><span class="string">&quot;org.apache.pulsar.broker.loadbalance.impl.ModularLoadManagerImpl&quot;</span><span class="punctuation">,</span><span class="attr">&quot;startTimestamp&quot;</span><span class="punctuation">:</span><span class="number">1690940955211</span><span class="punctuation">,</span><span class="attr">&quot;maxResourceUsage&quot;</span><span class="punctuation">:</span><span class="number">0.140625</span><span class="punctuation">,</span><span class="attr">&quot;loadReportType&quot;</span><span class="punctuation">:</span><span class="string">&quot;LocalBrokerData&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="采集数据"><a href="#采集数据" class="headerlink" title="采集数据"></a>采集数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SystemResourceUsage <span class="title function_">getSystemResourceUsage</span><span class="params">(<span class="keyword">final</span> BrokerHostUsage brokerHostUsage)</span> &#123;  </span><br><span class="line">    <span class="type">SystemResourceUsage</span> <span class="variable">systemResourceUsage</span> <span class="operator">=</span> brokerHostUsage.getBrokerHostUsage();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Override System memory usage and limit with JVM heap usage and limit  </span></span><br><span class="line">    <span class="type">double</span> <span class="variable">maxHeapMemoryInBytes</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory();  </span><br><span class="line">    <span class="type">double</span> <span class="variable">memoryUsageInBytes</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();  </span><br><span class="line">    <span class="type">double</span> <span class="variable">memoryUsage</span> <span class="operator">=</span> memoryUsageInBytes / MIBI;  </span><br><span class="line">    <span class="type">double</span> <span class="variable">memoryLimit</span> <span class="operator">=</span> maxHeapMemoryInBytes / MIBI;  </span><br><span class="line">    systemResourceUsage.setMemory(<span class="keyword">new</span> <span class="title class_">ResourceUsage</span>(memoryUsage, memoryLimit));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Collect JVM direct memory  </span></span><br><span class="line">    systemResourceUsage.setDirectMemory(<span class="keyword">new</span> <span class="title class_">ResourceUsage</span>((<span class="type">double</span>) (getJvmDirectMemoryUsed() / MIBI),  </span><br><span class="line">            (<span class="type">double</span>) (DirectMemoryUtils.jvmMaxDirectMemory() / MIBI)));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> systemResourceUsage;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会在运行时获取一些 JVM 和 堆外内存的数据。</p><h2 id="收集所有节点数据"><a href="#收集所有节点数据" class="headerlink" title="收集所有节点数据"></a>收集所有节点数据</h2><p>作为 <code>leader</code> 节点还需要收集所有节点的负载数据，然后根据一些规则选择将负载较高的节点移动到负债较低的节点中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateAllBrokerData</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 从 zookeeper 中获取所有节点</span></span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; activeBrokers = getAvailableBrokers();</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, BrokerData&gt; brokerDataMap = loadData.getBrokerData();</span><br><span class="line">    <span class="keyword">for</span> (String broker : activeBrokers) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s/%s&quot;</span>, LoadManager.LOADBALANCE_BROKERS_ROOT, broker);</span><br><span class="line">            <span class="comment">// 依次读取各个节点的负载数据</span></span><br><span class="line">            Optional&lt;LocalBrokerData&gt; localData = brokersData.readLock(key).get();</span><br><span class="line">            <span class="keyword">if</span> (!localData.isPresent()) &#123;</span><br><span class="line">                brokerDataMap.remove(broker);</span><br><span class="line">                log.info(<span class="string">&quot;[&#123;&#125;] Broker load report is not present&quot;</span>, broker);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brokerDataMap.containsKey(broker)) &#123;</span><br><span class="line">                <span class="comment">// Replace previous local broker data.</span></span><br><span class="line">                brokerDataMap.get(broker).setLocalData(localData.get());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Initialize BrokerData object for previously unseen</span></span><br><span class="line">                <span class="comment">// brokers.</span></span><br><span class="line">                <span class="comment">// 将数据写入到本地缓存</span></span><br><span class="line">                brokerDataMap.put(broker, <span class="keyword">new</span> <span class="title class_">BrokerData</span>(localData.get()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Error reading broker data from cache for broker - [&#123;&#125;], [&#123;&#125;]&quot;</span>, broker, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove obsolete brokers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> String broker : brokerDataMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!activeBrokers.contains(broker)) &#123;</span><br><span class="line">            brokerDataMap.remove(broker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会从 zookeeper 的节点中获取到所有的 broker 列表（broker 会在启动时将自身的信息注册到 zookeeper 中。）</p><p>然后依次读取各自节点的负载数据，也就是在负载均衡器启动的时候上报的数据。</p><h2 id="筛选出所有-broker-中需要-unload-的-bundle"><a href="#筛选出所有-broker-中需要-unload-的-bundle" class="headerlink" title="筛选出所有 broker 中需要 unload 的 bundle"></a>筛选出所有 broker 中需要 unload 的 bundle</h2><p>在 Pulsar 中 topic 是最核心的概念，而为了方便管理大量 topic，提出了一个 Bundle 的概念； Bundle 是一批 topic 的集合，管理 Bundle 自然会比 topic 更佳容易。</p><p>所以在 Pulsar 中做负载均衡最主要的就是将负载较高节点中的 bundle 转移到低负载的 broker 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateAllBrokerData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; activeBrokers = getAvailableBrokers();</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, BrokerData&gt; brokerDataMap = loadData.getBrokerData();</span><br><span class="line">    <span class="keyword">for</span> (String broker : activeBrokers) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s/%s&quot;</span>, LoadManager.LOADBALANCE_BROKERS_ROOT, broker);</span><br><span class="line">            Optional&lt;LocalBrokerData&gt; localData = brokersData.readLock(key).get();</span><br><span class="line">            <span class="keyword">if</span> (!localData.isPresent()) &#123;</span><br><span class="line">                brokerDataMap.remove(broker);</span><br><span class="line">                log.info(<span class="string">&quot;[&#123;&#125;] Broker load report is not present&quot;</span>, broker);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brokerDataMap.containsKey(broker)) &#123;</span><br><span class="line">                <span class="comment">// Replace previous local broker data.</span></span><br><span class="line">                brokerDataMap.get(broker).setLocalData(localData.get());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Initialize BrokerData object for previously unseen</span></span><br><span class="line">                <span class="comment">// brokers.</span></span><br><span class="line">                brokerDataMap.put(broker, <span class="keyword">new</span> <span class="title class_">BrokerData</span>(localData.get()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Error reading broker data from cache for broker - [&#123;&#125;], [&#123;&#125;]&quot;</span>, broker, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove obsolete brokers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> String broker : brokerDataMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!activeBrokers.contains(broker)) &#123;</span><br><span class="line">            brokerDataMap.remove(broker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负载均衡器在启动的时候就会查询所有节点的数据，然后写入到 <code>brokerDataMap</code> 中。</p><p><img src="https://s2.loli.net/2024/06/12/ASoLedKVlgRbCFO.png"><br>同时也会注册相关的 zookeeper 事件，当注册的节点发生变化时（一般是新增或者删减了 broker 节点）就会更新内存中缓存的负载数据。</p><p>之后 leader 节点会定期调用 <code>org.apache.pulsar.broker.loadbalance.impl.ModularLoadManagerImpl#doLoadShedding</code> 函数查询哪些数据需要卸载，然后进行重新负载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Multimap&lt;String, String&gt; bundlesToUnload = loadSheddingStrategy.findBundlesForUnloading(loadData, conf);</span><br></pre></td></tr></table></figure><p>最核心的就是调用这个 <code>findBundlesForUnloading</code> 函数，会返回需要卸载 bundle 集合，最终会遍历这个集合调用 admin API 进行卸载和重平衡。</p><p>而这个函数会有多种实现，本质上就是根据传入的各个节点的负载数据，然后根据自定义的规则返回一批需要卸载的数据。</p><p>以默认的 <code>org.apache.pulsar.broker.loadbalance.impl.ThresholdShedder</code> 规则为例：</p><p><img src="https://s2.loli.net/2024/06/12/hg751LtwZMrUyFb.png"><br>它是根据带宽、内存、流量等各个指标的权重算出每个节点的负载值，之后为整个集群计算出一个平均负载值。</p><p>以上图为例：超过 <code>ShedBundles</code> 的数据就需要被卸载掉，然后转移到低负载的节点中。</p><p>所以最左边节点和超出的 bundle 部分就需要被返回。</p><p>具体的计算逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">filterAndSelectBundle</span><span class="params">(LoadData loadData, Map&lt;String, Long&gt; recentlyUnloadedBundles, String broker,</span></span><br><span class="line"><span class="params">                                   LocalBrokerData localData, <span class="type">double</span> minimumThroughputToOffload)</span> &#123;</span><br><span class="line">    <span class="type">MutableDouble</span> <span class="variable">trafficMarkedToOffload</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutableDouble</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">MutableBoolean</span> <span class="variable">atLeastOneBundleSelected</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutableBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">    loadData.getBundleDataForLoadShedding().entrySet().stream()</span><br><span class="line">            .map((e) -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">bundle</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">BundleData</span> <span class="variable">bundleData</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="type">TimeAverageMessageData</span> <span class="variable">shortTermData</span> <span class="operator">=</span> bundleData.getShortTermData();</span><br><span class="line">                <span class="type">double</span> <span class="variable">throughput</span> <span class="operator">=</span> shortTermData.getMsgThroughputIn() + shortTermData.getMsgThroughputOut();</span><br><span class="line">                <span class="keyword">return</span> Pair.of(bundle, throughput);</span><br><span class="line">            &#125;).filter(e -&gt;</span><br><span class="line">                    !recentlyUnloadedBundles.containsKey(e.getLeft())</span><br><span class="line">            ).filter(e -&gt;</span><br><span class="line">                    localData.getBundles().contains(e.getLeft())</span><br><span class="line">            ).sorted((e1, e2) -&gt;</span><br><span class="line">                    Double.compare(e2.getRight(), e1.getRight())</span><br><span class="line">            ).forEach(e -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (trafficMarkedToOffload.doubleValue() &lt; minimumThroughputToOffload</span><br><span class="line">                        || atLeastOneBundleSelected.isFalse()) &#123;</span><br><span class="line">                    selectedBundlesCache.put(broker, e.getLeft());</span><br><span class="line">                    trafficMarkedToOffload.add(e.getRight());</span><br><span class="line">                    atLeastOneBundleSelected.setTrue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码里看的出来就是在一个备选集合中根据各种阈值和判断条件筛选出需要卸载的 bundle。</p><hr><p>而 <code>SimpleLoadManagerImpl</code> 的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (currentLoadReports) &#123;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;ResourceUnit, LoadReport&gt; entry : currentLoadReports.entrySet()) &#123;</span><br><span class="line"><span class="type">ResourceUnit</span> <span class="variable">overloadedRU</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"><span class="type">LoadReport</span> <span class="variable">lr</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"><span class="comment">// 所有数据做一个简单的筛选，超过阈值的数据需要被 unload</span></span><br><span class="line"><span class="keyword">if</span> (isAboveLoadLevel(lr.getSystemResourceUsage(), overloadThreshold)) &#123;</span><br><span class="line"><span class="type">ResourceType</span> <span class="variable">bottleneckResourceType</span> <span class="operator">=</span> lr.getBottleneckResourceType();</span><br><span class="line">Map&lt;String, NamespaceBundleStats&gt; bundleStats = lr.getSortedBundleStats(bottleneckResourceType);</span><br><span class="line"><span class="keyword">if</span> (bundleStats == <span class="literal">null</span>) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;Null bundle stats for bundle &#123;&#125;&quot;</span>, lr.getName());</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是很简单的通过将判断节点的负载是否超过了阈值 <code>isAboveLoadLevel</code>，然后做一个简单的排序就返回了。</p><p>从这里也看得出来 <code>SimpleLoadManagerImpl</code> 和 <code>ModularLoadManager</code> 的区别，<code>SimpleLoadManagerImpl</code> 更简单，并没有提供多个 <code>doLoadShedding</code> 的筛选实现。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说对于无状态的服务来说，理论上我们只需要做好负载算法即可（轮训、一致性哈希、低负载优先等）就可以很好的平衡各个节点之间的负载。</p><p>而对于有状态的服务来说，负载均衡就是将负载较高节点中的数据转移到负载低的节点中。</p><p>其中的关键就是需要存储各个节点的负载数据（业界常用的是存储到 zookeeper 中），然后再由一个 leader 节点从这些节点中根据某种负载算法选择出负载较高的节点以及负载较低的节点，最终把数据迁移过去即可。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Pulsar 有提供一个查询 Broker 负载的接口：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * Get load for this broker.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; PulsarAdminException&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LoadManagerReport &lt;span class=&quot;title function_&quot;&gt;getLoadReport&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; PulsarAdminException;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;LoadManagerReport&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceLookupData&lt;/span&gt; &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getCpu&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getMemory&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getDirectMemory&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getBandwidthIn&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getBandwidthOut&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以返回一些 broker 的负载数据，比如 CPU、内存、流量之类的数据。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/OB/Pulsar/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>🎉我是如何从零到成为 Apache 顶级项目的 Committer</title>
    <link href="http://crossoverjie.top/2024/07/11/ob/%F0%9F%8E%89how-to-be-committer/"/>
    <id>http://crossoverjie.top/2024/07/11/ob/%F0%9F%8E%89how-to-be-committer/</id>
    <published>2024-07-11T15:45:32.000Z</published>
    <updated>2024-07-11T15:46:29.320Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/07/07/bj8NHqYFegTx1WU.png" alt="image.png"><br><img src="https://s2.loli.net/2024/07/07/a86fbuopri9mDeS.png"></p><p>最近收到了 <a href="https://github.com/apache/pulsar/">Apache Pulsar</a> 和 <a href="https://github.com/apache/hertzbeat/">Apache HertzBeat</a>社区的邀请邮件，成为了这两个项目的 <code>Committer</code>。</p><span id="more"></span><p>一路走来我从最开始的打游击战的闲散人员到如今活跃在各个开源项目里的“老兵”，用现在流行的话来说 <code>Apache</code> 的这两个 <code>Committer</code> 就相当于是拿到了编制，进入了正规军。</p><p>下面就分享一下我的个人开源经历，希望对想要参与开源或者已经在其中的开发者有所帮助。</p><h1 id="我的-GitHub-开源故事"><a href="#我的-GitHub-开源故事" class="headerlink" title="我的 GitHub 开源故事"></a>我的 GitHub 开源故事</h1><h2 id="初识-GitHub"><a href="#初识-GitHub" class="headerlink" title="初识 GitHub"></a>初识 GitHub</h2><p><img src="https://s2.loli.net/2024/07/08/CylX9TKcQY12MWI.png"><br>我这个 <code>Github</code> 账号是在 15 年 9月份注册的，那时候刚出来参与工作。</p><p>其实在这之前我压根没有听说过 GitHub、对开源也是知之甚少；只是知道老师和同事经常让我在网上可以下载到一些第三方包（现在回想起来几乎都是好 Apache 的提供的包）来解决日常的一些常见需求。</p><p>当时只是觉得非常方便，没想到大部分的工作互联网上都有相关的解决方案。</p><p>直到第二年也就是 16 年我才提交第一行代码，记得当时是需要和同学共享一些代码。</p><p>在学校的时候大家都是把文件打包然后通过 QQ 发送的，因为我之前在 GitHub 上看到大家都是把源码公开的，所以当时的想法是不是可以直接使用 GitHub 把代码发给同学，这样就省去了打包解压的步骤了。</p><blockquote><p>现在想想还好都是一些非业务代码，不然就违反公司安全规定了。</p></blockquote><p>所以其实自己没有任何开源的概念，只是觉得分享代码很方便。</p><p>后续在网上看了 <code>Richard Matthew Stallman</code> 发起的<a href="https://zh.wikipedia.org/zh-hans/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%BF%90%E5%8A%A8">自由软件运动</a>才对开源的由来有了更多的认识，也越发佩服这些参与开源的大佬们。</p><h2 id="托管-Blog"><a href="#托管-Blog" class="headerlink" title="托管 Blog"></a>托管 Blog</h2><p><img src="https://s2.loli.net/2024/07/08/zhYcH9RmxkpWEA2.png" alt="image.png"><br><img src="https://s2.loli.net/2024/07/08/Cv86gmrlhxoDqBK.png" alt="image.png"></p><p>当时还非常流行在 GitHub 上搭建个人博客，我自然也跟上了这个潮流；直到现在也没有断更。<br>陆续写了 240+ 篇博客。</p><blockquote><p>记得当时最喜欢干的事就是折腾各种主题，可以在 GitHub 免费托管一个博客，对当时的我也是震撼蛮大的。</p></blockquote><p>关于博客的话题还有不少内容可以讲，放到后面继续分享。</p><h2 id="提交第一个项目"><a href="#提交第一个项目" class="headerlink" title="提交第一个项目"></a>提交第一个项目</h2><p><img src="https://s2.loli.net/2024/07/08/NtExsU8Z2ryWdzT.png"><br>因为当时在公司刚开始接触到 SSM(spring+springmvc+mybatis)，所以就想把日常学到的东西沉淀下来。</p><p>于是就把一些非业务代码整理后提交了第一个项目，以更新博客的方式陆续更新了各种解决方案：<br><img src="https://s2.loli.net/2024/07/08/BITYfjNS7oaEpJl.png"><br>至今已经全部更新完毕，所以我就将它归档了。</p><p>这也是我第一次正儿八经做开源项目，在这个过程中也结实到了不少朋友，沉淀了许多内容；对于刚工作一两年的我来说意义还是很重大的。</p><h1 id="参与正规军-Apache"><a href="#参与正规军-Apache" class="headerlink" title="参与正规军(Apache)"></a>参与正规军(Apache)</h1><p>时间点回到现在，因为工作原因我需要在公司内部维护 Pulsar 消息队列；当时 Pulsar 在公司还有着一些细枝末节的问题需要解决。</p><p>在解决这些问题的过程中就想着看能不能给社区贡献些代码，这样也可以更熟悉整个项目。</p><blockquote><p>其实 20 年左右在之前的公司就有使用 Pulsar，只是当时还没有意识到要向社区贡献代码。</p></blockquote><p>于是我先尝试做一些无关紧要的修改：<br><img src="https://s2.loli.net/2024/07/08/WLkOP5KhvBHmg7E.png"><br>因为这个还被大佬拒过几个 PR，与此同时我也在持续输出一个 Pulsar 相关的博客，当时也得到了大佬的认可：<br><img src="https://s2.loli.net/2024/07/08/spUaV8yPZMYbHAe.png"></p><p>之后我又根据日常工作中遇到的一些问题或者优化持续给社区提交 PR：<br><img src="https://s2.loli.net/2024/07/08/LPQ2RSHNotfJclY.png"></p><p>这个过程从第一个 PR 到社区大佬提名我大概经历了一年半的时间。</p><p>越大型、严谨的项目在处理这些 PR 时就是缓慢的，所以如果你真的想深度参与某个项目时就一定要有充分的耐心。</p><p>首先坚持下去，收获自然就来了。</p><hr><h3 id="Apache-HertzBeat"><a href="#Apache-HertzBeat" class="headerlink" title="Apache HertzBeat"></a>Apache HertzBeat</h3><p>今年四月份的时候我在朋友圈还看到另外一个项目：<a href="https://github.com/apache/hertzbeat">Apache HertzBeat</a>。</p><p>因为当时我也在做一些可观测性的内容，正好这个项目是和监控相关的；于是我就跟着文档走了一遍。</p><p>发现功能很强也很全，当时也是刚加入 Apache 的孵化器，所以还是有许多可以完善的地方。</p><p>我就开始以单测作为切入点尝试贡献源码，社区的响应速度也非常快。</p><p>之后逐渐将我在其他社区学到一些经验也复制到 HertzBeat 中，慢慢的贡献的代码越多，对 HertzBeat 也就更加熟悉了。</p><p>两个多月的时间我贡献了 30 个左右的 PR，后来也受到项目发起者的邀请：<br><img src="https://s2.loli.net/2024/07/08/L9SI6rO17TxkDaH.png" alt="image.png"></p><p>因为是相对更年轻的项目，才更需要大家群策群力；所以如果你也对监控系统感兴趣，或者比较熟悉前端技术栈（HertzBeat 有后台管理界面）都欢迎前来贡献，后续获得提名的机会要比已经发展稳定的项目更大一些。</p><h1 id="成为-Committer-的好处"><a href="#成为-Committer-的好处" class="headerlink" title="成为 Committer 的好处"></a>成为 Committer 的好处</h1><p>讲到这里顺便再讲讲成为  Committer 的一些好处了，虽然开源经常和免费白嫖划等号，大部分人都是用爱发电的，但因为也有许多大公司得到了开源的好处，所以也给活跃在社区里的贡献者提供了一些免费福利。</p><p>当然要拿到这些福利肯定是得有一个评判标准，最简单也最直观的就是你是否已经是 Apache 组织的 Committer。</p><h2 id="Github-Copilot"><a href="#Github-Copilot" class="headerlink" title="Github Copilot"></a>Github Copilot</h2><p>首先第一个好处是提供免费个人使用 Copilot，当然这不全是 Committer 的权益，如果你是某个开源项目的活跃贡献者也是可以申请的（不一定能申请过，目前好像没看到通过的标准），只是已经是 Committer 后肯定是能享受这个权益。</p><h2 id="Jetbrains-全家桶-IDE"><a href="#Jetbrains-全家桶-IDE" class="headerlink" title="Jetbrains 全家桶 IDE"></a>Jetbrains 全家桶 IDE</h2><p><img src="https://s2.loli.net/2024/07/08/kc9Ovp1u7M4DxWE.png"></p><p>JB 作为一个和开发者强绑定的公司，也提供了对应的福利，只要使用 Apache 的邮箱就可以免费使用他们的全家桶。</p><h2 id="Apache-邮箱"><a href="#Apache-邮箱" class="headerlink" title="Apache 邮箱"></a>Apache 邮箱</h2><p>提到了邮箱那就不得不提到 Apache 给每个 Committer 都会提供一个专属邮箱：<br><img src="https://s2.loli.net/2024/07/08/TQVkIhbUcAtpfCX.png"><br>虽然市面上有各种的免费邮箱注册服务，但当你使用 Apache 的邮箱和其他人沟通交流时，大概率对方潜意识里都会对你高看一点。</p><p>这虽然是一些虚无缥缈的东西，但有时候就是会让沟通更加顺畅（比如求职面试时）。</p><h2 id="项目的写权限"><a href="#项目的写权限" class="headerlink" title="项目的写权限"></a>项目的写权限</h2><p>还有一个好处就是有了项目的写权限，当你参与过开源项目就知道这个的重要性了，有些时候一些 PR 迟迟得不到回复和合并，自己只能干着急。</p><p>有了这个权限之后，只要你的 PR 有人 <code>Approve</code> 之后，在风险可控的情况下不用等着 maintainer 来合并，自己就可以操作。</p><p>同时得益于在社区的活跃程度，你再提交到 PR 会更得到重视，同时也能更好的推进某些 feature；这对于依赖某个开源项目的公司来说受益非常大。</p><h1 id="Apache-贡献阶梯"><a href="#Apache-贡献阶梯" class="headerlink" title="Apache 贡献阶梯"></a>Apache 贡献阶梯</h1><p>相信看到这里应该有不少人对成为 Apache Committer 感兴趣了，也比较好奇什么样的标准才能成为 Committer。</p><p>以下是我根据一些已经是 Committer 的大佬和 Apache 官方给的一个贡献阶梯作为参考总结出来的。</p><p><img src="https://s2.loli.net/2024/07/08/tlEuhMR85AmLasn.png"></p><p>参与开源的人主要分为以下几种角色：</p><ul><li>普通用户</li><li>贡献者</li><li>Committer</li><li>PMC 项目管理人员</li><li>基金会管理人员</li><li>基金会董事</li></ul><p>整个路径还是比较清晰的，只是从 PMC 开始到后面的董事难度都是指数级增加。</p><blockquote><p>目前整个国内当选过董事的都是屈指可数。</p></blockquote><p>而关于成为 Committer 的要求某些社区会有明显的标准：<br><img src="https://s2.loli.net/2024/07/08/qdfeaXc6gRlF5tN.png"></p><p>当然这个标准也不是一成不变的，只要持续的在社区活跃，有脸熟之后自然会有相关的 PMC 为你提名；当然这里的前提条件都是“持续活跃”。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后再总结下，为爱发电的开源项目也是可以获得回报的；特别是当你合并一个 PR 进入某个项目时带来的愉悦感非常强烈。</p><p>随着时间推进，在之后合并的 PR 可能没有前几次那么强烈，但只要达到一个范围，社区开始提名你为 Committer 时，这个多巴胺又会持续分泌。</p><p>同样的后续成为 PMC、管理人员、董事又会持续带来愉悦，当然难度也一个比一个大。</p><p>后面的层级离我还很远，如果今后有达到的一天再来和大家分享。</p><p>参考链接：</p><ul><li><a href="https://community.apache.org/contributor-ladder.html">https://community.apache.org/contributor-ladder.html</a></li><li><a href="https://hertzbeat.apache.org/zh-cn/docs/community/become_committer">https://hertzbeat.apache.org/zh-cn/docs/community/become_committer</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%BF%90%E5%8A%A8">https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%BF%90%E5%8A%A8</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/07/07/bj8NHqYFegTx1WU.png&quot; alt=&quot;image.png&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/07/07/a86fbuopri9mDeS.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近收到了 &lt;a href=&quot;https://github.com/apache/pulsar/&quot;&gt;Apache Pulsar&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/apache/hertzbeat/&quot;&gt;Apache HertzBeat&lt;/a&gt;社区的邀请邮件，成为了这两个项目的 &lt;code&gt;Committer&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
  </entry>
  
  <entry>
    <title>✅开源项目如何做集成测试</title>
    <link href="http://crossoverjie.top/2024/07/09/ob/%E2%9C%85%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%81%9A%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/"/>
    <id>http://crossoverjie.top/2024/07/09/ob/%E2%9C%85%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%81%9A%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/</id>
    <published>2024-07-09T03:15:25.000Z</published>
    <updated>2024-07-09T03:16:37.821Z</updated>
    
    <content type="html"><![CDATA[<p>之前有朋友问如何做集成测试，今天就重点讲讲这个集成测试在开源项目中是如何做的。</p><p>通常是需要对外提供服务的开源项目都需要集成测试：</p><ul><li>Pulsar</li><li>Kafka</li><li>Dubbo 等<span id="more"></span></li></ul><p>而只提供本地类库的项目通常只需要编写单元测试即可：</p><ul><li>Hutool</li><li>Apache Commmon</li></ul><p>以我接触到的服务型应用主要分为两类：一个是 Java 应用一个是 Golang 应用。</p><h1 id="🐳Golang"><a href="#🐳Golang" class="headerlink" title="🐳Golang"></a>🐳Golang</h1><p>Golang 因为工具链没有 Java 那么强大，所以大部分的集成测试的功能都是通过编写 Makefile 和 shell 脚本实现的。</p><p>还是以我熟悉的 Pulsar 的 go-client 为例，它在 GitHub 的集成测试是通过 GitHub action 触发的，定义如下：<br><img src="https://s2.loli.net/2024/05/20/f2196pujo8m7KRe.png"><br>最终调用的是 Makefile 中的 test 命令，并且把需要测试的 Golang 版本传入进去。</p><p><img src="https://s2.loli.net/2024/05/20/YpwtSHnLXqU1xQj.png"></p><p><code>Dockerfile</code>：<br><img src="https://s2.loli.net/2024/05/20/1ySGWF46U7EC2rk.png"></p><p>这个镜像简单来说就是将 Pulsar 的镜像作为基础运行镜像（这里面包含了 Pulsar 的服务端），然后将这个 pulsar-client-go 的代码复制进去编译。</p><p>接着运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /pulsar/pulsar-client-go &amp;&amp; ./scripts/run-ci.sh</span><br></pre></td></tr></table></figure><p>也就是测试脚本。</p><p><img src="https://s2.loli.net/2024/05/20/2Afmdu8ozRvH9FC.png"></p><p>测试脚本的逻辑也很简单：</p><ul><li>启动 pulsar 服务端</li><li>运行测试代码<br>因为所有的测试代码里连接服务端的地址都是 <code>localhost</code>，所以可以直接连接。<br><img src="https://s2.loli.net/2024/05/20/C1RHxTkuz25Mlj8.png"></li></ul><p>通过这里的 <a href="https://github.com/apache/pulsar-client-go/actions/runs/9014510238/job/24768797555">action</a> 日志可以跟踪所有的运行情况。</p><h1 id="☕Java"><a href="#☕Java" class="headerlink" title="☕Java"></a>☕Java</h1><p>Java 因为工具链强大，所以集成测试几乎不需要用 Makefile 和脚本配合执行。</p><p>还是以 Pulsar 为例，它的集成测试是需要模拟在本地启动一个服务端，然后再运行测试代码。</p><blockquote><p>这个的好处是任何一个单测都可以在本地直接运行，而  Go 的代码还需要先在本地启动一个服务端，测试起来比较麻烦。</p></blockquote><p>来看看它是如何实现的，我以其中一个 <a href="https://github.com/apache/pulsar/blob/631b13ad23d7e48c6e82d38f97c23d129062cb7c/pulsar-broker/src/test/java/org/apache/pulsar/client/impl/BrokerClientIntegrationTest.java#L117">BrokerClientIntegrationTest</a>为例：<br><img src="https://s2.loli.net/2024/05/20/9PbioA3RQLMBy6J.png"><br><img src="https://s2.loli.net/2024/05/20/blKePdxTUIkgRD3.png"><br>会在单测启动的时候先启动服务端。</p><p><img src="https://s2.loli.net/2024/05/20/gzY3lyTGuEDUwZF.png"></p><p>最终会调用 PulsarTestContext 的 build 函数启动 broker（服务端），而执行单测也只需要使用 mvn 就可以自动触发这些单元测试。<br><img src="https://s2.loli.net/2024/05/20/N15amZihWI73Qyw.png"><br>只是每一个单测都需要启停服务端，所以要把 Pulsar 的所有单测跑完通常需要 1～2 个小时。</p><p>所以这些集成测试本质上都是先要把测试环境构建出来，再跑对应的测试代码；后续也打算给 <a href="https://github.com/crossoverJie/cim">cim</a> 加上集成测试实操一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前有朋友问如何做集成测试，今天就重点讲讲这个集成测试在开源项目中是如何做的。&lt;/p&gt;
&lt;p&gt;通常是需要对外提供服务的开源项目都需要集成测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pulsar&lt;/li&gt;
&lt;li&gt;Kafka&lt;/li&gt;
&lt;li&gt;Dubbo 等</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
  </entry>
  
  <entry>
    <title>从 Helm 到 Operator：Kubernetes应用管理的进化</title>
    <link href="http://crossoverjie.top/2024/07/08/ob/how-operator-working/"/>
    <id>http://crossoverjie.top/2024/07/08/ob/how-operator-working/</id>
    <published>2024-07-08T03:19:51.000Z</published>
    <updated>2024-07-07T07:45:26.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🧰Helm-的作用"><a href="#🧰Helm-的作用" class="headerlink" title="🧰Helm 的作用"></a>🧰Helm 的作用</h1><p>在开始前需要先对 kubernetes  Operator 有个简单的认识。</p><p>以为我们在编写部署一些简单 <code>Deployment</code> 的时候只需要自己编写一个 yaml 文件然后 <code>kubectl apply</code> 即可。</p><span id="more"></span><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">  <span class="attr">template:</span>  </span><br><span class="line">    <span class="attr">metadata:</span>  </span><br><span class="line">      <span class="attr">labels:</span>  </span><br><span class="line">        <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">    <span class="attr">spec:</span>  </span><br><span class="line">      <span class="attr">containers:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">          <span class="attr">image:</span> <span class="string">crossoverjie/k8s-combat:v1</span>  </span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span>  </span><br><span class="line">          <span class="attr">resources:</span>  </span><br><span class="line">            <span class="attr">limits:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">300Mi</span>  </span><br><span class="line">            <span class="attr">requests:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;0.1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">30Mi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f deployment.yaml</span><br></pre></td></tr></table></figure><p>这对于一些并不复杂的项目来说完全够用了，但组件一多就比较麻烦了。</p><p><img src="https://s2.loli.net/2024/06/01/9EtzrfIAvcXm4aJ.png"><br>这里以 Apache Pulsar 为例：它的核心组件有:</p><ul><li>Broker</li><li>Proxy</li><li>Zookeeper</li><li>Bookkeeper</li><li>Prometheus(可选)</li><li>Grafana(可选)<br>等组件，每个组件的启动还有这依赖关系。<blockquote><p>必须需要等 Zookeeper 和 Bookkeeper 启动之后才能将流量放进来。</p></blockquote></li></ul><p>此时如何还继续使用 yaml 文件一个个部署就会非常繁琐，好在社区有提供 Helm 一键安装程序，使用它我们只需要在一个同意的 yaml 里简单的配置一些组件，配置就可以由 helm 来部署整个复杂的 Pulsar 系统。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">components:</span>  </span><br><span class="line">  <span class="comment"># zookeeper  </span></span><br><span class="line">  <span class="attr">zookeeper:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># bookkeeper  </span></span><br><span class="line">  <span class="attr">bookkeeper:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># bookkeeper - autorecovery  </span></span><br><span class="line">  <span class="attr">autorecovery:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># broker  </span></span><br><span class="line">  <span class="attr">broker:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># functions  </span></span><br><span class="line">  <span class="attr">functions:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="comment"># proxy  </span></span><br><span class="line">  <span class="attr">proxy:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># toolset  </span></span><br><span class="line">  <span class="attr">toolset:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># pulsar manager  </span></span><br><span class="line">  <span class="attr">pulsar_manager:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">monitoring:</span>  </span><br><span class="line">  <span class="comment"># monitoring - prometheus  </span></span><br><span class="line">  <span class="attr">prometheus:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># monitoring - grafana  </span></span><br><span class="line">  <span class="attr">grafana:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># monitoring - node_exporter  </span></span><br><span class="line">  <span class="attr">node_exporter:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># alerting - alert-manager  </span></span><br><span class="line">  <span class="attr">alert_manager:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>比如在 helm 的 yaml 中我们可以选择使用哪些 components，以及是否启用监控组件。</p><p>最后直接使用这个文件进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">helm install pulsar apache/pulsar \</span><br><span class="line">--values charts/pulsar/values.yaml \</span><br><span class="line">--<span class="built_in">set</span> namespace=pulsar \</span><br><span class="line">    --<span class="built_in">set</span> initialize=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>它就会自动生成各个组件的 yaml 文件，然后统一执行。</p><p>所以 helm 的本质上和 <code>kubectl apply yaml</code> 一样的，只是我们在定义 value.yaml 时帮我们处理了许多不需要用户低频修改的参数。</p><p>我们可以使用 helm 将要执行的 yaml 输出后人工审核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install pulsar apache/pulsar --dry-run --debug &gt; debug.yaml</span><br></pre></td></tr></table></figure><h1 id="🤔Operator-是什么"><a href="#🤔Operator-是什么" class="headerlink" title="🤔Operator 是什么"></a>🤔Operator 是什么</h1><h2 id="💔Helm-的痛点"><a href="#💔Helm-的痛点" class="headerlink" title="💔Helm 的痛点"></a>💔Helm 的痛点</h2><p>Helm 虽然可以帮我们部署或者升级一个大型应用，但他却没法帮我们运维这个应用。</p><p>举个例子：比如我希望当 Pulsar Broker 的流量或者内存达到某个阈值后就指定扩容 Broker，闲时再自动回收。</p><p>或者某个 Bookkeeper 的磁盘使用率达到阈值后可以自动扩容磁盘，这些仅仅使用 Helm 时都是无法实现的。</p><p>以上这些需求我们目前也是通过监控系统发出报警，然后再由人工处理。</p><p>其中最大的痛点就是进行升级：</p><ul><li>升级ZK</li><li>关闭auto recovery</li><li>升级Bookkeeper</li><li>升级Broker</li><li>升级Proxy</li><li>开启auto recovery</li></ul><p>因为每次升级是有先后顺序的，需要依次观察每个组件运行是否正常才能往后操作。</p><p>如果有 Operator 理性情况下下我们只需要更新一下镜像版本，它就可以自动执行以上的所有步骤最后将集群升级完毕。</p><p>所以相对于 Helm 来说 Operator 是可以站在一个更高的视角俯视整个应用系统，它能发现系统哪个地方需要它从而直接修复。</p><h2 id="💎CRD-Custom-Resource-Definitions"><a href="#💎CRD-Custom-Resource-Definitions" class="headerlink" title="💎CRD(Custom Resource Definitions)"></a>💎CRD(Custom Resource Definitions)</h2><p>而提到 Operator 那就不得不提到 CRD(Custom Resource Definitions)翻译过来就是自定义资源。</p><p>这是 kubernetes 提供的一个 API 扩展机制，类似于内置的 <code>Deployment/StatefulSet/Services</code> 资源，CRD 是一种自定义的资源。</p><p>这里以我们常用的 <code>prometheus-operator</code> 和 <code>VictoriaMetrics-operator</code> 为例：</p><p>Prometheus：</p><ul><li>**<code>Prometheus</code>**：用于定义 Prometheus 的 Deployment</li><li>**<code>Alertmanager</code>**：用于定义 <strong><code>Alertmanager</code></strong></li><li>**<code>ScrapeConfig</code>**：用于定会抓取规则</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">monitoring.coreos.com/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ScrapeConfig</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">static-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">my-namespace</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">prometheus:</span> <span class="string">system-monitoring-prometheus</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">staticConfigs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">job:</span> <span class="string">prometheus</span></span><br><span class="line">      <span class="attr">targets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">prometheus.demo.do.prometheus.io:9090</span></span><br></pre></td></tr></table></figure><p>使用时的一个很大区别就是资源的 <code>kind: ScrapeConfig</code> 为自定义的类型。</p><p>VictoriaMetrics 的 CRD：</p><ul><li>VMPodScrape：Pod 的抓取规则</li><li>VMCluster：配置 VM 集群</li><li>VMAlert：配置 VM 的告警规则</li><li>等等</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vmcluster.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">operator.victoriametrics.com/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VMCluster</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">retentionPeriod:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">  <span class="attr">replicationFactor:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">vmstorage:</span></span><br><span class="line">    <span class="attr">replicaCount:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">storageDataPath:</span> <span class="string">&quot;/vm-data&quot;</span></span><br><span class="line">    <span class="attr">storage:</span></span><br><span class="line">      <span class="attr">volumeClaimTemplate:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">storage:</span> <span class="string">&quot;10Gi&quot;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">  <span class="attr">vmselect:</span></span><br><span class="line">    <span class="attr">replicaCount:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">cacheMountPath:</span> <span class="string">&quot;/select-cache&quot;</span></span><br><span class="line">    <span class="attr">storage:</span></span><br><span class="line">      <span class="attr">volumeClaimTemplate:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">storage:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;0.5&quot;</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;500Mi&quot;</span></span><br><span class="line">  <span class="attr">vminsert:</span></span><br><span class="line">    <span class="attr">replicaCount:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>以上是用于创建一个 VM 集群的 CRD 资源，应用之后就会自动创建一个集群。</p><h1 id="Operator-原理"><a href="#Operator-原理" class="headerlink" title="Operator 原理"></a>Operator 原理</h1><p><img src="https://s2.loli.net/2024/06/01/t4ZnXcS9wokMPER.png"><br>Operator 通常是运行在 kubernetes API server 的 <code>webhook</code> 之上，简单来说就是在一些内置资源的关键节点 API-server 会调用我们注册的一个 <code>webhook</code>，在这个 <code>webhook</code> 中我们根据我们的 CRD 做一些自定义的操作。</p><p>理论上我们可以使用任何语言都可以写 Operator，只需要能处理 api-server 的回调即可。</p><p>只是 Go 语言有很多成熟的工具，比如常用的 <a href="https://kubebuilder.io/">kubebuilder</a> 和 <a href="https://sdk.operatorframework.io/">operator-sdk</a>.</p><p>他们内置了许多命令行工具，可以帮我们节省需要工作量。</p><p>这里以 operator-sdk 为例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ operator-sdk create webhook --group cache --version v1alpha1 --kind Memcached --defaulting --programmatic-validation</span><br></pre></td></tr></table></figure><p>会直接帮我们创建好一个标准的 operator 项目:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├── Dockerfile</span><br><span class="line">├── Makefile</span><br><span class="line">├── PROJECT</span><br><span class="line">├── api</span><br><span class="line">│   └── v1alpha1</span><br><span class="line">│       ├── memcached_webhook.go</span><br><span class="line">│       ├── webhook_suite_test.go</span><br><span class="line">├── config</span><br><span class="line">│   ├── certmanager</span><br><span class="line">│   │   ├── certificate.yaml</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── kustomizeconfig.yaml</span><br><span class="line">│   ├── default</span><br><span class="line">│   │   ├── manager_webhook_patch.yaml</span><br><span class="line">│   │   └── webhookcainjection_patch.yaml</span><br><span class="line">│   └── webhook</span><br><span class="line">│       ├── kustomization.yaml</span><br><span class="line">│       ├── kustomizeconfig.yaml</span><br><span class="line">│       └── service.yaml</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── main.go</span><br></pre></td></tr></table></figure><p>其中 Makefile 中包含了开发过程中常用的工具链（包括根据声明的结构体自动生成 CRD 资源、部署k8s 环境测试等等）、Dockerfile 等等。</p><p>这样我们就只需要专注于开发业务逻辑即可。</p><p>因为我前段时间给 <a href="https://github.com/open-telemetry/opentelemetry-operator">https://github.com/open-telemetry/opentelemetry-operator</a> 贡献过两个 feature，所以就以这个 Operator 为例：</p><p>它有一个 CRD: <code>kind: Instrumentation</code>，在这个 CRD 中可以将 OpenTelemetry 的 agent 注入到应用中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">opentelemetry.io/v1alpha1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Instrumentation</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">instrumentation-test-order</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">env:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_SERVICE_NAME</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">order</span></span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">order</span>  </span><br><span class="line">  <span class="attr">java:</span>  </span><br><span class="line">    <span class="attr">image:</span> <span class="string">autoinstrumentation-java:2.4.0-release</span>  </span><br><span class="line">    <span class="attr">extensions:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">autoinstrumentation-java:2.4.0-release</span>  </span><br><span class="line">        <span class="attr">dir:</span> <span class="string">/extensions</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="attr">env:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_RESOURCE_ATTRIBUTES</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">service.name=order</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_INSTRUMENTATION_MESSAGING_EXPERIMENTAL_RECEIVE_TELEMETRY_ENABLED</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_TRACES_EXPORTER</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">otlp</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_METRICS_EXPORTER</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">otlp</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_LOGS_EXPORTER</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">none</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXPORTER_OTLP_ENDPOINT</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">http://open-telemetry-opentelemetry-collector.otel.svc.cluster.local:4317</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXPORTER_OTLP_COMPRESSION</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">gzip</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXPERIMENTAL_EXPORTER_OTLP_RETRY_ENABLED</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure><p>它的运行规则是当我们的 Pod 在启动过程中会判断 Pod 的注解中是否开启了注入 OpenTelemetry 的配置。</p><p>如果开启则会将我们在 CRD 中自定义的镜像里的 javaagent 复制到业务容器中，同时会将下面的那些环境变量也一起加入的业务容器中。</p><p>要达到这样的效果就需要我们注册一个回调 endpoint。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mgr.GetWebhookServer().Register(<span class="string">&quot;/mutate-v1-pod&quot;</span>, &amp;webhook.Admission&#123;  </span><br><span class="line">    Handler: podmutation.NewWebhookHandler(cfg, ctrl.Log.WithName(<span class="string">&quot;pod-webhook&quot;</span>), decoder, mgr.GetClient(),  </span><br><span class="line">       []podmutation.PodMutator&#123;  </span><br><span class="line">          sidecar.NewMutator(logger, cfg, mgr.GetClient()),  </span><br><span class="line">          instrumentation.NewMutator(logger, mgr.GetClient(), mgr.GetEventRecorderFor(<span class="string">&quot;opentelemetry-operator&quot;</span>), cfg),  </span><br><span class="line">       &#125;),&#125;)</span><br></pre></td></tr></table></figure><p>当 Pod 创建或有新的变更请求时就会回调我们的接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *instPodMutator)</span></span> Mutate(ctx context.Context, ns corev1.Namespace, pod corev1.Pod) (corev1.Pod, <span class="type">error</span>) &#123;  </span><br><span class="line">    logger := pm.Logger.WithValues(<span class="string">&quot;namespace&quot;</span>, pod.Namespace, <span class="string">&quot;name&quot;</span>, pod.Name)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这个接口中我们就可以拿到 Pod 的信息，然后再获取 CRD <code>Instrumentation</code> 做我们的业务逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> otelInsts v1alpha1.InstrumentationList  </span><br><span class="line"><span class="keyword">if</span> err := pm.Client.List(ctx, &amp;otelInsts, client.InNamespace(ns.Name)); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 CRD 中将数据复制到业务容器中。</span></span><br><span class="line">pod.Spec.InitContainers = <span class="built_in">append</span>(pod.Spec.InitContainers, corev1.Container&#123;</span><br><span class="line">Name:      javaInitContainerName,</span><br><span class="line">Image:     javaSpec.Image,</span><br><span class="line">Command:   []<span class="type">string</span>&#123;<span class="string">&quot;cp&quot;</span>, <span class="string">&quot;/javaagent.jar&quot;</span>, javaInstrMountPath + <span class="string">&quot;/javaagent.jar&quot;</span>&#125;,</span><br><span class="line">Resources: javaSpec.Resources,</span><br><span class="line">VolumeMounts: []corev1.VolumeMount&#123;&#123;</span><br><span class="line">Name:      javaVolumeName,</span><br><span class="line">MountPath: javaInstrMountPath,</span><br><span class="line">&#125;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, extension := <span class="keyword">range</span> javaSpec.Extensions &#123;</span><br><span class="line">pod.Spec.InitContainers = <span class="built_in">append</span>(pod.Spec.InitContainers, corev1.Container&#123;</span><br><span class="line">Name:      initContainerName + fmt.Sprintf(<span class="string">&quot;-extension-%d&quot;</span>, i),</span><br><span class="line">Image:     extension.Image,</span><br><span class="line">Command:   []<span class="type">string</span>&#123;<span class="string">&quot;cp&quot;</span>, <span class="string">&quot;-r&quot;</span>, extension.Dir + <span class="string">&quot;/.&quot;</span>, javaInstrMountPath + <span class="string">&quot;/extensions&quot;</span>&#125;,</span><br><span class="line">Resources: javaSpec.Resources,</span><br><span class="line">VolumeMounts: []corev1.VolumeMount&#123;&#123;</span><br><span class="line">Name:      javaVolumeName,</span><br><span class="line">MountPath: javaInstrMountPath,</span><br><span class="line">&#125;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不过需要注意的是想要在测试环境中测试 operator 是需要安装一个 <a href="https://kubebuilder.io/quick-start">cert-manage</a>，这样 <code>webhook</code> 才能正常的回调。</p></blockquote><p><img src="https://s2.loli.net/2024/06/01/IUjriqye6EMFCT8.png"><br>要使得 CRD 生效，我们还得先将 CRD 安装进 kubernetes 集群中，不过这些 operator-sdk 这类根据已经考虑周到了。</p><p>我们只需要定义好 CRD 的结构体：<br><img src="https://s2.loli.net/2024/06/01/RBKp15lhkHsbeEY.png"></p><p>然后使用 Makefile 中的工具 <code>make bundle</code> 就会自动将结构体转换为 CRD。</p><p>参考链接：</p><ul><li><a href="https://github.com/VictoriaMetrics/operator">https://github.com/VictoriaMetrics/operator</a></li><li><a href="https://github.com/prometheus-operator/prometheus-operator">https://github.com/prometheus-operator/prometheus-operator</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;🧰Helm-的作用&quot;&gt;&lt;a href=&quot;#🧰Helm-的作用&quot; class=&quot;headerlink&quot; title=&quot;🧰Helm 的作用&quot;&gt;&lt;/a&gt;🧰Helm 的作用&lt;/h1&gt;&lt;p&gt;在开始前需要先对 kubernetes  Operator 有个简单的认识。&lt;/p&gt;
&lt;p&gt;以为我们在编写部署一些简单 &lt;code&gt;Deployment&lt;/code&gt; 的时候只需要自己编写一个 yaml 文件然后 &lt;code&gt;kubectl apply&lt;/code&gt; 即可。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="kubernetes" scheme="http://crossoverjie.top/categories/OB/kubernetes/"/>
    
    <category term="kubernetes" scheme="http://crossoverjie.top/categories/OB/kubernetes/kubernetes/"/>
    
    
    <category term="kubernetes" scheme="http://crossoverjie.top/tags/kubernetes/"/>
    
    <category term="Operator" scheme="http://crossoverjie.top/tags/Operator/"/>
    
  </entry>
  
  <entry>
    <title>【译】五个我最近在 Go 里学到的小技巧</title>
    <link href="http://crossoverjie.top/2024/07/02/ob/go-5-tips/"/>
    <id>http://crossoverjie.top/2024/07/02/ob/go-5-tips/</id>
    <published>2024-07-02T10:42:39.000Z</published>
    <updated>2024-07-02T11:11:48.928Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://medium.com/@andreiboar/5-small-tips-i-recently-learned-in-go-cf52d50cf129">https:&#x2F;&#x2F;medium.com&#x2F;@andreiboar&#x2F;5-small-tips-i-recently-learned-in-go-cf52d50cf129</a></p><h1 id="让编译器计算数组数量"><a href="#让编译器计算数组数量" class="headerlink" title="让编译器计算数组数量"></a>让编译器计算数组数量</h1><p>我们在 Go 通常很少使用数组 arrays，一般使用切片 Slice 来代替；</p><p>但是当你需要使用的时候，如果你对需要指定数量大小感到很烦时可以使用 <code>[...]</code> 让编译器自动帮我们计算数组大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  </span><br><span class="line">sameArr := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// Use ... instead of 3  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Arrays are equivalent  </span></span><br><span class="line">fmt.Println(arr)  </span><br><span class="line">fmt.Println(sameArr)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="使用-go-run-替换-go-run-main-go"><a href="#使用-go-run-替换-go-run-main-go" class="headerlink" title="使用 go run . 替换 go run main.go"></a>使用 go run . 替换 go run main.go</h1><p>每当我用 Go 写第一行代码时，我都习惯于开始写 <code>main.go</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>但是当 <code>main.go</code> 变得越来越大时，我喜欢把一些结构体移动到新的文件里，还是在 main 这个包中。</p><p>main.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">sayHello()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>say_hello.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;  </span><br><span class="line">fmt.Println(<span class="string">&quot;Hello!&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时使用 <code>go run main.go</code> 将会得到以下的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">command-line-arguments</span>  </span><br><span class="line">./main.go:4:2: undefined: sayHello</span><br></pre></td></tr></table></figure><p>此时可以使用 <code>go run .</code> 来解决这个问题。</p><h1 id="使用下划线让你的数字变得更易读"><a href="#使用下划线让你的数字变得更易读" class="headerlink" title="使用下划线让你的数字变得更易读"></a>使用下划线让你的数字变得更易读</h1><p>你知道可以使用下划线使得你的长数字更易读吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    number := <span class="number">10000000</span></span><br><span class="line">    better := <span class="number">10</span>_000_000</span><br><span class="line"></span><br><span class="line">    fmt.Println(number == better)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="可以在同一个包下有不同的测试包"><a href="#可以在同一个包下有不同的测试包" class="headerlink" title="可以在同一个包下有不同的测试包"></a>可以在同一个包下有不同的测试包</h1><p>在 Go 中我通常认为一个目录下只能有一个包，但也不是完全正确的。</p><p>假设你有一个包名为：<code>yourpackage</code> 此时你可以还可以在同一个目录下创建一个名为 <code>yourpackage_test</code> 的包，同时在这个包里编写你的测试代码。</p><p>这样做的好处是，那些没有被 exporter 的函数在 <code>yourpackage_test</code> 包下是不能直接访问的，确保测试的是被暴露的函数。</p><h1 id="多次传递相同参数的简单方法"><a href="#多次传递相同参数的简单方法" class="headerlink" title="多次传递相同参数的简单方法"></a>多次传递相同参数的简单方法</h1><p>在使用字符串格式化函数时，我总是觉得必须重复一个多次使用的参数很烦人：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Bob&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;My name is %s. Yes, you heard that right: %s\n&quot;</span>, name, name)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>还好还有更简便的方法，这样只需要传递一次参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">name := <span class="string">&quot;Bob&quot;</span>  </span><br><span class="line">fmt.Printf(<span class="string">&quot;My name is %[1]s. Yes, you heard that right: %[1]s\n&quot;</span>, name)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 Twitter 里发现的：<br><img src="https://s2.loli.net/2024/07/02/vaMP9CXwTEFcGKI.png"></p><p>希望你今天学到了一些新东西，最近有没有发现一些你从来不知道的 Golang 小技巧？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文链接：&lt;a href=&quot;https://medium.com/@andreiboar/5-small-tips-i-recently-learned-in-go-cf52d50cf129&quot;&gt;https:&amp;#x2F;&amp;#x2F;medium.com&amp;#x2F;@andreiboar&amp;#x2F;5-small-tips-i-recently-learned-in-go-cf52d50cf129&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;让编译器计算数组数量&quot;&gt;&lt;a href=&quot;#让编译器计算数组数量&quot; class=&quot;headerlink&quot; title=&quot;让编译器计算数组数量&quot;&gt;&lt;/a&gt;让编译器计算数组数量&lt;/h1&gt;&lt;p&gt;我们在 Go 通常很少使用数组 arrays，一般使用切片 Slice 来代替；&lt;/p&gt;
&lt;p&gt;但是当你需要使用的时候，如果你对需要指定数量大小感到很烦时可以使用 &lt;code&gt;[...]&lt;/code&gt; 让编译器自动帮我们计算数组大小：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr := [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sameArr := [...]&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125; &lt;span class=&quot;comment&quot;&gt;// Use ... instead of 3  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Arrays are equivalent  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fmt.Println(arr)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fmt.Println(sameArr)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="翻译" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="Go" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/Go/"/>
    
    
    <category term="Go" scheme="http://crossoverjie.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>如何找到并快速上手一个开源项目</title>
    <link href="http://crossoverjie.top/2024/07/01/ob/how-to-involve-OpenSource/"/>
    <id>http://crossoverjie.top/2024/07/01/ob/how-to-involve-OpenSource/</id>
    <published>2024-07-01T02:55:00.000Z</published>
    <updated>2024-07-01T01:29:40.460Z</updated>
    
    <content type="html"><![CDATA[<p>以前有写过两篇文章来简单聊过如何做开源的事情，最近我自己组了一个社区里面也有不少朋友对开源感兴趣，于是我便根据自己的经验系统的梳理了一些关于开源的事情。</p><ul><li><a href="https://crossoverjie.top/2023/08/05/ob/novice-contribute-open-source/">新手如何快速参与开源项目</a></li><li><a href="https://crossoverjie.top/2024/01/25/ob/create-a-plugin-for-cprobe/">手把手教你为开源项目贡献代码</a></li></ul><blockquote><p>有兴趣的可以先看看之前这两篇。</p></blockquote><span id="more"></span><h1 id="🔎如何找到自己感兴趣的开源项目"><a href="#🔎如何找到自己感兴趣的开源项目" class="headerlink" title="🔎如何找到自己感兴趣的开源项目"></a>🔎如何找到自己感兴趣的开源项目</h1><p>首先第一步先想清楚自己搞开源的目的是什么：</p><ul><li>参考社区大佬的代码，提升技术</li><li>丰富个人履历，提高面试通过率<ul><li>更功利一点就是想成为某个项目的 <code>Committer</code>&#x2F;<code>PMC</code></li></ul></li><li>单纯喜欢分享，热爱开源，认可开源改变世界💪。</li></ul><p>我人为前面三种都是一个目的，提升自己获得后续的好处；最后一种则是妥妥的纯热爱。</p><p>以我个人来说，我两者都沾一点；我相信大部分人都是前面三类的目的，到这里我可能要先浇点冷水。</p><blockquote><p>往往一个开源项目从你熟悉它开始到提第一个 PR 然后到合并中间经历的时间可能是大大超出你的预期的。</p></blockquote><p>特别是越大型越专业的项目（我相信你也是想加入这类有一定知名度的项目）。</p><p>因为开源社区大部分都是执行异步沟通，与即时通讯的快速反馈不同，甚至还有不少 reviewer 处于不同的时区。</p><p>所以一开始就想做好心理预期，不要指望着我给某个项目提交一个很牛逼的功能，然后他们快速 review 合并，然后给你 commit 权限。</p><p>而且有不少开源项目是由某一个公司主导的，比如（Pulsar、Golang、Kafka），他们可能对于外部社区来的新手并不那么上心，一个 PR 晾在那里几个月没人理都是很正常的。</p><p>所以我建议一开始选择的项目有以下几个筛选标准：</p><ul><li>尽量是自己日常在用，熟悉的项目。</li><li>最近有在及时更新维护的项目。</li><li>对社区新人的接纳程度是否足够包容。<ul><li>这点可以在 Github 里查找标签为 <code>help want/contribution welcome</code> 的 issue 或者是 PR。</li><li>查看这些 issue&#x2F; PR 最近的活跃时间，贡献者是否为新人。</li><li>往往一个包容度较高的项目以上信息都是很活跃的。</li></ul></li><li>项目主要维护者是否来着不同的公司，是否足够活跃。</li></ul><p><img src="https://s2.loli.net/2024/05/25/PIL8a5CoMbxRiwJ.png"><br><img src="https://s2.loli.net/2024/05/25/7CQaVFiAR4tyMbs.png"></p><p>推荐几个我认为比较符合我刚才提到的条件的项目：</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/7195">https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/7195</a></li><li><a href="https://github.com/apache/pulsar-client-go/issues?q=is:open+label:type/feature+sort:updated-desc">https://github.com/apache/pulsar-client-go/issues?q=is%3Aopen+label%3Atype%2Ffeature+sort%3Aupdated-desc</a></li><li><a href="https://github.com/apache/hertzbeat/">https://github.com/apache/hertzbeat/</a></li></ul><h1 id="🖐如何快速上手一个开源项目"><a href="#🖐如何快速上手一个开源项目" class="headerlink" title="🖐如何快速上手一个开源项目"></a>🖐如何快速上手一个开源项目</h1><p>如果找到了自己想贡献的项目，如果自己还不太熟悉的话，那就可以尝试以下步骤来快速上手它。</p><h2 id="✅单元测试"><a href="#✅单元测试" class="headerlink" title="✅单元测试"></a>✅单元测试</h2><p>首先第一个就是单元测试，单元测试是一个非常不错的方式来上手一个新的开源项目，<strong>但重点不是去看现有的单测，而是自己去写✍️</strong>。</p><p>写过单元测试的小伙伴就知道，如果要达到 90% 以上的覆盖率时需要对自己写的每一行代码都得了解，甚至在写的过程中会发现部分代码是不是没有必要，从而再帮助自己梳理一遍业务。</p><p>所以写单测确实是快速熟悉某个项目的方法，但这针对于一些逻辑简单的项目；对于一些业务复杂的项目建议还是快速跑通官方推荐一个功能。</p><h2 id="🌟以-Pulsar-为例"><a href="#🌟以-Pulsar-为例" class="headerlink" title="🌟以 Pulsar 为例"></a>🌟以 Pulsar 为例</h2><p>以 <a href="https://pulsar.apache.org/">Apache Pulsar</a>为例，那就先跑一个消息的生产者和消费者 demo；跑通了之后再尝试看看它客户端已有的单测代码，然后尝试改一些断言，此时就会发现预期值为什么会这么定义。<br><a href="https://github.com/apache/pulsar/blob/631b13ad23d7e48c6e82d38f97c23d129062cb7c/pulsar-broker/src/test/java/org/apache/pulsar/client/impl/BrokerClientIntegrationTest.java#L1077">https://github.com/apache/pulsar/blob/631b13ad23d7e48c6e82d38f97c23d129062cb7c/pulsar-broker/src/test/java/org/apache/pulsar/client/impl/BrokerClientIntegrationTest.java#L1077</a><br><img src="https://s2.loli.net/2024/05/17/CrITHSWeY1sP8dL.png"></p><p><img src="https://s2.loli.net/2024/05/17/J6DmLxQMZvuAqW7.png"></p><p>比如这里的一个 consumer 取消订阅两次时候就会抛出异常，此时我们就可以根据异常的地方找到源码里对连接状态的判断条件。</p><p>就可以得知：当客户端取消订阅时会修改连接状态。</p><h2 id="💓HertzBeat"><a href="#💓HertzBeat" class="headerlink" title="💓HertzBeat"></a>💓HertzBeat</h2><p>下面以 <a href="https://hertzbeat.apache.org/">Apache HertzBeat</a>为例来看看当时我是如何贡献单元测试的。</p><p><img src="https://s2.loli.net/2024/05/17/dixDGIQO2sZfh98.png"><br>通过官方的架构图可以得知 HertzBeat 是通过一个 collector 去直连目标采集数据的。</p><p>比如通过 Redis 的客户端去获取监控数据，然后再存放到自己的时序数据库中进行展示。</p><p>所以这个采集的过程就是比较核心的逻辑，我们可以看看他的接口定义。</p><p><img src="https://s2.loli.net/2024/05/17/3quVop5vSr6KzPY.png"><br>一共就三个接口，分别是：</p><ul><li>collect采集接口：在 Metrics 中定义了采集的目标信息（地址、端口等）<ul><li>采集完后的数据写入到 Builder 供后续的写入存储</li></ul></li><li>preCheck：提前做一些参数校验</li><li>supportProtocol：返回定义的协议类型，通过这个类型找到对应采集器</li></ul><p><img src="https://s2.loli.net/2024/05/17/hQZaFV2qo3176uf.png"></p><p>然后就交由不同的实现类去采集不同的指标。</p><p>这里我以 <code>RedisCommonCollectImpl</code>为例，主要的单测逻辑就是模拟 Redis 客户端的返回数据，然后在 Collect 的代码里查看不同的处理逻辑，其实就是要覆盖各种分支以及异常的情况。</p><p>最后再断言采集到的数据与预期是否匹配即可，贴一段核心逻辑：<br><img src="https://s2.loli.net/2024/05/17/EnrZxdDR5kLtMIG.png"></p><p>至于应该返回什么预期结果，有些 collector 可能会在代码注释里写清楚，但这个 Redis 没有写。</p><p>不过也有办法，我们可以把代码在本地跑起来之后进入管理台查看内置的监控模版。</p><p><img src="https://s2.loli.net/2024/05/17/g4EL7AdGfbrpXKU.png"><br>这里是用于定义会监控哪些字段的地方，这样我们就可以在代码预先生成好预期返回值了。</p><p><img src="https://s2.loli.net/2024/05/17/OCEYUZHscP6waI3.png"></p><p>具体的单测代码请看这里：<br><a href="https://github.com/apache/hertzbeat/blob/master/collector/src/test/java/org/apache/hertzbeat/collector/collect/redis/RedisClusterCollectImplTest.java#L46">https://github.com/apache/hertzbeat/blob/master/collector/src/test/java/org/apache/hertzbeat/collector/collect/redis/RedisClusterCollectImplTest.java#L46</a></p><h1 id="📝总结"><a href="#📝总结" class="headerlink" title="📝总结"></a>📝总结</h1><p>参与一个成熟社区的开源有一点一定要记住，<strong>就是要仔细阅读<a href="https://hertzbeat.apache.org/zh-cn/docs/community/contribution">贡献者文档</a>。</strong></p><p>里面往往会写清楚如何构建代码、代码规范、提交规范等信息，这些都捋清楚后提交的 PR 才更容易被社区接受。</p><p>后面会继续更新集成测试与 <code>e2e</code> 测试等内容。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前有写过两篇文章来简单聊过如何做开源的事情，最近我自己组了一个社区里面也有不少朋友对开源感兴趣，于是我便根据自己的经验系统的梳理了一些关于开源的事情。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/08/05/ob/novice-contribute-open-source/&quot;&gt;新手如何快速参与开源项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2024/01/25/ob/create-a-plugin-for-cprobe/&quot;&gt;手把手教你为开源项目贡献代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;有兴趣的可以先看看之前这两篇。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
  </entry>
  
  <entry>
    <title>OpenTelemetry 深度定制：跨服务追踪的实战技巧</title>
    <link href="http://crossoverjie.top/2024/06/26/ob/OpenTelemetry-custom-instrument/"/>
    <id>http://crossoverjie.top/2024/06/26/ob/OpenTelemetry-custom-instrument/</id>
    <published>2024-06-26T11:58:03.000Z</published>
    <updated>2024-07-01T01:33:40.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><img src="https://s2.loli.net/2024/05/19/7CnOFegSu4TLbhd.png"></p><p>在上一篇<a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">《从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅》</a>中在最后提到在做一些 Trace 的定制开发。</p><p>到现在差不多算是完成了，可以和大家分享一下。</p><p>我们的需求是这样的：</p><p><img src="https://s2.loli.net/2024/05/19/qex6IFcOnQ591gT.png"><br>假设现在有三个服务：ServiceA、ServiceB、ServiceC</p><span id="more"></span><p><code>ServiceA</code> 对外提供了一个 http 接口 <code>request</code>，在这个接口会调用 <code>ServiceB</code> 的 <code>order</code> 订单接口创建订单，同时 <code>serviceB</code> 调用 <code>serviceC</code> 的 pay 接口。</p><p><img src="https://s2.loli.net/2024/05/19/GtljX3BLVcePWFn.png"><br>整个调用关系如上图所示。</p><p>默认情况下 span 中的 attribute 会记录当前 span 的一些信息，比如：<br><img src="https://s2.loli.net/2024/05/19/tvgdT1Mke7OjPGp.png"><br>这些都是当前一些当前 span 内置的信息，比如当前 gRPC 接口的一些基本数据：服务名、ip、端口等信息。</p><p>但这里并没有上游的一些信息，虽然我们可以通过 Jaeger 的树状图得知上游是哪个应用调用过来的，但是一旦某个 span 下有多个子 span 的调用，就没办法很直观知道这个子 span 的上游是由谁发起的调用。</p><p>比如如下这个链路：<br><img src="https://s2.loli.net/2024/05/19/3rOdKfBmhSjz1GF.png"><br>当一个调用链非常长，同时也非常复杂时，没办法第一时间知道某一个 span 的上游到底是谁发起的，需要手动一层层的去折叠，或者全靠眼睛去找。</p><h2 id="预期效果"><a href="#预期效果" class="headerlink" title="预期效果"></a>预期效果</h2><p><img src="https://s2.loli.net/2024/05/19/9v3cGMrez8XA2ZH.png"></p><p>为此我们希望的效果是可以通过给每一个子 span 中加入两个 attribute，来标明它的父调用来源。</p><p>比如在 serviceB 中的所有 span 中都会加上两个标签：来源是 serviceA，同时是 serviceA 的 request 接口发起的请求。</p><p>而在 serviceC 中同样可以知道来源是 serviceB 的 Order 接口发起的调用。</p><p>我启动了三个 demo 应用，分别是 create1，create2，create3.</p><p>create1 中会提供一个 <code>request</code> 接口，在这里面调用 create2 的 <code>create2</code> 接口，<code>create2</code> 的接口里接着调用 create3 的 <code>create3</code> 接口。</p><p>create1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/request&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;  </span><br><span class="line">   <span class="type">HelloRequest</span> <span class="variable">request</span> <span class="operator">=</span> HelloRequest.newBuilder()  </span><br><span class="line">         .setName(name)  </span><br><span class="line">         .build();  </span><br><span class="line">   log.info(<span class="string">&quot;request: &#123;&#125;&quot;</span>, request);  </span><br><span class="line">   <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> myServiceStub.create2(request).getMessage();  </span><br><span class="line">   Executors.newFixedThreadPool(<span class="number">1</span>).execute(() -&gt; &#123;  </span><br><span class="line">      myServiceStub.create2(request).getMessage();  </span><br><span class="line">   &#125;);       <span class="keyword">return</span> message;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create2</span><span class="params">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;  </span><br><span class="line">    <span class="type">HelloReply</span> <span class="variable">reply</span> <span class="operator">=</span> HelloReply.newBuilder()  </span><br><span class="line">            .setMessage(<span class="string">&quot;Create2 ==&gt; &quot;</span> + request.getName())  </span><br><span class="line">            .build();  </span><br><span class="line">    log.info(<span class="string">&quot;Create2: &#123;&#125;&quot;</span>, reply.getMessage());  </span><br><span class="line">    myMethod(request.getName());  </span><br><span class="line">    myServiceStub.create3(request);</span><br><span class="line">    responseObserver.onNext(reply);  </span><br><span class="line">    responseObserver.onCompleted();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create3:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create3</span><span class="params">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;  </span><br><span class="line">    <span class="type">HelloReply</span> <span class="variable">reply</span> <span class="operator">=</span> HelloReply.newBuilder()  </span><br><span class="line">            .setMessage(<span class="string">&quot;Create3 ==&gt; &quot;</span> + request.getName())  </span><br><span class="line">            .build();  </span><br><span class="line">    log.info(<span class="string">&quot;Create3: &#123;&#125;&quot;</span>, reply.getMessage());  </span><br><span class="line">    myMethod(request.getName());  </span><br><span class="line">    responseObserver.onNext(reply);  </span><br><span class="line">    responseObserver.onCompleted();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.javaagent.extensions=otel-extensions-custom-context-1.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.traces.exporter=otlp \</span><br><span class="line">-Dotel.logs.exporter=none \</span><br><span class="line">-Dotel.service.name=create2 \</span><br><span class="line">-Dotel.exporter.otlp.protocol=grpc \</span><br><span class="line">-Dotel.propagators=tracecontext,baggage,demo \</span><br><span class="line">-Dotel.exporter.otlp.endpoint=http://127.0.0.1:5317 \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar --spring.application.name=create2 --server.port=9191 --grpc.server.port=9292 --grpc.client.myService.address=static://127.0.0.1:9393</span><br></pre></td></tr></table></figure><p>只是每个应用都需要使用我这边单独打的 agent 包以及一个 <code>extension</code>(tel-extensions-custom-context-1.0-SNAPSHOT.jar) 才能生效。</p><p>最终的效果如下：<br><img src="https://s2.loli.net/2024/05/19/4o5mEhjnMbZWL62.png"></p><h1 id="Baggage"><a href="#Baggage" class="headerlink" title="Baggage"></a>Baggage</h1><p>在讲具体的实现之前需要先了解几个 Trace 中的概念，在这里主要用到的是一个称为 Baggage 的对象。</p><p>在之前的文章中其实提到过它的原理以及使用场景：<br><a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/?highlight=%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%BD%E8%B8%AA%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E6%97%85#Baggage">从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅</a></p><p><img src="https://s2.loli.net/2024/05/19/gv2YEoO6LkiGIF9.png"></p><p>Baggage 的中文翻译是：包裹📦；简单来说就是我们可以通过自定义 baggage 可以将我们想要的数据存放在其中，这样再整个 Trace 的任意一个 Span 中都可以读取到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/request&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;  </span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">    Baggage.current().toBuilder().  </span><br><span class="line">          put(<span class="string">&quot;request.name&quot;</span>, name).build()  </span><br><span class="line">          .storeInContext(Context.current()).makeCurrent();</span><br><span class="line">&#125;         </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> Baggage.current().getEntryValue(<span class="string">&quot;request.name&quot;</span>);  </span><br><span class="line">log.info(<span class="string">&quot;request.name: &#123;&#125;&quot;</span>, value);</span><br></pre></td></tr></table></figure><p>理解了这个之后，我们要实现的将上游的信息传递到下游就可以通过这个组件实现了。</p><p>只需要在上游创建 span 时将它自身数据写入到 Baggage 中，再到下游 span 取出来写入到 attribute 中即可。</p><h1 id="ContextCustomizer"><a href="#ContextCustomizer" class="headerlink" title="ContextCustomizer"></a>ContextCustomizer</h1><p>这里的关键就是在哪里写入这个 Baggage，因为对第三方组件的 Instrumentation 的实现都是在 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation">opentelemetry-java-instrumentation</a>项目中。</p><blockquote><p>javaagent.jar 包也是通过该项目打包出来的。</p></blockquote><p>所以在该项目的 <code>io.opentelemetry.instrumentation.api.instrumenter.Instrumenter#doStart</code> 这个函数中我们发现一段逻辑：</p><p><img src="https://s2.loli.net/2024/05/20/FYiAnq2G3voIyR4.png"></p><hr><blockquote><p>这个函数是在创建一个 span 的时候调用的，通常这个创建函数是在这些第三方库的拦截器中创建的。</p></blockquote><p><img src="https://s2.loli.net/2024/05/20/b3cxYekiUGaSlO9.png"><br>比如这是在 grpc 的拦截器中调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context customizers run before span start, so that they can have access to the parent span  </span></span><br><span class="line"><span class="comment">// context, and so that their additions to the context will be visible to span processors  </span></span><br><span class="line"><span class="keyword">for</span> (ContextCustomizer&lt;? <span class="built_in">super</span> REQUEST&gt; contextCustomizer : contextCustomizers) &#123;  </span><br><span class="line">  context = contextCustomizer.onStart(context, request, attributes);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ContextCustomizer</code> 是一个接口只提供了一个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContextCustomizer</span>&lt;REQUEST&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** Allows to customize the operation &#123;<span class="doctag">@link</span> Context&#125;. */</span>  </span><br><span class="line">  Context <span class="title function_">onStart</span><span class="params">(Context parentContext, REQUEST request, Attributes startAttributes)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Context</code> 是上下文信息，可以在自定义的 ContextCustomizer 继续往上下文中追加信息。</li><li><code>REQUEST</code> 是一个泛型：一般是当前第三方组件的请求信息：<ul><li>比如是 <code>HTTP</code> 时，这个 <code>request</code> 就是 HTTP 的请求信息。</li><li>而如果是 <code>gRPC</code> ，则是 <code>gRPC</code> 的请求信息。</li><li>其他的请求类型同理。</li></ul></li><li><code>startAttributes</code> 则是预先写入的一些属性，比如在上图中看到的一些 <code>rpc.service/rpc.method</code>等字段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context customizers run before span start, so that they can have access to the parent span  </span></span><br><span class="line"><span class="comment">// context, and so that their additions to the context will be visible to span processors</span></span><br></pre></td></tr></table></figure><p>从这个接口的调用注释可以看出：<br>这个自定义的 context 会在 span 开始之前调用，所以在这里是可以访问到当前创建的 span 的父 context，同时在这里的 context 中新增的数据可以在 <code>SpanProcessor</code> 访问到。</p><h1 id="SpanProcessor"><a href="#SpanProcessor" class="headerlink" title="SpanProcessor"></a>SpanProcessor</h1><p>而 SpanProcessor 又是一个非常的重要的组件，我们接着刚才的 <code>contextCustomizer</code> 处往后跟踪代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context = contextCustomizer.onStart(context, request, attributes);</span><br><span class="line">---&gt;<span class="type">Span</span> <span class="variable">span</span> <span class="operator">=</span> spanBuilder.setParent(context).startSpan();</span><br><span class="line">---&gt;io.opentelemetry.sdk.trace.SdkSpanBuilder#startSpan</span><br><span class="line">---&gt;io.opentelemetry.sdk.trace.SdkSpan#startSpan</span><br><span class="line">---&gt;spanProcessor.onStart(parentContext, span);</span><br></pre></td></tr></table></figure><p>可以看到 <code>spanProcessor.onStart</code> 这个函数会在 contextCustomizer 之后调用。</p><p><img src="https://s2.loli.net/2024/05/20/vpxHt34TUbgfShz.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * SpanProcessor is the interface &#123;<span class="doctag">@link</span> SdkTracer&#125; uses to allow synchronous hooks for when a  </span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Span&#125; is started or when a &#123;<span class="doctag">@code</span> Span&#125; is ended.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//==========================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Called when a &#123;<span class="doctag">@link</span> io.opentelemetry.api.trace.Span&#125; is started, if the &#123;<span class="doctag">@link</span>  </span></span><br><span class="line"><span class="comment"> * Span#isRecording()&#125; returns true.  </span></span><br><span class="line"><span class="comment"> * * &lt;p&gt;This method is called synchronously on the execution thread, should not throw or block the  </span></span><br><span class="line"><span class="comment"> * execution thread. * * <span class="doctag">@param</span> parentContext the parent &#123;<span class="doctag">@code</span> Context&#125; of the span that just started.  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> span the &#123;<span class="doctag">@code</span> Span&#125; that just started.  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(Context parentContext, ReadWriteSpan span)</span>;</span><br></pre></td></tr></table></figure><p>从注释中可以知道 SpanProcessor 是作为一个 span 的生命周期中的关键节点的 hook 函数。</p><p>在这些函数中我们可以自定义一些 span 的数据，比如在 <code>onStart</code> 还可以往 span 中写入一些自定义的 attribute。</p><p>这也是我们这次会用到的一个接口，我们的方案是：</p><p>在 gRPC 构建 Instrument 时自定义一个 <code>GrpcServerContextCustomizer</code> ，在这个自定义的 <code>ContextCustomizer</code> 中写入一个 <code>Baggage</code>。</p><p>然后在 <code>io.opentelemetry.sdk.trace.SpanProcessor#onStart</code> 接口中取出这个 <code>Baggage</code> 写入到当前 span 的 attribute 中。</p><p>这样我们就可以看到之前提到的那些数据上游信息了。<br><img src="https://s2.loli.net/2024/05/19/4o5mEhjnMbZWL62.png"></p><h1 id="为-gRPC-添加上下文"><a href="#为-gRPC-添加上下文" class="headerlink" title="为 gRPC 添加上下文"></a>为 gRPC 添加上下文</h1><p>先来看看如何为 gRPC 添加 <code>Baggage</code>：</p><p>我们先自定义一个 <code>GrpcServerContextCustomizer</code> 实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrpcServerContextCustomizer</span> <span class="keyword">implements</span> <span class="title class_">ContextCustomizer</span>&lt;GrpcRequest&gt; &#123;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String currentServiceName;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARENT_RPC_KEY</span> <span class="operator">=</span> <span class="string">&quot;parent_rpc&quot;</span>;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CURRENT_RPC_KEY</span> <span class="operator">=</span> <span class="string">&quot;current_rpc&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CURRENT_HTTP_URL_PATH</span> <span class="operator">=</span> <span class="string">&quot;current_http_url_path&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">GrpcServerContextCustomizer</span><span class="params">(String serviceName)</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>.currentServiceName = serviceName;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">public</span> Context <span class="title function_">onStart</span><span class="params">(Context parentContext, GrpcRequest grpcRequest,  </span></span><br><span class="line"><span class="params">      Attributes startAttributeds)</span> &#123;  </span><br><span class="line">    <span class="type">BaggageBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Baggage.fromContext(parentContext).toBuilder();  </span><br><span class="line">  </span><br><span class="line">    <span class="type">String</span> <span class="variable">currentRpc</span> <span class="operator">=</span> Baggage.fromContext(parentContext).getEntryValue(CURRENT_RPC_KEY);  </span><br><span class="line">    <span class="type">String</span> <span class="variable">fullMethodName</span> <span class="operator">=</span> startAttributeds.get(AttributeKey.stringKey(<span class="string">&quot;rpc.method&quot;</span>));  </span><br><span class="line">    <span class="type">String</span> <span class="variable">rpcService</span> <span class="operator">=</span> startAttributeds.get(AttributeKey.stringKey(<span class="string">&quot;rpc.service&quot;</span>));  </span><br><span class="line">    <span class="comment">// call from grpc  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> rpcService + <span class="string">&quot;:&quot;</span> + fullMethodName;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">baggageInfo</span> <span class="operator">=</span> getBaggageInfo(currentServiceName, method);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">String</span> <span class="variable">httpUrlPath</span> <span class="operator">=</span> Baggage.fromContext(parentContext).getEntryValue(CURRENT_HTTP_URL_PATH);  </span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isNullOrEmpty(httpUrlPath)) &#123;  </span><br><span class="line">      <span class="comment">// call from http  </span></span><br><span class="line">      <span class="comment">// currentRpc = currentRpc;  currentRpc = create1|GET:/request      // clear current_http_url_path      builder.put(CURRENT_HTTP_URL_PATH, &quot;&quot;);  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">Baggage</span> <span class="variable">baggage</span> <span class="operator">=</span> builder  </span><br><span class="line">        .put(PARENT_RPC_KEY, currentRpc)  </span><br><span class="line">        .put(CURRENT_RPC_KEY, baggageInfo)  </span><br><span class="line">        .build();  </span><br><span class="line">    <span class="keyword">return</span> parentContext.with(baggage);  </span><br><span class="line">  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getBaggageInfo</span><span class="params">(String serviceName, String method)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNullOrEmpty(serviceName)) &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  </span><br><span class="line">    &#125;    <span class="keyword">return</span> serviceName + <span class="string">&quot;|&quot;</span> + method;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个代码中可以看出，我们需要先从上下文中获取 <code>CURRENT_RPC_KEY</code> ，从而得知当前的 span 是不是 root span。</p><p>所以我们其实是把当前的 span 信息作为一个 <code>PARENT_RPC_KEY</code> 写入到 Baggage 中。</p><p>这样在 <code>SpanProcessor</code> 中便可以直接取出 <code>PARENT_RPC_KEY</code> 作为上游的信息写入 span 的 attribute 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(Context parentContext, ReadWriteSpan span)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">parentRpc</span> <span class="operator">=</span> Baggage.fromContext(parentContext).getEntryValue(<span class="string">&quot;parent_rpc&quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isNullOrEmpty(parentRpc)) &#123;  </span><br><span class="line">        String[] split = parentRpc.split(<span class="string">&quot;\\|&quot;</span>);  </span><br><span class="line">        span.setAttribute(<span class="string">&quot;parent_rpc&quot;</span>, parentRpc);  </span><br><span class="line">        span.setAttribute(<span class="string">&quot;parent_service_name&quot;</span>, split[<span class="number">0</span>]);  </span><br><span class="line">        span.setAttribute(<span class="string">&quot;parent_service_method&quot;</span>, split[<span class="number">1</span>]); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，这里的 Baggage 需要使用 <code>Baggage.fromContext(parentContext)</code> 才能拿到刚才写入 Baggage 信息。</p></blockquote><p>之后我们找到构建 <a href="https://github.com/crossoverjie/opentelemetry-java-instrumentation/blob/715220c8d5e52001f9af9afbeb00bb87b4db0197/instrumentation/grpc-1.6/library/src/main/java/io/opentelemetry/instrumentation/grpc/v1_6/GrpcTelemetryBuilder.java#L31">gRPCServerInstrumenterBuilder</a> 的地方，写入我们刚才自定义的 <code>GrpcServerContextCustomizer</code> 即可。</p><p><img src="https://s2.loli.net/2024/05/20/rwSc8HmvqKL9ZQl.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.addContextCustomizer(<span class="keyword">new</span> <span class="title class_">GrpcServerContextCustomizer</span>(serviceName))</span><br></pre></td></tr></table></figure><p>这里我们选择写入到是 <code>serverInstrumenterBuilder</code> 而不是<code>clientInstrumenterBuilder</code>，因为在服务端的入口就知道是从哪个接口进来的请求。</p><h1 id="为-spring-boot-的-http-接口添加上下文"><a href="#为-spring-boot-的-http-接口添加上下文" class="headerlink" title="为 spring boot 的 http 接口添加上下文"></a>为 spring boot 的 http 接口添加上下文</h1><p>如果只存在 gRPC 调用时只添加 <code>gRPC</code> 的上下文也够用了，但是我们也不排除由外部接口是通过 HTTP 访问进来的，然后再调用内部的 <code>gRPC</code> 接口；这也是非常常见的架构模式。</p><p>所以我们还需要在 HTTP 中增加 <code>ContextCustomizer</code> 将自身的数据写入到 <code>Baggage</code> 中。</p><p>好在 <code>HttpServerRouteBuilder</code> 自身是实现了 <code>ContextCustomizer</code> 接口的，我们只需要往里面写入 <code>Baggage</code> 数据即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ContextCustomizer&lt;REQUEST&gt; <span class="title function_">build</span><span class="params">()</span> &#123;  </span><br><span class="line">  Set&lt;String&gt; knownMethods = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="built_in">this</span>.knownMethods);  </span><br><span class="line">  <span class="keyword">return</span> (context, request, startAttributes) -&gt; &#123;  </span><br><span class="line">    <span class="keyword">if</span> (HttpRouteState.fromContextOrNull(context) != <span class="literal">null</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> context;  </span><br><span class="line">    &#125;    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> getter.getHttpRequestMethod(request);  </span><br><span class="line">    <span class="keyword">if</span> (method == <span class="literal">null</span> || !knownMethods.contains(method)) &#123;  </span><br><span class="line">      method = <span class="string">&quot;HTTP&quot;</span>;  </span><br><span class="line">    &#125;    <span class="type">String</span> <span class="variable">urlPath</span> <span class="operator">=</span> getter.getUrlPath(request);  </span><br><span class="line">    <span class="type">String</span> <span class="variable">methodPath</span> <span class="operator">=</span> method + <span class="string">&quot;:&quot;</span> + urlPath;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">String</span> <span class="variable">currentRpc</span> <span class="operator">=</span> Baggage.fromContext(context).getEntryValue(CURRENT_RPC_KEY);  </span><br><span class="line">    <span class="type">String</span> <span class="variable">baggageInfo</span> <span class="operator">=</span> getBaggageInfo(serviceName, methodPath);  </span><br><span class="line">    <span class="type">Baggage</span> <span class="variable">baggage</span> <span class="operator">=</span> Baggage.fromContext(context).toBuilder()  </span><br><span class="line">        .put(PARENT_RPC_KEY, currentRpc)  </span><br><span class="line">        .put(CURRENT_RPC_KEY, baggageInfo)  </span><br><span class="line">        .put(CURRENT_HTTP_URL_PATH, methodPath)  </span><br><span class="line">        .build();   </span><br><span class="line">    <span class="keyword">return</span> context.with(HttpRouteState.create(method, <span class="literal">null</span>, <span class="number">0</span>))  </span><br><span class="line">        .with(baggage);  </span><br><span class="line">  &#125;;&#125;</span><br></pre></td></tr></table></figure><p>这里新增了 <code>CURRENT_HTTP_URL_PATH</code> 用于标记当前的请求来源是 HTTP，在 grpc 的 <code>ContextCustomizer</code> 解析时会判断这个值是否为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">httpUrlPath</span> <span class="operator">=</span> Baggage.fromContext(parentContext).getEntryValue(CURRENT_HTTP_URL_PATH);  </span><br><span class="line"><span class="keyword">if</span> (!StringUtils.isNullOrEmpty(httpUrlPath)) &#123;  </span><br><span class="line">  <span class="comment">// call from http  </span></span><br><span class="line">  <span class="comment">// currentRpc = currentRpc;  currentRpc = create1|GET:/request  // clear current_http_url_path  builder.put(CURRENT_HTTP_URL_PATH, &quot;&quot;);  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><img src="https://s2.loli.net/2024/05/20/ionwTD9EAr3CROL.png"></p><p>这样就可以在 grpc 的下游接口拿到入口的 HTTP 接口数据了。</p><hr><p>当然也有可能是在 grpc 接口中调用 HTTP 的接口的场景，只是我们的业务中没有这种情况，所以就没有适配这类的场景。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>ContextCustomizer</code> 接口没有提供对应的扩展，但是 <code>SpanProcessor</code> 是提供了扩展接口的。</p><blockquote><p>原本是想尽量别维护自己的 javaagent，但也好在 OpenTelemetry 是提供的接口，所以也并不会去修改原本的代码。</p></blockquote><p>所以我们还是需要创建一个 extensions 的项目在实现 <code>SpanProcessor</code>，这个在之前的 <a href="https://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/">《实战：如何编写一个 OpenTelemetry Extensions》</a>有详细讲到。</p><p>所以最后的应用启动方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.javaagent.extensions=otel-extensions-custom-context-1.0-SNAPSHOT.jar \</span><br></pre></td></tr></table></figure><p>需要使用我们手动打包的 javaagent 以及一个自定义扩展包。</p><p>打包方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew assemble</span><br></pre></td></tr></table></figure><blockquote><p><code>opentelemetry-java-instrumentation</code> 项目比较大，所以打包过程可能比较久。</p></blockquote><p>因为这其实是一些定制需求，所以就没提交到上游，感兴趣的可以自行合并代码测试。</p><p>最后可以这个分支中查看到修改的部分：<br><a href="https://github.com/crossoverJie/opentelemetry-java-instrumentation/compare/main...add-grpc-context">https://github.com/crossoverJie/opentelemetry-java-instrumentation/compare/main...add-grpc-context</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/05/19/7CnOFegSu4TLbhd.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一篇&lt;a href=&quot;https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/&quot;&gt;《从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅》&lt;/a&gt;中在最后提到在做一些 Trace 的定制开发。&lt;/p&gt;
&lt;p&gt;到现在差不多算是完成了，可以和大家分享一下。&lt;/p&gt;
&lt;p&gt;我们的需求是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/05/19/qex6IFcOnQ591gT.png&quot;&gt;&lt;br&gt;假设现在有三个服务：ServiceA、ServiceB、ServiceC&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>从 Prometheus 到 OpenTelemetry：指标监控的演进与实践</title>
    <link href="http://crossoverjie.top/2024/06/13/ob/OpenTelemetry-metrics-concept/"/>
    <id>http://crossoverjie.top/2024/06/13/ob/OpenTelemetry-metrics-concept/</id>
    <published>2024-06-13T10:22:48.000Z</published>
    <updated>2024-07-21T14:36:43.951Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇：<a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅</a>我们讲解了 Trace 的一些核心概念：</p><ul><li>Trace</li><li>Span</li><li>Context</li><li>Baggage 等</li></ul><p>这次我们来讲另一个话题 <code>Metrics</code>。</p><span id="more"></span><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>关于 metrics 我最早接触相关概念的就是 prometheus，它是第二个加入 CNCF（云原生）社区的项目（第一个是 kubernetes），可见在云原生领域 Metrics 指标监控从诞生之初就是一个非常重要的组件。</p><p>现实也确实如此，如今只要使用到了 kubernetes 相关的项目，对其监控就是必不可少的。</p><p>当然也不止是云原生的项目才需要 Metrics 指标监控，我们任何一个业务都是需要的，不然我们的服务运行对开发运维来说都是一个黑盒，无法知道此时系统的运行情况，因此才需要我们的业务系统将一些关键运行指标暴露出来。</p><p><img src="https://s2.loli.net/2024/05/12/1QWEAdFHqYzhl4g.png"></p><p>业务数据：比如订单的增长率、销售金额等业务数据；同时还有应用自身的资源占用情况：</p><ul><li>QPS</li><li>Latency</li><li>内存</li><li>CPU 等信息。</li></ul><p> 在使用 OpenTelemetry 之前，因为 prometheus 是这部分的绝对标准，所以我们通常都会使用 prometheus 的包来暴露这些指标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- The client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Hotspot JVM metrics--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_hotspot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>暴露一个自定义的指标也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.prometheus.client.Counter;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YourClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Counter</span> <span class="variable">requests</span> <span class="operator">=</span> Counter.build()</span><br><span class="line">     .name(<span class="string">&quot;requests_total&quot;</span>).help(<span class="string">&quot;Total requests.&quot;</span>).register();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    requests.inc();</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这是暴露一个单调递增的指标，prometheus 还提供了其他几种指标类型：</p></blockquote><ul><li>Counter</li><li>Gauge</li><li>Histogram</li></ul><p>之后我们只需要在 prometheus 中配置一些抓取规则即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;springboot&#x27;</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:8080&#x27;</span>] <span class="comment"># Spring Boot ip+port</span></span><br></pre></td></tr></table></figure><blockquote><p>当然如果是运行在 kubernetes 环境，prometheus 也可以基于服务发现配置一些规则，自动抓取我们的 Pod 的数据，由于不是本文的重点就不过多介绍。</p></blockquote><h1 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h1><p>在 OpenTelemetry 中自然也提供了 Metrics 这个组件，同时它也是完全兼容 Prometheus，所以我们理解和使用起来并不复杂。</p><h2 id="MeterProvider"><a href="#MeterProvider" class="headerlink" title="MeterProvider"></a>MeterProvider</h2><p>不同于 prometheus 客户端中直接提供了 Counter 就可以创建指标了，在 OpenTelemetry 中会提供一个 <code>MeterProvider</code> 的接口，使用这个接口可以获取 Meter，再使用 Meter 才可以创建 Counter、Gauge、Histogram 等数据。</p><p>下面来看看具体如何使用，这里我以 Pulsar 源码的代码进行演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InstrumentProvider</span><span class="params">(OpenTelemetry otel)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (otel == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// By default, metrics are disabled, unless the OTel java agent is configured.  </span></span><br><span class="line">        <span class="comment">// This allows to enable metrics without any code change.        otel = GlobalOpenTelemetry.get();  </span></span><br><span class="line">    &#125;    <span class="built_in">this</span>.meter = otel.getMeterProvider()  </span><br><span class="line">            .meterBuilder(<span class="string">&quot;org.apache.pulsar.client&quot;</span>)  </span><br><span class="line">            .setInstrumentationVersion(PulsarVersion.getVersion())  </span><br><span class="line">            .build();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">LongCounterBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> meter.counterBuilder(name)  </span><br><span class="line">        .setDescription(description)  </span><br><span class="line">        .setUnit(unit.toString());</span><br></pre></td></tr></table></figure><h2 id="Meter-Exporter"><a href="#Meter-Exporter" class="headerlink" title="Meter Exporter"></a>Meter Exporter</h2><p>Meter Exporter 则是一个 OpenTelemetry 独有的概念，与我们之前讲到的一样：OpenTelemetry 作为厂商无关的平台，允许我们将数据写入到任何兼容的产品里。</p><p>所以我们在使用 Metrics 时需要指定一个 exporter：</p><table><thead><tr><th>Exporter 类型</th><th>作用</th><th>备注</th><th>参数</th></tr></thead><tbody><tr><td>OTLP Exporter</td><td>通过 OpenTelemetry Protocol（OTLP） 发送指标数据到 collect。</td><td>默认生产环境中推荐使用，需要将数据发送到支持 OTLP 的后端，如 OpenTelemetry Collector。</td><td>-Dotel.metrics.exporter&#x3D;otlp (default)</td></tr><tr><td>Console Exporter</td><td>将指标数据打印到控制台的导出器。</td><td>开发和调试，快速查看指标数据。</td><td>-Dotel.metrics.exporter&#x3D;console</td></tr><tr><td>Prometheus Exporter</td><td>将指标数据以 Prometheus 抓取的格式暴露给 Prometheus 服务。</td><td>与 Prometheus 集成，适用于需要 Prometheus 监控的场景，这个可以无缝和以往使用 prometheus 的场景兼容</td><td>-Dotel.metrics.exporter&#x3D;prometheus</td></tr></tbody></table><h2 id="Metric-Instruments"><a href="#Metric-Instruments" class="headerlink" title="Metric Instruments"></a>Metric Instruments</h2><p>与 prometheus 类似，OpenTelemetry 也提供了以下几种指标类型：</p><ul><li><strong>Counter</strong>：单调递增计数器，比如可以用来记录订单数、总的请求数。</li><li><strong>UpDownCounter</strong>：与 Counter 类似，只不过它可以递减。</li><li><strong>Gauge</strong>：用于记录随时在变化的值，比如内存使用量、CPU 使用量等。</li><li><strong>Histogram</strong>：通常用于记录请求延迟、响应时间等。</li></ul><p>同时每个指标还有以下几个字段：</p><ul><li>Name：名称，必填。</li><li>Kind：类型，必填。</li><li>Unit：单位，可选。</li><li>Description：描述，可选。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">messageInCounter = meter  </span><br><span class="line">        .counterBuilder(MESSAGE_IN_COUNTER)  </span><br><span class="line">        .setUnit(<span class="string">&quot;&#123;message&#125;&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;The total number of messages received for this topic.&quot;</span>)  </span><br><span class="line">        .buildObserver();</span><br></pre></td></tr></table></figure><p>还是以 Pulsar 的为例，<code>messageInCounter</code> 是一个记录总的消息接收数量的 Counter 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subscriptionCounter = meter  </span><br><span class="line">        .upDownCounterBuilder(SUBSCRIPTION_COUNTER)  </span><br><span class="line">        .setUnit(<span class="string">&quot;&#123;subscription&#125;&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;The number of Pulsar subscriptions of the topic served by this broker.&quot;</span>)  </span><br><span class="line">        .buildObserver();</span><br></pre></td></tr></table></figure><p>这是记录一个订阅者数量的指标，类型是 UpDownCounter，也就是可以增加减少的指标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Double&gt; latencyHistogramBuckets =  </span><br><span class="line">        Lists.newArrayList(<span class="number">.0005</span>, <span class="number">.001</span>, <span class="number">.0025</span>, <span class="number">.005</span>, <span class="number">.01</span>, <span class="number">.025</span>, <span class="number">.05</span>, <span class="number">.1</span>, <span class="number">.25</span>, <span class="number">.5</span>, <span class="number">1.0</span>, <span class="number">2.5</span>, <span class="number">5.0</span>, <span class="number">10.0</span>, <span class="number">30.0</span>, <span class="number">60.0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">DoubleHistogramBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> meter.histogramBuilder(<span class="string">&quot;pulsar.client.producer.message.send.duration&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;Publish latency experienced by the application, includes client batching time&quot;</span>)  </span><br><span class="line">        .setUnit(Unit.Seconds.toString())  </span><br><span class="line">        .setExplicitBucketBoundariesAdvice(latencyHistogramBuckets);</span><br></pre></td></tr></table></figure><p>这是一个记录 Pulsar producer 发送延迟的指标，类型是 <code>Histogram</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">backlogQuotaAge = meter  </span><br><span class="line">        .gaugeBuilder(BACKLOG_QUOTA_AGE)  </span><br><span class="line">        .ofLongs()  </span><br><span class="line">        .setUnit(<span class="string">&quot;s&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;The age of the oldest unacknowledged message (backlog).&quot;</span>)  </span><br><span class="line">        .buildObserver();</span><br></pre></td></tr></table></figure><p>这是一个记录最大 unack 也就是 backlog 时间的指标，类型是 <code>Gauge</code>。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>在之前的文章：<a href="https://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/">实战：如何编写一个 OpenTelemetry Extensions</a>中讲过如何开发一个 OpenTelemetry 的 extension，其实当时我就是开发了一个用于在 Pulsar 客户端中暴露指标的一个插件。</p><blockquote><p>不过目前 Pulsar 社区已经集成了该功能。</p></blockquote><p>其中的核心代码与上面讲到的类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerObservers</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="type">Meter</span> <span class="variable">meter</span> <span class="operator">=</span> MetricsRegistration.getMeter();    </span><br><span class="line">    </span><br><span class="line">    meter.gaugeBuilder(<span class="string">&quot;pulsar_producer_num_msg_send&quot;</span>)    </span><br><span class="line">            .setDescription(<span class="string">&quot;The number of messages published in the last interval&quot;</span>)    </span><br><span class="line">            .ofLongs()    </span><br><span class="line">            .buildWithCallback(    </span><br><span class="line">                    r -&gt; recordProducerMetrics(r, ProducerStats::getNumMsgsSent));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recordProducerMetrics</span><span class="params">(ObservableLongMeasurement observableLongMeasurement, Function&lt;ProducerStats, Long&gt; getter)</span> &#123;    </span><br><span class="line">    <span class="keyword">for</span> (Producer producer : CollectionHelper.PRODUCER_COLLECTION.list()) &#123;    </span><br><span class="line">        <span class="type">ProducerStats</span> <span class="variable">stats</span> <span class="operator">=</span> producer.getStats();    </span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> producer.getTopic();    </span><br><span class="line">        <span class="keyword">if</span> (topic.endsWith(RetryMessageUtil.RETRY_GROUP_TOPIC_SUFFIX)) &#123;    </span><br><span class="line">            <span class="keyword">continue</span>;    </span><br><span class="line">        &#125;        observableLongMeasurement.record(getter.apply(stats),    </span><br><span class="line">                Attributes.of(PRODUCER_NAME, producer.getProducerName(), TOPIC, topic));    </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>只是这里使用了 <code>buildWithCallback</code> 回调函数，OpenTelemetry 会每隔 30s 调用一次这个函数，通常适用于 Gauge 类型的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent.jar \  </span><br><span class="line">     -Dotel.javaagent.extensions=ext.jar  \</span><br><span class="line">     -Dotel.metrics.exporter=prometheus \</span><br><span class="line">     -Dotel.exporter.prometheus.port=<span class="number">18180</span> \</span><br><span class="line">     -jar myapp.jar</span><br></pre></td></tr></table></figure><p>配合上 Prometheus 的两个启动参数就可以在本地 18180 中获取到指标数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:18180/metrics</span><br></pre></td></tr></table></figure><p>当然也可以直接发往 OpenTelemetry-Collector 中，再由它发往 prometheus，只是这样需要额外在 collector 中配置一下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">exporters:</span></span><br><span class="line">  <span class="attr">debug:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">otlphttp:</span></span><br><span class="line">    <span class="attr">metrics_endpoint:</span> <span class="string">http://promethus:8480/insert/0/opentelemetry/api/v1/push</span></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">pipelines:</span></span><br><span class="line">    <span class="attr">metrics:</span></span><br><span class="line">      <span class="attr">exporters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlphttp</span></span><br><span class="line">      <span class="attr">processors:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">k8sattributes</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">batch</span></span><br><span class="line">      <span class="attr">receivers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlp</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/12/4iMpax5Ptod2Nws.png"></p><p>这样我们就可以在 Grafana 中通过 prometheus 查询到数据了。</p><p>有一点需要注意，如果我们自定义的指标最好是参考官方的<a href="https://opentelemetry.io/docs/specs/semconv/general/metrics/">语义和命名规范</a>来定义这些指标名称。</p><p><img src="https://s2.loli.net/2024/05/12/vCDZY3ygX7MrzGH.png"></p><p>比如 OpenTelemetry 的规范中名称是用 <strong>.</strong> 来进行分隔的。</p><blockquote><p>切换为 OpenTelemetry 之后自然就不需要依赖 prometheus 的包，取而代之的是 OTel 的包：</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compileOnly <span class="string">&#x27;io.opentelemetry:opentelemetry-sdk-extension-autoconfigure-spi:1.34.1&#x27;</span>  </span><br><span class="line">compileOnly <span class="string">&#x27;io.opentelemetry.instrumentation:opentelemetry-instrumentation-api:1.32.0&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相对来说 Metrics 的使用比 Trace 简单的多，同时 Metrics 其实也可以和 Trace 进行关联，也就是 <a href="https://opentelemetry.io/docs/specs/otel/metrics/data-model/#exemplars">Exemplars</a>，限于篇幅就不在本文展开了，感兴趣的可以自行查阅。</p><p>参考链接：</p><ul><li><a href="https://github.com/apache/pulsar/blob/master/pulsar-client/src/main/java/org/apache/pulsar/client/impl/metrics/InstrumentProvider.java">https://github.com/apache/pulsar/blob/master/pulsar-client/src/main/java/org/apache/pulsar/client/impl/metrics/InstrumentProvider.java</a></li><li><a href="https://opentelemetry.io/docs/specs/semconv/general/metrics/">https://opentelemetry.io/docs/specs/semconv/general/metrics/</a></li><li><a href="https://opentelemetry.io/docs/specs/otel/metrics/data-model/#exemplars">https://opentelemetry.io/docs/specs/otel/metrics/data-model/#exemplars</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一篇：&lt;a href=&quot;https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/&quot;&gt;从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅&lt;/a&gt;我们讲解了 Trace 的一些核心概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trace&lt;/li&gt;
&lt;li&gt;Span&lt;/li&gt;
&lt;li&gt;Context&lt;/li&gt;
&lt;li&gt;Baggage 等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这次我们来讲另一个话题 &lt;code&gt;Metrics&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅</title>
    <link href="http://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/"/>
    <id>http://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/</id>
    <published>2024-06-05T16:55:16.000Z</published>
    <updated>2024-06-06T13:00:48.174Z</updated>
    
    <content type="html"><![CDATA[<p>在之前写过两篇比较系统的关于 OpenTelemetry 的文章：</p><ul><li><a href="https://juejin.cn/post/7358450927110357026">OpenTelemetry 实践指南：历史、架构与基本概念</a></li><li><a href="https://juejin.cn/post/7360216766373068837">实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术</a></li></ul><p>从基本概念到如何部署 demo 实战了解 OpenTelemetry，从那个 demo 中也可以得知整个 OpenTelemetry 体系的复杂性，包含了太多的组件和概念。</p><p>为了能更清晰的了解每个关键组件的作用以及原理，我打算分为几期来讲解 OpenTelemetry 的三个核心组件：</p><ul><li>Trace</li><li>Metrics</li><li>Logs</li></ul><p>首先以 Trace 讲起。</p><span id="more"></span><h1 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h1><p>开始之前还是先复习一下 Trace 的历史背景。</p><p>如今现代的分布式追踪的起源源自于 Google 在 2010 年发布的一篇论文：</p><ul><li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf">Dapper, a Large-Scale Distributed Systems Tracing Infrastructure</a></li></ul><p>在这篇论文中提出了分布式追踪的几个核心概念：</p><ul><li>Trace</li><li>Span<ul><li>Span 的一些基础数据结构</li></ul></li><li>可视化追踪以及展示</li></ul><p>之后 Twitter 受到了 Dapper 的启发开源了现在我们熟知的 <a href="https://zipkin.io/">Zipkin</a>，包含了存储和可视化 UI 展示我们的追踪链路。</p><p>Uber 也在 2015 年开源了 <a href="https://www.jaegertracing.io/">Jaeger</a> 项目，它的功能和 Zipkin 类似，但目前我们用的较多的还是 Jaeger；现在已经成为 CNCF 的托管项目。</p><p>之后陆续出现过 <strong>OpenTracing</strong> 和 <strong>OpenCensus</strong> 项目，他们都企图统一分布式追踪这一领域。</p><p>直到 <code>OpenTelemetry</code> 的出现整合了以上两个项目，并且逐渐成为可观测领域的标准。</p><blockquote><p>更多历史背景可以参考之前的文章：<a href="https://juejin.cn/post/7358450927110357026">OpenTelemetry 实践指南：历史、架构与基本概念</a></p></blockquote><p><img src="https://s2.loli.net/2024/05/05/ljQ6yNhKzn3b1c9.png"></p><p><img src="https://s2.loli.net/2024/05/05/NOEbTamR67x83nS.png"></p><p>这里我们结合 Dapper 论文中的资料进行分析，在这个调用中用户发起了一次请求，内部系统经历了 4 次 RPC 调用。</p><p>从第二张图会看到一些关键信息：</p><ul><li>spanName</li><li>parentId</li><li>spanId</li></ul><p>parentId 很好理解，主要是定义调用的主次关系；要注意的是并行调用时 parentId 是同一个。</p><p>spanId 在可以理解为每一个独立的操作，在这里就是一次 RPC 调用；同理一次数据库操作、消息的收发都是一个 span。</p><blockquote><p>span 的更多内容在后文继续讲解。</p></blockquote><h1 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h1><p><img src="https://s2.loli.net/2024/05/05/wyzLpbhYkjOUFav.png"><br>当我们把某一个具体的 span 放大会看到更加详细的信息，其中最关键的如下：</p><ul><li>traceId</li><li>spanName</li><li>spanId</li><li>parentId</li><li>开始时间</li><li>结束时间</li></ul><p>由于一个完整的 trace 链路由 N 个 span 组成，所以这个链路必须得有一个唯一的 traceId 将这些 span 串联起来。<br>这样才可以在可视化的时候更好的展示链路信息。</p><p>以上的这些字段很容易理解，都是一些必须的信息。</p><p>在 Dapper 论文中使用 Annotations 来存放 span 的属性，也就是刚才那些字段，当然也可以自定义存放一些数据，比如图中的 <code>&quot;foo&quot;</code>。</p><h2 id="OpenTelemetry-中的-Span"><a href="#OpenTelemetry-中的-Span" class="headerlink" title="OpenTelemetry 中的 Span"></a>OpenTelemetry 中的 Span</h2><p>OpenTelemetry 的 trace 自然也是基于 Dapper 的，只是额外做了一些优化，比如在刚才那些字段的基础上新增了一些概念：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/v1/sys/health&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;context&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;trace_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7bba9f33312b3dbb8b2c2c62bb7abe2d&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;span_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;086e83747d0e381e&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parent_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;start_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-10-22 16:04:01.209458162 +0000 UTC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;end_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-10-22 16:04:01.209514132 +0000 UTC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;STATUS_CODE_OK&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status_message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;net.transport&quot;</span><span class="punctuation">:</span> <span class="string">&quot;IP.TCP&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.peer.ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.17.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.peer.port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;51820&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.host.ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.177.2.152&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.host.port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;26040&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GET&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/v1/sys/health&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.server_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mortar-gateway&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.route&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/v1/sys/health&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.user_agent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Consul Health Check&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.scheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.177.2.152:26040&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.flavor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;events&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OK&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-10-22 16:04:01.209512872 +0000 UTC&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以这个 JSON 为例，新增了：</p><ul><li><input disabled="" type="checkbox"> <code>Span Context</code><ul><li><code>Span</code> 的上下文，存放的都是不可变的数据，因为每个 Span 之间是存在关联关系的，这些关联关系都是存放在 context 中，主要就是 trace_id, span_id.</li></ul></li><li><code>Attributes</code>: 可以理解为 Dapper 中的 Annotations，存放的是我们自定义的键值对，通常是由我们常用第三方开源 Instrumentation 内置的一些属性。</li><li><code>Span Events</code>: Span 的一些关键事件。</li></ul><p><img src="https://s2.loli.net/2024/05/05/3C49thIJOZTuf82.png"><br>比如我们常用的 Redis 客户端 lettuce，它就会自己记录一些 Attributes。</p><hr><p>如果有多个 span 存在依赖关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       [Span A]  ←←←(the root span)</span><br><span class="line">           |</span><br><span class="line">    +------+------+</span><br><span class="line">    |             |</span><br><span class="line">[Span B]      [Span C] ←←←(Span C is a `child` of Span A)</span><br><span class="line">    |             |</span><br><span class="line">[Span D]      +---+-------+</span><br><span class="line">              |           |</span><br><span class="line">          [Span E]    [Span F]</span><br></pre></td></tr></table></figure><p>大部分的可视化工具都是以时间线的方式进行展示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–&gt; time</span><br><span class="line"></span><br><span class="line"> [Span A···················································]</span><br><span class="line">   [Span B··········································]</span><br><span class="line">      [Span D······································]</span><br><span class="line">    [Span C····················································]</span><br><span class="line">         [Span E·······]        [Span F··]</span><br></pre></td></tr></table></figure><p>这些和 Dapper 中描述的概念没有本质区别。</p><hr><h3 id="Span-Status"><a href="#Span-Status" class="headerlink" title="Span Status"></a>Span Status</h3><p>Span 还内置了一些 Status：</p><ul><li><code>Unset</code></li><li><code>Error</code></li><li><code>Ok</code></li></ul><p>默认情况下是 Unset，出现错误时则是 Error，一切正常时则是 Ok。</p><p><img src="https://s2.loli.net/2024/05/05/glkIuxbFDBcai36.png"><br>通过可视化页面很容易得知某个 trace 中 span 的异常情况，点进去后可以看到具体的异常 span 以及它的错误日志。</p><h3 id="Span-Kind"><a href="#Span-Kind" class="headerlink" title="Span Kind"></a>Span Kind</h3><p>最后是 Span 的类型：</p><ul><li>Client</li><li>Server</li><li>Internal</li><li>Producer</li><li>Consumer</li></ul><p><img src="https://s2.loli.net/2024/05/05/rMjV9qsveNEKORW.png"></p><p>Client 和 Server 非常好理解，比如我们有一个 gRPC 接口，调用方的 Span 是 client，而服务端的 Span 自然就是 Server。</p><p>Internal 则是内部组件调用产生的 Span，这类 Span 相对会少一些。</p><p>Producer 和 Consumer 一般指的是发起异步调用时的 Span，我们常见的就是往消息队列里生产和消费消息。</p><p>通过这几种类型的 Span 也可以了解到什么情况下会创建 Span，通常是以下几种场景：</p><ul><li>RPC 调用</li><li>数据库（Redis、MySQL、Mongo 等等）操作</li><li>生产和消费消息</li><li>有意义的内部调用</li></ul><p>通常在一个函数内部再调用其他的本地函数是不用创建 span 的，不然这个链路会非常的长。</p><h2 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h2><p>当然也有一些特殊情况，比如我的某个内部函数非常重要，需要单独关心它的调用时长。</p><p>此时我们就可以使用 Annotations 来单独创建自己的 Span。</p><blockquote><p>这个 Annotations 和 Dapper 中的不是同一个，只是 Java 中的注解。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;  </span><br><span class="line">    Executors.newFixedThreadPool(<span class="number">1</span>).execute(() -&gt; &#123;  </span><br><span class="line">        myMethod(request.getName());  </span><br><span class="line">    &#125;);    </span><br><span class="line">    </span><br><span class="line">    <span class="type">HelloReply</span> <span class="variable">reply</span> <span class="operator">=</span> HelloReply.newBuilder()  </span><br><span class="line">            .setMessage(<span class="string">&quot;Hello ==&gt; &quot;</span> + request.getName())  </span><br><span class="line">            .build();  </span><br><span class="line">    responseObserver.onNext(reply);  </span><br><span class="line">    responseObserver.onCompleted();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@SneakyThrows</span>  </span><br><span class="line"><span class="meta">@WithSpan</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">(<span class="meta">@SpanAttribute(&quot;request.name&quot;)</span> String name)</span> &#123;  </span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);  </span><br><span class="line">    log.info(<span class="string">&quot;myMethod:&#123;&#125;&quot;</span>, name);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这段代码为例，这是一个 gRPC 的服务端接口，在这个接口中调用了一个函数 <code>myMethod</code>，默认情况下并不会为它单独创建一个 Span。</p><p>但如果我们想单独记录它，就可以使用 <code>@WithSpan</code> 这个注解，同时也可以使用  <code>@SpanAttribute</code> 来自定义 attribute。</p><p>最终的效果如下：<br><img src="https://s2.loli.net/2024/05/05/aBd1ubsS2kxMzGf.png"><br>此时就会单独为这个函数创建一个 Span。</p><blockquote><p>需要单独引入一个依赖:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.opentelemetry.instrumentation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opentelemetry-instrumentation-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Context-Propagation"><a href="#Context-Propagation" class="headerlink" title="Context Propagation"></a>Context Propagation</h1><p>上下文传播也是 Trace 中非常重要的概念，刚才提到了每个 Span 都有自己不可变的上下文，那么后续的 Span 如何和上游的 Span 进行关联呢？</p><p>这里有两种情况：</p><ul><li>同一进程</li><li>垮进程</li></ul><h2 id="同一进程"><a href="#同一进程" class="headerlink" title="同一进程"></a>同一进程</h2><p>同一个进程也分为两种情况：</p><ul><li>单线程</li><li>多线程</li></ul><p>单线程的比较好处理，我们只需要把数据写入 <code>ThreadLocal</code> 中就可以做到线程隔离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Context&gt; THREAD_LOCAL_STORAGE = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line"><span class="keyword">public</span> Context <span class="title function_">current</span><span class="params">()</span> &#123;  </span><br><span class="line">  <span class="keyword">return</span> THREAD_LOCAL_STORAGE.get();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这点我们可以通过源码 <code>io.opentelemetry.context.ThreadLocalContextStorage</code>看到具体的实现过程。</p><p>而如果是多线程时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executors.newFixedThreadPool(<span class="number">1</span>).execute(() -&gt; &#123;  </span><br><span class="line">    myMethod(request.getName());  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>则需要对使用的线程池进行单独处理，将父线程中 threadlocal 中的数据拷贝出来进行传递，比如有阿里提供的 <code>TransmittableThreadLocal</code>，可以提供对线程池的支持。</p><h2 id="跨进程"><a href="#跨进程" class="headerlink" title="跨进程"></a>跨进程</h2><p>而如果是垮进程的场景，就需要将 context 的信息进行序列化传递。</p><p>如果是 gRPC 调用会将信息存放到 metadata 中。</p><p>HTTP 调用则是存放在 header 中。</p><p>消息队列，比如 Pulsar 也可以将数据存放在消息中的 header 中进行传递。</p><p>数据一旦跨进程传输成功后，就和单进程一样的处理方式了。</p><h2 id="Baggage"><a href="#Baggage" class="headerlink" title="Baggage"></a>Baggage</h2><p><img src="https://s2.loli.net/2024/05/05/3c6LNtIbSkpQlRU.png"></p><p>有时候我们需要通过垮 Span 传递信息，比如如上图所示：<br>我们需要在 serverB 中拿到 serverA 中收到的一个请求参数： <code>http://127.0.0.1:8181/request\?name\=1232</code></p><p><img src="https://s2.loli.net/2024/05/05/hISQNv91KP85WFC.png"></p><p>这个数据默认会作为 span 的 attribute ，但只会存在于第一个 span。</p><p>如果我们想要在后续的 span 中也能拿到这个数据，甚至是垮进程也能获取到。</p><p>那就需要使用 <code>Baggage</code> 这个对象了。</p><p>它的使用也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/request&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;  </span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">    Baggage.current().toBuilder().  </span><br><span class="line">          put(<span class="string">&quot;request.name&quot;</span>, name).build()  </span><br><span class="line">          .storeInContext(Context.current()).makeCurrent();</span><br><span class="line">&#125;         </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> Baggage.current().getEntryValue(<span class="string">&quot;request.name&quot;</span>);  </span><br><span class="line">log.info(<span class="string">&quot;request.name: &#123;&#125;&quot;</span>, value);</span><br></pre></td></tr></table></figure><p>只要是属于同一个 trace 的调用就可以直接获取到数据。<br><img src="https://s2.loli.net/2024/05/05/Lz1hY8pflRebANx.png"></p><blockquote><p>traceId 也是垮 Span 传递的。</p></blockquote><p>而它的原理也是通过往 context 中写入数据实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span>  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaggageContextKey</span> &#123;  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ContextKey&lt;Baggage&gt; KEY = ContextKey.named(<span class="string">&quot;opentelemetry-baggage-key&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">BaggageContextKey</span><span class="params">()</span> &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/05/vIHtBxGATKOg13l.png"><br>而这个 context 是通过一个 entries 数据存储数据的，不管是在内部还是外部的跨进程调用，OpenTelemetry 都会将 context 通过 <code>Context Propagation</code> 传递出去。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Trace 这部分的内容我觉得比 Metrics 和 Logs 更加复杂一些，毕竟多了一些数据结构；现在的内容也只是冰山一角，现在也在做 trace 的一些定制化开发，后续有新的进展会接着更新。</p><p>参考链接：</p><ul><li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf">https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf</a></li><li><a href="https://opentelemetry.io/docs/languages/java/automatic/annotations/">https://opentelemetry.io/docs/languages/java/automatic/annotations/</a></li><li><a href="https://opentelemetry.io/docs/specs/otel/overview/#tracing-signal">https://opentelemetry.io/docs/specs/otel/overview/#tracing-signal</a></li><li><a href="https://opentelemetry.io/docs/concepts/context-propagation/">https://opentelemetry.io/docs/concepts/context-propagation/</a></li><li><a href="https://opentelemetry.io/docs/concepts/observability-primer/#distributed-traces">https://opentelemetry.io/docs/concepts/observability-primer/#distributed-traces</a></li><li><a href="https://tech.meituan.com/2023/04/20/traceid-google-dapper-mtrace.html">https://tech.meituan.com/2023/04/20/traceid-google-dapper-mtrace.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前写过两篇比较系统的关于 OpenTelemetry 的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7358450927110357026&quot;&gt;OpenTelemetry 实践指南：历史、架构与基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7360216766373068837&quot;&gt;实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从基本概念到如何部署 demo 实战了解 OpenTelemetry，从那个 demo 中也可以得知整个 OpenTelemetry 体系的复杂性，包含了太多的组件和概念。&lt;/p&gt;
&lt;p&gt;为了能更清晰的了解每个关键组件的作用以及原理，我打算分为几期来讲解 OpenTelemetry 的三个核心组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trace&lt;/li&gt;
&lt;li&gt;Metrics&lt;/li&gt;
&lt;li&gt;Logs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先以 Trace 讲起。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>【译】几个你或许并不知道 kubernetes 技巧</title>
    <link href="http://crossoverjie.top/2024/06/03/ob/Kubernetes-tricks/"/>
    <id>http://crossoverjie.top/2024/06/03/ob/Kubernetes-tricks/</id>
    <published>2024-06-03T10:05:25.000Z</published>
    <updated>2024-06-03T13:10:27.508Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/06/03/AoNyHhS4sl96tFx.png"></p><p>原文链接: <a href="https://overcast.blog/13-kubernetes-tricks-you-didnt-know-647de6364472">https://overcast.blog/13-kubernetes-tricks-you-didnt-know-647de6364472</a></p><h1 id="使用-PreStop-优雅关闭-Pod"><a href="#使用-PreStop-优雅关闭-Pod" class="headerlink" title="使用 PreStop 优雅关闭 Pod"></a>使用 PreStop 优雅关闭 Pod</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">graceful-shutdown-example</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sample-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;sleep 30 &amp;&amp; nginx -s quit&quot;</span>]</span><br></pre></td></tr></table></figure><p>PreStop 允许 Pod 在终止前执行一个命令或者是脚本，使用它就可以在应用退出前释放一些资源，确保应用可以优雅退出。</p><p>比如可以在 Nginx 的 Pod 退出前将当前的请求执行完毕。</p><span id="more"></span><h1 id="使用临时容器调试-Pod"><a href="#使用临时容器调试-Pod" class="headerlink" title="使用临时容器调试 Pod"></a>使用临时容器调试 Pod</h1><p>临时容器可以不修改一个运行的容器的前提下调试容器，可以很方便的调试一些生产环境的 bug，可以避免重启应用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl alpha debug -it podname --image=busybox --target=containername</span><br></pre></td></tr></table></figure><p>生产环境谨慎使用，只有在当前环境下无法排查问题的时候才使用。</p><h1 id="基于自定义的-Metrics-自动扩容Pod"><a href="#基于自定义的-Metrics-自动扩容Pod" class="headerlink" title="基于自定义的  Metrics 自动扩容Pod"></a>基于自定义的  Metrics 自动扩容Pod</h1><p>kubernetes 是提供了 HPA 机制可以跟进 CPU 内存等标准数据进行自动扩缩容，但有时我们需要根据自定义的数据进行扩缩容。</p><p>比如某个接口的延迟、队列大小等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">custom-metric-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">your-application</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span></span><br><span class="line">    <span class="attr">pods:</span></span><br><span class="line">      <span class="attr">metric:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">your_custom_metric</span></span><br><span class="line">      <span class="attr">target:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">AverageValue</span></span><br><span class="line">        <span class="attr">averageValue:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="用-Init-Containers-配置启动脚本"><a href="#用-Init-Containers-配置启动脚本" class="headerlink" title="用 Init Containers 配置启动脚本"></a>用 Init Containers 配置启动脚本</h1><p>初始化容器可以在应用容器启动前运行，我们可以使用它来初始化应用需要的配置、等待依赖的服务启动完成等工作：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-myservice</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;</span>]</span><br></pre></td></tr></table></figure><p>比如这个初始化容器会等待 myservice 可用后才会启动应用。</p><p>需要注意的是如果初始化容器会阻塞应用启动，所以要避免在初始化容器里执行耗时操作。</p><h1 id="Node-亲和性调度"><a href="#Node-亲和性调度" class="headerlink" title="Node 亲和性调度"></a>Node 亲和性调度</h1><p>当我们需要将某些应用部署到硬件配置较高的节点时（比如需要 SSD 硬盘），就可以使用节点亲和性来部署应用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">with-node-affinity</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">with-node-affinity</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">disktype</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ssd</span></span><br></pre></td></tr></table></figure><p>这个 Pod 会被部署到有这个 <code>disktype=ssd</code> 标签的 节点上。</p><h1 id="动态配置：ConfigMap-和-Secrets"><a href="#动态配置：ConfigMap-和-Secrets" class="headerlink" title="动态配置：ConfigMap 和 Secrets"></a>动态配置：ConfigMap 和 Secrets</h1><p>ConfigMap 和 Secrets可以动态注入到 Pod 中，避免对这些配置硬编码。</p><p>ConfigMap 适合非敏感的数据，Secrets 适合敏感的数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ConfigMap Example</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">config.json:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;key&quot;: &quot;value&quot;,</span></span><br><span class="line"><span class="string">      &quot;databaseURL&quot;: &quot;http://mydatabase.example.com&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="comment"># Pod Spec using ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">myapp</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">app-config</span></span><br></pre></td></tr></table></figure><p>这样在应用中就可以通过这路径 <code>/etc/config/config.json</code> 读取数据了。</p><blockquote><p>当然也可以把这些数据写入到环境变量中。</p></blockquote><p>以上这些个人技巧用的最多的是：</p><ul><li>临时容器调试 Pod，特别是业务容器缺少一些命令时。</li><li>Init Container 等待依赖的服务启动完成。</li><li>Node 亲和性调度。</li><li>ConfigMap 是基础操作了。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/06/03/AoNyHhS4sl96tFx.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&quot;https://overcast.blog/13-kubernetes-tricks-you-didnt-know-647de6364472&quot;&gt;https://overcast.blog/13-kubernetes-tricks-you-didnt-know-647de6364472&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;使用-PreStop-优雅关闭-Pod&quot;&gt;&lt;a href=&quot;#使用-PreStop-优雅关闭-Pod&quot; class=&quot;headerlink&quot; title=&quot;使用 PreStop 优雅关闭 Pod&quot;&gt;&lt;/a&gt;使用 PreStop 优雅关闭 Pod&lt;/h1&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;apiVersion:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;v1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kind:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Pod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;metadata:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;graceful-shutdown-example&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;spec:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;containers:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;sample-container&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;image:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;nginx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;lifecycle:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;preStop:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;exec:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attr&quot;&gt;command:&lt;/span&gt; [&lt;span class=&quot;string&quot;&gt;&amp;quot;/bin/sh&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;-c&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;sleep 30 &amp;amp;&amp;amp; nginx -s quit&amp;quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;PreStop 允许 Pod 在终止前执行一个命令或者是脚本，使用它就可以在应用退出前释放一些资源，确保应用可以优雅退出。&lt;/p&gt;
&lt;p&gt;比如可以在 Nginx 的 Pod 退出前将当前的请求执行完毕。&lt;/p&gt;</summary>
    
    
    
    <category term="翻译" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="kubernetes" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/kubernetes/"/>
    
    
    <category term="kubernetes" scheme="http://crossoverjie.top/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术</title>
    <link href="http://crossoverjie.top/2024/05/26/ob/OTel-demo/"/>
    <id>http://crossoverjie.top/2024/05/26/ob/OTel-demo/</id>
    <published>2024-05-26T02:49:02.000Z</published>
    <updated>2024-05-26T11:35:45.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇文章 <a href="https://crossoverjie.top/2024/05/21/ob/OpenTelemetry-getstart/">OpenTelemetry 实践指南：历史、架构与基本概念</a>中回顾了可观测性的历史以及介绍了一些 OpenTelemetry 的基础概念，同时也介绍了 OpenTelemetry 社区常用的开源项目。</p><p>基础背景知识了解后，这篇就来介绍一下使用 OpenTelemetry 如何实战部署应用，同时在一个可视化页面查看 trace、metric 等信息。</p><span id="more"></span><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>我们参考官方文档构建几个 spring boot 、Golang 项目再配合 Agent 其实也可以很方便的集成 OpenTelemetry。</p><p>但是要完整的体验 OpenTelemetry 的所有功能，包含 trace、logs、metrics，还有社区这么多语言的支持其实还是比较麻烦的。</p><p>我们还需要单独部署 collector、存储的 backend service 等组件、包括 trace UI 展示所需要的 Jaeger，metric 所需要的 grafana 等。</p><p>这些所有东西都自己从头弄的话还是比较费时，不过好在社区已经将这些步骤都考虑到了。</p><p>特地为大家写了一个 <a href="https://github.com/open-telemetry/opentelemetry-demo">opentelemetry-demo</a>。</p><p>这个项目模拟了一个微服务版本的电子商城，主要包含了以下一些项目：</p><table><thead><tr><th>Service</th><th>Language</th><th>Description</th></tr></thead><tbody><tr><td><a href="accounting/">accountingservice</a></td><td>Go</td><td>处理和计算订单数据</td></tr><tr><td><a href="ad/">adservice</a></td><td>Java</td><td>广告服务</td></tr><tr><td><a href="cart/">cartservice</a></td><td>.NET</td><td>购物车服务，主要会依赖 Redis</td></tr><tr><td><a href="checkout/">checkoutservice</a></td><td>Go</td><td>checkout</td></tr><tr><td><a href="currency/">currencyservice</a></td><td>C++</td><td>货币转换服务，提供了较高的 QPS 能力。</td></tr><tr><td><a href="email/">emailservice</a></td><td>Ruby</td><td>邮件服务</td></tr><tr><td><a href="fraud-detection/">frauddetectionservice</a></td><td>Kotlin</td><td>风控服务</td></tr><tr><td><a href="frontend/">frontend</a></td><td>JavaScript</td><td>前端应用</td></tr><tr><td><a href="load-generator/">loadgenerator</a></td><td>Python&#x2F;Locust</td><td>模拟压测服务</td></tr><tr><td><a href="payment/">paymentservice</a></td><td>JavaScript</td><td>支付服务</td></tr><tr><td><a href="product-catalog/">productcatalogservice</a></td><td>Go</td><td>商品服务</td></tr><tr><td><a href="quote/">quoteservice</a></td><td>PHP</td><td>成本服务</td></tr><tr><td><a href="recommendation/">recommendationservice</a></td><td>Python</td><td>推荐服务</td></tr><tr><td><a href="shipping/">shippingservice</a></td><td>Rust</td><td>shipping service</td></tr><tr><td>可以发现在这个 demo 中提供了许多的服务，而且包含了几乎所有主流的语言，可以很好的模拟我们实际的使用场景了。</td><td></td><td></td></tr></tbody></table><p><img src="https://s2.loli.net/2024/04/20/NahleoLGbv9tSuE.png"></p><p>通过这张图可以更直观的查看各个服务之间的关系。</p><p>整体来说前端所有的请求都会通过 <code>front-end-proxy</code> 这个组件代理，最终再由 front 这个服务进行转发到不同的后端服务中。</p><hr><p><img src="https://s2.loli.net/2024/04/20/wLVI1mSzYKjt2Fo.png"><br>除了一个项目的架构图之外，还有一个关于 OpenTelemetry 的数据流转图。</p><p>在 OpenTelemetry 中数据流转是它的特点也是非常重要的核心，这点在上一篇文章中讲过，用户可以自由定制数据的流转以及任意的处理数据，在这个图中就将数据流转可视化了。</p><ul><li>客户端可以通过 OTLP 协议或者是 HTTP 将数据上传到 OTel Collector 中。</li><li>在 collector 中会根据我们配置的 Process pipeline 处理数据。</li><li>Metric 数据通过  OTLP HTTP exporter 将数据导入到 Prometheus 中。<ul><li><a href="https://github.com/prometheus/prometheus/pull/12571">Prometheus</a> 已经于 23 年七月份支持 OTLP 格式的 metric 数据导入了。</li></ul></li><li>Trace 数据则是通过 OTLP Exporter 写入到 Jaeger 中进行存储，最后通过 Jaeger 的 UI 进行查询展示。</li><li>而存入 Prometheus 中的 metric 数据则是有 grafana 进行查询。</li></ul><blockquote><p>关于 collector 的配置会在后文讲解。</p></blockquote><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>接下来便是安装 Demo 了，我更推荐使用 helm 安装。</p><p>这里的版本要求是：</p><ul><li>Kubernetes 1.24+</li><li>Helm 3.9+</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm repo add open-telemetry https://open-telemetry.github.io/opentelemetry-helm-charts</span><br><span class="line">helm repo update</span><br><span class="line">helm install my-otel-demo open-telemetry/opentelemetry-demo</span><br></pre></td></tr></table></figure><p>这样就可以很简单的将 demo 所涉及到的所有组件和服务都安装到 default 命名空间中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm show values open-telemetry/opentelemetry-demo &gt; demo.yaml</span><br></pre></td></tr></table></figure><p>不过在安装前还是建议先导出一份 value.yaml，之后可以使用这个 yaml 定制需要安装的组件。</p><p>在这个 yaml 中我们可以看到有哪些组件和服务可以定制：<br><img src="https://s2.loli.net/2024/04/20/oe2S1fr3xPcypB4.png"><br>可以看到这里包含了我们刚才提到的所有服务，以及这些服务所依赖的 Kafka、redis、Prometheus 等中间件，都可以自己进行定制修改。</p><p><img src="https://s2.loli.net/2024/04/20/VP5GvtszWolSBnf.png"><br>当所有的 Pod 都成功运行之后表示安装成功。</p><blockquote><p>正常情况下安装不会有什么问题，最大可能的问题就是镜像拉取失败，此时我们可以先在本地手动 docker pull 下来镜像后再上传到私服，然后修改 deployment 中的镜像地址即可。</p></blockquote><h2 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h2><p>为了方便使用我们可以用这个 demo 进行测试，还需要将 front-proxy 的服务暴露出来可以在本地访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl port-forward svc/my-otel-demo-frontendproxy 8080:8080</span><br></pre></td></tr></table></figure><table><thead><tr><th>Component</th><th>Path</th></tr></thead><tbody><tr><td>Shop 首页</td><td><a href="http://localhost:8080/">http://localhost:8080</a></td></tr><tr><td>Grafana</td><td><a href="http://localhost:8080/grafana">http://localhost:8080/grafana</a></td></tr><tr><td>压测页面</td><td><a href="http://localhost:8080/loadgen">http://localhost:8080/loadgen</a></td></tr><tr><td>Jaeger UI</td><td><a href="http://localhost:8080/jaeger/ui">http://localhost:8080/jaeger/ui</a></td></tr><tr><td>正常情况下就可以打开这些页面进行访问了。</td><td></td></tr></tbody></table><p>不过使用 port-forward 转发的方式只是临时方案，使用 ctrl+c 就会停止暴露服务，所以如果想要一个稳定的访问链接时便可以配置一个 ingress。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">components:</span></span><br><span class="line">  <span class="attr">frontendProxy:</span></span><br><span class="line">    <span class="attr">ingress:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">annotations:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">hosts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">otel-demo.my-domain.com</span></span><br><span class="line">          <span class="attr">paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在之前的 helm 的 value.yaml 中配置即可，本地测试的话需要将这个 host 和 ingress 暴露出来的 IP 进行绑定才可以使用这个域名机进行访问。</p><p>更多关于 ingress 的使用可以参考我之前的文章：</p><ul><li><a href="https://crossoverjie.top/2023/09/15/ob/k8s-Ingress/">k8s入门到实战-使用Ingress</a></li></ul><p>当然简单起见也可以直接将 front-proxy 的 service 类型改为 LoadBalancer。（默认是 ClusterIP 只可以在集群内访问）</p><p>这样就可以直接通过这个 service 的 IP 进行访问了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">components:</span></span><br><span class="line">  <span class="attr">frontendProxy:</span></span><br><span class="line">    <span class="attr">service:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br></pre></td></tr></table></figure><blockquote><p>不过需要注意的是如果 demo 安装完成之后是不可以再次修改 service 的类型的，需要手动这个 service 删掉之后再次新建才可以。</p></blockquote><p> 临时测试使用的话还是推荐直接使用 port-forward 进行转发。</p><h1 id="查看-Trace"><a href="#查看-Trace" class="headerlink" title="查看 Trace"></a>查看 Trace</h1><p>通过之前的项目架构图可以得知，我们在项目首页刷新会直接请求 AdService 来获取广告。</p><p>为了简单起见我们只查询这一链路的调用情况：<br><img src="https://s2.loli.net/2024/04/21/t6a4KvOhSne9yfu.png"></p><p>打开 <a href="http://localhost:8080/jaeger/ui/search">http://localhost:8080/jaeger/ui/search</a> Jeager 的 UI 页面便可以筛选服务，之后点击查找 Traces 就可以列出一段时间内的访问 trace。</p><p><img src="https://s2.loli.net/2024/04/21/v8nVLxweyCO9NMm.png"><br>可以看到这个请求链路是从前端访问到 adService 中的 <code>getAds()</code>接口，然后在这个接口中再访问了 <code>getAdsByCategory</code> 函数。<br><img src="https://s2.loli.net/2024/04/21/3UXmHsCSLFguRZK.png"></p><p>最终在源码中也可以看到符合链路的调用代码。</p><blockquote><p>在刚才的链路图的右下角有一个 spanID，整个 trace 是由这些小的 span 组成，每一个 span 也会有唯一 spanID； trace 也会有一个 traceID 将这些 span 串联起来；更多关于 trace 的内容会在后面的文章进行分析。</p></blockquote><h2 id="查看-Metrics"><a href="#查看-Metrics" class="headerlink" title="查看 Metrics"></a>查看 Metrics</h2><p>我们再打开 grafana 便可以看到刚才访问的 adService 的延迟和接口的 QPS 情况：<br><img src="https://s2.loli.net/2024/04/21/29BlRATOnpkCQwS.png"></p><hr><p>在opentelemetry-collector-data-flow 面板中还可以看到 OpenTelemetry 的数据流转。<br><img src="https://s2.loli.net/2024/04/21/Tbtiv3gzY5xZIH1.png"></p><blockquote><p>更多监控信息可以查看其它的面板。</p></blockquote><p>而刚才面板中的数据流转规则则是在我们的 <a href="https://github.com/open-telemetry/opentelemetry-demo/blob/main/src/otelcollector/otelcol-config.yml">collector</a> 中进行配置的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">receivers:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">protocols:</span></span><br><span class="line">      <span class="attr">grpc:</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">cors:</span></span><br><span class="line">          <span class="attr">allowed_origins:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;http://*&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;https://*&quot;</span></span><br><span class="line">  <span class="attr">httpcheck/frontendproxy:</span></span><br><span class="line">    <span class="attr">targets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">endpoint:</span> <span class="string">http://frontendproxy:$&#123;env:ENVOY_PORT&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">exporters:</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">&quot;jaeger:4317&quot;</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">otlphttp/prometheus:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">&quot;http://prometheus:9090/api/v1/otlp&quot;</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">opensearch:</span></span><br><span class="line">    <span class="attr">logs_index:</span> <span class="string">otel</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">endpoint:</span> <span class="string">&quot;http://opensearch:9200&quot;</span></span><br><span class="line">      <span class="attr">tls:</span></span><br><span class="line">        <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="attr">batch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">connectors:</span></span><br><span class="line">  <span class="attr">spanmetrics:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">pipelines:</span></span><br><span class="line">    <span class="attr">traces:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">otlp</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">otlp</span>, <span class="string">debug</span>, <span class="string">spanmetrics</span>]</span><br><span class="line">    <span class="attr">metrics:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">httpcheck/frontendproxy</span>, <span class="string">otlp</span>, <span class="string">spanmetrics</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">otlphttp/prometheus</span>, <span class="string">debug</span>]</span><br><span class="line">    <span class="attr">logs:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">otlp</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">opensearch</span>, <span class="string">debug</span>]</span><br></pre></td></tr></table></figure><p>重点的就是这里的 <code>service.piplines</code>，可以进行任意的组装。</p><p>更多关于 collector 的配置也会在后续文章中继续讲解。</p><p>我们也可以继续访问这个 demo 网站，模拟加入购物车、下单等行为，再结合 trace 和 metric 观察系统的变化。</p><p>这样一个完整的 OpenTelemetry-Demo 就搭建完毕了，我们实际在生产环境使时完全可以参考这个 demo 进行配置，可以少踩很多坑。</p><p>参考链接：</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-demo/blob/main/src/adservice/Dockerfile">https://github.com/open-telemetry/opentelemetry-demo/blob/main/src/adservice/Dockerfile</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-demo">https://github.com/open-telemetry/opentelemetry-demo</a></li><li><a href="https://github.com/prometheus/prometheus/pull/12571">https://github.com/prometheus/prometheus/pull/12571</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-demo/blob/main/src/otelcollector/otelcol-config.yml">https://github.com/open-telemetry/opentelemetry-demo/blob/main/src/otelcollector/otelcol-config.yml</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇文章 &lt;a href=&quot;https://crossoverjie.top/2024/05/21/ob/OpenTelemetry-getstart/&quot;&gt;OpenTelemetry 实践指南：历史、架构与基本概念&lt;/a&gt;中回顾了可观测性的历史以及介绍了一些 OpenTelemetry 的基础概念，同时也介绍了 OpenTelemetry 社区常用的开源项目。&lt;/p&gt;
&lt;p&gt;基础背景知识了解后，这篇就来介绍一下使用 OpenTelemetry 如何实战部署应用，同时在一个可视化页面查看 trace、metric 等信息。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>OpenTelemetry 实践指南：历史、架构与基本概念</title>
    <link href="http://crossoverjie.top/2024/05/21/ob/OpenTelemetry-getstart/"/>
    <id>http://crossoverjie.top/2024/05/21/ob/OpenTelemetry-getstart/</id>
    <published>2024-05-21T13:46:00.000Z</published>
    <updated>2024-05-20T13:14:03.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前陆续写过一些和 OpenTelemetry 相关的文章：</p><ul><li><a href="https://crossoverjie.top/2024/04/07/ob/otel-replace-sw/">实战：如何优雅的从 Skywalking 切换到 OpenTelemetry</a></li><li><a href="https://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/">实战：如何编写一个 OpenTelemetry Extensions</a></li><li><a href="https://juejin.cn/post/7356138322367266854">从一个 JDK21+OpenTelemetry 不兼容的问题讲起</a></li></ul><p>这些内容的前提是最好有一些 OpenTelemetry 的背景知识，看起来就不会那么枯燥，为此这篇文章就来做一个入门科普，方便一些对 OpenTelemetry 不是那么熟的朋友快速掌握一些 OpenTelemetry 的基本概念。</p><span id="more"></span><hr><h2 id="历史发展"><a href="#历史发展" class="headerlink" title="历史发展"></a>历史发展</h2><p>早在 <code>OpenTelemetry</code> 诞生之前可观测性这个概念就一直存在了，我记得我最早接触到这个概念是在 16 年当时的公司所使用的一个产品：<a href="https://github.com/pinpoint-apm/pinpoint">pinpoint</a></p><blockquote><p>现如今这个项目依然比较活跃。</p></blockquote><p><img src="https://s2.loli.net/2024/04/15/VMLhpCWUGJmqn9z.png"><br>依然还记得当时通过它可以直接看到项目调用的拓扑图，在时间坐标上框出高延迟的点就能列出这些请求，同时还能查看此时的运行日志。</p><p>这样强大的功能对于一个刚工作一年的小白来说冲击力实属太大了一点。</p><p>后来才了解到 pinpoint 属于 APM 这类产品，类似的产品还有：</p><ul><li>Apache SkyWalking</li><li>美团的 CAT 等</li></ul><p>他们都是可以用于性能分析和链路追踪的产品，到后来公司的运维层面也接入过 Zabbix、open-falcon 之类的产品：<br><img src="https://s2.loli.net/2024/04/16/RwsCUSM4fxTaBj6.png"></p><p>17之后全面切换到 spring boot 时，也用过社区提供的 <a href="https://github.com/codecentric/spring-boot-admin">spring-boot-admin</a> 项目：</p><p><img src="https://s2.loli.net/2024/04/16/Y5vprI1fsVNwjPC.png"><br>这就是一个简单的可以监控 spring boot 应用的产品，用于展示 JVM 指标，或者自己也可以定义一些健康指标。</p><hr><p>再之后进入云原生体系后可观测性的技术栈稍有变化。</p><p><img src="https://s2.loli.net/2024/04/16/3MsXIo7lEgnhyUZ.png"></p><p>日志使用 Sidecar 代理的方式通过 Agent 将数据写入 ElasticSearch 中。<br>具体日志采集方式可以参考之前的文章：</p><ul><li><a href="https://juejin.cn/post/7347000319983419411">在 kubernetes 环境下如何采集日志</a></li></ul><p>而链路追踪则是使用的 <code>skywalking</code>，在 trace 这个领域 skywalking 还是非常受大家喜爱的。</p><p>不过最近也从 skywalking 切换到了我们本文所讲到的 OpenTelemetry，具体可以看之前的文章：</p><ul><li><a href="https://crossoverjie.top/2024/04/07/ob/otel-replace-sw/">实战：如何优雅的从 Skywalking 切换到 OpenTelemetry</a></li></ul><p>指标采集使用的是自然也是 Prometheus 的那一套技术栈，只是 Prometheus 换为了与它完全兼容的 VictoriaMetric 目前是为了更省资源。</p><p>客户端使用则是直接使用 Prometheus 的库进行指标暴露：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>prometheus-metrics-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>prometheus-metrics-instrumentation-jvm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>prometheus-metrics-exporter-httpserver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终通过配置抓取策略，由 VictoriaMetrics 的 <code>scrape</code> 程序来抓取指标最终写入到它自己的存储中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">operator.victoriametrics.com/v1beta1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">VMPodScrape</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-pod-scrape</span>  </span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">podMetricsEndpoints:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">scheme:</span> <span class="string">http</span>  </span><br><span class="line">      <span class="attr">scrape_interval:</span> <span class="string">&quot;30s&quot;</span>  </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/metrics</span>  </span><br><span class="line">      <span class="attr">relabelConfigs:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_annotation_prometheus_io_scrape</span>]  </span><br><span class="line">          <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">keep</span>  </span><br><span class="line">        <span class="comment"># 端口相同  </span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">keep_if_equal</span>  </span><br><span class="line">          <span class="attr">source_labels:</span> [ <span class="string">__meta_kubernetes_pod_annotation_prometheus_io_port</span>, <span class="string">__meta_kubernetes_pod_container_port_number</span> ]  </span><br><span class="line">        <span class="comment"># 过滤INIT容器  </span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">drop</span>  </span><br><span class="line">          <span class="attr">source_labels:</span> [ <span class="string">__meta_kubernetes_pod_container_init</span> ]  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_annotation_prometheus_io_path</span>]  </span><br><span class="line">          <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">(.+)</span>  </span><br><span class="line">          <span class="attr">target_label:</span> <span class="string">__metrics_path__</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">replace</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__address__</span>, <span class="string">__meta_kubernetes_pod_annotation_prometheus_io_port</span>]  </span><br><span class="line">          <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">([^:]+)(?::\d+)?;(\d+)</span>  </span><br><span class="line">          <span class="attr">target_label:</span> <span class="string">__address__</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1:$2</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">replace</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">__meta_kubernetes_pod_label_(.+)</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">labelmap</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_namespace</span>]  </span><br><span class="line">          <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">(.*)</span>  </span><br><span class="line">          <span class="attr">target_label:</span> <span class="string">kubernetes_namespace</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">replace</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_name</span>]  </span><br><span class="line">          <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">(.*)</span>  </span><br><span class="line">          <span class="attr">target_label:</span> <span class="string">kubernetes_pod_name</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">replace</span>  </span><br><span class="line">      <span class="attr">vm_scrape_params:</span>  </span><br><span class="line">        <span class="attr">stream_parse:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">namespaceSelector:</span>  </span><br><span class="line">    <span class="attr">any:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>以上是 VM 提供的 CRD</p></blockquote><h1 id="OpenTelemetry-诞生"><a href="#OpenTelemetry-诞生" class="headerlink" title="OpenTelemetry 诞生"></a>OpenTelemetry 诞生</h1><p>到此铺垫完成，不知道有没有发现在可观测性中关键的三个部分：日志、指标、trace 都是使用不同的开源产品，从而会导致技术栈较多，维护起来自然也是比较麻烦的。</p><p>这么一个软件领域的核心能力自然需要提供一个完整方案的，将以上的不同技术栈都整合在一起，更加的方便开发者使用。</p><p>在这之前也有两个社区想要做类似的事情：</p><ul><li>OpenTracing</li><li>OpenCensus</li></ul><p>不过他们并没有统一整个可观测领域，直到 2019 年 CNCF 社区宣布成立 OpenTelemetry，并且将上述两个社区进行合并共同开发 OpenTelemetry。</p><blockquote><p>背靠 CNCF 云原生社区加上许多知名厂商的支持（Google、Amazon、Redhat 等），现在已经正式成为 CNCF 的顶级项目了。</p></blockquote><h1 id="OpenTelemetry-架构介绍"><a href="#OpenTelemetry-架构介绍" class="headerlink" title="OpenTelemetry 架构介绍"></a>OpenTelemetry 架构介绍</h1><p><img src="https://s2.loli.net/2024/04/16/LMUtyG2ZqRbwYr8.png"></p><p>但我们打开 OpenTelemetry 社区的 GitHub 首页时，会看到有许多项目；第一反应应该是比较蒙的，下面我会着重介绍一些比较重要的项目。</p><p>在开始之前还是先简单介绍下 OpenTelemetry 的一些基础组件和概念：<br><img src="https://s2.loli.net/2024/04/16/pHON6Z3eun4IiJv.png"></p><p>整个 OpenTelemetry 系统其实可以简单分为三个部分：</p><ul><li>客户端</li><li>OTel collector</li><li>数据存储</li></ul><p>第一个客户端很好理解，也就是我们的业务应用；如果是 Java 应用只需要挂载一个 agent 就可以自动采集系统的指标、链路信息、日志等上传到 Collector 中。</p><p>也就是上图的左边部分。</p><p>之后就是非常关键的组件 collector，它可以通过 OTLP 协议接收刚才提到的客户端上传的数据，然后再内部进行处理，最终输出到后续的存储系统中。</p><h2 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h2><p><img src="https://s2.loli.net/2024/04/16/l8Jfcak9bsUCwTZ.png"></p><blockquote><p>上图是 collector 的架构图</p></blockquote><p>由于 OpenTelemetry 设计之初就是要做到厂商无关，所以它就得做出更高层级的设计。</p><p>关键点就是这里的 Receiver 和 Exporter 都是模块化的设计，第三方开发者可以基于它的标准开发不同组件从而兼容不同的产品。</p><p>Receiver：用于接收客户端上报的数据，不止是自己 agent 上报的数据，也可能会来自不同的厂商，比如 kubernetes、Kafka 等。</p><p>Exporter：同理，可以将 receiver 收到的数据进行处理之后输出到不同的组件中；比如 Kafka&#x2F;Pulsar&#x2F;Promethus&#x2F;Jaeger 等。</p><p>比如我们可以使用 <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/nginxreceiver">Nginx Receiver</a>接收来着 Nginx 上报的数据。</p><p>使用 <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/mysqlreceiver">MySQL Receiver</a>接收来自 MySQL 的数据。</p><p>当然通常我们使用最多的还是 <a href="https://github.com/open-telemetry/opentelemetry-collector/tree/main/receiver/otlpreceiver">OTLP Receiver</a>，这是官方的 OTLP 协议的接收器，可以接受官方的一些指标，比如我们只使用了 Java Agent 进行数据上报时。<br><img src="https://s2.loli.net/2024/04/16/WP46czTSAdYqKgb.png"><br><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver">https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver</a></p><p>在这里是可以看到目前支持的所有第三方的 Receiver。</p><hr><p><img src="https://s2.loli.net/2024/04/16/JxyICv8wHb7paZW.png"></p><p>OpenTelemetry 所支持的 Exporter 也很多，比如一些常见的存储：</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/clickhouseexporter">clickhouse exporter</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/elasticsearchexporter">elasticsearch exporter</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/pulsarexporter">pulsar exporter</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/prometheusexporter">prometheus exporter</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-collector/tree/main/exporter/otlphttpexporter">otlp http exporter</a></li></ul><p>Exporter 的使用场景很多：如果是指标相关的数据可以直接写入 Prometheus，如果是日志数据也可以直接写入 ElasticSearch。</p><p>如果还有其他的特殊需求（删减属性等）则可以写入消息队列，自行处理完之后再发往 collector 进行后续的处理。</p><p>可能你已经发现了，由于 collector 非常的灵活，所以我们可以像搭积木一样组装我们的 receiver 和 exporter，它会以我们配置的流水线的方式进行调用，这样我们就可以实现任意可定制的处理逻辑。</p><p>而这些流水线的组装对于客户端来说都是透明的，也就是说 collector 的更改完全不会影响到业务；业务只需要按照 OTLP 的格式上报数据即可。</p><p>在之前的从 Skywalking 切换到 OpenTelemetry 的文章中有人问为什么要切换到 OpenTelemetry？</p><p>从这里也能看得出来，OpenTelemetry 的灵活度非常高，借助于 Exporter 可以任意的更换后端存储，或者增加&#x2F;删减一些不需要的指标数据等。</p><hr><p>当然我们也可以统一的在这里进行搜索，可以列出所有的第三方集成的组件：<br><a href="https://opentelemetry.io/ecosystem/registry/">https://opentelemetry.io/ecosystem/registry/</a></p><p><img src="https://s2.loli.net/2024/04/16/XvOx5i9LImhDTe4.png"></p><h1 id="OpenTelemetry-项目介绍"><a href="#OpenTelemetry-项目介绍" class="headerlink" title="OpenTelemetry 项目介绍"></a>OpenTelemetry 项目介绍</h1><h2 id="opentelemetry-java"><a href="#opentelemetry-java" class="headerlink" title="opentelemetry-java"></a>opentelemetry-java</h2><p>介绍完基本的概念后，我们可以看看  OTel 社区的一些主要开源项目。<br><img src="https://s2.loli.net/2024/04/16/t3rWKEuHpTRjL7I.png"></p><p>这里我们还是以刚才的那个架构图从作往右讲起，也就是主要分为客户端和 collector 端。</p><p><img src="https://s2.loli.net/2024/04/16/zWAVoHaZORI83js.png"><br>目前官方支持的客户端语言已经非常齐全了，大部分的版本都已经是 Stable 稳定版，意味着可以进入生产环境。</p><p>这里我们以 Java 客户端为例：<br><img src="https://s2.loli.net/2024/04/16/Oea2KwgZYVS8qPf.png"><br>其中我们重点关注下 opentelemetry-java 和 opentelemetry-java-instrumentation 这两个项目。</p><p>我们用的最多的会是 <code>opentelemetry-java-instrumentation</code>，它会给我们提供一个 java agent 的 JAR 包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:path/to/opentelemetry-javaagent.jar \</span><br><span class="line">     -jar myapp.jar</span><br></pre></td></tr></table></figure><p>我们只需要在 Java 应用中加上该  agent 就可以实现日志、指标、trace 的自动上报。</p><p>而且它还实现了不同框架、库的指标采集与 trace。</p><p>在这里可以查到支持的库与框架列表：<br><img src="https://s2.loli.net/2024/04/17/kMDcrPwxJy4oZYe.png"></p><p><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md#libraries--frameworks">https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md#libraries--frameworks</a></p><blockquote><p>总之几乎就是你能想到和不能想到的都支持了。</p></blockquote><p>而 opentelemetry-java 我们直接使用的几率会小一些，opentelemetry-java-instrumentation 本身也是基于它创建的，可以理解为是 Java 版本的核心基础库，一些社区支持的组件就可以移动到 <code>instrumentation</code> 这个库中。</p><p>比如我在上篇文章：<a href="https://juejin.cn/post/7356138322367266854">从一个 JDK21+OpenTelemetry 不兼容的问题讲起</a>中涉及到的 <code>HostResourceProvider</code> 资源加载就是从 <code>opentelemetry-java</code> 中移动到了 <code>opentelemetry-java-instrumentation</code>。</p><p>具体可以参考：<a href="https://github.com/open-telemetry/opentelemetry-java/issues/4701">https://github.com/open-telemetry/opentelemetry-java/issues/4701</a></p><h2 id="collector"><a href="#collector" class="headerlink" title="collector"></a>collector</h2><p><img src="https://s2.loli.net/2024/04/16/2MaF7IwWvg9f1TS.png"></p><p>之后就是 collector 的组件了，它同样的也有两个库：<br><strong>OpenTelemetry Collector</strong> 和 <strong>OpenTelemetry Collector Contrib</strong></p><p>其实通过他们的名字也可以看得出来，他们的作用与刚才的 Java 库类似：</p><ul><li>opentelemetry-collector：由官方社区维护，提供了一些核心能力；比如只包含了最基本的 otlp 的 receiver 和 exporter。</li><li>opentelemetry-collector-contrib：包含了官方的 collector，同时更多的维护了社区提供的各种 receiver 和 exporter；就如上文提到的，一些社区组件（pulsar、MySQL、Kafka）等都维护在这个仓库。</li></ul><p>而我们生产使用时通常也是直接使用 opentelemetry-collector-contrib，毕竟它所支持的社区组件更多。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为 OpenTelemetry 想要解决的是整个可观测领域的所有需求，所以仓库非常多，社区也很开放，感兴趣的朋友可以直接参与贡献，这么多 repo 总有一个适合你的。</p><p>后续会继续讲解如何安装以及配置我们的 OpenTelemetry。</p><p>参考链接：</p><ul><li><a href="https://github.com/pinpoint-apm/pinpoint">https://github.com/pinpoint-apm/pinpoint</a></li><li><a href="https://github.com/codecentric/spring-boot-admin">https://github.com/codecentric/spring-boot-admin</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java">https://github.com/open-telemetry/opentelemetry-java</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation">https://github.com/open-telemetry/opentelemetry-java-instrumentation</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java/issues/4701">https://github.com/open-telemetry/opentelemetry-java/issues/4701</a></li></ul><p>#Blog #OpenTelemetry </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前陆续写过一些和 OpenTelemetry 相关的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2024/04/07/ob/otel-replace-sw/&quot;&gt;实战：如何优雅的从 Skywalking 切换到 OpenTelemetry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/&quot;&gt;实战：如何编写一个 OpenTelemetry Extensions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7356138322367266854&quot;&gt;从一个 JDK21+OpenTelemetry 不兼容的问题讲起&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些内容的前提是最好有一些 OpenTelemetry 的背景知识，看起来就不会那么枯燥，为此这篇文章就来做一个入门科普，方便一些对 OpenTelemetry 不是那么熟的朋友快速掌握一些 OpenTelemetry 的基本概念。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>从一个 JDK21+OpenTelemetry 不兼容的问题讲起</title>
    <link href="http://crossoverjie.top/2024/05/13/ob/jdk21+springboot+OTel+SPI/"/>
    <id>http://crossoverjie.top/2024/05/13/ob/jdk21+springboot+OTel+SPI/</id>
    <published>2024-05-13T15:31:40.000Z</published>
    <updated>2024-05-13T07:57:01.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间公司领导让我排查一个关于在 JDK21 环境中使用 Spring Boot 配合一个 JDK18 新增的一个 SPI(<code>java.net.spi.InetAddressResolverProvider</code>) 不生效的问题。</p><p>但这个不生效的前置条件有点多：</p><ul><li>JDK 的版本得在 18+</li><li>SpringBoot3.x</li><li>还在额外再配合使用 <code>-javaagent:opentelemetry-javaagent.jar</code> 使用，也就是 OpenTelemetry 提供的 agent。</li></ul><p>才会导致自定义的 <code>InetAddressResolverProvider</code> 无法正常工作。</p><span id="more"></span><hr><p>在复现这个问题之前先简单介绍下 <code>java.net.spi.InetAddressResolverProvider</code> 这个 SPI；它是在 JDK18 之后才提供的，在这之前我们使用 <code>InetAddress</code> 的内置解析器来解析主机名和 IP 地址，但这个解析器之前是不可以自定义的。</p><p>在某些场景下会不太方便，比如我们需要请求 <code>order.service</code> 这个域名时希望可以请求到某一个具体 IP 地址上，我们可以自己配置 host ，或者使用服务发现机制来实现。</p><p>但现在通过 <code>InetAddressResolverProvider</code> 就可以定义在请求这个域名的时候返回一个我们预期的 IP 地址。</p><p>同时由于它是一个 SPI，所以我们只需要编写一个第三方包，任何项目依赖它之后在发起网络请求时都会按照我们预期的 IP 进行请求。</p><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>要使用它也很简单，主要是两个类：</p><ul><li><code>InetAddressResolverProvider</code>：这是一个抽象类，我们可以继承它之后重写它的 get 函数返回一个 <code>InetAddressResolver</code> 对象</li><li><code>InetAddressResolver</code>：一个接口，主要提供了两个函数；一个用于传入域名返回 IP 地址，另一个反之：传入 IP 地址返回域名。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAddressResolverProvider</span> <span class="keyword">extends</span> <span class="title class_">InetAddressResolverProvider</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InetAddressResolver <span class="title function_">get</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyAddressResolver</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyAddressResolverProvider Internet Address Resolver Provider&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAddressResolver</span> <span class="keyword">implements</span> <span class="title class_">InetAddressResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAddressResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====MyAddressResolver&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Stream&lt;InetAddress&gt; <span class="title function_">lookupByName</span><span class="params">(String host, LookupPolicy lookupPolicy)</span></span><br><span class="line">            <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="keyword">if</span> (host.equals(<span class="string">&quot;fedora&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Stream.of(InetAddress.getByAddress(<span class="keyword">new</span> <span class="title class_">byte</span>[] &#123;<span class="number">127</span>, <span class="number">127</span>, <span class="number">10</span>, <span class="number">1</span>&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(InetAddress.getByAddress(<span class="keyword">new</span> <span class="title class_">byte</span>[] &#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">lookupByAddress</span><span class="params">(<span class="type">byte</span>[] addr)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;++++++&quot;</span> + addr[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + addr[<span class="number">1</span>] + <span class="string">&quot; &quot;</span> + addr[<span class="number">2</span>] + <span class="string">&quot; &quot;</span> + addr[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot;fedora&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">```<span class="type">java</span></span><br><span class="line"><span class="variable">addresses</span> <span class="operator">=</span> InetAddress.getAllByName(<span class="string">&quot;fedora&quot;</span>);</span><br><span class="line"><span class="comment">// output: 127 127 10 1</span></span><br></pre></td></tr></table></figure><p>这里我简单实现了一个对域名 fedora 的解析，会直接返回 <code>127.127.10.1</code>。</p><p>如果使用 IP 地址进行查询时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InetAddress</span> <span class="variable">byAddress</span> <span class="operator">=</span> InetAddress.getByAddress(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">127</span>, <span class="number">127</span>, <span class="number">10</span>, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;+++++&quot;</span> + byAddress.getHostName());</span><br><span class="line"><span class="comment">// output: fedora</span></span><br></pre></td></tr></table></figure><p>当然要要使得这个 SPI 生效的前提条件是我们需要新建一个文件：<br><code>META-INF/services/java.net.spi.InetAddressResolverProvider</code><br>里面的内容是我们自定义类的全限定名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.example.demo.MyAddressResolverProvider</span><br></pre></td></tr></table></figure><p>这样一个完整的 SPI 就实现完成了。</p><hr><p>正常情况下我们将应用打包为一个 jar 之后运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>是可以看到输出结果是符合预期的。</p><p>一旦我们使用配合上 spring boot 打包之后，也就是加上以下的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次执行其实也没啥问题，也能按照预期输出结果。</p><p>但我们加上 OpenTelemetry 的 agent 时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java  -javaagent:opentelemetry-javaagent.jar \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>就会发现在执行解析的时候抛出了 <code>java.net.UnknownHostException</code>异常。</p><p><img src="https://s2.loli.net/2024/04/08/owZLIF7yzUpSdjn.png"><br>从结果来看就是没有进入我们自定义的解析器。</p><h1 id="SPI-原理"><a href="#SPI-原理" class="headerlink" title="SPI 原理"></a>SPI 原理</h1><p>在讲排查过程之前还是要先预习下关于 Java SPI 的原理以及应用场景。</p><p>以前写过一个 http 框架 <a href="https://github.com/TogetherOS/cicada">cicada</a>，其中有一个可拔插 IOC 容器的功能：</p><blockquote><p>就是可以自定义实现自己的 IOC 容器，将自己实现的 IOC 容器打包为一个第三方包加入到依赖中，cicada 框架就会自动使用自定义的 IOC 实现。</p></blockquote><p>要实现这个功能本质上就是要定义一个接口，然后根据依赖的不同实现创建接口的实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CicadaBeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register into bean Factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object object)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get bean from bean Factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get bean by class type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * release all beans</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">releaseBean</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取具体的示例代码时就只需要使用 JDK 内置的 <code>ServiceLoader</code> 进行加载即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CicadaBeanFactory <span class="title function_">getCicadaBeanFactory</span><span class="params">()</span> &#123;  </span><br><span class="line">    ServiceLoader&lt;CicadaBeanFactory&gt; cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);  </span><br><span class="line">    <span class="keyword">if</span> (cicadaBeanFactories.iterator().hasNext())&#123;  </span><br><span class="line">        <span class="keyword">return</span> cicadaBeanFactories.iterator().next() ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CicadaDefaultBean</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码也非常的简洁，和刚才提到的 <code>InetAddressResolverProvider</code> 一样我们需要新增一个 <code>META-INF/services/top.crossoverjie.cicada.base.bean.CicadaBeanFactory</code> 文件来配置我们的类名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNextService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// PREFIX = META-INF/services/</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="literal">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ServiceLoader 类中会会去查找 <code>META-INF/services</code> 的文件，然后解析其中的内容从而反射生成对应的接口对象。</p><p>这里还有一个关键是通常我们的代码都会打包为一个 JAR 包，类加载器需要加载这个  JAR 包，同时需要在这个 JAR 包里找到我们之前定义的那个 spi 文件，如果这里查不到文件那就认为没有定义 SPI。</p><p>这个是本次问题的重点，会在后文分析原因的时候用到。</p><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>因为问题就出现在是否使用 opentelemetry-javaagent.jar 上，所以我需要知道在使用了 agent 之后有什么区别。</p><p>从刚才的对 SPI 的原理分析，加上 agent 出现异常，说明理论上就是没有读取到我们配置的文件: <code>java.net.spi.InetAddressResolverProvider</code>。</p><p>于是我便开始 debug，在 ServiceLoader 加载 jar 包的时候是可以看到具体使用的是什么 <code>classLoader</code> 。</p><p>这是不配置 agent 的时候使用的 classLoader：<br><img src="https://s2.loli.net/2024/04/10/kgR1hOzKbnGMJUA.png"><br>使用这个 loader 是可以通过文件路径在 jar 包中查找到我们配置的文件。</p><p>而配置上 agent 之后使用的 classLoader:<br><img src="https://s2.loli.net/2024/04/10/45sUKGr6xeVPNXA.png"><br>却是一个 JarLoader，这样是无法加载到在 springboot 格式下的配置文件的，至于为什么加载不到，那就要提一下 maven 打包后的文件目录和 spring boot 打包后的文件目录的区别了。</p><p><img src="https://s2.loli.net/2024/04/10/ZtDCc7SvXFHmL9J.png"><br>这里我截图了同样的一份代码不同的打包方式：<br>上面的是传统 maven，下图是 spring boot；其实主要的区别就是在 pom 中使用了一个构建插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>或者使用 <code>spring-boot</code> 命令再次打包的效果也是一样的。</p></blockquote><p>会发现 spring boot 打包后会多出一层 <code>BOOT-INF</code> 的文件夹，然后会在 <code>MANIFIST.MF</code> 文件中定义 <code>Main-Class</code> 和 <code>Start-Class</code>.</p><hr><p>通过上面的 debug 其实会发现 JarLoader 只能在加载 maven 打包后的文件，也就是说无法识别 BOOT-INF 这个目录。</p><p>正常情况下 spring boot 中会有一个额外的 <code>java.nio.file.spi.FileSystemProvider</code> 实现:<br><img src="https://s2.loli.net/2024/04/10/iFus4tA1KXEMYkq.png"><br>通过这个类的实现可以直接从 JAR 包中加载资源，比如我们自定义的 SPI 资源等。</p><p>初步判断使用 <code>opentelemetry-javaagent.jar</code>的 agent 之后，它的类加载器优先于了 spring boot ，从而导致后续的加载失败。</p><h2 id="远程-debug"><a href="#远程-debug" class="headerlink" title="远程 debug"></a>远程 debug</h2><p>这里穿插几个 debug 小技巧，其中一个是远程 debug，因为这里我是需要调试 javaagent，正常情况下是无法直接 debug 的。</p><p>所以我们可以使用以下命令启动应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=&quot;transport=dt_socket,server=y,suspend=y,address=5000&quot; -javaagent:opentelemetry-javaagent.jar \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/04/10/D2z4krNyHAanSlC.png"></p><p>然后在 idea 中配置一个 remote 启动。</p><blockquote><p>注意这里的端口得和命令行中的保持一致。</p></blockquote><p>当应用启动之后便可以在 idea 中启动这个 remote 了，这样便可以正常 debug 了。</p><h2 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h2><p>第二个是条件断点也非常有用，有时候我们需要调试一个公共函数，调用的地方非常多。</p><p>而我们只需要关心某一类行为的调用，此时就可以对这个函数中的变量进行判断，当他们满足某些条件时再进入断点，这样可以极大的提高我们的调试效率：<br><img src="https://s2.loli.net/2024/04/10/L9PkNyZprCql6Wd.png"></p><p>配置也很简单，只需要在断点上右键就可以编辑条件了。</p><h1 id="社区咨询"><a href="#社区咨询" class="headerlink" title="社区咨询"></a>社区咨询</h1><p>虽然我根据现象初步可以猜测下原因，但依然不确定如何调整才能解决这个问题，于是便去社区提了一个 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/10921">issue</a>。</p><p><img src="https://s2.loli.net/2024/04/10/YHiIOfvxu1EUMpj.png"><br>最后在社区大佬的帮助下发现我们需要禁用掉 OpenTelemetry agent 中的一个 resource 就可以了。</p><p><img src="https://s2.loli.net/2024/04/10/EiX3mD9k6cwjMUf.png"><br>这个 resource 是由 agent 触发的，它优先于 spring boot 之前进行 SPI 的加载。<br>目的是为了给 metric 和 trace 新增两个属性：<br><img src="https://s2.loli.net/2024/04/10/I39iXt4JfdwVn8S.png"></p><p><img src="https://s2.loli.net/2024/04/10/bH3wfUeCk4K9PJ5.png"><br>加载的核心代码在这里，只要禁用掉之后就不会再加载了。</p><p>禁用前：<br><img src="https://s2.loli.net/2024/04/10/7ZIo2VaqesFXL53.png"></p><p>禁用后：<br><img src="https://s2.loli.net/2024/04/10/k2yQBPxzMHFENjd.png"></p><p>当我们禁用掉之后就不会存在这两个属性了，不过我们目前并没有使用这两个属性，所以为了使得 SPI 生效就只有先禁用掉了，后续再看看社区还有没有其他的方案。</p><p>想要复现 debug 的可以在这里尝试：<br><a href="https://github.com/crossoverJie/demo">https://github.com/crossoverJie/demo</a></p><p>参考连接：</p><ul><li><a href="https://github.com/TogetherOS/cicada">https://github.com/TogetherOS/cicada</a></li><li><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#packaging.repackage-goal">https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#packaging.repackage-goal</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/10921">https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/10921</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/instrumentation/resources/library/README.md#host">https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/instrumentation/resources/library/README.md#host</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间公司领导让我排查一个关于在 JDK21 环境中使用 Spring Boot 配合一个 JDK18 新增的一个 SPI(&lt;code&gt;java.net.spi.InetAddressResolverProvider&lt;/code&gt;) 不生效的问题。&lt;/p&gt;
&lt;p&gt;但这个不生效的前置条件有点多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK 的版本得在 18+&lt;/li&gt;
&lt;li&gt;SpringBoot3.x&lt;/li&gt;
&lt;li&gt;还在额外再配合使用 &lt;code&gt;-javaagent:opentelemetry-javaagent.jar&lt;/code&gt; 使用，也就是 OpenTelemetry 提供的 agent。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;才会导致自定义的 &lt;code&gt;InetAddressResolverProvider&lt;/code&gt; 无法正常工作。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>如何对 kubernetes 应用做 e2e(端到端) 测试</title>
    <link href="http://crossoverjie.top/2024/05/05/ob/operator-e2e-test/"/>
    <id>http://crossoverjie.top/2024/05/05/ob/operator-e2e-test/</id>
    <published>2024-05-05T07:18:05.000Z</published>
    <updated>2024-05-05T13:13:35.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在给 <a href="https://github.com/open-telemetry/opentelemetry-operator/pull/2778">opentelemetry-operator</a>提交一个标签选择器的功能时，因为当时修改的函数是私有的，无法添加单测函数，所以社区建议我补充一个 <code>e2e test</code>.</p><blockquote><p>因为在当前的版本下，只要给 deployment 打上了 <code>instrumentation.opentelemetry.io/inject-java: &quot;true&quot;</code> 这类注解就会给该 deployment 注入 agent。<br>但没办法指定不同的 agent 版本（或者不同的环境变量），所以希望可以新增一个选择器，同时可以针对不同的 deployment 维护不同版本的 <code>Instrumentation</code>(是用于控制需要注入 deployment 的资源)；这样就可以灵活控制了。</p></blockquote><span id="more"></span><p><img src="https://s2.loli.net/2024/03/26/8QEaeXC9YwJp56m.png"></p><p>在这之前我其实也很少做 kubernetes 的 operator 开发，对如何做 kubernetes 的 e2e 测试也比较陌生，好在社区提供了详细的贡献文档。</p><p><img src="https://s2.loli.net/2024/03/26/Fv6SCofEtubZjcH.png"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>简单来说需要两个关键组件：</p><ul><li><a href="https://kind.sigs.k8s.io/">kind</a>: kubernetes in docker，是可以在本地利用 docker 启动一个 kubernetes 集群的工具，通常用于在本地进行开发、测试关于 kubernetes 相关的功能。<ul><li>安装 kind 的前提是本地已经安装好了 docker。</li></ul></li><li><a href="https://kyverno.github.io/chainsaw/latest/">chainsaw</a>: 一个 e2e 测试框架，提供了声明式的方式定义测试用例，也有着丰富断言功能。</li></ul><p>他们的安装都很简单，只要本地安装好了 golang，直接使用 go install 即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go install sigs.k8s.io/kind@v0.22.0</span><br><span class="line">go install github.com/kyverno/chainsaw@latest</span><br></pre></td></tr></table></figure><h2 id="kind-使用"><a href="#kind-使用" class="headerlink" title="kind 使用"></a>kind 使用</h2><p>在开始前还是先预习下 kind 的基本使用。</p><p>安装好 kind 之后，使用 create cluster 命令可以在本地创建一个 <code>kubernetes</code> 集群。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kind create cluster -h</span><br><span class="line">Creates a local Kubernetes cluster using Docker container &#x27;nodes&#x27;</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  kind create cluster [flags]</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/03/27/znDfd3m5HeyrXi4.png"><br>之后只需要等待集群安装成功即可，它会在我们的 <code>cat ~/.kube/config</code> 文件中追加刚才新建集群的连接信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k config get-contexts</span><br><span class="line">k config use-context xxx</span><br></pre></td></tr></table></figure><p>这样就可以使用这两个命令来查看和切换不同的集群了，虽说是一个本地模拟的 kubernetes 集群，但他的核心功能和一个标准的集群没有什么区别。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kind delete clusters --all</span><br></pre></td></tr></table></figure><p>使用完成之后可以使用这个命令将所有集群都删除掉。</p><h1 id="准备集群数据"><a href="#准备集群数据" class="headerlink" title="准备集群数据"></a>准备集群数据</h1><p>在 <code>opentelemetry-operator</code> 中有给我们准备好一个 make 命令: <code>make prepare-e2e</code> ；使用它会帮我们将 operator 的测试环境初始化好。</p><p>大概分为以下几步：</p><ul><li>安装 chainsaw</li><li>修改 controller 的镜像为我们本地构建的镜像名称</li><li>本地 docker 镜像打包</li><li>安装 cert-manager</li><li>安装 Operator 需要的 CRD</li><li>部署 Operator deployment</li><li>等待 Operator 启动成功</li></ul><p>不过这里的安装过程可能会遇到问题（本质上都是我们的网络问题）：<br><img src="https://s2.loli.net/2024/03/25/bYWdfOv9B27c8RE.png"><br><img src="https://s2.loli.net/2024/03/25/kH4b7I3UlngzENA.png"><br>这种情况可以想办法（科学上网）手动先把镜像拉取到本地，然后 kubernetes 就会从本地仓库获取到这个镜像。</p><h1 id="e2e-test"><a href="#e2e-test" class="headerlink" title="e2e test"></a>e2e test</h1><p>通常我们需要将同一类的测试功能放到一个文件夹里，比如这样：<br><img src="https://s2.loli.net/2024/03/27/eh8Rk4uFfWTHtna.png"><br>默认情况下 Chainsaw 会查找目录下名为 <code>chainsaw-test.yaml</code> 作为引导文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">chainsaw.kyverno.io/v1alpha1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Test</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">instrumentation-java</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">steps:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">step-00</span>  </span><br><span class="line">    <span class="attr">try:</span>   </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">command:</span>  </span><br><span class="line">        <span class="attr">entrypoint:</span> <span class="string">kubectl</span>  </span><br><span class="line">        <span class="attr">args:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">annotate</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">namespace</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">$&#123;NAMESPACE&#125;</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">openshift.io/sa.scc.uid-range=1000/1000</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">--overwrite</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">command:</span>  </span><br><span class="line">        <span class="attr">entrypoint:</span> <span class="string">kubectl</span>  </span><br><span class="line">        <span class="attr">args:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">annotate</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">namespace</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">$&#123;NAMESPACE&#125;</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">openshift.io/sa.scc.supplemental-groups=3000/3000</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">--overwrite</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">apply:</span>  </span><br><span class="line">        <span class="attr">file:</span> <span class="number">00</span><span class="string">-install-collector.yaml</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">apply:</span>  </span><br><span class="line">        <span class="attr">file:</span> <span class="number">00</span><span class="string">-install-instrumentation-select.yaml</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">step-01</span>  </span><br><span class="line">    <span class="attr">try:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">apply:</span>  </span><br><span class="line">        <span class="attr">file:</span> <span class="number">01</span><span class="string">-install-app-select.yaml</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">assert:</span>  </span><br><span class="line">        <span class="attr">file:</span> <span class="number">01</span><span class="string">-assert*.yaml</span>  </span><br><span class="line">    <span class="attr">catch:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">podLogs:</span>  </span><br><span class="line">          <span class="attr">selector:</span> <span class="string">app=my-java-select</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tests/e2e-instrumentation/instrumentation-select</span><br><span class="line">├── 00-install-collector.yaml</span><br><span class="line">├── 00-install-instrumentation-select.yaml</span><br><span class="line">├── 01-assert-select.yaml</span><br><span class="line">├── 01-assert-without-select.yaml</span><br><span class="line">├── 01-install-app-select.yaml</span><br><span class="line">└── chainsaw-test.yaml</span><br></pre></td></tr></table></figure><p>以我这里的这份文件为例，在其中定义了几个步骤：</p><ul><li>初始化环境信息，包含创建 namespace</li><li>安装我们测试所需要的资源<ul><li>00-install-collector.yaml：这里主要是安装一个 OpenTelemetry 的 collector</li><li>00-install-instrumentation-select.yaml：安装 Instrumentation 注入资源</li><li>01-install-app-select.yaml：应用一个我们需要测试的 deployment 资源</li><li><code>01-assert*.yaml</code>：最后对最终生成的 yaml 资源与 assert*.yaml 的进行断言匹配，只有匹配成功后才能测试成功。</li></ul></li></ul><blockquote><p>这里的测试目的主要是完成一个完整的 Java 应用的 deployment 注入 OpenTelemetry 的 agent 过程还有一些与 OpenTelemetry 相关的环境变量。</p></blockquote><p>以 <code>00-install-instrumentation-select.yaml</code> 文件为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">opentelemetry.io/v1alpha1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Instrumentation</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">java-select</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">my-java-select</span>  </span><br><span class="line">  <span class="attr">env:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_TRACES_EXPORTER</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">otlp</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXPORTER_OTLP_ENDPOINT</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">http://localhost:4317</span>  </span><br><span class="line">  <span class="attr">exporter:</span>  </span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">http://localhost:4317</span>  </span><br><span class="line">  <span class="attr">propagators:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">jaeger</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">b3</span>  </span><br><span class="line">  <span class="attr">sampler:</span>  </span><br><span class="line">    <span class="attr">type:</span> <span class="string">parentbased_traceidratio</span>  </span><br><span class="line">    <span class="attr">argument:</span> <span class="string">&quot;0.25&quot;</span>  </span><br><span class="line">  <span class="attr">java:</span>  </span><br><span class="line">    <span class="attr">env:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_JAVAAGENT_DEBUG</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;true&quot;</span>  </span><br></pre></td></tr></table></figure><p>它的预期效果是选择 <code>app: my-java-select</code> 的 deployment 将这些环境变量都注入进去，同时默认也会在 deployment 的容器中挂载一个 <code>javaagent.jar</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /otel-auto-instrumentation-java/</span><br><span class="line">javaagent.jar</span><br></pre></td></tr></table></figure><p>而我们的 <code>01-assert-select.yaml</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">annotations:</span>  </span><br><span class="line">    <span class="attr">instrumentation.opentelemetry.io/inject-java:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">    <span class="attr">sidecar.opentelemetry.io/inject:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-java-select</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">containers:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">env:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_JAVAAGENT_DEBUG</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">JAVA_TOOL_OPTIONS</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">&#x27; -javaagent:/otel-auto-instrumentation-java/javaagent.jar&#x27;</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_TRACES_EXPORTER</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">otlp</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXPORTER_OTLP_ENDPOINT</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">http://localhost:4317</span>    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_TRACES_SAMPLER</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">parentbased_traceidratio</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_SERVICE_NAME</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">my-java-select</span>   </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_PROPAGATORS</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">jaeger,b3</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_RESOURCE_ATTRIBUTES</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">myapp</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">args:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">--config=env:OTEL_CONFIG</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">otc-container</span>  </span><br><span class="line">  <span class="attr">initContainers:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">opentelemetry-auto-instrumentation-java</span>  </span><br><span class="line"><span class="attr">status:</span>  </span><br><span class="line">  <span class="attr">containerStatuses:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span>  </span><br><span class="line">    <span class="attr">ready:</span> <span class="literal">true</span>  </span><br><span class="line">    <span class="attr">started:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">initContainerStatuses:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">opentelemetry-auto-instrumentation-java</span>  </span><br><span class="line">    <span class="attr">ready:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">phase:</span> <span class="string">Running</span></span><br></pre></td></tr></table></figure><p>最终就是把实际的 <code>deployment</code> 的 yaml 内容和这份文件进行对比。</p><p>所以这个 e2e 测试就有点类似于集成测试，不会测试具体的功能函数，只需要最终结果能匹配就可以。</p><blockquote><p>当然这个和单元测试也是相辅相成的，缺一不可，不能完全只依赖 e2e 测试，也有可能是概率原因导致最终生成的资源相同；单元测试可以保证函数功能与预期相同。</p></blockquote><hr><p>都准备好之后便可以进行测试了，测试的时候也很简单，只需要执行以下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chainsaw test --test-dir ./tests/e2e-multi-instrumentation</span><br></pre></td></tr></table></figure><p>这样它就会遍历该目录下的 <code>chainsaw-test.yaml</code>文件进行测试，执行我们上面定义的那些步骤，最终输出测试结果：</p><p><img src="https://s2.loli.net/2024/03/27/VBwbKLdGjIXODrF.png"></p><p>同时 Chainsaw 也提供了 Github action，可以方便的让我们和 github CI 进行集成。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">example:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">permissions:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Chainsaw</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Chainsaw</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">kyverno/action-install-chainsaw@v0.1.0</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">release:</span> <span class="string">v0.0.9</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Check</span> <span class="string">install</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">chainsaw</span> <span class="string">version</span></span><br></pre></td></tr></table></figure><p>这样我们就可以在 github 中查看我们的测试结果了：<br><img src="https://s2.loli.net/2024/03/27/MaoL7EBmOZfsHd9.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后不得不感叹作为 CNCF 下面的项目 OpenTelemetry 的开发者体验真好，只要我们跟着<a href="https://github.com/open-telemetry/opentelemetry-operator/blob/main/CONTRIBUTING.md">贡献者文档</a>一步步操作都能顺利通过 CI 测试，同时还能避免一些 Code Review 过程中的低级错误。</p><p><img src="https://s2.loli.net/2024/03/27/kQGfWAhYHiyNXUq.png"><br>比如我第一次提 PR 的时候没有添加 changlog 文件，后面在贡献者手册里发现只需要执行 <code>make chlog-new</code> 就会基于当前分支信息帮我们生成一个 changelog 文件模板，然后只需要往里面填写内容即可。</p><p>这些工具链让不同开发者提交的代码和流程都符合规范，同时也降低了贡献难度。</p><p>以上所有的相关源码都可以在 <a href="https://github.com/open-telemetry/opentelemetry-operator">https://github.com/open-telemetry/opentelemetry-operator</a> 中进行查看。</p><p>参考链接：</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-operator/pull/2778">https://github.com/open-telemetry/opentelemetry-operator/pull/2778</a></li><li><a href="https://kind.sigs.k8s.io/">https://kind.sigs.k8s.io/</a></li><li><a href="https://kyverno.github.io/chainsaw/latest/">https://kyverno.github.io/chainsaw/latest/</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-operator/blob/main/CONTRIBUTING.md">https://github.com/open-telemetry/opentelemetry-operator/blob/main/CONTRIBUTING.md</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近在给 &lt;a href=&quot;https://github.com/open-telemetry/opentelemetry-operator/pull/2778&quot;&gt;opentelemetry-operator&lt;/a&gt;提交一个标签选择器的功能时，因为当时修改的函数是私有的，无法添加单测函数，所以社区建议我补充一个 &lt;code&gt;e2e test&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为在当前的版本下，只要给 deployment 打上了 &lt;code&gt;instrumentation.opentelemetry.io/inject-java: &amp;quot;true&amp;quot;&lt;/code&gt; 这类注解就会给该 deployment 注入 agent。&lt;br&gt;但没办法指定不同的 agent 版本（或者不同的环境变量），所以希望可以新增一个选择器，同时可以针对不同的 deployment 维护不同版本的 &lt;code&gt;Instrumentation&lt;/code&gt;(是用于控制需要注入 deployment 的资源)；这样就可以灵活控制了。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="k8s" scheme="http://crossoverjie.top/tags/k8s/"/>
    
    <category term="operator" scheme="http://crossoverjie.top/tags/operator/"/>
    
  </entry>
  
  <entry>
    <title>一次消息队列异常堆积的排查</title>
    <link href="http://crossoverjie.top/2024/04/29/ob/pulsar-slow-consume/"/>
    <id>http://crossoverjie.top/2024/04/29/ob/pulsar-slow-consume/</id>
    <published>2024-04-29T07:47:10.000Z</published>
    <updated>2024-04-29T02:24:24.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前两天收到业务反馈有一个 topic 的分区消息堆积了：<br><img src="https://s2.loli.net/2024/03/24/Ckb3MRswVAvjXfn.png"><br>根据之前的经验来看，要么是业务消费逻辑出现问题导致消费过慢，当然也有小概率是消息队列的 Bug（我们使用的是 pulsar）。</p><span id="more"></span><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p><img src="https://s2.loli.net/2024/03/24/6TBk2Jo9sWZpRGe.png"><br>通过排查，发现确实是在一点多的时候消息堆积了（后面是修复之后堆积开始下降）。</p><p>于是我在刚才堆积处查看了一条堆积消息的列表：<br><img src="https://s2.loli.net/2024/03/24/UeizjIc3brVfnNy.png"></p><p>获取到其中一条消息的 <code>messageId</code>.</p><blockquote><p>这里本质上使用的是 pulsar-admin 的 API。<br><a href="https://pulsar.apache.org/docs/3.2.x/admin-api-topics/#peek-messages"><code>org.apache.pulsar.client.admin.Topics#peekMessages</code></a></p></blockquote><p><img src="https://s2.loli.net/2024/03/24/IEGwRWphsFf6xk2.png"><br>再通过这条消息的 id （为了演示，这里的 messageId 可能不一样）在我们的 pulsar 消息链路系统中找到了消息的发送链路：<br><img src="https://s2.loli.net/2024/03/24/CwQRAWXMu8Hxq5y.png"><br>通过这个链路会发现消息一直在推送，但就是没有收到客户端的 ACK 响应。</p><blockquote><p>相关的消息链路埋点可以参考这里：<a href="https://crossoverjie.top/2023/12/11/ob/Pulsar-Broker-Interceptor/">如何编写一个 Pulsar Broker Interceptor 插件</a></p></blockquote><p>简单来说就是在以下几个 broker 提供的拦截器接口加上埋点数据即可：</p><ul><li>messageProduced</li><li>messageDispatched</li><li>messageAcked</li></ul><p>既然知道了是客户端没有响应 ACK，那就得知道客户端此时在干什么。</p><p>首先排查了 JVM 内存、CPU 等监控情况，发现一切都挺正常的，这段时间没有明显的尖刺。</p><h2 id="Arthas-排查"><a href="#Arthas-排查" class="headerlink" title="Arthas 排查"></a>Arthas 排查</h2><p>于是便准备使用 arthas 查看下线程的运行情况。</p><p>我们进入到对应 Pod 的容器，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p>因为 JVM 内存都没有啥异常，所以先看看 thread 的运行堆栈，考虑到是 pulsar 消费线程卡住了，所以我们需要加上线程状态已经过滤下线程的名称：<br><img src="https://s2.loli.net/2024/03/24/brPcepjMFKaC9d8.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread --state WAITING | grep pulsar</span><br></pre></td></tr></table></figure><p>此时就会列出当前 Java 进程中状态为 WATING 并且线程名称以 pulsar 开头的线程。</p><blockquote><p>我在之前的文章 <a href="https://crossoverjie.top/2023/08/03/ob/Pulsar-Client/">从 Pulsar Client 的原理到它的监控面板</a> 中分析过客户端的原理。</p></blockquote><p><img src="https://s2.loli.net/2023/08/02/vweWVR8fkJgrSMI.png" alt="20230802224400.png"><br><img src="https://s2.loli.net/2024/03/24/h7KQXueLySHYotW.png"></p><p>可以知道 pulsar 客户端在其中使用的是 <code>pulsar-</code>打头的线程名称，所以这样就列出了我们需要重点关注的线程。</p><p>我们以图中列出的线程 Id：320 为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread 320</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/03/24/cT1Eylp6aXd5QeZ.png"><br>此时便会打印当前线程的堆栈。</p><p>从上述堆栈中会发现线程一直处于 IO 操作中，看起来是在操作数据库。</p><p>我们再往下翻一翻，会发现上层调用的业务代码：<br><img src="https://s2.loli.net/2024/03/24/BhFGeJ7X6DLbC1s.png"><br>查阅代码得知这是一个数据库的写入操作，看起来是在这个环节数据库响应过慢导致的 pulsar 线程被阻塞了；从而导致消息没有及时 ACK。</p><p>为了最终确认是否由数据库引起的，于是继续查询了当前应用的慢 SQL 情况：<br><img src="https://s2.loli.net/2024/03/24/vcYDGapUVms82Jl.png"></p><p>发现其中有一个查询语句调用频次和平均耗时都比较高，而且正好这个表也是刚才在堆栈里操作的那张表。</p><p>经过业务排查发现这个慢 SQL 是由一个定时任务触发的，而这个定时任务由于某些原因一直也没有停止，所以为了快速解决这个问题，我们先尝试将这个定时任务停掉。</p><p>果然停掉没多久后消息就开始快速消费了：<br><img src="https://s2.loli.net/2024/03/24/wlDtCeBZL6IjkRM.png"><br>从这个时间线也可以看得出来了，在服务端推送了多次之后终于收到了 ACK。</p><p>修复之后业务再去排查优化这个慢 SQL，这样这个问题就得到根本的解决了。</p><h1 id="更多好用技巧"><a href="#更多好用技巧" class="headerlink" title="更多好用技巧"></a>更多好用技巧</h1><p>当然 arthas 好用的功能还远不止此，我觉得还有以下功能比较好用：</p><h2 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h2><p>profile：可以输出火焰图，在做性能分析的时候非常有用。<br><img src="https://s2.loli.net/2024/03/24/2qsjgQMCRhtxNdm.png"></p><h2 id="动态修改内存数据"><a href="#动态修改内存数据" class="headerlink" title="动态修改内存数据"></a>动态修改内存数据</h2><p>还记得之前我们碰到过一个 pulsar <a href="https://crossoverjie.top/2024/01/09/ob/Pulsar-Delete-Topic/">删除 topic 的 Bug</a>，虽然最终修复了问题，但是在发布修复版本的时候为了避免再次触发老版本的 bug，需要在内存中将某个关键字段的值修改掉。</p><p>而且是不能重启应用的情况下修改，此时使用 arthas 就非常的方便：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar &amp;&amp; java -jar arthas-boot.jar 1 -c &quot;vmtool -x 3 --action getInstances --className org.apache.pulsar.broker.ServiceConfiguration  --express &#x27;instances[0].setTopicLevelPoliciesEnabled(false)&#x27;&quot;</span><br></pre></td></tr></table></figure><p>这里使用的是 <code>vmtool</code> 这个子命令来获取对象，最终再使用 <code>express</code> 表达式将其中的值改为了 false。</p><p>当然这是一个高危操作，不到万不得已不推荐这么使用。</p><h2 id="Arthas-Tunnel-amp-Web-Console"><a href="#Arthas-Tunnel-amp-Web-Console" class="headerlink" title="Arthas Tunnel &amp; Web Console"></a>Arthas Tunnel &amp; Web Console</h2><p>这是一个方便开发者通过网页就可以连接到 arthas 的功能，避免直接登录到服务器进行操作。<br><img src="https://s2.loli.net/2024/03/24/d38vNUbylAhSKxP.png"><br><img src="https://s2.loli.net/2024/03/24/w8RomB4UVOyErvf.png"></p><p>我们在研效普通也内置了该功能，让开发排查问题更加方便。</p><h2 id="CPU-使用过多"><a href="#CPU-使用过多" class="headerlink" title="CPU 使用过多"></a>CPU 使用过多</h2><p>cpu 异常使用排查也是一个非常有用的功能，虽然我们可以通过监控得知 JVM 的 cpu 使用情况，但是没法知道具体是哪个线程以及哪行代码造成的 cpu 过高。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -n 3</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/03/24/SGTLjp8uBOHtJea.png"></p><p>使用以上命令就可以将 cpu 排名前三的线程打印出来，并且列出他的堆栈情况，这样可以很直观的得知 cpu 消耗了在哪些地方了。</p><p>当然还有一些 trace 查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace demo.MathGame run &#x27;#cost &gt; 10&#x27;</span><br></pre></td></tr></table></figure><p>比如这是将调用超过 10ms 的函数打印出来，不过如果我们接入了可观测系统（OpenTelemetry、skywalking等）这个功能就用不太上了。</p><hr><p> 还可以在运行的时候不停机修改日志级别，这种在线上排查一些疑难杂症的时候非常好用（通常情况下 debug 日志是不打印的），我们可以将日志级别调整为 debug 打印出更加详细的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[arthas@2062]$ </span><span class="language-bash">logger --name ROOT --level debug</span></span><br><span class="line">update logger level success.</span><br></pre></td></tr></table></figure><hr><p>如果是在 kubernetes 环境中执行也有可能碰到 Java 进程启动后没有在磁盘中写入 PID 的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar arthas-boot.jar</span>  </span><br><span class="line">[INFO] arthas-boot version: 3.6.7  </span><br><span class="line">[INFO] Can not find java process. Try to pass &lt;pid&gt; in command line.  </span><br><span class="line">Please select an available pid.</span><br></pre></td></tr></table></figure><p>导致直接运行的时候无法找到 Java 进程；此时就需要先 ps 拿到 PID 之后再传入 PID 连入 arthas：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar arthas-boot.jar 1</span></span><br></pre></td></tr></table></figure><p>更多关于 arthas 的用法可以参考官网。</p><p>参考链接：</p><ul><li><a href="https://pulsar.apache.org/docs/3.2.x/admin-api-topics/#peek-messages">https://pulsar.apache.org/docs/3.2.x/admin-api-topics/#peek-messages</a></li><li><a href="https://crossoverjie.top/2023/12/11/ob/Pulsar-Broker-Interceptor/">https://crossoverjie.top/2023/12/11/ob/Pulsar-Broker-Interceptor/</a></li><li><a href="https://arthas.aliyun.com/">https://arthas.aliyun.com/</a></li><li><a href="https://crossoverjie.top/2024/01/09/ob/Pulsar-Delete-Topic/">https://crossoverjie.top/2024/01/09/ob/Pulsar-Delete-Topic/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前两天收到业务反馈有一个 topic 的分区消息堆积了：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/03/24/Ckb3MRswVAvjXfn.png&quot;&gt;&lt;br&gt;根据之前的经验来看，要么是业务消费逻辑出现问题导致消费过慢，当然也有小概率是消息队列的 Bug（我们使用的是 pulsar）。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>在 kubernetes 环境下如何采集日志</title>
    <link href="http://crossoverjie.top/2024/04/21/ob/k8s-log-collect/"/>
    <id>http://crossoverjie.top/2024/04/21/ob/k8s-log-collect/</id>
    <published>2024-04-21T05:07:07.000Z</published>
    <updated>2024-04-21T11:49:07.604Z</updated>
    
    <content type="html"><![CDATA[<p>当我们没有使用云原生方案部署应用时采用的日志方案往往是 ELK 技术栈。<br><img src="https://s2.loli.net/2024/03/16/5pNYcOuxgXzsG1F.png"></p><p>这套技术方案比较成熟，稳定性也很高，所以几乎成为了当时的标配。</p><p>可是随着我们使用 kubernetes 步入云原生的时代后， kubernetes 把以往的操作系统上的许多底层都屏蔽，再由他提供了一些标准接口。</p><p>同时在 kubernetes 中的日志来源也比传统虚拟机多，比如可能有容器、kubernetes 自身的事件、日志等。</p><span id="more"></span><p>我们的日志采集方案也得与时俱进，kubernetes 的官方博客有介绍提供一下几种方案：</p><h1 id="节点采集"><a href="#节点采集" class="headerlink" title="节点采集"></a>节点采集</h1><p><img src="https://s2.loli.net/2024/03/18/EWB1PFJku6x8On3.png"></p><p>第一种方案是在节点中采集日志，我们知道 kubernetes 是分为 master 调度节点以及 worker 工作节点；我们的应用都是运行在 worker 节点中的。</p><blockquote><p>在 kubernetes 环境中更推荐使用标准的 stdout&#x2F;stderr 作为日志输出，这样 kubernetes 更方便做统一处理。</p></blockquote><p><img src="https://s2.loli.net/2024/03/16/iUXB3YQdEAgJmpT.png"></p><p>以我们的 docker 运行时为例，默认情况下我们的标准输入文件会写入到 <code>/var/log</code> 目录中。</p><p><img src="https://s2.loli.net/2024/03/16/48NxKOuQmB5oer1.png"></p><p>如上图所示：我们可以在 kubernetes 的每一个 worker 节点中部署一个 <code>DaemonSet</code> 类型的采集器（filebeat 等），再由他去采集该节点下 <code>/var/log</code> 的日志，最终由他将日志采集后发往日志处理的后端，比如 elasticsearch 等组件中。</p><p>这种方案的好处是资源占用较低，往往是有多少个 worker 节点就可以部署多少个采集器。</p><p>而且和业务的耦合度低，业务和采集器不管谁进行重启或升级互相都不会产生影响。</p><p>但缺点也比较明显，整个节点的日志采集瓶颈都在这个采集器这里了，如果某些 worker 节点的 Pod 数量不均衡，或者是本身日志产生也不平均时就会出现明显的负债不平衡。</p><p>而且也无法针对某些日志高峰场景进行调优（毕竟所有的 Pod 都是使用的一个日志采集器）。</p><p>所以节点级的日志采集更适用与该 worker 节点负债较低的时候使用，也更容易维护。</p><h1 id="Sidecar-代理模式"><a href="#Sidecar-代理模式" class="headerlink" title="Sidecar 代理模式"></a>Sidecar 代理模式</h1><p><img src="https://s2.loli.net/2024/03/16/Xo23G568BevhWKc.png"><br>第二种相对于第一种可以理解为由集中式的日志采集分散到各个应用 Pod 中自行采集。</p><p>需要为每一个业务 Pod 挂载一个边车（sidecar）进行日志采集，由于边车和业务 Pod 共享的是一个存储，所以可以很方便的读取到日志。</p><p>由于它是和应用挂载在一起的，所以资源占用自然会比节点采集更多，同理耦合度也增加了，采集组件的升级可能还会影响的业务 Pod。</p><p>但同样的带来好处就是可以针对单个 Pod 更精细的控制采集方案。</p><p>比如对于一些日志写入频繁的应用，可以将 filebeat 的配置提高，甚至还可以将这种高负载的日志单独写入一个 elasticsearch 中，这样可以与普通负载的日志进行资源隔离。</p><p>这个方案更适用与集群规模较大的场景，需要做一些精细化配置。</p><hr><p>我们其实也是采用的也是这个方案，不过具体细节稍有不同。</p><p>我们没有直接使用标准输入和输出，原因如下：</p><p>日志格式没法统一，导致最终查询的时候无法做一些标准化的限制（比如我们要求每个日志都需要带业务 id、traceId 等，查询时候有这些业务指标就很容易沉淀一些标准的查询语句。）</p><p>最终我们还是采用了 Java 的老朋友，logback 配置了自己的日志格式，所有的应用都会根据这个模版进行日志输出。</p><p>同时利用日志框架的批量写入、缓冲等特性还更容易进行日志的性能调优。（只使用标准输出时对应用来说是黑盒。）</p><p>最终我们的技术方案是：<br><img src="https://s2.loli.net/2024/03/16/V1mf7MBpodq5eRU.png"></p><h1 id="直接写入"><a href="#直接写入" class="headerlink" title="直接写入"></a>直接写入</h1><p>还有一种方案是直接写入，这个其实和 kubernetes 本身就没有太多关系了。</p><p>由业务自己调用 elasticsearch 或者其他的存储组件的 API 进行写入，这种通常适用于对性能要求较高的场景，略过了中间的采集步骤，直接写入存储端。</p><p>这个我在 <a href="https://crossoverjie.top/2023/08/23/ob/VictoriaLogs-Intro/">VictoriaLogs：一款超低占用的 ElasticSearch 替代方案</a>中介绍过，我需要在 broker 的拦截器中埋点消息信息，从而可以生成一个消息🆔的链路信息。</p><p><img src="https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png"></p><p>因为需要拦截消息的发送、消费的各个阶段，加上并发压力较高，所以对日志的写入性能要求还是蛮高的。</p><p>因此就需要在拦截器中直接对写入到日志存储。</p><blockquote><p>这里考虑到我这里的但一场景，以及对资源的消耗，最终选取了 <code>victoriaLog</code> 这个日志存储。</p></blockquote><p>而在发送日志的时候也得用了高性能的日志发生框架，这里选取了<a href="https://github.com/aliyun/aliyun-log-java-producer">aliyun-log-java-producer</a>然后做了一些定制。</p><p>这个库支持以下一些功能：</p><ul><li>高性能：批量发送、多线程等</li><li>自动重试</li><li>异步非阻塞</li><li>资源控制（可以对内存、数量进行控制）</li></ul><p>因为这是为阿里云日志服务的一个组件，代码里硬编码了只能写入阿里的日志服务。</p><p>所以拿来稍加改造后，现在可以支持自定义发送到任意后端，只需要在初始化时自定义实现发送回调接口即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProducerConfig</span> <span class="variable">producerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerConfig</span>();</span><br><span class="line">producerConfig.setSenderArgs(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;vlogUrl, client&#125;);</span><br><span class="line">producerConfig.setSender((batch, args) -&gt; &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (String s : batch.getLogItemsString()) &#123;</span><br><span class="line">        body.append(<span class="string">&quot;&#123;\&quot;create\&quot;:&#123;&#125;&#125;&quot;</span>);</span><br><span class="line">        body.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        body.append(s);</span><br><span class="line">        body.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span></span><br><span class="line">            RequestBody.create(MediaType.parse(<span class="string">&quot;application/json&quot;</span>), body.toString());</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                    .url(String.format(<span class="string">&quot;%s/insert/elasticsearch/_bulk&quot;</span>, args[<span class="number">0</span>]))</span><br><span class="line">                    .post(requestBody)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">    <span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> (OkHttpClient) args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> okHttpClient.newCall(request).execute()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (response.isSuccessful()) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Request failed with error code: &quot;</span> + response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Send vlogs failed&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">logProducer = <span class="keyword">new</span> <span class="title class_">LogProducer</span>(producerConfig);</span><br></pre></td></tr></table></figure><blockquote><p>考虑到这个库只是对阿里云日志服务的一个组件，加上代码已经很久没维护了，所以就没有将这部分代码提交到社区，感兴趣的评论区留言。</p></blockquote><h1 id="日志安全"><a href="#日志安全" class="headerlink" title="日志安全"></a>日志安全</h1><p>日志是一个非常基础但又很敏感的功能，首先是编码规范上要避免打印一些敏感信息；比如身份证、密码等；同时对日志的访问也要最好权限控制。</p><p>在我们内部的研效平台中，对于日志、监控等功能都是和应用权限挂钩的。</p><p>简单来说就是关闭了统一查询 ES 的入口，只在应用层级提供查询，类似于：</p><p><img src="https://s2.loli.net/2024/03/18/ogBTPu47CifOrnp.png"></p><blockquote><p>图来自于 orbit 产品。</p></blockquote><h1 id="OpenTelemetry"><a href="#OpenTelemetry" class="headerlink" title="OpenTelemetry"></a>OpenTelemetry</h1><p>当然讲到日志目前自然也逃不过 OpenTelemetry，作为当前云原生可观测性的标准也提供了对应的日志组件。</p><p><img src="https://s2.loli.net/2024/03/18/VdvhIbzRWxlc79Q.png"><br>OpenTelemetry 也定义了结构化的日志格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;resourceLogs&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span><span class="string">&quot;resource-attr&quot;</span><span class="punctuation">,</span><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;stringValue&quot;</span><span class="punctuation">:</span><span class="string">&quot;resource-attr-val-1&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;scopeLogs&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;logRecords&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;timeUnixNano&quot;</span><span class="punctuation">:</span><span class="string">&quot;1581452773000000789&quot;</span><span class="punctuation">,</span><span class="attr">&quot;severityNumber&quot;</span><span class="punctuation">:</span><span class="number">9</span><span class="punctuation">,</span><span class="attr">&quot;severityText&quot;</span><span class="punctuation">:</span><span class="string">&quot;Info&quot;</span><span class="attr">&quot;body&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;stringValue&quot;</span><span class="punctuation">:</span><span class="string">&quot;This is a log message&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span><span class="string">&quot;app&quot;</span><span class="punctuation">,</span><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;stringValue&quot;</span><span class="punctuation">:</span><span class="string">&quot;server&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span><span class="string">&quot;instance_num&quot;</span><span class="punctuation">,</span><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;intValue&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;droppedAttributesCount&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;traceId&quot;</span><span class="punctuation">:</span><span class="string">&quot;08040201000000000000000000000000&quot;</span><span class="punctuation">,</span><span class="attr">&quot;spanId&quot;</span><span class="punctuation">:</span><span class="string">&quot;0102040800000000&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;timeUnixNano&quot;</span><span class="punctuation">:</span><span class="string">&quot;1581452773000000789&quot;</span><span class="punctuation">,</span><span class="attr">&quot;severityNumber&quot;</span><span class="punctuation">:</span><span class="number">9</span><span class="punctuation">,</span><span class="attr">&quot;severityText&quot;</span><span class="punctuation">:</span><span class="string">&quot;Info&quot;</span><span class="punctuation">,</span><span class="attr">&quot;body&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;stringValue&quot;</span><span class="punctuation">:</span><span class="string">&quot;something happened&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span><span class="string">&quot;customer&quot;</span><span class="punctuation">,</span><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;stringValue&quot;</span><span class="punctuation">:</span><span class="string">&quot;acme&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span><span class="string">&quot;env&quot;</span><span class="punctuation">,</span><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;stringValue&quot;</span><span class="punctuation">:</span><span class="string">&quot;dev&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;droppedAttributesCount&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;traceId&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;spanId&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以配置 <code>otel.logs.exporter=otlp (default)</code> 可以将日志输出到 <code>oetl-collector</code> 中，再由他输出到后端存储中。</p><p>虽然这样 <code>otel-collectoer</code> 就成为瓶颈了，但我们也可以部署多个副本来降低压力。</p><p>同时也可以在应用中指定不同的 <code>endpoint(otel.exporter.otlp.endpoint=http://127.0.0.1:4317)</code> 来区分日志的 collector，与其他类型的 collector 做到资源隔离。</p><p>不过目前社区关于日志的实践还比较少，而且由于版本 1.0 版本 release 的时间也不算长，稳定性和之前的 filebeat 相比还得需要时间检验。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>理想情况下，我们需要将可观测性的三个重要组件都关联起来才能更好的排查定位问题。</p><p>比如当收到监控系统通过指标变化发出的报警时，可以通过链路追踪定位具体是哪个系统触发的问题。</p><p>之后通过 traceID 定位到具体的日志，再通过日志的上下文列出更多日志信息，这样整个链条就可以串联起来，可以极大的提高效率。</p><p>参考链接：</p><ul><li><a href="https://github.com/aliyun/aliyun-log-java-producer">https://github.com/aliyun/aliyun-log-java-producer</a></li><li><a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/">https://kubernetes.io/docs/concepts/cluster-administration/logging/</a></li><li><a href="https://coding.net/help/docs/orbit/env/logs-event/intro.html">https://coding.net/help/docs/orbit/env/logs-event/intro.html</a></li><li><a href="https://opentelemetry.io/docs/concepts/signals/logs/">https://opentelemetry.io/docs/concepts/signals/logs/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;当我们没有使用云原生方案部署应用时采用的日志方案往往是 ELK 技术栈。&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/03/16/5pNYcOuxgXzsG1F.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这套技术方案比较成熟，稳定性也很高，所以几乎成为了当时的标配。&lt;/p&gt;
&lt;p&gt;可是随着我们使用 kubernetes 步入云原生的时代后， kubernetes 把以往的操作系统上的许多底层都屏蔽，再由他提供了一些标准接口。&lt;/p&gt;
&lt;p&gt;同时在 kubernetes 中的日志来源也比传统虚拟机多，比如可能有容器、kubernetes 自身的事件、日志等。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="日志" scheme="http://crossoverjie.top/tags/%E6%97%A5%E5%BF%97/"/>
    
    <category term="kubernetes" scheme="http://crossoverjie.top/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>实战：如何编写一个 OpenTelemetry Extensions</title>
    <link href="http://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/"/>
    <id>http://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/</id>
    <published>2024-04-15T06:14:54.000Z</published>
    <updated>2024-04-15T13:27:35.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间我们从 <code>SkyWalking</code> 切换到了 <code>OpenTelemetry</code> ，与此同时之前使用 SkyWalking 编写的插件也得转移到 OpenTelemetry 体系下。</p><p>我也写了相关介绍文章：<br>实战：<a href="https://juejin.cn/post/7341669201010262053">如何优雅的从 SkyWalking 切换到 OpenTelemetry</a></p><p>好在 OpenTelemetry 社区也提供了 Extensions 的扩展开发，我们可以不用去修改社区发行版：<code>opentelemetry-javaagent.jar</code> 的源码也可以扩展其中的能力。</p><p>比如可以：</p><ul><li>修改一些 trace，某些 span 不想记录等。</li><li>新增 metrics</li></ul><span id="more"></span><p>这次我准备编写的插件也是和 metrics 有关的，因为 pulsar 的 Java sdk 中并没有暴露客户端的一些监控指标，所以我需要在插件中拦截到一些关键函数，然后执行暴露出指标。</p><p>截止到本文编写的时候， Pulsar 社区也已经将 <code>Java-client</code> <a href="https://github.com/apache/pulsar/pull/22178">集成</a>了 OpenTelemetry，后续正式发版后我这个插件也可以光荣退休了。</p><hr><p>由于 OpenTelemetry 社区还处于高速发展阶段，我在中文社区没有找到类似的参考文章（甚至英文社区也没有，只有一些 example 代码，或者是只有去社区成熟插件里去参考代码）</p><p>其中也踩了不少坑，所以觉得非常有必要分享出来帮助大家减少遇到同类问题的机会。</p><h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>OpenTelemetry extension 的写法其实和 <code>skywalking</code> 相似，都是用的 <a href="https://bytebuddy.net/#/">bytebuddy</a>这个字节码增强库，只是在一些 API 上有一些区别。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>首先需要创建一个 Java 项目，这里我直接参考了官方的示例，使用了 gradle 进行管理（理论上 maven 也是可以的，只是要找到在 gradle 使用的 maven 插件）。</p><p>这里贴一下简化版的 <code>build.gradle</code> 文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    id <span class="string">&quot;com.github.johnrengelman.shadow&quot;</span> version <span class="string">&quot;8.1.1&quot;</span></span><br><span class="line">    id <span class="string">&quot;com.diffplug.spotless&quot;</span> version <span class="string">&quot;6.24.0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span> = <span class="string">&#x27;com.xx.otel.extensions&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;1.0.0&#x27;</span></span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    versions = [</span><br><span class="line">            <span class="comment">// this line is managed by .github/scripts/update-sdk-version.sh</span></span><br><span class="line">            opentelemetrySdk           : <span class="string">&quot;1.34.1&quot;</span>,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// these lines are managed by .github/scripts/update-version.sh</span></span><br><span class="line">            opentelemetryJavaagent     : <span class="string">&quot;2.1.0-SNAPSHOT&quot;</span>,</span><br><span class="line">            opentelemetryJavaagentAlpha: <span class="string">&quot;2.1.0-alpha-SNAPSHOT&quot;</span>,</span><br><span class="line"></span><br><span class="line">            junit                      : <span class="string">&quot;5.10.1&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    deps = [</span><br><span class="line">    <span class="comment">// 自动生成服务发现 service 文件</span></span><br><span class="line">            autoservice: <span class="keyword">dependencies</span>.create(<span class="keyword">group</span>: <span class="string">&#x27;com.google.auto.service&#x27;</span>, name: <span class="string">&#x27;auto-service&#x27;</span>, version: <span class="string">&#x27;1.1.1&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    mavenLocal()</span><br><span class="line">    maven &#123; url <span class="string">&quot;https://maven.aliyun.com/repository/public&quot;</span> &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">configurations</span> &#123;</span><br><span class="line">    otel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line"></span><br><span class="line">    implementation(platform(<span class="string">&quot;io.opentelemetry:opentelemetry-bom:$&#123;versions.opentelemetrySdk&#125;&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Interfaces and SPIs that we implement. We use `compileOnly` dependency because during</span></span><br><span class="line"><span class="comment">    runtime all necessary classes are provided by javaagent itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    compileOnly <span class="string">&#x27;io.opentelemetry:opentelemetry-sdk-extension-autoconfigure-spi:1.34.1&#x27;</span></span><br><span class="line">    compileOnly <span class="string">&#x27;io.opentelemetry.instrumentation:opentelemetry-instrumentation-api:1.32.0&#x27;</span></span><br><span class="line">    compileOnly <span class="string">&#x27;io.opentelemetry.javaagent:opentelemetry-javaagent-extension-api:1.32.0-alpha&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Provides @AutoService annotation that makes registration of our SPI implementations much easier</span></span><br><span class="line">    compileOnly deps.autoservice</span><br><span class="line">    annotationProcessor deps.autoservice</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://mvnrepository.com/artifact/org.apache.pulsar/pulsar-client</span></span><br><span class="line">    compileOnly <span class="string">&#x27;org.apache.pulsar:pulsar-client:2.8.0&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后便是要创建  javaagent 的一个核心类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService(InstrumentationModule.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PulsarInstrumentationModule</span> <span class="keyword">extends</span> <span class="title class_">InstrumentationModule</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PulsarInstrumentationModule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;pulsar-client-metrics&quot;</span>, <span class="string">&quot;pulsar-client-metrics-2.8.0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个类中定义我们插件的名称，同时使用 <code>@AutoService</code> 注解可以在打包的时候帮我们在 <code>META-INF/services/</code>目录下生成 SPI 服务发现的文件：<br><img src="https://s2.loli.net/2024/03/10/krqEn7lsIQbKJh6.png"></p><blockquote><p>这是一个 Google 的插件，本质是插件是使用 SPI 的方式进行开发的。</p></blockquote><p>关于 SPI 以前也写过一篇文章，不熟的朋友可以用作参考：</p><ul><li><a href="https://crossoverjie.top/2020/02/24/wheel/cicada8-spi/">Java SPI 的原理与应用</a></li></ul><h2 id="创建-Instrumentation"><a href="#创建-Instrumentation" class="headerlink" title="创建 Instrumentation"></a>创建 Instrumentation</h2><p>之后就需要创建自己的 Instrumentation，这里可以把它理解为自己的拦截器，需要配置对哪个类的哪个函数进行拦截：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerCreateImplInstrumentation</span> <span class="keyword">implements</span> <span class="title class_">TypeInstrumentation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ElementMatcher&lt;TypeDescription&gt; <span class="title function_">typeMatcher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> named(<span class="string">&quot;org.apache.pulsar.client.impl.ProducerBuilderImpl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(TypeTransformer transformer)</span> &#123;</span><br><span class="line">        transformer.applyAdviceToMethod(</span><br><span class="line">                isMethod()</span><br><span class="line">                        .and(named(<span class="string">&quot;createAsync&quot;</span>)),</span><br><span class="line">                ProducerCreateImplInstrumentation.class.getName() + <span class="string">&quot;$ProducerCreateImplConstructorAdvice&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>比如这就是对 <code>ProducerBuilderImpl</code> 类的 createAsync 创建函数进行拦截，拦截之后的逻辑写在了 <code>ProducerCreateImplConstructorAdvice</code> 类中。</p><p>值得注意的是对一些继承和实现类的拦截方式是不相同的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> ElementMatcher&lt;TypeDescription&gt; <span class="title function_">typeMatcher</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> extendsClass(named(ENHANCE_CLASS));  </span><br><span class="line">    <span class="comment">// return implementsInterface(named(ENHANCE_CLASS));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这两个函数名称就能看出，分别是针对继承和实现类进行拦截的。</p><blockquote><p>这里的 API 比 SkyWalking 的更易读一些。</p></blockquote><p>之后需要把我们自定义的 Instrumentation 注册到刚才的 PulsarInstrumentationModule 类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;TypeInstrumentation&gt; <span class="title function_">typeInstrumentations</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ProducerCreateImplInstrumentation</span>(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ProducerCloseImplInstrumentation</span>(),</span><br><span class="line">            );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有多个的话也都得进行注册。</p><h2 id="编写切面代码"><a href="#编写切面代码" class="headerlink" title="编写切面代码"></a>编写切面代码</h2><p>之后便是编写我们自定义的切面逻辑了，也就是刚才自定义的 <code>ProducerCreateImplConstructorAdvice</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ProducerCreateImplConstructorAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Advice</span>.OnMethodEnter(suppress = Throwable.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">onEnter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// inert your code</span></span><br><span class="line">        MetricsRegistration.registerProducer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Advice</span>.OnMethodExit(suppress = Throwable.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Advice</span>.Return CompletableFuture&lt;Producer&gt; completableFuture)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> completableFuture.get();</span><br><span class="line">            CollectionHelper.PRODUCER_COLLECTION.addObject(producer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看得出来其实就是两个核心的注解：</p><ul><li><code>@Advice.OnMethodEnter</code> 切面函数调用之前</li><li><code>@Advice.OnMethodExit</code> 切面函数调用之后</li></ul><p>还可以在 <code>@Advice.OnMethodExit</code>的函数中使用 <code>@Advice.Return</code>获得函数调用的返回值。</p><p>当然也可以使用 <code>@Advice.This</code> 来获取切面的调用对象。</p><h2 id="编写自定义-metrics"><a href="#编写自定义-metrics" class="headerlink" title="编写自定义 metrics"></a>编写自定义 metrics</h2><p>因为我这个插件的主要目的是暴露一些自定义的 metrics，所以需要使用到 <code>io.opentelemetry.api.metrics</code> 这个包：</p><p>这里以 Producer 生产者为例，整体流程如下：</p><ul><li>创建生产者的时候将生产者对象存储起来</li><li>OpenTelemetry 框架会每隔一段时间回调一个自定义的函数</li><li>在这个函数中遍历所有的 producer 获取它的监控指标，然后暴露出去。</li></ul><p>注册函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerObservers</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">Meter</span> <span class="variable">meter</span> <span class="operator">=</span> MetricsRegistration.getMeter();  </span><br><span class="line">  </span><br><span class="line">    meter.gaugeBuilder(<span class="string">&quot;pulsar_producer_num_msg_send&quot;</span>)  </span><br><span class="line">            .setDescription(<span class="string">&quot;The number of messages published in the last interval&quot;</span>)  </span><br><span class="line">            .ofLongs()  </span><br><span class="line">            .buildWithCallback(  </span><br><span class="line">                    r -&gt; recordProducerMetrics(r, ProducerStats::getNumMsgsSent));</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recordProducerMetrics</span><span class="params">(ObservableLongMeasurement observableLongMeasurement, Function&lt;ProducerStats, Long&gt; getter)</span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> (Producer producer : CollectionHelper.PRODUCER_COLLECTION.list()) &#123;  </span><br><span class="line">        <span class="type">ProducerStats</span> <span class="variable">stats</span> <span class="operator">=</span> producer.getStats();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> producer.getTopic();  </span><br><span class="line">        <span class="keyword">if</span> (topic.endsWith(RetryMessageUtil.RETRY_GROUP_TOPIC_SUFFIX)) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;        observableLongMeasurement.record(getter.apply(stats),  </span><br><span class="line">                Attributes.of(PRODUCER_NAME, producer.getProducerName(), TOPIC, topic));  </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>回调函数，在这个函数中遍历所有的生产者，然后读取它的监控指标。</p><p>这样就完成了一个自定义指标的暴露，使用的时候只需要加载这个插件即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent.jar \</span><br><span class="line">     -Dotel.javaagent.extensions=ext.jar</span><br><span class="line">     -jar myapp.jar</span><br></pre></td></tr></table></figure><p><code>-Dotel.javaagent.extensions=/extensions</code><br>当然也可以指定一个目录，该目录下所有的 jar 都会被作为 extensions 被加入进来。</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>使用 <code>./gradlew build</code> 打包，之后可以在<code>build/libs/</code>目录下找到生成物。</p><p>当然也可以将 extension 直接打包到 <code>opentelemetry-javaagent.jar</code>中，这样就可以不用指定 <code>-Dotel.javaagent.extensions</code>参数了。</p><p>具体可以在 gradle 中加入以下 task：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">task <span class="title function_">extendedAgent</span><span class="params">(type: Jar)</span> &#123;</span><br><span class="line">  dependsOn(configurations.otel)</span><br><span class="line">  archiveFileName = <span class="string">&quot;opentelemetry-javaagent.jar&quot;</span></span><br><span class="line">  from <span class="title function_">zipTree</span><span class="params">(configurations.otel.singleFile)</span></span><br><span class="line">  from(tasks.shadowJar.archiveFile) &#123;</span><br><span class="line">    into <span class="string">&quot;extensions&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Preserve MANIFEST.MF file from the upstream javaagent</span></span><br><span class="line">  doFirst &#123;</span><br><span class="line">    manifest.from(</span><br><span class="line">      zipTree(configurations.otel.singleFile).matching &#123;</span><br><span class="line">        include <span class="string">&#x27;META-INF/MANIFEST.MF&#x27;</span></span><br><span class="line">      &#125;.singleFile</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体可以参考这里的配置：<br><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/examples/extension/build.gradle#L125">https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/examples/extension/build.gradle#L125</a></p><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><p>看起来这个开发过程挺简单的，但其中的坑还是不少。</p><h2 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h2><p>首先第一个就是我在调试过程中出现 <code>NoClassDefFoundError</code> 的异常。</p><p>但我把打包好的 extension 解压后明明是可以看到这个类的。</p><p><img src="https://s2.loli.net/2024/03/10/oyfEm27Tz5IJCnF.png"></p><p>排查一段时间后没啥头绪，我就从头仔细阅读了开发文档：<br><img src="https://s2.loli.net/2024/03/10/sLbS7Hum5TUz1VD.png"></p><p>发现我们需要重写 <code>getAdditionalHelperClassNames</code>函数，用于将我们外部的一些工具类加入到应用的 class loader 中，不然在应用在运行的时候就会报 <code>NoClassDefFoundError</code> 的错误。</p><p>因为是字节码增强的关系，所以很多日常开发觉得很常见的地方都不行了，比如：</p><ul><li>如果切面类是一个内部类的时候，必须使用静态函数</li><li>只能包含静态函数</li><li>不能包含任何字段，常量。</li><li>不能使用任何外部类，如果要使用就得使用 <code>getAdditionalHelperClassNames</code> 额外加入到 class loader 中（这一条就是我遇到的问题）</li><li>所有的函数必须使用 <code>@Advice</code> 注解</li></ul><p>以上的内容其实在文档中都有写：<br><img src="https://s2.loli.net/2024/03/10/1bXg6CMZYaUmdsu.png"></p><p>所以还是得仔细阅读文档。</p><h2 id="缺少异常日志"><a href="#缺少异常日志" class="headerlink" title="缺少异常日志"></a>缺少异常日志</h2><p>其实上述的异常刚开始都没有打印出来，只有一个现象就是程序没有正常运行。</p><p>因为没有日志也不知道如何排查，也怀疑是不是运行过程中报错了，所以就尝试把<code>@Advice</code> 注解的函数全部 try catch ，果然打印了上述的异常日志。</p><p><img src="https://s2.loli.net/2024/03/10/RMZbpyvkVc9qmJL.png"></p><p>之后我注意到了注解的这个参数，原来在默认情况下是不会打印任何日志的，需要手动打开。</p><p>比如这样：<code>@Advice.OnMethodExit(suppress = Throwable.class)</code></p><h2 id="调试日志"><a href="#调试日志" class="headerlink" title="调试日志"></a>调试日志</h2><p>最后就是调试功能了，因为我这个插件的是把指标发送到 OpenTelemetry-collector ，再由它发往 <code>VictoriaMetrics/Prometheus</code>；由于整个链路比较长，我想看到最终生成的指标是否正常的干扰条件太多了。</p><p>好在 OpenTelemetry 提供了多种 metrics.exporter 的输出方式：</p><ul><li>-Dotel.metrics.exporter&#x3D;otlp (default)，默认通过 otlp 协议输出到 collector 中。</li><li>-Dotel.metrics.exporter&#x3D;logging，以 stdout 的方式输出到控制台，主要用于调试</li><li>-Dotel.metrics.exporter&#x3D;logging-otlp</li><li>-Dotel.metrics.exporter&#x3D;prometheus，以 Prometheus 的方式输出，还可以配置端口，这样也可以让 Prometheus 进行远程采集，同样的也可以在本地调试。</li></ul><p>采用哪种方式可以根据环境情况自行选择。</p><h1 id="Opentelemetry-operator-配置-extension"><a href="#Opentelemetry-operator-配置-extension" class="headerlink" title="Opentelemetry-operator 配置 extension"></a>Opentelemetry-operator 配置 extension</h1><p>最近在使用 <code>opentelemetry-operator</code>注入 agent 的时候发现 operator 目前并不支持配置 extension，所以在社区也提交了一个<a href="https://github.com/open-telemetry/opentelemetry-operator/issues/1758#issuecomment-1982159356">草案</a>，下周会尝试提交一个 PR 来新增这个特性。</p><blockquote><p>这个需求我在 issue 列表中找到了好几个，时间也挺久远了，不太确定为什么社区还为实现。</p></blockquote><p>目前 operator 只支持在自定义镜像中配置 <code>javaagent.jar</code>，无法配置 extension：</p><blockquote><p>这个原理在之前的<a href="https://juejin.cn/post/7341669201010262053#heading-9">文章</a>中有提到。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">opentelemetry.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Instrumentation</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-instrumentation</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">java:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">your-customized-auto-instrumentation-image:java</span></span><br></pre></td></tr></table></figure><p>我的目的是可以在自定义镜像中把 extension 也复制进去，类似于这样：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> open-telemetry/opentelemetry-javaagent.jar /javaagent.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy extensions to specify a path.</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> open-telemetry/ext-1.0.0.jar /ext-1.0.0.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> -R go+r /javaagent.jar</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> -R go+r /ext-1.0.0.jar</span></span><br></pre></td></tr></table></figure><p>然后在 CRD 中配置这个 <code>extension</code> 的路径：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">opentelemetry.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Instrumentation</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-instrumentation</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">java:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">custom-image:1.0.0</span></span><br><span class="line">    <span class="attr">extensions:</span> <span class="string">/ext-1.0.0.jar</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="comment"># If extension.jar already exists in the container, you can only specify a specific path with this environment variable.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXTENSIONS_DIR</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">/custom-dir</span></span><br></pre></td></tr></table></figure><p>这样 operator 在拿到 extension 的路径时，就可以在环境变量中加入 <code>-Dotel.javaagent.extensions=$&#123;java.extensions&#125;</code> 参数，从而实现自定义 extension 的目的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个过程其实并不复杂，只是由于目前用的人还不算多，所以也很少有人写教程或者文章，相信用不了多久就会慢慢普及。</p><p>这里有一些官方的 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/examples/extension#extensions-examples">example</a>可以参考。</p><p>参考链接：</p><ul><li><a href="https://github.com/apache/pulsar/pull/22178">https://github.com/apache/pulsar/pull/22178</a></li><li><a href="https://opentelemetry.io/docs/languages/java/automatic/extensions/">https://opentelemetry.io/docs/languages/java/automatic/extensions/</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/examples/extension#extensions-examples">https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/examples/extension#extensions-examples</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-operator/issues/1758#issuecomment-1982159356">https://github.com/open-telemetry/opentelemetry-operator/issues/1758#issuecomment-1982159356</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间我们从 &lt;code&gt;SkyWalking&lt;/code&gt; 切换到了 &lt;code&gt;OpenTelemetry&lt;/code&gt; ，与此同时之前使用 SkyWalking 编写的插件也得转移到 OpenTelemetry 体系下。&lt;/p&gt;
&lt;p&gt;我也写了相关介绍文章：&lt;br&gt;实战：&lt;a href=&quot;https://juejin.cn/post/7341669201010262053&quot;&gt;如何优雅的从 SkyWalking 切换到 OpenTelemetry&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好在 OpenTelemetry 社区也提供了 Extensions 的扩展开发，我们可以不用去修改社区发行版：&lt;code&gt;opentelemetry-javaagent.jar&lt;/code&gt; 的源码也可以扩展其中的能力。&lt;/p&gt;
&lt;p&gt;比如可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改一些 trace，某些 span 不想记录等。&lt;/li&gt;
&lt;li&gt;新增 metrics&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>2024年的云原生架构需要哪些技术栈</title>
    <link href="http://crossoverjie.top/2024/04/11/ob/2024-cloud-native/"/>
    <id>http://crossoverjie.top/2024/04/11/ob/2024-cloud-native/</id>
    <published>2024-04-11T02:22:21.000Z</published>
    <updated>2024-04-10T13:34:24.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>时间过得很快啊，一转眼已经到了 2024 年，还记得 15 年刚工作那会掌握个 <code>SSM/H(Spring/Struts2/Mybatis/Hibernate)</code> 框架就能应付大部分面试了。</p><blockquote><p>现在 CS 专业的新同学估计都没听说过 SSM😢</p></blockquote><p>恰好从我刚开始工作时的移动互联网热潮到电商-&gt;共享经济-&gt;toB 大热-&gt;如今我都经历了一遍，技术栈也有由最开始的单体应用+物理机发展到现在的 kubernetes 云原生架构。</p><p>当然中途也经历了几个大的阶段：<br>SOA服务化-&gt; 微服务-&gt; 云原生-&gt; 服务网格-&gt; 无服务等几个阶段。</p><p>最近一份工作又主要是在做基础架构，我认为了解的还算是比较全面的，所以本文我就以我的视角分享下我们在 2024 年应当使用哪些云原生技术栈，因为涉及到的技术组件比较多，就不过多讨论细节了。</p><p>但可以保证的是提到的技术栈都是我所用过的，优缺点都会提到，主打一个真实体验。</p><span id="more"></span><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p> 首先是操作系统，这里有别于以往我们传统的操作系统(Linux&#x2F;Windows Server&#x2F;MacOS)，主要指的是云原生的操作系统，没有太多可以选择的余地，那就是 <code>kubernetes</code>。</p><p>不过怎么维护好 kubernetes 是一个难点问题，还记得去年下半年滴滴出过一次事故，网传就是 kubernetes 升级出现的问题。</p><p>根据我们的经验来看，对于小团队更建议直接托管给云厂商，维护 kubernetes 是一个非常复杂的工作，小团队通常都是一职多能，自己维护更容易出问题。</p><p>当然大团队有专人维护最好，即便是出问题也能快速响应，前提是自己能 cover 住这个风险。</p><blockquote><p>因为我们是小团队，所以考虑到成本和稳定性，我们也只使用了云厂商的 kubernetes 能力，其余的部分可控组件由我们自己维护（具体的后文会讲到）</p></blockquote><h2 id="多云的优势与好处"><a href="#多云的优势与好处" class="headerlink" title="多云的优势与好处"></a>多云的优势与好处</h2><p>既然都用了云厂商的容器服务，那也要考虑到云厂商故障可能带来的问题；比如去年的阿里云故障。</p><p>所以现在一些中大厂也会选择多云方案，将同一份代码部署再多个云服务商，一旦其中一个出现问题可以快速切换。</p><p>但具体的实施过程中也有许多挑战，比如最棘手也是最关键的数据一致性如何保证？</p><p>当然我们可以采用一些支持分布式部署的数据库或中间件，他们本身是支持数据同步的；比如消息队列中的 Pulsar，它就可以跨级群部署以及消息同步。</p><p>同时多云部署对应的成本也会提升，在这个“降本增效”的大背景下也得慎重考虑；所以对此还有一个折中方案：</p><blockquote><p>我们的技术架构需要具备快速迁移到其他云服务的能力，比如我们内部有一些工具可以定期备份资源，比如 MySQL 的 binlog，一些中间件的元数据，同时可以基于这些元数据快速恢复业务。</p></blockquote><p>一般遇到需要切换云服务时都是一些极端情况，所以允许部分运行时的数据丢失也是能接受的，我们只要保证最核心的数据不会丢失从而不影响业务即可。</p><p>这个说起来简单，但也需要我们花时间进行模拟演练；具体是否实施就得看公司是否接受云服务宕机带来的损失以及演练所花的成本了。</p><blockquote><p>我们是具备恢复元数据能力的，但会丢失部分运行时的数据。</p></blockquote><h1 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h1><p>既然我们已经选择 kubernetes 作为我们云原生的操作系统，那我们的持续集成与发布也得围绕着 kubernetes 来做。</p><p><img src="https://s2.loli.net/2024/03/05/P2ducxQtqSCGnDb.png"></p><p>上图是一张使用 Git 配合 gitlab+ArgoCD 的流程图，我们使用 gitlab 来管理源码，同时也可以利用他的 Pipline 帮我们做持续集成，最终使用 Argo 帮我们打通 kubernetes 的流程。</p><blockquote><p>也就是我们常说的 <code>GitOps</code></p></blockquote><p>同时我们的回滚历史版本，扩缩容都由 kubernetes 提供能力，我们的 DevOps 平台只需要调用 kubernetes 的 API 即可。</p><p>当然还有现在流行 FinOps，我的理解主要是做云成本的管理和优化，对应到我的工作就是回收一些不用的资源，在不影响业务的情况下适当的降低一些配置😳。</p><h1 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h1><p><img src="https://s2.loli.net/2024/03/06/mlzdFAHNM6bDGvr.png"></p><p>接下来便是我认为最重要的 Service Mesh 环节了，这个的背景故事就多了，本质上我觉得这都是由 RPC(Remote Process Call) 引起的也是分布式所带来的。</p><p>由最开始的单机的本地函数调用开始：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">local+------&gt;remote +------&gt; micro-service+-----&gt;service-mesh</span><br><span class="line">               +                  |                    +</span><br><span class="line">               v                  v                    v</span><br><span class="line">           +---+----+       +-----+------+        +----+----+</span><br><span class="line">           | motan  |       | SpringCloud|        | Istio   |</span><br><span class="line">           | dubbo  |       | Dubbo3.0   |        | Linkerd |</span><br><span class="line">           | gRPC   |       | SOFA       |        |         |</span><br><span class="line">           +--------+       +------------+        +---------+</span><br></pre></td></tr></table></figure><p>主要经历了以上三个重要的阶段，分别是 RPC 框架到微服务再到现在的服务网格。</p><ul><li>RPC 框架主要帮我们简化了分布式通信，只专注于业务本身</li><li>微服务框架的出现可以更好的帮我们治理大批量的服务，比如一些限流、路由、降级等功能，让我们分布式应用更加健壮。</li><li>而如今的服务网格让我们的应用程序更加适配云原生，专注于业务研发而不再需要去维护微服务框架；将这些基础功能全部下沉到我们的基础层，同时也带来了不弱于微服务框架的功能性。</li></ul><p>但使用 Istio 也有着不低的技术门槛，我觉得如果满足以下条件更推荐使用 Istio：</p><ul><li>应用已经接入 kubernetes 平台</li><li>应用之间采用的是 gRPC 通讯框架</li><li>API 网关也迁移到 Istio Gateway</li><li>公司至少预备一个专人维护 Istio（这里的维护不一定是对代码的了解，但一定要对 Istio 本身的功能和文档足够了解）</li></ul><p>除此之外使用 <code>SpringCloud</code>、<code>Dubbo</code>、<code>kratos</code>、<code>go-zero</code>之类的微服务框架也未尝不可。</p><p>我之前有写过两篇关于 Istio 的 文章，也可以用做参考：</p><ul><li><a href="https://crossoverjie.top/2023/10/16/ob/k8s-grpc-lb/">在 kubernetes 环境中实现 gRPC 负载均衡</a></li><li><a href="https://crossoverjie.top/2023/10/31/ob/k8s-Istio01/">服务网格实战-入门Istio</a></li></ul><h1 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h1><p><img src="https://s2.loli.net/2024/03/06/wOtk3Fb5fhEIWpB.png"><br>现如今可观测系统也变得越来越重要，个人觉得评价一个技术团队重要指标就是他们的可观测系统做的如何。</p><p>一个优秀的可观测系统可以清晰得知系统的运行状态、高效的排查问题、还有及时的故障告警。</p><p>要实现上述标准就需要我们可观测系统的三个核心指标了：</p><p><img src="https://s2.loli.net/2024/03/06/gXQIfcJO1qVWimH.png"></p><ul><li>Metrics，借助它我们可以在 Grafana 中绘制出各种直观的面板，可以更加全面的了解我们系统的运行状态</li></ul><p><img src="https://s2.loli.net/2024/03/06/sWk2gXnTNxuafBF.png"></p><ul><li>Trace则是可以帮助我们构建出系统调用的全貌，通过一个 trace 就可以知道一个请求经历了哪些系统，在哪个环节出了问题。</li><li>Logs 就比较好理解了，就是我们自己在应用里打印的一些日志；只是和以往的开发模式略有不同的是：在云原生体系中更推荐直接输出到标准输出和标准错误流中，一些第三方采集组件可以更方便的进行采集。</li></ul><hr><p>我们自己的可观测系统经历过一次迭代，以往的技术栈是：</p><ul><li><code>Metrics</code> 使用 <code>VictoriaMetrics</code>：这是一个完全兼容 <code>Prometheus</code> 的时序数据库，但相对 <code>Prometheus</code> 来说更加的节省资源。</li><li>Trace 选择的是 <code>SkyWalking</code>，这也是 Java trace 领域比较流行的技术方案。</li><li>Logs：使用 filebeat 采集日志然后输出到 ElasticSearch 中，这也是比较经典的方案。</li></ul><p>去年底我们做了一次比较大的改造，主要就是将 <code>SkyWalking</code> 换为了 <code>OpenTelemetry</code>，这是一个更加开放的社区，也逐渐成为云原生可观测的标准了。</p><p>使用它我们的灵活性更高，不用与某些具体的技术栈进行绑定；目前 logs 还没有切换，社区也还在 beta 测试中，后续成熟后也可以直接用 <code>OpenTelemetry</code> 来收集日志。</p><p>我也写的有一篇 SW 迁移到 <code>OpenTelemetry</code> 的文章，感兴趣的朋友可以参考：</p><ul><li><a href="https://juejin.cn/post/7341669201010262053">实战：如何优雅的从 SkyWalking 切换到 OpenTelemetry</a></li></ul><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>这里单独把消息队列拎出来是因为我目前主要是在维护公司内部的消息队列，同时业务体量大了之后消息队列变得非常重要了，通常会充当各个业务线对接的桥梁，或者是数据库同步 MySQL 的渠道，总之用处非常广泛。</p><p><img src="https://s2.loli.net/2024/03/07/WBeYUK8AVlcrgGs.png"></p><p>这里还是推荐更贴合云原生的消息队列 Pulsar，由于它存算分离的架构特性，配合kubernetes 的特性可以实现快速的扩缩容，相比 kafka 来说更易维护；同时社区活跃度也非常高，在 Bug 修复和支持新特性方面比较积极。</p><p>Pulsar官方支持的客户端也比较全面：</p><table><thead><tr><th>Language</th><th>Documentation</th><th>Release note</th><th>Code repo</th></tr></thead><tbody><tr><td>Java</td><td><a href="client-libraries-java.md">User doc</a>   <br/> <a href="/api/client/">API doc</a></td><td><a href="pathname:///release-notes/client-java">Standalone</a></td><td><a href="https://github.com/apache/pulsar/tree/master/pulsar-client">Bundled</a></td></tr><tr><td>C++</td><td><a href="client-libraries-cpp.md">User doc</a>    <br/> <a href="@pulsar:apidoc:cpp@">API doc</a></td><td><a href="pathname:///release-notes/client-cpp">Standalone</a></td><td><a href="https://github.com/apache/pulsar-client-cpp">Standalone</a></td></tr><tr><td>Python</td><td><a href="client-libraries-python.md">User doc</a> <br/> <a href="@pulsar:apidoc:python@">API doc</a></td><td><a href="pathname:///release-notes/client-python">Standalone</a></td><td><a href="https://github.com/apache/pulsar-client-python">Standalone</a></td></tr><tr><td>Go client</td><td><a href="client-libraries-go.md">User doc</a>   <br/> <a href="https://pkg.go.dev/github.com/apache/pulsar-client-go/pulsar">API doc</a></td><td><a href="pathname:///release-notes/client-go">Standalone</a></td><td><a href="https://github.com/apache/pulsar-client-go">Standalone</a></td></tr><tr><td>Node.js</td><td><a href="client-libraries-node.md">User doc</a>  <br/> <a href="@pulsar:apidoc:js@">API doc</a></td><td><a href="pathname:///release-notes/client-node">Standalone</a></td><td><a href="https://github.com/apache/pulsar-client-node">Standalone</a></td></tr><tr><td>C#&#x2F;DotPulsar</td><td><a href="client-libraries-dotnet.md">User doc</a></td><td><a href="pathname:///release-notes/client-cs">Standalone</a></td><td><a href="https://github.com/apache/pulsar-dotpulsar">Standalone</a></td></tr></tbody></table><p>还有一个问题是：如何部署我们的 Pulsar 集群，是私有化部署还是购买云服务（目前 Pulsar的商业公司 streamnative 和国内的腾讯云都有类似的服务）</p><p>我们之前有咨询过价格，相对来说还是自己部署性价比最高；和前文讲的一样，只使用云厂商的 kubernetes 服务，在这基础上部署我们的自己的服务。</p><p>因为得益于 Pulsar 社区的活跃，即便是自己维护出现问题也可以及时得到反馈；同时自己平时踩的坑也可以反哺社区。</p><p>之前也写过一些关于 Pulsar 的系列文章，感兴趣的可以查阅：</p><ul><li><a href="https://juejin.cn/post/7340195874867904547">在 kubernetes 环境下如何优雅扩缩容 Pulsar</a></li><li><a href="https://crossoverjie.top/2024/01/03/ob/Pulsar3.0-new-feature/">Pulsar3.0新功能介绍</a></li><li><a href="https://crossoverjie.top/2023/02/07/pulsar/pulsar-load-banance/">Pulsar负载均衡原理及优化</a></li><li><a href="https://crossoverjie.top/2024/01/15/ob/Bookkeeper-storage/">白话 Pulsar Bookkeeper 的存储模型</a></li><li><a href="https://crossoverjie.top/2023/01/16/pulsar/pulsar-perf-test/">Pulsar压测及优化</a></li></ul><h1 id="业务框架"><a href="#业务框架" class="headerlink" title="业务框架"></a>业务框架</h1><p>最后是业务框架的选择，决定这个的前提是我们先要确定选择哪个语言作为主力业务语言。</p><p>虽然这点对于 kubernetes 来说无关紧要，下面以我比较熟悉的 Java 和 Golang 进行介绍。</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>Java 可选的技术方案就比较多了，如果我们只是上了 kubernetes 但没有使用服务网格；那完全可以只使用 <code>springboot</code> 开发 http 接口，就和开发一个单体应用一样简单。</p><p>只是这样会缺少一些服务治理的能力，更适用于中小型团队。</p><p>如果团队人员较多，也没使用服务网格时；那就推荐使用前文介绍的微服务框架：比如 Dubbo、SpringCloud 等。</p><p>当有专门的云原生团队时，则更推荐使用服务网格的方案，这样我们就能综合以上两种方案的优点：</p><ul><li>代码简洁，只是需要将 http 换为 gRPC。</li><li>同时利用 Istio 也包含了微服务框架的能力。</li></ul><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><p>Golang 其实也与 Java 类似，中小团队时我们完全可以只使用 Gin 这类 http 框架进行开发。</p><p>而中大型团队在 <code>Golang</code> 生态中也有对标 <code>Dubbo</code> 和 <code>SpringCloud</code> 的框架，比如 <a href="https://github.com/go-kratos/kratos">kratos</a>和 <a href="https://github.com/zeromicro/go-zero">go-zero</a> 等。</p><p>得益于 Golang 的简洁特性，我觉得比使用 Java 开发业务更加简单和“无脑”。</p><p>同样的后续也可以切换到服务网格，直接采用 gRPC 和 Golang 也非常适配，此时团队应该也比较成熟了，完全可以自己基于 gRPC 做一个开发脚手架，或者也可以使用 Kratos 或者是 go-zero 去掉他们的服务调用模块即可。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是个人对目前流行的技术方案的理解，也分别对不同团队规模进行了推荐；确实没有完美的技术方案，只有最合适的，也不要跟风选择一些自己不能把控的技术栈，最终吃亏的可能就是自己。</p><p>参考链接：</p><ul><li><a href="https://levelup.gitconnected.com/gitops-in-kubernetes-with-gitlab-ci-and-argocd-9e20b5d3b55b">https://levelup.gitconnected.com/gitops-in-kubernetes-with-gitlab-ci-and-argocd-9e20b5d3b55b</a></li><li><a href="https://grpc.io/">https://grpc.io/</a></li></ul><p>#Blog #CloudNative </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;时间过得很快啊，一转眼已经到了 2024 年，还记得 15 年刚工作那会掌握个 &lt;code&gt;SSM/H(Spring/Struts2/Mybatis/Hibernate)&lt;/code&gt; 框架就能应付大部分面试了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在 CS 专业的新同学估计都没听说过 SSM😢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;恰好从我刚开始工作时的移动互联网热潮到电商-&amp;gt;共享经济-&amp;gt;toB 大热-&amp;gt;如今我都经历了一遍，技术栈也有由最开始的单体应用+物理机发展到现在的 kubernetes 云原生架构。&lt;/p&gt;
&lt;p&gt;当然中途也经历了几个大的阶段：&lt;br&gt;SOA服务化-&amp;gt; 微服务-&amp;gt; 云原生-&amp;gt; 服务网格-&amp;gt; 无服务等几个阶段。&lt;/p&gt;
&lt;p&gt;最近一份工作又主要是在做基础架构，我认为了解的还算是比较全面的，所以本文我就以我的视角分享下我们在 2024 年应当使用哪些云原生技术栈，因为涉及到的技术组件比较多，就不过多讨论细节了。&lt;/p&gt;
&lt;p&gt;但可以保证的是提到的技术栈都是我所用过的，优缺点都会提到，主打一个真实体验。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="CloudNative" scheme="http://crossoverjie.top/tags/CloudNative/"/>
    
    <category term="k8s" scheme="http://crossoverjie.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>实战：如何优雅的从 Skywalking 切换到 OpenTelemetry</title>
    <link href="http://crossoverjie.top/2024/04/07/ob/otel-replace-sw/"/>
    <id>http://crossoverjie.top/2024/04/07/ob/otel-replace-sw/</id>
    <published>2024-04-07T09:16:21.000Z</published>
    <updated>2024-04-07T15:27:53.792Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/03/04/8YFIh7suTirZacj.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近公司将我们之前使用的链路工具切换为了 <code>OpenTelemetry</code>.</p><p><img src="https://s2.loli.net/2024/03/03/9V1aUnpOd8EAG2Y.png"></p><span id="more"></span><p>我们的技术栈是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        OTLP                               </span><br><span class="line">Client──────────►Collect────────►StartRocks</span><br><span class="line">(Agent)                               ▲    </span><br><span class="line">                                      │    </span><br><span class="line">                                      │    </span><br><span class="line">                                   Jaeger                                       </span><br></pre></td></tr></table></figure><p>其中客户端使用 OpenTelemetry 提供的 Java Agent 进行埋点收集数据，再由 Agent 通过 OTLP(OpenTelemetry Protocol) 协议将数据发往 Collector，在 <code>Collector</code> 中我们可以自行任意处理数据，并决定将这些数据如何存储（这点在以往的 SkyWalking 体系中是很难自定义的）</p><p>这里我们将数据写入 StartRocks 中，供之后的 UI 层进行查看。</p><blockquote><p><code>OpenTelemetry</code> 是可观测系统的新标准，基于它可以兼容以前使用的 Prometheus、 victoriametrics、skywalking 等系统，同时还可以灵活扩展，不用与任何但一生态或技术栈进行绑定。<br>更多关于 OTel 的内容会在今后介绍。</p></blockquote><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><p>其中有一个关键问题就是：如何在线上进行<strong>无缝切换</strong>。</p><p>虽然我们内部的发布系统已经支持重新发布后就会切换到新的链路，也可以让业务自行发布然后逐步的切换到新的系统，这样也是最保险的方式。</p><p>但这样会有几个问题：</p><ul><li>当存在调用依赖的系统没有全部切换为新链路时，再查询的时候就会出现断层，整个链路无法全部串联起来。</li><li>业务团队没有足够的动力去推动发布，可能切换的周期较长。</li></ul><p>所以最好的方式还是由我们在后台统一发布，对外没有任何感知就可以一键全部切换为 OpenTelemetry。</p><p>仔细一看貌似也没什么难的，无非就是模拟用户点击发布按钮而已。</p><p>但这事由我们自动来做就不一样了，用户点击发布的时候会选择他们认为可以发布的分支进行发布，我们不能自作主张的比如选择 main 分支，有可能只是合并了但还不具备发布条件。</p><p>所以保险的方式还是得用当前项目上一次发布时所使用的 git hash 值重新打包发布。</p><p>但这也有几个问题：</p><ul><li>重复打包发布太慢了，线上几十上百个项目，每打包发布一次就得几分钟，虽然可以并发，但考虑到 kubernetes 的压力也不能调的太高。</li><li>保不准业务镜像中有单独加入一些环境变量，这样打包可能会漏。</li></ul><h1 id="切换方案"><a href="#切换方案" class="headerlink" title="切换方案"></a>切换方案</h1><p>所以思来想去最保险的方法还是将业务镜像拉取下来，然后手动删除镜像中的 skywalking 包以及 JVM 参数，全部替换为 OpenTelemetry 的包和 JVM 参数。</p><p>整体的方案如下：</p><ol><li>遍历 namespace 的 <code>pod ＞0</code> 的 deployment</li><li>遍历 deployment 中的所有 container，获得业务镜像<ol><li>跳过 istio 和日志采集 container，获取到业务容器</li><li>判断该容器是否需要替换，其实就是判断环境变量中是否有 skywalking ，如果有就需要替换。</li><li>获取业务容器的镜像</li></ol></li><li>基于该 Image 重新构建一个 OpenTelemetry 的镜像<br>   3.1 新的镜像包含新的启动脚本.<br>   3.1.1 新的启动脚本中会删除原有的 skywalking agent<br>   3.2 新镜像会包含 OpenTelemetry 的 jar 包以及我们自定义的 OTel 扩展包<br>   3.3 替换启动命令为新的启动脚本</li><li>修改 deployment 中的 JVM 启动参数</li><li>修改 deployment 的镜像后滚动更新</li><li>开启一个 goroutine 定时检测更新之后是否启动成功<ol><li>如果长时间 (比如五分钟) 都没有启动成功，则执行回滚流程</li></ol></li></ol><h1 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h1><p>因为需要涉及到操作 kubernetes，所以整体就使用 Golang 实现了。</p><h2 id="遍历-deployment-得到需要替换的容器镜像"><a href="#遍历-deployment-得到需要替换的容器镜像" class="headerlink" title="遍历 deployment 得到需要替换的容器镜像"></a>遍历 deployment 得到需要替换的容器镜像</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessDeployment</span><span class="params">(ctx context.Context, finish []<span class="type">string</span>, deployment v1.Deployment, clientSet kubernetes.Interface)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">deploymentName := deployment.Name</span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> finish &#123;</span><br><span class="line"><span class="keyword">if</span> s == deploymentName &#123;</span><br><span class="line">klog.Infof(<span class="string">&quot;Skip finish deployment:%s&quot;</span>, deploymentName)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Write finish deployment name to a file</span></span><br><span class="line"><span class="keyword">defer</span> writeDeploymentName2File(deploymentName, fmt.Sprintf(<span class="string">&quot;finish-%s.log&quot;</span>, deployment.Namespace))</span><br><span class="line"></span><br><span class="line">appName := deployment.GetObjectMeta().GetLabels()[<span class="string">&quot;appName&quot;</span>]</span><br><span class="line">klog.Infof(<span class="string">&quot;Begin to process deployment:%s, appName:%s&quot;</span>, deploymentName, appName)</span><br><span class="line"></span><br><span class="line">upgrade, err := checkContainIstio(ctx, deployment, clientSet)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> upgrade == <span class="literal">false</span> &#123;</span><br><span class="line">klog.Infof(<span class="string">&quot;Don&#x27;t have istio, No need to upgrade deployment:%s appName:%s&quot;</span>, deploymentName, appName)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, container := <span class="keyword">range</span> deployment.Spec.Template.Spec.Containers &#123;</span><br><span class="line"><span class="keyword">if</span> strings.HasPrefix(deploymentName, container.Name) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if container has sw jvm</span></span><br><span class="line"><span class="keyword">for</span> _, envVar := <span class="keyword">range</span> container.Env &#123;</span><br><span class="line"><span class="keyword">if</span> envVar.Name == <span class="string">&quot;CATALINA_OPTS&quot;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.Contains(envVar.Value, <span class="string">&quot;skywalking&quot;</span>) &#123;</span><br><span class="line">klog.Infof(<span class="string">&quot;Skip upgrade don&#x27;t have sw jvm deployment:%s container:%s&quot;</span>, deploymentName, container.Name)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">upgrade(container)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check newDeployment status</span></span><br><span class="line"><span class="keyword">go</span> checkNewDeploymentStatus(ctx, clientSet, newDeployment)</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete from image</span></span><br><span class="line">deleteImage(container.Image)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数需要传入一个 deployment ，同时还有一个已经完成了的列表进来。</p><blockquote><p>已完成列表用于多次运行的时候可以快速跳过已经执行的 deployment。</p></blockquote><p><code>checkContainIstio()</code> 函数很简单，判断是否包含了 Istio 容器，如果没有包含说明不是后端应用（可能是前端、大数据之类的任务），就可以直接跳过了。</p><hr><p><img src="https://s2.loli.net/2024/03/03/xzHPV9mgCJkZ4cY.png"><br>而判断是否需要替换的前提这事判断环境变量 <code>CATALINA_OPTS</code> 中是否包含了 skywalking 的内容，如果包含则说明需要进行替换。</p><h2 id="Upgrade-核心函数"><a href="#Upgrade-核心函数" class="headerlink" title="Upgrade 核心函数"></a>Upgrade 核心函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upgrade</span><span class="params">(container Container)</span></span>&#123;</span><br><span class="line">klog.Infof(<span class="string">&quot;Begin to upgrade deployment:%s container:%s&quot;</span>, deploymentName, container.Name)</span><br><span class="line">newImageName := fmt.Sprintf(<span class="string">&quot;%s-otel-%s&quot;</span>, container.Image, generateRandomString(<span class="number">4</span>))</span><br><span class="line">err := BuildNewOtelImage(container.Image, newImageName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update deployment jvm ENV</span></span><br><span class="line"><span class="keyword">for</span> e, envVar := <span class="keyword">range</span> container.Env &#123;</span><br><span class="line"><span class="keyword">if</span> envVar.Name == <span class="string">&quot;CATALINA_OPTS&quot;</span> &#123;</span><br><span class="line">otelJVM := replaceSWAgent2OTel(envVar.Value, appName)</span><br><span class="line">deployment.Spec.Template.Spec.Containers[i].Env[e].Value = otelJVM</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Update deployment image</span></span><br><span class="line">deployment.Spec.Template.Spec.Containers[i].Image = newImageName</span><br><span class="line"></span><br><span class="line">newDeployment, err := clientSet.AppsV1().Deployments(deployment.Namespace).Update(ctx, &amp;deployment, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">klog.Infof(<span class="string">&quot;Finish upgrade deployment:%s container:%s&quot;</span>, deploymentName, container.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一共分为以下几部：</p><ul><li>基于老镜像构建新镜像</li><li>更新原有的 <code>CATALINA_OPTS</code> 环境变量，也就是替换 skywalking 的参数</li><li>更新 deployment 镜像，触发滚动更新</li></ul><h2 id="构建新镜像"><a href="#构建新镜像" class="headerlink" title="构建新镜像"></a>构建新镜像</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">dockerfile = fmt.Sprintf(<span class="string">`FROM %s</span></span><br><span class="line"><span class="string">COPY %s /home/admin/%s</span></span><br><span class="line"><span class="string">COPY otel.tar.gz /home/admin/otel.tar.gz</span></span><br><span class="line"><span class="string">RUN tar -zxvf /home/admin/otel.tar.gz -C /home/admin</span></span><br><span class="line"><span class="string">RUN rm -rf /home/admin/skywalking-agent</span></span><br><span class="line"><span class="string">ENTRYPOINT [&quot;/bin/sh&quot;, &quot;/home/admin/start.sh&quot;]</span></span><br><span class="line"><span class="string">`</span>, fromImage, script, script)</span><br><span class="line"></span><br><span class="line">idx := strings.LastIndex(newImageName, <span class="string">&quot;/&quot;</span>) + <span class="number">1</span></span><br><span class="line">dockerFileName := newImageName[idx:]</span><br><span class="line">create, err := os.Create(fmt.Sprintf(<span class="string">&quot;Dockerfile-%s&quot;</span>, dockerFileName))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">create.Close()</span><br><span class="line">os.Remove(create.Name())</span><br><span class="line">&#125;()</span><br><span class="line">_, err = create.WriteString(dockerfile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmd := exec.Command(<span class="string">&quot;docker&quot;</span>, <span class="string">&quot;build&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;-f&quot;</span>, create.Name(), <span class="string">&quot;-t&quot;</span>, newImageName)</span><br><span class="line">cmd.Stdin = strings.NewReader(dockerfile)</span><br><span class="line"><span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里的重点就是构建这个新镜像，从这个 dockerfile 中也能看出具体的逻辑，也就是上文提到的删除原有的 skywalking 资源同时将新的 OpenTelemetry 资源打包进去。</p><p>最后再将这个镜像上传到私服。</p><p><img src="https://s2.loli.net/2024/03/03/s7fryhQSPJgcuvj.png"><br>其中的替换 JVM 参数也比较简单，直接删除 skywalking 的内容，然后再追加上 OpenTelemetry 需要的参数即可。</p><h2 id="定时检测替换是否成功"><a href="#定时检测替换是否成功" class="headerlink" title="定时检测替换是否成功"></a>定时检测替换是否成功</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkNewDeploymentStatus</span><span class="params">(ctx context.Context, clientSet kubernetes.Interface, newDeployment *v1.Deployment)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">ready := <span class="literal">true</span></span><br><span class="line">tick := time.Tick(<span class="number">10</span> * time.Second)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">30</span>; i++ &#123;</span><br><span class="line">&lt;-tick</span><br><span class="line">originPodList, err := clientSet.CoreV1().Pods(newDeployment.Namespace).List(ctx, metav1.ListOptions&#123;</span><br><span class="line">LabelSelector: metav1.FormatLabelSelector(&amp;metav1.LabelSelector&#123;</span><br><span class="line">MatchLabels: newDeployment.Spec.Selector.MatchLabels,</span><br><span class="line">&#125;),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if there are any Pods</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(originPodList.Items) == <span class="number">0</span> &#123;</span><br><span class="line">klog.Infof(<span class="string">&quot;No Pod in deployment:%s, Skip&quot;</span>, newDeployment.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> originPodList.Items &#123;</span><br><span class="line"><span class="comment">// Check Pod running</span></span><br><span class="line"><span class="keyword">for</span> _, status := <span class="keyword">range</span> item.Status.ContainerStatuses &#123;</span><br><span class="line"><span class="keyword">if</span> status.RestartCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">ready = <span class="literal">false</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">klog.Infof(<span class="string">&quot;Check deployment:%s namespace:%s status:%t&quot;</span>, newDeployment.Name, newDeployment.Namespace, ready)</span><br><span class="line"><span class="keyword">if</span> ready == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ready == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="comment">// rollback</span></span><br><span class="line">klog.Infof(<span class="string">&quot;=======Rollback deployment:%s namespace:%s&quot;</span>, newDeployment.Name, newDeployment.Namespace)</span><br><span class="line">writeDeploymentName2File(newDeployment.Name, fmt.Sprintf(<span class="string">&quot;rollback-%s.log&quot;</span>, newDeployment.Namespace))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会启动一个 10s 执行一次的定时任务，每次都会检测是否有容器发生了重启（正常情况下是不会出现重启的）</p><p>如果检测了 30 次都没有重启的容器，那就说明本次替换成功了，不然就记录一个日志文件，然后人工处理。</p><blockquote><p>这种通常是原有的镜像与 OpenTelemetry 不兼容，比如里面写死了一些 skywalking 的 API，导致启动失败。</p></blockquote><p>所以替换任务跑完之后我还会检测这个 <code>rollback-$namespace</code> 的日志文件，人工处理这些失败的应用。</p><h2 id="分批处理-deployment"><a href="#分批处理-deployment" class="headerlink" title="分批处理 deployment"></a>分批处理 deployment</h2><p>最后讲讲如何单个调用刚才的 <code>ProcessDeployment()</code> 函数。</p><p>考虑到不能对 kubernetes 产生影响，所以我们需要限制并发处理 deployment 的数量（我这里的限制是 10 个）。</p><p>所以就得分批进行替换，每次替换 10 个，而且其中有一个执行失败就得暂停后续任务，由人工检测失败原因再决定是否继续处理。</p><blockquote><p>毕竟处理的是线上应用，需要小心谨慎。</p></blockquote><p>所以触发的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessDeploymentList</span><span class="params">(ctx context.Context, data []v1.Deployment, clientSet kubernetes.Interface)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">file, err := os.ReadFile(fmt.Sprintf(<span class="string">&quot;finish-%s.log&quot;</span>, data[<span class="number">0</span>].Namespace))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">split := strings.Split(<span class="type">string</span>(file), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">batchSize := <span class="number">10</span></span><br><span class="line">start := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> start &lt; <span class="built_in">len</span>(data) &#123;</span><br><span class="line"></span><br><span class="line">end := start + batchSize</span><br><span class="line"><span class="keyword">if</span> end &gt; <span class="built_in">len</span>(data) &#123;</span><br><span class="line">end = <span class="built_in">len</span>(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">batch := data[start:end]</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待goroutine结束</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">klog.Infof(<span class="string">&quot;Start process batch size %d&quot;</span>, <span class="built_in">len</span>(batch))</span><br><span class="line"></span><br><span class="line">errs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="built_in">len</span>(batch))</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="built_in">len</span>(batch))</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> batch &#123;</span><br><span class="line">d := item</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">if</span> err := ProcessDeployment(ctx, split, d, clientSet); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">&quot;!!!Process deployment name:%s error: %v&quot;</span>, d.Name, err)</span><br><span class="line">errs &lt;- err</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(errs)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">//任何一个失败就返回</span></span><br><span class="line"><span class="keyword">for</span> err := <span class="keyword">range</span> errs &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start = end</span><br><span class="line">klog.Infof(<span class="string">&quot;Deal next batch&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>WaitGroup</code> 来控制一组任务，使用一个 chan 来传递异常；这类分批处理的代码在一些批处理框架中还蛮常见的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后只需要查询某个 namespace 下的所有 deployment 列表传入这个批处理函数即可。</p><p>不过整个过程中还是有几个点需要注意：</p><ul><li>因为需要替换镜像的前提是要把现有的镜像拉取到本地，所以跑这个任务的客户端需要有充足的磁盘，同时和镜像服务器的网络条件较好。</li><li>不然执行的过程会比较慢，同时磁盘占用满了也会影响任务。</li></ul><p>其实这个功能依然有提升空间，考虑到后续会升级 OpenTelemetry  agent 的版本，甚至也需要增减一些 JVM 参数。</p><p>所以最后有一个统一的工具，可以直接升级 Agent，而不是每次我都需要修改这里的代码。</p><p><img src="https://s2.loli.net/2024/03/03/lLIqQtmD2AdfGyv.png"></p><p>后来在网上看到了得物的相关分享，他们可以远程加载配置来解决这个问题。</p><p>这也是一种解决方案，直到我们看到了 OpenTelemetry 社区提供了 <a href="https://github.com/open-telemetry/opentelemetry-operator/#opentelemetry-auto-instrumentation-injection">Operator</a>，其中也包含了注入 agent 的功能。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">opentelemetry.io/v1alpha1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Instrumentation</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-instrumentation</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">exporter:</span>  </span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">http://otel-collector:4317</span>  </span><br><span class="line">  <span class="attr">propagators:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">tracecontext</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">baggage</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">b3</span>  </span><br><span class="line">  <span class="attr">sampler:</span>  </span><br><span class="line">    <span class="attr">type:</span> <span class="string">parentbased_traceidratio</span>  </span><br><span class="line">    <span class="attr">argument:</span> <span class="string">&quot;0.25&quot;</span>  </span><br><span class="line">  <span class="attr">java:</span>  </span><br><span class="line">    <span class="attr">image:</span> <span class="string">private/autoinstrumentation-java:1.32.0-1</span></span><br></pre></td></tr></table></figure><p>我们可以使用他提供的 CRD 来配置我们 agent，只要维护好自己的镜像就好了。</p><p>使用起来也很简单，只要安装好了 OpenTelemetry-operator ，然后再需要注入 Java Agent 的 Pod 中使用注解：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">instrumentation.opentelemetry.io/inject-java:</span> <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure><p> operator 就会自动从刚才我们配置的镜像中读取 agent，然后复制到我们的业务容器。</p><p>再配置上环境变量 <code>$JAVA_TOOL_OPTIONS=/otel/javaagent.java</code>, 这是一个 Java 内置的环境变量，应用启动的时候会自动识别，这样就可以自动注入 agent 了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">envJavaToolsOptions   = <span class="string">&quot;JAVA_TOOL_OPTIONS&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set env value</span></span><br><span class="line">idx := getIndexOfEnv(container.Env, envJavaToolsOptions)  </span><br><span class="line"><span class="keyword">if</span> idx == <span class="number">-1</span> &#123;  </span><br><span class="line">    container.Env = <span class="built_in">append</span>(container.Env, corev1.EnvVar&#123;  </span><br><span class="line">       Name:  envJavaToolsOptions,  </span><br><span class="line">       Value: javaJVMArgument,  </span><br><span class="line">    &#125;)&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    container.Env[idx].Value = container.Env[idx].Value + javaJVMArgument  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy javaagent.jar</span></span><br><span class="line">pod.Spec.InitContainers = <span class="built_in">append</span>(pod.Spec.InitContainers, corev1.Container&#123;  </span><br><span class="line">    Name:      javaInitContainerName,  </span><br><span class="line">    Image:     javaSpec.Image,  </span><br><span class="line">    Command:   []<span class="type">string</span>&#123;<span class="string">&quot;cp&quot;</span>, <span class="string">&quot;/javaagent.jar&quot;</span>, javaInstrMountPath + <span class="string">&quot;/javaagent.jar&quot;</span>&#125;,  </span><br><span class="line">    Resources: javaSpec.Resources,  </span><br><span class="line">    VolumeMounts: []corev1.VolumeMount&#123;&#123;  </span><br><span class="line">       Name:      javaVolumeName,  </span><br><span class="line">       MountPath: javaInstrMountPath,  </span><br><span class="line">    &#125;&#125;,&#125;)</span><br></pre></td></tr></table></figure><p>大致的运行原理是当有 Pod 的事件发生了变化（重启、重新部署等），operator 就会检测到变化，此时会判断是否开启了刚才的注解：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">instrumentation.opentelemetry.io/inject-java:</span> <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure><p>接着会写入环境变量 <code>JAVA_TOOL_OPTIONS</code>，同时将 jar 包从 InitContainers 中复制到业务容器中。</p><blockquote><p>这里使用到了 kubernetes 的初始化容器，该容器是用于做一些准备工作的，比如依赖安装、配置检测或者是等待其他一些组件启动成功后再启动业务容器。</p></blockquote><p>目前这个 operator 还处于使用阶段，同时部分功能还不满足（比如支持自定义扩展），今后有时间也可以分析下它的运行原理。</p><p>参考链接：</p><ul><li><a href="https://xie.infoq.cn/article/e6def1e245e9d67735bd00dd5">https://xie.infoq.cn/article/e6def1e245e9d67735bd00dd5</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-operator/#opentelemetry-auto-instrumentation-injection">https://github.com/open-telemetry/opentelemetry-operator/#opentelemetry-auto-instrumentation-injection</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/03/04/8YFIh7suTirZacj.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近公司将我们之前使用的链路工具切换为了 &lt;code&gt;OpenTelemetry&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/03/03/9V1aUnpOd8EAG2Y.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="k8s" scheme="http://crossoverjie.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>在 kubernetes 环境下如何优雅扩缩容 Pulsar</title>
    <link href="http://crossoverjie.top/2024/03/27/ob/k8s-pulsar-scale/"/>
    <id>http://crossoverjie.top/2024/03/27/ob/k8s-pulsar-scale/</id>
    <published>2024-03-27T08:13:42.000Z</published>
    <updated>2024-05-13T07:46:08.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在整个大环境的降本增效的熏陶下，我们也不得不做好应对方案。</p><p>根据对线上流量、存储以及系统资源的占用，发现我们的 Pulsar 集群有许多的冗余，所以考虑进行缩容从而减少资源浪费，最终也能省一些费用。</p><p>不过在缩容之前很有必要先聊聊扩容，Pulsar 一开始就是存算分离的架构（更多关于 Pulsar 架构的内容本文不做过多介绍，感兴趣的可以自行搜索），天然就非常适合 kubernetes 环境，也可以利用 <code>kubernetes</code> 的能力进行快速扩容。</p><span id="more"></span><h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p>Pulsar 的扩容相对比较简单，在 kubernetes 环境下只需要修改副本即可。</p><h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p>当我们的 broker 层出现瓶颈时（比如 CPU、内存负载较高、GC 频繁时）可以考虑扩容。</p><blockquote><p>计算层都扩容了，也需要根据流量计算下存储层是否够用。</p></blockquote><p>如果我们使用的是 helm 安装的 Pulsar 集群，那只需要修改对于的副本数即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">broker:</span>  </span><br><span class="line">  <span class="string">configuration</span>  </span><br><span class="line">  <span class="attr">component:</span> <span class="string">broker</span>  </span><br><span class="line">  <span class="attr">replicaCount:</span> <span class="number">3</span><span class="string">-&gt;5</span></span><br></pre></td></tr></table></figure><p>当我们将副本数从 3 增加到 5 之后 kubernetes 会自动拉起新增的两个 Pod，之后我们啥也不需要做了。</p><p>Pulsar 的负载均衡器会自动感知到新增两个 broker 的加入，从而帮我们将一些负载高的节点的流量迁移到新增的节点中。</p><h2 id="Bookkeeper"><a href="#Bookkeeper" class="headerlink" title="Bookkeeper"></a>Bookkeeper</h2><p>在介绍 bookkeeper 扩容前先简单介绍些 Bookkeeper 的一些基本概念。</p><ul><li>Ensemble size (E)：当前 Bookkeeper 集群的节点数量</li><li>Write quorum size (QW)：一条消息需要写入到几个 Bookkeeper 节点中</li><li>ACK quorum size (QA)：有多少个 Bookkeeper 节点 ACK 之后表示写入成功</li></ul><p>对应到我们在 <code>broker.conf</code> 中的配置如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">managedLedgerDefaultEnsembleSize</span>: <span class="string">&quot;2&quot;  </span></span><br><span class="line"><span class="attr">managedLedgerDefaultWriteQuorum</span>: <span class="string">&quot;2&quot;  </span></span><br><span class="line"><span class="attr">managedLedgerDefaultAckQuorum</span>: <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure><p>这个三个参数表示一条消息需要同时写入两个 Bookkeeper 节点，同时都返回 ACK 之后才能表示当前消息写入成功。</p><p>从这个配置也可以看出，Bookkeeper 是多副本写入模型，适当的降低 QW 和 QA 的数量可以提高写入吞吐率。</p><p>大部分场景下 Bookkeeper 有三个节点然后 E&#x2F;QW&#x2F;QA 都配置为 2 就可以满足消息多副本写入了。</p><blockquote><p>多副本可以保证当某个节点宕机后，这个节点的消息在其他节点依然有存放，消息读取不会出现问题。</p></blockquote><p>那什么情况下需要扩容 Bookkeeper 了，当然如果单个 Bookkeeper 的负载较高也是可以扩容的。</p><p>但我们当时扩容 Bookkeeper 的场景是想利用 Pulsar 的资源隔离功能。</p><p>因为有部分业务的消息量明显比高于其他的 topic，这样会导致某个 Broker 的负载较高，同时也可能影响到其他正常的 topic。</p><p>最好的方式就将这部分数据用单独的 broker 和 Bookkeeper 来承载，从而实现硬件资源的隔离。</p><p>这样的需求如果使用其他消息队列往往不太好实现，到后来可能就会部署多个集群来实现隔离，但这样也会增加运维的复杂度。</p><p>好在 Pulsar 天然就支持资源隔离，只需要一个集群就可以实现不同 namespace 的流量隔离。</p><p>此时就可以额外扩容几个 Bookkeeper 节点用于特定的 namespace 使用。<br><img src="https://s2.loli.net/2024/02/27/qA89EUDHpxNmK7O.png"></p><p>从上图可以看到：我们可以将 broker 和 Bookkeeper 分别进行分组，然后再配置对应的 namespace，这样就能实现资源隔离了。</p><blockquote><p>更多关于资源隔离的细节本文就不过多赘述了。</p></blockquote><p>铺垫了这么多，其实 Bookkeeper 的扩容也蛮简单的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bookkeeper:</span></span><br><span class="line">  <span class="attr">component:</span> <span class="string">bookie</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="comment"># requests:</span></span><br><span class="line">    <span class="comment"># memory: 4Gi</span></span><br><span class="line">    <span class="comment"># cpu: 2</span></span><br><span class="line">  <span class="attr">replicaCount:</span> <span class="number">3</span><span class="string">-&gt;5</span></span><br></pre></td></tr></table></figure><p>和 broker 扩容类似，提高副本数量后，Pulsar 的元数据中心会感知到新的 Bookkeeper 节点加入，从而更新 broker 中的节点数据，这样就会根据我们配置的隔离策略分配流量。</p><h1 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h1><p>其实本文的重点在于缩容，特别是 Bookkeeper 的缩容，这部分内容我在互联网上很少看到有人提及。</p><h2 id="Broker-1"><a href="#Broker-1" class="headerlink" title="Broker"></a>Broker</h2><p>Broker 的缩容相对简单，因为存算分离的特点：broker 作为计算层是无状态的，并不承载任何的数据。</p><blockquote><p>其实是承载数据的，只是 Pulsar 会自动迁移数据，从而体感上觉得是无状态的。</p></blockquote><p>只是当一个 broker 下线后，它上面所绑定的 topic 会自动转移到其他在线的 broker 中。</p><p>这个过程会导致连接了这个 broker 的 client 触发重连，从而短暂的影响业务。</p><blockquote><p>正因为 broker 的下线会导致 topic 的归属发生转移，所以在下线前最好是先通过监控面板观察需要下线的 broker topic 是否过多，如果过多则可以先手动 unload 一些数据，尽量避免一次性大批量的数据转移。</p></blockquote><p><img src="https://s2.loli.net/2024/02/27/1SzKpNiACdZIbrq.png" alt="image.png"></p><blockquote><p>观察各个broker 的 topic 数量</p></blockquote><h2 id="Bookkeeper-1"><a href="#Bookkeeper-1" class="headerlink" title="Bookkeeper"></a>Bookkeeper</h2><p>而 Bookkeeper 的缩容则没那么容易了，由于它是作为存储层，本身是有状态的，下线后节点上存储的数据是需要迁移到其他的 Bookkeeper 节点中的。</p><p>不然就无法满足之前提到的 Write quorum size (QW) 要求；因此缩容还有一个潜在条件需要满足：</p><p>缩容后的 Bookkeeper 节点数量需要大于broker 中的配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">managedLedgerDefaultEnsembleSize</span>: <span class="string">&quot;2&quot;  </span></span><br><span class="line"><span class="attr">managedLedgerDefaultWriteQuorum</span>: <span class="string">&quot;2&quot;  </span></span><br><span class="line"><span class="attr">managedLedgerDefaultAckQuorum</span>: <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure><p>不然写入会失败，整个集群将变得不可用。</p><p>Pulsar 提供了两种 Bookkeeper 的下线方案：</p><h3 id="不需要迁移数据"><a href="#不需要迁移数据" class="headerlink" title="不需要迁移数据"></a>不需要迁移数据</h3><p>其实两种方案主要区别在于是否需要迁移数据，第一种比较简单，就是不迁移数据的方案。</p><p>首先需要将 Bookkeeper 设置为 read-only 状态，此时该节点将不会接受写请求，直到这个 Bookkeeper 上的数据全部过期被回收后，我们就可以手动下线该节点。</p><p>使用 <code>forceReadOnlyBookie=true</code> 可以强制将 Bookkeeper 设置为只读。</p><p>但这个方案存在几个问题：</p><ul><li>下线时间不确定，如果该 <code>Bookkeeper</code> 上存储的数据生命周期较长，则无法预估什么时候可以下线该节点。</li><li>该配置修改后需要重启才能生效，在 kubernetes 环境中这些配置都是写在了 configmap 中，一旦刷新后所有节点都会读取到该配置，无法针对某一个节点生效；所以可能会出现将不该下线的节点设置为了只读状态。</li></ul><p>但该方案的好处是不需要迁移数据，人工介入的流程少，同样也就减少了出错的可能。</p><p>比较适合于用虚拟机部署的集群。</p><h3 id="迁移数据"><a href="#迁移数据" class="headerlink" title="迁移数据"></a>迁移数据</h3><p>第二种就是需要迁移数据的方案，更适用于 kubernetes 环境。</p><h4 id="迁移原理"><a href="#迁移原理" class="headerlink" title="迁移原理"></a>迁移原理</h4><p>先来看看迁移的原理：</p><ol><li>当 bookkeeper 停机后，AutoRecovery Auditor 会检测到 zookeeper 节点<code>/ledger/available</code> 发生变化，将下线节点的 ledger 信息写入到 zookeeper 的 <code>/ledgers/underreplicated</code> 节点中。</li><li>AutoRecovery ReplicationWorker 会检测 <code>/ledgers/underreplicated</code>节点信息，然后轮训这些 ledger 信息从其他在线的 BK 中复制数据到没有该数据的节点，保证 QW 数量不变。<ol><li>每复制一条数据后都会删除 <code>/ledgers/underreplicated</code> 节点信息。</li><li>所有 <code>/ledgers/underreplicated</code> 被删除后说明迁移任务完成。</li></ol></li><li>执行 <code>bin/bookkeeper shell decommissionbookie</code> 下线命令：<ol><li>会等待 <code>/ledgers/underreplicated</code> 全部删除</li><li> 然后删除 zookeeper 中的元数据</li><li>元数据删除后 bookkeeper 才是真正下线成功，此时 broker 才会感知到 Bookkeeper 下线。</li></ol></li></ol><p><code>AutoRecovery</code> 是 Bookkeeper 提供的一个自动恢复程序，他会在后台检测是否有数据需要迁移。</p><blockquote><p>简单来说就是当某个Bookkeeper 停机后，它上面所存储的 ledgerID 会被写入到元数据中心，此时会有一个单独的线程来扫描这些需要迁移的数据，最终将这些数据写入到其他在线的 Bookkeeper 节点。</p></blockquote><p>Bookkeeper 中的一些关键代码：<br><img src="https://s2.loli.net/2024/02/27/QqtYUBvadWpDmnR.png" alt="image.png"><br><img src="https://s2.loli.net/2024/02/27/gi9JLdMmYxunHTE.png" alt="image.png"></p><h4 id="下线步骤"><a href="#下线步骤" class="headerlink" title="下线步骤"></a>下线步骤</h4><p>下面来看具体的下线流程：</p><ol><li>副本数-1<ol><li><code>bin/bookkeeper shell listunderreplicated</code> 检测有多少 ledger 需要被迁移</li></ol></li><li>执行远程下线元数据<ol><li><code>nohup bin/bookkeeper shell decommissionbookie -bookieid bkid:3181 &gt; bk.log 2&gt;&amp;1 &amp;</code></li><li>这个命令会一直后台运行等待数据迁移完成，比较耗时</li></ol></li><li>查看下线节点是否已被剔除<ol><li><code>bin/bookkeeper shell listbookies -a</code></li></ol></li><li>循环第一步</li></ol><p>第一步是检测一些现在有多少数据需要迁移：<br><code>bin/bookkeeper shell listunderreplicated</code> 命令查看需要被迁移的 ledger 数据也是来自于 <code>/ledgers/underreplicated</code>节点<br><img src="https://s2.loli.net/2024/02/27/FiWJ8b27QD6w5E1.png" alt="image.png"></p><blockquote><p>正常情况下是 0</p></blockquote><p>第二步的命令会等待数据迁移完成后从 zookeeper 中删除节点信息，这个进程退出后表示下线成功。</p><p><img src="https://s2.loli.net/2024/02/27/TuK7FPXCm1fcgJS.png" alt="image.png"></p><blockquote><p>这个命令最好是后台执行，并输出日志到专门的文件，因为周期较长，很有可能终端会话已经超时了。</p></blockquote><p>我们登录 zookeeper 可以看到需要迁移的 ledger 数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/pulsar zookeeper-shell -server pulsar-zookeeper:2181</span><br><span class="line"></span><br><span class="line">get /ledgers/underreplication/ledgers/0000/0000/0000/0002/urL0000000002</span><br><span class="line">replica: &quot;pulsar-test-2-bookie-0.pulsar-test-2-bookie.pulsar-test-2.svc.cluster.local:3181&quot;</span><br><span class="line">ctime: 1708507296519</span><br></pre></td></tr></table></figure><p>underreplication 的节点路径中存放了 ledgerId，通过 ledgerId 计算路径：<br><img src="https://s2.loli.net/2024/02/27/bAx8nqeKQT7F4HV.png"><br><img src="https://s2.loli.net/2024/02/27/GiVlDP2M85pafAO.png"></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>下线过程中我们可以查看 <code>nohup bin/bookkeeper shell decommissionbookie -bookieid bkid:3181 &gt; bk.log 2&gt;&amp;1 &amp;</code>这个命令写入的日志来确认迁移的进度，日志中会打印当前还有多少数量的 ledger 没有迁移。</p><p>同时需要观察 zookeeper、Bookkeeper 的资源占用情况。</p><p>因为迁移过程中写入大量数据到 zookeeper 节点，同时迁移数时也会有大量流量写入 Bookkeeper。</p><p>不要让迁移过程影响到了正常的业务使用。</p><p>根据我的迁移经验来看，通常 2w 的ledger 数据需要 2～3 小时不等的时间，具体情况还得根据你的集群来确认。</p><h4 id="回滚方案"><a href="#回滚方案" class="headerlink" title="回滚方案"></a>回滚方案</h4><p>当然万一迁移比较耗时，或者影响了业务使用，所以还是要有一个回滚方案：</p><p>这里有一个大的前提：<br><strong>只要 BK 节点元数据、PVC（也就是磁盘中的数据） 没有被删除就可以进行回滚。</strong></p><p>所以只要上述的 decommissionbookie 命令没有完全执行完毕，我们就可以手动 kill 该进程，然后恢复副本数据。</p><p>这样恢复的 Bookkeeper 节点依然可以提供服务，同时数据也还存在；只是浪费了一些 autorecovery 的资源。</p><p>最后当 bookkeeper 成功下线后，我们需要删除 PVC，不然如果今后需要扩容的时候是无法启动 bookkeeper 的，因为在启动过程中会判断挂载的磁盘是否有数据。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说 Pulsar 的扩缩容还是非常简单的，只是对于有状态节点的数据迁移稍微复杂一些，但只要跟着流程走就不会有什么问题。</p><p>参考链接：</p><ul><li><a href="https://pulsar.apache.org/docs/next/administration-isolation/">https://pulsar.apache.org/docs/next/administration-isolation/</a></li><li><a href="https://bookkeeper.apache.org/docs/4.13.0/admin/decomission">https://bookkeeper.apache.org/docs/4.13.0/admin/decomission</a></li><li><a href="https://bookkeeper.apache.org/docs/4.13.0/admin/autorecovery">https://bookkeeper.apache.org/docs/4.13.0/admin/autorecovery</a></li></ul><p>#Blog #Pulsar </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在整个大环境的降本增效的熏陶下，我们也不得不做好应对方案。&lt;/p&gt;
&lt;p&gt;根据对线上流量、存储以及系统资源的占用，发现我们的 Pulsar 集群有许多的冗余，所以考虑进行缩容从而减少资源浪费，最终也能省一些费用。&lt;/p&gt;
&lt;p&gt;不过在缩容之前很有必要先聊聊扩容，Pulsar 一开始就是存算分离的架构（更多关于 Pulsar 架构的内容本文不做过多介绍，感兴趣的可以自行搜索），天然就非常适合 kubernetes 环境，也可以利用 &lt;code&gt;kubernetes&lt;/code&gt; 的能力进行快速扩容。&lt;/p&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    <category term="OB" scheme="http://crossoverjie.top/categories/Pulsar/OB/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
</feed>
