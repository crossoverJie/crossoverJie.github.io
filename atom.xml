<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverJie&#39;s Blog</title>
  
  <subtitle>baller</subtitle>
  <link href="http://crossoverjie.top/atom.xml" rel="self"/>
  
  <link href="http://crossoverjie.top/"/>
  <updated>2024-08-27T14:32:45.513Z</updated>
  <id>http://crossoverjie.top/</id>
  
  <author>
    <name>crossoverJie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenTelemetry 实战：从零实现应用指标监控</title>
    <link href="http://crossoverjie.top/2024/08/27/ob/OpenTelemetry-02-metrics/"/>
    <id>http://crossoverjie.top/2024/08/27/ob/OpenTelemetry-02-metrics/</id>
    <published>2024-08-27T06:53:35.000Z</published>
    <updated>2024-08-27T14:32:45.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇文章：<a href="https://juejin.cn/post/7391744486979076146">OpenTelemetry 实战：从零实现分布式链路追踪</a>讲解了链路相关的实战，本次我们继续跟进如何使用 OpenTelemetry 集成 metrics 监控。</p><blockquote><p>建议对指标监控不太熟的朋友可以先查看这篇前菜文章：<a href="https://crossoverjie.top/2024/06/13/ob/OpenTelemetry-metrics-concept/">从 Prometheus 到 OpenTelemetry：指标监控的演进与实践</a></p></blockquote><span id="more"></span><table><thead><tr><th>名称</th><th>作用</th><th>语言</th><th>版本</th></tr></thead><tbody><tr><td>java-demo</td><td>发送 gRPC 请求的客户端</td><td>Java</td><td>opentelemetry-agent: 2.4.0&#x2F;SpringBoot: 2.7.14</td></tr><tr><td><a href="https://github.com/crossoverJie/k8s-combat">k8s-combat</a></td><td>提供 gRPC 服务的服务端</td><td>Golang</td><td>go.opentelemetry.io&#x2F;otel: 1.28&#x2F; Go: 1.22</td></tr><tr><td><a href="https://www.jaegertracing.io/">Jaeger</a></td><td>trace 存储的服务端以及 TraceUI 展示</td><td>Golang</td><td>jaegertracing&#x2F;all-in-one:1.56</td></tr><tr><td><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib">opentelemetry-collector-contrib</a></td><td>OpenTelemetry 的 collector 服务端，用于收集 trace&#x2F;metrics&#x2F;logs 然后写入到远端存储</td><td>Golang</td><td>otel&#x2F;opentelemetry-collector-contrib:0.98.0</td></tr><tr><td><a href="https://prometheus.io/">Prometheus</a></td><td>作为 metrics 的存储和展示组件，也可以用 <a href="https://github.com/VictoriaMetrics/VictoriaMetrics">VictoriaMetrics</a> 等兼容 Prometheus 的存储替代。</td><td>Golang</td><td>quay.io&#x2F;prometheus&#x2F;prometheus:v2.49.1</td></tr><tr><td><img src="https://s2.loli.net/2024/07/22/oUPjd4KlX7niBaI.png" alt="image.png"></td><td></td><td></td><td></td></tr></tbody></table><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>以上是加入 metrics 之后的流程图，在原有的基础上会新增一个 <code>Prometheus</code> 组件，collector 会将 metrics 指标数据通过远程的 remote write 的方式写入到 Prometheus 中。</p><p>Prometheus 为了能兼容 OpenTelemetry 写入过来的数据，需要开启相关<a href="https://prometheus.io/docs/prometheus/latest/feature_flags/#otlp-receiver">特性</a>才可以。</p><p>如果是 docker 启动的话需要传入相关参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run  -d -p 9292:9090 --name prometheus \</span><br><span class="line">-v /prometheus/prometheus.yml:/etc/prometheus/prometheus.yml \</span><br><span class="line">quay.io/prometheus/prometheus:v2.49.1 \</span><br><span class="line">--config.file=/etc/prometheus/prometheus.yml \</span><br><span class="line">--storage.tsdb.path=/prometheus \</span><br><span class="line">--web.console.libraries=/etc/prometheus/console_libraries \</span><br><span class="line">--web.console.templates=/etc/prometheus/consoles \</span><br><span class="line">--enable-feature=exemplar-storage \</span><br><span class="line">--enable-feature=otlp-write-receiver</span><br></pre></td></tr></table></figure><p><code>--enable-feature=otlp-write-receiver</code> 最主要的就是这个参数，用于开启接收 OTLP 格式的数据。</p><p>但使用这个 Push 特性就会丧失掉 Prometheus 的许多 Pull 特性，比如服务发现，定时抓取等，不过也还好，Push 和 Pull 可以同时使用，原本使用 Pull 抓取的组件依然不受影响。</p><h2 id="修改-OpenTelemetry-Collector"><a href="#修改-OpenTelemetry-Collector" class="headerlink" title="修改 OpenTelemetry-Collector"></a>修改 OpenTelemetry-Collector</h2><p>接着我们需要修改下 Collector 的配置:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">exporters:</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">&quot;jaeger:4317&quot;</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">otlphttp/prometheus:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">http://prometheus:9292/api/v1/otlp</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">insecure:</span> <span class="literal">true</span>      </span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="attr">batch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">pipelines:</span></span><br><span class="line">    <span class="attr">traces:</span></span><br><span class="line">      <span class="attr">receivers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlp</span></span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">debug</span>        </span><br><span class="line">    <span class="attr">metrics:</span></span><br><span class="line">      <span class="attr">exporters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlphttp/prometheus</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">debug</span></span><br><span class="line">      <span class="attr">processors:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">batch</span></span><br><span class="line">      <span class="attr">receivers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlp</span></span><br></pre></td></tr></table></figure><p>这里我们在 <code>exporter</code> 中新增了一个 <code>otlphttp/prometheus</code> 的节点，用于指定导出 <code>prometheus</code> 的 <code>endpoint</code> 地址。</p><p>同时我们还需要在 <code>server.metrics.exporters</code> 中配置相同的 key: <code>otlphttp/prometheus</code>。</p><p>需要注意的是这里我们一定得是配置在 <code>metrics.exporters</code> 这个节点下，如果配置在 <code>traces.exporters</code> 下时，相当于是告诉 collector 讲 trace 的数据导出到 <code>otlphttp/prometheus.endpoint</code> 这个 endpoint 里了。</p><blockquote><p>所以重点是需要理解这里的配对关系。</p></blockquote><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p>这样我们只需要将应用启动之后就可以在 Prometheus 中查询到应用上报的指标了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.traces.exporter=otlp \</span><br><span class="line">-Dotel.metrics.exporter=otlp \</span><br><span class="line">-Dotel.logs.exporter=none \</span><br><span class="line">-Dotel.service.name=java-demo \</span><br><span class="line">-Dotel.exporter.otlp.protocol=grpc \</span><br><span class="line">-Dotel.propagators=tracecontext,baggage \</span><br><span class="line">-Dotel.exporter.otlp.endpoint=http://127.0.0.1:5317 -jar target/demo-0.0.1-SNAPSHOT.jar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run go app</span></span><br><span class="line">export OTEL_EXPORTER_OTLP_ENDPOINT=http://127.0.0.1:5317 OTEL_RESOURCE_ATTRIBUTES=service.name=k8s-combat</span><br><span class="line">./k8s-combat</span><br></pre></td></tr></table></figure><p>因为我们在 collector 中开启了 Debug 的 exporter，所以可以看到以下日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024-07-22T06:34:08.060ZinfoMetricsExporter&#123;&quot;kind&quot;: &quot;exporter&quot;, &quot;data_type&quot;: &quot;metrics&quot;, &quot;name&quot;: &quot;debug&quot;, &quot;resource metrics&quot;: 1, &quot;metrics&quot;: 18, &quot;data points&quot;: 44&#125;</span><br></pre></td></tr></table></figure><p>此时是可以说明指标上传成功的。</p><p>然后我们打开 <code>Prometheus</code> 的地址：<a href="http://127.0.0.1:9292/graph">http://127.0.0.1:9292/graph</a><br>便可以查询到 Java 应用和 Go 应用上报的指标。<br><img src="https://s2.loli.net/2024/07/22/O4TuE5WlFJ8Gyk1.png"></p><blockquote><p>OpenTelemetry 的 javaagent 会自动上报 JVM 相关的指标。</p></blockquote><hr><p>而在 Go 程序中我们还是需要显式的配置一些埋点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMeterProvider</span><span class="params">()</span></span> *sdkmetric.MeterProvider &#123;  </span><br><span class="line">    ctx := context.Background()  </span><br><span class="line">  </span><br><span class="line">    exporter, err := otlpmetricgrpc.New(ctx)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Printf(<span class="string">&quot;new otlp metric grpc exporter failed: %v&quot;</span>, err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    mp := sdkmetric.NewMeterProvider(  </span><br><span class="line">       sdkmetric.WithReader(sdkmetric.NewPeriodicReader(exporter)),  </span><br><span class="line">       sdkmetric.WithResource(initResource()),  </span><br><span class="line">    )    otel.SetMeterProvider(mp)  </span><br><span class="line">    <span class="keyword">return</span> mp  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mp := initMeterProvider()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := mp.Shutdown(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error shutting down meter provider: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>和 Tracer 类似，我们首先也得在 main 函数中调用 <code>initMeterProvider()</code> 函数来初始化 Meter，此时它会返回一个 <code>sdkmetric.MeterProvider</code> 对象。</p><p>OpenTelemetry Go 的 SDK 中已经提供了对 go runtime 的自动埋点，我们只需要调用相关函数即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := runtime.Start(runtime.WithMinimumReadMemStatsInterval(time.Second))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们启动应用，在 Prometheus 中就可以看到  Go  应用上报的相关指标了。<br><img src="https://s2.loli.net/2024/07/21/FAHrsZ5ap6SWNU7.png" alt="image.png"><br><img src="https://s2.loli.net/2024/07/22/pxWu4UREZ5PXng1.png"></p><blockquote><p>runtime_uptime_milliseconds_total  Go 的运行时指标</p></blockquote><p><code>Prometheus</code> 中展示指标的 UI 能力有限，通常我们都是配合 <code>grafana</code> 进行展示的。<br><img src="https://s2.loli.net/2024/07/22/A7HNl1zbfeI4JuR.png" alt="image.png"></p><h2 id="手动上报指标"><a href="#手动上报指标" class="headerlink" title="手动上报指标"></a>手动上报指标</h2><p>当然除了 SDK 自动上报的指标之外，我们也可以类似于 trace 那样手动上报一些指标；</p><p>比如我就想记录某个函数调用的次数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> meter =  otel.Meter(<span class="string">&quot;test.io/k8s/combat&quot;</span>)  </span><br><span class="line">apiCounter, err = meter.Int64Counter(  </span><br><span class="line">    <span class="string">&quot;api.counter&quot;</span>,  </span><br><span class="line">    metric.WithDescription(<span class="string">&quot;Number of API calls.&quot;</span>),  </span><br><span class="line">    metric.WithUnit(<span class="string">&quot;&#123;call&#125;&quot;</span>),  </span><br><span class="line">)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    log.Err(err)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, <span class="type">error</span>) &#123;  </span><br><span class="line">    <span class="keyword">defer</span> apiCounter.Add(ctx, <span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: fmt.Sprintf(<span class="string">&quot;hostname:%s, in:%s, md:%v&quot;</span>, name, in.Name, md)&#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要创建一个 <code>Int64Counter</code> 类型的指标，然后在需要埋点处调用它的函数 <code>apiCounter.Add(ctx, 1)</code> 即可。</p><p><img src="https://s2.loli.net/2024/07/21/cSwCa4U7WuoJ82n.png" alt="image.png"><br>之后便可以在 <code>Prometheus</code> 中查到这个指标了。</p><p>除此之外 OpenTelemetry 中的 metrics 定义和 Prometheus 也是类似的，还有以下几种类型：</p><ul><li><strong>Counter</strong>：单调递增计数器，比如可以用来记录订单数、总的请求数。</li><li><strong>UpDownCounter</strong>：与 Counter 类似，只不过它可以递减。</li><li><strong>Gauge</strong>：用于记录随时在变化的值，比如内存使用量、CPU 使用量等。</li><li><strong>Histogram</strong>：通常用于记录请求延迟、响应时间等。</li></ul><p>在 Java 中也提供有类似的 API 可以完成自定义指标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">messageInCounter = meter    </span><br><span class="line">        .counterBuilder(MESSAGE_IN_COUNTER)    </span><br><span class="line">        .setUnit(<span class="string">&quot;&#123;message&#125;&quot;</span>)    </span><br><span class="line">        .setDescription(<span class="string">&quot;The total number of messages received for this topic.&quot;</span>)    </span><br><span class="line">        .buildObserver();</span><br></pre></td></tr></table></figure><p>对于 Gauge 类型的数据用法如下，使用 <code>buildWithCallback</code> 回调函数上报数据，<code>OpenTelemetry</code> 会在框架层面每 30s 回调一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerObservers</span><span class="params">()</span> &#123;      </span><br><span class="line">    <span class="type">Meter</span> <span class="variable">meter</span> <span class="operator">=</span> MetricsRegistration.getMeter();      </span><br><span class="line">      </span><br><span class="line">    meter.gaugeBuilder(<span class="string">&quot;pulsar_producer_num_msg_send&quot;</span>)      </span><br><span class="line">            .setDescription(<span class="string">&quot;The number of messages published in the last interval&quot;</span>)      </span><br><span class="line">            .ofLongs()      </span><br><span class="line">            .buildWithCallback(      </span><br><span class="line">                    r -&gt; recordProducerMetrics(r, ProducerStats::getNumMsgsSent));  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recordProducerMetrics</span><span class="params">(ObservableLongMeasurement observableLongMeasurement, Function&lt;ProducerStats, Long&gt; getter)</span> &#123;      </span><br><span class="line">    <span class="keyword">for</span> (Producer producer : CollectionHelper.PRODUCER_COLLECTION.list()) &#123;      </span><br><span class="line">        <span class="type">ProducerStats</span> <span class="variable">stats</span> <span class="operator">=</span> producer.getStats();      </span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> producer.getTopic();      </span><br><span class="line">        <span class="keyword">if</span> (topic.endsWith(RetryMessageUtil.RETRY_GROUP_TOPIC_SUFFIX)) &#123;      </span><br><span class="line">            <span class="keyword">continue</span>;      </span><br><span class="line">        &#125;        observableLongMeasurement.record(getter.apply(stats),      </span><br><span class="line">                Attributes.of(PRODUCER_NAME, producer.getProducerName(), TOPIC, topic));      </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>更多具体用法可以参考官方文档链接：<br><a href="https://opentelemetry.io/docs/languages/java/instrumentation/#metrics">https://opentelemetry.io/docs/languages/java/instrumentation/#metrics</a></p><p>如果我们不想将数据通过 collector 而是直接上报到 Prometheus 中，使用 OpenTelemetry 框架也是可以实现的。</p><p>我们只需要配置下环境变量:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export OTEL_METRICS_EXPORTER=prometheus</span><br></pre></td></tr></table></figure><p>这样我们就可以访问 <a href="http://127.0.0.1:9464/metrics">http://127.0.0.1:9464/metrics</a> 获取到当前应用暴露出来的指标，此时就可以在 <code>Prometheus</code> 里配置好采集 job 来获取数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&quot;k8s-combat&quot;</span></span><br><span class="line">    <span class="comment"># metrics_path defaults to &#x27;/metrics&#x27;</span></span><br><span class="line">    <span class="comment"># scheme defaults to &#x27;http&#x27;.</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&quot;k8s-combat:9464&quot;</span>]   </span><br></pre></td></tr></table></figure><p>这就是典型的 Pull 模型，而 OpenTelemetry 推荐使用的是 Push 模型，数据由 OpenTelemetry 进行采集然后推送到 Prometheus。</p><p>这两种模式各有好处：</p><table><thead><tr><th></th><th>Pull模型</th><th>Push 模型</th></tr></thead><tbody><tr><td>优点</td><td>可以在一个集中的配置里管理所有的抓取端点，也可以为每一个应用单独配置抓取频次等数据。</td><td>在 OpenTelemetry 的 collector中可以集中对指标做预处理之后再将过滤后的数据写入 Prometheus，更加的灵活。</td></tr><tr><td>缺点</td><td>1. 预处理指标比较麻烦，所有的数据是到了 Prometheus 后再经过relabel处理后再写入存储。<br>2. 需要配置服务发现</td><td>1. 额外需要维护一个类似于 collector 这样的指标网关的组件</td></tr></tbody></table><p>比如我们是用和 Prometheus 兼容的 VictoriaMetrics 采集了 istio 的相关指标，但里面的指标太多了，我们需要删除掉一部分。</p><p>就需要在采集任务里编写规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">operator.victoriametrics.com/v1beta1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">VMPodScrape</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">isito-pod-scrape</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">podMetricsEndpoints:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">scheme:</span> <span class="string">http</span>  </span><br><span class="line">      <span class="attr">scrape_interval:</span> <span class="string">&quot;30s&quot;</span>  </span><br><span class="line">      <span class="attr">scrapeTimeout:</span> <span class="string">&quot;30s&quot;</span>  </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/stats/prometheus</span>  </span><br><span class="line">      <span class="attr">metricRelabelConfigs:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">regex:</span> <span class="string">^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum|istio_request_bytes_count|istio_response_bytes_sum|istio_request_bytes_sum|istio_request_duration_milliseconds_sum|istio_response_bytes_count|istio_request_duration_milliseconds_count|^ostrich_apigateway.*|istio_request_messages_total|istio_response_messages_total</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">drop_metrics</span>  </span><br><span class="line">  <span class="attr">namespaceSelector:</span>  </span><br><span class="line">    <span class="attr">any:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>换成在 collector 中处理后，这些逻辑都可以全部移动到 collector 中集中处理。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>metrics 的使用相对于 trace 更简单一些，不需要理解复杂的 context、span 等概念，只需要搞清楚有哪几种 metrics 类型，分别应用在哪些不同的场景即可。</p><p>参考链接：</p><ul><li><a href="https://prometheus.io/docs/prometheus/latest/feature_flags/#otlp-receiver">https://prometheus.io/docs/prometheus/latest/feature_flags/#otlp-receiver</a></li><li><a href="https://opentelemetry.io/docs/languages/java/instrumentation/#metrics">https://opentelemetry.io/docs/languages/java/instrumentation/#metrics</a></li><li><a href="https://opentelemetry.io/docs/languages/go/instrumentation/#metrics">https://opentelemetry.io/docs/languages/go/instrumentation/#metrics</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇文章：&lt;a href=&quot;https://juejin.cn/post/7391744486979076146&quot;&gt;OpenTelemetry 实战：从零实现分布式链路追踪&lt;/a&gt;讲解了链路相关的实战，本次我们继续跟进如何使用 OpenTelemetry 集成 metrics 监控。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;建议对指标监控不太熟的朋友可以先查看这篇前菜文章：&lt;a href=&quot;https://crossoverjie.top/2024/06/13/ob/OpenTelemetry-metrics-concept/&quot;&gt;从 Prometheus 到 OpenTelemetry：指标监控的演进与实践&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>OpenTelemetry 实战：从零实现分布式链路追踪</title>
    <link href="http://crossoverjie.top/2024/08/20/ob/OpenTelemetry-01-trace/"/>
    <id>http://crossoverjie.top/2024/08/20/ob/OpenTelemetry-01-trace/</id>
    <published>2024-08-20T06:53:35.000Z</published>
    <updated>2024-08-20T06:35:59.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前写过一篇 <a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅</a>的文章，主要是从概念上讲解了 Trace 在 OpenTelemetry 的中的场景和使用。</p><p>也写过一篇 <a href="https://crossoverjie.top/2024/05/26/ob/OTel-demo/">实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术</a>：如何从一个 demo 开始集成 OpenTelemetry。</p><p>但还是有不少小伙伴反馈说无法快速上手（可能也是这个 demo 的项目比较多），于是我准备从 0 开始从真实的代码一步步带大家集成 <code>OpenTelemetry</code>，因为 OpenTelemetry 本身是跨多种语言的，所以也会以两种语言为（Java、Golang）主进行讲解。</p><blockquote><p>使用这两种语言主要是因为 Java 几乎全是自动埋点，而 Golang 因为语言特性，大部分都得硬编码埋点；覆盖到这两种场景后其他语言也是类似的，顶多只是 API 名称有些许区别。</p></blockquote><p>在这个过程中也会穿插一些 OpenTelemetry 的原理，希望整个过程下来大家可以在项目中实际运用起来，同时也能知其所以然。</p><span id="more"></span><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>在这个过程中会涉及到以下项目：</p><table><thead><tr><th>名称</th><th>作用</th><th>语言</th><th>版本</th></tr></thead><tbody><tr><td>java-demo</td><td>发送 gRPC 请求的客户端</td><td>Java</td><td>opentelemetry-agent: 2.4.0&#x2F;SpringBoot: 2.7.14</td></tr><tr><td>k8s-combat</td><td>提供 gRPC 服务的服务端</td><td>Golang</td><td>go.opentelemetry.io&#x2F;otel: 1.28&#x2F; Go: 1.22</td></tr><tr><td>Jaeger</td><td>trace 存储的服务端以及 TraceUI 展示</td><td>Golang</td><td>jaegertracing&#x2F;all-in-one:1.56</td></tr><tr><td>opentelemetry-collector-contrib</td><td>OpenTelemetry 的 collector 服务端，用于收集 trace&#x2F;metrics&#x2F;logs 然后写入到远端存储</td><td>Golang</td><td>otel&#x2F;opentelemetry-collector-contrib:0.98.0</td></tr></tbody></table><p><img src="https://s2.loli.net/2024/07/15/u4BYXOkztqyUoEK.png" alt="image.png"></p><p>在开始之前我们先看看实际的效果，我们需要先把 collector 和 Jaeger 部署好：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -d --name jaeger \</span><br><span class="line">  -e COLLECTOR_ZIPKIN_HOST_PORT=:9411 \</span><br><span class="line">  -p 6831:6831/udp \</span><br><span class="line">  -p 6832:6832/udp \</span><br><span class="line">  -p 5778:5778 \</span><br><span class="line">  -p 16686:16686 \</span><br><span class="line">  -p 4317:4317 \</span><br><span class="line">  -p 4318:4318 \</span><br><span class="line">  -p 14250:14250 \</span><br><span class="line">  -p 14268:14268 \</span><br><span class="line">  -p 14269:14269 \</span><br><span class="line">  -p 9411:9411 \</span><br><span class="line">  jaegertracing/all-in-one:1.56</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run --rm -d -v $(pwd)/coll-config.yaml:/etc/otelcol-contrib/config.yaml --name coll \</span><br><span class="line">-p 5318:4318 \</span><br><span class="line">-p 5317:4317 \</span><br><span class="line">otel/opentelemetry-collector-contrib:0.98.0</span><br></pre></td></tr></table></figure><p>这里有一个 <code>coll-config</code> 的配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">receivers:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">protocols:</span></span><br><span class="line">      <span class="attr">grpc:</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line"><span class="attr">exporters:</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">&quot;127.0.0.1:4317&quot;</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="attr">batch:</span></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">pipelines:</span></span><br><span class="line">    <span class="attr">traces:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">otlp</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">otlp</span>, <span class="string">debug</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重点是这里的 <code>endpoint: &quot;127.0.0.1:4317&quot;</code> 我们需要配置位 Jaeger 的 IP 和端口。</p><blockquote><p>更多关于这里的配置会在后续单独的 collector 章节中讲解。</p></blockquote><p>这两个服务都启动成功后再启动我们的 Java 客户端和  Go  服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.traces.exporter=otlp \</span><br><span class="line">-Dotel.metrics.exporter=otlp \</span><br><span class="line">-Dotel.logs.exporter=none \</span><br><span class="line">-Dotel.service.name=demo \</span><br><span class="line">-Dotel.exporter.otlp.protocol=grpc \</span><br><span class="line">-Dotel.propagators=tracecontext,baggage \</span><br><span class="line">-Dotel.exporter.otlp.endpoint=http://127.0.0.1:5317 \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Golang</span></span><br><span class="line">export OTEL_EXPORTER_OTLP_ENDPOINT=http://127.0.0.1:5317</span><br><span class="line">export OTEL_RESOURCE_ATTRIBUTES=service.name=k8s-combat</span><br><span class="line">./k8s-combat</span><br></pre></td></tr></table></figure><p>可以看到不管是 Java 还是 Golang 应用都是需要配置 <code>OTEL_EXPORTER_OTLP_ENDPOINT</code> 参数，也就是 <code>opentelemetry-collector-contrib</code> 的地址。</p><blockquote><p>其余的一些配置在后面会讲到。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:9191/request\?name\=1232</span><br></pre></td></tr></table></figure><p>然后我们触发一下 Java 客户端的入口，就可以在 JaegerUI 中查询到刚才的链路了。<br><code>http://localhost:16686/search</code></p><p><img src="https://s2.loli.net/2024/07/15/skNmSDJaPfHh3GB.png" alt="image.png"><br><img src="https://s2.loli.net/2024/07/15/xoG2finOmFlDReE.png" alt="image.png"><br>这样整个 <code>trace</code> 链路就串起来了。</p><h1 id="Java-应用"><a href="#Java-应用" class="headerlink" title="Java 应用"></a>Java 应用</h1><p>下面来看看具体的应用代码里是如何编写的。</p><blockquote><p>Java 是基于 springboot 编写的，具体 springboot 的使用就不再赘述了。</p></blockquote><p>因为我们应用是使用 gRPC 通信的，所以需要提供一个 <code>helloworld.proto</code> 的 pb 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;  </span><br><span class="line">  </span><br><span class="line">option go_package = &quot;google.golang.org/grpc/examples/helloworld/helloworld&quot;;  </span><br><span class="line">option java_multiple_files = true;  </span><br><span class="line">option java_package = &quot;io.grpc.examples.helloworld&quot;;  </span><br><span class="line">option java_outer_classname = &quot;HelloWorldProto&quot;;  </span><br><span class="line">  </span><br><span class="line">package helloworld;  </span><br><span class="line">  </span><br><span class="line">// The greeting service definition.  </span><br><span class="line">service Greeter &#123;  </span><br><span class="line">  // Sends a greeting  </span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// The request message containing the user&#x27;s name.  </span><br><span class="line">message HelloRequest &#123;  </span><br><span class="line">  string name = 1;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// The response message containing the greetings  </span><br><span class="line">message HelloReply &#123;  </span><br><span class="line">  string message = 1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件也没啥好说的，就定义了一个简单的 <code>SayHello</code> 接口。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.devh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-stub<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-protobuf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Java 中使用了 <code>grpc-spring-boot-starter</code> 这个库来处理 gRPC 的客户端和服务端请求。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">grpc:</span>  </span><br><span class="line">  <span class="attr">server:</span>  </span><br><span class="line">    <span class="attr">port:</span> <span class="number">9192</span>  </span><br><span class="line">  <span class="attr">client:</span>  </span><br><span class="line">    <span class="attr">greeter:</span>  </span><br><span class="line">      <span class="attr">address:</span> <span class="string">&#x27;static://127.0.0.1:50051&#x27;</span>  </span><br><span class="line">      <span class="attr">enableKeepAlive:</span> <span class="literal">true</span>  </span><br><span class="line">      <span class="attr">keepAliveWithoutCalls:</span> <span class="literal">true</span>  </span><br><span class="line">      <span class="attr">negotiationType:</span> <span class="string">plaintext</span></span><br></pre></td></tr></table></figure><p>然后我们定义了一个接口用于接收请求触发 <code>gRPC</code> 的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/request&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;  </span><br><span class="line">   log.info(<span class="string">&quot;request: &#123;&#125;&quot;</span>, request);    </span><br><span class="line">   <span class="type">HelloReply</span> <span class="variable">abc</span> <span class="operator">=</span> greeterStub.sayHello(io.grpc.examples.helloworld.HelloRequest.newBuilder().setName(request.getName()).build());   </span><br><span class="line">   <span class="keyword">return</span> abc.getMessage();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 应用的实现非常简单，和我们日常日常开发没有任何区别；唯一的区别就是在启动时需要加入一个 <code>javaagent</code>以及一些启动参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.traces.exporter=otlp \</span><br><span class="line">-Dotel.metrics.exporter=otlp \</span><br><span class="line">-Dotel.logs.exporter=none \</span><br><span class="line">-Dotel.service.name=demo \</span><br><span class="line">-Dotel.exporter.otlp.protocol=grpc \</span><br><span class="line">-Dotel.propagators=tracecontext,baggage \</span><br><span class="line">-Dotel.exporter.otlp.endpoint=http://127.0.0.1:5317 \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>下面来仔细看看这些参数</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar</td><td>这个没啥好说的，指定一个 javaagent</td></tr><tr><td>otel.traces.exporter</td><td>指定 trace 以什么格式传输（默认是这里的 <code>otlp</code>)；当然还有其他的值：<code>logging/jaeger/zipkin</code> 等，我们这里使用 otlp 会将数据传输到 collector 中。</td></tr><tr><td>otel.metrics.exporter</td><td>同上，只是指定的是 metrics 的传输方式，我们在之后讲解指标的时候会用到。</td></tr><tr><td>otel.service.name</td><td>定义在 trace 中的应用名称，springboot 会默认使用 <code>spring.application.name</code> 这个变量。</td></tr><tr><td>otel.exporter.otlp.protocol</td><td>指定传输协议；除了 grpc 之外还有 <code>http/protobuf</code>，当然我们也可以根据 trace 和 metrics 分开指定：<code>otel.exporter.otlp.traces.protocol/otel.exporter.otlp.metrics.protocol</code></td></tr><tr><td>otel.propagators</td><td>指定我们跨服务传播上下文的时候使用哪种格式，默认是 <a href="https://www.w3.org/TR/trace-context/">W3C Trace Context</a>,<a href="https://www.w3.org/TR/baggage/">baggage</a>，当然也有其他的- <code>&quot;b3&quot;</code>: <a href="https://github.com/openzipkin/b3-propagation#single-header">B3 Single</a>，- <code>&quot;xray&quot;</code>: <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader">AWS X-Ray</a>，<code>&quot;jaeger&quot;</code>: <a href="https://www.jaegertracing.io/docs/1.21/client-libraries/#propagation-format">Jaeger</a>等</td></tr><tr><td>otel.exporter.otlp.endpoint</td><td>指定 collector 的 endpoint</td></tr><tr><td>更多细节的参数大家可以在这里找到：</td><td></td></tr><tr><td><a href="https://opentelemetry.io/docs/languages/java/configuration/">https://opentelemetry.io/docs/languages/java/configuration/</a></td><td></td></tr></tbody></table><h1 id="Golang-应用"><a href="#Golang-应用" class="headerlink" title="Golang 应用"></a>Golang 应用</h1><p>接着我们来看看 Go 是如何集成 <code>OpenTelemetry</code> 的。</p><p>在创建好项目之后我们需要添加 <code>OpenTelemetry</code> 所提供的包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go get &quot;go.opentelemetry.io/otel&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/propagation&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/sdk/metric&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/sdk/resource&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/sdk/trace&quot; \       &quot;go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc&quot;\</span><br></pre></td></tr></table></figure><p>然后我们需要创建一个初始化 <code>tracer</code> 的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initTracerProvider</span><span class="params">()</span></span> *sdktrace.TracerProvider &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">exporter, err := otlptracegrpc.New(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;new otlp trace grpc exporter failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">tp := sdktrace.NewTracerProvider(</span><br><span class="line">sdktrace.WithBatcher(exporter),</span><br><span class="line">sdktrace.WithResource(initResource()),</span><br><span class="line">)</span><br><span class="line">otel.SetTracerProvider(tp)</span><br><span class="line">otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext&#123;&#125;, propagation.Baggage&#123;&#125;))</span><br><span class="line"><span class="keyword">return</span> tp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们使用的是 <code>grpc</code> 协议上报 <code>otlp</code> 数据，所以这里使用的是 <code>exporter, err := otlptracegrpc.New(ctx)</code>  创建了一个 <code>exporter</code>。</p><p><code>otel.SetTextMapPropagator()</code> 这个函数里配置数据和刚才 Java 里配置的 <code>-Dotel.propagators=tracecontext,baggage</code> 是一样的效果。</p><p>与此同时我们还需要提供一个 <code>initResource()</code> 的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initResource</span><span class="params">()</span></span> *sdkresource.Resource &#123;</span><br><span class="line">initResourcesOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">extraResources, _ := sdkresource.New(</span><br><span class="line">context.Background(),</span><br><span class="line">sdkresource.WithOS(),</span><br><span class="line">sdkresource.WithProcess(),</span><br><span class="line">sdkresource.WithContainer(),</span><br><span class="line">sdkresource.WithHost(),</span><br><span class="line">)</span><br><span class="line">resource, _ = sdkresource.Merge(</span><br><span class="line">sdkresource.Default(),</span><br><span class="line">extraResources,</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数用来告诉 trace 需要暴露那些 resource，也就是我们在这里看到进程相关的属性：<br><img src="https://s2.loli.net/2024/07/15/Gveu4hNjWdYLiBo.png" alt="image.png"><br>比如这里的 <code>sdkresource.WithOS(),</code> 就会显示 OS 的类型和描述。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithOS</span><span class="params">()</span></span> Option &#123;  </span><br><span class="line">    <span class="keyword">return</span> WithDetectors(  </span><br><span class="line">       osTypeDetector&#123;&#125;,  </span><br><span class="line">       osDescriptionDetector&#123;&#125;,  </span><br><span class="line">    )&#125;</span><br></pre></td></tr></table></figure><p>而 <code>sdkresource.WithProcess(),</code> 显示的数据就更多了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithProcess</span><span class="params">()</span></span> Option &#123;  </span><br><span class="line">    <span class="keyword">return</span> WithDetectors(  </span><br><span class="line">       processPIDDetector&#123;&#125;,  </span><br><span class="line">       processExecutableNameDetector&#123;&#125;,  </span><br><span class="line">       processExecutablePathDetector&#123;&#125;,  </span><br><span class="line">       processCommandArgsDetector&#123;&#125;,  </span><br><span class="line">       processOwnerDetector&#123;&#125;,  </span><br><span class="line">       processRuntimeNameDetector&#123;&#125;,  </span><br><span class="line">       processRuntimeVersionDetector&#123;&#125;,  </span><br><span class="line">       processRuntimeDescriptionDetector&#123;&#125;,  </span><br><span class="line">    )&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上这些代码在 Java 中都是由 agent 指定创建的。</p></blockquote><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init OpenTelemetry start  </span></span><br><span class="line">tp := initTracerProvider()  </span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> err := tp.Shutdown(context.Background()); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Printf(<span class="string">&quot;Error shutting down tracer provider: %v&quot;</span>, err)  </span><br><span class="line">    &#125;&#125;()  </span><br><span class="line">   </span><br><span class="line">err := runtime.Start(runtime.WithMinimumReadMemStatsInterval(time.Second))  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    log.Err(err)  </span><br><span class="line">&#125;</span><br><span class="line">tracer = tp.Tracer(<span class="string">&quot;k8s-combat&quot;</span>)</span><br><span class="line"><span class="comment">// Init OpenTelemetry end</span></span><br></pre></td></tr></table></figure><p>之后我们需要在 main 函数一开始就初始化 <code>traceProvider</code>。</p><p>对于 <code>grpc</code> 来说，<code>OpenTelemetry</code> 的 Go-SDK 提供了自动埋点，但我们也得手动配置一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := grpc.NewServer(  </span><br><span class="line">    grpc.StatsHandler(otelgrpc.NewServerHandler()),  </span><br><span class="line">)  </span><br><span class="line">pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br></pre></td></tr></table></figure><p>使用 <code>grpc.StatsHandler(otelgrpc.NewServerHandler()),</code>  将 <code>OTel</code> 的 <code>serverHandle</code> 加入进去，这个 handle 会自动创建 <code>grpc</code> 服务端的 <code>span</code>。</p><blockquote><p>对 trace&#x2F;span 概念还有不了解的朋友可以查看这篇<a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">文章</a>。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> port = <span class="string">&quot;:50051&quot;</span>  </span><br><span class="line">lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    log.Fatal().Msgf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)  </span><br><span class="line">&#125;  </span><br><span class="line">s := grpc.NewServer(  </span><br><span class="line">    grpc.StatsHandler(otelgrpc.NewServerHandler()),  </span><br><span class="line">)  </span><br><span class="line">pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)  </span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    log.Fatal().Msgf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    log.Printf(<span class="string">&quot;served on %s \n&quot;</span>, port)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们只需要启动这个 grpc 服务即可，就算完成了 Go 服务的集成。</p><p>从这里可以看出 Java 相对于 Go 来说会简单许多，只需要配置一个 agent 就可以不该一行代码支持目前市面上流行的绝大多数框架。<br><img src="https://s2.loli.net/2024/04/17/kMDcrPwxJy4oZYe.png"></p><h1 id="自定义-span-的-attribute"><a href="#自定义-span-的-attribute" class="headerlink" title="自定义  span 的 attribute"></a>自定义  span 的 attribute</h1><p>我们在看链路信息的时候其实看的最多的是某个 <code>span</code> 里的 <code>attribute</code> 数据（有些地方又称为 <code>tag</code>)<br>如下图所示：<br><img src="https://s2.loli.net/2024/07/15/jrdkNCAZhi6UIvP.png"></p><p>这里会展示当前 <code>span</code> 的各种信息，但如果我们想要额外加一些自己关心的数据应该如何添加呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message HelloRequest &#123;  </span><br><span class="line">  string name = 1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们想知道这个 grpc 接口里的 name 参数，如上图所示那样展示在 span 中。</p><p>好在 <code>OpenTelemetry</code> 已经考虑到类似的需求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">span := trace.SpanFromContext(ctx)  </span><br><span class="line">span.SetAttributes(attribute.String(<span class="string">&quot;request.name&quot;</span>, in.Name))</span><br></pre></td></tr></table></figure><p>我们使用 <code>span := trace.SpanFromContext(ctx)</code>  获取到当前的 span，然后调用 <code>SetAttributes</code> 就可以添加自定义的数据了。</p><blockquote><p>对应的 Java 也有类似的函数。</p></blockquote><p>除了新增 <code>attribute</code> 之外还可以新增 Event，Link 等数据，使用方式也是类似的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddEvent adds an event with the provided name and options.  </span></span><br><span class="line">AddEvent(name <span class="type">string</span>, options ...EventOption)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// AddLink adds a link.  </span></span><br><span class="line"><span class="comment">// Adding links at span creation using WithLinks is preferred to calling AddLink  </span></span><br><span class="line"><span class="comment">// later, for contexts that are available during span creation, because head  </span></span><br><span class="line"><span class="comment">// sampling decisions can only consider information present during span creation.  </span></span><br><span class="line">AddLink(link Link)</span><br></pre></td></tr></table></figure><h1 id="自定义新增-span"><a href="#自定义新增-span" class="headerlink" title="自定义新增 span"></a>自定义新增 span</h1><p>同理我们可能不局限于为某个 span 新增 attribute，也有可能想要新增一个新的 span 来记录关键的调用信息。</p><blockquote><p>默认情况下只有 OpenTelemetry 实现过的组件的核心函数才会有 span，自己代码里的函数调用是不会创建span 的。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> span(ctx context.Context) &#123;  </span><br><span class="line">    ctx, span := tracer.Start(ctx, <span class="string">&quot;hello-span&quot;</span>)  </span><br><span class="line">    <span class="keyword">defer</span> span.End()  </span><br><span class="line">    <span class="comment">// do some work  </span></span><br><span class="line">    log.Printf(<span class="string">&quot;create span&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在  Go 中只需要手动 Start 一个 span 即可。</p><p>对应到 <code>Java</code> 稍微简单一些，只需要为函数添加一个注解即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WithSpan(&quot;span&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">span</span><span class="params">(<span class="meta">@SpanAttribute(&quot;request.name&quot;)</span> String name)</span> &#123;  </span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);  </span><br><span class="line">    log.info(<span class="string">&quot;span:&#123;&#125;&quot;</span>, name);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过得单独引入一个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.opentelemetry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opentelemetry-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.opentelemetry.instrumentation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opentelemetry-instrumentation-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终我们在 Jaeger UI 上看到的效果如下：</p><p><img src="https://s2.loli.net/2024/07/15/1tLlYezQwInZWDX.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://s2.loli.net/2024/07/15/WXPp1MUkdHo4zam.png"></p><p>最后总结一下，OpenTelemetry 支持许多流行的语言，主要分为两类：是否支持自动埋点。</p><p><img src="https://s2.loli.net/2024/07/15/fvu67rdoxtZkq5m.png"></p><blockquote><p>这里 Go 也可以零代码埋点，是使用了 eBPF，本文暂不做介绍。</p></blockquote><p>对于支持自动埋点的语言就很简单，只需要配置下 agent 即可；而原生的 Go 语言不支持自动埋点就得手动使用 OpenTelemetry 提供的 SDK 处理一些关键步骤；总体来说也不算复杂。</p><p>下一期会重点讲解如何使用 Metrics。</p><p>感兴趣的朋友可以在这里查看 Go 相关的源码：</p><ul><li><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></li></ul><p>参考链接：</p><ul><li><a href="https://opentelemetry.io/docs/languages/java/configuration/">https://opentelemetry.io/docs/languages/java/configuration/</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md">https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md</a></li><li><a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前写过一篇 &lt;a href=&quot;https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/&quot;&gt;从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅&lt;/a&gt;的文章，主要是从概念上讲解了 Trace 在 OpenTelemetry 的中的场景和使用。&lt;/p&gt;
&lt;p&gt;也写过一篇 &lt;a href=&quot;https://crossoverjie.top/2024/05/26/ob/OTel-demo/&quot;&gt;实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术&lt;/a&gt;：如何从一个 demo 开始集成 OpenTelemetry。&lt;/p&gt;
&lt;p&gt;但还是有不少小伙伴反馈说无法快速上手（可能也是这个 demo 的项目比较多），于是我准备从 0 开始从真实的代码一步步带大家集成 &lt;code&gt;OpenTelemetry&lt;/code&gt;，因为 OpenTelemetry 本身是跨多种语言的，所以也会以两种语言为（Java、Golang）主进行讲解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用这两种语言主要是因为 Java 几乎全是自动埋点，而 Golang 因为语言特性，大部分都得硬编码埋点；覆盖到这两种场景后其他语言也是类似的，顶多只是 API 名称有些许区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这个过程中也会穿插一些 OpenTelemetry 的原理，希望整个过程下来大家可以在项目中实际运用起来，同时也能知其所以然。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>深入理解单元测试：技巧与最佳实践</title>
    <link href="http://crossoverjie.top/2024/08/15/ob/unit-test/"/>
    <id>http://crossoverjie.top/2024/08/15/ob/unit-test/</id>
    <published>2024-08-15T02:43:09.000Z</published>
    <updated>2024-08-14T13:55:07.855Z</updated>
    
    <content type="html"><![CDATA[<p>之前分享过如何快速上手开源项目以及如何在开源项目里做集成测试，但还没有讲过具体的实操。</p><p>今天来详细讲讲如何写单元测试。</p><h1 id="🤔什么情况下需要单元测试"><a href="#🤔什么情况下需要单元测试" class="headerlink" title="🤔什么情况下需要单元测试"></a>🤔什么情况下需要单元测试</h1><p>这个大家应该是有共识的，对于一些功能单一、核心逻辑、同时变化不频繁的公开函数才有必要做单元测试。</p><p>对于业务复杂、链路繁琐但也是核心流程的功能通常建议做 e2e 测试，这样可以保证最终测试结果的一致性。</p><span id="more"></span><h1 id="💀具体案例"><a href="#💀具体案例" class="headerlink" title="💀具体案例"></a>💀具体案例</h1><p>我们都知道单测的主要目的是模拟执行你写过的每一行代码，目的就是要覆盖到主要分支，做到自己的每一行代码都心中有数。</p><p>下面以 <code>Apache HertzBeat</code> 的一些单测为例，讲解如何编写一个单元测试。</p><p><img src="https://s2.loli.net/2024/07/02/SbqCvHVZk6f5tB1.png"><br>先以一个最简单的 <code>org.apache.hertzbeat.collector.collect.udp.UdpCollectImpl#preCheck</code> 函数测试为例。<br>这里的 <code>preCheck</code> 函数就是简单的检测做参数校验。<br>测试时只要我们手动将 <code>metrics</code> 设置为 <code>null</code> 就可以进入这个 if 条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UdpCollectImplTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> UdpCollectImpl udpCollect;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testPreCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; aliasField = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        aliasField.add(<span class="string">&quot;responseTime&quot;</span>);</span><br><span class="line">        <span class="type">Metrics</span> <span class="variable">metrics</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Metrics</span>();</span><br><span class="line">        metrics.setAliasFields(aliasField);</span><br><span class="line">        assertThrows(IllegalArgumentException.class, () -&gt; udpCollect.preCheck(metrics));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>来看具体的单测代码，我们一行行的来看：</p><p><code>@ExtendWith(MockitoExtension.class)</code> 是 <code>Junit5</code> 提供的一个注解，里面传入的 <code>MockitoExtension.class</code> 是我们单测 mock 常用的框架。</p><p>简单来说就是告诉 <code>Junit5</code> ，当前的测试类会使用 mockito 作为扩展运行，从而可以 <code>mock</code> 我们运行时的一些对象。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InjectMocks</span>  </span><br><span class="line"><span class="keyword">private</span> UdpCollectImpl udpCollect;</span><br></pre></td></tr></table></figure><p><code>@InjectMocks</code> 也是 <code>mockito</code> 这个库提供的注解，通常用于声明需要测试的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InjectMocks</span>  </span><br><span class="line"><span class="keyword">private</span> AbstractCollect udpCollect;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/02/zSocET9f5y6lqC3.png"></p><p>需要注意的是这个注解必须是一个具体的类，不可以是一个抽象类或者是接口。</p><p>其实当我们了解了他的原理就能知道具体的原因：<br><img src="https://s2.loli.net/2024/07/02/5DwRyVsBHd1EmpA.png"></p><p>当我们 debug 运行时会发现 <code>udpCollect</code> 对象是有值的，而如果我们去掉这个注解 <code>@InjectMocks</code> 再运行就会抛空指针异常。</p><blockquote><p>因为并没有初始化 udpCollect</p></blockquote><p>而使用 <code>@InjectMocks</code>注解后，<code>mockito</code> 框架会自动给 <code>udpCollect</code> 注入一个代理对象；而如果是一个接口或者是抽象类，mockito 框架是无法知道创建具体哪个对象。</p><p>当然在这个简单场景下，我们直接 <code>udpCollect = new UdpCollectImpl()</code> 进行测试也是可以的。</p><h1 id="🔥配合-jacoco-输出单测覆盖率"><a href="#🔥配合-jacoco-输出单测覆盖率" class="headerlink" title="🔥配合 jacoco 输出单测覆盖率"></a>🔥配合 jacoco 输出单测覆盖率</h1><p><img src="https://s2.loli.net/2024/07/02/fgv3O4RbnHsQTWV.png"><br><img src="https://s2.loli.net/2024/07/02/coXOGkjyE2zKsYa.png"></p><p>在 IDEA 中我们可以以 <code>Coverage</code> 的方式运行，<code>IDEA</code> 就将我们的单测覆盖情况显示在源代码中，绿色的部分就代表在实际在运行时执行到的地方。</p><p>我们也可以在 <code>maven</code> 项目中集成 <code>jacoco</code>，只需要添加一个根目录的 <code>pom.xml</code> 中添加一个 <code>plugin</code> 就可以了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jacoco<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jacoco-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jacoco-maven-plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>prepare-agent<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>report<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>test<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>report<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后运行 <code>mvn test</code> 就会在 target 目录下生成测试报告了。</p><p><img src="https://s2.loli.net/2024/07/02/GiBrPjtLcXhgDbp.png"></p><p>我们还可以在 GitHub 的 CI 中集成 <code>Codecov</code>，他会直接读取 jacoco 的测试数据，并且在 PR 的评论区加上测试报告。<br><img src="https://s2.loli.net/2024/07/02/ujdGke4gf5mAW3x.png"></p><p><img src="https://s2.loli.net/2024/07/02/nFt5SukAjMPZ96W.png"></p><p><img src="https://s2.loli.net/2024/07/02/KcXJUs3mehxFAYz.png"></p><p>需要从 <code>Codecov</code> 里将你项目的 token 添加到 repo 的 环境变量中即可。</p><p>具体可以参考这个 PR：<a href="https://github.com/apache/hertzbeat/pull/1985">https://github.com/apache/hertzbeat/pull/1985</a></p><h1 id="☀️复杂一点的单测"><a href="#☀️复杂一点的单测" class="headerlink" title="☀️复杂一点的单测"></a>☀️复杂一点的单测</h1><p>刚才展示的是一个非常简单的场景，下面来看看稍微复杂的。</p><p>我们以这个单测为例：<br><code>org.apache.hertzbeat.collector.collect.redis.RedisClusterCollectImplTest</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClusterCollectImplTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> RedisCommonCollectImpl redisClusterCollect;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> StatefulRedisClusterConnection&lt;String, String&gt; connection;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> RedisAdvancedClusterCommands&lt;String, String&gt; cmd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> RedisClusterClient client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个单测在刚才的基础上多了一个 <code>@Mock</code> 的注解。</p><p>这是因为我们需要测试的 <code>RedisCommonCollectImpl</code> 类中需要依赖 <code>StatefulRedisClusterConnection/RedisAdvancedClusterCommands/RedisClusterClient</code> 这几个类所提供的服务。</p><p>单测的时候需要使用 <code>mockito</code> 创建一个他们的对象，并且注入到需要被测试的 <code>RedisCommonCollectImpl</code>类中。</p><blockquote><p>不然我们就需要准备单测所需要的资源，比如可以使用的 Redis、MySQL 等。</p></blockquote><h2 id="🚤模拟行为"><a href="#🚤模拟行为" class="headerlink" title="🚤模拟行为"></a>🚤模拟行为</h2><p>只是注入进去还不够，我们还需要模拟它的行为：</p><ul><li>比如调用某个函数可以模拟返回数据</li><li>模拟函数调用抛出异常</li><li>模拟函数调用耗时</li></ul><p>这里以最常见的模拟函数返回为例：</p><p><img src="https://s2.loli.net/2024/07/02/3lnFxsQmcWqao5u.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">clusterNodes</span> <span class="operator">=</span> connection.sync().clusterInfo();</span><br></pre></td></tr></table></figure><p>在源码里看到会使用 connection 的 <code>clusterInfo()</code> 函数返回集群信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">clusterKnownNodes</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">clusterInfoTemp</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        cluster_slots_fail:0</span></span><br><span class="line"><span class="string">        cluster_known_nodes:%s</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">clusterInfo</span> <span class="operator">=</span> String.format(clusterInfoTemp, clusterKnownNodes);</span><br><span class="line">Mockito.when(cmd.clusterInfo()).thenReturn(clusterInfo);        </span><br></pre></td></tr></table></figure><p>此时我们就可以使用 <code>Mockito.when().thenReturn()</code> 来模拟这个函数的返回数据。</p><p>而其中的 <code>cmd</code> 自然也是需要模拟返回的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Mockito.mockStatic(RedisClusterClient.class).when(()-&gt;RedisClusterClient.create(Mockito.any(ClientResources.class),</span><br><span class="line">        Mockito.any(RedisURI.class))).thenReturn(client);</span><br><span class="line">Mockito.when(client.connect()).thenReturn(connection);</span><br><span class="line"></span><br><span class="line">Mockito.when(connection.sync()).thenReturn(cmd);</span><br><span class="line">Mockito.when(cmd.info(metrics.getName())).thenReturn(info);</span><br><span class="line">Mockito.when(cmd.clusterInfo()).thenReturn(clusterInfo);</span><br></pre></td></tr></table></figure><p><code>cmd</code> 是通过 <code>Mockito.when(connection.sync()).thenReturn(cmd);</code>返回的，而 <code>connection</code> 又是从 <code>client.connect()</code> 返回的。</p><p>最终就像是套娃一样，<code>client</code> 在源码中是通过一个静态函数创建的。</p><h3 id="⚡模拟静态函数"><a href="#⚡模拟静态函数" class="headerlink" title="⚡模拟静态函数"></a>⚡模拟静态函数</h3><p>我依稀记得在我刚接触 <code>mockito</code> 的 16～17 年那段时间还不支持模拟调用静态函数，不过如今已经支持了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mock</span>  </span><br><span class="line"><span class="keyword">private</span> RedisClusterClient client;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mockito.mockStatic(RedisClusterClient.class).when(()-&gt;RedisClusterClient.create(Mockito.any(ClientResources.class),  </span><br><span class="line">        Mockito.any(RedisURI.class))).thenReturn(client);</span><br></pre></td></tr></table></figure><p>这样就可以模拟静态函数的返回值了，但前提是返回的 <code>client</code> 需要使用 <code>@Mock</code> 注解。</p><h3 id="💥模拟构造函数"><a href="#💥模拟构造函数" class="headerlink" title="💥模拟构造函数"></a>💥模拟构造函数</h3><p><img src="https://s2.loli.net/2024/07/02/aFiCLRyYh4IU83o.png"><br>有时候我们也需要模拟构造函数，从而可以模拟后续这个对象的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MockedConstruction&lt;FTPClient&gt; mocked = Mockito.mockConstruction(FTPClient.class,</span><br><span class="line">        (ftpClient, context) -&gt; &#123;</span><br><span class="line">            Mockito.doNothing().when(ftpClient).connect(ftpProtocol.getHost(),</span><br><span class="line">                    Integer.parseInt(ftpProtocol.getPort()));</span><br><span class="line"></span><br><span class="line">            Mockito.doAnswer(invocationOnMock -&gt; <span class="literal">true</span>).when(ftpClient)</span><br><span class="line">                    .login(ftpProtocol.getUsername(), ftpProtocol.getPassword());</span><br><span class="line">            Mockito.when(ftpClient.changeWorkingDirectory(ftpProtocol.getDirection())).thenReturn(isActive);</span><br><span class="line">            Mockito.doNothing().when(ftpClient).disconnect();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>可以使用 <code>Mockito.mockConstruction</code> 来进行模拟，该对象的一些行为就直接写在这个模拟函数内。</p><p>需要注意的是返回的 <code>mocked</code> 对象需要记得关闭。</p><h3 id="不需要-Mock"><a href="#不需要-Mock" class="headerlink" title="不需要 Mock"></a>不需要 Mock</h3><p>当然也不是所有的场景都需要 <code>mock</code>。</p><p>比如刚才第一个场景，没有依赖任何外部服务时就不需要 <code>mock</code>。</p><p><img src="https://s2.loli.net/2024/07/02/mW3gxERBc4qoz2L.png"></p><p>类似于这个 <a href="https://github.com/apache/hertzbeat/pull/2021">PR</a> 里的测试，只是依赖一个基础的内存缓存组件，就没必要 mock，但如果依赖的是 <code>Redis</code> 缓存组件还是需要 mock 的。<br><a href="https://github.com/apache/hertzbeat/pull/2021">https://github.com/apache/hertzbeat/pull/2021</a></p><h3 id="⚙️修改源码"><a href="#⚙️修改源码" class="headerlink" title="⚙️修改源码"></a>⚙️修改源码</h3><p>如果有些测试场景下需要获取内部变量方便后续的测试，但是该测试类也没有提供获取变量的函数，我们就只有修改源码来配合测试了。</p><p>比如这个 <a href="https://github.com/apache/hertzbeat/pull/">PR</a>：<br><img src="https://s2.loli.net/2024/07/02/bxfQgsymWVcnawE.png"></p><p>当然如果只是给测试环境下使用的函数或变量，我们可以加上 <code>@VisibleForTesting</code>注解标明一下，这个注解没有其他作用，可以让后续的维护者更清楚的知道这是做什么用的。</p><h1 id="📈集成测试"><a href="#📈集成测试" class="headerlink" title="📈集成测试"></a>📈集成测试</h1><p>单元测试只能测试一些功能单一的函数，要保证整个软件的质量仅依赖单测是不够的，我们还需要集成测试。</p><p>通常是需要对外提供服务的开源项目都需要集成测试：</p><ul><li>Pulsar</li><li>Kafka</li><li>Dubbo 等</li></ul><p>以我接触到的服务型应用主要分为两类：一个是 Java 应用一个是 Golang 应用。</p><h1 id="🐳Golang"><a href="#🐳Golang" class="headerlink" title="🐳Golang"></a>🐳Golang</h1><p><img src="https://s2.loli.net/2024/07/11/vZISu9Qg3foKhsU.png"></p><p><code>Golang</code> 因为工具链没有 Java 那么强大，所以大部分的集成测试的功能都是通过编写 Makefile 和 shell 脚本实现的。</p><p>还是以我熟悉的 Pulsar 的 <code>go-client</code> 为例，它在 GitHub 的集成测试是通过 GitHub action 触发的，定义如下：<br><img src="https://s2.loli.net/2024/05/20/f2196pujo8m7KRe.png"><br>最终调用的是 Makefile 中的 test 命令，并且把需要测试的 Golang 版本传入进去。</p><p><img src="https://s2.loli.net/2024/05/20/YpwtSHnLXqU1xQj.png"></p><p><code>Dockerfile</code>：<br><img src="https://s2.loli.net/2024/05/20/1ySGWF46U7EC2rk.png"></p><p>这个镜像简单来说就是将 Pulsar 的镜像作为基础运行镜像（这里面包含了 Pulsar 的服务端），然后将这个 pulsar-client-go 的代码复制进去编译。</p><p>接着运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /pulsar/pulsar-client-go &amp;&amp; ./scripts/run-ci.sh</span><br></pre></td></tr></table></figure><p>也就是测试脚本。</p><p><img src="https://s2.loli.net/2024/05/20/2Afmdu8ozRvH9FC.png"></p><p>测试脚本的逻辑也很简单：</p><ul><li>启动 pulsar 服务端</li><li>运行测试代码<br>因为所有的测试代码里连接服务端的地址都是 <code>localhost</code>，所以可以直接连接。<br><img src="https://s2.loli.net/2024/05/20/C1RHxTkuz25Mlj8.png"></li></ul><p>通过这里的 <a href="https://github.com/apache/pulsar-client-go/actions/runs/9014510238/job/24768797555">action</a> 日志可以跟踪所有的运行情况。</p><h1 id="☕Java"><a href="#☕Java" class="headerlink" title="☕Java"></a>☕Java</h1><p><img src="https://s2.loli.net/2024/07/11/KlqzSwJ6f895A4n.png"></p><p>Java 因为工具链强大，所以集成测试几乎不需要用 Makefile 和脚本配合执行。</p><p>还是以 Pulsar 为例，它的集成测试是需要模拟在本地启动一个服务端（因为 Pulsar 的服务端源码和测试代码都是 Java 写的，更方便做测试），然后再运行测试代码。</p><blockquote><p>这个的好处是任何一个单测都可以在本地直接运行，而  Go 的代码还需要先在本地启动一个服务端，测试起来比较麻烦。</p></blockquote><p>来看看它是如何实现的，我以其中一个 <a href="https://github.com/apache/pulsar/blob/631b13ad23d7e48c6e82d38f97c23d129062cb7c/pulsar-broker/src/test/java/org/apache/pulsar/client/impl/BrokerClientIntegrationTest.java#L117">BrokerClientIntegrationTest</a>为例：<br><img src="https://s2.loli.net/2024/05/20/9PbioA3RQLMBy6J.png"><br><img src="https://s2.loli.net/2024/05/20/blKePdxTUIkgRD3.png"><br>会在单测启动的时候先启动服务端。</p><p><img src="https://s2.loli.net/2024/05/20/gzY3lyTGuEDUwZF.png"></p><p>最终会调用 <code>PulsarTestContext</code> 的 <code>build</code> 函数启动 <code>broker</code>（服务端），而执行单测也只需要使用 <code>mvn test</code> 就可以自动触发这些单元测试。<br><img src="https://s2.loli.net/2024/05/20/N15amZihWI73Qyw.png"><br>只是每一个单测都需要启停服务端，所以要把 Pulsar 的所有单测跑完通常需要 1～2 个小时。</p><p>以上就是日常编写单测可能会碰到的场景，希望对大家有所帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前分享过如何快速上手开源项目以及如何在开源项目里做集成测试，但还没有讲过具体的实操。&lt;/p&gt;
&lt;p&gt;今天来详细讲讲如何写单元测试。&lt;/p&gt;
&lt;h1 id=&quot;🤔什么情况下需要单元测试&quot;&gt;&lt;a href=&quot;#🤔什么情况下需要单元测试&quot; class=&quot;headerlink&quot; title=&quot;🤔什么情况下需要单元测试&quot;&gt;&lt;/a&gt;🤔什么情况下需要单元测试&lt;/h1&gt;&lt;p&gt;这个大家应该是有共识的，对于一些功能单一、核心逻辑、同时变化不频繁的公开函数才有必要做单元测试。&lt;/p&gt;
&lt;p&gt;对于业务复杂、链路繁琐但也是核心流程的功能通常建议做 e2e 测试，这样可以保证最终测试结果的一致性。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="单测" scheme="http://crossoverjie.top/tags/%E5%8D%95%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>Pulsar升级自动化：一键搞定集群升级与测试</title>
    <link href="http://crossoverjie.top/2024/08/06/ob/Pulsar%20test%20framework/"/>
    <id>http://crossoverjie.top/2024/08/06/ob/Pulsar%20test%20framework/</id>
    <published>2024-08-06T03:15:50.000Z</published>
    <updated>2024-08-06T02:22:27.446Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/07/01/xZSMlpJPWTRGkge.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于我在公司内部负责维护 <code>Pulsar</code>，需要时不时的升级 <code>Pulsar</code> 版本从而和社区保持一致。</p><p>而每次升级过程都需要做相同的步骤：</p><ul><li>安装一个新版本的集群</li><li>触发功能性测试</li><li>触发性能测试</li><li>查看监控是否正常<ul><li>应用有无异常日志</li><li>流量是否正常</li><li>各个组件的内存占用是否正常</li><li>写入延迟是否正常</li></ul></li></ul><span id="more"></span><h1 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><p>以上的流程步骤最好是全部一键完成，我们只需要人工检测下监控是否正常即可。</p><p>于是我便写了一个命令行工具，执行流程如下：<br><img src="https://s2.loli.net/2024/07/01/cmXCqk6nyj2DpZA.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pulsar-upgrade-cli -h                                                                                                  ok | at 10:33:18 </span><br><span class="line">A cli app for upgrading Pulsar</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  pulsar-upgrade-cli [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  completion  Generate the autocompletion script for the specified shell</span><br><span class="line">  help        Help about any command</span><br><span class="line">  install     install a target version</span><br><span class="line">  scale       scale statefulSet of the cluster</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">      --burst-limit int                 client-side default throttling limit (default 100)</span><br><span class="line">      --debug                           enable verbose output</span><br><span class="line">  -h, --help                            help for pulsar-upgrade-cli</span><br><span class="line">      --kube-apiserver string           the address and the port for the Kubernetes API server</span><br><span class="line">      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.</span><br><span class="line">      --kube-as-user string             username to impersonate for the operation</span><br></pre></td></tr></table></figure><p>真实使用的 <code>example</code> 如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pulsar-upgrade-cli install \                                                   </span><br><span class="line">        --values ./charts/pulsar/values.yaml \</span><br><span class="line">        --set namespace=pulsar-test \</span><br><span class="line">        --set initialize=true \</span><br><span class="line">        --debug \</span><br><span class="line">        --test-case-schema=http \</span><br><span class="line">        --test-case-host=127.0.0.1 \</span><br><span class="line">        --test-case-port=9999 \</span><br><span class="line">    pulsar-test ./charts/pulsar -n pulsar-test</span><br></pre></td></tr></table></figure><p>它的安装命令非常类似于 <code>helm</code>，也是直接使用 helm 的 <code>value.yaml</code> 进行安装；只是在安装成功后（等待所有的 Pod 都处于 Running 状态）会再触发 test-case 测试，也就是请求一个 endpoint。</p><blockquote><p>这个 endpoint 会在内部处理所有的功能测试和性能测试，具体细节就在后文分析。</p></blockquote><p>同时还提供了一个 scale（扩、缩容） 命令，可以用修改集群规模：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缩容集群规模为0</span></span><br><span class="line">./pulsar-upgrade-cli scale --replicase 0 -n pulsar-test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缩容为最小集群</span></span><br><span class="line">./pulsar-upgrade-cli scale --replicase 1 -n pulsar-test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复为最满集群</span></span><br><span class="line">./pulsar-upgrade-cli scale --replicase 2 -n pulsar-test</span><br></pre></td></tr></table></figure><p>这个需求是因为我们的 <code>Pulsar</code> 测试集群部署在了一个 <code>servless</code> 的 <code>kubernetes</code> 集群里，它是按照使用量收费的，所以在我不需要的使用的时候可以通过这个命令将所有的副本数量修改为 0，从而减少使用成本。</p><p>当只需要做简单的功能测试时便回将集群修改为最小集群，将副本数修改为只可以提供服务即可。</p><p>而当需要做性能测试时就需要将集群修改为最高配置。</p><p>这样可以避免每次都安装新集群，同时也可以有效的减少测试成本。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">require (  </span><br><span class="line">    github.com/spf13/cobra v1<span class="number">.6</span><span class="number">.1</span>  </span><br><span class="line">    github.com/spf13/pflag v1<span class="number">.0</span><span class="number">.5</span>   </span><br><span class="line">    helm.sh/helm/v3 v3<span class="number">.10</span><span class="number">.2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个命令行工具本质上是参考了 helm 的命令行实现的，所有主要也是依赖了 <code>helm</code> 和 <code>cobra</code>。</p><p><img src="https://s2.loli.net/2024/07/01/rouTSUBDIWciElx.png"><br>下面以最主要的安装命令为例，核心的是以下的步骤：</p><ul><li>执行 <code>helm</code> 安装（这里是直接使用的 helm 的源码逻辑进行安装）</li><li>等待所有的 <code>Pod</code> 成功运行</li><li>触发 <code>test-case</code> 执行</li><li>等待测试用例执行完毕</li><li>检测是否需要卸载安装的集群</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *installEvent)</span></span> FinishInstall(cfg *action.Configuration, name <span class="type">string</span>) <span class="type">error</span> &#123;  </span><br><span class="line">    bar.Increment()  </span><br><span class="line">    bar.Finish()  </span><br><span class="line">  </span><br><span class="line">    clientSet, err := cfg.KubernetesClientSet()  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> err  </span><br><span class="line">    &#125;  </span><br><span class="line">    ctx := context.Background()  </span><br><span class="line">    ip, err := GetServiceExternalIp(ctx, clientSet, settings.Namespace(), fmt.Sprintf(<span class="string">&quot;%s-proxy&quot;</span>, name))  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> err  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    token, err := GetPulsarProxyToken(ctx, clientSet, settings.Namespace(), fmt.Sprintf(<span class="string">&quot;%s-token-proxy-admin&quot;</span>, name))  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> err  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// trigger testcase  </span></span><br><span class="line">    err = e.client.Trigger(context.Background(), ip, token)  </span><br><span class="line">    <span class="keyword">return</span> err  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>FinishInstall</code> 需要获取到新安装的 Pulsar 集群的 proxy IP 地址和鉴权所使用的 <code>token</code>(<code>GetServiceExternalIp()</code>&#x2F;<code>GetPulsarProxyToken()</code>)。</p><p>将这两个参数传递给 <code>test-case</code> 才可以构建出 <code>pulsar-client</code>.</p><p>这个命令的核心功能就是安装集群和触发测试，以及一些集群的基本运维能力。</p><h1 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h1><p>而关于这里的测试用例也有一些小伙伴咨询过，如何对 Pulsar 进行功能测试。</p><p>其实 Pulsar 源码中已经包含了几乎所有我们会使用到的测试代码，理论上只要新版本的官方镜像已经推送了那就是跑了所有的单测，质量是可以保证的。</p><p>那为什么还需要做功能测试呢？</p><p>其实很很简单，<code>Pulsar</code> 这类基础组件官方都有提供基准测试，但我们想要用于生产环境依然需要自己做压测得出一份属于自己环境下的性能测试报告；</p><p>根本目的是要看在自己的业务场景下是否可以满足（包括公司的软硬件，不同的业务代码）。</p><p>所以这里的功能测试代码有一个很重要的前提就是：<strong>需要使用真实的业务代码进行测试</strong>。</p><p>也就是业务在线上使用与 Pulsar 相关的代码需要参考功能测试里的代码实现，不然有些问题就无法在测试环节覆盖到。</p><blockquote><p>这里我就踩过坑，因为在功能测试里用的是官方的 example 代码进行测试的，自然是没有问题；但业务在实际使用时，使用到了一个 Schema 的场景，并没有在功能测试里覆盖到（官方的测试用例里也没有😂），就导致升级到某个版本后业务功能无法正常使用（虽然用法确实是有问题），但应该在我测试阶段就暴露出来。</p></blockquote><h2 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h2><p><img src="https://s2.loli.net/2024/07/01/3vZiGABjkYh5LUJ.png"><br>以上是一个集群的功能测试报告，这里我只有 8 个测试场景（结合实际业务使用），考虑到未来可能会有新的测试用例，所以在设计这个测试框架时就得考虑到扩展性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job5</span> <span class="operator">=</span>  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FailoverConsumerTest</span>(event, <span class="string">&quot;故障转移消费测试&quot;</span>, pulsarClient, <span class="number">20</span>, admin);  </span><br><span class="line">CompletableFuture&lt;Void&gt; c5 = CompletableFuture.runAsync(job5::start, EXECUTOR);  </span><br><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchemaTest</span>(event,<span class="string">&quot;schema测试&quot;</span>,pulsarClient,<span class="number">20</span>,prestoService);  </span><br><span class="line">CompletableFuture&lt;Void&gt; c6 = CompletableFuture.runAsync(job6::start, EXECUTOR);  </span><br><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VlogsTest</span>(event,<span class="string">&quot;vlogs test&quot;</span>,pulsarClient,<span class="number">20</span>, vlogsUrl);  </span><br><span class="line">CompletableFuture&lt;Void&gt; c7 = CompletableFuture.runAsync(job7::start, EXECUTOR);  </span><br><span class="line">  </span><br><span class="line">CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(c1, c2, c3, c4, c5, c6, c7);  </span><br><span class="line">all.whenComplete((___, __) -&gt; &#123;  </span><br><span class="line">    event.finishAll();  </span><br><span class="line">    pulsarClient.closeAsync();  </span><br><span class="line">    admin.close();  </span><br><span class="line">&#125;).get();</span><br></pre></td></tr></table></figure><p>对外提供的 trigger 接口就不贴代码了，重点就是在这里构建测试任务，然后等待他们全部执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractJobDefine</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Event event;</span><br><span class="line">    <span class="keyword">private</span> String jobName;</span><br><span class="line">    <span class="keyword">private</span> PulsarClient pulsarClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PulsarAdmin admin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractJobDefine</span><span class="params">(Event event, String jobName, PulsarClient pulsarClient, <span class="type">int</span> timeout, PulsarAdmin admin)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.event = event;</span><br><span class="line">        <span class="built_in">this</span>.jobName = jobName;</span><br><span class="line">        <span class="built_in">this</span>.pulsarClient = pulsarClient;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.admin = admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        event.addJob();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">                <span class="type">StopWatch</span> <span class="variable">watch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    watch.start(jobName);</span><br><span class="line">                    run(pulsarClient, admin);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    event.oneException(<span class="built_in">this</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    watch.stop();</span><br><span class="line">                    event.finishOne(jobName, StrUtil.format(<span class="string">&quot;cost: &#123;&#125;s&quot;</span>, watch.getTotalTimeSeconds()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, TestCase.EXECUTOR).get(timeout, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            event.oneException(<span class="built_in">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** run busy code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pulsarClient pulsar client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> admin pulsar admin client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(PulsarClient pulsarClient, PulsarAdmin admin)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码就是这个抽象的任务定义类，其中的 start 函数用于定义任务执行的模版：</p><ul><li>添加任务：具体实现是任务计数器+1</li><li>开始计时</li><li>执行抽血的 run 函数，具体实现交给子类</li><li>异常时记录事件</li><li>正常执行完毕后也记录事件</li></ul><p>下面来看一个普通用例的实现情况：<br><img src="https://s2.loli.net/2024/07/01/rdU5mPbfOJxv4TL.png"></p><p>就是重写了 <code>run()</code> 函数，然后在其中实现具体的测试用例，断言测试结果。</p><p>这样当我们需要再添加用例的时候只需要再新增一个子类实现即可。</p><p>同时还需要定义一个事件接口，用于处理一些关键的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Event</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 新增一个任务  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addJob</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 获取运行中的任务数量  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取运行中的任务数量  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    TestCaseRuntimeResponse <span class="title function_">getRuntime</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 单个任务执行完毕  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobName    任务名称  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> finishCost 任务完成耗时  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">finishOne</span><span class="params">(String jobName, String finishCost)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**单个任务执行异常  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobDefine 任务  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 异常  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">oneException</span><span class="params">(AbstractJobDefine jobDefine, Exception e)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 所有任务执行完毕  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">finishAll</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>getRuntime</code> 接口是用于在 cli 那边查询任务是否执行完毕的接口，只有任务执行完毕之后才能退出 <code>cli</code>。</p><h1 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h1><p>当这些任务运行完毕后我们需要重点查看应用客户端和 Pulsar broker 端是否有异常日志。</p><p>同时还需要观察一些关键的监控面板：</p><p><img src="https://s2.loli.net/2024/07/01/sGxOjRWnScPl5oZ.png"><br><img src="https://s2.loli.net/2024/07/01/E6hcSxHrRmNVFoi.png"><br><img src="https://s2.loli.net/2024/07/01/UeFZ73yRbpkAsEH.png"></p><p>包含但不限于：</p><ul><li>消息吞吐量</li><li><code>broker</code> 写入延迟</li><li><code>Bookkeeper</code> 的写入、读取成功率，以及延迟。</li></ul><p>当然还有 <code>zookeeper</code> 的运行情况也需要监控，限于篇幅就不一一粘贴了。</p><p>以上就是测试整个 Pulsar 集群的流程，当然还有一些需要优化的地方。</p><p>比如使用命令行还是有些不便，后续可能会切换到网页上就可以操作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/07/01/xZSMlpJPWTRGkge.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;由于我在公司内部负责维护 &lt;code&gt;Pulsar&lt;/code&gt;，需要时不时的升级 &lt;code&gt;Pulsar&lt;/code&gt; 版本从而和社区保持一致。&lt;/p&gt;
&lt;p&gt;而每次升级过程都需要做相同的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装一个新版本的集群&lt;/li&gt;
&lt;li&gt;触发功能性测试&lt;/li&gt;
&lt;li&gt;触发性能测试&lt;/li&gt;
&lt;li&gt;查看监控是否正常&lt;ul&gt;
&lt;li&gt;应用有无异常日志&lt;/li&gt;
&lt;li&gt;流量是否正常&lt;/li&gt;
&lt;li&gt;各个组件的内存占用是否正常&lt;/li&gt;
&lt;li&gt;写入延迟是否正常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>Pulsar客户端消费模式揭秘：Go 语言实现 ZeroQueueConsumer</title>
    <link href="http://crossoverjie.top/2024/07/29/ob/pulsar-client-zero-consumer/"/>
    <id>http://crossoverjie.top/2024/07/29/ob/pulsar-client-zero-consumer/</id>
    <published>2024-07-29T14:31:57.000Z</published>
    <updated>2024-07-29T03:08:42.394Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在 <a href="https://github.com/apache/pulsar-client-go">pulsar-client-go</a> 社区里看到这么一个 <a href="https://github.com/apache/pulsar-client-go/issues/1223">issue</a>：<br><img src="https://s2.loli.net/2024/06/24/KNsvV7jeZYSaiPq.png"></p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/apache/pulsar-client-go/pulsar&quot;</span></span><br><span class="line"></span><br><span class="line">client, err := pulsar.NewClient(pulsar.ClientOptions&#123;</span><br><span class="line">    URL: <span class="string">&quot;pulsar://localhost:6650&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">consumer, err := client.Subscribe(pulsar.ConsumerOptions&#123;</span><br><span class="line">    Topic:             <span class="string">&quot;persistent://public/default/mq-topic-1&quot;</span>,</span><br><span class="line">    SubscriptionName:  <span class="string">&quot;sub-1&quot;</span>,</span><br><span class="line">    Type:              pulsar.Shared,</span><br><span class="line">    ReceiverQueueSize: <span class="number">0</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小于等于 0 时会设置为 1000</span></span><br><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">    defaultReceiverQueueSize = <span class="number">1000</span>  </span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> options.ReceiverQueueSize &lt;= <span class="number">0</span> &#123;  </span><br><span class="line">    options.ReceiverQueueSize = defaultReceiverQueueSize  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他发现手动将 pulsar-client-go 客户端的 <code>ReceiverQueueSize</code> 设置为 0 的时候，客户端在初始化时会再将其调整为 1000.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> options.ReceiverQueueSize &lt; <span class="number">0</span> &#123;  </span><br><span class="line">    options.ReceiverQueueSize = defaultReceiverQueueSize  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果手动将源码修改为可以设置为 0 时，却不能正常消费，消费者会一直处于 waiting 状态，获取不到任何数据。</p><p>经过我的排查发现是 Pulsar 的  Go  客户端缺少了一个 <a href="https://github.com/apache/pulsar/blob/83b86abcb74595d7e8aa31b238a7dbb19a04dde2/pulsar-client/src/main/java/org/apache/pulsar/client/impl/ConsumerImpl.java#L268-L272">ZeroQueueConsumerImpl</a>的实现类，这个类主要用于可以精细控制消费逻辑。</p><blockquote><p>If you’d like to have tight control over message dispatching across consumers, set the <strong>consumers’ receiver queue size very low (potentially even to 0 if necessary)</strong>. Each consumer has a receiver queue that determines how many messages the consumer attempts to fetch at a time. For example, a receiver queue of 1000 (the default) means that the consumer attempts to process 1000 messages from the topic’s backlog upon connection. Setting the receiver queue to 0 essentially means ensuring that each consumer is only doing one thing at a time.</p></blockquote><p><a href="https://pulsar.apache.org/docs/next/cookbooks-message-queue/#client-configuration-changes">https://pulsar.apache.org/docs/next/cookbooks-message-queue/#client-configuration-changes</a></p><p>正如官方文档里提到的那样，可以将 ReceiverQueueSize 设置为 0；这样消费者就可以一条条的消费数据，而不会将消息堆积在客户端队列里。</p><h1 id="客户端消费逻辑"><a href="#客户端消费逻辑" class="headerlink" title="客户端消费逻辑"></a>客户端消费逻辑</h1><p>借此机会需要再回顾下 pulsar 客户端的消费逻辑，这样才能理解 <code>ReceiverQueueSize</code> 的作用以及如何在 pulsar-client-go 如何实现这个 <code>ZeroQueueConsumerImpl</code>。</p><p>Pulsar 客户端的消费模式是基于推拉结合的：</p><p><img src="https://s2.loli.net/2024/06/24/bTP1WGVJUR9wzYe.png"><br>如这张图所描述的流程，消费者在启动的时候会主动向服务端发送一个 Flow 的命令，告诉服务端需要下发多少条消息给客户端。</p><p>同时会使用刚才的那个 <code>ReceiverQueueSize</code>参数作为内部队列的大小，将客户端下发的消息存储在内部队列里。</p><p>然后在调用 <code>receive</code> 函数的时候会直接从这个队列里获取数据。</p><p><img src="https://s2.loli.net/2024/06/24/e3AabLk4FqB8VTo.png"><br><img src="https://s2.loli.net/2024/06/24/ZGHiaXBJfEyxh5d.png"></p><p>每次消费成功后都会将内部的一个 <code>AvailablePermit+1</code>，直到大于 <code>MaxReceiveQueueSize / 2</code> 就会再次向 broker 发送 flow 命令，告诉 broker 再次下发消息。</p><p>所以这里有一个很关键的事件：就是向 broker 发送 <code>flow</code> 命令，这样才会有新的消息下发给客户端。</p><p>之前经常都会有研发同学让我排查无法消费的问题，最终定位到的原因几乎都是消费缓慢，导致这里的 <code>AvailablePermit</code> 没有增长，从而也就不会触发 broker 给客户端推送新的消息。</p><p>看到的现象就是消费非常缓慢。</p><h1 id="ZeroQueueConsumerImpl-原理"><a href="#ZeroQueueConsumerImpl-原理" class="headerlink" title="ZeroQueueConsumerImpl 原理"></a>ZeroQueueConsumerImpl 原理</h1><p>下面来看看 <code>ZeroQueueConsumerImpl</code> 是如何实现队列大小为 0 依然是可以消费的。</p><p><img src="https://s2.loli.net/2024/06/24/Vmk9l2nucP31bNX.png"><br>在构建 consumer 的时候，就会根据队列大小从而来创建普通消费者还是 <code>ZeroQueueConsumerImpl</code> 消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">protected</span> CompletableFuture&lt;Message&lt;T&gt;&gt; <span class="title function_">internalReceiveAsync</span><span class="params">()</span> &#123;  </span><br><span class="line">    CompletableFuture&lt;Message&lt;T&gt;&gt; future = <span class="built_in">super</span>.internalReceiveAsync();  </span><br><span class="line">    <span class="keyword">if</span> (!future.isDone()) &#123;  </span><br><span class="line">        <span class="comment">// We expect the message to be not in the queue yet  </span></span><br><span class="line">        increaseAvailablePermits(cnx());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> future;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 <code>ZeroQueueConsumerImpl</code> 重写的一个消费函数，其中关键的就是 <code>increaseAvailablePermits(cnx());</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">increaseAvailablePermits</span><span class="params">(ClientCnx currentCnx)</span> &#123;</span><br><span class="line">    increaseAvailablePermits(currentCnx, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">increaseAvailablePermits</span><span class="params">(ClientCnx currentCnx, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> AVAILABLE_PERMITS_UPDATER.addAndGet(<span class="built_in">this</span>, delta);</span><br><span class="line">    <span class="keyword">while</span> (available &gt;= getCurrentReceiverQueueSize() / <span class="number">2</span> &amp;&amp; !paused) &#123;</span><br><span class="line">        <span class="keyword">if</span> (AVAILABLE_PERMITS_UPDATER.compareAndSet(<span class="built_in">this</span>, available, <span class="number">0</span>)) &#123;</span><br><span class="line">            sendFlowPermitsToBroker(currentCnx, available);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            available = AVAILABLE_PERMITS_UPDATER.get(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码里可以得知这里的逻辑就是将 AvailablePermit 自增，达到阈值后请求 broker 下发消息。</p><p>因为在 <code>ZeroQueueConsumerImpl</code> 中队列大小为 0，所以 <code>available &gt;= getCurrentReceiverQueueSize() / 2</code>永远都会为 true。</p><p>也就是说每消费一条消息都会请求 broker 让它再下发一条消息，这样就达到了每一条消息都精确控制的效果。</p><h1 id="pulsar-client-go-中的实现"><a href="#pulsar-client-go-中的实现" class="headerlink" title="pulsar-client-go 中的实现"></a>pulsar-client-go 中的实现</h1><p>为了在 pulsar-client-go 实现这个需求，我提交了一个 <a href="https://github.com/apache/pulsar-client-go/pull/1225">PR</a> 来解决这个问题。</p><p>其实从上面的分析已经得知为啥手动将 <code>ReceiverQueueSize</code> 设置为 0 无法消费消息了。</p><p>根本原因还是在初始化的时候优于队列为 0，导致不会给 broker 发送 flow 命令，这样就不会有消息推送到客户端，也就无法消费到数据了。</p><p>所以我们依然得参考 Java 的 <code>ZeroQueueConsumerImpl</code> 在每次消费的时候都手动增加  <code>availablePermits</code>。</p><p>为此我也新增了一个消费者 <code>zeroQueueConsumer</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EnableZeroQueueConsumer, if enabled, the ReceiverQueueSize will be 0.  </span></span><br><span class="line"><span class="comment">// Notice: only non-partitioned topic is supported.  </span></span><br><span class="line"><span class="comment">// Default is false.  </span></span><br><span class="line">EnableZeroQueueConsumer <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">consumer, err := client.Subscribe(ConsumerOptions&#123;  </span><br><span class="line">    Topic:                   topicName,  </span><br><span class="line">    SubscriptionName:        <span class="string">&quot;sub-1&quot;</span>,  </span><br><span class="line">    Type:                    Shared,  </span><br><span class="line">    NackRedeliveryDelay:     <span class="number">1</span> * time.Second,  </span><br><span class="line">    EnableZeroQueueConsumer: <span class="literal">true</span>,  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> options.EnableZeroQueueConsumer &#123;  </span><br><span class="line">    options.ReceiverQueueSize = <span class="number">0</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建消费者的时候需要指定是否开启 <code>ZeroQueueConsumer</code>，当开启后会手动将 ReceiverQueueSize 设置为 0.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以设置默认值。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">receiverQueueSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在 Go 中无法像 Java 那样在结构体初始化化的时候就指定默认值，再加上 Go 的 int 类型具备零值（也就是0），所以无法区分出 ReceiverQueueSize&#x3D;0 是用户主动设置的，还是没有传入这个参数使用的零值。</p></blockquote><p>所以才需要新增一个参数来手动区分是否使用 <code>ZeroQueueConsumer</code>。</p><p><img src="https://s2.loli.net/2024/06/24/TK2fJVEFlnL4dIy.png"><br>之后在创建 <code>consumer</code> 的时候进行判断，只有使用的是单分区的 <code>topic</code> 并且开启了 <code>EnableZeroQueueConsumer</code> 才能创建  <code>zeroQueueConsumer</code>。</p><hr><p><img src="https://s2.loli.net/2024/06/24/Aq5onPKOjIgserx.png"></p><blockquote><p>使用 PARTITIONED_METADATA 命令可以让 broker 返回分区数量。</p></blockquote><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *zeroQueueConsumer)</span></span> Receive(ctx context.Context) (Message, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> state := z.pc.getConsumerState(); state == consumerClosed || state == consumerClosing &#123;</span><br><span class="line">z.log.WithField(<span class="string">&quot;state&quot;</span>, state).Error(<span class="string">&quot;Failed to ack by closing or closed consumer&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;consumer state is closed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">z.Lock()</span><br><span class="line"><span class="keyword">defer</span> z.Unlock()</span><br><span class="line">z.pc.availablePermits.inc()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-z.closeCh:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, newError(ConsumerClosed, <span class="string">&quot;consumer closed&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> cm, ok := &lt;-z.messageCh:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, newError(ConsumerClosed, <span class="string">&quot;consumer closed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cm.Message, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的关键代码：<code>z.pc.availablePermits.inc()</code></p><p>消费时的逻辑其实和 Java 的 <code>ZeroQueueConsumerImpl</code> 逻辑保持了一致，也是每消费一条数据之前就增加一次 <code>availablePermits</code>。</p><p>pulsar-client-go 的运行原理与 Java 客户端的类似，也是将消息存放在了一个内部队列里，所以每次消费消息只需要从这个队列 <code>messageCh</code> 里获取即可。</p><p>值得注意的是， pulsar-client-go 版本的 <code>zeroQueueConsumer</code> 就不支持直接读取内部的队列了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *zeroQueueConsumer)</span></span> Chan() &lt;-<span class="keyword">chan</span> ConsumerMessage &#123;  </span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;zeroQueueConsumer cannot support Chan method&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会直接 panic，因为直接消费 channel 在客户端层面就没法帮用户主动发送 flow 命令了，所以这个功能就只能屏蔽掉了，只可以主动的 <code>receive</code> 消息。</p><p><img src="https://s2.loli.net/2024/06/24/dDlr3RWM6iYHFbc.png"></p><p>许久之前我也画过一个关于 pulsar client 的消费流程图，后续考虑会再写一篇关于 pulsar client 的原理分析文章。</p><p>参考链接：</p><ul><li><a href="https://github.com/apache/pulsar-client-go/issues/1223">https://github.com/apache/pulsar-client-go/issues/1223</a></li><li><a href="https://cloud.tencent.com/developer/article/2307608">https://cloud.tencent.com/developer/article/2307608</a></li><li><a href="https://pulsar.apache.org/docs/next/cookbooks-message-queue/#client-configuration-changes">https://pulsar.apache.org/docs/next/cookbooks-message-queue/#client-configuration-changes</a></li><li><a href="https://github.com/apache/pulsar-client-go/pull/1225">https://github.com/apache/pulsar-client-go/pull/1225</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间在 &lt;a href=&quot;https://github.com/apache/pulsar-client-go&quot;&gt;pulsar-client-go&lt;/a&gt; 社区里看到这么一个 &lt;a href=&quot;https://github.com/apache/pulsar-client-go/issues/1223&quot;&gt;issue&lt;/a&gt;：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/06/24/KNsvV7jeZYSaiPq.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/OB/Pulsar/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>如何监控 Nginx</title>
    <link href="http://crossoverjie.top/2024/07/23/ob/how-to-monitoring-nginx/"/>
    <id>http://crossoverjie.top/2024/07/23/ob/how-to-monitoring-nginx/</id>
    <published>2024-07-23T02:46:30.000Z</published>
    <updated>2024-07-23T03:18:06.688Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间接到一个需求，希望可以监控 Nginx 的运行状态。</p><p>我们都知道 Nginx 作为一个流行的 Web 服务器提供了多种能力，包括反向代理、负载均衡；也支持了许多协议，包括：</p><ul><li>gRPC</li><li>http</li><li>WebSocket 等<br>作为一个流量入口的中间件，对其的监控就显得至关重要了。</li></ul><span id="more"></span><p>市面上也有一些现成的产品可以监控 Nginx，比如知名的监控服务商 <code>datadog</code> 也提供了 Nginx 的监控。</p><p><img src="https://s2.loli.net/2024/06/21/BEjyS4ZQHKCrPqx.png"></p><p>但是我这是一个内网服务，并不能使用这些外部的云厂商，所有就只能在内部搭建 Nginx 的监控服务了。</p><p>不过 Nginx 默认情况下并没有提供 <code>/metrics</code> 的 endpoint，但好在它提供了一个额外的模块：<code>stub_status</code> 可以用于获取监控数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server</span> &#123;</span><br><span class="line">  <span class="string">listen</span> <span class="number">80</span><span class="string">;</span></span><br><span class="line">  <span class="string">server_name</span> <span class="string">_;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">location</span> <span class="string">/status</span> &#123;</span><br><span class="line">    <span class="string">stub_status</span> <span class="string">on;</span></span><br><span class="line">    <span class="string">access_log</span> <span class="string">off;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">      <span class="string">root</span> <span class="string">/usr/share/nginx/html;</span></span><br><span class="line">      <span class="string">index</span> <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/06/21/ZRIPyN2UxXuiCdE.png"><br>这样访问 <code>http://127.0.0.1:80/status</code> 就可以拿到一些基本的运行数据。</p><p>但这个格式明显不是 Prometheus 所支持的 metrics 格式，无法直接将数据采集到 Prometheus 中然后通过 Grafana 进行查看。</p><p>所以还得需要一个中间层来将这些数据转换为 Prometheus 可以接收的 metrics 数据。</p><h1 id="nginx-prometheus-exporter"><a href="#nginx-prometheus-exporter" class="headerlink" title="nginx-prometheus-exporter"></a>nginx-prometheus-exporter</h1><p>好在社区已经提供了类似的工具：<a href="https://github.com/nginxinc/nginx-prometheus-exporter">nginx-prometheus-exporter</a> 它读取刚才 status endpoint 所暴露的数据，然后转换为 Prometheus 格式，并对外提供了一个 <code>/metrics</code> 的 endpoint 供 Prometheus 来采集。</p><h2 id="转换数据"><a href="#转换数据" class="headerlink" title="转换数据"></a>转换数据</h2><p>我们在启动这个 <code>nginx-exporter</code> 时需要传入刚才 <code>Nginx</code> 暴露的 <code>/status</code> endpoint。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9113:9113 nginx/nginx-prometheus-exporter:1.1.0 --nginx.scrape-uri=http://&lt;nginx&gt;:8080/stub_status</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> templateMetrics <span class="type">string</span> = <span class="string">`Active connections: %d</span></span><br><span class="line"><span class="string">server accepts handled requests</span></span><br><span class="line"><span class="string">%d %d %d</span></span><br><span class="line"><span class="string">Reading: %d Writing: %d Waiting: %d</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 Nginx status 数据</span></span><br><span class="line">body, err := io.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to read the response body: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r := bytes.NewReader(body)</span><br><span class="line">stats, err := parseStubStats(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to parse response body %q: %w&quot;</span>, <span class="type">string</span>(body), err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 Nginx status 数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseStubStats</span><span class="params">(r io.Reader)</span></span> (*StubStats, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> s StubStats</span><br><span class="line"><span class="keyword">if</span> _, err := fmt.Fscanf(r, templateMetrics,</span><br><span class="line">&amp;s.Connections.Active,</span><br><span class="line">&amp;s.Connections.Accepted,</span><br><span class="line">&amp;s.Connections.Handled,</span><br><span class="line">&amp;s.Requests,</span><br><span class="line">&amp;s.Connections.Reading,</span><br><span class="line">&amp;s.Connections.Writing,</span><br><span class="line">&amp;s.Connections.Waiting); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to scan template metrics: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后会把刚才解析到的数据生成 metrics：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_active&quot;</span>],  </span><br><span class="line">    prometheus.GaugeValue, <span class="type">float64</span>(stats.Connections.Active))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_accepted&quot;</span>],  </span><br><span class="line">    prometheus.CounterValue, <span class="type">float64</span>(stats.Connections.Accepted))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_handled&quot;</span>],  </span><br><span class="line">    prometheus.CounterValue, <span class="type">float64</span>(stats.Connections.Handled))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_reading&quot;</span>],  </span><br><span class="line">    prometheus.GaugeValue, <span class="type">float64</span>(stats.Connections.Reading))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_writing&quot;</span>],  </span><br><span class="line">    prometheus.GaugeValue, <span class="type">float64</span>(stats.Connections.Writing))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_waiting&quot;</span>],  </span><br><span class="line">    prometheus.GaugeValue, <span class="type">float64</span>(stats.Connections.Waiting))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;http_requests_total&quot;</span>],  </span><br><span class="line">    prometheus.CounterValue, <span class="type">float64</span>(stats.Requests))</span><br></pre></td></tr></table></figure><p>这些 metrics 是一开始就定义好的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewNginxCollector creates an NginxCollector.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNginxCollector</span><span class="params">(nginxClient *client.NginxClient, namespace <span class="type">string</span>, constLabels <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, logger log.Logger)</span></span> *NginxCollector &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;NginxCollector&#123;</span><br><span class="line">nginxClient: nginxClient,</span><br><span class="line">logger:      logger,</span><br><span class="line">metrics: <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc&#123;</span><br><span class="line"><span class="string">&quot;connections_active&quot;</span>:   newGlobalMetric(namespace, <span class="string">&quot;connections_active&quot;</span>, <span class="string">&quot;Active client connections&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;connections_accepted&quot;</span>: newGlobalMetric(namespace, <span class="string">&quot;connections_accepted&quot;</span>, <span class="string">&quot;Accepted client connections&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;connections_handled&quot;</span>:  newGlobalMetric(namespace, <span class="string">&quot;connections_handled&quot;</span>, <span class="string">&quot;Handled client connections&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;connections_reading&quot;</span>:  newGlobalMetric(namespace, <span class="string">&quot;connections_reading&quot;</span>, <span class="string">&quot;Connections where NGINX is reading the request header&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;connections_writing&quot;</span>:  newGlobalMetric(namespace, <span class="string">&quot;connections_writing&quot;</span>, <span class="string">&quot;Connections where NGINX is writing the response back to the client&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;connections_waiting&quot;</span>:  newGlobalMetric(namespace, <span class="string">&quot;connections_waiting&quot;</span>, <span class="string">&quot;Idle client connections&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;http_requests_total&quot;</span>:  newGlobalMetric(namespace, <span class="string">&quot;http_requests_total&quot;</span>, <span class="string">&quot;Total http requests&quot;</span>, constLabels),</span><br><span class="line">&#125;,</span><br><span class="line">upMetric: newUpMetric(namespace, constLabels),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个函数是在 exporter 启动时候会调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;github.com/prometheus/client_golang/prometheus&quot;</span></span><br><span class="line"></span><br><span class="line">prometheus.MustRegister(collector.NewNginxCollector(ossClient, <span class="string">&quot;nginx&quot;</span>, labels, logger))</span><br></pre></td></tr></table></figure><p>使用的是 <code>prometheus</code> 包提供的注册函数，将我们刚才自定义的获取 <code>metrics</code> 的逻辑注册进去，这样当我们在 Prometheus 中配置好采集任务之后就可以定期扫描 <code>/status</code> 的数据然后转换为 Prometheus 指标返回。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">10s</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">nginx-exportor</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;127.0.0.1:9113&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这样就可以将 nginx status 的数据定期采集到 Prometheus 中了，最后使用社区提供的 grafana 面板便可以可视化的查看这些监控数据：<br><img src="https://s2.loli.net/2024/06/21/NvlwuAdDZHUznrC.png"></p><h2 id="Nginx-Plus"><a href="#Nginx-Plus" class="headerlink" title="Nginx Plus"></a>Nginx Plus</h2><p>同时这个 nginx-exporter 还支持 <code>Nginx Plus</code>(这是 Nginx 的商用增强版)，它的实现原理类似，只是它支持的指标更多一些而已。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NginxPlusCollector <span class="keyword">struct</span> &#123;  </span><br><span class="line">    upMetric                       prometheus.Gauge  </span><br><span class="line">    logger                         log.Logger  </span><br><span class="line">    cacheZoneMetrics               <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    workerMetrics                  <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    nginxClient                    *plusclient.NginxClient  </span><br><span class="line">    streamServerZoneMetrics        <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    streamZoneSyncMetrics          <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    streamUpstreamMetrics          <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    streamUpstreamServerMetrics    <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    locationZoneMetrics            <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    resolverMetrics                <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    limitRequestMetrics            <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    limitConnectionMetrics         <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    streamLimitConnectionMetrics   <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    upstreamServerMetrics          <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    upstreamMetrics                <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    streamUpstreamServerPeerLabels <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    serverZoneMetrics              <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    upstreamServerLabels           <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    streamUpstreamServerLabels     <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    serverZoneLabels               <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    streamServerZoneLabels         <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    upstreamServerPeerLabels       <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    workerLabels                   <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    cacheZoneLabels                <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    totalMetrics                   <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    variableLabelNames             VariableLabelNames  </span><br><span class="line">    variableLabelsMutex            sync.RWMutex  </span><br><span class="line">    mutex                          sync.Mutex  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://prometheus.io/docs/instrumenting/exporters/">Prometheus</a> 社区中提供不少这类 <code>exporter</code>：<br><img src="https://s2.loli.net/2024/06/21/ztuCr8FgJvcSbis.png"></p><p>这些 <code>exporter</code> 要解决的问题都是类似的，对于一些没有暴露 <code>/metrics</code> 的中间件通过他们提供的客户端直连，然后将获取到的数据转换为 Prometheus 所支持的格式。</p><blockquote><p>需要单独的 exporter 支持的中间件大部分都是一些老牌产品，在设计之初就没有考虑可观测性的需求，现在一些新的中间件几乎都原生支持 metrics，这种产品只需要在 Prometheus 中配置采集任务即可。</p></blockquote><h1 id="Cprobe"><a href="#Cprobe" class="headerlink" title="Cprobe"></a>Cprobe</h1><p>不知道大家发现没有，社区中提供的 <code>exporter</code> 还是挺多的，但如果我们都需要在自己的生产环境将这些 exporter 部署起来多少会有些繁琐：</p><ul><li>不同的 exporter 需要的参数可能不同</li><li>暴露的端口可能不同</li><li>配置文件难以统一管理</li></ul><p>在这个背景下社区有大佬发起了一个 <a href="https://github.com/cprobe/cprobe">cprobe</a> 项目，这是一个大而全的项目，可以将散落在各处的 <code>exporter</code> 都整合在一起。</p><p>并且统一抽象了接入方式，使得所有的插件都可以用类似的配置书写方式来维护这些插件。</p><p>目前已经支持以下一些常用的中间件：</p><p><img src="https://s2.loli.net/2024/06/21/eC75lpg2fBmstjS.png"></p><p>这里的 Nginx 就是本次监控的需求贡献的，因为还需要监控这里支持的一些其他中间件，所以最终也是使用 cprobe 来部署监控。</p><h2 id="整合-Nginx-exporter-到-Cprobe-中"><a href="#整合-Nginx-exporter-到-Cprobe-中" class="headerlink" title="整合 Nginx exporter 到 Cprobe 中"></a>整合 Nginx exporter 到 Cprobe 中</h2><p>下面来看看如何将社区中已经存在的 Nginx exporter 整合到  cprobe 中：</p><p>在开始之前我们先要抽象出这个插件需要哪些配置？</p><p>这个其实很好解决，我们直接看看需要实现的 exporter 中提供了哪些参数，这里以 Nginx 的为例：<br><img src="https://s2.loli.net/2024/06/21/zsY2F563pPglNcS.png"></p><p>排除掉一些我们不需要的，比如端口、日志级别、endpoint等配置之外，就只需要一些关于 SSL 的配置，所以最终我们需要的配置文件如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nginx_plus</span> = <span class="literal">false</span>  </span><br><span class="line"><span class="comment"># Path to the PEM encoded CA certificate file used to validate the servers SSL certificate.  </span></span><br><span class="line"><span class="attr">ssl_ca_cert</span> = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line"><span class="comment"># Path to the PEM encoded client certificate file to use when connecting to the server.  </span></span><br><span class="line"><span class="attr">ssl_client_cert</span> = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line"><span class="comment"># Path to the PEM encoded client certificate key file to use when connecting to the server.  </span></span><br><span class="line"><span class="attr">ssl_client_key</span> = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line"><span class="comment"># Perform SSL certificate verification.  </span></span><br><span class="line"><span class="attr">ssl_verify</span> = <span class="literal">false</span>  </span><br><span class="line"><span class="attr">timeout</span> = <span class="string">&#x27;5s&#x27;</span></span><br></pre></td></tr></table></figure><p>然后将这个 toml 里的配置转换为一个 struct。</p><p>在 cprobe 中有一个核心的接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// ParseConfig is used to parse config</span></span><br><span class="line">ParseConfig(baseDir <span class="type">string</span>, bs []<span class="type">byte</span>) (any, <span class="type">error</span>)</span><br><span class="line"><span class="comment">// Scrape is used to scrape metrics, cfg need to be cast specific cfg</span></span><br><span class="line">Scrape(ctx context.Context, target <span class="type">string</span>, cfg any, ss *types.Samples) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ParseConfig</code> 用于将刚才的配置文件流格式化为插件所需要的配置。</p><p><code>Scrape</code> 函数则是由 cprobe 定时调用的函数，会传入抓取的目标地址，每个插件将抓到的数据写入 <code>*types.Samples</code> 中即可。</p><p><code>cprobe</code> 会将 <code>*types.Samples</code> 的数据发送到 remote 的 Prometheus 中。</p><p>接下来看看 Nginx 插件的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">NginxPlus     <span class="type">bool</span>          <span class="string">`toml:&quot;nginx_plus&quot;`</span></span><br><span class="line">SSLCACert     <span class="type">string</span>        <span class="string">`toml:&quot;ssl_ca_cert&quot;`</span></span><br><span class="line">SSLClientCert <span class="type">string</span>        <span class="string">`toml:&quot;ssl_client_cert&quot;`</span></span><br><span class="line">SSLClientKey  <span class="type">string</span>        <span class="string">`toml:&quot;ssl_client_key&quot;`</span></span><br><span class="line">SSLVerify     <span class="type">bool</span>          <span class="string">`toml:&quot;ssl_verify&quot;`</span></span><br><span class="line">Timeout       time.Duration <span class="string">`toml:&quot;timeout&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Nginx)</span></span> ParseConfig(baseDir <span class="type">string</span>, bs []<span class="type">byte</span>) (any, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> c Config</span><br><span class="line">err := toml.Unmarshal(bs, &amp;c)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.Timeout == <span class="number">0</span> &#123;</span><br><span class="line">c.Timeout = time.Millisecond * <span class="number">500</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ParseConfig</code> 很简单，就是将配置文件转换为 struct。</p><p>抓取函数 <code>Scrape</code> 也很简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">collect, err := registerCollector(transport, target, <span class="literal">nil</span>, conf)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> err  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> prometheus.Metric)  </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    collect.Collect(ch)  </span><br><span class="line">    <span class="built_in">close</span>(ch)  </span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>就是构建之前在 <code>nginx exporter</code> 中的 <code>prometheus.Collector</code>，其实代码大部分也是从那边复制过来的。<br><img src="https://s2.loli.net/2024/06/21/4yHQgL1EAiZXwju.png"><br><img src="https://s2.loli.net/2024/06/21/1OloLxpEnbqiaXA.png"><br>所以其实迁移一个 exporter 到 cprobe 中非常简单，只需要：</p><ul><li>定义好需要的配置。</li><li>去掉不需要的代码，比如日志、端口之类的。</li><li>适配好刚才那两个核心函数 <code>ParseConfig/Scrape</code> 即可。</li></ul><p>但这样也有些小问题，现有的一些 exporter 还在迭代，那边更新的版本需要有人及时同步过来。</p><p>除非有一天 cprobe 可以作为一个标准，版本更新都在 cprobe 这边完成，这样就真的是做大做强了。</p><p>不过这些依旧是适配老一代的中间件产品，逐步都会适配现代的可观测体系，这些 exporter 也会逐渐走下历史舞台。</p><p>参考链接：</p><ul><li><a href="https://prometheus.io/docs/instrumenting/exporters/">https://prometheus.io/docs/instrumenting/exporters/</a></li><li><a href="https://github.com/nginxinc/nginx-prometheus-exporter">https://github.com/nginxinc/nginx-prometheus-exporter</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间接到一个需求，希望可以监控 Nginx 的运行状态。&lt;/p&gt;
&lt;p&gt;我们都知道 Nginx 作为一个流行的 Web 服务器提供了多种能力，包括反向代理、负载均衡；也支持了许多协议，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gRPC&lt;/li&gt;
&lt;li&gt;http&lt;/li&gt;
&lt;li&gt;WebSocket 等&lt;br&gt;作为一个流量入口的中间件，对其的监控就显得至关重要了。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="Nginx" scheme="http://crossoverjie.top/tags/Nginx/"/>
    
    <category term="Monitor" scheme="http://crossoverjie.top/tags/Monitor/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统如何做负载均衡</title>
    <link href="http://crossoverjie.top/2024/07/15/ob/Pulsar-loadbalance/"/>
    <id>http://crossoverjie.top/2024/07/15/ob/Pulsar-loadbalance/</id>
    <published>2024-07-15T02:22:14.000Z</published>
    <updated>2024-07-15T14:03:51.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Pulsar 有提供一个查询 Broker 负载的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get load for this broker.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> PulsarAdminException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">LoadManagerReport <span class="title function_">getLoadReport</span><span class="params">()</span> <span class="keyword">throws</span> PulsarAdminException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadManagerReport</span> <span class="keyword">extends</span> <span class="title class_">ServiceLookupData</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getCpu</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getMemory</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getDirectMemory</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getBandwidthIn</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getBandwidthOut</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以返回一些 broker 的负载数据，比如 CPU、内存、流量之类的数据。</p><span id="more"></span><blockquote><p>我目前碰到的问题是目前会遇到部分节点的负债不平衡，导致资源占用不均衡，所以想要手动查询所有节点的负载数据，然后人工进行负载。</p></blockquote><p>理论上这些数据是在运行时实时计算的数据，如果对于单机的倒还好说，每次请求这个接口直接实时计算一次就可以了。</p><p>但对于集群的服务来说会有多个节点，目前 Pulsar 提供的这个接口只能查询指定节点的负载数据，也就是说每次得传入目标节点的 IP 和端口。</p><p><img src="https://s2.loli.net/2024/06/07/ephIgndx54sFlLa.png"></p><p>所以我的预期是可以提供一个查询所有节点负载的接口，已经提了 <code>issue</code>，最近准备写 Purpose 把这个需求解决了。</p><p>实现这个需求的方案有两种：</p><ol><li>拿到所有 broker 也就是服务节点信息，依次遍历调用接口，然后自己组装信息。</li><li>从 zookeeper 中获取负载信息。</li></ol><p>理论上第二种更好，第一种实现虽然更简单，但每次都发起一次 http 请求，多少有些浪费。</p><p>第二种方案直接从源头获取负载信息，只需要请求一次就可以了。</p><p>而正好社区提供了一个命令行工具可以直接打印所有的 <code>broker</code> 负载数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pulsar-perf monitor-brokers --connect-string &lt;zookeeper host:port&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/06/07/UN8gpW915RfcODb.png"></p><h1 id="分布式系统常用组件"><a href="#分布式系统常用组件" class="headerlink" title="分布式系统常用组件"></a>分布式系统常用组件</h1><p>提供的命令行工具其实就是直接从 zookeeper 中查询的数据。</p><p>在分布式系统中需要一个集中的组件来管理各种数据，比如：</p><ol><li>可以利用该组件来选举 leader 节点</li><li>使用该组件来做分布式锁</li><li>为分布式系统同步数据</li><li>统一的存放和读取某些数据</li></ol><p>可以提供该功能的组件其实也不少：</p><ul><li><a href="https://zookeeper.apache.org/">zookeeper</a></li><li><a href="https://etcd.io/">etcd</a></li><li><a href="https://github.com/streamnative/oxia">oxia</a></li></ul><p>Zookeeper 是老牌的分布式协调组件，可以做 leader 选举、配置中心、分布式锁、服务注册与发现等功能。</p><p>在许多中间件和系统中都有应用，比如：</p><ul><li><a href="https://github.com/apache/pulsar">Apache Pulsar</a> 中作为协调中心</li><li><a href="https://github.com/apache/kafka">Kafka</a> 中也有类似的作用。</li><li>在 <a href="https://github.com/apache/dubbo">Dubbo</a> 中作为服务注册发现组件。</li></ul><hr><p>etcd 的功能与 zookeeper 类似，可以用作服务注册发现，也可以作为 Key Value 键值对存储系统；在 kubernetes 中扮演了巨大作用，经历了各种考验，稳定性已经非常可靠了。</p><hr><p><a href="https://github.com/streamnative/oxia">Oxia</a> 则是 StreamNative 开发的一个用于替换 Zookeeper 的中间件，功能也与 Zookeeper 类似；目前已经可以在 Pulsar 中替换 Zookeeper，只是还没有大规模的使用。</p><h1 id="Pulsar-中的应用"><a href="#Pulsar-中的应用" class="headerlink" title="Pulsar 中的应用"></a>Pulsar 中的应用</h1><p>下面以 Pulsar 为例（使用 zookeeper），看看在这类大型分布式系统中是如何处理负载均衡的。</p><p>再开始之前先明确下负载均衡大体上会做哪些事情。</p><ol><li>首先上报自己节点的负载数据</li><li>Leader 节点需要定时收集所有节点的负载数据。<ol><li>这些负载数据中包括：<ol><li><code>CPU</code>、堆内存、堆外内存等通用数据的使用量</li><li>流出、流入流量</li><li>一些系统特有的数据，比如在 <code>Pulsar</code> 中就是：<ol><li>每个 <code>broker</code> 中的 <code>topic</code>、<code>consumer</code>、<code>producer</code>、<code>bundle</code> 等数据。</li></ol></li></ol></li></ol></li><li>再由 leader 节点读取到这些数据后选择负载较高的节点，将数据迁移到负载较低的节点。</li></ol><p>以上就是一个完整的负载均衡的流程，下面我们依次看看在 <code>Pulsar</code> 中是如何实现这些逻辑的。</p><p>在 Pulsar 中提供了多种负载均衡策略，以下是加载负载均衡器的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> LoadManager <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> PulsarService pulsar)</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServiceConfiguration</span> <span class="variable">conf</span> <span class="operator">=</span> pulsar.getConfiguration();  </span><br><span class="line">        <span class="comment">// Assume there is a constructor with one argument of PulsarService.  </span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">loadManagerInstance</span> <span class="operator">=</span> Reflections.createInstance(conf.getLoadManagerClassName(),  </span><br><span class="line">                Thread.currentThread().getContextClassLoader());  </span><br><span class="line">        <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> LoadManager) &#123;  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> (LoadManager) loadManagerInstance;  </span><br><span class="line">            casted.initialize(pulsar);  </span><br><span class="line">            <span class="keyword">return</span> casted;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> ModularLoadManager) &#123;  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModularLoadManagerWrapper</span>((ModularLoadManager) loadManagerInstance);  </span><br><span class="line">            casted.initialize(pulsar);  </span><br><span class="line">            <span class="keyword">return</span> casted;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        LOG.warn(<span class="string">&quot;Error when trying to create load manager: &quot;</span>, e);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// If we failed to create a load manager, default to SimpleLoadManagerImpl.  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleLoadManagerImpl</span>(pulsar);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认使用的是 <code>ModularLoadManagerImpl</code>， 如果出现异常那就会使用 <code>SimpleLoadManagerImpl</code> 作为兜底。</p><p>他们两个的区别是 <code>ModularLoadManagerImpl</code> 的功能更全，可以做更为细致的负载策略。</p><p>接下来以默认的 <code>ModularLoadManagerImpl</code> 为例讲解上述的流程。</p><h2 id="上报负载数据"><a href="#上报负载数据" class="headerlink" title="上报负载数据"></a>上报负载数据</h2><p>在负载均衡器启动的时候就会收集节点数据然后进行上报：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> PulsarServerException &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="type">String</span> <span class="variable">brokerId</span> <span class="operator">=</span> pulsar.getBrokerId();</span><br><span class="line">         brokerZnodePath = LoadManager.LOADBALANCE_BROKERS_ROOT + <span class="string">&quot;/&quot;</span> + brokerId;</span><br><span class="line">         <span class="comment">// 收集本地负载数据</span></span><br><span class="line">         updateLocalBrokerData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上报 zookeeper</span></span><br><span class="line">         brokerDataLock = brokersData.acquireLock(brokerZnodePath, localData).join();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         log.error(<span class="string">&quot;Unable to acquire lock for broker: [&#123;&#125;]&quot;</span>, brokerZnodePath, e);</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PulsarServerException</span>(e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先获取到当前 broker 的 Id 然后拼接一个 zookeeper 节点的路径，将生成的 localData 上传到 zookeeper 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 存放 broker 的节点信息</span><br><span class="line">ls /loadbalance/brokers</span><br><span class="line"></span><br><span class="line">[broker-1:8080, broker-2:8080]</span><br><span class="line"></span><br><span class="line">// 根据节点信息查询负载数据</span><br><span class="line">get /loadbalance/brokers/broker-1:8080</span><br></pre></td></tr></table></figure><p>上报的数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;webServiceUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://broker-1:8080&quot;</span><span class="punctuation">,</span><span class="attr">&quot;pulsarServiceUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;pulsar://broker-1:6650&quot;</span><span class="punctuation">,</span><span class="attr">&quot;persistentTopicsEnabled&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="attr">&quot;nonPersistentTopicsEnabled&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">7.311714728372232</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">800.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;memory&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">124.0</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">2096.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;directMemory&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">36.0</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">256.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;bandwidthIn&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">0.8324254085661579</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">1.0E7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;bandwidthOut&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">0.7155446715644209</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">1.0E7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgRateIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgRateOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;lastUpdate&quot;</span><span class="punctuation">:</span><span class="number">1690979816792</span><span class="punctuation">,</span><span class="attr">&quot;lastStats&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;my-tenant/my-namespace/0x4ccccccb_0x66666664&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;msgRateIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgRateOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;consumerCount&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;producerCount&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;topics&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;cacheSize&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;numTopics&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;numBundles&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;numConsumers&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;numProducers&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;bundles&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;my-tenant/my-namespace/0x4ccccccb_0x66666664&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;lastBundleGains&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;lastBundleLosses&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;brokerVersionString&quot;</span><span class="punctuation">:</span><span class="string">&quot;3.1.0-SNAPSHOT&quot;</span><span class="punctuation">,</span><span class="attr">&quot;protocols&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;advertisedListeners&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;internal&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;brokerServiceUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;pulsar://broker-1:6650&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;loadManagerClassName&quot;</span><span class="punctuation">:</span><span class="string">&quot;org.apache.pulsar.broker.loadbalance.impl.ModularLoadManagerImpl&quot;</span><span class="punctuation">,</span><span class="attr">&quot;startTimestamp&quot;</span><span class="punctuation">:</span><span class="number">1690940955211</span><span class="punctuation">,</span><span class="attr">&quot;maxResourceUsage&quot;</span><span class="punctuation">:</span><span class="number">0.140625</span><span class="punctuation">,</span><span class="attr">&quot;loadReportType&quot;</span><span class="punctuation">:</span><span class="string">&quot;LocalBrokerData&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="采集数据"><a href="#采集数据" class="headerlink" title="采集数据"></a>采集数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SystemResourceUsage <span class="title function_">getSystemResourceUsage</span><span class="params">(<span class="keyword">final</span> BrokerHostUsage brokerHostUsage)</span> &#123;  </span><br><span class="line">    <span class="type">SystemResourceUsage</span> <span class="variable">systemResourceUsage</span> <span class="operator">=</span> brokerHostUsage.getBrokerHostUsage();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Override System memory usage and limit with JVM heap usage and limit  </span></span><br><span class="line">    <span class="type">double</span> <span class="variable">maxHeapMemoryInBytes</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory();  </span><br><span class="line">    <span class="type">double</span> <span class="variable">memoryUsageInBytes</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();  </span><br><span class="line">    <span class="type">double</span> <span class="variable">memoryUsage</span> <span class="operator">=</span> memoryUsageInBytes / MIBI;  </span><br><span class="line">    <span class="type">double</span> <span class="variable">memoryLimit</span> <span class="operator">=</span> maxHeapMemoryInBytes / MIBI;  </span><br><span class="line">    systemResourceUsage.setMemory(<span class="keyword">new</span> <span class="title class_">ResourceUsage</span>(memoryUsage, memoryLimit));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Collect JVM direct memory  </span></span><br><span class="line">    systemResourceUsage.setDirectMemory(<span class="keyword">new</span> <span class="title class_">ResourceUsage</span>((<span class="type">double</span>) (getJvmDirectMemoryUsed() / MIBI),  </span><br><span class="line">            (<span class="type">double</span>) (DirectMemoryUtils.jvmMaxDirectMemory() / MIBI)));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> systemResourceUsage;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会在运行时获取一些 JVM 和 堆外内存的数据。</p><h2 id="收集所有节点数据"><a href="#收集所有节点数据" class="headerlink" title="收集所有节点数据"></a>收集所有节点数据</h2><p>作为 <code>leader</code> 节点还需要收集所有节点的负载数据，然后根据一些规则选择将负载较高的节点移动到负债较低的节点中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateAllBrokerData</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 从 zookeeper 中获取所有节点</span></span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; activeBrokers = getAvailableBrokers();</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, BrokerData&gt; brokerDataMap = loadData.getBrokerData();</span><br><span class="line">    <span class="keyword">for</span> (String broker : activeBrokers) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s/%s&quot;</span>, LoadManager.LOADBALANCE_BROKERS_ROOT, broker);</span><br><span class="line">            <span class="comment">// 依次读取各个节点的负载数据</span></span><br><span class="line">            Optional&lt;LocalBrokerData&gt; localData = brokersData.readLock(key).get();</span><br><span class="line">            <span class="keyword">if</span> (!localData.isPresent()) &#123;</span><br><span class="line">                brokerDataMap.remove(broker);</span><br><span class="line">                log.info(<span class="string">&quot;[&#123;&#125;] Broker load report is not present&quot;</span>, broker);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brokerDataMap.containsKey(broker)) &#123;</span><br><span class="line">                <span class="comment">// Replace previous local broker data.</span></span><br><span class="line">                brokerDataMap.get(broker).setLocalData(localData.get());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Initialize BrokerData object for previously unseen</span></span><br><span class="line">                <span class="comment">// brokers.</span></span><br><span class="line">                <span class="comment">// 将数据写入到本地缓存</span></span><br><span class="line">                brokerDataMap.put(broker, <span class="keyword">new</span> <span class="title class_">BrokerData</span>(localData.get()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Error reading broker data from cache for broker - [&#123;&#125;], [&#123;&#125;]&quot;</span>, broker, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove obsolete brokers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> String broker : brokerDataMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!activeBrokers.contains(broker)) &#123;</span><br><span class="line">            brokerDataMap.remove(broker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会从 zookeeper 的节点中获取到所有的 broker 列表（broker 会在启动时将自身的信息注册到 zookeeper 中。）</p><p>然后依次读取各自节点的负载数据，也就是在负载均衡器启动的时候上报的数据。</p><h2 id="筛选出所有-broker-中需要-unload-的-bundle"><a href="#筛选出所有-broker-中需要-unload-的-bundle" class="headerlink" title="筛选出所有 broker 中需要 unload 的 bundle"></a>筛选出所有 broker 中需要 unload 的 bundle</h2><p>在 Pulsar 中 topic 是最核心的概念，而为了方便管理大量 topic，提出了一个 Bundle 的概念； Bundle 是一批 topic 的集合，管理 Bundle 自然会比 topic 更佳容易。</p><p>所以在 Pulsar 中做负载均衡最主要的就是将负载较高节点中的 bundle 转移到低负载的 broker 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateAllBrokerData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; activeBrokers = getAvailableBrokers();</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, BrokerData&gt; brokerDataMap = loadData.getBrokerData();</span><br><span class="line">    <span class="keyword">for</span> (String broker : activeBrokers) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s/%s&quot;</span>, LoadManager.LOADBALANCE_BROKERS_ROOT, broker);</span><br><span class="line">            Optional&lt;LocalBrokerData&gt; localData = brokersData.readLock(key).get();</span><br><span class="line">            <span class="keyword">if</span> (!localData.isPresent()) &#123;</span><br><span class="line">                brokerDataMap.remove(broker);</span><br><span class="line">                log.info(<span class="string">&quot;[&#123;&#125;] Broker load report is not present&quot;</span>, broker);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brokerDataMap.containsKey(broker)) &#123;</span><br><span class="line">                <span class="comment">// Replace previous local broker data.</span></span><br><span class="line">                brokerDataMap.get(broker).setLocalData(localData.get());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Initialize BrokerData object for previously unseen</span></span><br><span class="line">                <span class="comment">// brokers.</span></span><br><span class="line">                brokerDataMap.put(broker, <span class="keyword">new</span> <span class="title class_">BrokerData</span>(localData.get()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Error reading broker data from cache for broker - [&#123;&#125;], [&#123;&#125;]&quot;</span>, broker, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove obsolete brokers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> String broker : brokerDataMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!activeBrokers.contains(broker)) &#123;</span><br><span class="line">            brokerDataMap.remove(broker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负载均衡器在启动的时候就会查询所有节点的数据，然后写入到 <code>brokerDataMap</code> 中。</p><p><img src="https://s2.loli.net/2024/06/12/ASoLedKVlgRbCFO.png"><br>同时也会注册相关的 zookeeper 事件，当注册的节点发生变化时（一般是新增或者删减了 broker 节点）就会更新内存中缓存的负载数据。</p><p>之后 leader 节点会定期调用 <code>org.apache.pulsar.broker.loadbalance.impl.ModularLoadManagerImpl#doLoadShedding</code> 函数查询哪些数据需要卸载，然后进行重新负载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Multimap&lt;String, String&gt; bundlesToUnload = loadSheddingStrategy.findBundlesForUnloading(loadData, conf);</span><br></pre></td></tr></table></figure><p>最核心的就是调用这个 <code>findBundlesForUnloading</code> 函数，会返回需要卸载 bundle 集合，最终会遍历这个集合调用 admin API 进行卸载和重平衡。</p><p>而这个函数会有多种实现，本质上就是根据传入的各个节点的负载数据，然后根据自定义的规则返回一批需要卸载的数据。</p><p>以默认的 <code>org.apache.pulsar.broker.loadbalance.impl.ThresholdShedder</code> 规则为例：</p><p><img src="https://s2.loli.net/2024/06/12/hg751LtwZMrUyFb.png"><br>它是根据带宽、内存、流量等各个指标的权重算出每个节点的负载值，之后为整个集群计算出一个平均负载值。</p><p>以上图为例：超过 <code>ShedBundles</code> 的数据就需要被卸载掉，然后转移到低负载的节点中。</p><p>所以最左边节点和超出的 bundle 部分就需要被返回。</p><p>具体的计算逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">filterAndSelectBundle</span><span class="params">(LoadData loadData, Map&lt;String, Long&gt; recentlyUnloadedBundles, String broker,</span></span><br><span class="line"><span class="params">                                   LocalBrokerData localData, <span class="type">double</span> minimumThroughputToOffload)</span> &#123;</span><br><span class="line">    <span class="type">MutableDouble</span> <span class="variable">trafficMarkedToOffload</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutableDouble</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">MutableBoolean</span> <span class="variable">atLeastOneBundleSelected</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutableBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">    loadData.getBundleDataForLoadShedding().entrySet().stream()</span><br><span class="line">            .map((e) -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">bundle</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">BundleData</span> <span class="variable">bundleData</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="type">TimeAverageMessageData</span> <span class="variable">shortTermData</span> <span class="operator">=</span> bundleData.getShortTermData();</span><br><span class="line">                <span class="type">double</span> <span class="variable">throughput</span> <span class="operator">=</span> shortTermData.getMsgThroughputIn() + shortTermData.getMsgThroughputOut();</span><br><span class="line">                <span class="keyword">return</span> Pair.of(bundle, throughput);</span><br><span class="line">            &#125;).filter(e -&gt;</span><br><span class="line">                    !recentlyUnloadedBundles.containsKey(e.getLeft())</span><br><span class="line">            ).filter(e -&gt;</span><br><span class="line">                    localData.getBundles().contains(e.getLeft())</span><br><span class="line">            ).sorted((e1, e2) -&gt;</span><br><span class="line">                    Double.compare(e2.getRight(), e1.getRight())</span><br><span class="line">            ).forEach(e -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (trafficMarkedToOffload.doubleValue() &lt; minimumThroughputToOffload</span><br><span class="line">                        || atLeastOneBundleSelected.isFalse()) &#123;</span><br><span class="line">                    selectedBundlesCache.put(broker, e.getLeft());</span><br><span class="line">                    trafficMarkedToOffload.add(e.getRight());</span><br><span class="line">                    atLeastOneBundleSelected.setTrue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码里看的出来就是在一个备选集合中根据各种阈值和判断条件筛选出需要卸载的 bundle。</p><hr><p>而 <code>SimpleLoadManagerImpl</code> 的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (currentLoadReports) &#123;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;ResourceUnit, LoadReport&gt; entry : currentLoadReports.entrySet()) &#123;</span><br><span class="line"><span class="type">ResourceUnit</span> <span class="variable">overloadedRU</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"><span class="type">LoadReport</span> <span class="variable">lr</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"><span class="comment">// 所有数据做一个简单的筛选，超过阈值的数据需要被 unload</span></span><br><span class="line"><span class="keyword">if</span> (isAboveLoadLevel(lr.getSystemResourceUsage(), overloadThreshold)) &#123;</span><br><span class="line"><span class="type">ResourceType</span> <span class="variable">bottleneckResourceType</span> <span class="operator">=</span> lr.getBottleneckResourceType();</span><br><span class="line">Map&lt;String, NamespaceBundleStats&gt; bundleStats = lr.getSortedBundleStats(bottleneckResourceType);</span><br><span class="line"><span class="keyword">if</span> (bundleStats == <span class="literal">null</span>) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;Null bundle stats for bundle &#123;&#125;&quot;</span>, lr.getName());</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是很简单的通过将判断节点的负载是否超过了阈值 <code>isAboveLoadLevel</code>，然后做一个简单的排序就返回了。</p><p>从这里也看得出来 <code>SimpleLoadManagerImpl</code> 和 <code>ModularLoadManager</code> 的区别，<code>SimpleLoadManagerImpl</code> 更简单，并没有提供多个 <code>doLoadShedding</code> 的筛选实现。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说对于无状态的服务来说，理论上我们只需要做好负载算法即可（轮训、一致性哈希、低负载优先等）就可以很好的平衡各个节点之间的负载。</p><p>而对于有状态的服务来说，负载均衡就是将负载较高节点中的数据转移到负载低的节点中。</p><p>其中的关键就是需要存储各个节点的负载数据（业界常用的是存储到 zookeeper 中），然后再由一个 leader 节点从这些节点中根据某种负载算法选择出负载较高的节点以及负载较低的节点，最终把数据迁移过去即可。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Pulsar 有提供一个查询 Broker 负载的接口：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * Get load for this broker.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; PulsarAdminException&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LoadManagerReport &lt;span class=&quot;title function_&quot;&gt;getLoadReport&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; PulsarAdminException;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;LoadManagerReport&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceLookupData&lt;/span&gt; &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getCpu&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getMemory&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getDirectMemory&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getBandwidthIn&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getBandwidthOut&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以返回一些 broker 的负载数据，比如 CPU、内存、流量之类的数据。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/OB/Pulsar/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>🎉我是如何从零到成为 Apache 顶级项目的 Committer</title>
    <link href="http://crossoverjie.top/2024/07/11/ob/%F0%9F%8E%89how-to-be-committer/"/>
    <id>http://crossoverjie.top/2024/07/11/ob/%F0%9F%8E%89how-to-be-committer/</id>
    <published>2024-07-11T15:45:32.000Z</published>
    <updated>2024-07-11T15:46:29.320Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/07/07/bj8NHqYFegTx1WU.png" alt="image.png"><br><img src="https://s2.loli.net/2024/07/07/a86fbuopri9mDeS.png"></p><p>最近收到了 <a href="https://github.com/apache/pulsar/">Apache Pulsar</a> 和 <a href="https://github.com/apache/hertzbeat/">Apache HertzBeat</a>社区的邀请邮件，成为了这两个项目的 <code>Committer</code>。</p><span id="more"></span><p>一路走来我从最开始的打游击战的闲散人员到如今活跃在各个开源项目里的“老兵”，用现在流行的话来说 <code>Apache</code> 的这两个 <code>Committer</code> 就相当于是拿到了编制，进入了正规军。</p><p>下面就分享一下我的个人开源经历，希望对想要参与开源或者已经在其中的开发者有所帮助。</p><h1 id="我的-GitHub-开源故事"><a href="#我的-GitHub-开源故事" class="headerlink" title="我的 GitHub 开源故事"></a>我的 GitHub 开源故事</h1><h2 id="初识-GitHub"><a href="#初识-GitHub" class="headerlink" title="初识 GitHub"></a>初识 GitHub</h2><p><img src="https://s2.loli.net/2024/07/08/CylX9TKcQY12MWI.png"><br>我这个 <code>Github</code> 账号是在 15 年 9月份注册的，那时候刚出来参与工作。</p><p>其实在这之前我压根没有听说过 GitHub、对开源也是知之甚少；只是知道老师和同事经常让我在网上可以下载到一些第三方包（现在回想起来几乎都是好 Apache 的提供的包）来解决日常的一些常见需求。</p><p>当时只是觉得非常方便，没想到大部分的工作互联网上都有相关的解决方案。</p><p>直到第二年也就是 16 年我才提交第一行代码，记得当时是需要和同学共享一些代码。</p><p>在学校的时候大家都是把文件打包然后通过 QQ 发送的，因为我之前在 GitHub 上看到大家都是把源码公开的，所以当时的想法是不是可以直接使用 GitHub 把代码发给同学，这样就省去了打包解压的步骤了。</p><blockquote><p>现在想想还好都是一些非业务代码，不然就违反公司安全规定了。</p></blockquote><p>所以其实自己没有任何开源的概念，只是觉得分享代码很方便。</p><p>后续在网上看了 <code>Richard Matthew Stallman</code> 发起的<a href="https://zh.wikipedia.org/zh-hans/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%BF%90%E5%8A%A8">自由软件运动</a>才对开源的由来有了更多的认识，也越发佩服这些参与开源的大佬们。</p><h2 id="托管-Blog"><a href="#托管-Blog" class="headerlink" title="托管 Blog"></a>托管 Blog</h2><p><img src="https://s2.loli.net/2024/07/08/zhYcH9RmxkpWEA2.png" alt="image.png"><br><img src="https://s2.loli.net/2024/07/08/Cv86gmrlhxoDqBK.png" alt="image.png"></p><p>当时还非常流行在 GitHub 上搭建个人博客，我自然也跟上了这个潮流；直到现在也没有断更。<br>陆续写了 240+ 篇博客。</p><blockquote><p>记得当时最喜欢干的事就是折腾各种主题，可以在 GitHub 免费托管一个博客，对当时的我也是震撼蛮大的。</p></blockquote><p>关于博客的话题还有不少内容可以讲，放到后面继续分享。</p><h2 id="提交第一个项目"><a href="#提交第一个项目" class="headerlink" title="提交第一个项目"></a>提交第一个项目</h2><p><img src="https://s2.loli.net/2024/07/08/NtExsU8Z2ryWdzT.png"><br>因为当时在公司刚开始接触到 SSM(spring+springmvc+mybatis)，所以就想把日常学到的东西沉淀下来。</p><p>于是就把一些非业务代码整理后提交了第一个项目，以更新博客的方式陆续更新了各种解决方案：<br><img src="https://s2.loli.net/2024/07/08/BITYfjNS7oaEpJl.png"><br>至今已经全部更新完毕，所以我就将它归档了。</p><p>这也是我第一次正儿八经做开源项目，在这个过程中也结实到了不少朋友，沉淀了许多内容；对于刚工作一两年的我来说意义还是很重大的。</p><h1 id="参与正规军-Apache"><a href="#参与正规军-Apache" class="headerlink" title="参与正规军(Apache)"></a>参与正规军(Apache)</h1><p>时间点回到现在，因为工作原因我需要在公司内部维护 Pulsar 消息队列；当时 Pulsar 在公司还有着一些细枝末节的问题需要解决。</p><p>在解决这些问题的过程中就想着看能不能给社区贡献些代码，这样也可以更熟悉整个项目。</p><blockquote><p>其实 20 年左右在之前的公司就有使用 Pulsar，只是当时还没有意识到要向社区贡献代码。</p></blockquote><p>于是我先尝试做一些无关紧要的修改：<br><img src="https://s2.loli.net/2024/07/08/WLkOP5KhvBHmg7E.png"><br>因为这个还被大佬拒过几个 PR，与此同时我也在持续输出一个 Pulsar 相关的博客，当时也得到了大佬的认可：<br><img src="https://s2.loli.net/2024/07/08/spUaV8yPZMYbHAe.png"></p><p>之后我又根据日常工作中遇到的一些问题或者优化持续给社区提交 PR：<br><img src="https://s2.loli.net/2024/07/08/LPQ2RSHNotfJclY.png"></p><p>这个过程从第一个 PR 到社区大佬提名我大概经历了一年半的时间。</p><p>越大型、严谨的项目在处理这些 PR 时就是缓慢的，所以如果你真的想深度参与某个项目时就一定要有充分的耐心。</p><p>首先坚持下去，收获自然就来了。</p><hr><h3 id="Apache-HertzBeat"><a href="#Apache-HertzBeat" class="headerlink" title="Apache HertzBeat"></a>Apache HertzBeat</h3><p>今年四月份的时候我在朋友圈还看到另外一个项目：<a href="https://github.com/apache/hertzbeat">Apache HertzBeat</a>。</p><p>因为当时我也在做一些可观测性的内容，正好这个项目是和监控相关的；于是我就跟着文档走了一遍。</p><p>发现功能很强也很全，当时也是刚加入 Apache 的孵化器，所以还是有许多可以完善的地方。</p><p>我就开始以单测作为切入点尝试贡献源码，社区的响应速度也非常快。</p><p>之后逐渐将我在其他社区学到一些经验也复制到 HertzBeat 中，慢慢的贡献的代码越多，对 HertzBeat 也就更加熟悉了。</p><p>两个多月的时间我贡献了 30 个左右的 PR，后来也受到项目发起者的邀请：<br><img src="https://s2.loli.net/2024/07/08/L9SI6rO17TxkDaH.png" alt="image.png"></p><p>因为是相对更年轻的项目，才更需要大家群策群力；所以如果你也对监控系统感兴趣，或者比较熟悉前端技术栈（HertzBeat 有后台管理界面）都欢迎前来贡献，后续获得提名的机会要比已经发展稳定的项目更大一些。</p><h1 id="成为-Committer-的好处"><a href="#成为-Committer-的好处" class="headerlink" title="成为 Committer 的好处"></a>成为 Committer 的好处</h1><p>讲到这里顺便再讲讲成为  Committer 的一些好处了，虽然开源经常和免费白嫖划等号，大部分人都是用爱发电的，但因为也有许多大公司得到了开源的好处，所以也给活跃在社区里的贡献者提供了一些免费福利。</p><p>当然要拿到这些福利肯定是得有一个评判标准，最简单也最直观的就是你是否已经是 Apache 组织的 Committer。</p><h2 id="Github-Copilot"><a href="#Github-Copilot" class="headerlink" title="Github Copilot"></a>Github Copilot</h2><p>首先第一个好处是提供免费个人使用 Copilot，当然这不全是 Committer 的权益，如果你是某个开源项目的活跃贡献者也是可以申请的（不一定能申请过，目前好像没看到通过的标准），只是已经是 Committer 后肯定是能享受这个权益。</p><h2 id="Jetbrains-全家桶-IDE"><a href="#Jetbrains-全家桶-IDE" class="headerlink" title="Jetbrains 全家桶 IDE"></a>Jetbrains 全家桶 IDE</h2><p><img src="https://s2.loli.net/2024/07/08/kc9Ovp1u7M4DxWE.png"></p><p>JB 作为一个和开发者强绑定的公司，也提供了对应的福利，只要使用 Apache 的邮箱就可以免费使用他们的全家桶。</p><h2 id="Apache-邮箱"><a href="#Apache-邮箱" class="headerlink" title="Apache 邮箱"></a>Apache 邮箱</h2><p>提到了邮箱那就不得不提到 Apache 给每个 Committer 都会提供一个专属邮箱：<br><img src="https://s2.loli.net/2024/07/08/TQVkIhbUcAtpfCX.png"><br>虽然市面上有各种的免费邮箱注册服务，但当你使用 Apache 的邮箱和其他人沟通交流时，大概率对方潜意识里都会对你高看一点。</p><p>这虽然是一些虚无缥缈的东西，但有时候就是会让沟通更加顺畅（比如求职面试时）。</p><h2 id="项目的写权限"><a href="#项目的写权限" class="headerlink" title="项目的写权限"></a>项目的写权限</h2><p>还有一个好处就是有了项目的写权限，当你参与过开源项目就知道这个的重要性了，有些时候一些 PR 迟迟得不到回复和合并，自己只能干着急。</p><p>有了这个权限之后，只要你的 PR 有人 <code>Approve</code> 之后，在风险可控的情况下不用等着 maintainer 来合并，自己就可以操作。</p><p>同时得益于在社区的活跃程度，你再提交到 PR 会更得到重视，同时也能更好的推进某些 feature；这对于依赖某个开源项目的公司来说受益非常大。</p><h1 id="Apache-贡献阶梯"><a href="#Apache-贡献阶梯" class="headerlink" title="Apache 贡献阶梯"></a>Apache 贡献阶梯</h1><p>相信看到这里应该有不少人对成为 Apache Committer 感兴趣了，也比较好奇什么样的标准才能成为 Committer。</p><p>以下是我根据一些已经是 Committer 的大佬和 Apache 官方给的一个贡献阶梯作为参考总结出来的。</p><p><img src="https://s2.loli.net/2024/07/08/tlEuhMR85AmLasn.png"></p><p>参与开源的人主要分为以下几种角色：</p><ul><li>普通用户</li><li>贡献者</li><li>Committer</li><li>PMC 项目管理人员</li><li>基金会管理人员</li><li>基金会董事</li></ul><p>整个路径还是比较清晰的，只是从 PMC 开始到后面的董事难度都是指数级增加。</p><blockquote><p>目前整个国内当选过董事的都是屈指可数。</p></blockquote><p>而关于成为 Committer 的要求某些社区会有明显的标准：<br><img src="https://s2.loli.net/2024/07/08/qdfeaXc6gRlF5tN.png"></p><p>当然这个标准也不是一成不变的，只要持续的在社区活跃，有脸熟之后自然会有相关的 PMC 为你提名；当然这里的前提条件都是“持续活跃”。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后再总结下，为爱发电的开源项目也是可以获得回报的；特别是当你合并一个 PR 进入某个项目时带来的愉悦感非常强烈。</p><p>随着时间推进，在之后合并的 PR 可能没有前几次那么强烈，但只要达到一个范围，社区开始提名你为 Committer 时，这个多巴胺又会持续分泌。</p><p>同样的后续成为 PMC、管理人员、董事又会持续带来愉悦，当然难度也一个比一个大。</p><p>后面的层级离我还很远，如果今后有达到的一天再来和大家分享。</p><p>参考链接：</p><ul><li><a href="https://community.apache.org/contributor-ladder.html">https://community.apache.org/contributor-ladder.html</a></li><li><a href="https://hertzbeat.apache.org/zh-cn/docs/community/become_committer">https://hertzbeat.apache.org/zh-cn/docs/community/become_committer</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%BF%90%E5%8A%A8">https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%BF%90%E5%8A%A8</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/07/07/bj8NHqYFegTx1WU.png&quot; alt=&quot;image.png&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/07/07/a86fbuopri9mDeS.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近收到了 &lt;a href=&quot;https://github.com/apache/pulsar/&quot;&gt;Apache Pulsar&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/apache/hertzbeat/&quot;&gt;Apache HertzBeat&lt;/a&gt;社区的邀请邮件，成为了这两个项目的 &lt;code&gt;Committer&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
  </entry>
  
  <entry>
    <title>✅开源项目如何做集成测试</title>
    <link href="http://crossoverjie.top/2024/07/09/ob/%E2%9C%85%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%81%9A%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/"/>
    <id>http://crossoverjie.top/2024/07/09/ob/%E2%9C%85%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%81%9A%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/</id>
    <published>2024-07-09T03:15:25.000Z</published>
    <updated>2024-07-09T03:16:37.821Z</updated>
    
    <content type="html"><![CDATA[<p>之前有朋友问如何做集成测试，今天就重点讲讲这个集成测试在开源项目中是如何做的。</p><p>通常是需要对外提供服务的开源项目都需要集成测试：</p><ul><li>Pulsar</li><li>Kafka</li><li>Dubbo 等<span id="more"></span></li></ul><p>而只提供本地类库的项目通常只需要编写单元测试即可：</p><ul><li>Hutool</li><li>Apache Commmon</li></ul><p>以我接触到的服务型应用主要分为两类：一个是 Java 应用一个是 Golang 应用。</p><h1 id="🐳Golang"><a href="#🐳Golang" class="headerlink" title="🐳Golang"></a>🐳Golang</h1><p>Golang 因为工具链没有 Java 那么强大，所以大部分的集成测试的功能都是通过编写 Makefile 和 shell 脚本实现的。</p><p>还是以我熟悉的 Pulsar 的 go-client 为例，它在 GitHub 的集成测试是通过 GitHub action 触发的，定义如下：<br><img src="https://s2.loli.net/2024/05/20/f2196pujo8m7KRe.png"><br>最终调用的是 Makefile 中的 test 命令，并且把需要测试的 Golang 版本传入进去。</p><p><img src="https://s2.loli.net/2024/05/20/YpwtSHnLXqU1xQj.png"></p><p><code>Dockerfile</code>：<br><img src="https://s2.loli.net/2024/05/20/1ySGWF46U7EC2rk.png"></p><p>这个镜像简单来说就是将 Pulsar 的镜像作为基础运行镜像（这里面包含了 Pulsar 的服务端），然后将这个 pulsar-client-go 的代码复制进去编译。</p><p>接着运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /pulsar/pulsar-client-go &amp;&amp; ./scripts/run-ci.sh</span><br></pre></td></tr></table></figure><p>也就是测试脚本。</p><p><img src="https://s2.loli.net/2024/05/20/2Afmdu8ozRvH9FC.png"></p><p>测试脚本的逻辑也很简单：</p><ul><li>启动 pulsar 服务端</li><li>运行测试代码<br>因为所有的测试代码里连接服务端的地址都是 <code>localhost</code>，所以可以直接连接。<br><img src="https://s2.loli.net/2024/05/20/C1RHxTkuz25Mlj8.png"></li></ul><p>通过这里的 <a href="https://github.com/apache/pulsar-client-go/actions/runs/9014510238/job/24768797555">action</a> 日志可以跟踪所有的运行情况。</p><h1 id="☕Java"><a href="#☕Java" class="headerlink" title="☕Java"></a>☕Java</h1><p>Java 因为工具链强大，所以集成测试几乎不需要用 Makefile 和脚本配合执行。</p><p>还是以 Pulsar 为例，它的集成测试是需要模拟在本地启动一个服务端，然后再运行测试代码。</p><blockquote><p>这个的好处是任何一个单测都可以在本地直接运行，而  Go 的代码还需要先在本地启动一个服务端，测试起来比较麻烦。</p></blockquote><p>来看看它是如何实现的，我以其中一个 <a href="https://github.com/apache/pulsar/blob/631b13ad23d7e48c6e82d38f97c23d129062cb7c/pulsar-broker/src/test/java/org/apache/pulsar/client/impl/BrokerClientIntegrationTest.java#L117">BrokerClientIntegrationTest</a>为例：<br><img src="https://s2.loli.net/2024/05/20/9PbioA3RQLMBy6J.png"><br><img src="https://s2.loli.net/2024/05/20/blKePdxTUIkgRD3.png"><br>会在单测启动的时候先启动服务端。</p><p><img src="https://s2.loli.net/2024/05/20/gzY3lyTGuEDUwZF.png"></p><p>最终会调用 PulsarTestContext 的 build 函数启动 broker（服务端），而执行单测也只需要使用 mvn 就可以自动触发这些单元测试。<br><img src="https://s2.loli.net/2024/05/20/N15amZihWI73Qyw.png"><br>只是每一个单测都需要启停服务端，所以要把 Pulsar 的所有单测跑完通常需要 1～2 个小时。</p><p>所以这些集成测试本质上都是先要把测试环境构建出来，再跑对应的测试代码；后续也打算给 <a href="https://github.com/crossoverJie/cim">cim</a> 加上集成测试实操一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前有朋友问如何做集成测试，今天就重点讲讲这个集成测试在开源项目中是如何做的。&lt;/p&gt;
&lt;p&gt;通常是需要对外提供服务的开源项目都需要集成测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pulsar&lt;/li&gt;
&lt;li&gt;Kafka&lt;/li&gt;
&lt;li&gt;Dubbo 等</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
  </entry>
  
  <entry>
    <title>从 Helm 到 Operator：Kubernetes应用管理的进化</title>
    <link href="http://crossoverjie.top/2024/07/08/ob/how-operator-working/"/>
    <id>http://crossoverjie.top/2024/07/08/ob/how-operator-working/</id>
    <published>2024-07-08T03:19:51.000Z</published>
    <updated>2024-07-07T07:45:26.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🧰Helm-的作用"><a href="#🧰Helm-的作用" class="headerlink" title="🧰Helm 的作用"></a>🧰Helm 的作用</h1><p>在开始前需要先对 kubernetes  Operator 有个简单的认识。</p><p>以为我们在编写部署一些简单 <code>Deployment</code> 的时候只需要自己编写一个 yaml 文件然后 <code>kubectl apply</code> 即可。</p><span id="more"></span><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">  <span class="attr">template:</span>  </span><br><span class="line">    <span class="attr">metadata:</span>  </span><br><span class="line">      <span class="attr">labels:</span>  </span><br><span class="line">        <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">    <span class="attr">spec:</span>  </span><br><span class="line">      <span class="attr">containers:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">          <span class="attr">image:</span> <span class="string">crossoverjie/k8s-combat:v1</span>  </span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span>  </span><br><span class="line">          <span class="attr">resources:</span>  </span><br><span class="line">            <span class="attr">limits:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">300Mi</span>  </span><br><span class="line">            <span class="attr">requests:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;0.1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">30Mi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f deployment.yaml</span><br></pre></td></tr></table></figure><p>这对于一些并不复杂的项目来说完全够用了，但组件一多就比较麻烦了。</p><p><img src="https://s2.loli.net/2024/06/01/9EtzrfIAvcXm4aJ.png"><br>这里以 Apache Pulsar 为例：它的核心组件有:</p><ul><li>Broker</li><li>Proxy</li><li>Zookeeper</li><li>Bookkeeper</li><li>Prometheus(可选)</li><li>Grafana(可选)<br>等组件，每个组件的启动还有这依赖关系。<blockquote><p>必须需要等 Zookeeper 和 Bookkeeper 启动之后才能将流量放进来。</p></blockquote></li></ul><p>此时如何还继续使用 yaml 文件一个个部署就会非常繁琐，好在社区有提供 Helm 一键安装程序，使用它我们只需要在一个同意的 yaml 里简单的配置一些组件，配置就可以由 helm 来部署整个复杂的 Pulsar 系统。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">components:</span>  </span><br><span class="line">  <span class="comment"># zookeeper  </span></span><br><span class="line">  <span class="attr">zookeeper:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># bookkeeper  </span></span><br><span class="line">  <span class="attr">bookkeeper:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># bookkeeper - autorecovery  </span></span><br><span class="line">  <span class="attr">autorecovery:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># broker  </span></span><br><span class="line">  <span class="attr">broker:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># functions  </span></span><br><span class="line">  <span class="attr">functions:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="comment"># proxy  </span></span><br><span class="line">  <span class="attr">proxy:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># toolset  </span></span><br><span class="line">  <span class="attr">toolset:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># pulsar manager  </span></span><br><span class="line">  <span class="attr">pulsar_manager:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">monitoring:</span>  </span><br><span class="line">  <span class="comment"># monitoring - prometheus  </span></span><br><span class="line">  <span class="attr">prometheus:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># monitoring - grafana  </span></span><br><span class="line">  <span class="attr">grafana:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># monitoring - node_exporter  </span></span><br><span class="line">  <span class="attr">node_exporter:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># alerting - alert-manager  </span></span><br><span class="line">  <span class="attr">alert_manager:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>比如在 helm 的 yaml 中我们可以选择使用哪些 components，以及是否启用监控组件。</p><p>最后直接使用这个文件进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">helm install pulsar apache/pulsar \</span><br><span class="line">--values charts/pulsar/values.yaml \</span><br><span class="line">--<span class="built_in">set</span> namespace=pulsar \</span><br><span class="line">    --<span class="built_in">set</span> initialize=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>它就会自动生成各个组件的 yaml 文件，然后统一执行。</p><p>所以 helm 的本质上和 <code>kubectl apply yaml</code> 一样的，只是我们在定义 value.yaml 时帮我们处理了许多不需要用户低频修改的参数。</p><p>我们可以使用 helm 将要执行的 yaml 输出后人工审核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install pulsar apache/pulsar --dry-run --debug &gt; debug.yaml</span><br></pre></td></tr></table></figure><h1 id="🤔Operator-是什么"><a href="#🤔Operator-是什么" class="headerlink" title="🤔Operator 是什么"></a>🤔Operator 是什么</h1><h2 id="💔Helm-的痛点"><a href="#💔Helm-的痛点" class="headerlink" title="💔Helm 的痛点"></a>💔Helm 的痛点</h2><p>Helm 虽然可以帮我们部署或者升级一个大型应用，但他却没法帮我们运维这个应用。</p><p>举个例子：比如我希望当 Pulsar Broker 的流量或者内存达到某个阈值后就指定扩容 Broker，闲时再自动回收。</p><p>或者某个 Bookkeeper 的磁盘使用率达到阈值后可以自动扩容磁盘，这些仅仅使用 Helm 时都是无法实现的。</p><p>以上这些需求我们目前也是通过监控系统发出报警，然后再由人工处理。</p><p>其中最大的痛点就是进行升级：</p><ul><li>升级ZK</li><li>关闭auto recovery</li><li>升级Bookkeeper</li><li>升级Broker</li><li>升级Proxy</li><li>开启auto recovery</li></ul><p>因为每次升级是有先后顺序的，需要依次观察每个组件运行是否正常才能往后操作。</p><p>如果有 Operator 理性情况下下我们只需要更新一下镜像版本，它就可以自动执行以上的所有步骤最后将集群升级完毕。</p><p>所以相对于 Helm 来说 Operator 是可以站在一个更高的视角俯视整个应用系统，它能发现系统哪个地方需要它从而直接修复。</p><h2 id="💎CRD-Custom-Resource-Definitions"><a href="#💎CRD-Custom-Resource-Definitions" class="headerlink" title="💎CRD(Custom Resource Definitions)"></a>💎CRD(Custom Resource Definitions)</h2><p>而提到 Operator 那就不得不提到 CRD(Custom Resource Definitions)翻译过来就是自定义资源。</p><p>这是 kubernetes 提供的一个 API 扩展机制，类似于内置的 <code>Deployment/StatefulSet/Services</code> 资源，CRD 是一种自定义的资源。</p><p>这里以我们常用的 <code>prometheus-operator</code> 和 <code>VictoriaMetrics-operator</code> 为例：</p><p>Prometheus：</p><ul><li>**<code>Prometheus</code>**：用于定义 Prometheus 的 Deployment</li><li>**<code>Alertmanager</code>**：用于定义 <strong><code>Alertmanager</code></strong></li><li>**<code>ScrapeConfig</code>**：用于定会抓取规则</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">monitoring.coreos.com/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ScrapeConfig</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">static-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">my-namespace</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">prometheus:</span> <span class="string">system-monitoring-prometheus</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">staticConfigs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">job:</span> <span class="string">prometheus</span></span><br><span class="line">      <span class="attr">targets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">prometheus.demo.do.prometheus.io:9090</span></span><br></pre></td></tr></table></figure><p>使用时的一个很大区别就是资源的 <code>kind: ScrapeConfig</code> 为自定义的类型。</p><p>VictoriaMetrics 的 CRD：</p><ul><li>VMPodScrape：Pod 的抓取规则</li><li>VMCluster：配置 VM 集群</li><li>VMAlert：配置 VM 的告警规则</li><li>等等</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vmcluster.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">operator.victoriametrics.com/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VMCluster</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">retentionPeriod:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">  <span class="attr">replicationFactor:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">vmstorage:</span></span><br><span class="line">    <span class="attr">replicaCount:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">storageDataPath:</span> <span class="string">&quot;/vm-data&quot;</span></span><br><span class="line">    <span class="attr">storage:</span></span><br><span class="line">      <span class="attr">volumeClaimTemplate:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">storage:</span> <span class="string">&quot;10Gi&quot;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">  <span class="attr">vmselect:</span></span><br><span class="line">    <span class="attr">replicaCount:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">cacheMountPath:</span> <span class="string">&quot;/select-cache&quot;</span></span><br><span class="line">    <span class="attr">storage:</span></span><br><span class="line">      <span class="attr">volumeClaimTemplate:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">storage:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;0.5&quot;</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;500Mi&quot;</span></span><br><span class="line">  <span class="attr">vminsert:</span></span><br><span class="line">    <span class="attr">replicaCount:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>以上是用于创建一个 VM 集群的 CRD 资源，应用之后就会自动创建一个集群。</p><h1 id="Operator-原理"><a href="#Operator-原理" class="headerlink" title="Operator 原理"></a>Operator 原理</h1><p><img src="https://s2.loli.net/2024/06/01/t4ZnXcS9wokMPER.png"><br>Operator 通常是运行在 kubernetes API server 的 <code>webhook</code> 之上，简单来说就是在一些内置资源的关键节点 API-server 会调用我们注册的一个 <code>webhook</code>，在这个 <code>webhook</code> 中我们根据我们的 CRD 做一些自定义的操作。</p><p>理论上我们可以使用任何语言都可以写 Operator，只需要能处理 api-server 的回调即可。</p><p>只是 Go 语言有很多成熟的工具，比如常用的 <a href="https://kubebuilder.io/">kubebuilder</a> 和 <a href="https://sdk.operatorframework.io/">operator-sdk</a>.</p><p>他们内置了许多命令行工具，可以帮我们节省需要工作量。</p><p>这里以 operator-sdk 为例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ operator-sdk create webhook --group cache --version v1alpha1 --kind Memcached --defaulting --programmatic-validation</span><br></pre></td></tr></table></figure><p>会直接帮我们创建好一个标准的 operator 项目:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├── Dockerfile</span><br><span class="line">├── Makefile</span><br><span class="line">├── PROJECT</span><br><span class="line">├── api</span><br><span class="line">│   └── v1alpha1</span><br><span class="line">│       ├── memcached_webhook.go</span><br><span class="line">│       ├── webhook_suite_test.go</span><br><span class="line">├── config</span><br><span class="line">│   ├── certmanager</span><br><span class="line">│   │   ├── certificate.yaml</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── kustomizeconfig.yaml</span><br><span class="line">│   ├── default</span><br><span class="line">│   │   ├── manager_webhook_patch.yaml</span><br><span class="line">│   │   └── webhookcainjection_patch.yaml</span><br><span class="line">│   └── webhook</span><br><span class="line">│       ├── kustomization.yaml</span><br><span class="line">│       ├── kustomizeconfig.yaml</span><br><span class="line">│       └── service.yaml</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── main.go</span><br></pre></td></tr></table></figure><p>其中 Makefile 中包含了开发过程中常用的工具链（包括根据声明的结构体自动生成 CRD 资源、部署k8s 环境测试等等）、Dockerfile 等等。</p><p>这样我们就只需要专注于开发业务逻辑即可。</p><p>因为我前段时间给 <a href="https://github.com/open-telemetry/opentelemetry-operator">https://github.com/open-telemetry/opentelemetry-operator</a> 贡献过两个 feature，所以就以这个 Operator 为例：</p><p>它有一个 CRD: <code>kind: Instrumentation</code>，在这个 CRD 中可以将 OpenTelemetry 的 agent 注入到应用中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">opentelemetry.io/v1alpha1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Instrumentation</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">instrumentation-test-order</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">env:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_SERVICE_NAME</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">order</span></span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">order</span>  </span><br><span class="line">  <span class="attr">java:</span>  </span><br><span class="line">    <span class="attr">image:</span> <span class="string">autoinstrumentation-java:2.4.0-release</span>  </span><br><span class="line">    <span class="attr">extensions:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">autoinstrumentation-java:2.4.0-release</span>  </span><br><span class="line">        <span class="attr">dir:</span> <span class="string">/extensions</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="attr">env:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_RESOURCE_ATTRIBUTES</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">service.name=order</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_INSTRUMENTATION_MESSAGING_EXPERIMENTAL_RECEIVE_TELEMETRY_ENABLED</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_TRACES_EXPORTER</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">otlp</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_METRICS_EXPORTER</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">otlp</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_LOGS_EXPORTER</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">none</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXPORTER_OTLP_ENDPOINT</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">http://open-telemetry-opentelemetry-collector.otel.svc.cluster.local:4317</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXPORTER_OTLP_COMPRESSION</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">gzip</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXPERIMENTAL_EXPORTER_OTLP_RETRY_ENABLED</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure><p>它的运行规则是当我们的 Pod 在启动过程中会判断 Pod 的注解中是否开启了注入 OpenTelemetry 的配置。</p><p>如果开启则会将我们在 CRD 中自定义的镜像里的 javaagent 复制到业务容器中，同时会将下面的那些环境变量也一起加入的业务容器中。</p><p>要达到这样的效果就需要我们注册一个回调 endpoint。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mgr.GetWebhookServer().Register(<span class="string">&quot;/mutate-v1-pod&quot;</span>, &amp;webhook.Admission&#123;  </span><br><span class="line">    Handler: podmutation.NewWebhookHandler(cfg, ctrl.Log.WithName(<span class="string">&quot;pod-webhook&quot;</span>), decoder, mgr.GetClient(),  </span><br><span class="line">       []podmutation.PodMutator&#123;  </span><br><span class="line">          sidecar.NewMutator(logger, cfg, mgr.GetClient()),  </span><br><span class="line">          instrumentation.NewMutator(logger, mgr.GetClient(), mgr.GetEventRecorderFor(<span class="string">&quot;opentelemetry-operator&quot;</span>), cfg),  </span><br><span class="line">       &#125;),&#125;)</span><br></pre></td></tr></table></figure><p>当 Pod 创建或有新的变更请求时就会回调我们的接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *instPodMutator)</span></span> Mutate(ctx context.Context, ns corev1.Namespace, pod corev1.Pod) (corev1.Pod, <span class="type">error</span>) &#123;  </span><br><span class="line">    logger := pm.Logger.WithValues(<span class="string">&quot;namespace&quot;</span>, pod.Namespace, <span class="string">&quot;name&quot;</span>, pod.Name)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这个接口中我们就可以拿到 Pod 的信息，然后再获取 CRD <code>Instrumentation</code> 做我们的业务逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> otelInsts v1alpha1.InstrumentationList  </span><br><span class="line"><span class="keyword">if</span> err := pm.Client.List(ctx, &amp;otelInsts, client.InNamespace(ns.Name)); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 CRD 中将数据复制到业务容器中。</span></span><br><span class="line">pod.Spec.InitContainers = <span class="built_in">append</span>(pod.Spec.InitContainers, corev1.Container&#123;</span><br><span class="line">Name:      javaInitContainerName,</span><br><span class="line">Image:     javaSpec.Image,</span><br><span class="line">Command:   []<span class="type">string</span>&#123;<span class="string">&quot;cp&quot;</span>, <span class="string">&quot;/javaagent.jar&quot;</span>, javaInstrMountPath + <span class="string">&quot;/javaagent.jar&quot;</span>&#125;,</span><br><span class="line">Resources: javaSpec.Resources,</span><br><span class="line">VolumeMounts: []corev1.VolumeMount&#123;&#123;</span><br><span class="line">Name:      javaVolumeName,</span><br><span class="line">MountPath: javaInstrMountPath,</span><br><span class="line">&#125;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, extension := <span class="keyword">range</span> javaSpec.Extensions &#123;</span><br><span class="line">pod.Spec.InitContainers = <span class="built_in">append</span>(pod.Spec.InitContainers, corev1.Container&#123;</span><br><span class="line">Name:      initContainerName + fmt.Sprintf(<span class="string">&quot;-extension-%d&quot;</span>, i),</span><br><span class="line">Image:     extension.Image,</span><br><span class="line">Command:   []<span class="type">string</span>&#123;<span class="string">&quot;cp&quot;</span>, <span class="string">&quot;-r&quot;</span>, extension.Dir + <span class="string">&quot;/.&quot;</span>, javaInstrMountPath + <span class="string">&quot;/extensions&quot;</span>&#125;,</span><br><span class="line">Resources: javaSpec.Resources,</span><br><span class="line">VolumeMounts: []corev1.VolumeMount&#123;&#123;</span><br><span class="line">Name:      javaVolumeName,</span><br><span class="line">MountPath: javaInstrMountPath,</span><br><span class="line">&#125;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不过需要注意的是想要在测试环境中测试 operator 是需要安装一个 <a href="https://kubebuilder.io/quick-start">cert-manage</a>，这样 <code>webhook</code> 才能正常的回调。</p></blockquote><p><img src="https://s2.loli.net/2024/06/01/IUjriqye6EMFCT8.png"><br>要使得 CRD 生效，我们还得先将 CRD 安装进 kubernetes 集群中，不过这些 operator-sdk 这类根据已经考虑周到了。</p><p>我们只需要定义好 CRD 的结构体：<br><img src="https://s2.loli.net/2024/06/01/RBKp15lhkHsbeEY.png"></p><p>然后使用 Makefile 中的工具 <code>make bundle</code> 就会自动将结构体转换为 CRD。</p><p>参考链接：</p><ul><li><a href="https://github.com/VictoriaMetrics/operator">https://github.com/VictoriaMetrics/operator</a></li><li><a href="https://github.com/prometheus-operator/prometheus-operator">https://github.com/prometheus-operator/prometheus-operator</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;🧰Helm-的作用&quot;&gt;&lt;a href=&quot;#🧰Helm-的作用&quot; class=&quot;headerlink&quot; title=&quot;🧰Helm 的作用&quot;&gt;&lt;/a&gt;🧰Helm 的作用&lt;/h1&gt;&lt;p&gt;在开始前需要先对 kubernetes  Operator 有个简单的认识。&lt;/p&gt;
&lt;p&gt;以为我们在编写部署一些简单 &lt;code&gt;Deployment&lt;/code&gt; 的时候只需要自己编写一个 yaml 文件然后 &lt;code&gt;kubectl apply&lt;/code&gt; 即可。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="kubernetes" scheme="http://crossoverjie.top/categories/OB/kubernetes/"/>
    
    <category term="kubernetes" scheme="http://crossoverjie.top/categories/OB/kubernetes/kubernetes/"/>
    
    
    <category term="kubernetes" scheme="http://crossoverjie.top/tags/kubernetes/"/>
    
    <category term="Operator" scheme="http://crossoverjie.top/tags/Operator/"/>
    
  </entry>
  
  <entry>
    <title>【译】五个我最近在 Go 里学到的小技巧</title>
    <link href="http://crossoverjie.top/2024/07/02/ob/go-5-tips/"/>
    <id>http://crossoverjie.top/2024/07/02/ob/go-5-tips/</id>
    <published>2024-07-02T10:42:39.000Z</published>
    <updated>2024-07-02T11:11:48.928Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://medium.com/@andreiboar/5-small-tips-i-recently-learned-in-go-cf52d50cf129">https:&#x2F;&#x2F;medium.com&#x2F;@andreiboar&#x2F;5-small-tips-i-recently-learned-in-go-cf52d50cf129</a></p><h1 id="让编译器计算数组数量"><a href="#让编译器计算数组数量" class="headerlink" title="让编译器计算数组数量"></a>让编译器计算数组数量</h1><p>我们在 Go 通常很少使用数组 arrays，一般使用切片 Slice 来代替；</p><p>但是当你需要使用的时候，如果你对需要指定数量大小感到很烦时可以使用 <code>[...]</code> 让编译器自动帮我们计算数组大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  </span><br><span class="line">sameArr := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// Use ... instead of 3  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Arrays are equivalent  </span></span><br><span class="line">fmt.Println(arr)  </span><br><span class="line">fmt.Println(sameArr)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="使用-go-run-替换-go-run-main-go"><a href="#使用-go-run-替换-go-run-main-go" class="headerlink" title="使用 go run . 替换 go run main.go"></a>使用 go run . 替换 go run main.go</h1><p>每当我用 Go 写第一行代码时，我都习惯于开始写 <code>main.go</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>但是当 <code>main.go</code> 变得越来越大时，我喜欢把一些结构体移动到新的文件里，还是在 main 这个包中。</p><p>main.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">sayHello()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>say_hello.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;  </span><br><span class="line">fmt.Println(<span class="string">&quot;Hello!&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时使用 <code>go run main.go</code> 将会得到以下的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">command-line-arguments</span>  </span><br><span class="line">./main.go:4:2: undefined: sayHello</span><br></pre></td></tr></table></figure><p>此时可以使用 <code>go run .</code> 来解决这个问题。</p><h1 id="使用下划线让你的数字变得更易读"><a href="#使用下划线让你的数字变得更易读" class="headerlink" title="使用下划线让你的数字变得更易读"></a>使用下划线让你的数字变得更易读</h1><p>你知道可以使用下划线使得你的长数字更易读吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    number := <span class="number">10000000</span></span><br><span class="line">    better := <span class="number">10</span>_000_000</span><br><span class="line"></span><br><span class="line">    fmt.Println(number == better)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="可以在同一个包下有不同的测试包"><a href="#可以在同一个包下有不同的测试包" class="headerlink" title="可以在同一个包下有不同的测试包"></a>可以在同一个包下有不同的测试包</h1><p>在 Go 中我通常认为一个目录下只能有一个包，但也不是完全正确的。</p><p>假设你有一个包名为：<code>yourpackage</code> 此时你可以还可以在同一个目录下创建一个名为 <code>yourpackage_test</code> 的包，同时在这个包里编写你的测试代码。</p><p>这样做的好处是，那些没有被 exporter 的函数在 <code>yourpackage_test</code> 包下是不能直接访问的，确保测试的是被暴露的函数。</p><h1 id="多次传递相同参数的简单方法"><a href="#多次传递相同参数的简单方法" class="headerlink" title="多次传递相同参数的简单方法"></a>多次传递相同参数的简单方法</h1><p>在使用字符串格式化函数时，我总是觉得必须重复一个多次使用的参数很烦人：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Bob&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;My name is %s. Yes, you heard that right: %s\n&quot;</span>, name, name)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>还好还有更简便的方法，这样只需要传递一次参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">name := <span class="string">&quot;Bob&quot;</span>  </span><br><span class="line">fmt.Printf(<span class="string">&quot;My name is %[1]s. Yes, you heard that right: %[1]s\n&quot;</span>, name)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 Twitter 里发现的：<br><img src="https://s2.loli.net/2024/07/02/vaMP9CXwTEFcGKI.png"></p><p>希望你今天学到了一些新东西，最近有没有发现一些你从来不知道的 Golang 小技巧？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文链接：&lt;a href=&quot;https://medium.com/@andreiboar/5-small-tips-i-recently-learned-in-go-cf52d50cf129&quot;&gt;https:&amp;#x2F;&amp;#x2F;medium.com&amp;#x2F;@andreiboar&amp;#x2F;5-small-tips-i-recently-learned-in-go-cf52d50cf129&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;让编译器计算数组数量&quot;&gt;&lt;a href=&quot;#让编译器计算数组数量&quot; class=&quot;headerlink&quot; title=&quot;让编译器计算数组数量&quot;&gt;&lt;/a&gt;让编译器计算数组数量&lt;/h1&gt;&lt;p&gt;我们在 Go 通常很少使用数组 arrays，一般使用切片 Slice 来代替；&lt;/p&gt;
&lt;p&gt;但是当你需要使用的时候，如果你对需要指定数量大小感到很烦时可以使用 &lt;code&gt;[...]&lt;/code&gt; 让编译器自动帮我们计算数组大小：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr := [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sameArr := [...]&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125; &lt;span class=&quot;comment&quot;&gt;// Use ... instead of 3  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Arrays are equivalent  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fmt.Println(arr)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fmt.Println(sameArr)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="翻译" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="Go" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/Go/"/>
    
    
    <category term="Go" scheme="http://crossoverjie.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>如何找到并快速上手一个开源项目</title>
    <link href="http://crossoverjie.top/2024/07/01/ob/how-to-involve-OpenSource/"/>
    <id>http://crossoverjie.top/2024/07/01/ob/how-to-involve-OpenSource/</id>
    <published>2024-07-01T02:55:00.000Z</published>
    <updated>2024-07-31T02:19:26.123Z</updated>
    
    <content type="html"><![CDATA[<p>以前有写过两篇文章来简单聊过如何做开源的事情，最近我自己组了一个社区里面也有不少朋友对开源感兴趣，于是我便根据自己的经验系统的梳理了一些关于开源的事情。</p><ul><li><a href="https://crossoverjie.top/2023/08/05/ob/novice-contribute-open-source/">新手如何快速参与开源项目</a></li><li><a href="https://crossoverjie.top/2024/01/25/ob/create-a-plugin-for-cprobe/">手把手教你为开源项目贡献代码</a></li></ul><blockquote><p>有兴趣的可以先看看之前这两篇。</p></blockquote><span id="more"></span><h1 id="🔎如何找到自己感兴趣的开源项目"><a href="#🔎如何找到自己感兴趣的开源项目" class="headerlink" title="🔎如何找到自己感兴趣的开源项目"></a>🔎如何找到自己感兴趣的开源项目</h1><p>首先第一步先想清楚自己搞开源的目的是什么：</p><ul><li>参考社区大佬的代码，提升技术</li><li>丰富个人履历，提高面试通过率<ul><li>更功利一点就是想成为某个项目的 <code>Committer</code>&#x2F;<code>PMC</code></li></ul></li><li>单纯喜欢分享，热爱开源，认可开源改变世界💪。</li></ul><p>我认为前面三种都是一个目的，提升自己获得后续的好处；最后一种则是妥妥的纯热爱。</p><p>以我个人来说，我两者都沾一点；我相信大部分人都是前面三类的目的，到这里我可能要先浇点冷水。</p><blockquote><p>往往一个开源项目从你熟悉它开始到提第一个 PR 然后到合并中间经历的时间可能是大大超出你的预期的。</p></blockquote><p>特别是越大型越专业的项目（我相信你也是想加入这类有一定知名度的项目）。</p><p>因为开源社区大部分都是执行异步沟通，与即时通讯的快速反馈不同，甚至还有不少 reviewer 处于不同的时区。</p><p>所以一开始就想做好心理预期，不要指望着我给某个项目提交一个很牛逼的功能，然后他们快速 review 合并，然后给你 commit 权限。</p><p>而且有不少开源项目是由某一个公司主导的，比如（Pulsar、Golang、Kafka），他们可能对于外部社区来的新手并不那么上心，一个 PR 晾在那里几个月没人理都是很正常的。</p><p>所以我建议一开始选择的项目有以下几个筛选标准：</p><ul><li>尽量是自己日常在用，熟悉的项目。</li><li>最近有在及时更新维护的项目。</li><li>对社区新人的接纳程度是否足够包容。<ul><li>这点可以在 Github 里查找标签为 <code>help want/contribution welcome</code> 的 issue 或者是 PR。</li><li>查看这些 issue&#x2F; PR 最近的活跃时间，贡献者是否为新人。</li><li>往往一个包容度较高的项目以上信息都是很活跃的。</li></ul></li><li>项目主要维护者是否来着不同的公司，是否足够活跃。</li></ul><p><img src="https://s2.loli.net/2024/05/25/PIL8a5CoMbxRiwJ.png"><br><img src="https://s2.loli.net/2024/05/25/7CQaVFiAR4tyMbs.png"></p><p>推荐几个我认为比较符合我刚才提到的条件的项目：</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/7195">https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/7195</a></li><li><a href="https://github.com/apache/pulsar-client-go/issues?q=is:open+label:type/feature+sort:updated-desc">https://github.com/apache/pulsar-client-go/issues?q=is%3Aopen+label%3Atype%2Ffeature+sort%3Aupdated-desc</a></li><li><a href="https://github.com/apache/hertzbeat/">https://github.com/apache/hertzbeat/</a></li></ul><h1 id="🖐如何快速上手一个开源项目"><a href="#🖐如何快速上手一个开源项目" class="headerlink" title="🖐如何快速上手一个开源项目"></a>🖐如何快速上手一个开源项目</h1><p>如果找到了自己想贡献的项目，如果自己还不太熟悉的话，那就可以尝试以下步骤来快速上手它。</p><h2 id="✅单元测试"><a href="#✅单元测试" class="headerlink" title="✅单元测试"></a>✅单元测试</h2><p>首先第一个就是单元测试，单元测试是一个非常不错的方式来上手一个新的开源项目，<strong>但重点不是去看现有的单测，而是自己去写✍️</strong>。</p><p>写过单元测试的小伙伴就知道，如果要达到 90% 以上的覆盖率时需要对自己写的每一行代码都得了解，甚至在写的过程中会发现部分代码是不是没有必要，从而再帮助自己梳理一遍业务。</p><p>所以写单测确实是快速熟悉某个项目的方法，但这针对于一些逻辑简单的项目；对于一些业务复杂的项目建议还是快速跑通官方推荐一个功能。</p><h2 id="🌟以-Pulsar-为例"><a href="#🌟以-Pulsar-为例" class="headerlink" title="🌟以 Pulsar 为例"></a>🌟以 Pulsar 为例</h2><p>以 <a href="https://pulsar.apache.org/">Apache Pulsar</a>为例，那就先跑一个消息的生产者和消费者 demo；跑通了之后再尝试看看它客户端已有的单测代码，然后尝试改一些断言，此时就会发现预期值为什么会这么定义。<br><a href="https://github.com/apache/pulsar/blob/631b13ad23d7e48c6e82d38f97c23d129062cb7c/pulsar-broker/src/test/java/org/apache/pulsar/client/impl/BrokerClientIntegrationTest.java#L1077">https://github.com/apache/pulsar/blob/631b13ad23d7e48c6e82d38f97c23d129062cb7c/pulsar-broker/src/test/java/org/apache/pulsar/client/impl/BrokerClientIntegrationTest.java#L1077</a><br><img src="https://s2.loli.net/2024/05/17/CrITHSWeY1sP8dL.png"></p><p><img src="https://s2.loli.net/2024/05/17/J6DmLxQMZvuAqW7.png"></p><p>比如这里的一个 consumer 取消订阅两次时候就会抛出异常，此时我们就可以根据异常的地方找到源码里对连接状态的判断条件。</p><p>就可以得知：当客户端取消订阅时会修改连接状态。</p><h2 id="💓HertzBeat"><a href="#💓HertzBeat" class="headerlink" title="💓HertzBeat"></a>💓HertzBeat</h2><p>下面以 <a href="https://hertzbeat.apache.org/">Apache HertzBeat</a>为例来看看当时我是如何贡献单元测试的。</p><p><img src="https://s2.loli.net/2024/05/17/dixDGIQO2sZfh98.png"><br>通过官方的架构图可以得知 HertzBeat 是通过一个 collector 去直连目标采集数据的。</p><p>比如通过 Redis 的客户端去获取监控数据，然后再存放到自己的时序数据库中进行展示。</p><p>所以这个采集的过程就是比较核心的逻辑，我们可以看看他的接口定义。</p><p><img src="https://s2.loli.net/2024/05/17/3quVop5vSr6KzPY.png"><br>一共就三个接口，分别是：</p><ul><li>collect采集接口：在 Metrics 中定义了采集的目标信息（地址、端口等）<ul><li>采集完后的数据写入到 Builder 供后续的写入存储</li></ul></li><li>preCheck：提前做一些参数校验</li><li>supportProtocol：返回定义的协议类型，通过这个类型找到对应采集器</li></ul><p><img src="https://s2.loli.net/2024/05/17/hQZaFV2qo3176uf.png"></p><p>然后就交由不同的实现类去采集不同的指标。</p><p>这里我以 <code>RedisCommonCollectImpl</code>为例，主要的单测逻辑就是模拟 Redis 客户端的返回数据，然后在 Collect 的代码里查看不同的处理逻辑，其实就是要覆盖各种分支以及异常的情况。</p><p>最后再断言采集到的数据与预期是否匹配即可，贴一段核心逻辑：<br><img src="https://s2.loli.net/2024/05/17/EnrZxdDR5kLtMIG.png"></p><p>至于应该返回什么预期结果，有些 collector 可能会在代码注释里写清楚，但这个 Redis 没有写。</p><p>不过也有办法，我们可以把代码在本地跑起来之后进入管理台查看内置的监控模版。</p><p><img src="https://s2.loli.net/2024/05/17/g4EL7AdGfbrpXKU.png"><br>这里是用于定义会监控哪些字段的地方，这样我们就可以在代码预先生成好预期返回值了。</p><p><img src="https://s2.loli.net/2024/05/17/OCEYUZHscP6waI3.png"></p><p>具体的单测代码请看这里：<br><a href="https://github.com/apache/hertzbeat/blob/master/collector/src/test/java/org/apache/hertzbeat/collector/collect/redis/RedisClusterCollectImplTest.java#L46">https://github.com/apache/hertzbeat/blob/master/collector/src/test/java/org/apache/hertzbeat/collector/collect/redis/RedisClusterCollectImplTest.java#L46</a></p><h1 id="📝总结"><a href="#📝总结" class="headerlink" title="📝总结"></a>📝总结</h1><p>参与一个成熟社区的开源有一点一定要记住，<strong>就是要仔细阅读<a href="https://hertzbeat.apache.org/zh-cn/docs/community/contribution">贡献者文档</a>。</strong></p><p>里面往往会写清楚如何构建代码、代码规范、提交规范等信息，这些都捋清楚后提交的 PR 才更容易被社区接受。</p><p>后面会继续更新集成测试与 <code>e2e</code> 测试等内容。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前有写过两篇文章来简单聊过如何做开源的事情，最近我自己组了一个社区里面也有不少朋友对开源感兴趣，于是我便根据自己的经验系统的梳理了一些关于开源的事情。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/08/05/ob/novice-contribute-open-source/&quot;&gt;新手如何快速参与开源项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2024/01/25/ob/create-a-plugin-for-cprobe/&quot;&gt;手把手教你为开源项目贡献代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;有兴趣的可以先看看之前这两篇。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
  </entry>
  
  <entry>
    <title>OpenTelemetry 深度定制：跨服务追踪的实战技巧</title>
    <link href="http://crossoverjie.top/2024/06/26/ob/OpenTelemetry-custom-instrument/"/>
    <id>http://crossoverjie.top/2024/06/26/ob/OpenTelemetry-custom-instrument/</id>
    <published>2024-06-26T11:58:03.000Z</published>
    <updated>2024-07-01T01:33:40.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><img src="https://s2.loli.net/2024/05/19/7CnOFegSu4TLbhd.png"></p><p>在上一篇<a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">《从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅》</a>中在最后提到在做一些 Trace 的定制开发。</p><p>到现在差不多算是完成了，可以和大家分享一下。</p><p>我们的需求是这样的：</p><p><img src="https://s2.loli.net/2024/05/19/qex6IFcOnQ591gT.png"><br>假设现在有三个服务：ServiceA、ServiceB、ServiceC</p><span id="more"></span><p><code>ServiceA</code> 对外提供了一个 http 接口 <code>request</code>，在这个接口会调用 <code>ServiceB</code> 的 <code>order</code> 订单接口创建订单，同时 <code>serviceB</code> 调用 <code>serviceC</code> 的 pay 接口。</p><p><img src="https://s2.loli.net/2024/05/19/GtljX3BLVcePWFn.png"><br>整个调用关系如上图所示。</p><p>默认情况下 span 中的 attribute 会记录当前 span 的一些信息，比如：<br><img src="https://s2.loli.net/2024/05/19/tvgdT1Mke7OjPGp.png"><br>这些都是当前一些当前 span 内置的信息，比如当前 gRPC 接口的一些基本数据：服务名、ip、端口等信息。</p><p>但这里并没有上游的一些信息，虽然我们可以通过 Jaeger 的树状图得知上游是哪个应用调用过来的，但是一旦某个 span 下有多个子 span 的调用，就没办法很直观知道这个子 span 的上游是由谁发起的调用。</p><p>比如如下这个链路：<br><img src="https://s2.loli.net/2024/05/19/3rOdKfBmhSjz1GF.png"><br>当一个调用链非常长，同时也非常复杂时，没办法第一时间知道某一个 span 的上游到底是谁发起的，需要手动一层层的去折叠，或者全靠眼睛去找。</p><h2 id="预期效果"><a href="#预期效果" class="headerlink" title="预期效果"></a>预期效果</h2><p><img src="https://s2.loli.net/2024/05/19/9v3cGMrez8XA2ZH.png"></p><p>为此我们希望的效果是可以通过给每一个子 span 中加入两个 attribute，来标明它的父调用来源。</p><p>比如在 serviceB 中的所有 span 中都会加上两个标签：来源是 serviceA，同时是 serviceA 的 request 接口发起的请求。</p><p>而在 serviceC 中同样可以知道来源是 serviceB 的 Order 接口发起的调用。</p><p>我启动了三个 demo 应用，分别是 create1，create2，create3.</p><p>create1 中会提供一个 <code>request</code> 接口，在这里面调用 create2 的 <code>create2</code> 接口，<code>create2</code> 的接口里接着调用 create3 的 <code>create3</code> 接口。</p><p>create1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/request&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;  </span><br><span class="line">   <span class="type">HelloRequest</span> <span class="variable">request</span> <span class="operator">=</span> HelloRequest.newBuilder()  </span><br><span class="line">         .setName(name)  </span><br><span class="line">         .build();  </span><br><span class="line">   log.info(<span class="string">&quot;request: &#123;&#125;&quot;</span>, request);  </span><br><span class="line">   <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> myServiceStub.create2(request).getMessage();  </span><br><span class="line">   Executors.newFixedThreadPool(<span class="number">1</span>).execute(() -&gt; &#123;  </span><br><span class="line">      myServiceStub.create2(request).getMessage();  </span><br><span class="line">   &#125;);       <span class="keyword">return</span> message;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create2</span><span class="params">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;  </span><br><span class="line">    <span class="type">HelloReply</span> <span class="variable">reply</span> <span class="operator">=</span> HelloReply.newBuilder()  </span><br><span class="line">            .setMessage(<span class="string">&quot;Create2 ==&gt; &quot;</span> + request.getName())  </span><br><span class="line">            .build();  </span><br><span class="line">    log.info(<span class="string">&quot;Create2: &#123;&#125;&quot;</span>, reply.getMessage());  </span><br><span class="line">    myMethod(request.getName());  </span><br><span class="line">    myServiceStub.create3(request);</span><br><span class="line">    responseObserver.onNext(reply);  </span><br><span class="line">    responseObserver.onCompleted();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create3:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create3</span><span class="params">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;  </span><br><span class="line">    <span class="type">HelloReply</span> <span class="variable">reply</span> <span class="operator">=</span> HelloReply.newBuilder()  </span><br><span class="line">            .setMessage(<span class="string">&quot;Create3 ==&gt; &quot;</span> + request.getName())  </span><br><span class="line">            .build();  </span><br><span class="line">    log.info(<span class="string">&quot;Create3: &#123;&#125;&quot;</span>, reply.getMessage());  </span><br><span class="line">    myMethod(request.getName());  </span><br><span class="line">    responseObserver.onNext(reply);  </span><br><span class="line">    responseObserver.onCompleted();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.javaagent.extensions=otel-extensions-custom-context-1.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.traces.exporter=otlp \</span><br><span class="line">-Dotel.logs.exporter=none \</span><br><span class="line">-Dotel.service.name=create2 \</span><br><span class="line">-Dotel.exporter.otlp.protocol=grpc \</span><br><span class="line">-Dotel.propagators=tracecontext,baggage,demo \</span><br><span class="line">-Dotel.exporter.otlp.endpoint=http://127.0.0.1:5317 \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar --spring.application.name=create2 --server.port=9191 --grpc.server.port=9292 --grpc.client.myService.address=static://127.0.0.1:9393</span><br></pre></td></tr></table></figure><p>只是每个应用都需要使用我这边单独打的 agent 包以及一个 <code>extension</code>(tel-extensions-custom-context-1.0-SNAPSHOT.jar) 才能生效。</p><p>最终的效果如下：<br><img src="https://s2.loli.net/2024/05/19/4o5mEhjnMbZWL62.png"></p><h1 id="Baggage"><a href="#Baggage" class="headerlink" title="Baggage"></a>Baggage</h1><p>在讲具体的实现之前需要先了解几个 Trace 中的概念，在这里主要用到的是一个称为 Baggage 的对象。</p><p>在之前的文章中其实提到过它的原理以及使用场景：<br><a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/?highlight=%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%BD%E8%B8%AA%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E6%97%85#Baggage">从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅</a></p><p><img src="https://s2.loli.net/2024/05/19/gv2YEoO6LkiGIF9.png"></p><p>Baggage 的中文翻译是：包裹📦；简单来说就是我们可以通过自定义 baggage 可以将我们想要的数据存放在其中，这样再整个 Trace 的任意一个 Span 中都可以读取到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/request&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;  </span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">    Baggage.current().toBuilder().  </span><br><span class="line">          put(<span class="string">&quot;request.name&quot;</span>, name).build()  </span><br><span class="line">          .storeInContext(Context.current()).makeCurrent();</span><br><span class="line">&#125;         </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> Baggage.current().getEntryValue(<span class="string">&quot;request.name&quot;</span>);  </span><br><span class="line">log.info(<span class="string">&quot;request.name: &#123;&#125;&quot;</span>, value);</span><br></pre></td></tr></table></figure><p>理解了这个之后，我们要实现的将上游的信息传递到下游就可以通过这个组件实现了。</p><p>只需要在上游创建 span 时将它自身数据写入到 Baggage 中，再到下游 span 取出来写入到 attribute 中即可。</p><h1 id="ContextCustomizer"><a href="#ContextCustomizer" class="headerlink" title="ContextCustomizer"></a>ContextCustomizer</h1><p>这里的关键就是在哪里写入这个 Baggage，因为对第三方组件的 Instrumentation 的实现都是在 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation">opentelemetry-java-instrumentation</a>项目中。</p><blockquote><p>javaagent.jar 包也是通过该项目打包出来的。</p></blockquote><p>所以在该项目的 <code>io.opentelemetry.instrumentation.api.instrumenter.Instrumenter#doStart</code> 这个函数中我们发现一段逻辑：</p><p><img src="https://s2.loli.net/2024/05/20/FYiAnq2G3voIyR4.png"></p><hr><blockquote><p>这个函数是在创建一个 span 的时候调用的，通常这个创建函数是在这些第三方库的拦截器中创建的。</p></blockquote><p><img src="https://s2.loli.net/2024/05/20/b3cxYekiUGaSlO9.png"><br>比如这是在 grpc 的拦截器中调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context customizers run before span start, so that they can have access to the parent span  </span></span><br><span class="line"><span class="comment">// context, and so that their additions to the context will be visible to span processors  </span></span><br><span class="line"><span class="keyword">for</span> (ContextCustomizer&lt;? <span class="built_in">super</span> REQUEST&gt; contextCustomizer : contextCustomizers) &#123;  </span><br><span class="line">  context = contextCustomizer.onStart(context, request, attributes);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ContextCustomizer</code> 是一个接口只提供了一个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContextCustomizer</span>&lt;REQUEST&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** Allows to customize the operation &#123;<span class="doctag">@link</span> Context&#125;. */</span>  </span><br><span class="line">  Context <span class="title function_">onStart</span><span class="params">(Context parentContext, REQUEST request, Attributes startAttributes)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Context</code> 是上下文信息，可以在自定义的 ContextCustomizer 继续往上下文中追加信息。</li><li><code>REQUEST</code> 是一个泛型：一般是当前第三方组件的请求信息：<ul><li>比如是 <code>HTTP</code> 时，这个 <code>request</code> 就是 HTTP 的请求信息。</li><li>而如果是 <code>gRPC</code> ，则是 <code>gRPC</code> 的请求信息。</li><li>其他的请求类型同理。</li></ul></li><li><code>startAttributes</code> 则是预先写入的一些属性，比如在上图中看到的一些 <code>rpc.service/rpc.method</code>等字段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context customizers run before span start, so that they can have access to the parent span  </span></span><br><span class="line"><span class="comment">// context, and so that their additions to the context will be visible to span processors</span></span><br></pre></td></tr></table></figure><p>从这个接口的调用注释可以看出：<br>这个自定义的 context 会在 span 开始之前调用，所以在这里是可以访问到当前创建的 span 的父 context，同时在这里的 context 中新增的数据可以在 <code>SpanProcessor</code> 访问到。</p><h1 id="SpanProcessor"><a href="#SpanProcessor" class="headerlink" title="SpanProcessor"></a>SpanProcessor</h1><p>而 SpanProcessor 又是一个非常的重要的组件，我们接着刚才的 <code>contextCustomizer</code> 处往后跟踪代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context = contextCustomizer.onStart(context, request, attributes);</span><br><span class="line">---&gt;<span class="type">Span</span> <span class="variable">span</span> <span class="operator">=</span> spanBuilder.setParent(context).startSpan();</span><br><span class="line">---&gt;io.opentelemetry.sdk.trace.SdkSpanBuilder#startSpan</span><br><span class="line">---&gt;io.opentelemetry.sdk.trace.SdkSpan#startSpan</span><br><span class="line">---&gt;spanProcessor.onStart(parentContext, span);</span><br></pre></td></tr></table></figure><p>可以看到 <code>spanProcessor.onStart</code> 这个函数会在 contextCustomizer 之后调用。</p><p><img src="https://s2.loli.net/2024/05/20/vpxHt34TUbgfShz.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * SpanProcessor is the interface &#123;<span class="doctag">@link</span> SdkTracer&#125; uses to allow synchronous hooks for when a  </span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Span&#125; is started or when a &#123;<span class="doctag">@code</span> Span&#125; is ended.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//==========================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Called when a &#123;<span class="doctag">@link</span> io.opentelemetry.api.trace.Span&#125; is started, if the &#123;<span class="doctag">@link</span>  </span></span><br><span class="line"><span class="comment"> * Span#isRecording()&#125; returns true.  </span></span><br><span class="line"><span class="comment"> * * &lt;p&gt;This method is called synchronously on the execution thread, should not throw or block the  </span></span><br><span class="line"><span class="comment"> * execution thread. * * <span class="doctag">@param</span> parentContext the parent &#123;<span class="doctag">@code</span> Context&#125; of the span that just started.  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> span the &#123;<span class="doctag">@code</span> Span&#125; that just started.  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(Context parentContext, ReadWriteSpan span)</span>;</span><br></pre></td></tr></table></figure><p>从注释中可以知道 SpanProcessor 是作为一个 span 的生命周期中的关键节点的 hook 函数。</p><p>在这些函数中我们可以自定义一些 span 的数据，比如在 <code>onStart</code> 还可以往 span 中写入一些自定义的 attribute。</p><p>这也是我们这次会用到的一个接口，我们的方案是：</p><p>在 gRPC 构建 Instrument 时自定义一个 <code>GrpcServerContextCustomizer</code> ，在这个自定义的 <code>ContextCustomizer</code> 中写入一个 <code>Baggage</code>。</p><p>然后在 <code>io.opentelemetry.sdk.trace.SpanProcessor#onStart</code> 接口中取出这个 <code>Baggage</code> 写入到当前 span 的 attribute 中。</p><p>这样我们就可以看到之前提到的那些数据上游信息了。<br><img src="https://s2.loli.net/2024/05/19/4o5mEhjnMbZWL62.png"></p><h1 id="为-gRPC-添加上下文"><a href="#为-gRPC-添加上下文" class="headerlink" title="为 gRPC 添加上下文"></a>为 gRPC 添加上下文</h1><p>先来看看如何为 gRPC 添加 <code>Baggage</code>：</p><p>我们先自定义一个 <code>GrpcServerContextCustomizer</code> 实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrpcServerContextCustomizer</span> <span class="keyword">implements</span> <span class="title class_">ContextCustomizer</span>&lt;GrpcRequest&gt; &#123;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String currentServiceName;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARENT_RPC_KEY</span> <span class="operator">=</span> <span class="string">&quot;parent_rpc&quot;</span>;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CURRENT_RPC_KEY</span> <span class="operator">=</span> <span class="string">&quot;current_rpc&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CURRENT_HTTP_URL_PATH</span> <span class="operator">=</span> <span class="string">&quot;current_http_url_path&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">GrpcServerContextCustomizer</span><span class="params">(String serviceName)</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>.currentServiceName = serviceName;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">public</span> Context <span class="title function_">onStart</span><span class="params">(Context parentContext, GrpcRequest grpcRequest,  </span></span><br><span class="line"><span class="params">      Attributes startAttributeds)</span> &#123;  </span><br><span class="line">    <span class="type">BaggageBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Baggage.fromContext(parentContext).toBuilder();  </span><br><span class="line">  </span><br><span class="line">    <span class="type">String</span> <span class="variable">currentRpc</span> <span class="operator">=</span> Baggage.fromContext(parentContext).getEntryValue(CURRENT_RPC_KEY);  </span><br><span class="line">    <span class="type">String</span> <span class="variable">fullMethodName</span> <span class="operator">=</span> startAttributeds.get(AttributeKey.stringKey(<span class="string">&quot;rpc.method&quot;</span>));  </span><br><span class="line">    <span class="type">String</span> <span class="variable">rpcService</span> <span class="operator">=</span> startAttributeds.get(AttributeKey.stringKey(<span class="string">&quot;rpc.service&quot;</span>));  </span><br><span class="line">    <span class="comment">// call from grpc  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> rpcService + <span class="string">&quot;:&quot;</span> + fullMethodName;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">baggageInfo</span> <span class="operator">=</span> getBaggageInfo(currentServiceName, method);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">String</span> <span class="variable">httpUrlPath</span> <span class="operator">=</span> Baggage.fromContext(parentContext).getEntryValue(CURRENT_HTTP_URL_PATH);  </span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isNullOrEmpty(httpUrlPath)) &#123;  </span><br><span class="line">      <span class="comment">// call from http  </span></span><br><span class="line">      <span class="comment">// currentRpc = currentRpc;  currentRpc = create1|GET:/request      // clear current_http_url_path      builder.put(CURRENT_HTTP_URL_PATH, &quot;&quot;);  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">Baggage</span> <span class="variable">baggage</span> <span class="operator">=</span> builder  </span><br><span class="line">        .put(PARENT_RPC_KEY, currentRpc)  </span><br><span class="line">        .put(CURRENT_RPC_KEY, baggageInfo)  </span><br><span class="line">        .build();  </span><br><span class="line">    <span class="keyword">return</span> parentContext.with(baggage);  </span><br><span class="line">  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getBaggageInfo</span><span class="params">(String serviceName, String method)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNullOrEmpty(serviceName)) &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  </span><br><span class="line">    &#125;    <span class="keyword">return</span> serviceName + <span class="string">&quot;|&quot;</span> + method;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个代码中可以看出，我们需要先从上下文中获取 <code>CURRENT_RPC_KEY</code> ，从而得知当前的 span 是不是 root span。</p><p>所以我们其实是把当前的 span 信息作为一个 <code>PARENT_RPC_KEY</code> 写入到 Baggage 中。</p><p>这样在 <code>SpanProcessor</code> 中便可以直接取出 <code>PARENT_RPC_KEY</code> 作为上游的信息写入 span 的 attribute 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(Context parentContext, ReadWriteSpan span)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">parentRpc</span> <span class="operator">=</span> Baggage.fromContext(parentContext).getEntryValue(<span class="string">&quot;parent_rpc&quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isNullOrEmpty(parentRpc)) &#123;  </span><br><span class="line">        String[] split = parentRpc.split(<span class="string">&quot;\\|&quot;</span>);  </span><br><span class="line">        span.setAttribute(<span class="string">&quot;parent_rpc&quot;</span>, parentRpc);  </span><br><span class="line">        span.setAttribute(<span class="string">&quot;parent_service_name&quot;</span>, split[<span class="number">0</span>]);  </span><br><span class="line">        span.setAttribute(<span class="string">&quot;parent_service_method&quot;</span>, split[<span class="number">1</span>]); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，这里的 Baggage 需要使用 <code>Baggage.fromContext(parentContext)</code> 才能拿到刚才写入 Baggage 信息。</p></blockquote><p>之后我们找到构建 <a href="https://github.com/crossoverjie/opentelemetry-java-instrumentation/blob/715220c8d5e52001f9af9afbeb00bb87b4db0197/instrumentation/grpc-1.6/library/src/main/java/io/opentelemetry/instrumentation/grpc/v1_6/GrpcTelemetryBuilder.java#L31">gRPCServerInstrumenterBuilder</a> 的地方，写入我们刚才自定义的 <code>GrpcServerContextCustomizer</code> 即可。</p><p><img src="https://s2.loli.net/2024/05/20/rwSc8HmvqKL9ZQl.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.addContextCustomizer(<span class="keyword">new</span> <span class="title class_">GrpcServerContextCustomizer</span>(serviceName))</span><br></pre></td></tr></table></figure><p>这里我们选择写入到是 <code>serverInstrumenterBuilder</code> 而不是<code>clientInstrumenterBuilder</code>，因为在服务端的入口就知道是从哪个接口进来的请求。</p><h1 id="为-spring-boot-的-http-接口添加上下文"><a href="#为-spring-boot-的-http-接口添加上下文" class="headerlink" title="为 spring boot 的 http 接口添加上下文"></a>为 spring boot 的 http 接口添加上下文</h1><p>如果只存在 gRPC 调用时只添加 <code>gRPC</code> 的上下文也够用了，但是我们也不排除由外部接口是通过 HTTP 访问进来的，然后再调用内部的 <code>gRPC</code> 接口；这也是非常常见的架构模式。</p><p>所以我们还需要在 HTTP 中增加 <code>ContextCustomizer</code> 将自身的数据写入到 <code>Baggage</code> 中。</p><p>好在 <code>HttpServerRouteBuilder</code> 自身是实现了 <code>ContextCustomizer</code> 接口的，我们只需要往里面写入 <code>Baggage</code> 数据即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ContextCustomizer&lt;REQUEST&gt; <span class="title function_">build</span><span class="params">()</span> &#123;  </span><br><span class="line">  Set&lt;String&gt; knownMethods = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="built_in">this</span>.knownMethods);  </span><br><span class="line">  <span class="keyword">return</span> (context, request, startAttributes) -&gt; &#123;  </span><br><span class="line">    <span class="keyword">if</span> (HttpRouteState.fromContextOrNull(context) != <span class="literal">null</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> context;  </span><br><span class="line">    &#125;    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> getter.getHttpRequestMethod(request);  </span><br><span class="line">    <span class="keyword">if</span> (method == <span class="literal">null</span> || !knownMethods.contains(method)) &#123;  </span><br><span class="line">      method = <span class="string">&quot;HTTP&quot;</span>;  </span><br><span class="line">    &#125;    <span class="type">String</span> <span class="variable">urlPath</span> <span class="operator">=</span> getter.getUrlPath(request);  </span><br><span class="line">    <span class="type">String</span> <span class="variable">methodPath</span> <span class="operator">=</span> method + <span class="string">&quot;:&quot;</span> + urlPath;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">String</span> <span class="variable">currentRpc</span> <span class="operator">=</span> Baggage.fromContext(context).getEntryValue(CURRENT_RPC_KEY);  </span><br><span class="line">    <span class="type">String</span> <span class="variable">baggageInfo</span> <span class="operator">=</span> getBaggageInfo(serviceName, methodPath);  </span><br><span class="line">    <span class="type">Baggage</span> <span class="variable">baggage</span> <span class="operator">=</span> Baggage.fromContext(context).toBuilder()  </span><br><span class="line">        .put(PARENT_RPC_KEY, currentRpc)  </span><br><span class="line">        .put(CURRENT_RPC_KEY, baggageInfo)  </span><br><span class="line">        .put(CURRENT_HTTP_URL_PATH, methodPath)  </span><br><span class="line">        .build();   </span><br><span class="line">    <span class="keyword">return</span> context.with(HttpRouteState.create(method, <span class="literal">null</span>, <span class="number">0</span>))  </span><br><span class="line">        .with(baggage);  </span><br><span class="line">  &#125;;&#125;</span><br></pre></td></tr></table></figure><p>这里新增了 <code>CURRENT_HTTP_URL_PATH</code> 用于标记当前的请求来源是 HTTP，在 grpc 的 <code>ContextCustomizer</code> 解析时会判断这个值是否为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">httpUrlPath</span> <span class="operator">=</span> Baggage.fromContext(parentContext).getEntryValue(CURRENT_HTTP_URL_PATH);  </span><br><span class="line"><span class="keyword">if</span> (!StringUtils.isNullOrEmpty(httpUrlPath)) &#123;  </span><br><span class="line">  <span class="comment">// call from http  </span></span><br><span class="line">  <span class="comment">// currentRpc = currentRpc;  currentRpc = create1|GET:/request  // clear current_http_url_path  builder.put(CURRENT_HTTP_URL_PATH, &quot;&quot;);  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><img src="https://s2.loli.net/2024/05/20/ionwTD9EAr3CROL.png"></p><p>这样就可以在 grpc 的下游接口拿到入口的 HTTP 接口数据了。</p><hr><p>当然也有可能是在 grpc 接口中调用 HTTP 的接口的场景，只是我们的业务中没有这种情况，所以就没有适配这类的场景。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>ContextCustomizer</code> 接口没有提供对应的扩展，但是 <code>SpanProcessor</code> 是提供了扩展接口的。</p><blockquote><p>原本是想尽量别维护自己的 javaagent，但也好在 OpenTelemetry 是提供的接口，所以也并不会去修改原本的代码。</p></blockquote><p>所以我们还是需要创建一个 extensions 的项目在实现 <code>SpanProcessor</code>，这个在之前的 <a href="https://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/">《实战：如何编写一个 OpenTelemetry Extensions》</a>有详细讲到。</p><p>所以最后的应用启动方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.javaagent.extensions=otel-extensions-custom-context-1.0-SNAPSHOT.jar \</span><br></pre></td></tr></table></figure><p>需要使用我们手动打包的 javaagent 以及一个自定义扩展包。</p><p>打包方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew assemble</span><br></pre></td></tr></table></figure><blockquote><p><code>opentelemetry-java-instrumentation</code> 项目比较大，所以打包过程可能比较久。</p></blockquote><p>因为这其实是一些定制需求，所以就没提交到上游，感兴趣的可以自行合并代码测试。</p><p>最后可以这个分支中查看到修改的部分：<br><a href="https://github.com/crossoverJie/opentelemetry-java-instrumentation/compare/main...add-grpc-context">https://github.com/crossoverJie/opentelemetry-java-instrumentation/compare/main...add-grpc-context</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/05/19/7CnOFegSu4TLbhd.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一篇&lt;a href=&quot;https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/&quot;&gt;《从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅》&lt;/a&gt;中在最后提到在做一些 Trace 的定制开发。&lt;/p&gt;
&lt;p&gt;到现在差不多算是完成了，可以和大家分享一下。&lt;/p&gt;
&lt;p&gt;我们的需求是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/05/19/qex6IFcOnQ591gT.png&quot;&gt;&lt;br&gt;假设现在有三个服务：ServiceA、ServiceB、ServiceC&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>从 Prometheus 到 OpenTelemetry：指标监控的演进与实践</title>
    <link href="http://crossoverjie.top/2024/06/13/ob/OpenTelemetry-metrics-concept/"/>
    <id>http://crossoverjie.top/2024/06/13/ob/OpenTelemetry-metrics-concept/</id>
    <published>2024-06-13T10:22:48.000Z</published>
    <updated>2024-07-21T14:36:43.951Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇：<a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅</a>我们讲解了 Trace 的一些核心概念：</p><ul><li>Trace</li><li>Span</li><li>Context</li><li>Baggage 等</li></ul><p>这次我们来讲另一个话题 <code>Metrics</code>。</p><span id="more"></span><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>关于 metrics 我最早接触相关概念的就是 prometheus，它是第二个加入 CNCF（云原生）社区的项目（第一个是 kubernetes），可见在云原生领域 Metrics 指标监控从诞生之初就是一个非常重要的组件。</p><p>现实也确实如此，如今只要使用到了 kubernetes 相关的项目，对其监控就是必不可少的。</p><p>当然也不止是云原生的项目才需要 Metrics 指标监控，我们任何一个业务都是需要的，不然我们的服务运行对开发运维来说都是一个黑盒，无法知道此时系统的运行情况，因此才需要我们的业务系统将一些关键运行指标暴露出来。</p><p><img src="https://s2.loli.net/2024/05/12/1QWEAdFHqYzhl4g.png"></p><p>业务数据：比如订单的增长率、销售金额等业务数据；同时还有应用自身的资源占用情况：</p><ul><li>QPS</li><li>Latency</li><li>内存</li><li>CPU 等信息。</li></ul><p> 在使用 OpenTelemetry 之前，因为 prometheus 是这部分的绝对标准，所以我们通常都会使用 prometheus 的包来暴露这些指标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- The client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Hotspot JVM metrics--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_hotspot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>暴露一个自定义的指标也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.prometheus.client.Counter;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YourClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Counter</span> <span class="variable">requests</span> <span class="operator">=</span> Counter.build()</span><br><span class="line">     .name(<span class="string">&quot;requests_total&quot;</span>).help(<span class="string">&quot;Total requests.&quot;</span>).register();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    requests.inc();</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这是暴露一个单调递增的指标，prometheus 还提供了其他几种指标类型：</p></blockquote><ul><li>Counter</li><li>Gauge</li><li>Histogram</li></ul><p>之后我们只需要在 prometheus 中配置一些抓取规则即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;springboot&#x27;</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:8080&#x27;</span>] <span class="comment"># Spring Boot ip+port</span></span><br></pre></td></tr></table></figure><blockquote><p>当然如果是运行在 kubernetes 环境，prometheus 也可以基于服务发现配置一些规则，自动抓取我们的 Pod 的数据，由于不是本文的重点就不过多介绍。</p></blockquote><h1 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h1><p>在 OpenTelemetry 中自然也提供了 Metrics 这个组件，同时它也是完全兼容 Prometheus，所以我们理解和使用起来并不复杂。</p><h2 id="MeterProvider"><a href="#MeterProvider" class="headerlink" title="MeterProvider"></a>MeterProvider</h2><p>不同于 prometheus 客户端中直接提供了 Counter 就可以创建指标了，在 OpenTelemetry 中会提供一个 <code>MeterProvider</code> 的接口，使用这个接口可以获取 Meter，再使用 Meter 才可以创建 Counter、Gauge、Histogram 等数据。</p><p>下面来看看具体如何使用，这里我以 Pulsar 源码的代码进行演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InstrumentProvider</span><span class="params">(OpenTelemetry otel)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (otel == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// By default, metrics are disabled, unless the OTel java agent is configured.  </span></span><br><span class="line">        <span class="comment">// This allows to enable metrics without any code change.        otel = GlobalOpenTelemetry.get();  </span></span><br><span class="line">    &#125;    <span class="built_in">this</span>.meter = otel.getMeterProvider()  </span><br><span class="line">            .meterBuilder(<span class="string">&quot;org.apache.pulsar.client&quot;</span>)  </span><br><span class="line">            .setInstrumentationVersion(PulsarVersion.getVersion())  </span><br><span class="line">            .build();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">LongCounterBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> meter.counterBuilder(name)  </span><br><span class="line">        .setDescription(description)  </span><br><span class="line">        .setUnit(unit.toString());</span><br></pre></td></tr></table></figure><h2 id="Meter-Exporter"><a href="#Meter-Exporter" class="headerlink" title="Meter Exporter"></a>Meter Exporter</h2><p>Meter Exporter 则是一个 OpenTelemetry 独有的概念，与我们之前讲到的一样：OpenTelemetry 作为厂商无关的平台，允许我们将数据写入到任何兼容的产品里。</p><p>所以我们在使用 Metrics 时需要指定一个 exporter：</p><table><thead><tr><th>Exporter 类型</th><th>作用</th><th>备注</th><th>参数</th></tr></thead><tbody><tr><td>OTLP Exporter</td><td>通过 OpenTelemetry Protocol（OTLP） 发送指标数据到 collect。</td><td>默认生产环境中推荐使用，需要将数据发送到支持 OTLP 的后端，如 OpenTelemetry Collector。</td><td>-Dotel.metrics.exporter&#x3D;otlp (default)</td></tr><tr><td>Console Exporter</td><td>将指标数据打印到控制台的导出器。</td><td>开发和调试，快速查看指标数据。</td><td>-Dotel.metrics.exporter&#x3D;console</td></tr><tr><td>Prometheus Exporter</td><td>将指标数据以 Prometheus 抓取的格式暴露给 Prometheus 服务。</td><td>与 Prometheus 集成，适用于需要 Prometheus 监控的场景，这个可以无缝和以往使用 prometheus 的场景兼容</td><td>-Dotel.metrics.exporter&#x3D;prometheus</td></tr></tbody></table><h2 id="Metric-Instruments"><a href="#Metric-Instruments" class="headerlink" title="Metric Instruments"></a>Metric Instruments</h2><p>与 prometheus 类似，OpenTelemetry 也提供了以下几种指标类型：</p><ul><li><strong>Counter</strong>：单调递增计数器，比如可以用来记录订单数、总的请求数。</li><li><strong>UpDownCounter</strong>：与 Counter 类似，只不过它可以递减。</li><li><strong>Gauge</strong>：用于记录随时在变化的值，比如内存使用量、CPU 使用量等。</li><li><strong>Histogram</strong>：通常用于记录请求延迟、响应时间等。</li></ul><p>同时每个指标还有以下几个字段：</p><ul><li>Name：名称，必填。</li><li>Kind：类型，必填。</li><li>Unit：单位，可选。</li><li>Description：描述，可选。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">messageInCounter = meter  </span><br><span class="line">        .counterBuilder(MESSAGE_IN_COUNTER)  </span><br><span class="line">        .setUnit(<span class="string">&quot;&#123;message&#125;&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;The total number of messages received for this topic.&quot;</span>)  </span><br><span class="line">        .buildObserver();</span><br></pre></td></tr></table></figure><p>还是以 Pulsar 的为例，<code>messageInCounter</code> 是一个记录总的消息接收数量的 Counter 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subscriptionCounter = meter  </span><br><span class="line">        .upDownCounterBuilder(SUBSCRIPTION_COUNTER)  </span><br><span class="line">        .setUnit(<span class="string">&quot;&#123;subscription&#125;&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;The number of Pulsar subscriptions of the topic served by this broker.&quot;</span>)  </span><br><span class="line">        .buildObserver();</span><br></pre></td></tr></table></figure><p>这是记录一个订阅者数量的指标，类型是 UpDownCounter，也就是可以增加减少的指标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Double&gt; latencyHistogramBuckets =  </span><br><span class="line">        Lists.newArrayList(<span class="number">.0005</span>, <span class="number">.001</span>, <span class="number">.0025</span>, <span class="number">.005</span>, <span class="number">.01</span>, <span class="number">.025</span>, <span class="number">.05</span>, <span class="number">.1</span>, <span class="number">.25</span>, <span class="number">.5</span>, <span class="number">1.0</span>, <span class="number">2.5</span>, <span class="number">5.0</span>, <span class="number">10.0</span>, <span class="number">30.0</span>, <span class="number">60.0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">DoubleHistogramBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> meter.histogramBuilder(<span class="string">&quot;pulsar.client.producer.message.send.duration&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;Publish latency experienced by the application, includes client batching time&quot;</span>)  </span><br><span class="line">        .setUnit(Unit.Seconds.toString())  </span><br><span class="line">        .setExplicitBucketBoundariesAdvice(latencyHistogramBuckets);</span><br></pre></td></tr></table></figure><p>这是一个记录 Pulsar producer 发送延迟的指标，类型是 <code>Histogram</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">backlogQuotaAge = meter  </span><br><span class="line">        .gaugeBuilder(BACKLOG_QUOTA_AGE)  </span><br><span class="line">        .ofLongs()  </span><br><span class="line">        .setUnit(<span class="string">&quot;s&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;The age of the oldest unacknowledged message (backlog).&quot;</span>)  </span><br><span class="line">        .buildObserver();</span><br></pre></td></tr></table></figure><p>这是一个记录最大 unack 也就是 backlog 时间的指标，类型是 <code>Gauge</code>。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>在之前的文章：<a href="https://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/">实战：如何编写一个 OpenTelemetry Extensions</a>中讲过如何开发一个 OpenTelemetry 的 extension，其实当时我就是开发了一个用于在 Pulsar 客户端中暴露指标的一个插件。</p><blockquote><p>不过目前 Pulsar 社区已经集成了该功能。</p></blockquote><p>其中的核心代码与上面讲到的类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerObservers</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="type">Meter</span> <span class="variable">meter</span> <span class="operator">=</span> MetricsRegistration.getMeter();    </span><br><span class="line">    </span><br><span class="line">    meter.gaugeBuilder(<span class="string">&quot;pulsar_producer_num_msg_send&quot;</span>)    </span><br><span class="line">            .setDescription(<span class="string">&quot;The number of messages published in the last interval&quot;</span>)    </span><br><span class="line">            .ofLongs()    </span><br><span class="line">            .buildWithCallback(    </span><br><span class="line">                    r -&gt; recordProducerMetrics(r, ProducerStats::getNumMsgsSent));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recordProducerMetrics</span><span class="params">(ObservableLongMeasurement observableLongMeasurement, Function&lt;ProducerStats, Long&gt; getter)</span> &#123;    </span><br><span class="line">    <span class="keyword">for</span> (Producer producer : CollectionHelper.PRODUCER_COLLECTION.list()) &#123;    </span><br><span class="line">        <span class="type">ProducerStats</span> <span class="variable">stats</span> <span class="operator">=</span> producer.getStats();    </span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> producer.getTopic();    </span><br><span class="line">        <span class="keyword">if</span> (topic.endsWith(RetryMessageUtil.RETRY_GROUP_TOPIC_SUFFIX)) &#123;    </span><br><span class="line">            <span class="keyword">continue</span>;    </span><br><span class="line">        &#125;        observableLongMeasurement.record(getter.apply(stats),    </span><br><span class="line">                Attributes.of(PRODUCER_NAME, producer.getProducerName(), TOPIC, topic));    </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>只是这里使用了 <code>buildWithCallback</code> 回调函数，OpenTelemetry 会每隔 30s 调用一次这个函数，通常适用于 Gauge 类型的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent.jar \  </span><br><span class="line">     -Dotel.javaagent.extensions=ext.jar  \</span><br><span class="line">     -Dotel.metrics.exporter=prometheus \</span><br><span class="line">     -Dotel.exporter.prometheus.port=<span class="number">18180</span> \</span><br><span class="line">     -jar myapp.jar</span><br></pre></td></tr></table></figure><p>配合上 Prometheus 的两个启动参数就可以在本地 18180 中获取到指标数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:18180/metrics</span><br></pre></td></tr></table></figure><p>当然也可以直接发往 OpenTelemetry-Collector 中，再由它发往 prometheus，只是这样需要额外在 collector 中配置一下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">exporters:</span></span><br><span class="line">  <span class="attr">debug:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">otlphttp:</span></span><br><span class="line">    <span class="attr">metrics_endpoint:</span> <span class="string">http://promethus:8480/insert/0/opentelemetry/api/v1/push</span></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">pipelines:</span></span><br><span class="line">    <span class="attr">metrics:</span></span><br><span class="line">      <span class="attr">exporters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlphttp</span></span><br><span class="line">      <span class="attr">processors:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">k8sattributes</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">batch</span></span><br><span class="line">      <span class="attr">receivers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlp</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/12/4iMpax5Ptod2Nws.png"></p><p>这样我们就可以在 Grafana 中通过 prometheus 查询到数据了。</p><p>有一点需要注意，如果我们自定义的指标最好是参考官方的<a href="https://opentelemetry.io/docs/specs/semconv/general/metrics/">语义和命名规范</a>来定义这些指标名称。</p><p><img src="https://s2.loli.net/2024/05/12/vCDZY3ygX7MrzGH.png"></p><p>比如 OpenTelemetry 的规范中名称是用 <strong>.</strong> 来进行分隔的。</p><blockquote><p>切换为 OpenTelemetry 之后自然就不需要依赖 prometheus 的包，取而代之的是 OTel 的包：</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compileOnly <span class="string">&#x27;io.opentelemetry:opentelemetry-sdk-extension-autoconfigure-spi:1.34.1&#x27;</span>  </span><br><span class="line">compileOnly <span class="string">&#x27;io.opentelemetry.instrumentation:opentelemetry-instrumentation-api:1.32.0&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相对来说 Metrics 的使用比 Trace 简单的多，同时 Metrics 其实也可以和 Trace 进行关联，也就是 <a href="https://opentelemetry.io/docs/specs/otel/metrics/data-model/#exemplars">Exemplars</a>，限于篇幅就不在本文展开了，感兴趣的可以自行查阅。</p><p>参考链接：</p><ul><li><a href="https://github.com/apache/pulsar/blob/master/pulsar-client/src/main/java/org/apache/pulsar/client/impl/metrics/InstrumentProvider.java">https://github.com/apache/pulsar/blob/master/pulsar-client/src/main/java/org/apache/pulsar/client/impl/metrics/InstrumentProvider.java</a></li><li><a href="https://opentelemetry.io/docs/specs/semconv/general/metrics/">https://opentelemetry.io/docs/specs/semconv/general/metrics/</a></li><li><a href="https://opentelemetry.io/docs/specs/otel/metrics/data-model/#exemplars">https://opentelemetry.io/docs/specs/otel/metrics/data-model/#exemplars</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一篇：&lt;a href=&quot;https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/&quot;&gt;从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅&lt;/a&gt;我们讲解了 Trace 的一些核心概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trace&lt;/li&gt;
&lt;li&gt;Span&lt;/li&gt;
&lt;li&gt;Context&lt;/li&gt;
&lt;li&gt;Baggage 等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这次我们来讲另一个话题 &lt;code&gt;Metrics&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅</title>
    <link href="http://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/"/>
    <id>http://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/</id>
    <published>2024-06-05T16:55:16.000Z</published>
    <updated>2024-06-06T13:00:48.174Z</updated>
    
    <content type="html"><![CDATA[<p>在之前写过两篇比较系统的关于 OpenTelemetry 的文章：</p><ul><li><a href="https://juejin.cn/post/7358450927110357026">OpenTelemetry 实践指南：历史、架构与基本概念</a></li><li><a href="https://juejin.cn/post/7360216766373068837">实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术</a></li></ul><p>从基本概念到如何部署 demo 实战了解 OpenTelemetry，从那个 demo 中也可以得知整个 OpenTelemetry 体系的复杂性，包含了太多的组件和概念。</p><p>为了能更清晰的了解每个关键组件的作用以及原理，我打算分为几期来讲解 OpenTelemetry 的三个核心组件：</p><ul><li>Trace</li><li>Metrics</li><li>Logs</li></ul><p>首先以 Trace 讲起。</p><span id="more"></span><h1 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h1><p>开始之前还是先复习一下 Trace 的历史背景。</p><p>如今现代的分布式追踪的起源源自于 Google 在 2010 年发布的一篇论文：</p><ul><li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf">Dapper, a Large-Scale Distributed Systems Tracing Infrastructure</a></li></ul><p>在这篇论文中提出了分布式追踪的几个核心概念：</p><ul><li>Trace</li><li>Span<ul><li>Span 的一些基础数据结构</li></ul></li><li>可视化追踪以及展示</li></ul><p>之后 Twitter 受到了 Dapper 的启发开源了现在我们熟知的 <a href="https://zipkin.io/">Zipkin</a>，包含了存储和可视化 UI 展示我们的追踪链路。</p><p>Uber 也在 2015 年开源了 <a href="https://www.jaegertracing.io/">Jaeger</a> 项目，它的功能和 Zipkin 类似，但目前我们用的较多的还是 Jaeger；现在已经成为 CNCF 的托管项目。</p><p>之后陆续出现过 <strong>OpenTracing</strong> 和 <strong>OpenCensus</strong> 项目，他们都企图统一分布式追踪这一领域。</p><p>直到 <code>OpenTelemetry</code> 的出现整合了以上两个项目，并且逐渐成为可观测领域的标准。</p><blockquote><p>更多历史背景可以参考之前的文章：<a href="https://juejin.cn/post/7358450927110357026">OpenTelemetry 实践指南：历史、架构与基本概念</a></p></blockquote><p><img src="https://s2.loli.net/2024/05/05/ljQ6yNhKzn3b1c9.png"></p><p><img src="https://s2.loli.net/2024/05/05/NOEbTamR67x83nS.png"></p><p>这里我们结合 Dapper 论文中的资料进行分析，在这个调用中用户发起了一次请求，内部系统经历了 4 次 RPC 调用。</p><p>从第二张图会看到一些关键信息：</p><ul><li>spanName</li><li>parentId</li><li>spanId</li></ul><p>parentId 很好理解，主要是定义调用的主次关系；要注意的是并行调用时 parentId 是同一个。</p><p>spanId 在可以理解为每一个独立的操作，在这里就是一次 RPC 调用；同理一次数据库操作、消息的收发都是一个 span。</p><blockquote><p>span 的更多内容在后文继续讲解。</p></blockquote><h1 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h1><p><img src="https://s2.loli.net/2024/05/05/wyzLpbhYkjOUFav.png"><br>当我们把某一个具体的 span 放大会看到更加详细的信息，其中最关键的如下：</p><ul><li>traceId</li><li>spanName</li><li>spanId</li><li>parentId</li><li>开始时间</li><li>结束时间</li></ul><p>由于一个完整的 trace 链路由 N 个 span 组成，所以这个链路必须得有一个唯一的 traceId 将这些 span 串联起来。<br>这样才可以在可视化的时候更好的展示链路信息。</p><p>以上的这些字段很容易理解，都是一些必须的信息。</p><p>在 Dapper 论文中使用 Annotations 来存放 span 的属性，也就是刚才那些字段，当然也可以自定义存放一些数据，比如图中的 <code>&quot;foo&quot;</code>。</p><h2 id="OpenTelemetry-中的-Span"><a href="#OpenTelemetry-中的-Span" class="headerlink" title="OpenTelemetry 中的 Span"></a>OpenTelemetry 中的 Span</h2><p>OpenTelemetry 的 trace 自然也是基于 Dapper 的，只是额外做了一些优化，比如在刚才那些字段的基础上新增了一些概念：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/v1/sys/health&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;context&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;trace_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7bba9f33312b3dbb8b2c2c62bb7abe2d&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;span_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;086e83747d0e381e&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parent_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;start_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-10-22 16:04:01.209458162 +0000 UTC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;end_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-10-22 16:04:01.209514132 +0000 UTC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;STATUS_CODE_OK&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status_message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;net.transport&quot;</span><span class="punctuation">:</span> <span class="string">&quot;IP.TCP&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.peer.ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.17.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.peer.port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;51820&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.host.ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.177.2.152&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.host.port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;26040&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GET&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/v1/sys/health&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.server_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mortar-gateway&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.route&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/v1/sys/health&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.user_agent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Consul Health Check&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.scheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.177.2.152:26040&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.flavor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;events&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OK&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-10-22 16:04:01.209512872 +0000 UTC&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以这个 JSON 为例，新增了：</p><ul><li><input disabled="" type="checkbox"> <code>Span Context</code><ul><li><code>Span</code> 的上下文，存放的都是不可变的数据，因为每个 Span 之间是存在关联关系的，这些关联关系都是存放在 context 中，主要就是 trace_id, span_id.</li></ul></li><li><code>Attributes</code>: 可以理解为 Dapper 中的 Annotations，存放的是我们自定义的键值对，通常是由我们常用第三方开源 Instrumentation 内置的一些属性。</li><li><code>Span Events</code>: Span 的一些关键事件。</li></ul><p><img src="https://s2.loli.net/2024/05/05/3C49thIJOZTuf82.png"><br>比如我们常用的 Redis 客户端 lettuce，它就会自己记录一些 Attributes。</p><hr><p>如果有多个 span 存在依赖关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       [Span A]  ←←←(the root span)</span><br><span class="line">           |</span><br><span class="line">    +------+------+</span><br><span class="line">    |             |</span><br><span class="line">[Span B]      [Span C] ←←←(Span C is a `child` of Span A)</span><br><span class="line">    |             |</span><br><span class="line">[Span D]      +---+-------+</span><br><span class="line">              |           |</span><br><span class="line">          [Span E]    [Span F]</span><br></pre></td></tr></table></figure><p>大部分的可视化工具都是以时间线的方式进行展示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–&gt; time</span><br><span class="line"></span><br><span class="line"> [Span A···················································]</span><br><span class="line">   [Span B··········································]</span><br><span class="line">      [Span D······································]</span><br><span class="line">    [Span C····················································]</span><br><span class="line">         [Span E·······]        [Span F··]</span><br></pre></td></tr></table></figure><p>这些和 Dapper 中描述的概念没有本质区别。</p><hr><h3 id="Span-Status"><a href="#Span-Status" class="headerlink" title="Span Status"></a>Span Status</h3><p>Span 还内置了一些 Status：</p><ul><li><code>Unset</code></li><li><code>Error</code></li><li><code>Ok</code></li></ul><p>默认情况下是 Unset，出现错误时则是 Error，一切正常时则是 Ok。</p><p><img src="https://s2.loli.net/2024/05/05/glkIuxbFDBcai36.png"><br>通过可视化页面很容易得知某个 trace 中 span 的异常情况，点进去后可以看到具体的异常 span 以及它的错误日志。</p><h3 id="Span-Kind"><a href="#Span-Kind" class="headerlink" title="Span Kind"></a>Span Kind</h3><p>最后是 Span 的类型：</p><ul><li>Client</li><li>Server</li><li>Internal</li><li>Producer</li><li>Consumer</li></ul><p><img src="https://s2.loli.net/2024/05/05/rMjV9qsveNEKORW.png"></p><p>Client 和 Server 非常好理解，比如我们有一个 gRPC 接口，调用方的 Span 是 client，而服务端的 Span 自然就是 Server。</p><p>Internal 则是内部组件调用产生的 Span，这类 Span 相对会少一些。</p><p>Producer 和 Consumer 一般指的是发起异步调用时的 Span，我们常见的就是往消息队列里生产和消费消息。</p><p>通过这几种类型的 Span 也可以了解到什么情况下会创建 Span，通常是以下几种场景：</p><ul><li>RPC 调用</li><li>数据库（Redis、MySQL、Mongo 等等）操作</li><li>生产和消费消息</li><li>有意义的内部调用</li></ul><p>通常在一个函数内部再调用其他的本地函数是不用创建 span 的，不然这个链路会非常的长。</p><h2 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h2><p>当然也有一些特殊情况，比如我的某个内部函数非常重要，需要单独关心它的调用时长。</p><p>此时我们就可以使用 Annotations 来单独创建自己的 Span。</p><blockquote><p>这个 Annotations 和 Dapper 中的不是同一个，只是 Java 中的注解。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;  </span><br><span class="line">    Executors.newFixedThreadPool(<span class="number">1</span>).execute(() -&gt; &#123;  </span><br><span class="line">        myMethod(request.getName());  </span><br><span class="line">    &#125;);    </span><br><span class="line">    </span><br><span class="line">    <span class="type">HelloReply</span> <span class="variable">reply</span> <span class="operator">=</span> HelloReply.newBuilder()  </span><br><span class="line">            .setMessage(<span class="string">&quot;Hello ==&gt; &quot;</span> + request.getName())  </span><br><span class="line">            .build();  </span><br><span class="line">    responseObserver.onNext(reply);  </span><br><span class="line">    responseObserver.onCompleted();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@SneakyThrows</span>  </span><br><span class="line"><span class="meta">@WithSpan</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">(<span class="meta">@SpanAttribute(&quot;request.name&quot;)</span> String name)</span> &#123;  </span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);  </span><br><span class="line">    log.info(<span class="string">&quot;myMethod:&#123;&#125;&quot;</span>, name);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这段代码为例，这是一个 gRPC 的服务端接口，在这个接口中调用了一个函数 <code>myMethod</code>，默认情况下并不会为它单独创建一个 Span。</p><p>但如果我们想单独记录它，就可以使用 <code>@WithSpan</code> 这个注解，同时也可以使用  <code>@SpanAttribute</code> 来自定义 attribute。</p><p>最终的效果如下：<br><img src="https://s2.loli.net/2024/05/05/aBd1ubsS2kxMzGf.png"><br>此时就会单独为这个函数创建一个 Span。</p><blockquote><p>需要单独引入一个依赖:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.opentelemetry.instrumentation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opentelemetry-instrumentation-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Context-Propagation"><a href="#Context-Propagation" class="headerlink" title="Context Propagation"></a>Context Propagation</h1><p>上下文传播也是 Trace 中非常重要的概念，刚才提到了每个 Span 都有自己不可变的上下文，那么后续的 Span 如何和上游的 Span 进行关联呢？</p><p>这里有两种情况：</p><ul><li>同一进程</li><li>垮进程</li></ul><h2 id="同一进程"><a href="#同一进程" class="headerlink" title="同一进程"></a>同一进程</h2><p>同一个进程也分为两种情况：</p><ul><li>单线程</li><li>多线程</li></ul><p>单线程的比较好处理，我们只需要把数据写入 <code>ThreadLocal</code> 中就可以做到线程隔离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Context&gt; THREAD_LOCAL_STORAGE = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line"><span class="keyword">public</span> Context <span class="title function_">current</span><span class="params">()</span> &#123;  </span><br><span class="line">  <span class="keyword">return</span> THREAD_LOCAL_STORAGE.get();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这点我们可以通过源码 <code>io.opentelemetry.context.ThreadLocalContextStorage</code>看到具体的实现过程。</p><p>而如果是多线程时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executors.newFixedThreadPool(<span class="number">1</span>).execute(() -&gt; &#123;  </span><br><span class="line">    myMethod(request.getName());  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>则需要对使用的线程池进行单独处理，将父线程中 threadlocal 中的数据拷贝出来进行传递，比如有阿里提供的 <code>TransmittableThreadLocal</code>，可以提供对线程池的支持。</p><h2 id="跨进程"><a href="#跨进程" class="headerlink" title="跨进程"></a>跨进程</h2><p>而如果是垮进程的场景，就需要将 context 的信息进行序列化传递。</p><p>如果是 gRPC 调用会将信息存放到 metadata 中。</p><p>HTTP 调用则是存放在 header 中。</p><p>消息队列，比如 Pulsar 也可以将数据存放在消息中的 header 中进行传递。</p><p>数据一旦跨进程传输成功后，就和单进程一样的处理方式了。</p><h2 id="Baggage"><a href="#Baggage" class="headerlink" title="Baggage"></a>Baggage</h2><p><img src="https://s2.loli.net/2024/05/05/3c6LNtIbSkpQlRU.png"></p><p>有时候我们需要通过垮 Span 传递信息，比如如上图所示：<br>我们需要在 serverB 中拿到 serverA 中收到的一个请求参数： <code>http://127.0.0.1:8181/request\?name\=1232</code></p><p><img src="https://s2.loli.net/2024/05/05/hISQNv91KP85WFC.png"></p><p>这个数据默认会作为 span 的 attribute ，但只会存在于第一个 span。</p><p>如果我们想要在后续的 span 中也能拿到这个数据，甚至是垮进程也能获取到。</p><p>那就需要使用 <code>Baggage</code> 这个对象了。</p><p>它的使用也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/request&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;  </span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">    Baggage.current().toBuilder().  </span><br><span class="line">          put(<span class="string">&quot;request.name&quot;</span>, name).build()  </span><br><span class="line">          .storeInContext(Context.current()).makeCurrent();</span><br><span class="line">&#125;         </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> Baggage.current().getEntryValue(<span class="string">&quot;request.name&quot;</span>);  </span><br><span class="line">log.info(<span class="string">&quot;request.name: &#123;&#125;&quot;</span>, value);</span><br></pre></td></tr></table></figure><p>只要是属于同一个 trace 的调用就可以直接获取到数据。<br><img src="https://s2.loli.net/2024/05/05/Lz1hY8pflRebANx.png"></p><blockquote><p>traceId 也是垮 Span 传递的。</p></blockquote><p>而它的原理也是通过往 context 中写入数据实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span>  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaggageContextKey</span> &#123;  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ContextKey&lt;Baggage&gt; KEY = ContextKey.named(<span class="string">&quot;opentelemetry-baggage-key&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">BaggageContextKey</span><span class="params">()</span> &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/05/vIHtBxGATKOg13l.png"><br>而这个 context 是通过一个 entries 数据存储数据的，不管是在内部还是外部的跨进程调用，OpenTelemetry 都会将 context 通过 <code>Context Propagation</code> 传递出去。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Trace 这部分的内容我觉得比 Metrics 和 Logs 更加复杂一些，毕竟多了一些数据结构；现在的内容也只是冰山一角，现在也在做 trace 的一些定制化开发，后续有新的进展会接着更新。</p><p>参考链接：</p><ul><li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf">https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf</a></li><li><a href="https://opentelemetry.io/docs/languages/java/automatic/annotations/">https://opentelemetry.io/docs/languages/java/automatic/annotations/</a></li><li><a href="https://opentelemetry.io/docs/specs/otel/overview/#tracing-signal">https://opentelemetry.io/docs/specs/otel/overview/#tracing-signal</a></li><li><a href="https://opentelemetry.io/docs/concepts/context-propagation/">https://opentelemetry.io/docs/concepts/context-propagation/</a></li><li><a href="https://opentelemetry.io/docs/concepts/observability-primer/#distributed-traces">https://opentelemetry.io/docs/concepts/observability-primer/#distributed-traces</a></li><li><a href="https://tech.meituan.com/2023/04/20/traceid-google-dapper-mtrace.html">https://tech.meituan.com/2023/04/20/traceid-google-dapper-mtrace.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前写过两篇比较系统的关于 OpenTelemetry 的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7358450927110357026&quot;&gt;OpenTelemetry 实践指南：历史、架构与基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7360216766373068837&quot;&gt;实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从基本概念到如何部署 demo 实战了解 OpenTelemetry，从那个 demo 中也可以得知整个 OpenTelemetry 体系的复杂性，包含了太多的组件和概念。&lt;/p&gt;
&lt;p&gt;为了能更清晰的了解每个关键组件的作用以及原理，我打算分为几期来讲解 OpenTelemetry 的三个核心组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trace&lt;/li&gt;
&lt;li&gt;Metrics&lt;/li&gt;
&lt;li&gt;Logs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先以 Trace 讲起。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>【译】几个你或许并不知道 kubernetes 技巧</title>
    <link href="http://crossoverjie.top/2024/06/03/ob/Kubernetes-tricks/"/>
    <id>http://crossoverjie.top/2024/06/03/ob/Kubernetes-tricks/</id>
    <published>2024-06-03T10:05:25.000Z</published>
    <updated>2024-06-03T13:10:27.508Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/06/03/AoNyHhS4sl96tFx.png"></p><p>原文链接: <a href="https://overcast.blog/13-kubernetes-tricks-you-didnt-know-647de6364472">https://overcast.blog/13-kubernetes-tricks-you-didnt-know-647de6364472</a></p><h1 id="使用-PreStop-优雅关闭-Pod"><a href="#使用-PreStop-优雅关闭-Pod" class="headerlink" title="使用 PreStop 优雅关闭 Pod"></a>使用 PreStop 优雅关闭 Pod</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">graceful-shutdown-example</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sample-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;sleep 30 &amp;&amp; nginx -s quit&quot;</span>]</span><br></pre></td></tr></table></figure><p>PreStop 允许 Pod 在终止前执行一个命令或者是脚本，使用它就可以在应用退出前释放一些资源，确保应用可以优雅退出。</p><p>比如可以在 Nginx 的 Pod 退出前将当前的请求执行完毕。</p><span id="more"></span><h1 id="使用临时容器调试-Pod"><a href="#使用临时容器调试-Pod" class="headerlink" title="使用临时容器调试 Pod"></a>使用临时容器调试 Pod</h1><p>临时容器可以不修改一个运行的容器的前提下调试容器，可以很方便的调试一些生产环境的 bug，可以避免重启应用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl alpha debug -it podname --image=busybox --target=containername</span><br></pre></td></tr></table></figure><p>生产环境谨慎使用，只有在当前环境下无法排查问题的时候才使用。</p><h1 id="基于自定义的-Metrics-自动扩容Pod"><a href="#基于自定义的-Metrics-自动扩容Pod" class="headerlink" title="基于自定义的  Metrics 自动扩容Pod"></a>基于自定义的  Metrics 自动扩容Pod</h1><p>kubernetes 是提供了 HPA 机制可以跟进 CPU 内存等标准数据进行自动扩缩容，但有时我们需要根据自定义的数据进行扩缩容。</p><p>比如某个接口的延迟、队列大小等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">custom-metric-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">your-application</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span></span><br><span class="line">    <span class="attr">pods:</span></span><br><span class="line">      <span class="attr">metric:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">your_custom_metric</span></span><br><span class="line">      <span class="attr">target:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">AverageValue</span></span><br><span class="line">        <span class="attr">averageValue:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="用-Init-Containers-配置启动脚本"><a href="#用-Init-Containers-配置启动脚本" class="headerlink" title="用 Init Containers 配置启动脚本"></a>用 Init Containers 配置启动脚本</h1><p>初始化容器可以在应用容器启动前运行，我们可以使用它来初始化应用需要的配置、等待依赖的服务启动完成等工作：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-myservice</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;</span>]</span><br></pre></td></tr></table></figure><p>比如这个初始化容器会等待 myservice 可用后才会启动应用。</p><p>需要注意的是如果初始化容器会阻塞应用启动，所以要避免在初始化容器里执行耗时操作。</p><h1 id="Node-亲和性调度"><a href="#Node-亲和性调度" class="headerlink" title="Node 亲和性调度"></a>Node 亲和性调度</h1><p>当我们需要将某些应用部署到硬件配置较高的节点时（比如需要 SSD 硬盘），就可以使用节点亲和性来部署应用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">with-node-affinity</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">with-node-affinity</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">disktype</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ssd</span></span><br></pre></td></tr></table></figure><p>这个 Pod 会被部署到有这个 <code>disktype=ssd</code> 标签的 节点上。</p><h1 id="动态配置：ConfigMap-和-Secrets"><a href="#动态配置：ConfigMap-和-Secrets" class="headerlink" title="动态配置：ConfigMap 和 Secrets"></a>动态配置：ConfigMap 和 Secrets</h1><p>ConfigMap 和 Secrets可以动态注入到 Pod 中，避免对这些配置硬编码。</p><p>ConfigMap 适合非敏感的数据，Secrets 适合敏感的数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ConfigMap Example</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">config.json:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;key&quot;: &quot;value&quot;,</span></span><br><span class="line"><span class="string">      &quot;databaseURL&quot;: &quot;http://mydatabase.example.com&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="comment"># Pod Spec using ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">myapp</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">app-config</span></span><br></pre></td></tr></table></figure><p>这样在应用中就可以通过这路径 <code>/etc/config/config.json</code> 读取数据了。</p><blockquote><p>当然也可以把这些数据写入到环境变量中。</p></blockquote><p>以上这些个人技巧用的最多的是：</p><ul><li>临时容器调试 Pod，特别是业务容器缺少一些命令时。</li><li>Init Container 等待依赖的服务启动完成。</li><li>Node 亲和性调度。</li><li>ConfigMap 是基础操作了。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/06/03/AoNyHhS4sl96tFx.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&quot;https://overcast.blog/13-kubernetes-tricks-you-didnt-know-647de6364472&quot;&gt;https://overcast.blog/13-kubernetes-tricks-you-didnt-know-647de6364472&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;使用-PreStop-优雅关闭-Pod&quot;&gt;&lt;a href=&quot;#使用-PreStop-优雅关闭-Pod&quot; class=&quot;headerlink&quot; title=&quot;使用 PreStop 优雅关闭 Pod&quot;&gt;&lt;/a&gt;使用 PreStop 优雅关闭 Pod&lt;/h1&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;apiVersion:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;v1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kind:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Pod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;metadata:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;graceful-shutdown-example&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;spec:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;containers:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;sample-container&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;image:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;nginx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;lifecycle:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;preStop:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;exec:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attr&quot;&gt;command:&lt;/span&gt; [&lt;span class=&quot;string&quot;&gt;&amp;quot;/bin/sh&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;-c&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;sleep 30 &amp;amp;&amp;amp; nginx -s quit&amp;quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;PreStop 允许 Pod 在终止前执行一个命令或者是脚本，使用它就可以在应用退出前释放一些资源，确保应用可以优雅退出。&lt;/p&gt;
&lt;p&gt;比如可以在 Nginx 的 Pod 退出前将当前的请求执行完毕。&lt;/p&gt;</summary>
    
    
    
    <category term="翻译" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="kubernetes" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/kubernetes/"/>
    
    
    <category term="kubernetes" scheme="http://crossoverjie.top/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术</title>
    <link href="http://crossoverjie.top/2024/05/26/ob/OTel-demo/"/>
    <id>http://crossoverjie.top/2024/05/26/ob/OTel-demo/</id>
    <published>2024-05-26T02:49:02.000Z</published>
    <updated>2024-05-26T11:35:45.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇文章 <a href="https://crossoverjie.top/2024/05/21/ob/OpenTelemetry-getstart/">OpenTelemetry 实践指南：历史、架构与基本概念</a>中回顾了可观测性的历史以及介绍了一些 OpenTelemetry 的基础概念，同时也介绍了 OpenTelemetry 社区常用的开源项目。</p><p>基础背景知识了解后，这篇就来介绍一下使用 OpenTelemetry 如何实战部署应用，同时在一个可视化页面查看 trace、metric 等信息。</p><span id="more"></span><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>我们参考官方文档构建几个 spring boot 、Golang 项目再配合 Agent 其实也可以很方便的集成 OpenTelemetry。</p><p>但是要完整的体验 OpenTelemetry 的所有功能，包含 trace、logs、metrics，还有社区这么多语言的支持其实还是比较麻烦的。</p><p>我们还需要单独部署 collector、存储的 backend service 等组件、包括 trace UI 展示所需要的 Jaeger，metric 所需要的 grafana 等。</p><p>这些所有东西都自己从头弄的话还是比较费时，不过好在社区已经将这些步骤都考虑到了。</p><p>特地为大家写了一个 <a href="https://github.com/open-telemetry/opentelemetry-demo">opentelemetry-demo</a>。</p><p>这个项目模拟了一个微服务版本的电子商城，主要包含了以下一些项目：</p><table><thead><tr><th>Service</th><th>Language</th><th>Description</th></tr></thead><tbody><tr><td><a href="accounting/">accountingservice</a></td><td>Go</td><td>处理和计算订单数据</td></tr><tr><td><a href="ad/">adservice</a></td><td>Java</td><td>广告服务</td></tr><tr><td><a href="cart/">cartservice</a></td><td>.NET</td><td>购物车服务，主要会依赖 Redis</td></tr><tr><td><a href="checkout/">checkoutservice</a></td><td>Go</td><td>checkout</td></tr><tr><td><a href="currency/">currencyservice</a></td><td>C++</td><td>货币转换服务，提供了较高的 QPS 能力。</td></tr><tr><td><a href="email/">emailservice</a></td><td>Ruby</td><td>邮件服务</td></tr><tr><td><a href="fraud-detection/">frauddetectionservice</a></td><td>Kotlin</td><td>风控服务</td></tr><tr><td><a href="frontend/">frontend</a></td><td>JavaScript</td><td>前端应用</td></tr><tr><td><a href="load-generator/">loadgenerator</a></td><td>Python&#x2F;Locust</td><td>模拟压测服务</td></tr><tr><td><a href="payment/">paymentservice</a></td><td>JavaScript</td><td>支付服务</td></tr><tr><td><a href="product-catalog/">productcatalogservice</a></td><td>Go</td><td>商品服务</td></tr><tr><td><a href="quote/">quoteservice</a></td><td>PHP</td><td>成本服务</td></tr><tr><td><a href="recommendation/">recommendationservice</a></td><td>Python</td><td>推荐服务</td></tr><tr><td><a href="shipping/">shippingservice</a></td><td>Rust</td><td>shipping service</td></tr><tr><td>可以发现在这个 demo 中提供了许多的服务，而且包含了几乎所有主流的语言，可以很好的模拟我们实际的使用场景了。</td><td></td><td></td></tr></tbody></table><p><img src="https://s2.loli.net/2024/04/20/NahleoLGbv9tSuE.png"></p><p>通过这张图可以更直观的查看各个服务之间的关系。</p><p>整体来说前端所有的请求都会通过 <code>front-end-proxy</code> 这个组件代理，最终再由 front 这个服务进行转发到不同的后端服务中。</p><hr><p><img src="https://s2.loli.net/2024/04/20/wLVI1mSzYKjt2Fo.png"><br>除了一个项目的架构图之外，还有一个关于 OpenTelemetry 的数据流转图。</p><p>在 OpenTelemetry 中数据流转是它的特点也是非常重要的核心，这点在上一篇文章中讲过，用户可以自由定制数据的流转以及任意的处理数据，在这个图中就将数据流转可视化了。</p><ul><li>客户端可以通过 OTLP 协议或者是 HTTP 将数据上传到 OTel Collector 中。</li><li>在 collector 中会根据我们配置的 Process pipeline 处理数据。</li><li>Metric 数据通过  OTLP HTTP exporter 将数据导入到 Prometheus 中。<ul><li><a href="https://github.com/prometheus/prometheus/pull/12571">Prometheus</a> 已经于 23 年七月份支持 OTLP 格式的 metric 数据导入了。</li></ul></li><li>Trace 数据则是通过 OTLP Exporter 写入到 Jaeger 中进行存储，最后通过 Jaeger 的 UI 进行查询展示。</li><li>而存入 Prometheus 中的 metric 数据则是有 grafana 进行查询。</li></ul><blockquote><p>关于 collector 的配置会在后文讲解。</p></blockquote><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>接下来便是安装 Demo 了，我更推荐使用 helm 安装。</p><p>这里的版本要求是：</p><ul><li>Kubernetes 1.24+</li><li>Helm 3.9+</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm repo add open-telemetry https://open-telemetry.github.io/opentelemetry-helm-charts</span><br><span class="line">helm repo update</span><br><span class="line">helm install my-otel-demo open-telemetry/opentelemetry-demo</span><br></pre></td></tr></table></figure><p>这样就可以很简单的将 demo 所涉及到的所有组件和服务都安装到 default 命名空间中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm show values open-telemetry/opentelemetry-demo &gt; demo.yaml</span><br></pre></td></tr></table></figure><p>不过在安装前还是建议先导出一份 value.yaml，之后可以使用这个 yaml 定制需要安装的组件。</p><p>在这个 yaml 中我们可以看到有哪些组件和服务可以定制：<br><img src="https://s2.loli.net/2024/04/20/oe2S1fr3xPcypB4.png"><br>可以看到这里包含了我们刚才提到的所有服务，以及这些服务所依赖的 Kafka、redis、Prometheus 等中间件，都可以自己进行定制修改。</p><p><img src="https://s2.loli.net/2024/04/20/VP5GvtszWolSBnf.png"><br>当所有的 Pod 都成功运行之后表示安装成功。</p><blockquote><p>正常情况下安装不会有什么问题，最大可能的问题就是镜像拉取失败，此时我们可以先在本地手动 docker pull 下来镜像后再上传到私服，然后修改 deployment 中的镜像地址即可。</p></blockquote><h2 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h2><p>为了方便使用我们可以用这个 demo 进行测试，还需要将 front-proxy 的服务暴露出来可以在本地访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl port-forward svc/my-otel-demo-frontendproxy 8080:8080</span><br></pre></td></tr></table></figure><table><thead><tr><th>Component</th><th>Path</th></tr></thead><tbody><tr><td>Shop 首页</td><td><a href="http://localhost:8080/">http://localhost:8080</a></td></tr><tr><td>Grafana</td><td><a href="http://localhost:8080/grafana">http://localhost:8080/grafana</a></td></tr><tr><td>压测页面</td><td><a href="http://localhost:8080/loadgen">http://localhost:8080/loadgen</a></td></tr><tr><td>Jaeger UI</td><td><a href="http://localhost:8080/jaeger/ui">http://localhost:8080/jaeger/ui</a></td></tr><tr><td>正常情况下就可以打开这些页面进行访问了。</td><td></td></tr></tbody></table><p>不过使用 port-forward 转发的方式只是临时方案，使用 ctrl+c 就会停止暴露服务，所以如果想要一个稳定的访问链接时便可以配置一个 ingress。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">components:</span></span><br><span class="line">  <span class="attr">frontendProxy:</span></span><br><span class="line">    <span class="attr">ingress:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">annotations:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">hosts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">otel-demo.my-domain.com</span></span><br><span class="line">          <span class="attr">paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在之前的 helm 的 value.yaml 中配置即可，本地测试的话需要将这个 host 和 ingress 暴露出来的 IP 进行绑定才可以使用这个域名机进行访问。</p><p>更多关于 ingress 的使用可以参考我之前的文章：</p><ul><li><a href="https://crossoverjie.top/2023/09/15/ob/k8s-Ingress/">k8s入门到实战-使用Ingress</a></li></ul><p>当然简单起见也可以直接将 front-proxy 的 service 类型改为 LoadBalancer。（默认是 ClusterIP 只可以在集群内访问）</p><p>这样就可以直接通过这个 service 的 IP 进行访问了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">components:</span></span><br><span class="line">  <span class="attr">frontendProxy:</span></span><br><span class="line">    <span class="attr">service:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br></pre></td></tr></table></figure><blockquote><p>不过需要注意的是如果 demo 安装完成之后是不可以再次修改 service 的类型的，需要手动这个 service 删掉之后再次新建才可以。</p></blockquote><p> 临时测试使用的话还是推荐直接使用 port-forward 进行转发。</p><h1 id="查看-Trace"><a href="#查看-Trace" class="headerlink" title="查看 Trace"></a>查看 Trace</h1><p>通过之前的项目架构图可以得知，我们在项目首页刷新会直接请求 AdService 来获取广告。</p><p>为了简单起见我们只查询这一链路的调用情况：<br><img src="https://s2.loli.net/2024/04/21/t6a4KvOhSne9yfu.png"></p><p>打开 <a href="http://localhost:8080/jaeger/ui/search">http://localhost:8080/jaeger/ui/search</a> Jeager 的 UI 页面便可以筛选服务，之后点击查找 Traces 就可以列出一段时间内的访问 trace。</p><p><img src="https://s2.loli.net/2024/04/21/v8nVLxweyCO9NMm.png"><br>可以看到这个请求链路是从前端访问到 adService 中的 <code>getAds()</code>接口，然后在这个接口中再访问了 <code>getAdsByCategory</code> 函数。<br><img src="https://s2.loli.net/2024/04/21/3UXmHsCSLFguRZK.png"></p><p>最终在源码中也可以看到符合链路的调用代码。</p><blockquote><p>在刚才的链路图的右下角有一个 spanID，整个 trace 是由这些小的 span 组成，每一个 span 也会有唯一 spanID； trace 也会有一个 traceID 将这些 span 串联起来；更多关于 trace 的内容会在后面的文章进行分析。</p></blockquote><h2 id="查看-Metrics"><a href="#查看-Metrics" class="headerlink" title="查看 Metrics"></a>查看 Metrics</h2><p>我们再打开 grafana 便可以看到刚才访问的 adService 的延迟和接口的 QPS 情况：<br><img src="https://s2.loli.net/2024/04/21/29BlRATOnpkCQwS.png"></p><hr><p>在opentelemetry-collector-data-flow 面板中还可以看到 OpenTelemetry 的数据流转。<br><img src="https://s2.loli.net/2024/04/21/Tbtiv3gzY5xZIH1.png"></p><blockquote><p>更多监控信息可以查看其它的面板。</p></blockquote><p>而刚才面板中的数据流转规则则是在我们的 <a href="https://github.com/open-telemetry/opentelemetry-demo/blob/main/src/otelcollector/otelcol-config.yml">collector</a> 中进行配置的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">receivers:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">protocols:</span></span><br><span class="line">      <span class="attr">grpc:</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">cors:</span></span><br><span class="line">          <span class="attr">allowed_origins:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;http://*&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;https://*&quot;</span></span><br><span class="line">  <span class="attr">httpcheck/frontendproxy:</span></span><br><span class="line">    <span class="attr">targets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">endpoint:</span> <span class="string">http://frontendproxy:$&#123;env:ENVOY_PORT&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">exporters:</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">&quot;jaeger:4317&quot;</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">otlphttp/prometheus:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">&quot;http://prometheus:9090/api/v1/otlp&quot;</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">opensearch:</span></span><br><span class="line">    <span class="attr">logs_index:</span> <span class="string">otel</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">endpoint:</span> <span class="string">&quot;http://opensearch:9200&quot;</span></span><br><span class="line">      <span class="attr">tls:</span></span><br><span class="line">        <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="attr">batch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">connectors:</span></span><br><span class="line">  <span class="attr">spanmetrics:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">pipelines:</span></span><br><span class="line">    <span class="attr">traces:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">otlp</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">otlp</span>, <span class="string">debug</span>, <span class="string">spanmetrics</span>]</span><br><span class="line">    <span class="attr">metrics:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">httpcheck/frontendproxy</span>, <span class="string">otlp</span>, <span class="string">spanmetrics</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">otlphttp/prometheus</span>, <span class="string">debug</span>]</span><br><span class="line">    <span class="attr">logs:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">otlp</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">opensearch</span>, <span class="string">debug</span>]</span><br></pre></td></tr></table></figure><p>重点的就是这里的 <code>service.piplines</code>，可以进行任意的组装。</p><p>更多关于 collector 的配置也会在后续文章中继续讲解。</p><p>我们也可以继续访问这个 demo 网站，模拟加入购物车、下单等行为，再结合 trace 和 metric 观察系统的变化。</p><p>这样一个完整的 OpenTelemetry-Demo 就搭建完毕了，我们实际在生产环境使时完全可以参考这个 demo 进行配置，可以少踩很多坑。</p><p>参考链接：</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-demo/blob/main/src/adservice/Dockerfile">https://github.com/open-telemetry/opentelemetry-demo/blob/main/src/adservice/Dockerfile</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-demo">https://github.com/open-telemetry/opentelemetry-demo</a></li><li><a href="https://github.com/prometheus/prometheus/pull/12571">https://github.com/prometheus/prometheus/pull/12571</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-demo/blob/main/src/otelcollector/otelcol-config.yml">https://github.com/open-telemetry/opentelemetry-demo/blob/main/src/otelcollector/otelcol-config.yml</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇文章 &lt;a href=&quot;https://crossoverjie.top/2024/05/21/ob/OpenTelemetry-getstart/&quot;&gt;OpenTelemetry 实践指南：历史、架构与基本概念&lt;/a&gt;中回顾了可观测性的历史以及介绍了一些 OpenTelemetry 的基础概念，同时也介绍了 OpenTelemetry 社区常用的开源项目。&lt;/p&gt;
&lt;p&gt;基础背景知识了解后，这篇就来介绍一下使用 OpenTelemetry 如何实战部署应用，同时在一个可视化页面查看 trace、metric 等信息。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>OpenTelemetry 实践指南：历史、架构与基本概念</title>
    <link href="http://crossoverjie.top/2024/05/21/ob/OpenTelemetry-getstart/"/>
    <id>http://crossoverjie.top/2024/05/21/ob/OpenTelemetry-getstart/</id>
    <published>2024-05-21T13:46:00.000Z</published>
    <updated>2024-05-20T13:14:03.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前陆续写过一些和 OpenTelemetry 相关的文章：</p><ul><li><a href="https://crossoverjie.top/2024/04/07/ob/otel-replace-sw/">实战：如何优雅的从 Skywalking 切换到 OpenTelemetry</a></li><li><a href="https://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/">实战：如何编写一个 OpenTelemetry Extensions</a></li><li><a href="https://juejin.cn/post/7356138322367266854">从一个 JDK21+OpenTelemetry 不兼容的问题讲起</a></li></ul><p>这些内容的前提是最好有一些 OpenTelemetry 的背景知识，看起来就不会那么枯燥，为此这篇文章就来做一个入门科普，方便一些对 OpenTelemetry 不是那么熟的朋友快速掌握一些 OpenTelemetry 的基本概念。</p><span id="more"></span><hr><h2 id="历史发展"><a href="#历史发展" class="headerlink" title="历史发展"></a>历史发展</h2><p>早在 <code>OpenTelemetry</code> 诞生之前可观测性这个概念就一直存在了，我记得我最早接触到这个概念是在 16 年当时的公司所使用的一个产品：<a href="https://github.com/pinpoint-apm/pinpoint">pinpoint</a></p><blockquote><p>现如今这个项目依然比较活跃。</p></blockquote><p><img src="https://s2.loli.net/2024/04/15/VMLhpCWUGJmqn9z.png"><br>依然还记得当时通过它可以直接看到项目调用的拓扑图，在时间坐标上框出高延迟的点就能列出这些请求，同时还能查看此时的运行日志。</p><p>这样强大的功能对于一个刚工作一年的小白来说冲击力实属太大了一点。</p><p>后来才了解到 pinpoint 属于 APM 这类产品，类似的产品还有：</p><ul><li>Apache SkyWalking</li><li>美团的 CAT 等</li></ul><p>他们都是可以用于性能分析和链路追踪的产品，到后来公司的运维层面也接入过 Zabbix、open-falcon 之类的产品：<br><img src="https://s2.loli.net/2024/04/16/RwsCUSM4fxTaBj6.png"></p><p>17之后全面切换到 spring boot 时，也用过社区提供的 <a href="https://github.com/codecentric/spring-boot-admin">spring-boot-admin</a> 项目：</p><p><img src="https://s2.loli.net/2024/04/16/Y5vprI1fsVNwjPC.png"><br>这就是一个简单的可以监控 spring boot 应用的产品，用于展示 JVM 指标，或者自己也可以定义一些健康指标。</p><hr><p>再之后进入云原生体系后可观测性的技术栈稍有变化。</p><p><img src="https://s2.loli.net/2024/04/16/3MsXIo7lEgnhyUZ.png"></p><p>日志使用 Sidecar 代理的方式通过 Agent 将数据写入 ElasticSearch 中。<br>具体日志采集方式可以参考之前的文章：</p><ul><li><a href="https://juejin.cn/post/7347000319983419411">在 kubernetes 环境下如何采集日志</a></li></ul><p>而链路追踪则是使用的 <code>skywalking</code>，在 trace 这个领域 skywalking 还是非常受大家喜爱的。</p><p>不过最近也从 skywalking 切换到了我们本文所讲到的 OpenTelemetry，具体可以看之前的文章：</p><ul><li><a href="https://crossoverjie.top/2024/04/07/ob/otel-replace-sw/">实战：如何优雅的从 Skywalking 切换到 OpenTelemetry</a></li></ul><p>指标采集使用的是自然也是 Prometheus 的那一套技术栈，只是 Prometheus 换为了与它完全兼容的 VictoriaMetric 目前是为了更省资源。</p><p>客户端使用则是直接使用 Prometheus 的库进行指标暴露：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>prometheus-metrics-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>prometheus-metrics-instrumentation-jvm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>prometheus-metrics-exporter-httpserver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终通过配置抓取策略，由 VictoriaMetrics 的 <code>scrape</code> 程序来抓取指标最终写入到它自己的存储中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">operator.victoriametrics.com/v1beta1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">VMPodScrape</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-pod-scrape</span>  </span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">podMetricsEndpoints:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">scheme:</span> <span class="string">http</span>  </span><br><span class="line">      <span class="attr">scrape_interval:</span> <span class="string">&quot;30s&quot;</span>  </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/metrics</span>  </span><br><span class="line">      <span class="attr">relabelConfigs:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_annotation_prometheus_io_scrape</span>]  </span><br><span class="line">          <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">keep</span>  </span><br><span class="line">        <span class="comment"># 端口相同  </span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">keep_if_equal</span>  </span><br><span class="line">          <span class="attr">source_labels:</span> [ <span class="string">__meta_kubernetes_pod_annotation_prometheus_io_port</span>, <span class="string">__meta_kubernetes_pod_container_port_number</span> ]  </span><br><span class="line">        <span class="comment"># 过滤INIT容器  </span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">drop</span>  </span><br><span class="line">          <span class="attr">source_labels:</span> [ <span class="string">__meta_kubernetes_pod_container_init</span> ]  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_annotation_prometheus_io_path</span>]  </span><br><span class="line">          <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">(.+)</span>  </span><br><span class="line">          <span class="attr">target_label:</span> <span class="string">__metrics_path__</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">replace</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__address__</span>, <span class="string">__meta_kubernetes_pod_annotation_prometheus_io_port</span>]  </span><br><span class="line">          <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">([^:]+)(?::\d+)?;(\d+)</span>  </span><br><span class="line">          <span class="attr">target_label:</span> <span class="string">__address__</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1:$2</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">replace</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">__meta_kubernetes_pod_label_(.+)</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">labelmap</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_namespace</span>]  </span><br><span class="line">          <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">(.*)</span>  </span><br><span class="line">          <span class="attr">target_label:</span> <span class="string">kubernetes_namespace</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">replace</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_name</span>]  </span><br><span class="line">          <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">(.*)</span>  </span><br><span class="line">          <span class="attr">target_label:</span> <span class="string">kubernetes_pod_name</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">replace</span>  </span><br><span class="line">      <span class="attr">vm_scrape_params:</span>  </span><br><span class="line">        <span class="attr">stream_parse:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">namespaceSelector:</span>  </span><br><span class="line">    <span class="attr">any:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>以上是 VM 提供的 CRD</p></blockquote><h1 id="OpenTelemetry-诞生"><a href="#OpenTelemetry-诞生" class="headerlink" title="OpenTelemetry 诞生"></a>OpenTelemetry 诞生</h1><p>到此铺垫完成，不知道有没有发现在可观测性中关键的三个部分：日志、指标、trace 都是使用不同的开源产品，从而会导致技术栈较多，维护起来自然也是比较麻烦的。</p><p>这么一个软件领域的核心能力自然需要提供一个完整方案的，将以上的不同技术栈都整合在一起，更加的方便开发者使用。</p><p>在这之前也有两个社区想要做类似的事情：</p><ul><li>OpenTracing</li><li>OpenCensus</li></ul><p>不过他们并没有统一整个可观测领域，直到 2019 年 CNCF 社区宣布成立 OpenTelemetry，并且将上述两个社区进行合并共同开发 OpenTelemetry。</p><blockquote><p>背靠 CNCF 云原生社区加上许多知名厂商的支持（Google、Amazon、Redhat 等），现在已经正式成为 CNCF 的顶级项目了。</p></blockquote><h1 id="OpenTelemetry-架构介绍"><a href="#OpenTelemetry-架构介绍" class="headerlink" title="OpenTelemetry 架构介绍"></a>OpenTelemetry 架构介绍</h1><p><img src="https://s2.loli.net/2024/04/16/LMUtyG2ZqRbwYr8.png"></p><p>但我们打开 OpenTelemetry 社区的 GitHub 首页时，会看到有许多项目；第一反应应该是比较蒙的，下面我会着重介绍一些比较重要的项目。</p><p>在开始之前还是先简单介绍下 OpenTelemetry 的一些基础组件和概念：<br><img src="https://s2.loli.net/2024/04/16/pHON6Z3eun4IiJv.png"></p><p>整个 OpenTelemetry 系统其实可以简单分为三个部分：</p><ul><li>客户端</li><li>OTel collector</li><li>数据存储</li></ul><p>第一个客户端很好理解，也就是我们的业务应用；如果是 Java 应用只需要挂载一个 agent 就可以自动采集系统的指标、链路信息、日志等上传到 Collector 中。</p><p>也就是上图的左边部分。</p><p>之后就是非常关键的组件 collector，它可以通过 OTLP 协议接收刚才提到的客户端上传的数据，然后再内部进行处理，最终输出到后续的存储系统中。</p><h2 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h2><p><img src="https://s2.loli.net/2024/04/16/l8Jfcak9bsUCwTZ.png"></p><blockquote><p>上图是 collector 的架构图</p></blockquote><p>由于 OpenTelemetry 设计之初就是要做到厂商无关，所以它就得做出更高层级的设计。</p><p>关键点就是这里的 Receiver 和 Exporter 都是模块化的设计，第三方开发者可以基于它的标准开发不同组件从而兼容不同的产品。</p><p>Receiver：用于接收客户端上报的数据，不止是自己 agent 上报的数据，也可能会来自不同的厂商，比如 kubernetes、Kafka 等。</p><p>Exporter：同理，可以将 receiver 收到的数据进行处理之后输出到不同的组件中；比如 Kafka&#x2F;Pulsar&#x2F;Promethus&#x2F;Jaeger 等。</p><p>比如我们可以使用 <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/nginxreceiver">Nginx Receiver</a>接收来着 Nginx 上报的数据。</p><p>使用 <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/mysqlreceiver">MySQL Receiver</a>接收来自 MySQL 的数据。</p><p>当然通常我们使用最多的还是 <a href="https://github.com/open-telemetry/opentelemetry-collector/tree/main/receiver/otlpreceiver">OTLP Receiver</a>，这是官方的 OTLP 协议的接收器，可以接受官方的一些指标，比如我们只使用了 Java Agent 进行数据上报时。<br><img src="https://s2.loli.net/2024/04/16/WP46czTSAdYqKgb.png"><br><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver">https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver</a></p><p>在这里是可以看到目前支持的所有第三方的 Receiver。</p><hr><p><img src="https://s2.loli.net/2024/04/16/JxyICv8wHb7paZW.png"></p><p>OpenTelemetry 所支持的 Exporter 也很多，比如一些常见的存储：</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/clickhouseexporter">clickhouse exporter</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/elasticsearchexporter">elasticsearch exporter</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/pulsarexporter">pulsar exporter</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/prometheusexporter">prometheus exporter</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-collector/tree/main/exporter/otlphttpexporter">otlp http exporter</a></li></ul><p>Exporter 的使用场景很多：如果是指标相关的数据可以直接写入 Prometheus，如果是日志数据也可以直接写入 ElasticSearch。</p><p>如果还有其他的特殊需求（删减属性等）则可以写入消息队列，自行处理完之后再发往 collector 进行后续的处理。</p><p>可能你已经发现了，由于 collector 非常的灵活，所以我们可以像搭积木一样组装我们的 receiver 和 exporter，它会以我们配置的流水线的方式进行调用，这样我们就可以实现任意可定制的处理逻辑。</p><p>而这些流水线的组装对于客户端来说都是透明的，也就是说 collector 的更改完全不会影响到业务；业务只需要按照 OTLP 的格式上报数据即可。</p><p>在之前的从 Skywalking 切换到 OpenTelemetry 的文章中有人问为什么要切换到 OpenTelemetry？</p><p>从这里也能看得出来，OpenTelemetry 的灵活度非常高，借助于 Exporter 可以任意的更换后端存储，或者增加&#x2F;删减一些不需要的指标数据等。</p><hr><p>当然我们也可以统一的在这里进行搜索，可以列出所有的第三方集成的组件：<br><a href="https://opentelemetry.io/ecosystem/registry/">https://opentelemetry.io/ecosystem/registry/</a></p><p><img src="https://s2.loli.net/2024/04/16/XvOx5i9LImhDTe4.png"></p><h1 id="OpenTelemetry-项目介绍"><a href="#OpenTelemetry-项目介绍" class="headerlink" title="OpenTelemetry 项目介绍"></a>OpenTelemetry 项目介绍</h1><h2 id="opentelemetry-java"><a href="#opentelemetry-java" class="headerlink" title="opentelemetry-java"></a>opentelemetry-java</h2><p>介绍完基本的概念后，我们可以看看  OTel 社区的一些主要开源项目。<br><img src="https://s2.loli.net/2024/04/16/t3rWKEuHpTRjL7I.png"></p><p>这里我们还是以刚才的那个架构图从作往右讲起，也就是主要分为客户端和 collector 端。</p><p><img src="https://s2.loli.net/2024/04/16/zWAVoHaZORI83js.png"><br>目前官方支持的客户端语言已经非常齐全了，大部分的版本都已经是 Stable 稳定版，意味着可以进入生产环境。</p><p>这里我们以 Java 客户端为例：<br><img src="https://s2.loli.net/2024/04/16/Oea2KwgZYVS8qPf.png"><br>其中我们重点关注下 opentelemetry-java 和 opentelemetry-java-instrumentation 这两个项目。</p><p>我们用的最多的会是 <code>opentelemetry-java-instrumentation</code>，它会给我们提供一个 java agent 的 JAR 包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:path/to/opentelemetry-javaagent.jar \</span><br><span class="line">     -jar myapp.jar</span><br></pre></td></tr></table></figure><p>我们只需要在 Java 应用中加上该  agent 就可以实现日志、指标、trace 的自动上报。</p><p>而且它还实现了不同框架、库的指标采集与 trace。</p><p>在这里可以查到支持的库与框架列表：<br><img src="https://s2.loli.net/2024/04/17/kMDcrPwxJy4oZYe.png"></p><p><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md#libraries--frameworks">https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md#libraries--frameworks</a></p><blockquote><p>总之几乎就是你能想到和不能想到的都支持了。</p></blockquote><p>而 opentelemetry-java 我们直接使用的几率会小一些，opentelemetry-java-instrumentation 本身也是基于它创建的，可以理解为是 Java 版本的核心基础库，一些社区支持的组件就可以移动到 <code>instrumentation</code> 这个库中。</p><p>比如我在上篇文章：<a href="https://juejin.cn/post/7356138322367266854">从一个 JDK21+OpenTelemetry 不兼容的问题讲起</a>中涉及到的 <code>HostResourceProvider</code> 资源加载就是从 <code>opentelemetry-java</code> 中移动到了 <code>opentelemetry-java-instrumentation</code>。</p><p>具体可以参考：<a href="https://github.com/open-telemetry/opentelemetry-java/issues/4701">https://github.com/open-telemetry/opentelemetry-java/issues/4701</a></p><h2 id="collector"><a href="#collector" class="headerlink" title="collector"></a>collector</h2><p><img src="https://s2.loli.net/2024/04/16/2MaF7IwWvg9f1TS.png"></p><p>之后就是 collector 的组件了，它同样的也有两个库：<br><strong>OpenTelemetry Collector</strong> 和 <strong>OpenTelemetry Collector Contrib</strong></p><p>其实通过他们的名字也可以看得出来，他们的作用与刚才的 Java 库类似：</p><ul><li>opentelemetry-collector：由官方社区维护，提供了一些核心能力；比如只包含了最基本的 otlp 的 receiver 和 exporter。</li><li>opentelemetry-collector-contrib：包含了官方的 collector，同时更多的维护了社区提供的各种 receiver 和 exporter；就如上文提到的，一些社区组件（pulsar、MySQL、Kafka）等都维护在这个仓库。</li></ul><p>而我们生产使用时通常也是直接使用 opentelemetry-collector-contrib，毕竟它所支持的社区组件更多。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为 OpenTelemetry 想要解决的是整个可观测领域的所有需求，所以仓库非常多，社区也很开放，感兴趣的朋友可以直接参与贡献，这么多 repo 总有一个适合你的。</p><p>后续会继续讲解如何安装以及配置我们的 OpenTelemetry。</p><p>参考链接：</p><ul><li><a href="https://github.com/pinpoint-apm/pinpoint">https://github.com/pinpoint-apm/pinpoint</a></li><li><a href="https://github.com/codecentric/spring-boot-admin">https://github.com/codecentric/spring-boot-admin</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java">https://github.com/open-telemetry/opentelemetry-java</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation">https://github.com/open-telemetry/opentelemetry-java-instrumentation</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java/issues/4701">https://github.com/open-telemetry/opentelemetry-java/issues/4701</a></li></ul><p>#Blog #OpenTelemetry </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前陆续写过一些和 OpenTelemetry 相关的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2024/04/07/ob/otel-replace-sw/&quot;&gt;实战：如何优雅的从 Skywalking 切换到 OpenTelemetry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/&quot;&gt;实战：如何编写一个 OpenTelemetry Extensions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7356138322367266854&quot;&gt;从一个 JDK21+OpenTelemetry 不兼容的问题讲起&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些内容的前提是最好有一些 OpenTelemetry 的背景知识，看起来就不会那么枯燥，为此这篇文章就来做一个入门科普，方便一些对 OpenTelemetry 不是那么熟的朋友快速掌握一些 OpenTelemetry 的基本概念。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>从一个 JDK21+OpenTelemetry 不兼容的问题讲起</title>
    <link href="http://crossoverjie.top/2024/05/13/ob/jdk21+springboot+OTel+SPI/"/>
    <id>http://crossoverjie.top/2024/05/13/ob/jdk21+springboot+OTel+SPI/</id>
    <published>2024-05-13T15:31:40.000Z</published>
    <updated>2024-05-13T07:57:01.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间公司领导让我排查一个关于在 JDK21 环境中使用 Spring Boot 配合一个 JDK18 新增的一个 SPI(<code>java.net.spi.InetAddressResolverProvider</code>) 不生效的问题。</p><p>但这个不生效的前置条件有点多：</p><ul><li>JDK 的版本得在 18+</li><li>SpringBoot3.x</li><li>还在额外再配合使用 <code>-javaagent:opentelemetry-javaagent.jar</code> 使用，也就是 OpenTelemetry 提供的 agent。</li></ul><p>才会导致自定义的 <code>InetAddressResolverProvider</code> 无法正常工作。</p><span id="more"></span><hr><p>在复现这个问题之前先简单介绍下 <code>java.net.spi.InetAddressResolverProvider</code> 这个 SPI；它是在 JDK18 之后才提供的，在这之前我们使用 <code>InetAddress</code> 的内置解析器来解析主机名和 IP 地址，但这个解析器之前是不可以自定义的。</p><p>在某些场景下会不太方便，比如我们需要请求 <code>order.service</code> 这个域名时希望可以请求到某一个具体 IP 地址上，我们可以自己配置 host ，或者使用服务发现机制来实现。</p><p>但现在通过 <code>InetAddressResolverProvider</code> 就可以定义在请求这个域名的时候返回一个我们预期的 IP 地址。</p><p>同时由于它是一个 SPI，所以我们只需要编写一个第三方包，任何项目依赖它之后在发起网络请求时都会按照我们预期的 IP 进行请求。</p><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>要使用它也很简单，主要是两个类：</p><ul><li><code>InetAddressResolverProvider</code>：这是一个抽象类，我们可以继承它之后重写它的 get 函数返回一个 <code>InetAddressResolver</code> 对象</li><li><code>InetAddressResolver</code>：一个接口，主要提供了两个函数；一个用于传入域名返回 IP 地址，另一个反之：传入 IP 地址返回域名。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAddressResolverProvider</span> <span class="keyword">extends</span> <span class="title class_">InetAddressResolverProvider</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InetAddressResolver <span class="title function_">get</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyAddressResolver</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyAddressResolverProvider Internet Address Resolver Provider&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAddressResolver</span> <span class="keyword">implements</span> <span class="title class_">InetAddressResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAddressResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====MyAddressResolver&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Stream&lt;InetAddress&gt; <span class="title function_">lookupByName</span><span class="params">(String host, LookupPolicy lookupPolicy)</span></span><br><span class="line">            <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="keyword">if</span> (host.equals(<span class="string">&quot;fedora&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Stream.of(InetAddress.getByAddress(<span class="keyword">new</span> <span class="title class_">byte</span>[] &#123;<span class="number">127</span>, <span class="number">127</span>, <span class="number">10</span>, <span class="number">1</span>&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(InetAddress.getByAddress(<span class="keyword">new</span> <span class="title class_">byte</span>[] &#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">lookupByAddress</span><span class="params">(<span class="type">byte</span>[] addr)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;++++++&quot;</span> + addr[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + addr[<span class="number">1</span>] + <span class="string">&quot; &quot;</span> + addr[<span class="number">2</span>] + <span class="string">&quot; &quot;</span> + addr[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot;fedora&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">```<span class="type">java</span></span><br><span class="line"><span class="variable">addresses</span> <span class="operator">=</span> InetAddress.getAllByName(<span class="string">&quot;fedora&quot;</span>);</span><br><span class="line"><span class="comment">// output: 127 127 10 1</span></span><br></pre></td></tr></table></figure><p>这里我简单实现了一个对域名 fedora 的解析，会直接返回 <code>127.127.10.1</code>。</p><p>如果使用 IP 地址进行查询时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InetAddress</span> <span class="variable">byAddress</span> <span class="operator">=</span> InetAddress.getByAddress(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">127</span>, <span class="number">127</span>, <span class="number">10</span>, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;+++++&quot;</span> + byAddress.getHostName());</span><br><span class="line"><span class="comment">// output: fedora</span></span><br></pre></td></tr></table></figure><p>当然要要使得这个 SPI 生效的前提条件是我们需要新建一个文件：<br><code>META-INF/services/java.net.spi.InetAddressResolverProvider</code><br>里面的内容是我们自定义类的全限定名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.example.demo.MyAddressResolverProvider</span><br></pre></td></tr></table></figure><p>这样一个完整的 SPI 就实现完成了。</p><hr><p>正常情况下我们将应用打包为一个 jar 之后运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>是可以看到输出结果是符合预期的。</p><p>一旦我们使用配合上 spring boot 打包之后，也就是加上以下的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次执行其实也没啥问题，也能按照预期输出结果。</p><p>但我们加上 OpenTelemetry 的 agent 时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java  -javaagent:opentelemetry-javaagent.jar \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>就会发现在执行解析的时候抛出了 <code>java.net.UnknownHostException</code>异常。</p><p><img src="https://s2.loli.net/2024/04/08/owZLIF7yzUpSdjn.png"><br>从结果来看就是没有进入我们自定义的解析器。</p><h1 id="SPI-原理"><a href="#SPI-原理" class="headerlink" title="SPI 原理"></a>SPI 原理</h1><p>在讲排查过程之前还是要先预习下关于 Java SPI 的原理以及应用场景。</p><p>以前写过一个 http 框架 <a href="https://github.com/TogetherOS/cicada">cicada</a>，其中有一个可拔插 IOC 容器的功能：</p><blockquote><p>就是可以自定义实现自己的 IOC 容器，将自己实现的 IOC 容器打包为一个第三方包加入到依赖中，cicada 框架就会自动使用自定义的 IOC 实现。</p></blockquote><p>要实现这个功能本质上就是要定义一个接口，然后根据依赖的不同实现创建接口的实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CicadaBeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register into bean Factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object object)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get bean from bean Factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get bean by class type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * release all beans</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">releaseBean</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取具体的示例代码时就只需要使用 JDK 内置的 <code>ServiceLoader</code> 进行加载即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CicadaBeanFactory <span class="title function_">getCicadaBeanFactory</span><span class="params">()</span> &#123;  </span><br><span class="line">    ServiceLoader&lt;CicadaBeanFactory&gt; cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);  </span><br><span class="line">    <span class="keyword">if</span> (cicadaBeanFactories.iterator().hasNext())&#123;  </span><br><span class="line">        <span class="keyword">return</span> cicadaBeanFactories.iterator().next() ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CicadaDefaultBean</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码也非常的简洁，和刚才提到的 <code>InetAddressResolverProvider</code> 一样我们需要新增一个 <code>META-INF/services/top.crossoverjie.cicada.base.bean.CicadaBeanFactory</code> 文件来配置我们的类名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNextService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// PREFIX = META-INF/services/</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="literal">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ServiceLoader 类中会会去查找 <code>META-INF/services</code> 的文件，然后解析其中的内容从而反射生成对应的接口对象。</p><p>这里还有一个关键是通常我们的代码都会打包为一个 JAR 包，类加载器需要加载这个  JAR 包，同时需要在这个 JAR 包里找到我们之前定义的那个 spi 文件，如果这里查不到文件那就认为没有定义 SPI。</p><p>这个是本次问题的重点，会在后文分析原因的时候用到。</p><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>因为问题就出现在是否使用 opentelemetry-javaagent.jar 上，所以我需要知道在使用了 agent 之后有什么区别。</p><p>从刚才的对 SPI 的原理分析，加上 agent 出现异常，说明理论上就是没有读取到我们配置的文件: <code>java.net.spi.InetAddressResolverProvider</code>。</p><p>于是我便开始 debug，在 ServiceLoader 加载 jar 包的时候是可以看到具体使用的是什么 <code>classLoader</code> 。</p><p>这是不配置 agent 的时候使用的 classLoader：<br><img src="https://s2.loli.net/2024/04/10/kgR1hOzKbnGMJUA.png"><br>使用这个 loader 是可以通过文件路径在 jar 包中查找到我们配置的文件。</p><p>而配置上 agent 之后使用的 classLoader:<br><img src="https://s2.loli.net/2024/04/10/45sUKGr6xeVPNXA.png"><br>却是一个 JarLoader，这样是无法加载到在 springboot 格式下的配置文件的，至于为什么加载不到，那就要提一下 maven 打包后的文件目录和 spring boot 打包后的文件目录的区别了。</p><p><img src="https://s2.loli.net/2024/04/10/ZtDCc7SvXFHmL9J.png"><br>这里我截图了同样的一份代码不同的打包方式：<br>上面的是传统 maven，下图是 spring boot；其实主要的区别就是在 pom 中使用了一个构建插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>或者使用 <code>spring-boot</code> 命令再次打包的效果也是一样的。</p></blockquote><p>会发现 spring boot 打包后会多出一层 <code>BOOT-INF</code> 的文件夹，然后会在 <code>MANIFIST.MF</code> 文件中定义 <code>Main-Class</code> 和 <code>Start-Class</code>.</p><hr><p>通过上面的 debug 其实会发现 JarLoader 只能在加载 maven 打包后的文件，也就是说无法识别 BOOT-INF 这个目录。</p><p>正常情况下 spring boot 中会有一个额外的 <code>java.nio.file.spi.FileSystemProvider</code> 实现:<br><img src="https://s2.loli.net/2024/04/10/iFus4tA1KXEMYkq.png"><br>通过这个类的实现可以直接从 JAR 包中加载资源，比如我们自定义的 SPI 资源等。</p><p>初步判断使用 <code>opentelemetry-javaagent.jar</code>的 agent 之后，它的类加载器优先于了 spring boot ，从而导致后续的加载失败。</p><h2 id="远程-debug"><a href="#远程-debug" class="headerlink" title="远程 debug"></a>远程 debug</h2><p>这里穿插几个 debug 小技巧，其中一个是远程 debug，因为这里我是需要调试 javaagent，正常情况下是无法直接 debug 的。</p><p>所以我们可以使用以下命令启动应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=&quot;transport=dt_socket,server=y,suspend=y,address=5000&quot; -javaagent:opentelemetry-javaagent.jar \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/04/10/D2z4krNyHAanSlC.png"></p><p>然后在 idea 中配置一个 remote 启动。</p><blockquote><p>注意这里的端口得和命令行中的保持一致。</p></blockquote><p>当应用启动之后便可以在 idea 中启动这个 remote 了，这样便可以正常 debug 了。</p><h2 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h2><p>第二个是条件断点也非常有用，有时候我们需要调试一个公共函数，调用的地方非常多。</p><p>而我们只需要关心某一类行为的调用，此时就可以对这个函数中的变量进行判断，当他们满足某些条件时再进入断点，这样可以极大的提高我们的调试效率：<br><img src="https://s2.loli.net/2024/04/10/L9PkNyZprCql6Wd.png"></p><p>配置也很简单，只需要在断点上右键就可以编辑条件了。</p><h1 id="社区咨询"><a href="#社区咨询" class="headerlink" title="社区咨询"></a>社区咨询</h1><p>虽然我根据现象初步可以猜测下原因，但依然不确定如何调整才能解决这个问题，于是便去社区提了一个 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/10921">issue</a>。</p><p><img src="https://s2.loli.net/2024/04/10/YHiIOfvxu1EUMpj.png"><br>最后在社区大佬的帮助下发现我们需要禁用掉 OpenTelemetry agent 中的一个 resource 就可以了。</p><p><img src="https://s2.loli.net/2024/04/10/EiX3mD9k6cwjMUf.png"><br>这个 resource 是由 agent 触发的，它优先于 spring boot 之前进行 SPI 的加载。<br>目的是为了给 metric 和 trace 新增两个属性：<br><img src="https://s2.loli.net/2024/04/10/I39iXt4JfdwVn8S.png"></p><p><img src="https://s2.loli.net/2024/04/10/bH3wfUeCk4K9PJ5.png"><br>加载的核心代码在这里，只要禁用掉之后就不会再加载了。</p><p>禁用前：<br><img src="https://s2.loli.net/2024/04/10/7ZIo2VaqesFXL53.png"></p><p>禁用后：<br><img src="https://s2.loli.net/2024/04/10/k2yQBPxzMHFENjd.png"></p><p>当我们禁用掉之后就不会存在这两个属性了，不过我们目前并没有使用这两个属性，所以为了使得 SPI 生效就只有先禁用掉了，后续再看看社区还有没有其他的方案。</p><p>想要复现 debug 的可以在这里尝试：<br><a href="https://github.com/crossoverJie/demo">https://github.com/crossoverJie/demo</a></p><p>参考连接：</p><ul><li><a href="https://github.com/TogetherOS/cicada">https://github.com/TogetherOS/cicada</a></li><li><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#packaging.repackage-goal">https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#packaging.repackage-goal</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/10921">https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/10921</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/instrumentation/resources/library/README.md#host">https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/instrumentation/resources/library/README.md#host</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间公司领导让我排查一个关于在 JDK21 环境中使用 Spring Boot 配合一个 JDK18 新增的一个 SPI(&lt;code&gt;java.net.spi.InetAddressResolverProvider&lt;/code&gt;) 不生效的问题。&lt;/p&gt;
&lt;p&gt;但这个不生效的前置条件有点多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK 的版本得在 18+&lt;/li&gt;
&lt;li&gt;SpringBoot3.x&lt;/li&gt;
&lt;li&gt;还在额外再配合使用 &lt;code&gt;-javaagent:opentelemetry-javaagent.jar&lt;/code&gt; 使用，也就是 OpenTelemetry 提供的 agent。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;才会导致自定义的 &lt;code&gt;InetAddressResolverProvider&lt;/code&gt; 无法正常工作。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>如何对 kubernetes 应用做 e2e(端到端) 测试</title>
    <link href="http://crossoverjie.top/2024/05/05/ob/operator-e2e-test/"/>
    <id>http://crossoverjie.top/2024/05/05/ob/operator-e2e-test/</id>
    <published>2024-05-05T07:18:05.000Z</published>
    <updated>2024-05-05T13:13:35.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在给 <a href="https://github.com/open-telemetry/opentelemetry-operator/pull/2778">opentelemetry-operator</a>提交一个标签选择器的功能时，因为当时修改的函数是私有的，无法添加单测函数，所以社区建议我补充一个 <code>e2e test</code>.</p><blockquote><p>因为在当前的版本下，只要给 deployment 打上了 <code>instrumentation.opentelemetry.io/inject-java: &quot;true&quot;</code> 这类注解就会给该 deployment 注入 agent。<br>但没办法指定不同的 agent 版本（或者不同的环境变量），所以希望可以新增一个选择器，同时可以针对不同的 deployment 维护不同版本的 <code>Instrumentation</code>(是用于控制需要注入 deployment 的资源)；这样就可以灵活控制了。</p></blockquote><span id="more"></span><p><img src="https://s2.loli.net/2024/03/26/8QEaeXC9YwJp56m.png"></p><p>在这之前我其实也很少做 kubernetes 的 operator 开发，对如何做 kubernetes 的 e2e 测试也比较陌生，好在社区提供了详细的贡献文档。</p><p><img src="https://s2.loli.net/2024/03/26/Fv6SCofEtubZjcH.png"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>简单来说需要两个关键组件：</p><ul><li><a href="https://kind.sigs.k8s.io/">kind</a>: kubernetes in docker，是可以在本地利用 docker 启动一个 kubernetes 集群的工具，通常用于在本地进行开发、测试关于 kubernetes 相关的功能。<ul><li>安装 kind 的前提是本地已经安装好了 docker。</li></ul></li><li><a href="https://kyverno.github.io/chainsaw/latest/">chainsaw</a>: 一个 e2e 测试框架，提供了声明式的方式定义测试用例，也有着丰富断言功能。</li></ul><p>他们的安装都很简单，只要本地安装好了 golang，直接使用 go install 即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go install sigs.k8s.io/kind@v0.22.0</span><br><span class="line">go install github.com/kyverno/chainsaw@latest</span><br></pre></td></tr></table></figure><h2 id="kind-使用"><a href="#kind-使用" class="headerlink" title="kind 使用"></a>kind 使用</h2><p>在开始前还是先预习下 kind 的基本使用。</p><p>安装好 kind 之后，使用 create cluster 命令可以在本地创建一个 <code>kubernetes</code> 集群。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kind create cluster -h</span><br><span class="line">Creates a local Kubernetes cluster using Docker container &#x27;nodes&#x27;</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  kind create cluster [flags]</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/03/27/znDfd3m5HeyrXi4.png"><br>之后只需要等待集群安装成功即可，它会在我们的 <code>cat ~/.kube/config</code> 文件中追加刚才新建集群的连接信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k config get-contexts</span><br><span class="line">k config use-context xxx</span><br></pre></td></tr></table></figure><p>这样就可以使用这两个命令来查看和切换不同的集群了，虽说是一个本地模拟的 kubernetes 集群，但他的核心功能和一个标准的集群没有什么区别。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kind delete clusters --all</span><br></pre></td></tr></table></figure><p>使用完成之后可以使用这个命令将所有集群都删除掉。</p><h1 id="准备集群数据"><a href="#准备集群数据" class="headerlink" title="准备集群数据"></a>准备集群数据</h1><p>在 <code>opentelemetry-operator</code> 中有给我们准备好一个 make 命令: <code>make prepare-e2e</code> ；使用它会帮我们将 operator 的测试环境初始化好。</p><p>大概分为以下几步：</p><ul><li>安装 chainsaw</li><li>修改 controller 的镜像为我们本地构建的镜像名称</li><li>本地 docker 镜像打包</li><li>安装 cert-manager</li><li>安装 Operator 需要的 CRD</li><li>部署 Operator deployment</li><li>等待 Operator 启动成功</li></ul><p>不过这里的安装过程可能会遇到问题（本质上都是我们的网络问题）：<br><img src="https://s2.loli.net/2024/03/25/bYWdfOv9B27c8RE.png"><br><img src="https://s2.loli.net/2024/03/25/kH4b7I3UlngzENA.png"><br>这种情况可以想办法（科学上网）手动先把镜像拉取到本地，然后 kubernetes 就会从本地仓库获取到这个镜像。</p><h1 id="e2e-test"><a href="#e2e-test" class="headerlink" title="e2e test"></a>e2e test</h1><p>通常我们需要将同一类的测试功能放到一个文件夹里，比如这样：<br><img src="https://s2.loli.net/2024/03/27/eh8Rk4uFfWTHtna.png"><br>默认情况下 Chainsaw 会查找目录下名为 <code>chainsaw-test.yaml</code> 作为引导文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">chainsaw.kyverno.io/v1alpha1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Test</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">instrumentation-java</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">steps:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">step-00</span>  </span><br><span class="line">    <span class="attr">try:</span>   </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">command:</span>  </span><br><span class="line">        <span class="attr">entrypoint:</span> <span class="string">kubectl</span>  </span><br><span class="line">        <span class="attr">args:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">annotate</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">namespace</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">$&#123;NAMESPACE&#125;</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">openshift.io/sa.scc.uid-range=1000/1000</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">--overwrite</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">command:</span>  </span><br><span class="line">        <span class="attr">entrypoint:</span> <span class="string">kubectl</span>  </span><br><span class="line">        <span class="attr">args:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">annotate</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">namespace</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">$&#123;NAMESPACE&#125;</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">openshift.io/sa.scc.supplemental-groups=3000/3000</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">--overwrite</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">apply:</span>  </span><br><span class="line">        <span class="attr">file:</span> <span class="number">00</span><span class="string">-install-collector.yaml</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">apply:</span>  </span><br><span class="line">        <span class="attr">file:</span> <span class="number">00</span><span class="string">-install-instrumentation-select.yaml</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">step-01</span>  </span><br><span class="line">    <span class="attr">try:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">apply:</span>  </span><br><span class="line">        <span class="attr">file:</span> <span class="number">01</span><span class="string">-install-app-select.yaml</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">assert:</span>  </span><br><span class="line">        <span class="attr">file:</span> <span class="number">01</span><span class="string">-assert*.yaml</span>  </span><br><span class="line">    <span class="attr">catch:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">podLogs:</span>  </span><br><span class="line">          <span class="attr">selector:</span> <span class="string">app=my-java-select</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tests/e2e-instrumentation/instrumentation-select</span><br><span class="line">├── 00-install-collector.yaml</span><br><span class="line">├── 00-install-instrumentation-select.yaml</span><br><span class="line">├── 01-assert-select.yaml</span><br><span class="line">├── 01-assert-without-select.yaml</span><br><span class="line">├── 01-install-app-select.yaml</span><br><span class="line">└── chainsaw-test.yaml</span><br></pre></td></tr></table></figure><p>以我这里的这份文件为例，在其中定义了几个步骤：</p><ul><li>初始化环境信息，包含创建 namespace</li><li>安装我们测试所需要的资源<ul><li>00-install-collector.yaml：这里主要是安装一个 OpenTelemetry 的 collector</li><li>00-install-instrumentation-select.yaml：安装 Instrumentation 注入资源</li><li>01-install-app-select.yaml：应用一个我们需要测试的 deployment 资源</li><li><code>01-assert*.yaml</code>：最后对最终生成的 yaml 资源与 assert*.yaml 的进行断言匹配，只有匹配成功后才能测试成功。</li></ul></li></ul><blockquote><p>这里的测试目的主要是完成一个完整的 Java 应用的 deployment 注入 OpenTelemetry 的 agent 过程还有一些与 OpenTelemetry 相关的环境变量。</p></blockquote><p>以 <code>00-install-instrumentation-select.yaml</code> 文件为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">opentelemetry.io/v1alpha1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Instrumentation</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">java-select</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">my-java-select</span>  </span><br><span class="line">  <span class="attr">env:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_TRACES_EXPORTER</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">otlp</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXPORTER_OTLP_ENDPOINT</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">http://localhost:4317</span>  </span><br><span class="line">  <span class="attr">exporter:</span>  </span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">http://localhost:4317</span>  </span><br><span class="line">  <span class="attr">propagators:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">jaeger</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">b3</span>  </span><br><span class="line">  <span class="attr">sampler:</span>  </span><br><span class="line">    <span class="attr">type:</span> <span class="string">parentbased_traceidratio</span>  </span><br><span class="line">    <span class="attr">argument:</span> <span class="string">&quot;0.25&quot;</span>  </span><br><span class="line">  <span class="attr">java:</span>  </span><br><span class="line">    <span class="attr">env:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_JAVAAGENT_DEBUG</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;true&quot;</span>  </span><br></pre></td></tr></table></figure><p>它的预期效果是选择 <code>app: my-java-select</code> 的 deployment 将这些环境变量都注入进去，同时默认也会在 deployment 的容器中挂载一个 <code>javaagent.jar</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /otel-auto-instrumentation-java/</span><br><span class="line">javaagent.jar</span><br></pre></td></tr></table></figure><p>而我们的 <code>01-assert-select.yaml</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">annotations:</span>  </span><br><span class="line">    <span class="attr">instrumentation.opentelemetry.io/inject-java:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">    <span class="attr">sidecar.opentelemetry.io/inject:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-java-select</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">containers:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">env:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_JAVAAGENT_DEBUG</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">JAVA_TOOL_OPTIONS</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">&#x27; -javaagent:/otel-auto-instrumentation-java/javaagent.jar&#x27;</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_TRACES_EXPORTER</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">otlp</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXPORTER_OTLP_ENDPOINT</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">http://localhost:4317</span>    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_TRACES_SAMPLER</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">parentbased_traceidratio</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_SERVICE_NAME</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">my-java-select</span>   </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_PROPAGATORS</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">jaeger,b3</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_RESOURCE_ATTRIBUTES</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">myapp</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">args:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">--config=env:OTEL_CONFIG</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">otc-container</span>  </span><br><span class="line">  <span class="attr">initContainers:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">opentelemetry-auto-instrumentation-java</span>  </span><br><span class="line"><span class="attr">status:</span>  </span><br><span class="line">  <span class="attr">containerStatuses:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span>  </span><br><span class="line">    <span class="attr">ready:</span> <span class="literal">true</span>  </span><br><span class="line">    <span class="attr">started:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">initContainerStatuses:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">opentelemetry-auto-instrumentation-java</span>  </span><br><span class="line">    <span class="attr">ready:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">phase:</span> <span class="string">Running</span></span><br></pre></td></tr></table></figure><p>最终就是把实际的 <code>deployment</code> 的 yaml 内容和这份文件进行对比。</p><p>所以这个 e2e 测试就有点类似于集成测试，不会测试具体的功能函数，只需要最终结果能匹配就可以。</p><blockquote><p>当然这个和单元测试也是相辅相成的，缺一不可，不能完全只依赖 e2e 测试，也有可能是概率原因导致最终生成的资源相同；单元测试可以保证函数功能与预期相同。</p></blockquote><hr><p>都准备好之后便可以进行测试了，测试的时候也很简单，只需要执行以下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chainsaw test --test-dir ./tests/e2e-multi-instrumentation</span><br></pre></td></tr></table></figure><p>这样它就会遍历该目录下的 <code>chainsaw-test.yaml</code>文件进行测试，执行我们上面定义的那些步骤，最终输出测试结果：</p><p><img src="https://s2.loli.net/2024/03/27/VBwbKLdGjIXODrF.png"></p><p>同时 Chainsaw 也提供了 Github action，可以方便的让我们和 github CI 进行集成。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">example:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">permissions:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Chainsaw</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Chainsaw</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">kyverno/action-install-chainsaw@v0.1.0</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">release:</span> <span class="string">v0.0.9</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Check</span> <span class="string">install</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">chainsaw</span> <span class="string">version</span></span><br></pre></td></tr></table></figure><p>这样我们就可以在 github 中查看我们的测试结果了：<br><img src="https://s2.loli.net/2024/03/27/MaoL7EBmOZfsHd9.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后不得不感叹作为 CNCF 下面的项目 OpenTelemetry 的开发者体验真好，只要我们跟着<a href="https://github.com/open-telemetry/opentelemetry-operator/blob/main/CONTRIBUTING.md">贡献者文档</a>一步步操作都能顺利通过 CI 测试，同时还能避免一些 Code Review 过程中的低级错误。</p><p><img src="https://s2.loli.net/2024/03/27/kQGfWAhYHiyNXUq.png"><br>比如我第一次提 PR 的时候没有添加 changlog 文件，后面在贡献者手册里发现只需要执行 <code>make chlog-new</code> 就会基于当前分支信息帮我们生成一个 changelog 文件模板，然后只需要往里面填写内容即可。</p><p>这些工具链让不同开发者提交的代码和流程都符合规范，同时也降低了贡献难度。</p><p>以上所有的相关源码都可以在 <a href="https://github.com/open-telemetry/opentelemetry-operator">https://github.com/open-telemetry/opentelemetry-operator</a> 中进行查看。</p><p>参考链接：</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-operator/pull/2778">https://github.com/open-telemetry/opentelemetry-operator/pull/2778</a></li><li><a href="https://kind.sigs.k8s.io/">https://kind.sigs.k8s.io/</a></li><li><a href="https://kyverno.github.io/chainsaw/latest/">https://kyverno.github.io/chainsaw/latest/</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-operator/blob/main/CONTRIBUTING.md">https://github.com/open-telemetry/opentelemetry-operator/blob/main/CONTRIBUTING.md</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近在给 &lt;a href=&quot;https://github.com/open-telemetry/opentelemetry-operator/pull/2778&quot;&gt;opentelemetry-operator&lt;/a&gt;提交一个标签选择器的功能时，因为当时修改的函数是私有的，无法添加单测函数，所以社区建议我补充一个 &lt;code&gt;e2e test&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为在当前的版本下，只要给 deployment 打上了 &lt;code&gt;instrumentation.opentelemetry.io/inject-java: &amp;quot;true&amp;quot;&lt;/code&gt; 这类注解就会给该 deployment 注入 agent。&lt;br&gt;但没办法指定不同的 agent 版本（或者不同的环境变量），所以希望可以新增一个选择器，同时可以针对不同的 deployment 维护不同版本的 &lt;code&gt;Instrumentation&lt;/code&gt;(是用于控制需要注入 deployment 的资源)；这样就可以灵活控制了。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="k8s" scheme="http://crossoverjie.top/tags/k8s/"/>
    
    <category term="operator" scheme="http://crossoverjie.top/tags/operator/"/>
    
  </entry>
  
</feed>
