<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverJie&#39;s Blog</title>
  
  <subtitle>baller</subtitle>
  <link href="http://crossoverjie.top/atom.xml" rel="self"/>
  
  <link href="http://crossoverjie.top/"/>
  <updated>2023-11-26T11:14:57.135Z</updated>
  <id>http://crossoverjie.top/</id>
  
  <author>
    <name>crossoverJie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k8s入门到实战-应用探针</title>
    <link href="http://crossoverjie.top/2023/11/25/ob/k8s-probe/"/>
    <id>http://crossoverjie.top/2023/11/25/ob/k8s-probe/</id>
    <published>2023-11-25T15:20:13.000Z</published>
    <updated>2023-11-26T11:14:57.135Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/11/26/5uwvC1TrsjMYDZF.png" alt="Probe.png"></p><p>今天进入 <code>kubernetes</code> 的运维部分（并不是运维 <code>kubernetes</code>，而是运维应用），其实日常我们大部分使用 <code>kubernetes</code> 的功能就是以往运维的工作，现在云原生将运维和研发关系变得更紧密了。</p><span id="more"></span><p>今天主要讲解 <code>Probe</code> 探针相关的功能，探针最实用的功能就是可以控制应用优雅上线。</p><h1 id="就绪探针"><a href="#就绪探针" class="headerlink" title="就绪探针"></a>就绪探针</h1><p>举个例子，当我们的 service 关联了多个 Pod 的时候，其中一个 Pod 正在重启但还没达到可以对外提供服务的状态，这时候如果有流量进入。</p><p>那这个请求肯定就会出现异常，从而导致问题，所以我们需要一个和 <code>kubernetes</code> 沟通的渠道，告诉它什么时候可以将流量放进来。<br><img src="https://s2.loli.net/2023/11/26/StHngQR4K9vCxjf.png" alt="image.png"><br>比如如图所示的情况，红色 <code>Pod</code> 在未就绪的时候就不会有流量。</p><p>使用就绪探针就可以达到类似的效果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span>  </span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">3</span>  </span><br><span class="line">  <span class="attr">httpGet:</span>  </span><br><span class="line">    <span class="attr">path:</span> <span class="string">/ping</span>  </span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span>  </span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">HTTP</span>  </span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">3</span>  </span><br><span class="line">  <span class="attr">successThreshold:</span> <span class="number">1</span>  </span><br><span class="line">  <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这个配置也很直接：</p><ul><li>配置一个 HTTP 的 ping 接口</li><li>每三秒检测一次</li><li>失败 3 次则认为检测失败</li><li>成功一次就认为检测成功</li></ul><blockquote><p>但没有配置就绪探针时，一旦 Pod 的 <code>Endpoint</code> 加入到 service 中(Pod 进入 <code>Running</code> 状态)，请求就有可能被转发过来，所以配置就绪探针是非常有必要的。</p></blockquote><h1 id="启动探针"><a href="#启动探针" class="headerlink" title="启动探针"></a>启动探针</h1><p>而启动探针往往是和就绪探针搭配干活的，如果我们一个 Pod 启动时间过长，比如超过上面配置的失败检测次数，此时 Pod 就会被 kubernetes 重启，这样可能会进入无限重启的循环。</p><p>所以启动探针可以先检测一次是否已经启动，直到启动成功后才会做后续的检测。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">startupProbe:</span>  </span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">30</span>  </span><br><span class="line">  <span class="attr">httpGet:</span>  </span><br><span class="line">    <span class="attr">path:</span> <span class="string">/ping</span>  </span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span>  </span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">HTTP</span>  </span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">5</span>  </span><br><span class="line">  <span class="attr">successThreshold:</span> <span class="number">1</span>  </span><br><span class="line">  <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>我这里两个检测接口是同一个，具体得根据自己是实际业务进行配置；<br>比如应用端口启动之后并不代表业务已经就绪了，可能某些基础数据还没加载到内存中，这个时候就需要自己写其他的接口来配置就绪探针了。</p></blockquote><h1 id="存活探针"><a href="#存活探针" class="headerlink" title="存活探针"></a>存活探针</h1><p>存活探针往往是用于保证应用高可用的，虽然 kubernetes 可以在 Pod 退出后自动重启，比如 <code>Pod OOM</code>；但应用假死他是检测不出来的。</p><p>为了保证这种情况下 Pod 也能被自动重启，就可以配合存活探针使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span>  </span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">3</span>  </span><br><span class="line">  <span class="attr">httpGet:</span>  </span><br><span class="line">    <span class="attr">path:</span> <span class="string">/ping</span>  </span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span>  </span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">HTTP</span>  </span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">3</span>  </span><br><span class="line">  <span class="attr">successThreshold:</span> <span class="number">1</span>  </span><br><span class="line">  <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>一旦接口响应失败，kubernetes 就会尝试重启。</p><p><img src="https://s2.loli.net/2023/11/26/khZlsDHLyX2WOxT.png" alt="image.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://s2.loli.net/2023/11/26/jRqSIbk4HmnsTWl.png" alt="image.png"></p><p>以上探针配置最好是可以在研效平台可视化配置，这样维护起来也比较简单。</p><p>探针是维护应用健康的必要手段，强烈推荐大家都进行配置。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/11/26/5uwvC1TrsjMYDZF.png&quot; alt=&quot;Probe.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天进入 &lt;code&gt;kubernetes&lt;/code&gt; 的运维部分（并不是运维 &lt;code&gt;kubernetes&lt;/code&gt;，而是运维应用），其实日常我们大部分使用 &lt;code&gt;kubernetes&lt;/code&gt; 的功能就是以往运维的工作，现在云原生将运维和研发关系变得更紧密了。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
  </entry>
  
  <entry>
    <title>技术阅读周刊第第7️⃣期</title>
    <link href="http://crossoverjie.top/2023/11/24/ob/newsletter/Newsletter07-20231124/"/>
    <id>http://crossoverjie.top/2023/11/24/ob/newsletter/Newsletter07-20231124/</id>
    <published>2023-11-24T09:28:25.000Z</published>
    <updated>2023-11-24T03:32:53.691Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/11/24/zGKworjfL7JkyQt.png" alt="image.png"></p><p><strong>技术阅读周刊，每周更新。</strong></p><h2 id="历史更新"><a href="#历史更新" class="headerlink" title="历史更新"></a>历史更新</h2><ul><li><a href="https://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/">20231013：第一期</a></li><li><a href="https://crossoverjie.top/2023/10/22/ob/newsletter/Newsletter02-20231022/">20231022：第二期</a></li><li><a href="https://crossoverjie.top/2023/10/27/ob/newsletter/Newsletter03-20231027/">20231027：第三期</a></li><li><a href="https://crossoverjie.top/2023/11/03/ob/newsletter/Newsletter04-20231103/">20231103：第四期</a></li><li><a href="https://crossoverjie.top/2023/11/10/ob/newsletter/Newsletter05-20231110/">20231107：第五期</a></li><li><a href="https://crossoverjie.top/2023/11/17/ob/newsletter/Newsletter06-20231117/">20231117：第六期</a><span id="more"></span></li></ul><h2 id="What-is-a-JWT-Understanding-JSON-Web-Tokens"><a href="#What-is-a-JWT-Understanding-JSON-Web-Tokens" class="headerlink" title="What is a JWT? Understanding JSON Web Tokens"></a>What is a JWT? Understanding JSON Web Tokens</h2><p>URL: <a href="https://supertokens.com/blog/what-is-jwt">https://supertokens.com/blog/what-is-jwt</a></p><blockquote><p>本文主要讲了一些 JWT 的基本原理，以及优缺点<br><img src="https://s2.loli.net/2023/11/20/iltd8qpuH6b75PY.png" alt="image.png"></p></blockquote><ul><li>JWT 的生成规则 <code>&lt;header&gt;.&lt;body&gt;.&lt;signature&gt;</code><ul><li>使用证书+签名算法创建签名 Key</li><li>将 header 和 body 的空格换行都去掉后进行 base64，然后使用 <code>.</code> 拼接起来。</li><li>将刚才拼接的字符串使用 <code>Base64 + HMACSHA256</code> 生成签名。</li><li>最终将 <code>&lt;header&gt;.&lt;body&gt;.&lt;signature&gt;</code> 拼接成 <code>JWT</code>。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Base64URLSafe</span>(   <span class="title class_">HMACSHA256</span>(<span class="string">&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJhYmNkMTIzIiwiZXhwaXJ5IjoxNjQ2NjM1NjExMzAxfQ&quot;</span>, <span class="string">&quot;NTNv7j0TuYARvmNMmWXo6fKvM4o6nv/aUi9ryX38ZH+L1bkrnD1ObOQ8JAUmHCBq7Iy7otZcyAagBLHVKvvYaIpmMuxmARQ97jUVG16Jkpkp1wXOPsrF9zwew6TpczyHkHgX5EuLg2MeBuiT/qJACs1J0apruOOJCg/gOtkjB4c=&quot;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="title class_">Results</span> <span class="attr">in</span>:</span><br><span class="line">3Thp81rDFrKXr3WrY1MyMnNK8kKoZBX9lg-<span class="title class_">JwFznR</span>-M</span><br></pre></td></tr></table></figure></li></ul></li><li>验证 JWT<ul><li>先获取 header，校验头里的签名类型和算法</li><li>获取 body，然后按照之前的方式 <code>Base64 + HMACSHA256</code> 生成签名</li><li>判断两者签名是否相同，不同则验证失败</li><li>判断过期时间是否过期</li></ul></li><li>JWT 的优点<ul><li>安全性：使用非对称加密保证数据不被篡改</li><li>高效，无状态：不需要单独使用数据库存储数据，只使用算法就能验证</li></ul></li><li>缺点<ul><li>因为他的独立性和无状态，除非是 token 过期了，不然很难撤销</li><li>依赖于第一步里生成的签名 Key，一旦这个 Key 被泄露就会被伪造。</li></ul></li></ul><h2 id="Go-开发中的十大常见陷阱-译"><a href="#Go-开发中的十大常见陷阱-译" class="headerlink" title="Go 开发中的十大常见陷阱[译]"></a>Go 开发中的十大常见陷阱[译]</h2><p>URL: <a href="https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/">https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/</a></p><blockquote><p>最近在  Reddit 上看到一个帖子，让推荐一本 Go 相关的书籍，大部分都是推荐的 “100 Go Mistakes and How to Avoid Them”，目前还没有中译版本，不过作者之前写过一个十个错误的博客，也可以预先看看。</p></blockquote><ul><li>未知的枚举值，将枚举的未知值设置为 0</li><li>自动优化的基准测试</li><li>被转移的指针，日常开发中建议传值，速度会更快。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loop:  </span><br><span class="line">  <span class="keyword">for</span> &#123;  </span><br><span class="line">    <span class="keyword">select</span> &#123;  </span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:  </span><br><span class="line">    <span class="comment">// Do something  </span></span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():  </span><br><span class="line">      <span class="keyword">break</span> loop  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>出乎意料的 break，在 select 语句中想要退出 for 循环，可以使用标签。</li><li>正确传递错误上下文，使用 <a href="https://github.com/pkg/errors">https://github.com/pkg/errors</a></li><li>扩容切片有性能损耗，如果知道长度可以在初始化时指定长度。</li><li>正确使用 context</li><li>做好函数抽象，可以参考 <code>io.Reader/io.Writer</code></li><li>在 goroutine 中使用循环调用的时候需要额外赋值，这个在  1.22 已经修复了。</li></ul><h2 id="Dapr-A-Portable-Event-Driven-Runtime-for-Building-Distributed-Applications-by-Seifeddine-Rajhi-Nov-2023-Medium"><a href="#Dapr-A-Portable-Event-Driven-Runtime-for-Building-Distributed-Applications-by-Seifeddine-Rajhi-Nov-2023-Medium" class="headerlink" title="Dapr: A Portable, Event-Driven Runtime for Building Distributed Applications | by Seifeddine Rajhi | Nov, 2023 | Medium"></a>Dapr: A Portable, Event-Driven Runtime for Building Distributed Applications | by Seifeddine Rajhi | Nov, 2023 | Medium</h2><p>URL: <a href="https://medium.com/@seifeddinerajhi/dapr-a-portable-event-driven-runtime-for-building-distributed-applications-c2ea8254406c">https://medium.com/@seifeddinerajhi/dapr-a-portable-event-driven-runtime-for-building-distributed-applications-c2ea8254406c</a></p><blockquote><p>本文介绍了 Dapr 是什么，以及给了一个入门示例</p></blockquote><p><img src="https://s2.loli.net/2023/11/23/v1LOZia9uxS8PUR.png" alt="image.png"></p><ul><li>Dapr 是 <strong>Distributed Application Runtime</strong> 的简称，翻译过来就是分布式应用运行时。</li><li>你可以使用任何语言，任何框架、运行在任何地方构建你的分布式应用程序</li><li>Dapr 抽象了我们应用开发中所需要的大部分 API，所有与这些 API 交互的 SDK 都是由 Dapr 提供，所以我们不需要关系他的底层是什么。</li></ul><h2 id="3-years-managing-Kubernetes-clusters-my-10-lessons-by-Herve-Khg-Nov-2023-Medium"><a href="#3-years-managing-Kubernetes-clusters-my-10-lessons-by-Herve-Khg-Nov-2023-Medium" class="headerlink" title="3 years managing Kubernetes clusters, my 10 lessons. | by Herve Khg | Nov, 2023 | Medium"></a>3 years managing Kubernetes clusters, my 10 lessons. | by Herve Khg | Nov, 2023 | Medium</h2><p>URL: <a href="https://hervekhg.medium.com/3-years-managing-kubernetes-clusters-my-10-lessons-b565a5509f0e">https://hervekhg.medium.com/3-years-managing-kubernetes-clusters-my-10-lessons-b565a5509f0e</a></p><blockquote><p>作者描述他三年的 kubernetes 集群管理的十条经验</p></blockquote><ul><li>在云环境使用 kubernetes，这会比自己维护要简单很多，即便是自己维护也不会让自己的业务能力得到成长，或者收益性价比不高</li><li>使用代码来部署应用，避免直接在控制台用命令操作，这样难以记录操作。</li><li>避免过度使用 helm，同时要对充分理解其中的配置项；这个也很重要。</li><li>不要直接迁移应用到 kubernetes，往往需要做相关的适配。</li><li>非必要不要使用 Mesh</li><li>避免过多的使用管理工具，<code>kubernetes</code> 的管理工具有很多，但大部分操作就靠 <code>kubectl</code> 就够用了。</li><li>一定要记得定义资源的限制（内存和 CPU），避免程序 bug 导致 kubernetes 集群出现问题</li><li>尽量不要在 Pod 中存储数据，推荐使用 NAS、云存储</li><li>配置 HPA，可以根据负载自动扩容 Pod</li><li>不要畏惧改变，每年需要对 <code>kubernetes</code> 进行升级，升级前需要充分阅读 <code>ReleaseNote</code>.</li></ul><h2 id="Ten-Optimization-Tricks-to-Make-Your-Java-Application-Run-Faster-by-lance-Javarevisited-Medium"><a href="#Ten-Optimization-Tricks-to-Make-Your-Java-Application-Run-Faster-by-lance-Javarevisited-Medium" class="headerlink" title="Ten Optimization Tricks to Make Your Java Application Run Faster | by lance | Javarevisited | Medium"></a>Ten Optimization Tricks to Make Your Java Application Run Faster | by lance | Javarevisited | Medium</h2><p>URL: <a href="https://medium.com/javarevisited/ten-optimization-tricks-to-make-your-java-application-run-faster-9742f568ed6f">https://medium.com/javarevisited/ten-optimization-tricks-to-make-your-java-application-run-faster-9742f568ed6f</a></p><blockquote><p>十个优化让 Java 应用更快</p></blockquote><ol><li>循环拼接字符串使用 StringBuilder</li><li>线程池代替自定义线程</li><li>容器类预先分配大小</li><li>用枚举代替常量</li><li>用 NIO 代替传统 IO</li><li>用位移操作</li><li>多使用单例模式</li><li>减少锁的范围</li><li>尽量少使用全局变量</li><li>多使用基础数据类型</li></ol><p>文章链接：</p><ul><li><a href="https://supertokens.com/blog/what-is-jwt">https://supertokens.com/blog/what-is-jwt</a></li><li><a href="https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/">https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/</a></li><li><a href="https://medium.com/@seifeddinerajhi/dapr-a-portable-event-driven-runtime-for-building-distributed-applications-c2ea8254406c">https://medium.com/@seifeddinerajhi/dapr-a-portable-event-driven-runtime-for-building-distributed-applications-c2ea8254406c</a></li><li><a href="https://hervekhg.medium.com/3-years-managing-kubernetes-clusters-my-10-lessons-b565a5509f0e">https://hervekhg.medium.com/3-years-managing-kubernetes-clusters-my-10-lessons-b565a5509f0e</a></li><li><a href="https://medium.com/javarevisited/ten-optimization-tricks-to-make-your-java-application-run-faster-9742f568ed6f">https://medium.com/javarevisited/ten-optimization-tricks-to-make-your-java-application-run-faster-9742f568ed6f</a></li></ul><p>#Newletters </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/11/24/zGKworjfL7JkyQt.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术阅读周刊，每周更新。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;历史更新&quot;&gt;&lt;a href=&quot;#历史更新&quot; class=&quot;headerlink&quot; title=&quot;历史更新&quot;&gt;&lt;/a&gt;历史更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/&quot;&gt;20231013：第一期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/10/22/ob/newsletter/Newsletter02-20231022/&quot;&gt;20231022：第二期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/10/27/ob/newsletter/Newsletter03-20231027/&quot;&gt;20231027：第三期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/11/03/ob/newsletter/Newsletter04-20231103/&quot;&gt;20231103：第四期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/11/10/ob/newsletter/Newsletter05-20231110/&quot;&gt;20231107：第五期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/11/17/ob/newsletter/Newsletter06-20231117/&quot;&gt;20231117：第六期&lt;/a&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Newsletter" scheme="http://crossoverjie.top/categories/OB/Newsletter/"/>
    
    
  </entry>
  
  <entry>
    <title>升级到 Pulsar3.0 后深入了解 JWT 鉴权</title>
    <link href="http://crossoverjie.top/2023/11/19/ob/Pulsar-JWT/"/>
    <id>http://crossoverjie.top/2023/11/19/ob/Pulsar-JWT/</id>
    <published>2023-11-19T08:19:28.000Z</published>
    <updated>2023-11-19T15:41:46.100Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/11/19/gAadEDNG4piBbSl.png" alt="image.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在测试将 <code>Pulsar</code> 2.11.2 升级到 <code>3.0.1</code>的过程中碰到一个鉴权问题，正好借着这个问题充分了解下 <code>Pulsar</code> 的鉴权机制是如何运转的。</p><span id="more"></span><p>Pulsar 支持 <code>Namespace/Topic</code> 级别的鉴权，在生产环境中往往会使用 <code>topic</code> 级别的鉴权，从而防止消息泄露或者其他因为权限管控不严格而导致的问题。</p><p><img src="https://s2.loli.net/2023/11/19/1HGIlndNFCWwAzK.png" alt="image.png"></p><p>我们会在创建 <code>topic</code> 的时候为 <code>topic</code> 绑定一个应用，这样就只能由这个应用发送消息，其他的应用尝试发送消息的时候会遇到 401 鉴权的异常。</p><blockquote><p>同理，对于订阅者也可以关联指定的应用，从而使得只有规定的应用可以消费消息。</p></blockquote><h1 id="鉴权流程"><a href="#鉴权流程" class="headerlink" title="鉴权流程"></a>鉴权流程</h1><p>以上的两个功能本质上都是通过 <code>Pulsar</code> 的 <code>admin-API</code> 实现的。</p><p><img src="https://s2.loli.net/2023/11/19/zlLxTZi7rV8XvJg.png" alt="image.png"><br>这里关键的就是 <code>role</code>，在我们的场景下通常是一个应用的 <code>AppId</code>，只要是一个和项目唯一绑定的 <code>ID</code> 即可。</p><p>这只是授权的一步，整个鉴权流程图如下：<br><img src="https://s2.loli.net/2023/11/19/mGcIvBYo6SNy8gH.png"></p><h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><h3 id="生成公私钥"><a href="#生成公私钥" class="headerlink" title="生成公私钥"></a>生成公私钥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/pulsar tokens create-key-pair --output-private-key my-private.key --output-public-key my-public.key</span><br></pre></td></tr></table></figure><p>将公钥分发到 <code>broker</code> 的节点上，鉴权的时候 <code>broker</code> 会使用公钥进行验证。</p><p>而私钥通常是管理员单独保存起来用于在后续的步骤为客户端生成 <code>token</code></p><h3 id="使用私钥生成-token"><a href="#使用私钥生成-token" class="headerlink" title="使用私钥生成 token"></a>使用私钥生成 token</h3><p>之后我们便可以使用这个私钥生成 <code>token</code> 了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin/pulsar tokens create --private-key file:///path/to/my-private.key \</span><br><span class="line">            --subject 123456</span><br><span class="line"></span><br><span class="line">eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiJ9</span><br></pre></td></tr></table></figure><blockquote><p>其中的 <code>subject</code> 和本文长提到的 <code>role</code> 相等</p></blockquote><h3 id="使用-subject-授权"><a href="#使用-subject-授权" class="headerlink" title="使用 subject 授权"></a>使用 subject 授权</h3><p>只是单纯生成了 <code>token</code> 其实并没有什么作用，还得将 <code>subject</code>(role) 与 <code>topic</code> 进行授权绑定。</p><p><img src="https://s2.loli.net/2023/11/19/zlLxTZi7rV8XvJg.png" alt="image.png"><br>也就是上图的这个步骤。</p><blockquote><p>这里创建的 <code>admin</code> 客户端也得使用一个 <code>superRole</code> 角色的 <code>token</code> 才有权限进行授权。<br> <code>superRole</code> 使用在  <code>broker.conf</code> 中进行配置。</p></blockquote><h3 id="客户端使用-token-接入-broker"><a href="#客户端使用-token-接入-broker" class="headerlink" title="客户端使用 token 接入 broker"></a>客户端使用 token 接入 broker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PulsarClient</span> <span class="variable">client</span> <span class="operator">=</span> PulsarClient.builder()</span><br><span class="line">    .serviceUrl(<span class="string">&quot;pulsar://broker.example.com:6650/&quot;</span>)</span><br><span class="line">    .authentication(AuthenticationFactory.token(<span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJKb2UifQ.ipevRNuRP6HflG8cFKnmUPtypruRC4fb1DWtoLL62SY&quot;</span>)）</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>使用刚才私钥生成的 token 接入 broker 才能生产或者消费数据。</p><h2 id="originalPrincipal-cannot-be-a-proxy-role"><a href="#originalPrincipal-cannot-be-a-proxy-role" class="headerlink" title="originalPrincipal cannot be a proxy role"></a>originalPrincipal cannot be a proxy role</h2><p>这些流程正常都没啥问题，但直到我升级了 <code>Pulsar3.0</code> 后客户端直接就连不上了。</p><p>在 <code>broker</code> 中看到了 <code>WARN</code> 的警告日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot specify originalPrincipal when connecting without valid proxy role</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/11/19/8atrUwAj2Tg6GLu.jpg" alt="image.png"><br>之后在 3.0 的升级日志中看到相关的 <a href="https://github.com/apache/pulsar/pull/19455">Issue</a>。</p><p>从这个 PR 相关的代码和变更的文档可以得知：<br><img src="https://s2.loli.net/2023/11/19/3ktMOS6IjDu9nmE.png" alt="image.png"><br><img src="https://s2.loli.net/2023/11/19/fpJ8CuwnlXdhxWm.png" alt="image.png"></p><p>升级到 3.0 之后风险校验等级提高了，<code>proxyRole</code> 这个字段需要在 <code>broker</code> 中进行指定（之前的版本不需要强制填写）。</p><p>因为我们使用了 Proxy 组件，所有的请求都需要从 proxy 中转一次，这个 proxyRole 是为了告诉 broker：只有使用了 <code>proxyRole</code> 作为 <code>token</code> 的 <code>Proxy</code> 才能访问 broker，这样保证了 <code>broker</code> 的安全。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">superUserRoles: broker-admin,admin,proxy-admin </span><br><span class="line">proxyRoles: proxy-admin</span><br></pre></td></tr></table></figure><p>以上是我的配置，我的 Proxy 配置的也是 <code>proxy-admin</code> 这个 token，所以理论上是没有问题的，但依然鉴权失败了，查看 broker 的日志后拿到以下日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Illegal combination of role [proxy-admin] and originalPrincipal [proxy-admin]: originalPrincipal cannot be a proxy role.</span><br></pre></td></tr></table></figure><p>排查了许久依然没有太多头绪，所以我提了相关的 issue:<br><a href="https://github.com/apache/pulsar/issues/21583">https://github.com/apache/pulsar/issues/21583</a><br>之后我咨询了 <code>Pulsar</code> 的 PMC <a href="https://github.com/Technoboy-">@Technoboy</a>  在他的提示下发现我在测试的时候使用的是 <code>proxy-admin</code>，正好和 <code>proxyRoles</code> 相等。<br><img src="https://s2.loli.net/2023/11/19/AuoY8Sq4FPUVHjN.png" alt="image.png"><br>阅读源码和这个 <code>PR</code> 的 <code>comment</code> 之后得知：<br><img src="https://s2.loli.net/2023/11/19/pTbQkj2rOKnHNwS.png" alt="image.png"><br>也就是说客户端不能使用和 <code>proxyRole</code> 相同的角色进行连接，这个角色应当也只能给 <code>Proxy</code> 使用，这样的安全性才会高。</p><p>所以这个 Comment 还在讨论这是一个 <code>breaking change?</code> 还是一个增强补丁。<br>因为合并这个 PR 后对没有使用 <code>proxyRole</code> 的客户端将无法连接，同时也可能出现我这种 <code>proxyRole</code> 就是客户端使用的角色，这种情况也会鉴权失败。</p><p>所以我换了一个 superRole 角色就可以了，比如换成了 <code>admin</code>。</p><blockquote><p>但其实即便是放到我们的生产系统，只要配置了 <code>proxyRole</code> 也不会有问题，因为我们应用所使用的 role 都是不这里的 <code>superUserRole</code>，全部都是使用 <code>AppId</code> 生成的。</p></blockquote><h1 id="token-不一致"><a href="#token-不一致" class="headerlink" title="token 不一致"></a>token 不一致</h1><p>但也有一个疑惑，我在换为存放在 <code>configmap</code> 中的 admin token 之前(测试环境使用的是 helm 安装集群，所以这些 token 都是存放在 configmap 中的)，</p><p>为了验证是否只要非 <code>proxyRole</code> 的 <code>superRole</code> 都可以使用，我就自己使用了私钥重新生成了一个 <code>admin</code> 的 <code>token</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/pulsar tokens create --private-key file:///pulsar/private/private.key --subject admin</span><br></pre></td></tr></table></figure><p>这样生成的 <code>token</code> 也是可以使用的，但是我将 token 复制出来之后却发现 helm 生成的 <code>token</code> 与我用 <code>pulsar</code> 命令行生成的 <code>token</code> 并不相同。</p><p>为了搞清楚为什么 token 不同但鉴权依然可以通过的原因，之后我将 token decode之后知道了原因：<br><img src="https://s2.loli.net/2023/11/19/rKMRqGsmTDvLnZ2.png" alt="image.png"><br><img src="https://s2.loli.net/2023/11/19/xZn4v5EIFwXMRKk.png" alt="image.png"><br>原来是 Header 不同从而导致最终的 token 不同，helm 生成的 <code>token</code> 中多了一个 typ 字段。</p><hr><p>之后我检查了 helm 安装的流程，发现原来 helm 的脚本中使用的并不是 Java 的命令行工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;PULSARCTL_BIN&#125; token create -a RS256 --private-key-file <span class="variable">$&#123;privatekeytmpfile&#125;</span> --subject <span class="variable">$&#123;role&#125;</span> 2&amp;&gt; <span class="variable">$&#123;tokentmpfile&#125;</span></span></span><br></pre></td></tr></table></figure><p>这个 <code>PULSARCTL_BIN</code> 是一个由 Go 写的命令行工具，我查看了其中的源码，才知道 Go 的 JWT 工具会自带一个 header。<br><a href="https://github.com/streamnative/pulsarctl">https://github.com/streamnative/pulsarctl</a></p><p><img src="https://s2.loli.net/2023/11/19/kZ2zaOfo7PbvT4j.png" alt="image.png"><br>而 <code>Java</code> 是没有这个逻辑的，但也只是加了 <code>header</code>，<code>payload</code> 的值都是相同的。<br>这样也就解释了为什么 <code>token</code> 不同但确依然能使用的原因。</p><p>#Blog #Pulsar </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/11/19/gAadEDNG4piBbSl.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近在测试将 &lt;code&gt;Pulsar&lt;/code&gt; 2.11.2 升级到 &lt;code&gt;3.0.1&lt;/code&gt;的过程中碰到一个鉴权问题，正好借着这个问题充分了解下 &lt;code&gt;Pulsar&lt;/code&gt; 的鉴权机制是如何运转的。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
  </entry>
  
  <entry>
    <title>技术阅读周刊第第6️⃣期</title>
    <link href="http://crossoverjie.top/2023/11/17/ob/newsletter/Newsletter06-20231117/"/>
    <id>http://crossoverjie.top/2023/11/17/ob/newsletter/Newsletter06-20231117/</id>
    <published>2023-11-17T09:28:25.000Z</published>
    <updated>2023-11-17T06:00:24.349Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/11/17/yZANlmctghPTJDj.png" alt="image.png"></p><p><strong>技术阅读周刊，每周更新。</strong></p><h2 id="历史更新"><a href="#历史更新" class="headerlink" title="历史更新"></a>历史更新</h2><ul><li><a href="https://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/">20231013：第一期</a></li><li><a href="https://crossoverjie.top/2023/10/22/ob/newsletter/Newsletter02-20231022/">20231022：第二期</a></li><li><a href="https://crossoverjie.top/2023/10/27/ob/newsletter/Newsletter03-20231027/">20231027：第三期</a></li><li><a href="https://crossoverjie.top/2023/11/03/ob/newsletter/Newsletter04-20231103/">20231103：第四期</a></li><li><a href="https://crossoverjie.top/2023/11/10/ob/newsletter/Newsletter05-20231110/ni">20231007：第五期</a><span id="more"></span></li></ul><h2 id="5-Skills-the-Best-Engineers-I-Know-Have-in-Common"><a href="#5-Skills-the-Best-Engineers-I-Know-Have-in-Common" class="headerlink" title="5 Skills the Best Engineers I Know Have in Common"></a>5 Skills the Best Engineers I Know Have in Common</h2><p>URL: <a href="https://www.developing.dev/p/5-skills-all-10x-engineers-have?utm_source=post-email-title&amp;publication_id=1340878&amp;post_id=138715343&amp;utm_campaign=email-post-title&amp;isFreemail=true&amp;r=4buvd&amp;utm_medium=email">https://www.developing.dev/p/5-skills-all-10x-engineers-have?utm_source=post-email-title&amp;publication_id=1340878&amp;post_id=138715343&amp;utm_campaign=email-post-title&amp;isFreemail=true&amp;r=4buvd&amp;utm_medium=email</a></p><blockquote><p>作者讲述了他身边最好的工程师都具备的五个通用技能</p></blockquote><p><img src="https://s2.loli.net/2023/11/13/5NCshr4JWIemotP.png" alt="image.png"></p><ul><li>技术的深度与广度<ul><li>对于最好的工程师来说，深度和广度他们都会掌握</li><li>要保持好奇心，好奇心是学习任何新东西的原始动力</li><li>和身边厉害的工程师一起工作，会快速从他们身上学到东西</li></ul></li><li>不用权威去影响他人<ul><li>我理解的是不是依靠资历、经验来向他人输出观点；而是就事论事，利用知识、技能来输出。</li><li>锻炼写作和口语</li><li>学会销售</li></ul></li><li>提升他人<ul><li>分享知识，写 WIKI、做分享</li><li>团队协作：codereview、团队讨论等</li><li>构建工具，解决大家遇到的一些共性问题。</li></ul></li><li>要有主人公意识<ul><li>这些工程师都有主人公意识。</li><li>像老板一样思考问题</li></ul></li></ul><h2 id="Explaining-9-Types-of-API-Testing"><a href="#Explaining-9-Types-of-API-Testing" class="headerlink" title="Explaining 9 Types of API Testing"></a>Explaining 9 Types of API Testing</h2><p>URL: <a href="https://blog.bytebytego.com/p/ep83-explaining-9-types-of-api-testing?ref=dailydev">https://blog.bytebytego.com/p/ep83-explaining-9-types-of-api-testing?ref=dailydev</a><br><img src="https://s2.loli.net/2023/11/14/LrPN8GQ4FjuTISa.gif"></p><blockquote><p>介绍了九种常见的 API 测试方法</p></blockquote><ul><li>冒烟测试：简单的验证 API 是否可以正常工作</li><li>功能测试：根据需求进行测试，有预期结果进行比较</li><li>集成测试：结合多个 API 完成集成测试，更完善的功能测试</li><li>回归测试：确保新增功能没有影响到原有的 API</li><li>负载测试：模拟不同的负载进行测试，测出系统可支持的最大容量</li><li>压力测试：模拟高负载场景，在这种压力情况下观察 API 行为</li><li>安全测试：模拟外部安全测试</li><li>UI测试：配合 UI 交互进行功能测试</li><li>模糊测试：对 API 进行无效输入，尝试让 API 崩溃</li></ul><blockquote><p>实际情况可能并不会分的这么细，往往会将一些步骤合并在一起。</p></blockquote><h2 id="Prometheus-14-点实践经验分享"><a href="#Prometheus-14-点实践经验分享" class="headerlink" title="Prometheus 14 点实践经验分享"></a>Prometheus 14 点实践经验分享</h2><p>URL: <a href="https://mp.weixin.qq.com/s/z2IVP26swYaTeiPTeOMoQw">https://mp.weixin.qq.com/s/z2IVP26swYaTeiPTeOMoQw</a><br><img src="https://s2.loli.net/2023/11/16/8TKa5VBeX4jfdMr.png" alt="image.png"><br>这是一篇 17 年的 <code>Prometheus</code> 使用分享，但放到现在一点也不过时。</p><ul><li>使用 USE 理论来判断资源是否健康<ul><li>Utilization 利用率</li><li>Saturation 饱和率</li><li>Errors 错误</li></ul></li><li>使用 RED 理论<ul><li>Request rate 请求速率</li><li>Error rate 错误速率</li><li>Duration 持续时间</li></ul></li><li>指标命名需要有规范<ul><li>通常使用框架生成的都没啥问题</li><li>可以参考 Prometheus 的官方实践 <a href="https://prometheus.io/docs/practices/naming/">https://prometheus.io/docs/practices/naming/</a></li></ul></li><li>注意指标基数<ul><li>避免基数爆炸的，比如不能使用 user_id, trace_id 等作为指标的 label</li></ul></li><li>统计失败+总量而不要统计失败+成功量</li><li>告警症状而非原因</li><li>告警规则需要配置持续时间，避免无效告警</li><li>查询时候通常先求 rate() 再求 sum()</li></ul><h2 id="程序员可能必读书单推荐（一）-面向信仰编程"><a href="#程序员可能必读书单推荐（一）-面向信仰编程" class="headerlink" title="程序员可能必读书单推荐（一） - 面向信仰编程"></a>程序员可能必读书单推荐（一） - 面向信仰编程</h2><p>URL: <a href="https://draveness.me//books-1">https://draveness.me//books-1</a></p><blockquote><p>draveness 大佬推荐的都是一些偏低层的，静得下心的可以看看，我觉得我是看不下来的。</p></blockquote><ul><li>SICP 《计算机程序的构造和解释》</li><li>CTMCP 《计算机程序设计的概念、技术和模型》</li><li>DDIA 《设计数据密集型应用》</li></ul><h2 id="TOP-20-Go最佳实践"><a href="#TOP-20-Go最佳实践" class="headerlink" title="TOP 20 Go最佳实践"></a>TOP 20 Go最佳实践</h2><p>URL: <a href="https://colobu.com/2023/11/17/golang-quick-reference-top-20-best-coding-practices/">https://colobu.com/2023/11/17/golang-quick-reference-top-20-best-coding-practices/</a></p><blockquote><p>都是一些基本套路，各种语言的使用者都推荐掌握</p></blockquote><ul><li>适当使用缩进，推荐统一使用 <code>gofmt</code></li><li>变量和函数名具有意义</li><li>限制行长度，IDE 通常都会有提示</li><li>使用常量代替魔法值</li><li>显示处理错误</li><li>避免使用全局变量</li><li>使用结构体处理复杂逻辑，更易维护</li><li>使用 <code>goroutines</code> 处理并发</li><li>使用 Recover 处理 panic</li><li>避免使用 Init 函数，更容易维护</li><li>使用 Defer 清理资源</li><li>使用复合字面值而非构造函数</li><li>使用显示返回值而非具名返回值，也是代码更易读</li><li>避免变量屏蔽，易读性</li><li>使用接口抽象</li></ul><p>文章链接：</p><ul><li><a href="https://www.developing.dev/p/5-skills-all-10x-engineers-have?utm_source=post-email-title&amp;publication_id=1340878&amp;post_id=138715343&amp;utm_campaign=email-post-title&amp;isFreemail=true&amp;r=4buvd&amp;utm_medium=email">https://www.developing.dev/p/5-skills-all-10x-engineers-have?utm_source=post-email-title&amp;publication_id=1340878&amp;post_id=138715343&amp;utm_campaign=email-post-title&amp;isFreemail=true&amp;r=4buvd&amp;utm_medium=email</a></li><li><a href="https://blog.bytebytego.com/p/ep83-explaining-9-types-of-api-testing?ref=dailydev">https://blog.bytebytego.com/p/ep83-explaining-9-types-of-api-testing?ref=dailydev</a></li><li><a href="https://mp.weixin.qq.com/s/z2IVP26swYaTeiPTeOMoQw">https://mp.weixin.qq.com/s/z2IVP26swYaTeiPTeOMoQw</a></li><li><a href="https://draveness.me//books-1">https://draveness.me//books-1</a></li><li><a href="https://colobu.com/2023/11/17/golang-quick-reference-top-20-best-coding-practices/">https://colobu.com/2023/11/17/golang-quick-reference-top-20-best-coding-practices/</a></li></ul><p>#Newletters </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/11/17/yZANlmctghPTJDj.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术阅读周刊，每周更新。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;历史更新&quot;&gt;&lt;a href=&quot;#历史更新&quot; class=&quot;headerlink&quot; title=&quot;历史更新&quot;&gt;&lt;/a&gt;历史更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/&quot;&gt;20231013：第一期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/10/22/ob/newsletter/Newsletter02-20231022/&quot;&gt;20231022：第二期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/10/27/ob/newsletter/Newsletter03-20231027/&quot;&gt;20231027：第三期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/11/03/ob/newsletter/Newsletter04-20231103/&quot;&gt;20231103：第四期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/11/10/ob/newsletter/Newsletter05-20231110/ni&quot;&gt;20231007：第五期&lt;/a&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Newsletter" scheme="http://crossoverjie.top/categories/OB/Newsletter/"/>
    
    
  </entry>
  
  <entry>
    <title>k8s实战-Istio 网关</title>
    <link href="http://crossoverjie.top/2023/11/13/ob/k8s-istio03/"/>
    <id>http://crossoverjie.top/2023/11/13/ob/k8s-istio03/</id>
    <published>2023-11-13T14:07:18.000Z</published>
    <updated>2023-11-14T08:03:13.523Z</updated>
    
    <content type="html"><![CDATA[<p>在上一期 <a href="https://crossoverjie.top/2023/11/07/ob/k8s-Istio02/">k8s-服务网格实战-配置 Mesh</a> 中讲解了如何配置集群内的 Mesh 请求，Istio 同样也可以处理集群外部流量，也就是我们常见的网关。<br><img src="https://s2.loli.net/2023/11/14/TSCmnecrjHKfLzi.png" alt="image.png"></p><span id="more"></span><p>其实和之前讲到的<a href="https://crossoverjie.top/2023/09/15/ob/k8s-Ingress/">k8s入门到实战-使用Ingress</a> <code>Ingress</code> 作用类似，都是将内部服务暴露出去的方法。</p><p>只是使用 <code>Istio-gateway</code> 会更加灵活。<br><img src="https://s2.loli.net/2023/11/14/hVFUTLB2CHjeRuM.png" alt="image.png"></p><p>这里有一张功能对比图，可以明显的看出 <code>Istio-gateway</code> 支持的功能会更多，如果是一个中大型企业并且已经用上 Istio 后还是更推荐是有 <code>Istio-gateway</code>，使用同一个控制面就可以管理内外网流量。</p><h2 id="创建-Gateway"><a href="#创建-Gateway" class="headerlink" title="创建 Gateway"></a>创建 Gateway</h2><p>开始之前首先是创建一个 <code>Istio-Gateway</code> 的资源：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-ingress-gateway</span>  </span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">servers:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span>  </span><br><span class="line">        <span class="attr">number:</span> <span class="number">80</span>  </span><br><span class="line">        <span class="attr">name:</span> <span class="string">http</span>  </span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">HTTP</span>  </span><br><span class="line">      <span class="attr">hosts:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;www.service1.io&#x27;</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">istio-ingressgateway</span> <span class="comment">#与现有的 gateway 关联  </span></span><br><span class="line">    <span class="attr">istio:</span> <span class="string">ingressgateway</span></span><br></pre></td></tr></table></figure><p>其中的 <code>selector</code> 选择器中匹配的 label 与我们安装 <code>Istio</code> 时候自带的 <code>gateway</code> 关联即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 gateway 的 label</span></span><br><span class="line">k get pod -n istio-system</span><br><span class="line">NAME                                    READY   STATUS</span><br><span class="line">istio-ingressgateway-649f75b6b9-klljw   1/1     Running</span><br><span class="line"></span><br><span class="line">k describe pod istio-ingressgateway-649f75b6b9-klljw -n istio-system |grep Labels</span><br><span class="line">Labels:           app=istio-ingressgateway</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/10/26/3JXneYvyqI4WTgt.png" alt="image.png"></p><blockquote><p>这个 <code>Gateway</code> 在我们第一次安装 <code>Istio</code> 的时候就会安装这个组件。</p></blockquote><hr><p>这个配置的含义是网关会代理通过 <code>www.service1.io</code> 这个域名访问的所有请求。</p><p>之后需要使用刚才的 gateway 与我们的服务的 service 进行绑定，这时就需要使用到 <code>VirtualService</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-istio-http-vs</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">gateways:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">istio-ingress-gateway</span> <span class="comment"># 绑定刚才创建的 gateway 名称 </span></span><br><span class="line">  <span class="attr">hosts:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">www.service1.io</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default</span>  </span><br><span class="line">  <span class="attr">route:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span>  </span><br><span class="line">        <span class="attr">host:</span> <span class="string">k8s-combat-service-istio-mesh</span>  <span class="comment">#service 名称</span></span><br><span class="line">        <span class="attr">port:</span>  </span><br><span class="line">          <span class="attr">number:</span> <span class="number">8081</span>  </span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure><p>这个和我们之前讲到的 Mesh 内部流量时所使用到的 <code>VirtualService</code> 配置是一样的。</p><p>这里的含义也是通过 <code>www.service1.io</code> 以及 <code>istio-ingress-gateway</code> 网关的流量会进入这个虚拟服务，但所有的请求都会进入 <code>subset: v1</code> 这个分组。</p><p>这个的分组信息在上一节可以查询到：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-service-ds</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">host:</span> <span class="string">k8s-combat-service-istio-mesh</span>  </span><br><span class="line">  <span class="attr">subsets:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span>  </span><br><span class="line">      <span class="attr">labels:</span>  </span><br><span class="line">        <span class="attr">app:</span> <span class="string">k8s-combat-service-v1</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span>  </span><br><span class="line">      <span class="attr">labels:</span>  </span><br><span class="line">        <span class="attr">app:</span> <span class="string">k8s-combat-service-v2</span></span><br></pre></td></tr></table></figure><p>之后我们访问这个域名即可拿到响应，同时我们打开 <code>k8s-combat-service-istio-mesh</code> service 的 Pod 查看日志，会发现所有的请求都进入了 v1, 如果不需要这个限制条件，将 <code>subset: v1</code> 删除即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl  http://www.service1.io/ping</span><br></pre></td></tr></table></figure><blockquote><p>本地需要配置下 host: <code>127.0.0.1 www.service1.io</code></p></blockquote><p><img src="https://s2.loli.net/2023/11/13/ksR9FbdWMEhlLBQ.png" alt="image.png"></p><p>还有一点，我们需要拿到 <code>gateway</code> 的外部IP，才能将 IP 和刚才的域名<code>www.service1.io</code> 进行绑定（host，或者是域名管理台）。</p><p>如果使用的是 <code>docker-desktop</code> 自带的 <code>kubernetes</code> 集群时候直接使用 <code>127.0.0.1</code> 即可，默认就会绑定上。</p><p>如果使用的是 <code>minikube</code> 安装的，那需要使用 <code>minikube tunnel</code> 手动为 service 为<code>LoadBalancer</code> 类型的绑定一个本地 IP，具体可以参考文档：<br><a href="https://minikube.sigs.k8s.io/docs/tasks/loadbalancer">https://minikube.sigs.k8s.io/docs/tasks/loadbalancer</a></p><blockquote><p>如果是生产环境使用，云服务厂商会自动绑定一个外网 IP。</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://s2.loli.net/2023/11/14/4yBEDZOcsWKxLpg.png" alt="image.png"></p><p>这个的访问请求的流程和之前讲到的 <code>kubernetes Ingress</code> 流程是类似的，只是 gateway 是通过 <code>VirtualService</code> 来路由的 service，同时在这个 <code>VirtualService</code> 中可以自定义许多的路由规则。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>服务网格 <code>Istio</code> 基本上讲完了，后续还有关于 <code>Telemetry</code> 相关的 <code>trace</code>、<code>log</code>、<code>metrics</code> 会在运维章节更新，也会和 Istio 有所关联。<br>感兴趣的朋友可以持续关注。</p><p>本文的所有源码在这里可以访问：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p><p>#Blog #Istio </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一期 &lt;a href=&quot;https://crossoverjie.top/2023/11/07/ob/k8s-Istio02/&quot;&gt;k8s-服务网格实战-配置 Mesh&lt;/a&gt; 中讲解了如何配置集群内的 Mesh 请求，Istio 同样也可以处理集群外部流量，也就是我们常见的网关。&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/11/14/TSCmnecrjHKfLzi.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/k8s/"/>
    
    
    <category term="Istio" scheme="http://crossoverjie.top/tags/Istio/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读周刊第第5️⃣期</title>
    <link href="http://crossoverjie.top/2023/11/10/ob/newsletter/Newsletter05-20231110/"/>
    <id>http://crossoverjie.top/2023/11/10/ob/newsletter/Newsletter05-20231110/</id>
    <published>2023-11-10T09:28:25.000Z</published>
    <updated>2023-11-10T02:28:00.685Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/11/10/aywEgYVeC9vL8pZ.png" alt="image.png"></p><p><strong>技术阅读周刊，每周更新。</strong></p><h2 id="历史更新"><a href="#历史更新" class="headerlink" title="历史更新"></a>历史更新</h2><ul><li><a href="https://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/">20231013：第一期</a></li><li><a href="https://crossoverjie.top/2023/10/22/ob/newsletter/Newsletter02-20231022/">20231022：第二期</a></li><li><a href="https://crossoverjie.top/2023/10/27/ob/newsletter/Newsletter03-20231027/">20231027：第三期</a></li><li><a href="https://crossoverjie.top/2023/11/03/ob/newsletter/Newsletter04-20231103/">20231027：第四期</a><span id="more"></span></li></ul><h2 id="How-to-Use-OpenTelemetry-in-Go-OpenTelemetry-is-a-powerful…-by-Akanksha-Rana-KloudMate"><a href="#How-to-Use-OpenTelemetry-in-Go-OpenTelemetry-is-a-powerful…-by-Akanksha-Rana-KloudMate" class="headerlink" title="How to Use OpenTelemetry in Go. OpenTelemetry is a powerful… | by Akanksha Rana | KloudMate"></a>How to Use OpenTelemetry in Go. OpenTelemetry is a powerful… | by Akanksha Rana | KloudMate</h2><p>URL: <a href="https://blog.kloudmate.com/how-to-use-opentelemetry-in-go-e416ca01c499">https://blog.kloudmate.com/how-to-use-opentelemetry-in-go-e416ca01c499</a></p><blockquote><p>作者一步步带你使用 golang 配置了 <code>OpenTelemetry</code>，不过由于 Go 不支持 agent，还是没有 Java 方便，很多地方都需要硬编码。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tp := trace.NewTracerProvider(  </span><br><span class="line">    trace.WithBatcher(exp),  </span><br><span class="line">    trace.WithResource(newResource()),  </span><br><span class="line">)  </span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> err := tp.Shutdown(context.Background()); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        l.Fatal(err)  </span><br><span class="line">    &#125;&#125;()  </span><br><span class="line">otel.SetTracerProvider(tp)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/11/07/wFtivm6abfVrgSD.png" alt="image.png"></p><p>最终会输出到文件中，适配起来倒也蛮简单的。</p><h2 id="What-happens-when-you-create-a-pod-in-Kubernetes-by-Daniele-Polencic-ITNEXT"><a href="#What-happens-when-you-create-a-pod-in-Kubernetes-by-Daniele-Polencic-ITNEXT" class="headerlink" title="What happens when you create a pod in Kubernetes | by Daniele Polencic | ITNEXT"></a>What happens when you create a pod in Kubernetes | by Daniele Polencic | ITNEXT</h2><p>URL: <a href="https://itnext.io/what-happens-when-you-create-a-pod-in-kubernetes-6b789b6db8a8">https://itnext.io/what-happens-when-you-create-a-pod-in-kubernetes-6b789b6db8a8</a></p><blockquote><p>本文讲解了一个 Pod 在 <code>kubernetes</code> 中创建的主要流程。</p></blockquote><p><img src="https://s2.loli.net/2023/11/08/2V6ei8XnJ9t1Zj3.png" alt="image.png"><br><img src="https://s2.loli.net/2023/11/08/gKhrCXLtkzicI4F.png" alt="image.png"><br><img src="https://s2.loli.net/2023/11/08/mfGkSAFtdvOCyLx.png" alt="image.png"><br><img src="https://s2.loli.net/2023/11/08/XG7co1AF9blViaM.png" alt="image.png"><br><img src="https://s2.loli.net/2023/11/08/EXVFnQYz9Arkyx2.png" alt="image.png"></p><ul><li>客户端校验 <code>yaml</code> 格式是否正确</li><li>成功后会将 <code>yaml</code> 写入 <code>etcd</code>.</li><li>之后会将 Pod 信息写入调度队列</li><li>调度队列获取该任务，然后选择一个合适的 Node 节点部署 Pod</li><li>等待 Pod 启动成功通过 Prob 探针校验</li><li>将 Pod 的 <code>IP:Port</code> 信息作为 <code>endpoint</code> 存储在 <code>etcd</code></li><li>如果有创建 <code>service</code>，会将这个 <code>endpoint</code> 和 <code>service</code> 进行绑定</li><li>之后其余的组件就可以使用这个 service，比如 <code>service mesh</code>、<code>ingress</code>、<code>kube-proxy</code>、<code>coreDNS</code> 等组件。</li></ul><h2 id="像Redis作者那样，使用Go实现一个聊天服务器，不到100行代码"><a href="#像Redis作者那样，使用Go实现一个聊天服务器，不到100行代码" class="headerlink" title="像Redis作者那样，使用Go实现一个聊天服务器，不到100行代码"></a>像Redis作者那样，使用Go实现一个聊天服务器，不到100行代码</h2><p>URL: <a href="https://colobu.com/2023/10/29/implement-a-small-chat-server-like-antirez-in-100-lines/">https://colobu.com/2023/10/29/implement-a-small-chat-server-like-antirez-in-100-lines/</a></p><blockquote><p>前段时间 Redis 作者用 C 语言写了一个简单的聊天服务器，作者使用 Go 实现了类似的功能，代码量也很少，适合新手联系（ Go +goroutine 确实比 Java 写起来要简单）<br><img src="https://s2.loli.net/2023/11/09/af9pk2lC51ujIgq.png" alt="image.png"></p></blockquote><p>有几个核心流程：</p><ul><li>每次创建一个连接时，都会将这个连接保存在内存里，使用 conn 作为 key</li><li>每次发送消息时会将消息发到一个内部 chan 中，然后异步读取 chan 并通过 conn 发送消息</li></ul><h2 id="Five-API-Performance-Optimization-Tricks-that-Every-Java-Developer-Must-Know-by-lance-Javarevisited-Medium"><a href="#Five-API-Performance-Optimization-Tricks-that-Every-Java-Developer-Must-Know-by-lance-Javarevisited-Medium" class="headerlink" title="Five API Performance Optimization Tricks that Every Java Developer Must Know | by lance | Javarevisited | Medium"></a>Five API Performance Optimization Tricks that Every Java Developer Must Know | by lance | Javarevisited | Medium</h2><p>URL: <a href="https://medium.com/javarevisited/five-api-performance-optimization-tricks-that-every-java-developer-must-know-75324ee1d244">https://medium.com/javarevisited/five-api-performance-optimization-tricks-that-every-java-developer-must-know-75324ee1d244</a></p><blockquote><p>作者讲了一些常见的  API 优化手段，不止是 Java 开发者适用。</p></blockquote><ol><li>并行调用</li><li>避免长事务：避免 RPC 和查询逻辑与事务代码放在一起，应该拆分。</li><li>添加合适的索引</li><li>数据库返回少量的数据</li><li>加缓存</li></ol><h2 id="Are-you-correctly-using-Optional-Collections-and-Null-in-your-Java-code-by-Abhishek-Singh-Medium"><a href="#Are-you-correctly-using-Optional-Collections-and-Null-in-your-Java-code-by-Abhishek-Singh-Medium" class="headerlink" title="Are you correctly using Optional, Collections, and Null in your Java code ? | by Abhishek Singh | Medium"></a>Are you correctly using Optional, Collections, and Null in your Java code ? | by Abhishek Singh | Medium</h2><p>URL: <a href="https://medium.com/@abhisheksinghjava/are-you-correctly-using-optional-collections-and-null-in-your-java-code-5d2b8617d47c">https://medium.com/@abhisheksinghjava/are-you-correctly-using-optional-collections-and-null-in-your-java-code-5d2b8617d47c</a></p><blockquote><p>Java 介绍了 <code>Optional</code> 的正确用法<br><img src="https://s2.loli.net/2023/11/10/u5xIePQBwz3iS8Z.png" alt="image.png"><br><img src="https://s2.loli.net/2023/11/10/I2AiOCdvaDbXrG4.png" alt="image.png"></p></blockquote><ol><li>入参不需要 <code>Optional</code></li><li>私有方法返回不需要 <code>Optional</code></li><li>公共方法返回使用 <code>Optional</code>，因为有些开发者可能不会判断 null。</li><li>集合类数据返回不需要返回 <code>Optional/null</code>, 而是返回空集合。</li></ol><p>文章链接：</p><ul><li><a href="https://blog.kloudmate.com/how-to-use-opentelemetry-in-go-e416ca01c499">https://blog.kloudmate.com/how-to-use-opentelemetry-in-go-e416ca01c499</a></li><li><a href="https://itnext.io/what-happens-when-you-create-a-pod-in-kubernetes-6b789b6db8a8">https://itnext.io/what-happens-when-you-create-a-pod-in-kubernetes-6b789b6db8a8</a></li><li><a href="https://colobu.com/2023/10/29/implement-a-small-chat-server-like-antirez-in-100-lines/">https://colobu.com/2023/10/29/implement-a-small-chat-server-like-antirez-in-100-lines/</a></li><li><a href="https://medium.com/javarevisited/five-api-performance-optimization-tricks-that-every-java-developer-must-know-75324ee1d244">https://medium.com/javarevisited/five-api-performance-optimization-tricks-that-every-java-developer-must-know-75324ee1d244</a></li><li><a href="https://medium.com/@abhisheksinghjava/are-you-correctly-using-optional-collections-and-null-in-your-java-code-5d2b8617d47c">https://medium.com/@abhisheksinghjava/are-you-correctly-using-optional-collections-and-null-in-your-java-code-5d2b8617d47c</a></li></ul><p>#Newletters </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/11/10/aywEgYVeC9vL8pZ.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术阅读周刊，每周更新。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;历史更新&quot;&gt;&lt;a href=&quot;#历史更新&quot; class=&quot;headerlink&quot; title=&quot;历史更新&quot;&gt;&lt;/a&gt;历史更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/&quot;&gt;20231013：第一期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/10/22/ob/newsletter/Newsletter02-20231022/&quot;&gt;20231022：第二期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/10/27/ob/newsletter/Newsletter03-20231027/&quot;&gt;20231027：第三期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/11/03/ob/newsletter/Newsletter04-20231103/&quot;&gt;20231027：第四期&lt;/a&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Newsletter" scheme="http://crossoverjie.top/categories/OB/Newsletter/"/>
    
    
  </entry>
  
  <entry>
    <title>k8s-服务网格实战-配置 Mesh（灰度发布）</title>
    <link href="http://crossoverjie.top/2023/11/07/ob/k8s-Istio02/"/>
    <id>http://crossoverjie.top/2023/11/07/ob/k8s-Istio02/</id>
    <published>2023-11-07T14:30:46.000Z</published>
    <updated>2023-11-07T07:42:58.171Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/11/07/rmwdGK6TQDuhAEW.png" alt="istio-02.png"></p><p>在上一篇 <a href="https://crossoverjie.top/2023/10/31/ob/k8s-Istio01/">k8s-服务网格实战-入门Istio</a>中分享了如何安装部署 <code>Istio</code>，同时可以利用 <code>Istio</code> 实现 <code>gRPC</code> 的负载均衡。</p><span id="more"></span><p>今天我们更进一步，深入了解使用 Istio 的功能。<br><img src="https://s2.loli.net/2023/11/07/jKIeEH7ir9uqDUd.png" alt="image.png"><br>从 Istio 的流量模型中可以看出：Istio 支持管理集群的出入口请求（gateway），同时也支持管理集群内的 mesh 流量，也就是集群内服务之间的请求。</p><p>本次先讲解集群内部的请求，配合实现以下两个功能：</p><ul><li>灰度发布（对指定的请求分别路由到不同的 service 中）</li><li>配置 service 的请求权重</li></ul><h2 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h2><p>在开始之前会部署两个 <code>deployment</code> 和一个 <code>service</code>，同时这两个 <code>deployment</code> 所关联的 <code>Pod</code> 分别对应了两个不同的 <code>label</code>，由于在灰度的时候进行分组。<br><img src="https://s2.loli.net/2023/11/07/tLOYQiNg5HEe2ry.png" alt="image.png"></p><p>使用这个 <code>yaml</code> 会部署所需要的 <code>deployment</code> 和 <code>service</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/crossoverJie/k8s-combat/main/deployment/istio-mesh.yaml </span><br></pre></td></tr></table></figure><hr><p>首先设想下什么情况下我们需要灰度发布，一般是某个重大功能的测试，只对部分进入内测的用户开放入口。</p><p>假设我们做的是一个 <code>App</code>，我们可以对拿到了内测包用户的所有请求头中加入一个版本号。</p><p>比如 <code>version=200</code> 表示新版本，<code>version=100</code> 表示老版本。<br>同时在服务端会将这个版本号打印出来，用于区分请求是否进入了预期的 Pod。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client </span></span><br><span class="line">version := r.URL.Query().Get(<span class="string">&quot;version&quot;</span>)  </span><br><span class="line">name := <span class="string">&quot;world&quot;</span>  </span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Second)  </span><br><span class="line">md := metadata.New(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;  </span><br><span class="line">    <span class="string">&quot;version&quot;</span>: version,  </span><br><span class="line">&#125;)  </span><br><span class="line">ctx = metadata.NewOutgoingContext(ctx, md)  </span><br><span class="line"><span class="keyword">defer</span> cancel()  </span><br><span class="line">g, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, <span class="type">error</span>) &#123;  </span><br><span class="line">    md, ok := metadata.FromIncomingContext(ctx)  </span><br><span class="line">    <span class="keyword">var</span> version <span class="type">string</span>  </span><br><span class="line">    <span class="keyword">if</span> ok &#123;  </span><br><span class="line">       version = md.Get(<span class="string">&quot;version&quot;</span>)[<span class="number">0</span>]  </span><br><span class="line">    &#125;    log.Printf(<span class="string">&quot;Received: %v, version: %s&quot;</span>, in.GetName(), version)  </span><br><span class="line">    name, _ := os.Hostname()  </span><br><span class="line">    <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: fmt.Sprintf(<span class="string">&quot;hostname:%s, in:%s, version:%s&quot;</span>, name, in.Name, version)&#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对-service-分组"><a href="#对-service-分组" class="headerlink" title="对 service 分组"></a>对 service 分组</h3><p>进行灰度测试时往往需要新增部署一个灰度服务，这里我们称为 v2（也就是上图中的 Pod2）。</p><p>同时需要将 v1 和 v2 分组：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-service-ds</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">host:</span> <span class="string">k8s-combat-service-istio-mesh</span>  </span><br><span class="line">  <span class="attr">subsets:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span>  </span><br><span class="line">      <span class="attr">labels:</span>  </span><br><span class="line">        <span class="attr">app:</span> <span class="string">k8s-combat-service-v1</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span>  </span><br><span class="line">      <span class="attr">labels:</span>  </span><br><span class="line">        <span class="attr">app:</span> <span class="string">k8s-combat-service-v2</span></span><br></pre></td></tr></table></figure><p>这里我们使用 Istio 的 <code>DestinationRule</code> 定义 <code>subset</code>，也就是将我们的 <code>service</code> 下的 Pod 分为 v1&#x2F;v2。</p><blockquote><p>使用 标签 <code>app</code> 进行分组</p></blockquote><p>注意这里的 <code>host: k8s-combat-service-istio-mesh</code> 通常配置的是 <code>service</code> 名称。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-service-istio-mesh</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">appId:</span> <span class="string">&quot;12345&quot;</span>  </span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span>  </span><br><span class="line">  <span class="attr">ports:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8081</span>  </span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8081</span>  </span><br><span class="line">      <span class="attr">name:</span> <span class="string">app</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grpc</span>  </span><br><span class="line">      <span class="attr">port:</span> <span class="number">50051</span>  </span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">50051</span></span><br></pre></td></tr></table></figure><p>也就是这里 service 的名称，同时也支持配置为 <code>host: k8s-combat-service-istio-mesh.default.svc.cluster.local</code>，如果使用的简写<code>Istio</code> 会根据当前指定的 <code>namespace</code> 进行解析。</p><blockquote><p>Istio 更推荐使用全限定名替代我们这里的简写，从而避免误操作。</p></blockquote><p>当然我们也可以在 <code>DestinationRule</code> 中配置负载均衡的策略，这里我们先略过：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-service-ds</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">host:</span> <span class="string">k8s-combat-service-istio-mesh</span> </span><br><span class="line">  <span class="attr">trafficPolicy:</span></span><br><span class="line">    <span class="attr">loadBalancer:</span></span><br><span class="line">      <span class="attr">simple:</span> <span class="string">ROUND_ROBIN</span>  </span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/11/07/TJyEV6eIiCcapSH.png" alt="image.png"></p><hr><p>这样我们就定义好了两个分组：</p><ul><li>v1：app: k8s-combat-service-v1</li><li>v2：app: k8s-combat-service-v2</li></ul><p>之后就可以配置路由规则将流量分别指定到两个不同的组中，这里我们使用 <code>VirtualService</code> 进行配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-service-vs</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">gateways:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">mesh</span>  </span><br><span class="line">  <span class="attr">hosts:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">k8s-combat-service-istio-mesh</span> <span class="comment"># match this host</span></span><br><span class="line"><span class="attr">http:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span>  </span><br><span class="line">    <span class="attr">match:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">headers:</span>  </span><br><span class="line">          <span class="attr">version:</span>  </span><br><span class="line">            <span class="attr">exact:</span> <span class="string">&#x27;100&#x27;</span>  </span><br><span class="line">    <span class="attr">route:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">destination:</span>  </span><br><span class="line">          <span class="attr">host:</span> <span class="string">k8s-combat-service-istio-mesh</span>  </span><br><span class="line">          <span class="attr">subset:</span> <span class="string">v1</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span>  </span><br><span class="line">    <span class="attr">match:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">headers:</span>  </span><br><span class="line">          <span class="attr">version:</span>  </span><br><span class="line">            <span class="attr">exact:</span> <span class="string">&#x27;200&#x27;</span>  </span><br><span class="line">    <span class="attr">route:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">destination:</span>  </span><br><span class="line">          <span class="attr">host:</span> <span class="string">k8s-combat-service-istio-mesh</span>  </span><br><span class="line">          <span class="attr">subset:</span> <span class="string">v2</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default</span>  </span><br><span class="line">    <span class="attr">route:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">destination:</span>  </span><br><span class="line">          <span class="attr">host:</span> <span class="string">k8s-combat-service-istio-mesh</span>  </span><br><span class="line">          <span class="attr">subset:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure><p>这个规则很简单，会检测 http 协议的 <code>header</code> 中的 <code>version</code> 字段值，如果为 100 这路由到 <code>subset=v1</code> 这个分组的 Pod 中，同理为 200 时则路由到 <code>subset=v2</code> 这个分组的 Pod 中。</p><p>当没有匹配到 header 时则进入默认的 <code>subset:v1</code></p><blockquote><p> <code>gRPC</code> 也是基于 http 协议，它的 <code>metadata</code> 也就对应了 <code>http</code> 协议中的 <code>header</code>。</p></blockquote><h3 id="header-x3D-100"><a href="#header-x3D-100" class="headerlink" title="header&#x3D;100"></a>header&#x3D;100</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Greeting: hostname:k8s-combat-service-v1-5b998dc8c8-hkb72, <span class="keyword">in</span>:world, version:100istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=100&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-v1-5b998dc8c8-hkb72, <span class="keyword">in</span>:world, version:100istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=100&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-v1-5b998dc8c8-hkb72, <span class="keyword">in</span>:world, version:100istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=100&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-v1-5b998dc8c8-hkb72, <span class="keyword">in</span>:world, version:100istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=100&quot;</span></span><br></pre></td></tr></table></figure><h3 id="header-x3D-200"><a href="#header-x3D-200" class="headerlink" title="header&#x3D;200"></a>header&#x3D;200</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Greeting: hostname:k8s-combat-service-v2-5db566fb76-xj7j6, <span class="keyword">in</span>:world, version:200istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=200&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-v2-5db566fb76-xj7j6, <span class="keyword">in</span>:world, version:200istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=200&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-v2-5db566fb76-xj7j6, <span class="keyword">in</span>:world, version:200istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=200&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-v2-5db566fb76-xj7j6, <span class="keyword">in</span>:world, version:200istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=200&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-v2-5db566fb76-xj7j6, <span class="keyword">in</span>:world, version:200istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=200&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-v2-5db566fb76-xj7j6, <span class="keyword">in</span>:world, version:200istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=200&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-v2-5db566fb76-xj7j6, <span class="keyword">in</span>:world, version:200istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=200&quot;</span></span><br></pre></td></tr></table></figure><p>根据以上的上面的测试请求来看，只要我们请求头里带上指定的 <code>version</code> 就会被路由到指定的 <code>Pod</code> 中。</p><p>利用这个特性我们就可以在灰度验证的时候单独发一个灰度版本的 <code>Deployment</code>，同时配合客户端指定版本就可以实现灰度功能了。</p><h2 id="配置权重"><a href="#配置权重" class="headerlink" title="配置权重"></a>配置权重</h2><p>同样基于 <code>VirtualService</code> 我们还可以对不同的 <code>subset</code> 分组进行权重配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-service-vs</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">gateways:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">mesh</span>  </span><br><span class="line">  <span class="attr">hosts:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">k8s-combat-service-istio-mesh</span> <span class="comment"># match this host  </span></span><br><span class="line">  <span class="attr">http:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">match:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">uri:</span>  </span><br><span class="line">            <span class="attr">exact:</span> <span class="string">/helloworld.Greeter/SayHello</span>  </span><br><span class="line">      <span class="attr">route:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">destination:</span>  </span><br><span class="line">            <span class="attr">host:</span> <span class="string">k8s-combat-service-istio-mesh</span>  </span><br><span class="line">            <span class="attr">subset:</span> <span class="string">v1</span>  </span><br><span class="line">          <span class="attr">weight:</span> <span class="number">10</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">destination:</span>  </span><br><span class="line">            <span class="attr">host:</span> <span class="string">k8s-combat-service-istio-mesh</span>  </span><br><span class="line">            <span class="attr">subset:</span> <span class="string">v2</span>  </span><br><span class="line">          <span class="attr">weight:</span> <span class="number">90</span>  </span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5000ms</span></span><br></pre></td></tr></table></figure><p>这里演示的是针对 <code>SayHello</code> 接口进行权重配置（当然还有多种匹配规则），90% 的流量会进入 v2 这个 subset，也就是在 <code>k8s-combat-service-istio-mesh</code> service 下的 <code>app: k8s-combat-service-v2</code> Pod。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Greeting: hostname:k8s-combat-service-v2-5db566fb76-xj7j6, <span class="keyword">in</span>:world, version:200istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=200&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-v2-5db566fb76-xj7j6, <span class="keyword">in</span>:world, version:200istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=200&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-v2-5db566fb76-xj7j6, <span class="keyword">in</span>:world, version:200istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=200&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-v2-5db566fb76-xj7j6, <span class="keyword">in</span>:world, version:200istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=200&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-v2-5db566fb76-xj7j6, <span class="keyword">in</span>:world, version:200istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=200&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-v2-5db566fb76-xj7j6, <span class="keyword">in</span>:world, version:200istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=200&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-**v1**-5b998dc8c8-hkb72, <span class="keyword">in</span>:world, version:200istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$ curl <span class="string">&quot;http://127.0.0.1:8081/grpc_client?name=k8s-combat-service-istio-mesh&amp;version=200&quot;</span></span><br><span class="line">Greeting: hostname:k8s-combat-service-v2-5db566fb76-xj7j6, <span class="keyword">in</span>:world, version:200istio-proxy@k8s-combat-service-v1-5b998dc8c8-hkb72:/$</span><br></pre></td></tr></table></figure><p>经过测试会发现大部分的请求都会按照我们的预期进入 v2 这个分组。</p><p>当然除之外之外我们还可以：</p><ul><li>超时时间</li><li>故障注入</li><li>重试<br>具体的配置可以参考 <a href="https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPMatchRequest">Istio</a> 官方文档：<br><img src="https://s2.loli.net/2023/11/07/LBjEtd1MP9VcAgl.png" alt="image.png"><br>当然在一些云平台也提供了可视化的页面，可以更直观的使用。<br><img src="https://s2.loli.net/2023/11/07/2LVTgeiSK9HyxQJ.png" alt="image.png"></li></ul><blockquote><p>以上是 阿里云的截图</p></blockquote><p>但他们的管理的资源都偏 <code>kubernetes</code>，一般是由运维或者是 DevOps 来配置，不方便开发使用，所以还需要一个介于云厂商和开发者之间的管理发布平台，可以由开发者以项目维度管理维护这些功能。</p><p>本文的所有源码在这里可以访问：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p><p>#Blog #Istio </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/11/07/rmwdGK6TQDuhAEW.png&quot; alt=&quot;istio-02.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一篇 &lt;a href=&quot;https://crossoverjie.top/2023/10/31/ob/k8s-Istio01/&quot;&gt;k8s-服务网格实战-入门Istio&lt;/a&gt;中分享了如何安装部署 &lt;code&gt;Istio&lt;/code&gt;，同时可以利用 &lt;code&gt;Istio&lt;/code&gt; 实现 &lt;code&gt;gRPC&lt;/code&gt; 的负载均衡。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/k8s/"/>
    
    
    <category term="Istio" scheme="http://crossoverjie.top/tags/Istio/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读周刊第第四期</title>
    <link href="http://crossoverjie.top/2023/11/03/ob/newsletter/Newsletter04-20231103/"/>
    <id>http://crossoverjie.top/2023/11/03/ob/newsletter/Newsletter04-20231103/</id>
    <published>2023-11-03T09:28:25.000Z</published>
    <updated>2023-11-02T10:09:56.401Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/11/02/bYGoVQFxSL5nqw1.png" alt="image.png"></p><p><strong>技术阅读周刊，每周更新。</strong></p><h2 id="历史更新"><a href="#历史更新" class="headerlink" title="历史更新"></a>历史更新</h2><ul><li><a href="https://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/">20231013：第一期</a></li><li><a href="https://crossoverjie.top/2023/10/22/ob/newsletter/Newsletter02-20231022/">20231022：第二期</a></li><li><a href="https://crossoverjie.top/2023/10/27/ob/newsletter/Newsletter03-20231027/">20231027：第三期</a><span id="more"></span></li></ul><h2 id="Technology-trends-for-Spring-projects-java"><a href="#Technology-trends-for-Spring-projects-java" class="headerlink" title="Technology trends for Spring projects : java"></a>Technology trends for Spring projects : java</h2><p>URL: <a href="https://www.reddit.com/r/java/comments/17ixfzf/technology_trends_for_spring_projects/">https://www.reddit.com/r/java/comments/17ixfzf/technology_trends_for_spring_projects/</a><br>这是一个 <code>Reddit</code> 帖子，讨论了 <code>Spring</code> 项目的技术趋势，以下是一些点赞较高的回复：<br>在招聘的时候还会 <code>Spring</code> 考虑周边的技术栈：比如 Linux、Docker、<code>kubernetes</code>、Git 等，但如果你具备 Spring Security 和 OpenSSL 的话会更受欢迎。</p><blockquote><p>这点在国内感受貌似并不明显，不确定是不是国外更看重一些。</p></blockquote><p>Kotlin 在服务端目前还处于一个较小的规模，特别是如今 Java 发版节奏加快，对于大部分人来说没有足够的理由来摆脱 Java。</p><p><code>Spring</code> 依然是 Java 领域最流行的服务端框架，不管你是否喜欢。</p><p>不用花太多时间去追寻学习新技术，更重要的是确保你已经打好基础了，比如数据库几乎不会发生变化，Spring 底层依然是基于 Servlet 实现的，理解这些基础技术是如何运作的，从而避免一些常见问题。<br>    现在 Spring 已经没有使用 servlet，而是该用 WebFlux 替代</p><blockquote><p>比较认可这个观点，还是更应该花时间到不会变的技术栈上，上层技术如何改变学起来也会更容易。</p></blockquote><p>其中有两个评论比较有意思：<br>Spring 团队花了大量的时间来接入 Kotlin，比如 coroutines 和一些其他资源<br>    在 Spring3 发布的时候，spring 团队也投入了大量时间到 <code>Groovy</code><br>确实当下 <code>Groovy</code> 使用的越来越少了，所以技术潮流确实会随时间变化，还是抓住不可变的性价比更高。</p><h2 id="Service-mesh-data-plane-vs-control-plane-by-Matt-Klein-Envoy-Proxy"><a href="#Service-mesh-data-plane-vs-control-plane-by-Matt-Klein-Envoy-Proxy" class="headerlink" title="Service mesh data plane vs. control plane | by Matt Klein | Envoy Proxy"></a>Service mesh data plane vs. control plane | by Matt Klein | Envoy Proxy</h2><p>URL: <a href="https://blog.envoyproxy.io/service-mesh-data-plane-vs-control-plane-2774e720f7fc">https://blog.envoyproxy.io/service-mesh-data-plane-vs-control-plane-2774e720f7fc</a><br><img src="https://s2.loli.net/2023/11/02/chqbKiTEmDrJpvt.png" alt="image.png"></p><p>服务网格中的数据库面和控制面对比，数据面主要包含以下功能：</p><ul><li>健康检测</li><li>路由</li><li>负载均衡</li><li>身份验证</li><li>可观测性</li></ul><p>控制面主要包含以下功能：</p><ul><li>服务注册发现</li><li>各种控制面的配置管理</li></ul><p>常见的数据面产品有：<a href="https://linkerd.io/">Linkerd</a>, <a href="https://www.nginx.com/">NGINX</a>, <a href="https://www.haproxy.com/">HAProxy</a>, <a href="https://envoyproxy.github.io/">Envoy</a>, <a href="https://traefik.io/">Traefik</a><br>控制面产品有：<a href="https://istio.io/">Istio</a>, <a href="https://verizon.github.io/nelson/">Nelson</a>, <a href="https://github.com/airbnb/synapse">SmartStack</a><br>数据面和控制面是松耦合的，可以替换不同的数据面产品。</p><h2 id="Kubewatch-A-Kubernetes-Watcher-for-Observability-and-Monitoring-by-Seifeddine-Rajhi-Oct-2023-Medium"><a href="#Kubewatch-A-Kubernetes-Watcher-for-Observability-and-Monitoring-by-Seifeddine-Rajhi-Oct-2023-Medium" class="headerlink" title="Kubewatch: A Kubernetes Watcher for Observability and Monitoring | by Seifeddine Rajhi | Oct, 2023 | Medium"></a>Kubewatch: A Kubernetes Watcher for Observability and Monitoring | by Seifeddine Rajhi | Oct, 2023 | Medium</h2><p>URL: <a href="https://medium.com/@seifeddinerajhi/kubewatch-a-kubernetes-watcher-for-observability-and-monitoring-d6dea1dbeb06">https://medium.com/@seifeddinerajhi/kubewatch-a-kubernetes-watcher-for-observability-and-monitoring-d6dea1dbeb06</a><br>介绍了一个名为 <a href="https://github.com/robusta-dev/kubewatch">kubewatch</a> 的开源项目。<br><img src="https://s2.loli.net/2023/11/02/E57lCTrt3fnR2wZ.png" alt="image.png"></p><p>可以将各种资源变化的事件通过 webhook 的方式发出通知，可以让维护者请求 <code>kubernetes</code> 的运行状态。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">namespaceToWatch:</span> <span class="string">&quot;default&quot;</span></span><br><span class="line"><span class="attr">resourcesToWatch:</span></span><br><span class="line">  <span class="attr">deployment:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">replicationcontroller:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">replicaset:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">daemonset:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">services:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">pod:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">job:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">node:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">clusterrole:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">clusterrolebinding:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">serviceaccount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">persistentvolume:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">secret:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">configmap:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">ingress:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">coreevent:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">event:</span> <span class="literal">true</span>     </span><br></pre></td></tr></table></figure><blockquote><p>这类开源项目其实还蛮多的，我之前也写过一个用于监听我们应用 Pod 的变化的事件，然后将这些消息发送给 Pulsar，只是这个项目做的更全了。</p></blockquote><h2 id="Bye-bye-ChatGPT-AI-Tools-That-Are-As-Good-As-ChatGPT-But-Few-People-Use-by-ArticleAce-Medium"><a href="#Bye-bye-ChatGPT-AI-Tools-That-Are-As-Good-As-ChatGPT-But-Few-People-Use-by-ArticleAce-Medium" class="headerlink" title="Bye-bye, ChatGPT: AI Tools That Are As Good As ChatGPT (But Few People Use) | by ArticleAce | Medium"></a>Bye-bye, ChatGPT: AI Tools That Are As Good As ChatGPT (But Few People Use) | by ArticleAce | Medium</h2><p>URL: <a href="https://medium.com/@Article_Ace/bye-bye-chatgpt-ai-tools-that-are-as-good-as-chatgpt-but-few-people-use-9df4dcdf5ab0">https://medium.com/@Article_Ace/bye-bye-chatgpt-ai-tools-that-are-as-good-as-chatgpt-but-few-people-use-9df4dcdf5ab0</a><br>作者分享了一些除了 ChatGPT 之外的工具，大部分是一些垂直应用。</p><h3 id="Auto-GPT"><a href="#Auto-GPT" class="headerlink" title="Auto-GPT"></a>Auto-GPT</h3><p><a href="https://github.com/Significant-Gravitas/Auto-GPT">https://github.com/Significant-Gravitas/Auto-GPT</a><br><img src="https://s2.loli.net/2023/11/02/LfYKVmgsy4IarE7.png" alt="image.png"></p><p>这个工具已经很流行了，可以自己给自己输入 Prompt 直到完成你的目标为止。</p><h3 id="OpenAI-Playground"><a href="#OpenAI-Playground" class="headerlink" title="OpenAI-Playground"></a>OpenAI-Playground</h3><p>ChatGPT 目前只能让我们选择使用的模型（3.5&#x2F;4）但我们可以使用 playground 来自定义一些输出。<br><a href="https://platform.openai.com/playground">https://platform.openai.com/playground</a><br><img src="https://s2.loli.net/2023/11/02/xjbguH3NhY8PRrw.png" alt="image.png"></p><h3 id="Jasper"><a href="#Jasper" class="headerlink" title="Jasper"></a>Jasper</h3><p> Jasper 是一个用于为社交媒体、广告、博客、邮件生成内容的 AI 工具，相当于是一些不同的垂直领域。<br> <a href="https://www.jasper.ai/">https://www.jasper.ai/</a><br> <img src="https://s2.loli.net/2023/11/02/gfGbBRN8wimklxI.png" alt="image.png"><br>作者会用它来生成一些创意、和视频脚本。</p><h3 id="Quillbot"><a href="#Quillbot" class="headerlink" title="Quillbot"></a>Quillbot</h3><p><a href="https://quillbot.com/">https://quillbot.com/</a><br>这个也是我自己用的较多的工具，可以用来润色我们的英文表达。<br>但我需要在 GitHub 上提一些比较复杂的 issue 、PR 或者是英文邮件时，就会用这个工具进行润色，效果还是很不错的。<br><img src="https://s2.loli.net/2023/11/02/i3bfTUeMvsrEVly.png" alt="image.png"></p><h2 id="如何用Go实现一个异步网络库？"><a href="#如何用Go实现一个异步网络库？" class="headerlink" title="如何用Go实现一个异步网络库？"></a>如何用Go实现一个异步网络库？</h2><p>URL: <a href="https://mp.weixin.qq.com/s/UBcDrPwEdFz7JOfj0UP2Uw">https://mp.weixin.qq.com/s/UBcDrPwEdFz7JOfj0UP2Uw</a><br>本文主要讲解了一些场景的网络模型以及 Go 原生网络模型的原理，并对如何实现一个网络库提供了一些思路<br>网络库通常是为了解决两个问题：</p><ul><li>C10K&#x2F;100K 问题，如何应对海量的并发连接</li><li>服务端如何在高并发的时候正确响应<br>对此有三种网络模型：</li><li>传统 IO 阻塞模型</li><li>Reactor 模型</li><li>Proactor 模型<br><img src="https://s2.loli.net/2023/11/02/X2kKESoBzRwjlip.png" alt="image.png"></li></ul><p> Go 原生模型其实已经很强了，可以把他理解为 Reactor 模型。<br> <img src="https://s2.loli.net/2023/11/02/grRPoQ5uIJBVDAS.png" alt="image.png"></p><p>可以基于以下三层设计进行设计：<br><img src="https://s2.loli.net/2023/11/02/spoJIROb8zWdNL7.png" alt="image.png"><br>也可以参考一些开源的网络库：</p><ul><li><a href="https://github.com/panjf2000/gnet">https://github.com/panjf2000/gnet</a></li><li><a href="https://github.com/Allenxuxu/gev">https://github.com/Allenxuxu/gev</a></li><li><a href="https://github.com/aceld/zinx">https://github.com/aceld/zinx</a></li></ul><p>文章链接：</p><ul><li><a href="https://www.reddit.com/r/java/comments/17ixfzf/technology_trends_for_spring_projects/">https://www.reddit.com/r/java/comments/17ixfzf/technology_trends_for_spring_projects/</a></li><li><a href="https://blog.envoyproxy.io/service-mesh-data-plane-vs-control-plane-2774e720f7fc">https://blog.envoyproxy.io/service-mesh-data-plane-vs-control-plane-2774e720f7fc</a></li><li><a href="https://medium.com/@seifeddinerajhi/kubewatch-a-kubernetes-watcher-for-observability-and-monitoring-d6dea1dbeb06">https://medium.com/@seifeddinerajhi/kubewatch-a-kubernetes-watcher-for-observability-and-monitoring-d6dea1dbeb06</a></li><li><a href="https://medium.com/@Article_Ace/bye-bye-chatgpt-ai-tools-that-are-as-good-as-chatgpt-but-few-people-use-9df4dcdf5ab0">https://medium.com/@Article_Ace/bye-bye-chatgpt-ai-tools-that-are-as-good-as-chatgpt-but-few-people-use-9df4dcdf5ab0</a></li><li><a href="https://mp.weixin.qq.com/s/UBcDrPwEdFz7JOfj0UP2Uw">https://mp.weixin.qq.com/s/UBcDrPwEdFz7JOfj0UP2Uw</a></li></ul><p>#Newletters </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/11/02/bYGoVQFxSL5nqw1.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术阅读周刊，每周更新。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;历史更新&quot;&gt;&lt;a href=&quot;#历史更新&quot; class=&quot;headerlink&quot; title=&quot;历史更新&quot;&gt;&lt;/a&gt;历史更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/&quot;&gt;20231013：第一期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/10/22/ob/newsletter/Newsletter02-20231022/&quot;&gt;20231022：第二期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/10/27/ob/newsletter/Newsletter03-20231027/&quot;&gt;20231027：第三期&lt;/a&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Newsletter" scheme="http://crossoverjie.top/categories/OB/Newsletter/"/>
    
    
  </entry>
  
  <entry>
    <title>k8s-服务网格实战-入门Istio</title>
    <link href="http://crossoverjie.top/2023/10/31/ob/k8s-Istio01/"/>
    <id>http://crossoverjie.top/2023/10/31/ob/k8s-Istio01/</id>
    <published>2023-10-31T14:30:46.000Z</published>
    <updated>2023-10-31T15:29:38.024Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/31/QChAqoOVcxbP4tU.png" alt="istio-01.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>终于进入大家都比较感兴趣的服务网格系列了，在前面已经讲解了：</p><ul><li>如何部署应用到 <code>kubernetes</code></li><li>服务之间如何调用</li><li>如何通过域名访问我们的服务</li><li>如何使用 <code>kubernetes</code> 自带的配置 <code>ConfigMap</code></li></ul><p>基本上已经够我们开发一般规模的 web 应用了；但在企业中往往有着复杂的应用调用关系，应用与应用之间的请求也需要进行管理。<br>比如常见的限流、降级、trace、监控、负载均衡等功能。</p><p>在我们使用 <code>kubernetes</code> 之前往往都是由微服务框架来解决这些问题，比如 Dubbo、SpringCloud 都有对应的功能。</p><p>但当我们上了 <code>kubernetes</code> 之后这些事情就应该交给一个专门的云原生组件来解决，也就是本次会讲到的 <code>Istio</code>，它是目前使用最为广泛的服务网格解决方案。</p><span id="more"></span><p><img src="https://s2.loli.net/2023/10/31/CtJsogSyPD7cjEW.png" alt="image.png"><br>官方对于 Istio 的解释比较简洁，落到具体的功能点也就是刚才提到的：</p><ul><li>限流降级</li><li>路由转发、负载均衡</li><li>入口网关、<code>TLS安全认证</code></li><li>灰度发布等</li></ul><p><img src="https://s2.loli.net/2023/10/31/aXnNZhu91m7V2Tw.png" alt="image.png"></p><p>再结合官方的架构图可知：Istio 分为控制面 <code>control plane</code> 和数据面 <code>data plane</code>。</p><p>控制面可以理解为 Istio 自身的管理功能：</p><ul><li>比如服务注册发现</li><li>管理配置数据面所需要的网络规则等</li></ul><p>而数据面可以简单的把他理解为由 <code>Envoy</code> 代理的我们的业务应用，我们应用中所有的流量进出都会经过 <code>Envoy</code> 代理。</p><p>所以它可以实现负载均衡、熔断保护、认证授权等功能。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先安装 Istio 命令行工具</p><blockquote><p>这里的前提是有一个 kubernetes 运行环境</p></blockquote><p>Linux 使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://istio.io/downloadIstio | sh -</span><br></pre></td></tr></table></figure><p>Mac 可以使用 brew：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install istioctl</span><br></pre></td></tr></table></figure><p>其他环境可以下载 Istio 后配置环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PWD/bin:$PATH</span><br></pre></td></tr></table></figure><p>之后我们可以使用 <code>install</code> 命令安装控制面。</p><blockquote><p>这里默认使用的是 <code>kubectl</code> 所配置的 <code>kubernetes</code> 集群</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istioctl install --<span class="built_in">set</span> profile=demo -y</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/10/30/DLOeRGrA7gNC1Xa.png"><br>这个的 <code>profile</code> 还有以下不同的值，为了演示我们使用 <code>demo</code> 即可。<br><img src="https://s2.loli.net/2023/10/26/3JXneYvyqI4WTgt.png" alt="image.png"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启 default 命名空间自动注入</span></span><br><span class="line">$ k label namespace default istio-injection=enabled</span><br><span class="line"></span><br><span class="line">$ k describe ns default</span><br><span class="line">Name:         default</span><br><span class="line">Labels:       istio-injection=enabled</span><br><span class="line">              kubernetes.io/metadata.name=default</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Active</span><br><span class="line">No resource quota.</span><br><span class="line">No LimitRange resource.</span><br></pre></td></tr></table></figure><p>之后我们为 <code>namespace</code> 打上 <code>label</code>，使得 Istio 控制面知道哪个 <code>namespace</code> 下的 <code>Pod</code> 会自动注入 <code>sidecar</code>。</p><p>这里我们为 default 这个命名空间打开自动注入 <code>sidecar</code>，然后在这里部署我们之前使用到的 <a href="https://github.com/crossoverJie/k8s-combat/blob/main/deployment/deployment-istio.yaml">deployment-istio.yaml</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ k apply -f deployment/deployment-istio.yaml</span><br><span class="line"></span><br><span class="line">$ k get pod</span><br><span class="line">NAME                                  READY   STATUS    RESTARTS</span><br><span class="line">k8s-combat-service-5bfd78856f-8zjjf   2/2     Running   0          </span><br><span class="line">k8s-combat-service-5bfd78856f-mblqd   2/2     Running   0          </span><br><span class="line">k8s-combat-service-5bfd78856f-wlc8z   2/2     Running   0       </span><br></pre></td></tr></table></figure><p>此时会看到每个Pod 有两个 container（其中一个就是 istio-proxy sidecar），也就是之前做 <a href="https://crossoverjie.top/2023/10/16/ob/k8s-grpc-lb/">gRPC 负载均衡</a>测试时的代码。</p><p><img src="https://s2.loli.net/2023/10/31/js1Gz5yVCNLep9W.png" alt="image.png"><br>还是进行负载均衡测试，效果是一样的，说明 <code>Istio</code> 起作用了。</p><p>此时我们再观察 <code>sidecar</code> 的日志时，会看到刚才我们所发出和接受到的流量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ k logs -f k8s-combat-service-5bfd78856f-wlc8z -c istio-proxy</span><br><span class="line"></span><br><span class="line">[2023-10-31T14:52:14.279Z] <span class="string">&quot;POST /helloworld.Greeter/SayHello HTTP/2&quot;</span> 200 - via_upstream - <span class="string">&quot;-&quot;</span> 12 61 14 9 <span class="string">&quot;-&quot;</span> <span class="string">&quot;grpc-go/1.58.3&quot;</span> <span class="string">&quot;6d293d32-af96-9f87-a8e4-6665632f7236&quot;</span> <span class="string">&quot;k8s-combat-service:50051&quot;</span> <span class="string">&quot;172.17.0.9:50051&quot;</span> inbound|50051|| 127.0.0.6:42051 172.17.0.9:50051 172.17.0.9:40804 outbound_.50051_._.k8s-combat-service.default.svc.cluster.local default</span><br><span class="line">[2023-10-31T14:52:14.246Z] <span class="string">&quot;POST /helloworld.Greeter/SayHello HTTP/2&quot;</span> 200 - via_upstream - <span class="string">&quot;-&quot;</span> 12 61 58 39 <span class="string">&quot;-&quot;</span> <span class="string">&quot;grpc-go/1.58.3&quot;</span> <span class="string">&quot;6d293d32-af96-9f87-a8e4-6665632f7236&quot;</span> <span class="string">&quot;k8s-combat-service:50051&quot;</span> <span class="string">&quot;172.17.0.9:50051&quot;</span> outbound|50051||k8s-combat-service.default.svc.cluster.local 172.17.0.9:40804 10.101.204.13:50051 172.17.0.9:54012 - default</span><br><span class="line">[2023-10-31T14:52:15.659Z] <span class="string">&quot;POST /helloworld.Greeter/SayHello HTTP/2&quot;</span> 200 - via_upstream - <span class="string">&quot;-&quot;</span> 12 61 35 34 <span class="string">&quot;-&quot;</span> <span class="string">&quot;grpc-go/1.58.3&quot;</span> <span class="string">&quot;ed8ab4f2-384d-98da-81b7-d4466eaf0207&quot;</span> <span class="string">&quot;k8s-combat-service:50051&quot;</span> <span class="string">&quot;172.17.0.10:50051&quot;</span> outbound|50051||k8s-combat-service.default.svc.cluster.local 172.17.0.9:39800 10.101.204.13:50051 172.17.0.9:54012 - default</span><br><span class="line">[2023-10-31T14:52:16.524Z] <span class="string">&quot;POST /helloworld.Greeter/SayHello HTTP/2&quot;</span> 200 - via_upstream - <span class="string">&quot;-&quot;</span> 12 61 28 26 <span class="string">&quot;-&quot;</span> <span class="string">&quot;grpc-go/1.58.3&quot;</span> <span class="string">&quot;67a22028-dfb3-92ca-aa23-573660b30dd4&quot;</span> <span class="string">&quot;k8s-combat-service:50051&quot;</span> <span class="string">&quot;172.17.0.8:50051&quot;</span> outbound|50051||k8s-combat-service.default.svc.cluster.local 172.17.0.9:44580 10.101.204.13:50051 172.17.0.9:54012 - default</span><br><span class="line">[2023-10-31T14:52:16.680Z] <span class="string">&quot;POST /helloworld.Greeter/SayHello HTTP/2&quot;</span> 200 - via_upstream - <span class="string">&quot;-&quot;</span> 12 61 2 2 <span class="string">&quot;-&quot;</span> <span class="string">&quot;grpc-go/1.58.3&quot;</span> <span class="string">&quot;b4761d9f-7e4c-9f2c-b06f-64a028faa5bc&quot;</span> <span class="string">&quot;k8s-combat-service:50051&quot;</span> <span class="string">&quot;172.17.0.10:50051&quot;</span> outbound|50051||k8s-combat-service.default.svc.cluster.local 172.17.0.9:39800 10.101.204.13:50051 172.17.0.9:54012 - default</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本期的内容比较简单，主要和安装配置相关，下一期更新如何配置内部服务调用的超时、限流等功能。</p><p>其实目前大部分操作都是偏运维的，即便是后续的超时配置等功能都只是编写 yaml 资源。</p><p>但在生产使用时，我们会给开发者提供一个管理台的可视化页面，可供他们自己灵活配置这些原本需要在 <code>yaml</code> 中配置的功能。</p><p><img src="https://s2.loli.net/2023/10/31/B3TiC9rJwPbGVHQ.png" alt="image.png"><br>其实各大云平台厂商都有提供类似的能力，比如阿里云的 EDAS 等。</p><p>本文的所有源码在这里可以访问：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p><p>#Blog #Istio </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/31/QChAqoOVcxbP4tU.png&quot; alt=&quot;istio-01.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;终于进入大家都比较感兴趣的服务网格系列了，在前面已经讲解了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何部署应用到 &lt;code&gt;kubernetes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;服务之间如何调用&lt;/li&gt;
&lt;li&gt;如何通过域名访问我们的服务&lt;/li&gt;
&lt;li&gt;如何使用 &lt;code&gt;kubernetes&lt;/code&gt; 自带的配置 &lt;code&gt;ConfigMap&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上已经够我们开发一般规模的 web 应用了；但在企业中往往有着复杂的应用调用关系，应用与应用之间的请求也需要进行管理。&lt;br&gt;比如常见的限流、降级、trace、监控、负载均衡等功能。&lt;/p&gt;
&lt;p&gt;在我们使用 &lt;code&gt;kubernetes&lt;/code&gt; 之前往往都是由微服务框架来解决这些问题，比如 Dubbo、SpringCloud 都有对应的功能。&lt;/p&gt;
&lt;p&gt;但当我们上了 &lt;code&gt;kubernetes&lt;/code&gt; 之后这些事情就应该交给一个专门的云原生组件来解决，也就是本次会讲到的 &lt;code&gt;Istio&lt;/code&gt;，它是目前使用最为广泛的服务网格解决方案。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/k8s/"/>
    
    
    <category term="Istio" scheme="http://crossoverjie.top/tags/Istio/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读周刊第三期</title>
    <link href="http://crossoverjie.top/2023/10/27/ob/newsletter/Newsletter03-20231027/"/>
    <id>http://crossoverjie.top/2023/10/27/ob/newsletter/Newsletter03-20231027/</id>
    <published>2023-10-27T09:28:25.000Z</published>
    <updated>2023-11-02T10:05:09.441Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/27/pLbBGguZfWicwUj.png"></p><p><strong>技术阅读周刊，每周更新。</strong></p><h2 id="历史更新"><a href="#历史更新" class="headerlink" title="历史更新"></a>历史更新</h2><ul><li><a href="https://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/">20231013：第一期</a></li><li><a href="https://crossoverjie.top/2023/10/22/ob/newsletter/Newsletter02-20231022/">20231022：第二期</a><span id="more"></span></li></ul><h2 id="Understanding-The-Linux-TTY-Subsystem"><a href="#Understanding-The-Linux-TTY-Subsystem" class="headerlink" title="Understanding The Linux TTY Subsystem"></a>Understanding The Linux TTY Subsystem</h2><p>URL: <a href="https://ishuah.com/2021/02/04/understanding-the-linux-tty-subsystem/">https://ishuah.com/2021/02/04/understanding-the-linux-tty-subsystem/</a><br><img src="https://s2.loli.net/2023/10/25/bnzXueWDiyfLdc4.png"><br>本文讲解了 Linux TTY 的历史故事和来源。</p><ol><li>TTY 是 teletype 的简写，电传打印机；最早是在二次世界大战发挥重要作用。</li><li>60 年代的计算机使用了teletype 作为输入终端。</li><li>后续随着技术进步使用了软件模拟替代了物理的电传打印机。</li><li>TTY 早起位于 Linux 的内核空间，导致缺乏灵活性，后续移动到了用户空间。</li><li>之后又出现了 shell，用户使用 shell 登录系统时会分配一个 TTY 给 shell镜像操作。</li><li>TTY 作为 shell 的硬件运行环境，搭配在一起提供了基础的 Linux 操作环境。</li></ol><h2 id="100行代码实现一个模拟终端"><a href="#100行代码实现一个模拟终端" class="headerlink" title="100行代码实现一个模拟终端"></a>100行代码实现一个模拟终端</h2><p>URL: <a href="https://ishuah.com/2021/03/10/build-a-terminal-emulator-in-100-lines-of-go/">https://ishuah.com/2021/03/10/build-a-terminal-emulator-in-100-lines-of-go/</a><br>本文在之前介绍 TTY 背景知识的前提下，讲解使用 100 行代码实现一个模拟终端的 App。<br>最终使用效果如下：<br><img src="https://s2.loli.net/2023/10/27/dUYHwo1nufDgli7.png"></p><ol><li>第一步使用了  Go  的一个 GUI 库 <code>fyne</code> 渲染了一个普通文本框</li><li>讲解了一个终端和内核通讯的流程图<br><img src="https://s2.loli.net/2023/10/27/DP8qJwjEBIcyMFQ.png" alt="image.png"></li><li>PTY master 获取用户输入发送给 PTY slaver，slave 会执行最终的 shell，并将执行结果返回到 PTY master</li><li>这里使用了  Go  的一个第三方库实现了 PTY 的功能<br><img src="https://s2.loli.net/2023/10/27/1LmBXSg6hlNGDkq.png" alt="image.png"></li><li>使用 <code>fyne</code> 获取键盘事件，缓存用户输入的内容，直到检测到输入了回车键，此时将缓存内容发往 pty</li><li>优化响应结果，目前只能输出最新的一行内容，所以新增一个缓冲区存放历史输出。<br><img src="https://s2.loli.net/2023/10/27/9fhpFxztEAXjdun.png" alt="image.png"><br>最终一个简单的模拟终端便实现了，当然功能还很简单，感兴趣的朋友可以在这基础上持续优化。</li></ol><h2 id="混沌工程"><a href="#混沌工程" class="headerlink" title="混沌工程"></a>混沌工程</h2><blockquote><p>最近在复现一个可能的网络问题的时候，接触到了混沌工程，以下是我对它的一些理解</p></blockquote><p>混沌工程（Chaos-Mesh）是一个开源的混沌平台，<code>混沌</code>这词可能不好理解，不过通过他所提供的功能就知道具体是干什么的了。</p><p>核心功能是提供了一些列的故障注入，比如：</p><ul><li>Pod 故障：重启、OOM等</li><li>网络故障：延迟、丢包、断网</li><li>DNS 故障</li><li>HTTP 故障</li><li>甚至还能模拟 JVM 故障<br><img src="https://s2.loli.net/2023/10/27/JcxZdUfARIPDXWh.png" alt="image.png"></li></ul><blockquote><p>这是对一个 Pod 的 http 请求 80 端口进行中断的配置。</p></blockquote><p>通过这些功能可以看出它是一个模拟故障平台，我们可以在它的管理台进行丰富的故障模拟，可以在开发测试过程中增强我们系统的健壮性。</p><h2 id="Hacking-Your-iTerm-Boost-your-command-line-productivity-by…-by-Chandan-Kumar-Better-Programming"><a href="#Hacking-Your-iTerm-Boost-your-command-line-productivity-by…-by-Chandan-Kumar-Better-Programming" class="headerlink" title="Hacking Your iTerm. Boost your command line productivity by… | by Chandan Kumar | Better Programming"></a>Hacking Your iTerm. Boost your command line productivity by… | by Chandan Kumar | Better Programming</h2><p>URL: <a href="https://betterprogramming.pub/hacking-your-iterm-5d2bdacdaccf">https://betterprogramming.pub/hacking-your-iterm-5d2bdacdaccf</a></p><blockquote><p>作者分享了它使用终端的一些技巧和工具</p></blockquote><h3 id="iTerm"><a href="#iTerm" class="headerlink" title="iTerm"></a>iTerm</h3><p>推荐使用 <code>iTerm</code> 这个就不多说了</p><h3 id="powerlevel10k"><a href="#powerlevel10k" class="headerlink" title="powerlevel10k"></a>powerlevel10k</h3><p><img src="https://s2.loli.net/2023/10/27/4OKyMHjQwRBT9Ui.png" alt="image.png"></p><p> powerlevel10k 是一个 zsh 主题，提供了许多自定义的选项，可以按照自己的习惯定制。<br><a href="https://github.com/romkatv/powerlevel10k">https://github.com/romkatv/powerlevel10k</a></p><h3 id="Syntax-highlighting"><a href="#Syntax-highlighting" class="headerlink" title="Syntax highlighting"></a>Syntax highlighting</h3><p><img src="https://s2.loli.net/2023/10/27/4rzmkBG3OD1LvXP.png" alt="image.png"><br>语法高亮可以让自己知道输入是否正确<br><a href="https://github.com/zsh-users/zsh-syntax-highlighting">https://github.com/zsh-users/zsh-syntax-highlighting</a></p><h3 id="Auto-suggestion"><a href="#Auto-suggestion" class="headerlink" title="Auto-suggestion"></a>Auto-suggestion</h3><p>自动提示插件，可以类似于 IDE 的方式使用命令行，这个还蛮好用的。<br><img src="https://miro.medium.com/v2/resize:fit:4800/0*HbzHqgfrcPT7VvUE.gif"><br><a href="https://github.com/zsh-users/zsh-autosuggestions">https://github.com/zsh-users/zsh-autosuggestions</a></p><h3 id="Autojump"><a href="#Autojump" class="headerlink" title="Autojump"></a>Autojump</h3><p><img src="https://s2.loli.net/2023/10/27/TKcgMWXSmBiD2kj.png" alt="image.png"><br>自动跳转，可以更快的跳转到我们尝使用的目录，提高效率。<br><a href="https://github.com/wting/autojump">https://github.com/wting/autojump</a></p><h3 id="iTerm-的一些窗口导航快捷键"><a href="#iTerm-的一些窗口导航快捷键" class="headerlink" title="iTerm 的一些窗口导航快捷键"></a>iTerm 的一些窗口导航快捷键</h3><ul><li>新窗口 — <code>⌘</code> + <code>T</code></li><li>关闭窗口 — <code>⌘</code> + <code>W</code> </li><li>切换 Tab<code>⌘</code> + <code>Number Key</code> — ( <code>⌘2</code> 切换到第二个 Tab)</li><li>垂直分割窗口 (same profile) — <code>⌘</code> + <code>D</code></li><li>水平分割窗口(same profile) — <code>⌘</code> + <code>Shift</code> + <code>D</code> </li><li>根据顺序切换窗口 — <code>⌘</code> + <code>]</code> , <code>⌘</code> + <code>[</code></li><li>上一个 tab<code>⌘</code>+ <code>&lt;-</code> — </li><li>下一个窗口<code>⌘</code>+ <code>-&gt;</code></li><li>最大化窗口<code>⌘</code> + <code>Shift</code> + <code>Enter</code></li></ul><h2 id="当我们聊-Kubernetes-Operator-时，我们在聊些什么-云原生-徐新坤-InfoQ精选文章"><a href="#当我们聊-Kubernetes-Operator-时，我们在聊些什么-云原生-徐新坤-InfoQ精选文章" class="headerlink" title="当我们聊 Kubernetes Operator 时，我们在聊些什么_云原生_徐新坤_InfoQ精选文章"></a>当我们聊 Kubernetes Operator 时，我们在聊些什么_云原生_徐新坤_InfoQ精选文章</h2><p>URL: <a href="https://www.infoq.cn/article/SJMUvMg_0H7BS5d99euR">https://www.infoq.cn/article/SJMUvMg_0H7BS5d99euR</a></p><blockquote><p>作者讲解了 Docker、Helm、Operator、kubernetes Controller 之间的关系以及一些核心概念。</p></blockquote><ol><li>Docker的核心价值是提供了标准化的交付流程，现在几乎没人再交付源码了</li><li>Operator 和 Docker 类似的是标准化了分布式系统的交付流程。</li><li>Helm 也可以做分布式系统交付，但他更侧重于协调多个资源管理，比如可以让 A Pod 启动之后再启动 B Pod。</li><li>但 Helm 无法感知整个系统的运行时状态，而 <code>Operator</code> 则可以，通过这个感知可以自动实现扩容、故障恢复、异常处理等工作，在实现了 Helm 的自动化的同时还实现了智能化。</li><li><code>Operator</code> 是处于一个第三方视角观察整个系统，所以它可以拿到全局的信息，从而最终达到声明状态的一个目的。</li><li><code>Operator</code> 可以当做另一种 <code>Controller</code>，可以理解为第三方的 <code>controller</code>，一般是运维我们自己的应用。</li><li><code>Operator</code> 可以将以往运维的经验沉淀为代码，更利于推进 Dev、Ops 合并为 <code>DevOps</code>。</li></ol><p>文章链接：</p><ul><li><a href="https://ishuah.com/2021/02/04/understanding-the-linux-tty-subsystem/">https://ishuah.com/2021/02/04/understanding-the-linux-tty-subsystem/</a></li><li><a href="https://ishuah.com/2021/03/10/build-a-terminal-emulator-in-100-lines-of-go/">https://ishuah.com/2021/03/10/build-a-terminal-emulator-in-100-lines-of-go/</a></li><li><a href="https://chaos-mesh.org/zh/docs/">https://chaos-mesh.org/zh/docs/</a></li><li><a href="https://betterprogramming.pub/hacking-your-iterm-5d2bdacdaccf">https://betterprogramming.pub/hacking-your-iterm-5d2bdacdaccf</a></li><li><a href="https://www.infoq.cn/article/SJMUvMg_0H7BS5d99euR">https://www.infoq.cn/article/SJMUvMg_0H7BS5d99euR</a></li></ul><p>#Newletters </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/27/pLbBGguZfWicwUj.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术阅读周刊，每周更新。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;历史更新&quot;&gt;&lt;a href=&quot;#历史更新&quot; class=&quot;headerlink&quot; title=&quot;历史更新&quot;&gt;&lt;/a&gt;历史更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/&quot;&gt;20231013：第一期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/10/22/ob/newsletter/Newsletter02-20231022/&quot;&gt;20231022：第二期&lt;/a&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Newsletter" scheme="http://crossoverjie.top/categories/OB/Newsletter/"/>
    
    
  </entry>
  
  <entry>
    <title>技术阅读周刊第二期</title>
    <link href="http://crossoverjie.top/2023/10/22/ob/newsletter/Newsletter02-20231022/"/>
    <id>http://crossoverjie.top/2023/10/22/ob/newsletter/Newsletter02-20231022/</id>
    <published>2023-10-22T08:22:13.000Z</published>
    <updated>2023-10-22T11:21:47.713Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/22/1nblhKQu6o4HMjk.png" alt="image.png"></p><p><strong>技术阅读周刊，每周更新。</strong></p><h2 id="历史更新"><a href="#历史更新" class="headerlink" title="历史更新"></a>历史更新</h2><ul><li><a href="https://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/">20231013：第一期</a></li></ul><span id="more"></span><h2 id="Google-Software-Engineer-Interview-Experience-—-Offer🌟🌟🌟"><a href="#Google-Software-Engineer-Interview-Experience-—-Offer🌟🌟🌟" class="headerlink" title="Google Software Engineer Interview Experience — Offer🌟🌟🌟"></a>Google Software Engineer Interview Experience — Offer🌟🌟🌟</h2><blockquote><p>谷歌软件工程师的面试经验。</p></blockquote><p>作者背景：2020 年毕业于 MIT Pune（印度城市），将近 3年的开发经验<br>在这次拿到 Google offer 之前参与过3～4 次 Google 面试，上一次是2019 年。<br>因为有之前的面试经验，所以直接跳过了电话面试，直接准备现场面试。</p><p>作者花了三周时间做准备。</p><h3 id="1st-Leetcode-Medium-Coding-45min"><a href="#1st-Leetcode-Medium-Coding-45min" class="headerlink" title="1st Leetcode Medium Coding(45min)"></a>1st Leetcode Medium Coding(45min)</h3><p>主题：</p><ul><li>深度优先查询</li><li>广度优先查询</li><li>哈希表相关。<br>与面试官交流作者的方法，最终顺利过了第一轮。</li></ul><h3 id="2nd-Leetcode-Medium-Coding-45min"><a href="#2nd-Leetcode-Medium-Coding-45min" class="headerlink" title="2nd Leetcode Medium Coding(45min)"></a>2nd Leetcode Medium Coding(45min)</h3><p>主题：</p><ul><li>滑动窗口</li><li>哈希表</li><li>字符串<br>作者刚开始用了一个暴力解法，经过思考后得出一个最优解。<br>其他的问题都得出了正确的时间复杂度。</li></ul><h3 id="3rd-Leetcode-Hard-Coding-45min"><a href="#3rd-Leetcode-Hard-Coding-45min" class="headerlink" title="3rd Leetcode Hard Coding(45min)"></a>3rd Leetcode Hard Coding(45min)</h3><p>主题：</p><ul><li>广度优先查询</li><li>堆排序（优先级队列）</li><li>矩阵</li><li>数组<br>这轮面试比较有难度，在面试官的提醒下完成了。</li></ul><h3 id="4th-谷歌味面试，领导轮"><a href="#4th-谷歌味面试，领导轮" class="headerlink" title="4th 谷歌味面试，领导轮"></a>4th 谷歌味面试，领导轮</h3><p>这一轮就是一些行为面试，讨论了一些过去的经历，和假设的一些情况。<br>作者使用了 STAR(Situation, Task, Action, Result) 进行了回答，整个过程比较顺利。</p><p>评论区：</p><ul><li>希望可以分享下自己准备的资料</li><li>没有系统设计题吗？</li></ul><blockquote><p>看来国际一线大厂对算法的考察占比也是非常高的，但作者可能也有一些考虑没有放出面试的具体题目。</p></blockquote><h2 id="From-JetBrains-to-Vim-A-modern-Vim-configuration-and-plugin-set-by-devsjc-Sep-2023-Medium🌟🌟🌟🌟"><a href="#From-JetBrains-to-Vim-A-modern-Vim-configuration-and-plugin-set-by-devsjc-Sep-2023-Medium🌟🌟🌟🌟" class="headerlink" title="From JetBrains to Vim: A modern Vim configuration and plugin set | by devsjc | Sep, 2023 | Medium🌟🌟🌟🌟"></a>From JetBrains to Vim: A modern Vim configuration and plugin set | by devsjc | Sep, 2023 | Medium🌟🌟🌟🌟</h2><p>作者从 JetBrains 切换到 Vim，在 Vim 中主要使用到的插件。<br><img src="https://s2.loli.net/2023/10/20/GsWbix7aUzlMQ6t.png" alt="image.png"><br>作者是由于 Vim 作者的离世才决定花时间研究下 Vim，以下是他常用的一些插件：</p><h3 id="Plugin-kristijanhusak-x2F-vim-packager"><a href="#Plugin-kristijanhusak-x2F-vim-packager" class="headerlink" title="Plugin: kristijanhusak&#x2F;vim-packager"></a>Plugin: <a href="https://github.com/kristijanhusak/vim-packager"><strong>kristijanhusak&#x2F;vim-packager</strong></a></h3><p><img src="https://s2.loli.net/2023/10/20/DsRxePkVrEMUtio.png" alt="image.png"><br>从名字可以看出这是一个包管理插件。</p><h3 id="Plugin-junegunn-x2F-fzf-vim"><a href="#Plugin-junegunn-x2F-fzf-vim" class="headerlink" title="Plugin: junegunn&#x2F;fzf.vim"></a>Plugin: <a href="https://github.com/junegunn/fzf.vim"><strong>junegunn&#x2F;fzf.vim</strong></a></h3><p><img src="https://s2.loli.net/2023/10/20/CzrZPsWBORpEiHn.png" alt="image.png"><br>模糊搜索插件。</p><h3 id="Plugin-yegappan-x2F-lsp"><a href="#Plugin-yegappan-x2F-lsp" class="headerlink" title="Plugin: yegappan&#x2F;lsp"></a>Plugin: <a href="https://github.com/yegappan/lsp"><strong>yegappan&#x2F;lsp</strong></a></h3><p><img src="https://s2.loli.net/2023/10/20/fPC9sqQNbXjcuwY.png" alt="image.png"></p><p>这个插件功能强大：</p><ul><li>自动补全</li><li>变量声明跳转</li><li>重命名变量<blockquote><p>其实就是我们常见 IDE 一些基本功能</p></blockquote></li></ul><h3 id="Plugin-dense-analysis-x2F-ale"><a href="#Plugin-dense-analysis-x2F-ale" class="headerlink" title="Plugin: dense-analysis&#x2F;ale"></a>Plugin: <a href="https://github.com/dense-analysis/ale"><strong>dense-analysis&#x2F;ale</strong></a></h3><p><img src="https://s2.loli.net/2023/10/20/cdJfVMWm8vA2wqO.png" alt="image.png"><br>错误提示插件，可以高亮并修复错误。</p><h3 id="Plugin-907th-x2F-vim-auto-save"><a href="#Plugin-907th-x2F-vim-auto-save" class="headerlink" title="Plugin: 907th&#x2F;vim-auto-save"></a>Plugin: <a href="https://github.com/907th/vim-auto-save"><strong>907th&#x2F;vim-auto-save</strong></a></h3><p>自动保存插件，作者从 IDE 切换到 Vim 后不能自动保存，这个插件可以弥补这个缺失。</p><h3 id="Plugin-jiangmiao-x2F-auto-pairs"><a href="#Plugin-jiangmiao-x2F-auto-pairs" class="headerlink" title="Plugin: jiangmiao&#x2F;auto-pairs"></a>Plugin: <a href="https://github.com/jiangmiao/auto-pairs"><strong>jiangmiao&#x2F;auto-pairs</strong></a></h3><p>自动添加、删除成对的括号，引号等符号。</p><h3 id="Plugin-airblade-x2F-vim-gitgutter"><a href="#Plugin-airblade-x2F-vim-gitgutter" class="headerlink" title="Plugin: airblade&#x2F;vim-gitgutter"></a>Plugin: <a href="https://github.com/airblade/vim-gitgutter"><strong>airblade&#x2F;vim-gitgutter</strong></a></h3><p>用于显示 git 面板的插件，比较提交记录、对比等。</p><h3 id="Plugin-bluz71-x2F-vim-mistfly-statusline"><a href="#Plugin-bluz71-x2F-vim-mistfly-statusline" class="headerlink" title="Plugin: bluz71&#x2F;vim-mistfly-statusline"></a>Plugin: <a href="https://github.com/bluz71/vim-mistfly-statusline"><strong>bluz71&#x2F;vim-mistfly-statusline</strong></a></h3><p><img src="https://s2.loli.net/2023/10/20/qX2cEQ3rDCu5sZP.png" alt="image.png"><br>用于显示一些状态，比如 vim 模式、git 等。</p><p>可以发现大部分的插件功能 IDE 都是自带的，而作者之所以选择 Vim 也是因为他更加的轻量，相对于 <code>Jetbrains</code> 家的 IDE 来说。</p><h2 id="Building-your-brand-How-I-reached-10k-subscribers-in-6-months"><a href="#Building-your-brand-How-I-reached-10k-subscribers-in-6-months" class="headerlink" title="Building your brand: How I reached 10k subscribers in 6 months"></a>Building your brand: How I reached 10k subscribers in 6 months</h2><blockquote><p>作者讲述了他用了半年时间做的 newsletter 个人品牌获得了 1w个订阅的经历：</p></blockquote><p><img src="https://s2.loli.net/2023/10/22/CaZWOu6iMrxb8PE.png" alt="image.png"></p><p>1. 做这个过程中收获了两个好处，如果你想掌握某样技能，那教会别人是最快的，也就是做分享</p><p>2. 可以和有许多不同观点的人交流，获得不同的收获</p><p>3. 和许多人保持了连接，获得赞助、面试机会</p><p>4. 公开学习：公开分享你学到的和你直到的东西。</p><p>5. 长期坚持合适你的方法去学习沉淀一件事情</p><h2 id="How-companies-Ship-code-to-Production🌟🌟🌟"><a href="#How-companies-Ship-code-to-Production🌟🌟🌟" class="headerlink" title="How companies Ship code to Production🌟🌟🌟"></a>How companies Ship code to Production🌟🌟🌟</h2><p><img src="https://s2.loli.net/2023/10/22/vonCAaQWdqgS6HU.png" alt="image.png"></p><blockquote><p>企业如何代码交付到生产环境:</p></blockquote><p>1. 产品负责人创建需求</p><p>2. 和研发人员讨论需求</p><p>3. 开发需求</p><p>4. 构建打包，需要通过单元测试、覆盖率、Sonar 扫描等流程</p><p>5. 构建成功后发布到开发环境</p><p>6. 可能会有多个团队在开发不同的分支，所以需要将代码部署到 QA1、QA2</p><p>7. 测试团队会到一个单独的测试环境执行回归测试和性能测试</p><p>8. 测试通过后会部署到 UAT 环境</p><p>9. UAT 测试通过后，将会按照发布计划发布到生产环境</p><p>10. SRE 团队负责对生产环境进行运维和监控</p><blockquote><p>在国内这算是一个中大型团队的交付流程了，需要小型团队可能并不会有单测、代码扫描、多个测试环境、SRE 等流程。</p></blockquote><h2 id="Understanding-Database-Types🌟🌟🌟"><a href="#Understanding-Database-Types🌟🌟🌟" class="headerlink" title="Understanding Database Types🌟🌟🌟"></a>Understanding Database Types🌟🌟🌟</h2><p>介绍了目前流行的数据库类型：<br><img src="https://s2.loli.net/2023/10/22/lQJDZ9KAIeNuqiW.png" alt="image.png"></p><ul><li>关系型数据库<ul><li>MySQL</li><li>Oracle</li><li>SQL Server</li><li>PG</li></ul></li><li>时序数据库<ul><li>InfluxDB</li><li>TimeScale DB</li><li>Graphite</li><li>Prometheus</li></ul></li><li>NoSQL 数据库<ul><li>MongoDB</li><li>Cassandra</li><li>Redis</li><li>Couchbase<br><img src="https://s2.loli.net/2023/10/22/6vgpl1Y9G8EqsF2.png" alt="image.png"></li></ul></li></ul><blockquote><p>是一篇科普文章，但因为是一个付费订阅的 Newsletter 我也就没有看过，对这些数据库类型的整理还是比较完善的。</p></blockquote><p>文章链接：</p><ul><li><a href="https://medium.com/@lahotipranali/google-software-engineer-interview-experience-offer-25e4eb6a0a5c">https://medium.com/@lahotipranali/google-software-engineer-interview-experience-offer-25e4eb6a0a5c</a></li><li><a href="https://medium.com/@devsjc/from-jetbrains-to-vim-a-modern-vim-configuration-and-plugin-set-d58472a7d53d">https://medium.com/@devsjc/from-jetbrains-to-vim-a-modern-vim-configuration-and-plugin-set-d58472a7d53d</a></li><li><a href="https://careercutler.substack.com/p/building-your-brand-how-i-reached">https://careercutler.substack.com/p/building-your-brand-how-i-reached</a></li><li><a href="https://blog.bytebytego.com/p/ep81-how-companies-ship-code-to-production?utm_source=post-email-title&amp;publication_id=817132&amp;post_id=137944253&amp;utm_campaign=email-post-title&amp;isFreemail=true&amp;r=4buvd&amp;utm_medium=email">https://blog.bytebytego.com/p/ep81-how-companies-ship-code-to-production?utm_source=post-email-title&amp;publication_id=817132&amp;post_id=137944253&amp;utm_campaign=email-post-title&amp;isFreemail=true&amp;r=4buvd&amp;utm_medium=email</a></li><li><a href="https://blog.bytebytego.com/p/understanding-database-types">https://blog.bytebytego.com/p/understanding-database-types</a></li></ul><p>#Newletters </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/22/1nblhKQu6o4HMjk.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术阅读周刊，每周更新。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;历史更新&quot;&gt;&lt;a href=&quot;#历史更新&quot; class=&quot;headerlink&quot; title=&quot;历史更新&quot;&gt;&lt;/a&gt;历史更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/&quot;&gt;20231013：第一期&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Newsletter" scheme="http://crossoverjie.top/categories/OB/Newsletter/"/>
    
    
    <category term="Tech" scheme="http://crossoverjie.top/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅重启 kubernetes 的 Pod</title>
    <link href="http://crossoverjie.top/2023/10/19/ob/k8s-restart-pod/"/>
    <id>http://crossoverjie.top/2023/10/19/ob/k8s-restart-pod/</id>
    <published>2023-10-19T02:58:44.000Z</published>
    <updated>2023-10-19T10:34:44.918Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/19/IW8kEDatFlMhz1O.png" alt="restart pod.png"></p><p>最近在升级服务网格 Istio，升级后有个必要的流程就是需要重启数据面的所有的 Pod，也就是业务的 Pod，这样才能将这些 Pod 的 sidecar 更新为新版本。</p><span id="more"></span><h1 id="方案-1"><a href="#方案-1" class="headerlink" title="方案 1"></a>方案 1</h1><p>因为我们不同环境的 Pod 数不少，不可能手动一个个重启；之前也做过类似的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete --all pods --namespace=dev</span><br></pre></td></tr></table></figure><p>这样可以一键将 dev 这个命名空间下的 Pod 删掉，kubernetes 之后会自动将这些 Pod 重启，保证和应用的可用性。</p><p>但这有个大问题是对 <code>kubernetes</code> 的调度压力较大，一般一个 <code>namespace</code> 下少说也是几百个 Pod，全部需要重新调度启动对 <code>kubernetes</code> 的负载会很高，稍有不慎就会有严重的后果。</p><p>所以当时我的第一版方案是遍历所有的  deployment，删除一个 Pod 后休眠 5 分钟再删下一个，伪代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">deployments, err := clientSet.AppsV1().Deployments(ns).List(ctx, metav1.ListOptions&#123;&#125;)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> err  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, deployment := <span class="keyword">range</span> deployments.Items &#123;</span><br><span class="line">podList, err := clientSet.CoreV1().Pods(ns).List(ctx, metav1.ListOptions&#123;  </span><br><span class="line">    LabelSelector: fmt.Sprintf(<span class="string">&quot;app=%s&quot;</span>, deployment.Name),  </span><br><span class="line">&#125;)</span><br><span class="line">err = clientSet.CoreV1().Pods(pod.Namespace).Delete(ctx, pod.Name, metav1.DeleteOptions&#123;&#125;)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> err  </span><br><span class="line">&#125;  </span><br><span class="line">log.Printf(<span class="string">&quot;    Pod %s rebuild success.\n&quot;</span>, pod.Name)</span><br><span class="line">time.Sleep(time.Minute * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>这个方案确实是简单粗暴，但在测试的时候就发现了问题。</p><p>当某些业务只有一个 Pod 的时候，直接删掉之后这个业务就挂了，没有多余的副本可以提供服务了。</p><p><strong>这肯定是不能接受的。</strong></p><p>甚至还有删除之后没有重启成功的：</p><ul><li>长期没有重启导致镜像缓存没有了，甚至镜像已经被删除了，这种根本就没法启动成功。</li><li>也有一些 Pod 有 <code>Init-Container</code> 会在启动的时候做一些事情，如果失败了也是没法启动成功的。<br>总之就是有多种情况导致一个 Pod 无法正常启动，这在线上就会直接导致生产问题，所以方案一肯定是不能用的。</li></ul><h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>为此我就准备了方案二：</p><p><img src="https://s2.loli.net/2023/10/19/reKiba4XtWSnP6z.png" alt="image.png"></p><ul><li>先将副本数+1，这是会新增一个 Pod，也会使用最新的 sidecar 镜像。</li><li>等待新建的 Pod 重启成功。</li><li>重启成功后删除原有的 Pod。</li><li>再将副本数还原为之前的数量。</li></ul><p>这样可以将原有的 Pod 平滑的重启，同时如果新的 Pod 启动失败也不会继续重启其他 <code>Deployment</code> 的 Pod，老的 Pod 也是一直保留的，对服务本身没有任何影响。</p><h2 id="存在的问题-1"><a href="#存在的问题-1" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>看起来是没有什么问题的，就是实现起来比较麻烦，流程很繁琐，这里我贴了部分核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RebuildDeploymentV2</span><span class="params">(ctx context.Context, clientSet kubernetes.Interface, ns <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">deployments, err := clientSet.AppsV1().Deployments(ns).List(ctx, metav1.ListOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, deployment := <span class="keyword">range</span> deployments.Items &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print each Deployment</span></span><br><span class="line">log.Printf(<span class="string">&quot;Ready deployment: %s\n&quot;</span>, deployment.Name)</span><br><span class="line"></span><br><span class="line">originPodList, err := clientSet.CoreV1().Pods(ns).List(ctx, metav1.ListOptions&#123;</span><br><span class="line">LabelSelector: fmt.Sprintf(<span class="string">&quot;app=%s&quot;</span>, deployment.Name),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if there are any Pods</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(originPodList.Items) == <span class="number">0</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;No pod in %s\n&quot;</span>, deployment.Name)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Skip Pods that have already been upgraded</span></span><br><span class="line">updateSkip := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, container := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line"><span class="keyword">if</span> container.Name == <span class="string">&quot;istio-proxy&quot;</span> &amp;&amp; container.Image == <span class="string">&quot;proxyv2:1.x.x&quot;</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;  Pod: %s Container: %s has already upgrade, skip\n&quot;</span>, pod.Name, container.Name)</span><br><span class="line">updateSkip = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> updateSkip &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scale the Deployment, create a new pod.</span></span><br><span class="line">scale, err := clientSet.AppsV1().Deployments(ns).GetScale(ctx, deployment.Name, metav1.GetOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">scale.Spec.Replicas = scale.Spec.Replicas + <span class="number">1</span></span><br><span class="line">_, err = clientSet.AppsV1().Deployments(ns).UpdateScale(ctx, deployment.Name, scale, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for pods to be scaled</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">podList, err := clientSet.CoreV1().Pods(ns).List(ctx, metav1.ListOptions&#123;</span><br><span class="line">LabelSelector: fmt.Sprintf(<span class="string">&quot;app=%s&quot;</span>, deployment.Name),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(podList.Items) != <span class="type">int</span>(scale.Spec.Replicas) &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for pods to be running</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">podList, err := clientSet.CoreV1().Pods(ns).List(ctx, metav1.ListOptions&#123;</span><br><span class="line">LabelSelector: fmt.Sprintf(<span class="string">&quot;app=%s&quot;</span>, deployment.Name),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">isPending := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> podList.Items &#123;</span><br><span class="line"><span class="keyword">if</span> item.Status.Phase != v1.PodRunning &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Deployment: %s Pod: %s Not Running Status: %s\n&quot;</span>, deployment.Name, item.Name, item.Status.Phase)</span><br><span class="line">isPending = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> isPending == <span class="literal">true</span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove origin pod</span></span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> originPodList.Items &#123;</span><br><span class="line">err = clientSet.CoreV1().Pods(ns).Delete(context.Background(), pod.Name, metav1.DeleteOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Remove origin %s success.\n&quot;</span>, pod.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recover scale</span></span><br><span class="line">newScale, err := clientSet.AppsV1().Deployments(ns).GetScale(ctx, deployment.Name, metav1.GetOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">newScale.Spec.Replicas = newScale.Spec.Replicas - <span class="number">1</span></span><br><span class="line">newScale.ResourceVersion = <span class="string">&quot;&quot;</span></span><br><span class="line">newScale.UID = <span class="string">&quot;&quot;</span></span><br><span class="line">_, err = clientSet.AppsV1().Deployments(ns).UpdateScale(ctx, deployment.Name, newScale, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Depoloyment %s rebuild success.\n&quot;</span>, deployment.Name)</span><br><span class="line">log.Println()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看的出来代码是比较多的。</p><h1 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h1><p>有没有更简单的方法呢，当我把上述的方案和领导沟通后他人都傻了，这也太复杂了：<code>kubectl</code> 不是有一个直接滚动重启的命令吗。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">❯ k rollout -h</span><br><span class="line">Manage the rollout of one or many resources.</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  <span class="built_in">history</span>       View rollout <span class="built_in">history</span></span><br><span class="line">  pause         Mark the provided resource as paused</span><br><span class="line">  restart       Restart a resource</span><br><span class="line">  resume        Resume a paused resource</span><br><span class="line">  status        Show the status of the rollout</span><br><span class="line">  undo          Undo a previous rollout</span><br></pre></td></tr></table></figure><p><code>kubectl rollout restart deployment/abc</code><br>使用这个命令可以将 <code>abc</code> 这个 <code>deployment</code> 进行滚动更新，这个更新操作发生在  kubernetes 的服务端，执行的步骤和方案二差不多，只是 kubernetes 实现的比我的更加严谨。</p><p>后来我在查看 <code>Istio</code> 的官方升级指南中也是提到了这个命令：<br><img src="https://s2.loli.net/2023/10/19/IjckD8GK2pzXfyn.png" alt="image.png"></p><blockquote><p>所以还是得好好看官方文档</p></blockquote><h2 id="整合-kubectl"><a href="#整合-kubectl" class="headerlink" title="整合 kubectl"></a>整合 kubectl</h2><p>既然有现成的了，那就将这个命令整合到我的脚本里即可，再遍历 namespace 下的 deployment 的时候循环调用就可以了。</p><p>但这个 <code>rollout</code> 命令在 <code>kubernetes</code> 的 <code>client-go</code> 的 <code>SDK</code> 中是没有这个 API 的。</p><p>所以我只有参考 kubectl 的源码，将这部分功能复制过来；不过好在可以直接依赖 kubect 到我的项目里。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">require (  </span><br><span class="line">    k8s.io/api v0<span class="number">.28</span><span class="number">.2</span>  </span><br><span class="line">    k8s.io/apimachinery v0<span class="number">.28</span><span class="number">.2</span>  </span><br><span class="line">    k8s.io/cli-runtime v0<span class="number">.28</span><span class="number">.2</span>  </span><br><span class="line">    k8s.io/client-<span class="keyword">go</span> v0<span class="number">.28</span><span class="number">.2</span>  </span><br><span class="line">    k8s.io/klog/v2 v2<span class="number">.100</span><span class="number">.1</span>  </span><br><span class="line">    k8s.io/kubectl v0<span class="number">.28</span><span class="number">.2</span>  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/10/19/7beuKWadX8M9y5c.png" alt="image.png"></p><p>源码里使用到的 <code>RestartOptions</code> 结构体是公共访问的，所以我就参考它源码魔改了一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRollOutRestart</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">    kubeConfigFlags := defaultConfigFlags()  </span><br><span class="line">    streams, _, _, _ := genericiooptions.NewTestIOStreams()  </span><br><span class="line">    ns := <span class="string">&quot;dev&quot;</span>  </span><br><span class="line">    kubeConfigFlags.Namespace = &amp;ns  </span><br><span class="line">    matchVersionKubeConfigFlags := cmdutil.NewMatchVersionFlags(kubeConfigFlags)  </span><br><span class="line">    f := cmdutil.NewFactory(matchVersionKubeConfigFlags)  </span><br><span class="line">    deploymentName := <span class="string">&quot;deployment/abc&quot;</span>  </span><br><span class="line">    r := &amp;rollout.RestartOptions&#123;  </span><br><span class="line">       PrintFlags: genericclioptions.NewPrintFlags(<span class="string">&quot;restarted&quot;</span>).WithTypeSetter(scheme.Scheme),  </span><br><span class="line">       Resources:  []<span class="type">string</span>&#123;deploymentName&#125;,  </span><br><span class="line">       IOStreams:  streams,  </span><br><span class="line">    &#125;  </span><br><span class="line">    err := r.Complete(f, <span class="literal">nil</span>, []<span class="type">string</span>&#123;deploymentName&#125;)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Fatal(err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    err = r.RunRestart()  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Fatal(err)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终在几次 debug 后终于可以运行了，只需要将这部分逻辑移动到循环里，加上 <code>sleep</code> 便可以有规律的重启 Pod 了。</p><p>参考链接：</p><ul><li><a href="https://istio.io/latest/docs/setup/upgrade/canary/#data-plane">https://istio.io/latest/docs/setup/upgrade/canary/#data-plane</a></li><li><a href="https://github.com/kubernetes/kubectl/blob/master/pkg/cmd/rollout/rollout_restart.go">https://github.com/kubernetes/kubectl/blob/master/pkg/cmd/rollout/rollout_restart.go</a></li></ul><p>#Blog #K8s </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/19/IW8kEDatFlMhz1O.png&quot; alt=&quot;restart pod.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在升级服务网格 Istio，升级后有个必要的流程就是需要重启数据面的所有的 Pod，也就是业务的 Pod，这样才能将这些 Pod 的 sidecar 更新为新版本。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/OB/k8s/"/>
    
    
    <category term="client-go" scheme="http://crossoverjie.top/tags/client-go/"/>
    
  </entry>
  
  <entry>
    <title>在 kubernetes 环境中实现 gRPC 负载均衡</title>
    <link href="http://crossoverjie.top/2023/10/16/ob/k8s-grpc-lb/"/>
    <id>http://crossoverjie.top/2023/10/16/ob/k8s-grpc-lb/</id>
    <published>2023-10-16T07:55:50.000Z</published>
    <updated>2023-10-17T06:01:48.484Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/16/wJiKvMAaWUyOCpX.png" alt="Istio-grpc-lb.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间写过一篇 <code>gRPC</code> 的入门文章，在最后还留了一个坑没有填：<br><img src="https://s2.loli.net/2023/10/16/41I2RZXeQanFgdB.png" alt="image.png"><br>也就是 <code>gRPC</code> 的负载均衡问题，因为当时的业务请求量不算大，再加上公司没有对 Istio 这类服务网格比较熟悉的大牛，所以我们也就一直拖着没有解决，依然只是使用了 kubernetes 的 service 进行负载，好在也没有出什么问题。</p><span id="more"></span><p>由于现在换了公司后也需要维护公司的服务网格服务，结合公司内部对 Istio 的使用现在终于不再停留在理论阶段了。</p><p>所以也终有机会将这个坑填了。</p><h1 id="gRPC-负载均衡"><a href="#gRPC-负载均衡" class="headerlink" title="gRPC 负载均衡"></a>gRPC 负载均衡</h1><h2 id="负载不均衡"><a href="#负载不均衡" class="headerlink" title="负载不均衡"></a>负载不均衡</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>先来回顾下背景，为什么会有 <code>gRPC</code> 负载不均衡的问题。<br>由于 <code>gRPC</code> 是基于 HTTP&#x2F;2 协议的，所以客户端和服务端会保持长链接，一旦链接建立成功后就会一直使用这个连接处理后续的请求。</p><p><img src="https://s2.loli.net/2023/10/16/NxJqPM49vAgEBtX.png" alt="image.png"></p><p>除非我们每次请求之后都新建一个连接，这显然是不合理的。</p><p>所以要解决 <code>gRPC</code> 的负载均衡通常有两种方案：</p><ul><li>服务端负载均衡</li><li>客户端负载均衡<br>在 <code>gRPC</code> 这个场景服务端负载均衡不是很合适，所有的请求都需要经过一个负载均衡器，这样它就成为整个系统的瓶颈，所以更推荐使用客户端负载均衡。</li></ul><p>客户端负载均衡目前也有两种方案，最常见也是传统方案。<br><img src="https://s2.loli.net/2023/10/16/x31gJLImRlfXa9i.png" alt="image.png"><br>这里以 Dubbo 的调用过程为例，调用的时候需要从服务注册中心获取到提供者的节点信息，然后在客户端本地根据一定的负载均衡算法得出一个节点然后发起请求。</p><p>换成 <code>gRPC</code> 也是类似的，这里以 <code>go-zero</code> 负载均衡的原理为例：<br><img src="https://s2.loli.net/2023/10/16/PLnyAKsmDZQRoeh.png" alt="image.png"></p><p>gRPC 官方库也提供了对应的负载均衡接口，但我们依然需要自己维护服务列表然后在客户端编写负载均衡算法，这里有个官方 demo:</p><p><a href="https://github.com/grpc/grpc-go/blob/87eb5b7502493f758e76c4d09430c0049a81a557/examples/features/load_balancing/client/main.go">https://github.com/grpc/grpc-go/blob/87eb5b7502493f758e76c4d09430c0049a81a557/examples/features/load_balancing&#x2F;client&#x2F;main.go</a></p><p>但切换到 kubernetes 环境中时再使用以上的方式就不够优雅了，因为我们使用 kubernetes 的目的就是不想再额外的维护这个客户端包，这部分能力最好是由 kubernetes 自己就能提供。</p><p>但遗憾的是 kubernetes 提供的 service 只是基于 L4 的负载，所以我们每次请求的时候都只能将请求发往同一个 Provider 节点。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这里我写了一个小程序来验证负载不均衡的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create gRPC server</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   <span class="keyword">var</span> port = <span class="string">&quot;:50051&quot;</span>  </span><br><span class="line">   lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)  </span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">      log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)  </span><br><span class="line">   &#125;  </span><br><span class="line">   s := grpc.NewServer()  </span><br><span class="line">   pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)  </span><br><span class="line">   <span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">      log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)  </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      log.Printf(<span class="string">&quot;served on %s \n&quot;</span>, port)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.  </span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;  </span><br><span class="line">   pb.UnimplementedGreeterServer  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// SayHello implements helloworld.GreeterServer  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, <span class="type">error</span>) &#123;  </span><br><span class="line">   log.Printf(<span class="string">&quot;Received: %v&quot;</span>, in.GetName())  </span><br><span class="line">   name, _ := os.Hostname()  </span><br><span class="line">   <span class="comment">// Return hostname of Server</span></span><br><span class="line">   <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: fmt.Sprintf(<span class="string">&quot;hostname:%s, in:%s&quot;</span>, name, in.Name)&#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用同一个 gRPC 连接发起一次 gRPC 请求，服务端会返回它的 <code>hostname</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (  </span><br><span class="line">   once sync.Once  </span><br><span class="line">   c    pb.GreeterClient  </span><br><span class="line">)  </span><br><span class="line">http.HandleFunc(<span class="string">&quot;/grpc_client&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">   once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">      service := r.URL.Query().Get(<span class="string">&quot;name&quot;</span>)  </span><br><span class="line">      conn, err := grpc.Dial(fmt.Sprintf(<span class="string">&quot;%s:50051&quot;</span>, service), grpc.WithInsecure(), grpc.WithBlock())  </span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)  </span><br><span class="line">      &#125;  </span><br><span class="line">      c = pb.NewGreeterClient(conn)  </span><br><span class="line">   &#125;)  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// Contact the server and print out its response.  </span></span><br><span class="line">   name := <span class="string">&quot;world&quot;</span>  </span><br><span class="line">   ctx, cancel := context.WithTimeout(context.Background(), time.Second)  </span><br><span class="line">   <span class="keyword">defer</span> cancel()  </span><br><span class="line">   g, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: name&#125;)  </span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">      log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)  </span><br><span class="line">   &#125;  </span><br><span class="line">   fmt.Fprint(w, fmt.Sprintf(<span class="string">&quot;Greeting: %s&quot;</span>, g.GetMessage()))  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>创建一个 service 用于给 <code>gRPC</code> 提供域名：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">native-tools-2</span></span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">native-tools-2</span></span><br><span class="line">  <span class="attr">ports:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span>  </span><br><span class="line">      <span class="attr">port:</span> <span class="number">8081</span>  </span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8081</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grpc</span>  </span><br><span class="line">      <span class="attr">port:</span> <span class="number">50051</span>  </span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">50051</span></span><br></pre></td></tr></table></figure><p>同时将我们的 gRPC server 部署三个节点，再部署了一个客户端节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ k get pod</span><br><span class="line">NAME                                READY   STATUS    RESTARTS</span><br><span class="line">native-tools-2-d6c454689-52wgd      1/1     Running   0              </span><br><span class="line">native-tools-2-d6c454689-67rx4      1/1     Running   0              </span><br><span class="line">native-tools-2-d6c454689-zpwxt      1/1     Running   0              </span><br><span class="line">native-tools-65c5bd87fc-2fsmc       2/2     Running   0             </span><br></pre></td></tr></table></figure><p>我们进入客户端节点执行多次 grpc 请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">k <span class="built_in">exec</span> -it native-tools-65c5bd87fc-2fsmc bash</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br></pre></td></tr></table></figure><p>会发现每次请求的都是同一个节点 <code>native-tools-2-d6c454689-zpwxt</code>，这也就证明了在 kubernetes 中直接使用 gRPC 负载是不均衡的，一旦连接建立后就只能将请求发往那个节点。</p><h2 id="使用-Istio"><a href="#使用-Istio" class="headerlink" title="使用 Istio"></a>使用 Istio</h2><p>Istio 可以拿来解决这个问题，我们换到一个注入了 Istio 的 namespace 下还是同样的 代码，同样的 service 资源进行测试。</p><blockquote><p>关于开启 namespace 的 Istio 注入会在后续更新，现在感兴趣的可以查看下官方文档：<br><a href="https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/">https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-5m7dl, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-xprjz, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-5m7dl, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-5m7dl, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-xprjz, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-xprjz, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-5m7dl, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-5m7dl, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-nz8h5, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-nz8h5, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br></pre></td></tr></table></figure><p>可以发现同样的请求已经被负载到了多个 server 后端，这样我们就可以不再单独维护一个客户端 SDK 的情况下实现了负载均衡。</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>其实本质上 Istio 也是客户端负载均衡的一种实现。<br><img src="https://s2.loli.net/2023/10/16/XOU1TGtvm7PeJ8o.png" alt="image.png"><br>以 Istio 的架构图为例：</p><ul><li>每一个 Pod 下会新增一个 <code>Proxy</code> 的 <code>container</code>，所有的流量入口和出口都会经过它。</li><li>它会从控制平面 <code>Istiod</code> 中拿到服务的注册信息，也就是 <code>kubernetes</code> 中的 service。</li><li>发生请求时由 proxy 容器中的 <code>Envoy</code> 进行最终的负载请求。</li></ul><p>可以在使用了 Istio 的 Pod 中查看到具体的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ k get pod native-tools-2-5fbf46cf54-5m7dl -n istio-test-2 -o json | jq <span class="string">&#x27;.spec.containers[].name&#x27;</span></span><br><span class="line"><span class="string">&quot;istio-proxy&quot;</span></span><br><span class="line"><span class="string">&quot;native-tools-2&quot;</span></span><br></pre></td></tr></table></figure><p>可以发现这里存在一个 <code>istio-proxy</code> 的容器，也就是我们常说的 <code>sidecar</code>，这样我们就可以把原本的 SDK 里的功能全部交给 Istio 去处理。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当然 Istio 的功能远不止于此，比如：</p><ul><li>统一网关，处理东西、南北向流量。</li><li>灰度发布</li><li>流量控制</li><li>接口粒度的超时配置</li><li>自动重试等</li></ul><p>这次只是一个开胃菜，更多关于 <code>Istio</code> 的内容会在后续更新，比如会从如何在 <code>kubernetes</code> 集群中安装 <code>Istio</code> 讲起，带大家一步步使用好 <code>Istio</code>。</p><p>本文相关源码：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p><p><sub>参考链接：</sub></p><ul><li><a href="https://istio.io/latest/docs/setup/getting-started/">https://istio.io/latest/docs/setup/getting-started/</a></li><li><a href="https://segmentfault.com/a/1190000042295402">https://segmentfault.com/a/1190000042295402</a></li><li><a href="https://go-zero.dev/docs/tutorials/service/governance/lb">https://go-zero.dev/docs/tutorials/service/governance/lb</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/16/wJiKvMAaWUyOCpX.png&quot; alt=&quot;Istio-grpc-lb.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间写过一篇 &lt;code&gt;gRPC&lt;/code&gt; 的入门文章，在最后还留了一个坑没有填：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/16/41I2RZXeQanFgdB.png&quot; alt=&quot;image.png&quot;&gt;&lt;br&gt;也就是 &lt;code&gt;gRPC&lt;/code&gt; 的负载均衡问题，因为当时的业务请求量不算大，再加上公司没有对 Istio 这类服务网格比较熟悉的大牛，所以我们也就一直拖着没有解决，依然只是使用了 kubernetes 的 service 进行负载，好在也没有出什么问题。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/OB/k8s/"/>
    
    
    <category term="gRPC" scheme="http://crossoverjie.top/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读周刊第一期</title>
    <link href="http://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/"/>
    <id>http://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/</id>
    <published>2023-10-13T08:22:13.000Z</published>
    <updated>2023-10-18T02:54:40.821Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/13/qHMR6zDI529ZsEf.png" alt="Newsletter01.png"></p><p>我自己平时有每天阅读文章的习惯，也会将这些文章保存起来并做一些记录，今天在看阮一峰的科技爱好者周刊时突然想到我也可以将这些看过的觉得不错的内容分享出来。<br><img src="https://s2.loli.net/2023/10/13/TaQZ2MyX4xEIedR.png" alt="image.png"></p><p>顺便也可以让大伙参与留下自己觉得不错的内容，互相学习。</p><span id="more"></span><p>以下便是第一期的内容：</p><h1 id="Istio-中的负载均衡详解及多集群路由实践-🌟🌟🌟"><a href="#Istio-中的负载均衡详解及多集群路由实践-🌟🌟🌟" class="headerlink" title="Istio 中的负载均衡详解及多集群路由实践 🌟🌟🌟"></a><a href="https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/">Istio 中的负载均衡详解及多集群路由实践</a> 🌟🌟🌟</h1><p>1. 介绍了客户端负载均衡和服务端负载均衡的特点和应用场景。<br>2. 引申出 Istio 使用 Envoy 做客户端负载均衡的方案。<br>3. 介绍 Istio 支持的一些负载均衡算法。<br>4. 如何为具体的服务配置负载均衡，以及如何编写 <code>DestinationRule</code> <code>和VirtualService</code></p><h1 id="理解-gRPC-协议🌟🌟🌟🌟"><a href="#理解-gRPC-协议🌟🌟🌟🌟" class="headerlink" title="理解 gRPC 协议🌟🌟🌟🌟"></a><a href="https://taoshu.in/grpc.html">理解 gRPC 协议</a>🌟🌟🌟🌟</h1><p>1. 首先是介绍了 JSON 编码的缺点，可读性高，但性能差。<br>2. PB 性能好，但可读性差，同时还需要配套工具，比如 .proto 格式 IDL 文件来做额外的接口描述。<br>3. 接口请求是底层依然是 http 协议，不过是 http&#x2F;2 协议，但是请求的映射是直接使用 .proto 文件的描述。<br>4. 消息格式描述了消息体前有五个字节，第一个字节描述了是否压缩，后续四个字节描述了消息大小。<br>5. 因为是 stream 协议的关系，才加了这五个字节，因为每次请求都是同一个连接，为了要区分不同的请求就需要在这五个字节来区分了。</p><h1 id="Protocol-Buffers-编码🌟🌟🌟🌟"><a href="#Protocol-Buffers-编码🌟🌟🌟🌟" class="headerlink" title="Protocol Buffers 编码🌟🌟🌟🌟"></a><a href="https://taoshu.in/pb-encoding.html">Protocol Buffers 编码</a>🌟🌟🌟🌟</h1><blockquote><p>配合上一篇一起阅读更加</p></blockquote><p>详细讲解了 PB 编码的原理。<br>1. 定长数据都比较简单，主要是解决变长字符串的问题。<br>2. 以 <code>websocket</code> 为例，<code>websocket</code> 的是三挡变速，而 PB 引入了  VarInts 实现了无级变速，<strong>但前提是字段不能太多</strong>。<br>3. 使用了 Tag 代替了字段名，但坏处就是解码必须需要 PB 文件，也就是需要通过 PB 文件生成目标语言。<br>4. 同时 Tag 也不能更改，更改后解码端得同步更新。</p><h1 id="The-top-7-software-engineering-workflow-tips-I-wish-I-knew-earlier-🧰-🌟🌟🌟🌟"><a href="#The-top-7-software-engineering-workflow-tips-I-wish-I-knew-earlier-🧰-🌟🌟🌟🌟" class="headerlink" title="The top 7 software engineering workflow tips I wish I knew earlier 🧰 🌟🌟🌟🌟"></a>The top 7 software engineering workflow tips I wish I knew earlier 🧰 🌟🌟🌟🌟</h1><blockquote><p>作者使用多年的提高工作效率的七个习惯<br>1. Git 相关，别名，我觉得对我来说是自动补全+历史记录更好用<br>2. 编码相关，别直接使用查找，可以多使用 IDE 快捷键+AI 编程<br>3. 记录学到的知识，比如 Notion，现在我使用 Obsidian<br>4. 使用 Todo 记录自己的灵感，脑子不是拿来存储这些东西的，是拿来做创造力相关的事情（这个我也是使用的 Obsidian 插件 Memos）。<br>5. 可视化沟通，比如使用截图 App，写文档等。<br>6. 使用密码 App，比如 1Password<br>7. 使用窗口管理 App</p></blockquote><h1 id="conc：Go-语言的并发工具库🌟🌟🌟🌟"><a href="#conc：Go-语言的并发工具库🌟🌟🌟🌟" class="headerlink" title="conc：Go 语言的并发工具库🌟🌟🌟🌟"></a><a href="https://github.com/sourcegraph/conc">conc</a>：Go 语言的并发工具库🌟🌟🌟🌟</h1><blockquote><p>Better structured concurrency for go</p></blockquote><p>这是项目的介绍，简单来说就是封装了一些使用  goroutine 的常用操作：</p><ul><li>使用 <code>conc.WaitGroup</code> 替代标准的 <code>sync.WaitGroup</code>，并提供了安全运行的特性，不用担心 panic。</li><li>使用 <code>pool.ResultPool</code> 可以拿到执行的结果，<code>Javaer</code> 是不是似曾相识。</li><li><code>iter.Map/iter.ForEach</code> 可以直接并发 Map 或者是迭代 slice。</li></ul><p><img src="https://s2.loli.net/2023/10/13/iwhN8qW5MmpXfQV.png" alt="image.png"><br>这里举了个例子，如果我们想要写出一个安全的 <code>goroutine</code> 程序，大概需要写左边那么多的代码，而使用 <code>conc</code> 会简单很多，也更加易读。</p><p>其实从这里就不难看出，<code>conc</code> 只是将这些代码封装好了，感兴趣的也可以看看源码，代码不多，很快就可以看完。</p><blockquote><p>以上内容和评分纯主观参考，均没有使用类似于 ChatGPT 这类 AI 工具进行总结，绝对是传统人肉阅读归纳，匠心工艺。</p><p>上榜文章都很不错，推荐大家去阅读原文。</p></blockquote><p>文章链接：</p><ul><li><a href="https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/">https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/</a></li><li><a href="https://github.com/sourcegraph/conc">https://github.com/sourcegraph/conc</a></li><li><a href="https://taoshu.in/pb-encoding.html">https://taoshu.in/pb-encoding.html</a></li><li><a href="https://taoshu.in/grpc.html">https://taoshu.in/grpc.html</a></li><li><a href="https://careercutler.substack.com/p/the-top-7-software-engineering-workflow?ref=dailydev">https://careercutler.substack.com/p/the-top-7-software-engineering-workflow?ref=dailydev</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/13/qHMR6zDI529ZsEf.png&quot; alt=&quot;Newsletter01.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;我自己平时有每天阅读文章的习惯，也会将这些文章保存起来并做一些记录，今天在看阮一峰的科技爱好者周刊时突然想到我也可以将这些看过的觉得不错的内容分享出来。&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/13/TaQZ2MyX4xEIedR.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;顺便也可以让大伙参与留下自己觉得不错的内容，互相学习。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Newsletter" scheme="http://crossoverjie.top/categories/OB/Newsletter/"/>
    
    
    <category term="Tech" scheme="http://crossoverjie.top/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>使用 Helm 管理应用的一些 Tips</title>
    <link href="http://crossoverjie.top/2023/10/07/ob/Helm-tips/"/>
    <id>http://crossoverjie.top/2023/10/07/ob/Helm-tips/</id>
    <published>2023-10-07T12:36:14.000Z</published>
    <updated>2023-10-08T09:49:14.476Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/08/9HKS1lNqyGMson5.png" alt="Helm tips.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><code>Helm</code> 是一个 <strong>Kubernetes</strong> 的包管理工具，有点类似于 <code>Mac</code> 上的 <code>brew</code>，<code>Python</code> 中的 <code>PIP</code>；可以很方便的帮我们直接在 <code>kubernetes</code> 中安装某个应用。</p><p>比如我们可以直接使用以下命令方便的在 k8s 集群安装和卸载 <code>MySQL</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm install my-sql oci://registry-1.docker.io/bitnamicharts/mysql -n mysql</span><br><span class="line"></span><br><span class="line">helm uninstall my-mysql -n mysql</span><br></pre></td></tr></table></figure><span id="more"></span><p>对于一些复杂的应用使用 Helm 一键安装会更简单，以 Pulsar 举例：<br><img src="https://s2.loli.net/2023/10/08/ig4koZIFlUT5Bt1.png" alt="image.png"><br>它有着多个组件，比如 bookkeeper、zookeeper、broker、proxy 等，各个组件还有着依赖关系。</p><p>如果我们手动安装流程会比较繁琐，而使用 Helm 时便非常简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm repo add apache https://pulsar.apache.org/charts</span><br><span class="line"></span><br><span class="line">helm install my-pulsar apache/pulsar --version 3.0.0 -n pulsar</span><br></pre></td></tr></table></figure><blockquote><p>当然他也只是帮我们生成了部署所需要的 yaml 文件，也没有太多黑科技。</p></blockquote><h1 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h1><p>看似简单的工具我在实际线上使用的时候也踩过一个坑，最大的一个问题就是某次升级 Pulsar 的时候生成的 yaml 文件是空的，导致整个集群被删除了😭。</p><p>还好最后使用 <code>helm  rollback version</code> 将集群恢复过来了，我们的持久化数据也还在。</p><p>而出现这个问题的原因是我执行了下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade pulsar ./charts/pulsar --version 2.9.2 -f charts/pulsar/values-2.10.3.yaml -n pulsar</span><br></pre></td></tr></table></figure><p>我们是将 <code>pulsar</code> 的 <code>Helm-Chart</code> 源码下载到本地，然后修改 <code>value.yaml</code> 的方式执行升级的。</p><p>当时执行命令的时候没有注意，在一个没有 <code>values-2.10.3.yaml</code> 文件的目录下执行的，导致生成的 <code>yaml</code> 文件是空的，也就导致 k8s 在 <code>pulsar</code> 这个 <code>namespace</code> 下删除了所有的资源。</p><h2 id="模拟升级"><a href="#模拟升级" class="headerlink" title="模拟升级"></a>模拟升级</h2><p>为了避免今后再次出现类似的问题，需要在升级前先模拟升级：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade pulsar ./charts/pulsar --version 2.9.2 -f charts/pulsar/values-2.10.3.yaml -n pulsar --dry-run --debug &gt; debug.yaml</span><br></pre></td></tr></table></figure><p>其中关键的 <code>dry-run</code> 和 <code>debug</code> 参数可以指定模拟升级和输出详细的内容。</p><p>这样我们就可以在升级前先查看 <code>debug.yaml</code> 里的内容是不是符合我们的预期。</p><h1 id="对比升级"><a href="#对比升级" class="headerlink" title="对比升级"></a>对比升级</h1><p>但这样并不能直观的看出哪些地方是我们修改的，还好社区已经有了相关的插件，可以帮我们高亮显示修改的地方。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm plugin install https://github.com/databus23/helm-diff</span><br></pre></td></tr></table></figure><p>我们先安装好这个 helm 插件。</p><p>然后在升级前先使用该插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm diff upgrade pulsar ./charts/pulsar --version 2.9.2 -f charts/pulsar/values-2.10.3.yaml -n pulsar</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/10/08/V1k5gdhLASfq9JR.png" alt="image.png"></p><p>这样就可以高亮显示出修改的内容。</p><blockquote><p>不用担心这个命令会直接升级，它会自动加上 –dry-run –debug 参数。</p></blockquote><p>更多命令可以参考官方文档：<br><a href="https://github.com/databus23/helm-diff">https://github.com/databus23/helm-diff</a></p><p>Helm 功能很强，在操作生产环境的时候必须得谨慎，都是血淋淋的教训啊。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/08/9HKS1lNqyGMson5.png&quot; alt=&quot;Helm tips.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Helm&lt;/code&gt; 是一个 &lt;strong&gt;Kubernetes&lt;/strong&gt; 的包管理工具，有点类似于 &lt;code&gt;Mac&lt;/code&gt; 上的 &lt;code&gt;brew&lt;/code&gt;，&lt;code&gt;Python&lt;/code&gt; 中的 &lt;code&gt;PIP&lt;/code&gt;；可以很方便的帮我们直接在 &lt;code&gt;kubernetes&lt;/code&gt; 中安装某个应用。&lt;/p&gt;
&lt;p&gt;比如我们可以直接使用以下命令方便的在 k8s 集群安装和卸载 &lt;code&gt;MySQL&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;helm install my-sql oci://registry-1.docker.io/bitnamicharts/mysql -n mysql&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;helm uninstall my-mysql -n mysql&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Helm" scheme="http://crossoverjie.top/categories/Helm/"/>
    
    
    <category term="CloudNative" scheme="http://crossoverjie.top/tags/CloudNative/"/>
    
  </entry>
  
  <entry>
    <title>跟着播客学英语-Why I use vim ? part two.</title>
    <link href="http://crossoverjie.top/2023/10/06/ob/podcasts-english-1-vim/"/>
    <id>http://crossoverjie.top/2023/10/06/ob/podcasts-english-1-vim/</id>
    <published>2023-10-06T12:54:10.000Z</published>
    <updated>2023-10-06T10:04:51.597Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/05/lx4a2h1KcUyIoHd.png"></p><p>在上一期作者讲到了他使用 Vim 的主要原因是提高效率，不需要再去使用鼠标，今天我们继续上次未听完的内容：</p><span id="more"></span><p>if you type Vi, that’s going to be alias to Vim anyway by default there’s, not really a good reason for you to use vi that I can think of. The reason I first started using Vim is kind of a <code>silly</code> one, and that is because my brother used it, uh, my brother, Nick, he climbs mountains for a living. Right now, he lives in Seattle and goes up and down rain near when it gets too cold to climb. Rainer? He goes to the other side of the world and leads, climbs up mountains over there, and then comes back again and starts climb a rain air over and over and over again.</p><p>Before he did that, though, he used to do quite a bit of programming, and I remember when I would watch him program because he started programming before me, he looked like a real hacker. He looked like the hackers you see on TV. He never touched the mouse. There was text flying out all over the screen files, opening, closing splits. It was awesome. It was like I wanted to be that person you. Know and He was using vim. I didn’t know it was Vim, but that’s what he was using. So I opened Vim. I tried to edit some files I was using Eclipse at the time and doing Java.</p><blockquote><p>作者首次使用 Vim 的 原因有点傻，因为他的哥哥 Nick 做了很长时间的编程，一直使用的都是 Vim，看起来就行是电视里真正的黑客那样，他从不使用鼠标，文字也在屏幕里乱飞，看起来非常酷。<br>而那个时候作者还在使用 eclipse 编写 Java</p></blockquote><p>This is like my first year of college, I was taking an introductory to programming class. It’s the first programming I’ve ever done, and I thought Eclipse was great. It compiled my code for me. It had buttons for everything, but I didn’t feel like a real hacker when I looked at nick. I mean, granted, he was writing C, which already looks way cooler. He was using Vim as well, and it just <code>impressed</code> me, so I try to start opening up some of my Java files, and I have no idea how to do it. No idea how to edit a file I have no idea how to save a file I have no idea how to type in the document for crying out loud.</p><p>If I press keys, it does nothing. Sometimes a delete words, sometimes at pacewords, <code>it&#39;s a mess</code>, and this is probably the first experience that everybody has when they start using Vim, because Vim operates completely different than any other text editor I’ve ever used it’s <code>weird</code> them has modes, it has a language, it has objects, subjects, counts, verbs. All that stuff is, like, really weird when you first get started, but once you understand it, it’s a lot of learning upfront everything, just kind of clicks and you’re instantly faster than you’ve ever been before,</p><blockquote><p>eclipse 很好用，但看起来没有 Nick 使用 Vim 那么酷，使得作者印象深刻。</p><p>因此他尝试使用 Vim 来打开 Java 文件，但却不知道如何编辑、删除、保存等基本操作，大部分初次使用 Vim 应该都会碰到这些问题，它和我们使用的其他编辑器完全不同，看起来比较奇怪。</p><p>不过一旦你掌握它，那么使用效率将会飞速提高。</p></blockquote><p>for example, let’s say, we wanted to copy a method from one ruby file and put it in another. If I was using sublime text, I would take my mouse. I would select that method I’d press command c to copy it, and then I’d click over to where I want the method to be, and I’d press command v to paste it. Not very bad that’s pretty fast probably doesn’t take very long, but in Vim, you can do it even faster and without touching your mouse, them has a verb for yanking text it’s not called copying it’s, called yanking.</p><p>It has a movement called inside, so you can yank inside something, and then it has subjects called text blocks, which, in Ruby, those are methods. Vim understands blocks of text if you’re editing a markdown document like, say, a read me, them’ll know where a paragraph starts and where a paragraph ends, if we’re editing a ruby file it’s going to know where a method begins and where a method ends, or where your class begins or where your class ends, so using the Verb Yank, which happens to be the key Y,</p><blockquote><p>如果我们使用 sublime 这样的编辑器复制一个方法时会比较麻烦，首先要用鼠标选中文本，然后复制再粘贴。<br>但使用 Vim 时不需要使用鼠标，而是被称为 Yanking，当编辑  Markdown 时 Vim 会知道段落的开始和结尾，编辑 Ruby 时可以方法的开始和结尾。</p></blockquote><p>and then the movement inside, which happens to be the key I, and then the subject paragraph, which is vim’s word for a block of text, you can yank a method. So if I put my cursor inside a ruby method and I type Y I P. For yank inside paragraph, it’s going to copy that method to the clipboard. So by understanding the verb, yank the movement inside and the subject paragraph, we can perform actions really, really quickly, and then if we want to pace it somewhere else, we press the peaky for paste,</p><p>and it’ll stick that text down, so everything in Vim is based on those concepts of verbs, movements and subjects. You also have one more thing you can play with, and that is counts, so if you want to perform something multiple times, in most cases, you can stick a number in front of it like one, two, three, five, and it’s going to do it that many times, understanding those basic concepts, gets you a really long way, and then it’s just a matter of understanding which keys correspond to which verbs and which movements and which subjects,</p><blockquote><p>在 vim 中只需要将光标移动到方法中，然后使用 YIP 就可以复制整个方法。<br>所以只要理解了这些基本概念就可以快速提高效率。</p></blockquote><p>and that just comes with time, which is the third reason I like to use Vim. Is there so much stuff to learn whenever I get bored? All I got to do is pull up them help, and I could start learning stuff in every little thing, I learn, every little keyboard shortcut, every movement, every subject, gets me a little bit faster, and it doesn’t seem like a lot like the example I gave earlier, of copying and pasting text and sublime with a mouse that doesn’t take very long. But if you add up all those little bits,</p><p>you’re saving a ton of time, a good <code>analogy</code> I like to use is <code>lifting</code> weights if I’m <code>squatting</code> 100 pounds, and I take a little, teeny, tiny two and a half pound plate, and I put it on each side of the barbell I probably won’t, even notice it, I mean, I’ll be squatting 105 pounds now, right, that’s not really that big of a difference, but if I add those two and a half pound plates 60 more times, going in once a day, and doing that, I’m now squatting 400 pounds, which is a pretty big difference, so those little changes don’t seem like a lot,</p><blockquote><p>我喜欢使用 Vim 的一个原因是可以学到许多东西，每学一些都可以让自己的效率提高一点。<br>就像是我们深蹲一样，慢慢的加重量，反复尝试最终就能得到巨大的提升。</p></blockquote><p>but taken as a whole, you’re editing text way faster than people who aren’t using vim. The last reason I like to use Vim is because it runs in the terminal, and this may not seem like a big deal, but it really is <code>cosmetically</code>, it’s nice because you can just pop a terminal open, full screen and have no chrome I use mac os, so I’ve got that big menu bar on top, it’s really nice to just full screen a terminal and not see anything at all, and have your command line tools and your text editor all running in the same window I happen to use tmucks to manage that stuff I won’t talk about Tmux and now,</p><p>but I definitely will talk about it in another episode, but even out of the <code>cosmetic</code> reasons, it’s nice to have a text editor that runs in the terminal because you’re not always using your own machine right as web developers, I’m a web developer, we’re always connecting to remote machines to edit files. Now, why is it that we should be forced to use a different text editor? The nice thing about Vim is it runs in the terminal, so every machine you connect to will likely already have Vim installed, but even if it doesn’t you can install it,</p><p>and you can put your config files over there and you can make it so that no matter where you’re editing text you’re always in the same environment, which is awesome. Before I started using Vim out, connect a remote machines, and, and be forced to use some textset or I’m not familiar with, and it drove me nuts, but now I sometimes forget I’m on a remote machine because it’s exactly the same as the machine I use at home, so if you’ve never tried them, or maybe you tried it in the past, and it was super confusing or really turned you off.</p><blockquote><p>最后一个使用 Vim 的 原因是它可以在终端中运行，不仅可以使用自己的设备，还可以连接到远程设备去编辑文件，还可以使用相同的配置文件，使得所有的环境配置都是相同的</p></blockquote><p>Give it a second shot there’s, a great stack overflow article that just kind of rehashs a lot of the things I said here, but it’s just it’s also just fun to read it talks about the core concepts of vi, the editor that Vim is based on, and I put a link to that in the shownotes there’s, also, them casts by Drew Neil, which is a screencast series that’s totally free, and he covers a lot of advanced concepts he’s got a little bit of beginner stuff in there as well. You can also just open up a terminal and type vim tutor and Vim’s going to give you a little lesson in how to use Vim,</p><p>give it a shot that’s all I’ve got for this week, you can find the shownotes at healthy hacker Dot Com, slash one, if you have any questions or feedback, send me a voicemail healthy hacker, Dot Com Slash Voicemail.</p><blockquote><p>在 stack overflow 中有着各种教程，大家可以尝试一下。</p></blockquote><h1 id="生词"><a href="#生词" class="headerlink" title="生词"></a>生词</h1><p>The reason I first started using Vim is kind of a <code>silly</code> one<br>我第一次使用 Vim 的原因有点傻。</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://s2.loli.net/2023/10/06/WKxpPUNT5wZr983.png" alt="image.png"></h2><p><code>it&#39;s a mess</code><br>搞砸了<br><img src="https://s2.loli.net/2023/10/06/Cl6pKGR7e8A54mk.png" alt="image.png"></p><p>a good <code>analogy</code> I like to use is <code>lifting</code> weights if I’m <code>squatting</code> 100 pounds,<br>but it really is <code>cosmetically</code>,<br><img src="https://s2.loli.net/2023/10/06/8DxnNGwmMiyzCbJ.png"></p><p><img src="https://s2.loli.net/2023/10/06/68yEronuJUpm9wW.png" alt="image.png"><br><img src="https://s2.loli.net/2023/10/06/2O86HijZufx9eVW.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/05/lx4a2h1KcUyIoHd.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一期作者讲到了他使用 Vim 的主要原因是提高效率，不需要再去使用鼠标，今天我们继续上次未听完的内容：&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Podcasts" scheme="http://crossoverjie.top/categories/OB/Podcasts/"/>
    
    
    <category term="English" scheme="http://crossoverjie.top/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>跟着播客学英语-Why I use vim ? part one.</title>
    <link href="http://crossoverjie.top/2023/10/02/ob/podcasts-english-0-vim/"/>
    <id>http://crossoverjie.top/2023/10/02/ob/podcasts-english-0-vim/</id>
    <published>2023-10-02T12:54:10.000Z</published>
    <updated>2023-10-05T15:25:45.382Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/03/kheL1o68m2IyXbU.png" alt="why-use-vim-01.png"></p><p>最近这段时间在学英语，在网上看到有网友推荐可以听英文播客提高听力水平。</p><p>正好我自己也有听播客的习惯，只不过几乎都是中文，但现在我已经尝试听了一段时间的英文播客，觉得效果还不错。</p><p>大部分都是和 IT 相关的内容，所以一些关键词还能听懂，同时也是自己的感兴趣的内容，如果是一次听不懂我就会反复收听。<br>视频版：</p><iframe src="//player.bilibili.com/player.html?aid=961634958&bvid=BV1TH4y1Z77L&cid=1287992721&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><span id="more"></span><p>今天来听第一期内容，这位作者是一位资深工程师，讲述他为什么使用 Vim 的过程。<br><a href="https://www.healthyhacker.com/2014/07/29/why-i-use-vim/">https://www.healthyhacker.com/2014/07/29/why-i-use-vim/</a></p><p>以下是我通过语音转文字的内容</p><blockquote><p>我会精简翻译比较重要的部分，还是推荐大家去收听原始播客。</p></blockquote><p>Healthy hacker episode one. Welcome to the healthy hacker, where we talk about programming, puzzles, memory, fitness, diet, and everything else that you a healthy hacker , find Interesting. I’m Chris Hunt, and on the very first episode episode one, I’m going to answer a question? I get all the time, every conference I go to, every time I start a new job, every time I pair with somebody new. And that is: Chris, why do you use Vim? At of all the text editor on the planet, why do you choose to use Vim?</p><blockquote><p>作者在各种会议和新同事的接触中都会被问到这个问题：为什么你会使用 vim</p></blockquote><p>It’s so old it looks like <code>crap</code>. Why do you do it? So I’m totally going to tell you I have many various reasons why I love using Vim really excited about it, going to answer that question before we do though, we are going to talk about the workout of the week , all right. The workout of the week is a section that, uh, basically, I’m just going to take a workout I’ve done recently, and tell you about it, and hopefully you find the time this week to try it yourself, because every single one of these workouts you can do, I promise you. </p><blockquote><p>在开始之前先聊聊本周的锻炼</p></blockquote><p>Okay, so this week’s workout is a workout that I’ve been doing for several years. You need <code>barely</code> no equipment. All you need is a floor. I do it at least once, when I travel, sometimes twice, sometimes three times. I think there was a point in my life where I was doing this. Work out, like three or four times a day. This is the only thing I was doing. I don’t recommend that, but you should totally give it a shot at least once this week and let me know how you do, because I’m <code>curious</code>,</p><blockquote><p>这个锻炼已经进行了许多年了，几乎不需要额外的设备，只需要一块地板。旅行的时候也会继续坚持，建议你本周至少得尝试一次。</p></blockquote><p>so let’s get right into it this is  A ten rep pyramid, and I’ll I’ll explain what that means. Basically, you want to do each exercise, one time, then two times, then three times, then four times, all the way up to ten, the top of the pyramid ten times, and then you go back down again to one, so nine, a seven until you finally end with one rep of each exercise, so the two exercises are going to do for this workout is a pushup and a shoulder press with no weight on each of these, you’re just doing body weight.</p><blockquote><p>做一个递增组和递减组，从每组一个动作增加到每组 10 个动作，再由十个动作一组减少到一个动作一组；<br>每组做两个动作，俯卧撑，和坐姿推肩，都不用负重，只需要自重即可。</p></blockquote><p>So I’m sure, everybody knows what a pushup is. If you don’t check out the show notes, or just do a Google image search, shoulder press you may or may not be as familiar with, but it’s just like it sounds. You take your hands, put them by your shoulders, and then press your hands up into the air again, just to Google. Im in search, you’ll totally get what this is. So the workout is one pushup. One shoulder press, then two pushups, two shoulder presses, then three pushups, then three shoulder presses,</p><blockquote><p>应该都知道俯卧撑怎么做，如果推肩不知道怎么做的话可以去 Google，都是比较简单动作；<br>所以这个训练是一次俯卧撑，一次推肩为一个动作；然后增加到两个俯卧撑+推肩+然后是三个俯卧撑+三个推肩。</p></blockquote><p>then four, five, six, seven, eight 910, and then go back down again, nine, eight, seven, six, and you finish with one push up, one shoulder, press. Now. The goal with this is to go as fast as you possibly can, but take breaks as necessary. I <code>definitely</code> can’t do this without stopping, especially on the pushups part. So do as fast as you can. When I did this this morning, I did it in seven minutes and 28 seconds, so let me know how you do. I’m super curious if you’ve never done this before, it’s going to seem crazy hard,</p><blockquote><p>以此类推做到十次，再递减到 1 一次，目标是尽可能的快速完成。<br>休息也是非常有必要的，我无法做到不休息全部完成，特别是在俯卧撑这个部分。<br>非常好奇你做完的感受，如果你从来没做过的话，还是比较困难的。</p></blockquote><p>but I know you can do it. By the time you finished this workout, you will have done 100 pushups and 100 shoulder presses. If it really Really Really is out of your <code>reach</code>, even with breaks, then you can scale this workout, decreasing your pyramid. So instead of doing a ten rep pyramid, do like a six rep pyramid or a Five Rep Pyramid, but with brakes, I know that everybody can do 100 pushups in 100 shoulder presses. It might take you a while, but you can do it, so give it a shot. All right. </p><blockquote><p>但超过你的承受范围时，可以适当减少组数。</p></blockquote><p>So now it’s time to answer that question: why do I use Vim? Well, for starters, if you’re going to learn any editor vim is a pretty good <code>investment</code>. It’s been around for a long time over 20 years. It’s open source, it runs on everything it’s not like there’s, a company vested in its future you know it doesn’t cost you money, it’s for as long as I’m programming, vim is going to be around, so if I’m going to waste time trying to master a text editor, vim is probably a good choice because it’s not going anywhere</p><p>I’m not going to have to forget everything I’ve learned and start learning a different text editor. I can use vim for the rest of my life for all my text editor so it’s a good <code>investment</code> of your time. Now if you do a Google search, you start looking for books for Vim, you might see Vi and Vi is actually an older editor that Vim is based on Vim stands for Vi improved, and most of them’s functionality comes from Vi, so most of us, don’t use Vi, some of the things I really like about vim, that Vi doesn’t have is improved syntax,</p><p>highlighting for the languages I like to use mostly Ruby and Javascript. Nowadays, they’re spell-checking, so when you use it for typing an emails or typing up a poll request that comes in handy, there’s splits, so you can view maybe your test and your code at the same time, without having to go back and forth, you have multiple levels of undo and redo them can do diffs, or, as vi can’t do diff, so you can open up two of the same files that are edited at different points of time, and see that diff in red and green it’s pretty nice,</p><blockquote><p>学习 vim 是一个很好的投资，它是开源的免费的，值得花时间去学习。<br>vi 是 vim 的前身，vim 在此基础上进行了改进，比如语法高亮、输入检测等。<br>vim 还可以分屏，可视化对比等</p></blockquote><p>and then you also have scripting Vim script itself, which is, the native script language for Vim is not pretty, but you can also do scripting with other languages, like Perl, Ruby, python and Vim also has a really awesome help system with which vi does not have there’s also some improvements that Vim ads that I don’t really care about, I mean I took notes, obviously because I don’t have all this stuff memorized, and I’ve titled this section dumb <code>stuff</code>, because it’s kind of du I don’t care linefolding is one editing of compressed files I don’t really care about that.</p><blockquote><p>Vim 还内置了脚本语言 vimscript，很好用的帮助系统，这些 vi 都没有。</p></blockquote><p>You can edit files over network connections like ssh ftp http. I could say how that would be useful, but I’ve never wanted or had to do that, and then them also provides a graphical user interface. Usually you open this up using Gvim for graphical Vim, and that provides mouse integration, again, things I don’t care about. One of the main reasons I use Vim is for speed, and not having to touch the mouse, so it’s kind of silly to for me to get excited about that kind of <code>stuff</code>, okay So so that’s the kind of the differences between Vim and Vi and why everybody uses Vim most computers now.</p><blockquote><p>vim 可以通过网络连接来编辑文件，同时也提供了 GUI 界面，可以使用鼠标来操作。<br>不过我对这个并不感兴趣，使用 vim 的主要原因就是因为速度，不需要在去触摸鼠标了（这确实也是大部分人使用 vim 的原因）</p></blockquote><h1 id="生词"><a href="#生词" class="headerlink" title="生词"></a>生词</h1><p>It’s so old it looks like <code>crap</code>:  它已经很老了，看起来是垃圾。<br><code>crap</code>:<br><img src="https://s2.loli.net/2023/10/03/3RZontYrVcDTFGq.png" alt="image.png"></p><p>if you’re going to learn any editor, vim is a pretty good <code>investment</code>：<br>如果你想学习一个编辑器，Vim 是一个不错的投资。<br><code>investment</code>:<br><img src="https://s2.loli.net/2023/10/03/PjR97l2iYNLtU3g.png" alt="image.png"></p><p>I <code>definitely</code> can’t do this without stopping<br>我绝对不能不停下来<br><code>definitely</code>:<br><img src="https://s2.loli.net/2023/10/03/saTHywQgdti5ePA.png" alt="image.png"></p><p>let me know how you do, because I’m <code>curious</code>:<br>告诉我你是怎么做的，我很好奇。<br><code>curious</code><br><img src="https://s2.loli.net/2023/10/03/vWz9ZR6MdLVSrUu.png" alt="image.png"></p><p>You need <code>barely</code> no equipment.<br>你几乎不需要设备<br><code>barely</code><br><img src="https://s2.loli.net/2023/10/03/9rcKYjITGQgUB4n.png" alt="image.png"></p><p>I don’t have all this <code>stuff</code> memorized:<br>我没有记住所有这些东西<br><code>stuff</code><br><img src="https://s2.loli.net/2023/10/03/nP8SpO2DTdHLj31.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/03/kheL1o68m2IyXbU.png&quot; alt=&quot;why-use-vim-01.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近这段时间在学英语，在网上看到有网友推荐可以听英文播客提高听力水平。&lt;/p&gt;
&lt;p&gt;正好我自己也有听播客的习惯，只不过几乎都是中文，但现在我已经尝试听了一段时间的英文播客，觉得效果还不错。&lt;/p&gt;
&lt;p&gt;大部分都是和 IT 相关的内容，所以一些关键词还能听懂，同时也是自己的感兴趣的内容，如果是一次听不懂我就会反复收听。&lt;br&gt;视频版：&lt;/p&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=961634958&amp;bvid=BV1TH4y1Z77L&amp;cid=1287992721&amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Podcasts" scheme="http://crossoverjie.top/categories/OB/Podcasts/"/>
    
    
    <category term="English" scheme="http://crossoverjie.top/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>k8s入门到实战-应用配置</title>
    <link href="http://crossoverjie.top/2023/09/26/ob/k8s-configmap/"/>
    <id>http://crossoverjie.top/2023/09/26/ob/k8s-configmap/</id>
    <published>2023-09-26T06:20:33.000Z</published>
    <updated>2023-09-26T13:24:40.137Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/26/b9N2AufHMpqWRKs.png" alt="ConfigMap.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在前面<a href="https://crossoverjie.top/categories/k8s/">三节中</a>已经讲到如何将我们的应用部署到 k8s 集群并提供对外访问的能力，x现在可以满足基本的应用开发需求了。</p><p>现在我们需要更进一步，使用 k8s 提供的一些其他对象来标准化我的应用开发。<br>首先就是 <code>ConfigMap</code>，从它的名字也可以看出这是用于管理配置的对象。</p><span id="more"></span><h1 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h1><p>不管我们之前是做 <code>Java</code>、<code>Go</code> 还是 <code>Python</code> 开发都会使用到配置文件，而 <code>ConfigMap</code> 的作用可以将我们原本写在配置文件里的内容转存到 <code>k8s</code> 中，然后和我们的 <code>Container</code> 进行绑定。</p><h2 id="存储到环境变量"><a href="#存储到环境变量" class="headerlink" title="存储到环境变量"></a>存储到环境变量</h2><p>绑定的第一种方式就是将配置直接写入到环境变量，这里我先定义一个 <code>ConfigMap</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-configmap</span>  </span><br><span class="line"><span class="attr">data:</span>  </span><br><span class="line">  <span class="attr">PG_URL:</span> <span class="string">&quot;postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable&quot;</span></span><br></pre></td></tr></table></figure><p>重点是 <code>data</code> 部分，存储的是一个 <code>KV</code> 结构的数据，这里存储的是一个数据库连接。</p><blockquote><p>需要注意，KV 的大小不能超过 1MB</p></blockquote><p>接着可以在容器定义中绑定这个 <code>ConfigMap</code> 的所有 <code>KV</code> 到容器的环境变量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define all the ConfigMap&#x27;s data as container environment variables </span></span><br><span class="line"><span class="attr">envFrom:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">configMapRef:</span>  </span><br><span class="line">      <span class="attr">name:</span> <span class="string">k8s-combat-configmap</span></span><br></pre></td></tr></table></figure><p>我将 <code>ConfigMap</code> 的定义也放在了同一个 <a href="https://github.com/crossoverJie/k8s-combat/blob/main/deployment/deployment.yaml">deployment</a> 中，直接 apply:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ k apply -f deployment/deployment.yaml</span><br><span class="line">deployment.apps/k8s-combat created</span><br><span class="line">configmap/k8s-combat-configmap created</span><br></pre></td></tr></table></figure><p>此时 <code>ConfigMap</code> 也会被创建，我们可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">❯ k get configmap</span><br><span class="line">NAME                   DATA   AGE</span><br><span class="line">k8s-combat-configmap   1      3m17s</span><br><span class="line"></span><br><span class="line">❯ k describe configmap k8s-combat-configmap</span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">PG_URL:</span><br><span class="line">----</span><br><span class="line">postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable</span><br></pre></td></tr></table></figure><p>拿到刚才声明的配置信息。</p><hr><p>同时我在代码中也读取了这个环境变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">   name, _ := os.Hostname()  </span><br><span class="line">   url := os.Getenv(<span class="string">&quot;PG_URL&quot;</span>)   </span><br><span class="line">   fmt.Fprint(w, fmt.Sprintf(<span class="string">&quot;%s-%s&quot;</span>, name, url))  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>访问这个接口便能拿到这个环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-combat-7b987bb496-pqt9s:/# curl http://127.0.0.1:8081</span><br><span class="line">k8s-combat-7b987bb496-pqt9s-postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable</span><br><span class="line"></span><br><span class="line">root@k8s-combat-7b987bb496-pqt9s:/# echo $PG_URL</span><br><span class="line">postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable</span><br></pre></td></tr></table></figure><h2 id="存储到文件"><a href="#存储到文件" class="headerlink" title="存储到文件"></a>存储到文件</h2><p>有些时候我们也需要将这些配置存储到一个文件中，比如在 Java 中可以使用 <code>spring</code> 读取，<code>Go</code> 也可以使用 <code>configor</code> 这些第三方库来读取，所有配置都在一个文件中也更方便维护。</p><p><img src="https://s2.loli.net/2023/09/26/g2IhktH7iwWb8LT.png" alt="image.png"><br>在 <code>ConfigMap</code> 中新增了一个 <code>key:APP</code> 存放了一个 <code>yaml</code> 格式的数据，然后在容器中使用 <code>volumes</code> 和 <code>volumeMounts</code> 将数据挂载到容器中的指定路径<code>/go/bin/app.yaml</code></p><p>apply 之后我们可以在容器中查看这个文件是否存在：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-combat-7b987bb496-pqt9s:/# cat /go/bin/app.yaml</span><br><span class="line">name: k8s-combat</span><br><span class="line">pulsar:</span><br><span class="line">  url: &quot;pulsar://localhost:6650&quot;</span><br><span class="line">  token: &quot;abc&quot;</span><br></pre></td></tr></table></figure><p>配置已经成功挂载到了这个路径，我们便可以在代码中读取这些数据。</p><h1 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h1><p>可以看到 <code>ConfigMap</code> 中是明文存储数据的；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k describe configmap k8s-combat-configmap</span><br></pre></td></tr></table></figure><p>可以直接查看。</p><p>对一些敏感数据就不够用了，这时我们可以使用 <code>Secret</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-secret</span>  </span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span>  </span><br><span class="line"><span class="attr">data:</span>  </span><br><span class="line">  <span class="attr">PWD:</span> <span class="string">YWJjCg==</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">env:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PG_PWD</span>  </span><br><span class="line">    <span class="attr">valueFrom:</span>  </span><br><span class="line">      <span class="attr">secretKeyRef:</span>  </span><br><span class="line">        <span class="attr">name:</span> <span class="string">k8s-combat-secret</span>  </span><br><span class="line">        <span class="attr">key:</span> <span class="string">PWD</span></span><br></pre></td></tr></table></figure><p>这里我新增了一个 <code>Secret</code> 用于存储密码，并在 <code>container</code> 中也将这个 <code>key</code> 写入到环境变量中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ echo &#x27;abc&#x27; | base64</span><br><span class="line">YWJjCg==</span><br></pre></td></tr></table></figure><p><code>Secret</code> 中的数据需要使用 <code>base64</code> 进行编码，所以我这里存储的是 abc.</p><p>apply 之后我们再查看这个 <code>Secret</code> 是不能直接查看原始数据的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ k describe secret k8s-combat-secret</span><br><span class="line">Name:         k8s-combat-secret</span><br><span class="line">Type:  Opaque</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">PWD:  4 bytes</span><br></pre></td></tr></table></figure><p><code>Secret</code> 相比 <code>ConfigMap</code> 多了一个 <code>Type</code> 选项。<br><img src="https://s2.loli.net/2023/09/26/G25TRcSzCbIVDQ3.png"></p><p>我们现阶段在应用中用的最多的就是这里的 <code>Opaque</code>，其他的暂时还用不上。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在实际开发过程中研发人员基本上是不会直接接触 <code>ConfigMap</code>，一般会给开发者在管理台提供维护配置的页面进行 CRUD。</p><p>由于 <code>ConfigMap</code> 依赖于 k8s 与我们应用的语言无关，所以一些高级特性，比如实时更新就无法实现，每次修改后都得重启应用才能生效。</p><p>类似于 Java 中常见的配置中心：<code>Apollo,Nacos</code> 使用上会有不小的区别，但这些是应用语言强绑定的，如果业务对这些配置中心特性有强烈需求的话也是可以使用的。</p><p>但如果团队本身就是多语言研发，想要降低运维复杂度 <code>ConfigMap</code> 还是不二的选择。</p><p>下一章节会更新大家都很感兴趣的服务网格 <code>Istio</code>，感兴趣的朋友多多点赞转发🙏🏻。</p><p>本文的所有源码和资源文件在这里可以访问：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/26/b9N2AufHMpqWRKs.png&quot; alt=&quot;ConfigMap.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在前面&lt;a href=&quot;https://crossoverjie.top/categories/k8s/&quot;&gt;三节中&lt;/a&gt;已经讲到如何将我们的应用部署到 k8s 集群并提供对外访问的能力，x现在可以满足基本的应用开发需求了。&lt;/p&gt;
&lt;p&gt;现在我们需要更进一步，使用 k8s 提供的一些其他对象来标准化我的应用开发。&lt;br&gt;首先就是 &lt;code&gt;ConfigMap&lt;/code&gt;，从它的名字也可以看出这是用于管理配置的对象。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/k8s/"/>
    
    
    <category term="ConfigMap" scheme="http://crossoverjie.top/tags/ConfigMap/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言史诗级更新-循环Bug修复</title>
    <link href="http://crossoverjie.top/2023/09/24/ob/go-loop-fix/"/>
    <id>http://crossoverjie.top/2023/09/24/ob/go-loop-fix/</id>
    <published>2023-09-24T10:05:25.000Z</published>
    <updated>2023-09-24T11:45:54.302Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/24/rU7IujkPWX1TRQM.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前两天 <code>Golang</code> 的官方博客更新了一篇文章：<a href="https://go.dev/blog/loopvar-preview">Fixing For Loops in Go 1.22</a></p><p>看这个标题的就是修复了 Go 循环的 bug，这真的是史诗级的更新；我身边接触到的大部分 Go 开发者都犯过这样的错误，包括我自己，所以前两年我也写过类似的博客：<br><a href="https://crossoverjie.top/2021/12/28/go/for-mistake/">简单的 for 循环也会踩的坑</a></p><span id="more"></span><p>先来简单回顾下使用使用 for 循环会碰到的问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list := []*Demo&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;&#125;  </span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;  </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">fmt.Println(<span class="string">&quot;name=&quot;</span>+v.Name)  </span><br><span class="line">&#125;()  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Demo <span class="keyword">struct</span> &#123;  </span><br><span class="line">Name <span class="type">string</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预期的结果应该是打印 <code>a,b</code>，但实际打印的却是<code>b,b</code>。</p><p><img src="https://s2.loli.net/2023/09/24/I98GMk5efvNUDbT.png" alt="image.png"></p><p><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1619047">Let’s Encrypt: CAA Rechecking bug</a><br>类似的问题连 <code>mozilla</code> 团队也没能幸免，所以也确实是一个非常常见的问题，这样的写法符合大部分的开发者的直觉，毕竟其他语言这么使用也没有问题。</p><p>当然在现阶段要解决也很简单，要么就是在使用之前先复制一次，或者使用闭包传参：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制</span></span><br><span class="line"> list := []*Demo&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;&#125;  </span><br><span class="line"> <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;  </span><br><span class="line">  temp:=v  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   fmt.Println(<span class="string">&quot;name=&quot;</span>+temp.Name)  </span><br><span class="line">  &#125;()  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"> list := []*Demo&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;&#125;  </span><br><span class="line"> <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(temp *Demo)</span></span> &#123;  </span><br><span class="line">   fmt.Println(<span class="string">&quot;name=&quot;</span>+temp.Name)  </span><br><span class="line">  &#125;(v)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>还好官方也意识到了这个问题：<br><img src="https://s2.loli.net/2023/09/24/6NTZSijCofypK54.png" alt="image.png"><br>所以在 1.22 中我们可以不用再写这个 <code>    v:=v</code>这个多余的复制语句了，也不会出现上面的问题。</p><p>我们在 1.21 中可以使用环境变量预览这个特性:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ GOEXPERIMENT=loopvar <span class="keyword">go</span> test</span><br><span class="line">name=b</span><br><span class="line">name=a</span><br></pre></td></tr></table></figure><p>在 1.22 发布后建议大家都可以升级了，将这种恶心的 bug 扼杀在摇篮里。</p><p>1.22 后带来了一个好消息是今后少了一道面试题，坏消息是又新增了一个 1.22 版本带来了哪些变化的面试题😂</p><p>更多详情可以参看官方播客：<a href="https://go.dev/blog/loopvar-preview">https://go.dev/blog/loopvar-preview</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/24/rU7IujkPWX1TRQM.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前两天 &lt;code&gt;Golang&lt;/code&gt; 的官方博客更新了一篇文章：&lt;a href=&quot;https://go.dev/blog/loopvar-preview&quot;&gt;Fixing For Loops in Go 1.22&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看这个标题的就是修复了 Go 循环的 bug，这真的是史诗级的更新；我身边接触到的大部分 Go 开发者都犯过这样的错误，包括我自己，所以前两年我也写过类似的博客：&lt;br&gt;&lt;a href=&quot;https://crossoverjie.top/2021/12/28/go/for-mistake/&quot;&gt;简单的 for 循环也会踩的坑&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="http://crossoverjie.top/categories/Golang/"/>
    
    
    <category term="loop" scheme="http://crossoverjie.top/tags/loop/"/>
    
  </entry>
  
  <entry>
    <title>Github commit 签名+合并 Commit</title>
    <link href="http://crossoverjie.top/2023/09/18/ob/git-tips-rebase/"/>
    <id>http://crossoverjie.top/2023/09/18/ob/git-tips-rebase/</id>
    <published>2023-09-18T09:56:51.000Z</published>
    <updated>2023-09-19T06:36:40.881Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/18/gCjw9hZx4Y6cPSn.png" alt="Github的一个奇技淫巧.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间给 <code>VictoriaLogs</code> 提交了一个 PR：<br><a href="https://github.com/VictoriaMetrics/VictoriaMetrics/pull/4934">https://github.com/VictoriaMetrics/VictoriaMetrics/pull/4934</a></p><p>本来一切都很顺利，只等合并了，但在临门一脚的时候社区维护人员问我可否给 <code>git</code> <code>commit</code> 加上签名。</p><blockquote><p>于是我就默默的调试到了凌晨四点😭</p></blockquote><p><img src="https://s2.loli.net/2023/09/18/VXhjU9ypuKP1ZWg.png" alt="image.png"></p><span id="more"></span><p>以前我也没怎么注意过这个选项，经过 <code>Google</code> 后发现 <code>Idea</code> 在提交的时候可以自行设置。</p><p><img src="https://s2.loli.net/2023/09/18/QdTetRSNG5c3KVr.png" alt="image.png"><br>当我勾选了这个提交新的代码后，依然被告知没有正确的签名，这时我才发现理解错误了。</p><h1 id="为-GitHub-的提交签名"><a href="#为-GitHub-的提交签名" class="headerlink" title="为 GitHub 的提交签名"></a>为 GitHub 的提交签名</h1><p>结合这位社区大佬给的文档，他所需要的是每次提交的代码都是有签名的，类似于这样：<br><img src="https://s2.loli.net/2023/09/18/26vgVMZmNrPCkqo.png" alt="image.png"></p><p>如果我们想要 <code>GitHub</code> 现实 <code>Verified</code> 这个标签，那就需要对 <code>commit</code> 或者是打的 <code>tag</code> 进行签名。</p><p>而签名的方式有三种：<code>GPG</code>, <code>SSH</code>, <code>S/MIME</code>，这里我以 GPG 签名为例，整体流程如下：</p><p><img src="https://s2.loli.net/2023/09/18/HwDIlL94c51Uz3e.png" alt="image.png"></p><p>先在<a href="https://www.gnupg.org/download/">https://www.gnupg.org/download/</a>这里下载安装 GPG 的命令行程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --full-generate-key</span><br></pre></td></tr></table></figure><p>使用这个命令生成 key，之后会根据提示录入一些信息，包含你的 ID 和邮箱，建议都和 GitHub 的 ID 邮箱保持一致即可，然后一路回车完事。</p><p>之后可以使用这个命令查看刚才创建的 Key：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gpg --list-secret-keys --keyid-format=long</span><br><span class="line">------------------------------------</span><br><span class="line">sec   4096R/3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]</span><br><span class="line">uid                          Hubot &lt;hubot@example.com&gt;</span><br><span class="line">ssb   4096R/4BB6D45482678BE3 2016-03-10</span><br></pre></td></tr></table></figure><p>我们需要将 <code>3AA5C34371567BD2</code> 这个 Key 的 ID 字符串复制，之后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --armor --export 3AA5C34371567BD2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Prints the GPG key ID, <span class="keyword">in</span> ASCII armor format</span></span><br></pre></td></tr></table></figure><p>此时会打印出公钥，我们将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PGP PUBLIC KEY BLOCK-----</span><br><span class="line">-----END PGP PUBLIC KEY BLOCK-----</span><br></pre></td></tr></table></figure><p>这些数据复制到 GitHub 的个人设置页面：<br><img src="https://s2.loli.net/2023/09/18/zvMgJcqAnRQjYxG.png" alt="image.png"></p><p>此时还没完，如果我们直接提交代码的也不会有 <code>Verified</code> 的标签。</p><p><img src="https://s2.loli.net/2023/09/18/eST5f1Vad4x8Ou7.png" alt="image.png"></p><p>我们还需要打开 git 的 config 设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config commit.gpgsign true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局打开</span></span><br><span class="line">git config --global commit.gpgsign true</span><br><span class="line">git commit -S -m &quot;YOUR_COMMIT_MESSAGE&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>这样提交的 Commit 就会打上验证的标签了。<br><img src="https://s2.loli.net/2023/09/18/HKcvrfMozC9YEnx.png" alt="image.png"></p><blockquote><p>-S 的效果和在 idea 中选中 Sign-off 的效果一样。</p></blockquote><p>官方文档也有详细的步骤：<br><a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/about-commit-signature-verification">https://docs.github.com/en/authentication/managing-commit-signature-verification/about-commit-signature-verification</a></p><h1 id="Squash-合并提交"><a href="#Squash-合并提交" class="headerlink" title="Squash 合并提交"></a>Squash 合并提交</h1><p>不过在我这个 <code>PR</code> 的背景下还有一个步骤没有完成，就是我之前提交的 <code>Commit</code> 都没要验证，我需要将他们都合并为一个验证的 Commit 然后在强制推送上去，这样整个 <code>git log</code> 看起来才足够简洁。</p><p>最终效果如下，只有一个 Commit 存在。<br><img src="https://s2.loli.net/2023/09/18/1OzjkDwhdWuJS8n.png"></p><p>这时候就得需要 git rebase 出马了。</p><p><img src="https://s2.loli.net/2023/09/18/vaOPw3gQTtVSoxC.png" alt="image.png"><br>以刚才测试的这两个提交为例，我需要将他们合并为一个提交。</p><p>我们先使用这个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~N</span><br><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure><p>N 就是我们需要合并几个提交，在我这里就是 2.</p><p><img src="https://s2.loli.net/2023/09/18/PN6nUE3BVu48TWF.png" alt="image.png"><br>我们需要将除了第一个 commit 之外的都修改为 s，也就是下面注释里的 <code>squash</code> 的简写（压缩的意思）。</p><p>这是一个 vim 的交互编辑模式，编辑完成之后保存退出。</p><blockquote><p>不会还有程序员不知道如何保存 vim 退出吧🐕。</p></blockquote><p>保存后又会弹出一个编辑页面，让我们填写这次压缩之后的提交记录，默认会帮我生成好，当然你也可以全部删掉后重写。</p><p><img src="https://s2.loli.net/2023/09/18/YCx5ablcrBmsdiD.png" alt="image.png"></p><p>我这里就直接使用它生成好的就可以了，依然还是保存退出。</p><p>最后再强行推送到我所在的分支即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin test-rebase -f</span><br></pre></td></tr></table></figure><p>在这个分支的提交页面也只会看到刚才强行推送的记录了，刚才的两个提交已经合并为这一个了。</p><p><img src="https://s2.loli.net/2023/09/18/ULO3kxgSYErPqle.png" alt="image.png"></p><h1 id="将修改提交到其他分支"><a href="#将修改提交到其他分支" class="headerlink" title="将修改提交到其他分支"></a>将修改提交到其他分支</h1><p>有时候线上出现问题需要马上修复的时候，我会不下意识的直接就开始改了，等真的提交代码被拒的时候才发现是在主分支上。</p><p>我觉得有类似需求的场景还不少，这时候就需要将当前分支的修改提交到一个新的分支上，总不能 revert 之后重新再写吧。</p><p>所以通常我的流程是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个分支</span></span><br><span class="line">git branch newbranch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将当前分支的修改临时保存到暂缓区，同时回滚当前分支。</span></span><br><span class="line">git stash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到新的分支</span></span><br><span class="line">git checkout newbranch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从暂缓区中取出刚才的修改</span></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>这样之前分支的修改就会同步到新的分支上了，借着便在新的分支上继续开发了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>借着这个机会也了解了 <code>rebase</code> 的骚操作挺多的，不过我平时用的最多的还是 <code>merge</code>，这个倒没有好坏之分，只要同组的开发者都达成一致即可。</p><p>#Blog #Github #Git</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/18/gCjw9hZx4Y6cPSn.png&quot; alt=&quot;Github的一个奇技淫巧.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间给 &lt;code&gt;VictoriaLogs&lt;/code&gt; 提交了一个 PR：&lt;br&gt;&lt;a href=&quot;https://github.com/VictoriaMetrics/VictoriaMetrics/pull/4934&quot;&gt;https://github.com/VictoriaMetrics/VictoriaMetrics/pull/4934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本来一切都很顺利，只等合并了，但在临门一脚的时候社区维护人员问我可否给 &lt;code&gt;git&lt;/code&gt; &lt;code&gt;commit&lt;/code&gt; 加上签名。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;于是我就默默的调试到了凌晨四点😭&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/18/VXhjU9ypuKP1ZWg.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="http://crossoverjie.top/categories/git/"/>
    
    
    <category term="rebase" scheme="http://crossoverjie.top/tags/rebase/"/>
    
  </entry>
  
</feed>
