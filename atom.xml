<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverJie&#39;s Blog</title>
  
  <subtitle>baller</subtitle>
  <link href="http://crossoverjie.top/atom.xml" rel="self"/>
  
  <link href="http://crossoverjie.top/"/>
  <updated>2024-06-13T09:18:05.873Z</updated>
  <id>http://crossoverjie.top/</id>
  
  <author>
    <name>crossoverJie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从 Prometheus 到 OpenTelemetry：指标监控的演进与实践</title>
    <link href="http://crossoverjie.top/2024/06/13/ob/OpenTelemetry-metrics-concept/"/>
    <id>http://crossoverjie.top/2024/06/13/ob/OpenTelemetry-metrics-concept/</id>
    <published>2024-06-13T10:22:48.000Z</published>
    <updated>2024-06-13T09:18:05.873Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇：<a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅</a>我们讲解了 Trace 的一些核心概念：</p><ul><li>Trace</li><li>Span</li><li>Context</li><li>Baggage 等</li></ul><p>这次我们来讲另一个话题 <code>Metrics</code>。</p><span id="more"></span><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>关于 metrics 我最早接触相关概念的就是 prometheus，它是第二个加入 CNCF（云原生）社区的项目（第一个是 kubernetes），可见在云原生领域 Metrics 指标监控从诞生之初就是一个非常重要的组件。</p><p>现实也确实如此，如今只要使用到了 kubernetes 相关的项目，对其监控就是必不可少的。</p><p>当然也不止是云原生的项目才需要 Metrics 指标监控，我们任何一个业务都是需要的，不然我们的服务运行对开发运维来说都是一个黑盒，无法知道此时系统的运行情况，因此才需要我们的业务系统将一些关键运行指标暴露出来。</p><p><img src="https://s2.loli.net/2024/05/12/1QWEAdFHqYzhl4g.png"></p><p>业务数据：比如订单的增长率、销售金额等业务数据；同时还有应用自身的资源占用情况：</p><ul><li>QPS</li><li>Latency</li><li>内存</li><li>CPU 等信息。</li></ul><p> 在使用 OpenTelemetry 之前，因为 prometheus 是这部分的绝对标准，所以我们通常都会使用 prometheus 的包来暴露这些指标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- The client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Hotspot JVM metrics--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_hotspot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>暴露一个自定义的指标也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.prometheus.client.Counter;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YourClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Counter</span> <span class="variable">requests</span> <span class="operator">=</span> Counter.build()</span><br><span class="line">     .name(<span class="string">&quot;requests_total&quot;</span>).help(<span class="string">&quot;Total requests.&quot;</span>).register();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    requests.inc();</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这是暴露一个单调递增的指标，prometheus 还提供了其他几种指标类型：</p></blockquote><ul><li>Counter</li><li>Gauge</li><li>Histogram</li></ul><p>之后我们只需要在 prometheus 中配置一些抓取规则即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;springboot&#x27;</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:8080&#x27;</span>] <span class="comment"># Spring Boot ip+port</span></span><br></pre></td></tr></table></figure><blockquote><p>当然如果是运行在 kubernetes 环境，prometheus 也可以基于服务发现配置一些规则，自动抓取我们的 Pod 的数据，由于不是本文的重点就不过多介绍。</p></blockquote><h1 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h1><p>在 OpenTelemetry 中自然也提供了 Metrics 这个组件，同时它也是完全兼容 Prometheus，所以我们理解和使用起来并不复杂。</p><h2 id="MeterProvider"><a href="#MeterProvider" class="headerlink" title="MeterProvider"></a>MeterProvider</h2><p>不同于 prometheus 客户端中直接提供了 Counter 就可以创建指标了，在 OpenTelemetry 中会提供一个 <code>MeterProvider</code> 的接口，使用这个接口可以获取 Meter，再使用 Meter 才可以创建 Counter、Gauge、Histogram 等数据。</p><p>下面来看看具体如何使用，这里我以 Pulsar 源码的代码进行演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InstrumentProvider</span><span class="params">(OpenTelemetry otel)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (otel == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// By default, metrics are disabled, unless the OTel java agent is configured.  </span></span><br><span class="line">        <span class="comment">// This allows to enable metrics without any code change.        otel = GlobalOpenTelemetry.get();  </span></span><br><span class="line">    &#125;    <span class="built_in">this</span>.meter = otel.getMeterProvider()  </span><br><span class="line">            .meterBuilder(<span class="string">&quot;org.apache.pulsar.client&quot;</span>)  </span><br><span class="line">            .setInstrumentationVersion(PulsarVersion.getVersion())  </span><br><span class="line">            .build();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">LongCounterBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> meter.counterBuilder(name)  </span><br><span class="line">        .setDescription(description)  </span><br><span class="line">        .setUnit(unit.toString());</span><br></pre></td></tr></table></figure><h2 id="Meter-Exporter"><a href="#Meter-Exporter" class="headerlink" title="Meter Exporter"></a>Meter Exporter</h2><p>Meter Exporter 则是一个 OpenTelemetry 独有的概念，与我们之前讲到的一样：OpenTelemetry 作为厂商无关的平台，允许我们将数据写入到任何兼容的产品里。</p><p>所以我们在使用 Metrics 时需要指定一个 exporter：</p><table><thead><tr><th>Exporter 类型</th><th>作用</th><th>备注</th><th>参数</th></tr></thead><tbody><tr><td>OTLP Exporter</td><td>通过 OpenTelemetry Protocol（OTLP） 发送指标数据到 collect。</td><td>默认生产环境中推荐使用，需要将数据发送到支持 OTLP 的后端，如 OpenTelemetry Collector。</td><td>-Dotel.metrics.exporter&#x3D;otlp (default)</td></tr><tr><td>Console Exporter</td><td>将指标数据打印到控制台的导出器。</td><td>开发和调试，快速查看指标数据。</td><td>-Dotel.metrics.exporter&#x3D;console</td></tr><tr><td>Prometheus Exporter</td><td>将指标数据以 Prometheus 抓取的格式暴露给 Prometheus 服务。</td><td>与 Prometheus 集成，适用于需要 Prometheus 监控的场景，这个可以无缝和以往使用 prometheus 的场景兼容</td><td>-Dotel.metrics.exporter&#x3D;prometheus</td></tr></tbody></table><h2 id="Metric-Instruments"><a href="#Metric-Instruments" class="headerlink" title="Metric Instruments"></a>Metric Instruments</h2><p>与 prometheus 类似，OpenTelemetry 也提供了以下几种指标类型：</p><ul><li><strong>Counter</strong>：单调递增计数器，比如可以用来记录订单数、总的请求数。</li><li><strong>UpDownCounter</strong>：与 Counter 类似，只不过它可以递减。</li><li><strong>Gauge</strong>：用于记录随时在变化的值，比如内存使用量、CPU 使用量等。</li><li><strong>Histogram</strong>：通常用于记录请求延迟、响应时间等。</li></ul><p>同时每个指标还有以下几个字段：</p><ul><li>Name：名称，必填。</li><li>Kind：类型，必填。</li><li>Unit：单位，可选。</li><li>Description：描述，可选。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">messageInCounter = meter  </span><br><span class="line">        .counterBuilder(MESSAGE_IN_COUNTER)  </span><br><span class="line">        .setUnit(<span class="string">&quot;&#123;message&#125;&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;The total number of messages received for this topic.&quot;</span>)  </span><br><span class="line">        .buildObserver();</span><br></pre></td></tr></table></figure><p>还是以 Pulsar 的为例，<code>messageInCounter</code> 是一个记录总的消息接收数量的 Counter 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subscriptionCounter = meter  </span><br><span class="line">        .upDownCounterBuilder(SUBSCRIPTION_COUNTER)  </span><br><span class="line">        .setUnit(<span class="string">&quot;&#123;subscription&#125;&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;The number of Pulsar subscriptions of the topic served by this broker.&quot;</span>)  </span><br><span class="line">        .buildObserver();</span><br></pre></td></tr></table></figure><p>这是记录一个订阅者数量的指标，类型是 UpDownCounter，也就是可以增加减少的指标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Double&gt; latencyHistogramBuckets =  </span><br><span class="line">        Lists.newArrayList(<span class="number">.0005</span>, <span class="number">.001</span>, <span class="number">.0025</span>, <span class="number">.005</span>, <span class="number">.01</span>, <span class="number">.025</span>, <span class="number">.05</span>, <span class="number">.1</span>, <span class="number">.25</span>, <span class="number">.5</span>, <span class="number">1.0</span>, <span class="number">2.5</span>, <span class="number">5.0</span>, <span class="number">10.0</span>, <span class="number">30.0</span>, <span class="number">60.0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">DoubleHistogramBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> meter.histogramBuilder(<span class="string">&quot;pulsar.client.producer.message.send.duration&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;Publish latency experienced by the application, includes client batching time&quot;</span>)  </span><br><span class="line">        .setUnit(Unit.Seconds.toString())  </span><br><span class="line">        .setExplicitBucketBoundariesAdvice(latencyHistogramBuckets);</span><br></pre></td></tr></table></figure><p>这是一个记录 Pulsar producer 发送延迟的指标，类型是 <code>Histogram</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">backlogQuotaAge = meter  </span><br><span class="line">        .gaugeBuilder(BACKLOG_QUOTA_AGE)  </span><br><span class="line">        .ofLongs()  </span><br><span class="line">        .setUnit(<span class="string">&quot;s&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;The age of the oldest unacknowledged message (backlog).&quot;</span>)  </span><br><span class="line">        .buildObserver();</span><br></pre></td></tr></table></figure><p>这是一个记录最大 unack 也就是 backlog 时间的指标，类型是 <code>Gauge</code>。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>在之前的文章：<a href="https://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/">实战：如何编写一个 OpenTelemetry Extensions</a>中讲过如何开发一个 OpenTelemetry 的 extension，其实当时我就是开发了一个用于在 Pulsar 客户端中暴露指标的一个插件。</p><blockquote><p>不过目前 Pulsar 社区已经集成了该功能。</p></blockquote><p>其中的核心代码与上面讲到的类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerObservers</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="type">Meter</span> <span class="variable">meter</span> <span class="operator">=</span> MetricsRegistration.getMeter();    </span><br><span class="line">    </span><br><span class="line">    meter.gaugeBuilder(<span class="string">&quot;pulsar_producer_num_msg_send&quot;</span>)    </span><br><span class="line">            .setDescription(<span class="string">&quot;The number of messages published in the last interval&quot;</span>)    </span><br><span class="line">            .ofLongs()    </span><br><span class="line">            .buildWithCallback(    </span><br><span class="line">                    r -&gt; recordProducerMetrics(r, ProducerStats::getNumMsgsSent));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recordProducerMetrics</span><span class="params">(ObservableLongMeasurement observableLongMeasurement, Function&lt;ProducerStats, Long&gt; getter)</span> &#123;    </span><br><span class="line">    <span class="keyword">for</span> (Producer producer : CollectionHelper.PRODUCER_COLLECTION.list()) &#123;    </span><br><span class="line">        <span class="type">ProducerStats</span> <span class="variable">stats</span> <span class="operator">=</span> producer.getStats();    </span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> producer.getTopic();    </span><br><span class="line">        <span class="keyword">if</span> (topic.endsWith(RetryMessageUtil.RETRY_GROUP_TOPIC_SUFFIX)) &#123;    </span><br><span class="line">            <span class="keyword">continue</span>;    </span><br><span class="line">        &#125;        observableLongMeasurement.record(getter.apply(stats),    </span><br><span class="line">                Attributes.of(PRODUCER_NAME, producer.getProducerName(), TOPIC, topic));    </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>只是这里使用了 <code>buildWithCallback</code> 回调函数，OpenTelemetry 会每隔 30s 调用一次这个函数，通常适用于 Gauge 类型的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent.jar \  </span><br><span class="line">     -Dotel.javaagent.extensions=ext.jar  \</span><br><span class="line">     -Dotel.metrics.exporter=prometheus \</span><br><span class="line">     -Dotel.exporter.prometheus.port=<span class="number">18180</span> \</span><br><span class="line">     -jar myapp.jar</span><br></pre></td></tr></table></figure><p>配合上 Prometheus 的两个启动参数就可以在本地 18180 中获取到指标数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:18180/metrics</span><br></pre></td></tr></table></figure><p>当然也可以直接发往 OpenTelemetry-Collector 中，再由它发往 prometheus，只是这样需要额外在 collector 中配置一下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">exporters:</span></span><br><span class="line">  <span class="attr">debug:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">otlphttp:</span></span><br><span class="line">    <span class="attr">metrics_endpoint:</span> <span class="string">http://promethus:8480/insert/0/opentelemetry/api/v1/push</span></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">pipelines:</span></span><br><span class="line">    <span class="attr">metrics:</span></span><br><span class="line">      <span class="attr">exporters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlphttp</span></span><br><span class="line">      <span class="attr">processors:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">k8sattributes</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">batch</span></span><br><span class="line">      <span class="attr">receivers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlp</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/12/4iMpax5Ptod2Nws.png"></p><p>这样我们就可以在 Grafana 中通过 prometheus 查询到数据了。</p><p>有一点需要注意，如果我们自定义的指标最好是参考官方的<a href="https://opentelemetry.io/docs/specs/semconv/general/metrics/">语义和命名规范</a>来定义这些指标名称。</p><p><img src="https://s2.loli.net/2024/05/12/vCDZY3ygX7MrzGH.png"></p><p>比如 OpenTelemetry 的规范中名称是用 <strong>.</strong> 来进行分隔的。</p><blockquote><p>切换为 OpenTelemetry 之后自然就不需要依赖 prometheus 的包，取而代之的是 OTel 的包：</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compileOnly <span class="string">&#x27;io.opentelemetry:opentelemetry-sdk-extension-autoconfigure-spi:1.34.1&#x27;</span>  </span><br><span class="line">compileOnly <span class="string">&#x27;io.opentelemetry.instrumentation:opentelemetry-instrumentation-api:1.32.0&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相对来说 Metrics 的使用比 Trace 简单的多，同时 Metrics 其实也可以和 Trace 进行关联，也就是 <a href="https://opentelemetry.io/docs/specs/otel/metrics/data-model/#exemplars">Exemplars</a>，限于篇幅就不在本文展开了，感兴趣的可以自行查阅。</p><p>参考链接：</p><ul><li><a href="https://github.com/apache/pulsar/blob/master/pulsar-client/src/main/java/org/apache/pulsar/client/impl/metrics/InstrumentProvider.java">https://github.com/apache/pulsar/blob/master/pulsar-client/src/main/java/org/apache/pulsar/client/impl/metrics/InstrumentProvider.java</a></li><li><a href="https://opentelemetry.io/docs/specs/semconv/general/metrics/">https://opentelemetry.io/docs/specs/semconv/general/metrics/</a></li><li><a href="https://opentelemetry.io/docs/specs/otel/metrics/data-model/#exemplars">https://opentelemetry.io/docs/specs/otel/metrics/data-model/#exemplars</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一篇：&lt;a href=&quot;https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/&quot;&gt;从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅&lt;/a&gt;我们讲解了 Trace 的一些核心概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trace&lt;/li&gt;
&lt;li&gt;Span&lt;/li&gt;
&lt;li&gt;Context&lt;/li&gt;
&lt;li&gt;Baggage 等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这次我们来讲另一个话题 &lt;code&gt;Metrics&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
  </entry>
  
  <entry>
    <title>从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅</title>
    <link href="http://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/"/>
    <id>http://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/</id>
    <published>2024-06-05T16:55:16.000Z</published>
    <updated>2024-06-06T13:00:48.174Z</updated>
    
    <content type="html"><![CDATA[<p>在之前写过两篇比较系统的关于 OpenTelemetry 的文章：</p><ul><li><a href="https://juejin.cn/post/7358450927110357026">OpenTelemetry 实践指南：历史、架构与基本概念</a></li><li><a href="https://juejin.cn/post/7360216766373068837">实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术</a></li></ul><p>从基本概念到如何部署 demo 实战了解 OpenTelemetry，从那个 demo 中也可以得知整个 OpenTelemetry 体系的复杂性，包含了太多的组件和概念。</p><p>为了能更清晰的了解每个关键组件的作用以及原理，我打算分为几期来讲解 OpenTelemetry 的三个核心组件：</p><ul><li>Trace</li><li>Metrics</li><li>Logs</li></ul><p>首先以 Trace 讲起。</p><span id="more"></span><h1 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h1><p>开始之前还是先复习一下 Trace 的历史背景。</p><p>如今现代的分布式追踪的起源源自于 Google 在 2010 年发布的一篇论文：</p><ul><li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf">Dapper, a Large-Scale Distributed Systems Tracing Infrastructure</a></li></ul><p>在这篇论文中提出了分布式追踪的几个核心概念：</p><ul><li>Trace</li><li>Span<ul><li>Span 的一些基础数据结构</li></ul></li><li>可视化追踪以及展示</li></ul><p>之后 Twitter 受到了 Dapper 的启发开源了现在我们熟知的 <a href="https://zipkin.io/">Zipkin</a>，包含了存储和可视化 UI 展示我们的追踪链路。</p><p>Uber 也在 2015 年开源了 <a href="https://www.jaegertracing.io/">Jaeger</a> 项目，它的功能和 Zipkin 类似，但目前我们用的较多的还是 Jaeger；现在已经成为 CNCF 的托管项目。</p><p>之后陆续出现过 <strong>OpenTracing</strong> 和 <strong>OpenCensus</strong> 项目，他们都企图统一分布式追踪这一领域。</p><p>直到 <code>OpenTelemetry</code> 的出现整合了以上两个项目，并且逐渐成为可观测领域的标准。</p><blockquote><p>更多历史背景可以参考之前的文章：<a href="https://juejin.cn/post/7358450927110357026">OpenTelemetry 实践指南：历史、架构与基本概念</a></p></blockquote><p><img src="https://s2.loli.net/2024/05/05/ljQ6yNhKzn3b1c9.png"></p><p><img src="https://s2.loli.net/2024/05/05/NOEbTamR67x83nS.png"></p><p>这里我们结合 Dapper 论文中的资料进行分析，在这个调用中用户发起了一次请求，内部系统经历了 4 次 RPC 调用。</p><p>从第二张图会看到一些关键信息：</p><ul><li>spanName</li><li>parentId</li><li>spanId</li></ul><p>parentId 很好理解，主要是定义调用的主次关系；要注意的是并行调用时 parentId 是同一个。</p><p>spanId 在可以理解为每一个独立的操作，在这里就是一次 RPC 调用；同理一次数据库操作、消息的收发都是一个 span。</p><blockquote><p>span 的更多内容在后文继续讲解。</p></blockquote><h1 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h1><p><img src="https://s2.loli.net/2024/05/05/wyzLpbhYkjOUFav.png"><br>当我们把某一个具体的 span 放大会看到更加详细的信息，其中最关键的如下：</p><ul><li>traceId</li><li>spanName</li><li>spanId</li><li>parentId</li><li>开始时间</li><li>结束时间</li></ul><p>由于一个完整的 trace 链路由 N 个 span 组成，所以这个链路必须得有一个唯一的 traceId 将这些 span 串联起来。<br>这样才可以在可视化的时候更好的展示链路信息。</p><p>以上的这些字段很容易理解，都是一些必须的信息。</p><p>在 Dapper 论文中使用 Annotations 来存放 span 的属性，也就是刚才那些字段，当然也可以自定义存放一些数据，比如图中的 <code>&quot;foo&quot;</code>。</p><h2 id="OpenTelemetry-中的-Span"><a href="#OpenTelemetry-中的-Span" class="headerlink" title="OpenTelemetry 中的 Span"></a>OpenTelemetry 中的 Span</h2><p>OpenTelemetry 的 trace 自然也是基于 Dapper 的，只是额外做了一些优化，比如在刚才那些字段的基础上新增了一些概念：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/v1/sys/health&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;context&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;trace_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7bba9f33312b3dbb8b2c2c62bb7abe2d&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;span_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;086e83747d0e381e&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parent_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;start_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-10-22 16:04:01.209458162 +0000 UTC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;end_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-10-22 16:04:01.209514132 +0000 UTC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;STATUS_CODE_OK&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status_message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;net.transport&quot;</span><span class="punctuation">:</span> <span class="string">&quot;IP.TCP&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.peer.ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.17.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.peer.port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;51820&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.host.ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.177.2.152&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.host.port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;26040&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GET&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/v1/sys/health&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.server_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mortar-gateway&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.route&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/v1/sys/health&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.user_agent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Consul Health Check&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.scheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.177.2.152:26040&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.flavor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;events&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OK&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-10-22 16:04:01.209512872 +0000 UTC&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以这个 JSON 为例，新增了：</p><ul><li><input disabled="" type="checkbox"> <code>Span Context</code><ul><li><code>Span</code> 的上下文，存放的都是不可变的数据，因为每个 Span 之间是存在关联关系的，这些关联关系都是存放在 context 中，主要就是 trace_id, span_id.</li></ul></li><li><code>Attributes</code>: 可以理解为 Dapper 中的 Annotations，存放的是我们自定义的键值对，通常是由我们常用第三方开源 Instrumentation 内置的一些属性。</li><li><code>Span Events</code>: Span 的一些关键事件。</li></ul><p><img src="https://s2.loli.net/2024/05/05/3C49thIJOZTuf82.png"><br>比如我们常用的 Redis 客户端 lettuce，它就会自己记录一些 Attributes。</p><hr><p>如果有多个 span 存在依赖关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       [Span A]  ←←←(the root span)</span><br><span class="line">           |</span><br><span class="line">    +------+------+</span><br><span class="line">    |             |</span><br><span class="line">[Span B]      [Span C] ←←←(Span C is a `child` of Span A)</span><br><span class="line">    |             |</span><br><span class="line">[Span D]      +---+-------+</span><br><span class="line">              |           |</span><br><span class="line">          [Span E]    [Span F]</span><br></pre></td></tr></table></figure><p>大部分的可视化工具都是以时间线的方式进行展示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–&gt; time</span><br><span class="line"></span><br><span class="line"> [Span A···················································]</span><br><span class="line">   [Span B··········································]</span><br><span class="line">      [Span D······································]</span><br><span class="line">    [Span C····················································]</span><br><span class="line">         [Span E·······]        [Span F··]</span><br></pre></td></tr></table></figure><p>这些和 Dapper 中描述的概念没有本质区别。</p><hr><h3 id="Span-Status"><a href="#Span-Status" class="headerlink" title="Span Status"></a>Span Status</h3><p>Span 还内置了一些 Status：</p><ul><li><code>Unset</code></li><li><code>Error</code></li><li><code>Ok</code></li></ul><p>默认情况下是 Unset，出现错误时则是 Error，一切正常时则是 Ok。</p><p><img src="https://s2.loli.net/2024/05/05/glkIuxbFDBcai36.png"><br>通过可视化页面很容易得知某个 trace 中 span 的异常情况，点进去后可以看到具体的异常 span 以及它的错误日志。</p><h3 id="Span-Kind"><a href="#Span-Kind" class="headerlink" title="Span Kind"></a>Span Kind</h3><p>最后是 Span 的类型：</p><ul><li>Client</li><li>Server</li><li>Internal</li><li>Producer</li><li>Consumer</li></ul><p><img src="https://s2.loli.net/2024/05/05/rMjV9qsveNEKORW.png"></p><p>Client 和 Server 非常好理解，比如我们有一个 gRPC 接口，调用方的 Span 是 client，而服务端的 Span 自然就是 Server。</p><p>Internal 则是内部组件调用产生的 Span，这类 Span 相对会少一些。</p><p>Producer 和 Consumer 一般指的是发起异步调用时的 Span，我们常见的就是往消息队列里生产和消费消息。</p><p>通过这几种类型的 Span 也可以了解到什么情况下会创建 Span，通常是以下几种场景：</p><ul><li>RPC 调用</li><li>数据库（Redis、MySQL、Mongo 等等）操作</li><li>生产和消费消息</li><li>有意义的内部调用</li></ul><p>通常在一个函数内部再调用其他的本地函数是不用创建 span 的，不然这个链路会非常的长。</p><h2 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h2><p>当然也有一些特殊情况，比如我的某个内部函数非常重要，需要单独关心它的调用时长。</p><p>此时我们就可以使用 Annotations 来单独创建自己的 Span。</p><blockquote><p>这个 Annotations 和 Dapper 中的不是同一个，只是 Java 中的注解。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;  </span><br><span class="line">    Executors.newFixedThreadPool(<span class="number">1</span>).execute(() -&gt; &#123;  </span><br><span class="line">        myMethod(request.getName());  </span><br><span class="line">    &#125;);    </span><br><span class="line">    </span><br><span class="line">    <span class="type">HelloReply</span> <span class="variable">reply</span> <span class="operator">=</span> HelloReply.newBuilder()  </span><br><span class="line">            .setMessage(<span class="string">&quot;Hello ==&gt; &quot;</span> + request.getName())  </span><br><span class="line">            .build();  </span><br><span class="line">    responseObserver.onNext(reply);  </span><br><span class="line">    responseObserver.onCompleted();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@SneakyThrows</span>  </span><br><span class="line"><span class="meta">@WithSpan</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">(<span class="meta">@SpanAttribute(&quot;request.name&quot;)</span> String name)</span> &#123;  </span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);  </span><br><span class="line">    log.info(<span class="string">&quot;myMethod:&#123;&#125;&quot;</span>, name);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这段代码为例，这是一个 gRPC 的服务端接口，在这个接口中调用了一个函数 <code>myMethod</code>，默认情况下并不会为它单独创建一个 Span。</p><p>但如果我们想单独记录它，就可以使用 <code>@WithSpan</code> 这个注解，同时也可以使用  <code>@SpanAttribute</code> 来自定义 attribute。</p><p>最终的效果如下：<br><img src="https://s2.loli.net/2024/05/05/aBd1ubsS2kxMzGf.png"><br>此时就会单独为这个函数创建一个 Span。</p><blockquote><p>需要单独引入一个依赖:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.opentelemetry.instrumentation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opentelemetry-instrumentation-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Context-Propagation"><a href="#Context-Propagation" class="headerlink" title="Context Propagation"></a>Context Propagation</h1><p>上下文传播也是 Trace 中非常重要的概念，刚才提到了每个 Span 都有自己不可变的上下文，那么后续的 Span 如何和上游的 Span 进行关联呢？</p><p>这里有两种情况：</p><ul><li>同一进程</li><li>垮进程</li></ul><h2 id="同一进程"><a href="#同一进程" class="headerlink" title="同一进程"></a>同一进程</h2><p>同一个进程也分为两种情况：</p><ul><li>单线程</li><li>多线程</li></ul><p>单线程的比较好处理，我们只需要把数据写入 <code>ThreadLocal</code> 中就可以做到线程隔离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Context&gt; THREAD_LOCAL_STORAGE = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line"><span class="keyword">public</span> Context <span class="title function_">current</span><span class="params">()</span> &#123;  </span><br><span class="line">  <span class="keyword">return</span> THREAD_LOCAL_STORAGE.get();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这点我们可以通过源码 <code>io.opentelemetry.context.ThreadLocalContextStorage</code>看到具体的实现过程。</p><p>而如果是多线程时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executors.newFixedThreadPool(<span class="number">1</span>).execute(() -&gt; &#123;  </span><br><span class="line">    myMethod(request.getName());  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>则需要对使用的线程池进行单独处理，将父线程中 threadlocal 中的数据拷贝出来进行传递，比如有阿里提供的 <code>TransmittableThreadLocal</code>，可以提供对线程池的支持。</p><h2 id="跨进程"><a href="#跨进程" class="headerlink" title="跨进程"></a>跨进程</h2><p>而如果是垮进程的场景，就需要将 context 的信息进行序列化传递。</p><p>如果是 gRPC 调用会将信息存放到 metadata 中。</p><p>HTTP 调用则是存放在 header 中。</p><p>消息队列，比如 Pulsar 也可以将数据存放在消息中的 header 中进行传递。</p><p>数据一旦跨进程传输成功后，就和单进程一样的处理方式了。</p><h2 id="Baggage"><a href="#Baggage" class="headerlink" title="Baggage"></a>Baggage</h2><p><img src="https://s2.loli.net/2024/05/05/3c6LNtIbSkpQlRU.png"></p><p>有时候我们需要通过垮 Span 传递信息，比如如上图所示：<br>我们需要在 serverB 中拿到 serverA 中收到的一个请求参数： <code>http://127.0.0.1:8181/request\?name\=1232</code></p><p><img src="https://s2.loli.net/2024/05/05/hISQNv91KP85WFC.png"></p><p>这个数据默认会作为 span 的 attribute ，但只会存在于第一个 span。</p><p>如果我们想要在后续的 span 中也能拿到这个数据，甚至是垮进程也能获取到。</p><p>那就需要使用 <code>Baggage</code> 这个对象了。</p><p>它的使用也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/request&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;  </span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">    Baggage.current().toBuilder().  </span><br><span class="line">          put(<span class="string">&quot;request.name&quot;</span>, name).build()  </span><br><span class="line">          .storeInContext(Context.current()).makeCurrent();</span><br><span class="line">&#125;         </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> Baggage.current().getEntryValue(<span class="string">&quot;request.name&quot;</span>);  </span><br><span class="line">log.info(<span class="string">&quot;request.name: &#123;&#125;&quot;</span>, value);</span><br></pre></td></tr></table></figure><p>只要是属于同一个 trace 的调用就可以直接获取到数据。<br><img src="https://s2.loli.net/2024/05/05/Lz1hY8pflRebANx.png"></p><blockquote><p>traceId 也是垮 Span 传递的。</p></blockquote><p>而它的原理也是通过往 context 中写入数据实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span>  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaggageContextKey</span> &#123;  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ContextKey&lt;Baggage&gt; KEY = ContextKey.named(<span class="string">&quot;opentelemetry-baggage-key&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">BaggageContextKey</span><span class="params">()</span> &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/05/vIHtBxGATKOg13l.png"><br>而这个 context 是通过一个 entries 数据存储数据的，不管是在内部还是外部的跨进程调用，OpenTelemetry 都会将 context 通过 <code>Context Propagation</code> 传递出去。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Trace 这部分的内容我觉得比 Metrics 和 Logs 更加复杂一些，毕竟多了一些数据结构；现在的内容也只是冰山一角，现在也在做 trace 的一些定制化开发，后续有新的进展会接着更新。</p><p>参考链接：</p><ul><li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf">https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf</a></li><li><a href="https://opentelemetry.io/docs/languages/java/automatic/annotations/">https://opentelemetry.io/docs/languages/java/automatic/annotations/</a></li><li><a href="https://opentelemetry.io/docs/specs/otel/overview/#tracing-signal">https://opentelemetry.io/docs/specs/otel/overview/#tracing-signal</a></li><li><a href="https://opentelemetry.io/docs/concepts/context-propagation/">https://opentelemetry.io/docs/concepts/context-propagation/</a></li><li><a href="https://opentelemetry.io/docs/concepts/observability-primer/#distributed-traces">https://opentelemetry.io/docs/concepts/observability-primer/#distributed-traces</a></li><li><a href="https://tech.meituan.com/2023/04/20/traceid-google-dapper-mtrace.html">https://tech.meituan.com/2023/04/20/traceid-google-dapper-mtrace.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前写过两篇比较系统的关于 OpenTelemetry 的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7358450927110357026&quot;&gt;OpenTelemetry 实践指南：历史、架构与基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7360216766373068837&quot;&gt;实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从基本概念到如何部署 demo 实战了解 OpenTelemetry，从那个 demo 中也可以得知整个 OpenTelemetry 体系的复杂性，包含了太多的组件和概念。&lt;/p&gt;
&lt;p&gt;为了能更清晰的了解每个关键组件的作用以及原理，我打算分为几期来讲解 OpenTelemetry 的三个核心组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trace&lt;/li&gt;
&lt;li&gt;Metrics&lt;/li&gt;
&lt;li&gt;Logs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先以 Trace 讲起。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>【译】几个你或许并不知道 kubernetes 技巧</title>
    <link href="http://crossoverjie.top/2024/06/03/ob/Kubernetes-tricks/"/>
    <id>http://crossoverjie.top/2024/06/03/ob/Kubernetes-tricks/</id>
    <published>2024-06-03T10:05:25.000Z</published>
    <updated>2024-06-03T13:10:27.508Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/06/03/AoNyHhS4sl96tFx.png"></p><p>原文链接: <a href="https://overcast.blog/13-kubernetes-tricks-you-didnt-know-647de6364472">https://overcast.blog/13-kubernetes-tricks-you-didnt-know-647de6364472</a></p><h1 id="使用-PreStop-优雅关闭-Pod"><a href="#使用-PreStop-优雅关闭-Pod" class="headerlink" title="使用 PreStop 优雅关闭 Pod"></a>使用 PreStop 优雅关闭 Pod</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">graceful-shutdown-example</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sample-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;sleep 30 &amp;&amp; nginx -s quit&quot;</span>]</span><br></pre></td></tr></table></figure><p>PreStop 允许 Pod 在终止前执行一个命令或者是脚本，使用它就可以在应用退出前释放一些资源，确保应用可以优雅退出。</p><p>比如可以在 Nginx 的 Pod 退出前将当前的请求执行完毕。</p><span id="more"></span><h1 id="使用临时容器调试-Pod"><a href="#使用临时容器调试-Pod" class="headerlink" title="使用临时容器调试 Pod"></a>使用临时容器调试 Pod</h1><p>临时容器可以不修改一个运行的容器的前提下调试容器，可以很方便的调试一些生产环境的 bug，可以避免重启应用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl alpha debug -it podname --image=busybox --target=containername</span><br></pre></td></tr></table></figure><p>生产环境谨慎使用，只有在当前环境下无法排查问题的时候才使用。</p><h1 id="基于自定义的-Metrics-自动扩容Pod"><a href="#基于自定义的-Metrics-自动扩容Pod" class="headerlink" title="基于自定义的  Metrics 自动扩容Pod"></a>基于自定义的  Metrics 自动扩容Pod</h1><p>kubernetes 是提供了 HPA 机制可以跟进 CPU 内存等标准数据进行自动扩缩容，但有时我们需要根据自定义的数据进行扩缩容。</p><p>比如某个接口的延迟、队列大小等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">custom-metric-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">your-application</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span></span><br><span class="line">    <span class="attr">pods:</span></span><br><span class="line">      <span class="attr">metric:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">your_custom_metric</span></span><br><span class="line">      <span class="attr">target:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">AverageValue</span></span><br><span class="line">        <span class="attr">averageValue:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="用-Init-Containers-配置启动脚本"><a href="#用-Init-Containers-配置启动脚本" class="headerlink" title="用 Init Containers 配置启动脚本"></a>用 Init Containers 配置启动脚本</h1><p>初始化容器可以在应用容器启动前运行，我们可以使用它来初始化应用需要的配置、等待依赖的服务启动完成等工作：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-myservice</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;</span>]</span><br></pre></td></tr></table></figure><p>比如这个初始化容器会等待 myservice 可用后才会启动应用。</p><p>需要注意的是如果初始化容器会阻塞应用启动，所以要避免在初始化容器里执行耗时操作。</p><h1 id="Node-亲和性调度"><a href="#Node-亲和性调度" class="headerlink" title="Node 亲和性调度"></a>Node 亲和性调度</h1><p>当我们需要将某些应用部署到硬件配置较高的节点时（比如需要 SSD 硬盘），就可以使用节点亲和性来部署应用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">with-node-affinity</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">with-node-affinity</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">disktype</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ssd</span></span><br></pre></td></tr></table></figure><p>这个 Pod 会被部署到有这个 <code>disktype=ssd</code> 标签的 节点上。</p><h1 id="动态配置：ConfigMap-和-Secrets"><a href="#动态配置：ConfigMap-和-Secrets" class="headerlink" title="动态配置：ConfigMap 和 Secrets"></a>动态配置：ConfigMap 和 Secrets</h1><p>ConfigMap 和 Secrets可以动态注入到 Pod 中，避免对这些配置硬编码。</p><p>ConfigMap 适合非敏感的数据，Secrets 适合敏感的数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ConfigMap Example</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">config.json:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;key&quot;: &quot;value&quot;,</span></span><br><span class="line"><span class="string">      &quot;databaseURL&quot;: &quot;http://mydatabase.example.com&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="comment"># Pod Spec using ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">myapp</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">app-config</span></span><br></pre></td></tr></table></figure><p>这样在应用中就可以通过这路径 <code>/etc/config/config.json</code> 读取数据了。</p><blockquote><p>当然也可以把这些数据写入到环境变量中。</p></blockquote><p>以上这些个人技巧用的最多的是：</p><ul><li>临时容器调试 Pod，特别是业务容器缺少一些命令时。</li><li>Init Container 等待依赖的服务启动完成。</li><li>Node 亲和性调度。</li><li>ConfigMap 是基础操作了。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/06/03/AoNyHhS4sl96tFx.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&quot;https://overcast.blog/13-kubernetes-tricks-you-didnt-know-647de6364472&quot;&gt;https://overcast.blog/13-kubernetes-tricks-you-didnt-know-647de6364472&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;使用-PreStop-优雅关闭-Pod&quot;&gt;&lt;a href=&quot;#使用-PreStop-优雅关闭-Pod&quot; class=&quot;headerlink&quot; title=&quot;使用 PreStop 优雅关闭 Pod&quot;&gt;&lt;/a&gt;使用 PreStop 优雅关闭 Pod&lt;/h1&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;apiVersion:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;v1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kind:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;Pod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;metadata:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;graceful-shutdown-example&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;spec:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;containers:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;sample-container&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;image:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;nginx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;lifecycle:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;preStop:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;exec:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;attr&quot;&gt;command:&lt;/span&gt; [&lt;span class=&quot;string&quot;&gt;&amp;quot;/bin/sh&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;-c&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;sleep 30 &amp;amp;&amp;amp; nginx -s quit&amp;quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;PreStop 允许 Pod 在终止前执行一个命令或者是脚本，使用它就可以在应用退出前释放一些资源，确保应用可以优雅退出。&lt;/p&gt;
&lt;p&gt;比如可以在 Nginx 的 Pod 退出前将当前的请求执行完毕。&lt;/p&gt;</summary>
    
    
    
    <category term="翻译" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="kubernetes" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/kubernetes/"/>
    
    
    <category term="kubernetes" scheme="http://crossoverjie.top/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术</title>
    <link href="http://crossoverjie.top/2024/05/26/ob/OTel-demo/"/>
    <id>http://crossoverjie.top/2024/05/26/ob/OTel-demo/</id>
    <published>2024-05-26T02:49:02.000Z</published>
    <updated>2024-05-26T11:35:45.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇文章 <a href="https://crossoverjie.top/2024/05/21/ob/OpenTelemetry-getstart/">OpenTelemetry 实践指南：历史、架构与基本概念</a>中回顾了可观测性的历史以及介绍了一些 OpenTelemetry 的基础概念，同时也介绍了 OpenTelemetry 社区常用的开源项目。</p><p>基础背景知识了解后，这篇就来介绍一下使用 OpenTelemetry 如何实战部署应用，同时在一个可视化页面查看 trace、metric 等信息。</p><span id="more"></span><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>我们参考官方文档构建几个 spring boot 、Golang 项目再配合 Agent 其实也可以很方便的集成 OpenTelemetry。</p><p>但是要完整的体验 OpenTelemetry 的所有功能，包含 trace、logs、metrics，还有社区这么多语言的支持其实还是比较麻烦的。</p><p>我们还需要单独部署 collector、存储的 backend service 等组件、包括 trace UI 展示所需要的 Jaeger，metric 所需要的 grafana 等。</p><p>这些所有东西都自己从头弄的话还是比较费时，不过好在社区已经将这些步骤都考虑到了。</p><p>特地为大家写了一个 <a href="https://github.com/open-telemetry/opentelemetry-demo">opentelemetry-demo</a>。</p><p>这个项目模拟了一个微服务版本的电子商城，主要包含了以下一些项目：</p><table><thead><tr><th>Service</th><th>Language</th><th>Description</th></tr></thead><tbody><tr><td><a href="accounting/">accountingservice</a></td><td>Go</td><td>处理和计算订单数据</td></tr><tr><td><a href="ad/">adservice</a></td><td>Java</td><td>广告服务</td></tr><tr><td><a href="cart/">cartservice</a></td><td>.NET</td><td>购物车服务，主要会依赖 Redis</td></tr><tr><td><a href="checkout/">checkoutservice</a></td><td>Go</td><td>checkout</td></tr><tr><td><a href="currency/">currencyservice</a></td><td>C++</td><td>货币转换服务，提供了较高的 QPS 能力。</td></tr><tr><td><a href="email/">emailservice</a></td><td>Ruby</td><td>邮件服务</td></tr><tr><td><a href="fraud-detection/">frauddetectionservice</a></td><td>Kotlin</td><td>风控服务</td></tr><tr><td><a href="frontend/">frontend</a></td><td>JavaScript</td><td>前端应用</td></tr><tr><td><a href="load-generator/">loadgenerator</a></td><td>Python&#x2F;Locust</td><td>模拟压测服务</td></tr><tr><td><a href="payment/">paymentservice</a></td><td>JavaScript</td><td>支付服务</td></tr><tr><td><a href="product-catalog/">productcatalogservice</a></td><td>Go</td><td>商品服务</td></tr><tr><td><a href="quote/">quoteservice</a></td><td>PHP</td><td>成本服务</td></tr><tr><td><a href="recommendation/">recommendationservice</a></td><td>Python</td><td>推荐服务</td></tr><tr><td><a href="shipping/">shippingservice</a></td><td>Rust</td><td>shipping service</td></tr><tr><td>可以发现在这个 demo 中提供了许多的服务，而且包含了几乎所有主流的语言，可以很好的模拟我们实际的使用场景了。</td><td></td><td></td></tr></tbody></table><p><img src="https://s2.loli.net/2024/04/20/NahleoLGbv9tSuE.png"></p><p>通过这张图可以更直观的查看各个服务之间的关系。</p><p>整体来说前端所有的请求都会通过 <code>front-end-proxy</code> 这个组件代理，最终再由 front 这个服务进行转发到不同的后端服务中。</p><hr><p><img src="https://s2.loli.net/2024/04/20/wLVI1mSzYKjt2Fo.png"><br>除了一个项目的架构图之外，还有一个关于 OpenTelemetry 的数据流转图。</p><p>在 OpenTelemetry 中数据流转是它的特点也是非常重要的核心，这点在上一篇文章中讲过，用户可以自由定制数据的流转以及任意的处理数据，在这个图中就将数据流转可视化了。</p><ul><li>客户端可以通过 OTLP 协议或者是 HTTP 将数据上传到 OTel Collector 中。</li><li>在 collector 中会根据我们配置的 Process pipeline 处理数据。</li><li>Metric 数据通过  OTLP HTTP exporter 将数据导入到 Prometheus 中。<ul><li><a href="https://github.com/prometheus/prometheus/pull/12571">Prometheus</a> 已经于 23 年七月份支持 OTLP 格式的 metric 数据导入了。</li></ul></li><li>Trace 数据则是通过 OTLP Exporter 写入到 Jaeger 中进行存储，最后通过 Jaeger 的 UI 进行查询展示。</li><li>而存入 Prometheus 中的 metric 数据则是有 grafana 进行查询。</li></ul><blockquote><p>关于 collector 的配置会在后文讲解。</p></blockquote><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>接下来便是安装 Demo 了，我更推荐使用 helm 安装。</p><p>这里的版本要求是：</p><ul><li>Kubernetes 1.24+</li><li>Helm 3.9+</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm repo add open-telemetry https://open-telemetry.github.io/opentelemetry-helm-charts</span><br><span class="line">helm repo update</span><br><span class="line">helm install my-otel-demo open-telemetry/opentelemetry-demo</span><br></pre></td></tr></table></figure><p>这样就可以很简单的将 demo 所涉及到的所有组件和服务都安装到 default 命名空间中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm show values open-telemetry/opentelemetry-demo &gt; demo.yaml</span><br></pre></td></tr></table></figure><p>不过在安装前还是建议先导出一份 value.yaml，之后可以使用这个 yaml 定制需要安装的组件。</p><p>在这个 yaml 中我们可以看到有哪些组件和服务可以定制：<br><img src="https://s2.loli.net/2024/04/20/oe2S1fr3xPcypB4.png"><br>可以看到这里包含了我们刚才提到的所有服务，以及这些服务所依赖的 Kafka、redis、Prometheus 等中间件，都可以自己进行定制修改。</p><p><img src="https://s2.loli.net/2024/04/20/VP5GvtszWolSBnf.png"><br>当所有的 Pod 都成功运行之后表示安装成功。</p><blockquote><p>正常情况下安装不会有什么问题，最大可能的问题就是镜像拉取失败，此时我们可以先在本地手动 docker pull 下来镜像后再上传到私服，然后修改 deployment 中的镜像地址即可。</p></blockquote><h2 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h2><p>为了方便使用我们可以用这个 demo 进行测试，还需要将 front-proxy 的服务暴露出来可以在本地访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl port-forward svc/my-otel-demo-frontendproxy 8080:8080</span><br></pre></td></tr></table></figure><table><thead><tr><th>Component</th><th>Path</th></tr></thead><tbody><tr><td>Shop 首页</td><td><a href="http://localhost:8080/">http://localhost:8080</a></td></tr><tr><td>Grafana</td><td><a href="http://localhost:8080/grafana">http://localhost:8080/grafana</a></td></tr><tr><td>压测页面</td><td><a href="http://localhost:8080/loadgen">http://localhost:8080/loadgen</a></td></tr><tr><td>Jaeger UI</td><td><a href="http://localhost:8080/jaeger/ui">http://localhost:8080/jaeger/ui</a></td></tr><tr><td>正常情况下就可以打开这些页面进行访问了。</td><td></td></tr></tbody></table><p>不过使用 port-forward 转发的方式只是临时方案，使用 ctrl+c 就会停止暴露服务，所以如果想要一个稳定的访问链接时便可以配置一个 ingress。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">components:</span></span><br><span class="line">  <span class="attr">frontendProxy:</span></span><br><span class="line">    <span class="attr">ingress:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">annotations:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">hosts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">otel-demo.my-domain.com</span></span><br><span class="line">          <span class="attr">paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在之前的 helm 的 value.yaml 中配置即可，本地测试的话需要将这个 host 和 ingress 暴露出来的 IP 进行绑定才可以使用这个域名机进行访问。</p><p>更多关于 ingress 的使用可以参考我之前的文章：</p><ul><li><a href="https://crossoverjie.top/2023/09/15/ob/k8s-Ingress/">k8s入门到实战-使用Ingress</a></li></ul><p>当然简单起见也可以直接将 front-proxy 的 service 类型改为 LoadBalancer。（默认是 ClusterIP 只可以在集群内访问）</p><p>这样就可以直接通过这个 service 的 IP 进行访问了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">components:</span></span><br><span class="line">  <span class="attr">frontendProxy:</span></span><br><span class="line">    <span class="attr">service:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br></pre></td></tr></table></figure><blockquote><p>不过需要注意的是如果 demo 安装完成之后是不可以再次修改 service 的类型的，需要手动这个 service 删掉之后再次新建才可以。</p></blockquote><p> 临时测试使用的话还是推荐直接使用 port-forward 进行转发。</p><h1 id="查看-Trace"><a href="#查看-Trace" class="headerlink" title="查看 Trace"></a>查看 Trace</h1><p>通过之前的项目架构图可以得知，我们在项目首页刷新会直接请求 AdService 来获取广告。</p><p>为了简单起见我们只查询这一链路的调用情况：<br><img src="https://s2.loli.net/2024/04/21/t6a4KvOhSne9yfu.png"></p><p>打开 <a href="http://localhost:8080/jaeger/ui/search">http://localhost:8080/jaeger/ui/search</a> Jeager 的 UI 页面便可以筛选服务，之后点击查找 Traces 就可以列出一段时间内的访问 trace。</p><p><img src="https://s2.loli.net/2024/04/21/v8nVLxweyCO9NMm.png"><br>可以看到这个请求链路是从前端访问到 adService 中的 <code>getAds()</code>接口，然后在这个接口中再访问了 <code>getAdsByCategory</code> 函数。<br><img src="https://s2.loli.net/2024/04/21/3UXmHsCSLFguRZK.png"></p><p>最终在源码中也可以看到符合链路的调用代码。</p><blockquote><p>在刚才的链路图的右下角有一个 spanID，整个 trace 是由这些小的 span 组成，每一个 span 也会有唯一 spanID； trace 也会有一个 traceID 将这些 span 串联起来；更多关于 trace 的内容会在后面的文章进行分析。</p></blockquote><h2 id="查看-Metrics"><a href="#查看-Metrics" class="headerlink" title="查看 Metrics"></a>查看 Metrics</h2><p>我们再打开 grafana 便可以看到刚才访问的 adService 的延迟和接口的 QPS 情况：<br><img src="https://s2.loli.net/2024/04/21/29BlRATOnpkCQwS.png"></p><hr><p>在opentelemetry-collector-data-flow 面板中还可以看到 OpenTelemetry 的数据流转。<br><img src="https://s2.loli.net/2024/04/21/Tbtiv3gzY5xZIH1.png"></p><blockquote><p>更多监控信息可以查看其它的面板。</p></blockquote><p>而刚才面板中的数据流转规则则是在我们的 <a href="https://github.com/open-telemetry/opentelemetry-demo/blob/main/src/otelcollector/otelcol-config.yml">collector</a> 中进行配置的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">receivers:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">protocols:</span></span><br><span class="line">      <span class="attr">grpc:</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">cors:</span></span><br><span class="line">          <span class="attr">allowed_origins:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;http://*&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;https://*&quot;</span></span><br><span class="line">  <span class="attr">httpcheck/frontendproxy:</span></span><br><span class="line">    <span class="attr">targets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">endpoint:</span> <span class="string">http://frontendproxy:$&#123;env:ENVOY_PORT&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">exporters:</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">&quot;jaeger:4317&quot;</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">otlphttp/prometheus:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">&quot;http://prometheus:9090/api/v1/otlp&quot;</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">opensearch:</span></span><br><span class="line">    <span class="attr">logs_index:</span> <span class="string">otel</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">endpoint:</span> <span class="string">&quot;http://opensearch:9200&quot;</span></span><br><span class="line">      <span class="attr">tls:</span></span><br><span class="line">        <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="attr">batch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">connectors:</span></span><br><span class="line">  <span class="attr">spanmetrics:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">pipelines:</span></span><br><span class="line">    <span class="attr">traces:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">otlp</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">otlp</span>, <span class="string">debug</span>, <span class="string">spanmetrics</span>]</span><br><span class="line">    <span class="attr">metrics:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">httpcheck/frontendproxy</span>, <span class="string">otlp</span>, <span class="string">spanmetrics</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">otlphttp/prometheus</span>, <span class="string">debug</span>]</span><br><span class="line">    <span class="attr">logs:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">otlp</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">opensearch</span>, <span class="string">debug</span>]</span><br></pre></td></tr></table></figure><p>重点的就是这里的 <code>service.piplines</code>，可以进行任意的组装。</p><p>更多关于 collector 的配置也会在后续文章中继续讲解。</p><p>我们也可以继续访问这个 demo 网站，模拟加入购物车、下单等行为，再结合 trace 和 metric 观察系统的变化。</p><p>这样一个完整的 OpenTelemetry-Demo 就搭建完毕了，我们实际在生产环境使时完全可以参考这个 demo 进行配置，可以少踩很多坑。</p><p>参考链接：</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-demo/blob/main/src/adservice/Dockerfile">https://github.com/open-telemetry/opentelemetry-demo/blob/main/src/adservice/Dockerfile</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-demo">https://github.com/open-telemetry/opentelemetry-demo</a></li><li><a href="https://github.com/prometheus/prometheus/pull/12571">https://github.com/prometheus/prometheus/pull/12571</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-demo/blob/main/src/otelcollector/otelcol-config.yml">https://github.com/open-telemetry/opentelemetry-demo/blob/main/src/otelcollector/otelcol-config.yml</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇文章 &lt;a href=&quot;https://crossoverjie.top/2024/05/21/ob/OpenTelemetry-getstart/&quot;&gt;OpenTelemetry 实践指南：历史、架构与基本概念&lt;/a&gt;中回顾了可观测性的历史以及介绍了一些 OpenTelemetry 的基础概念，同时也介绍了 OpenTelemetry 社区常用的开源项目。&lt;/p&gt;
&lt;p&gt;基础背景知识了解后，这篇就来介绍一下使用 OpenTelemetry 如何实战部署应用，同时在一个可视化页面查看 trace、metric 等信息。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>OpenTelemetry 实践指南：历史、架构与基本概念</title>
    <link href="http://crossoverjie.top/2024/05/21/ob/OpenTelemetry-getstart/"/>
    <id>http://crossoverjie.top/2024/05/21/ob/OpenTelemetry-getstart/</id>
    <published>2024-05-21T13:46:00.000Z</published>
    <updated>2024-05-20T13:14:03.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前陆续写过一些和 OpenTelemetry 相关的文章：</p><ul><li><a href="https://crossoverjie.top/2024/04/07/ob/otel-replace-sw/">实战：如何优雅的从 Skywalking 切换到 OpenTelemetry</a></li><li><a href="https://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/">实战：如何编写一个 OpenTelemetry Extensions</a></li><li><a href="https://juejin.cn/post/7356138322367266854">从一个 JDK21+OpenTelemetry 不兼容的问题讲起</a></li></ul><p>这些内容的前提是最好有一些 OpenTelemetry 的背景知识，看起来就不会那么枯燥，为此这篇文章就来做一个入门科普，方便一些对 OpenTelemetry 不是那么熟的朋友快速掌握一些 OpenTelemetry 的基本概念。</p><span id="more"></span><hr><h2 id="历史发展"><a href="#历史发展" class="headerlink" title="历史发展"></a>历史发展</h2><p>早在 <code>OpenTelemetry</code> 诞生之前可观测性这个概念就一直存在了，我记得我最早接触到这个概念是在 16 年当时的公司所使用的一个产品：<a href="https://github.com/pinpoint-apm/pinpoint">pinpoint</a></p><blockquote><p>现如今这个项目依然比较活跃。</p></blockquote><p><img src="https://s2.loli.net/2024/04/15/VMLhpCWUGJmqn9z.png"><br>依然还记得当时通过它可以直接看到项目调用的拓扑图，在时间坐标上框出高延迟的点就能列出这些请求，同时还能查看此时的运行日志。</p><p>这样强大的功能对于一个刚工作一年的小白来说冲击力实属太大了一点。</p><p>后来才了解到 pinpoint 属于 APM 这类产品，类似的产品还有：</p><ul><li>Apache SkyWalking</li><li>美团的 CAT 等</li></ul><p>他们都是可以用于性能分析和链路追踪的产品，到后来公司的运维层面也接入过 Zabbix、open-falcon 之类的产品：<br><img src="https://s2.loli.net/2024/04/16/RwsCUSM4fxTaBj6.png"></p><p>17之后全面切换到 spring boot 时，也用过社区提供的 <a href="https://github.com/codecentric/spring-boot-admin">spring-boot-admin</a> 项目：</p><p><img src="https://s2.loli.net/2024/04/16/Y5vprI1fsVNwjPC.png"><br>这就是一个简单的可以监控 spring boot 应用的产品，用于展示 JVM 指标，或者自己也可以定义一些健康指标。</p><hr><p>再之后进入云原生体系后可观测性的技术栈稍有变化。</p><p><img src="https://s2.loli.net/2024/04/16/3MsXIo7lEgnhyUZ.png"></p><p>日志使用 Sidecar 代理的方式通过 Agent 将数据写入 ElasticSearch 中。<br>具体日志采集方式可以参考之前的文章：</p><ul><li><a href="https://juejin.cn/post/7347000319983419411">在 kubernetes 环境下如何采集日志</a></li></ul><p>而链路追踪则是使用的 <code>skywalking</code>，在 trace 这个领域 skywalking 还是非常受大家喜爱的。</p><p>不过最近也从 skywalking 切换到了我们本文所讲到的 OpenTelemetry，具体可以看之前的文章：</p><ul><li><a href="https://crossoverjie.top/2024/04/07/ob/otel-replace-sw/">实战：如何优雅的从 Skywalking 切换到 OpenTelemetry</a></li></ul><p>指标采集使用的是自然也是 Prometheus 的那一套技术栈，只是 Prometheus 换为了与它完全兼容的 VictoriaMetric 目前是为了更省资源。</p><p>客户端使用则是直接使用 Prometheus 的库进行指标暴露：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>prometheus-metrics-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>prometheus-metrics-instrumentation-jvm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>prometheus-metrics-exporter-httpserver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终通过配置抓取策略，由 VictoriaMetrics 的 <code>scrape</code> 程序来抓取指标最终写入到它自己的存储中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">operator.victoriametrics.com/v1beta1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">VMPodScrape</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-pod-scrape</span>  </span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">podMetricsEndpoints:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">scheme:</span> <span class="string">http</span>  </span><br><span class="line">      <span class="attr">scrape_interval:</span> <span class="string">&quot;30s&quot;</span>  </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/metrics</span>  </span><br><span class="line">      <span class="attr">relabelConfigs:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_annotation_prometheus_io_scrape</span>]  </span><br><span class="line">          <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">keep</span>  </span><br><span class="line">        <span class="comment"># 端口相同  </span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">keep_if_equal</span>  </span><br><span class="line">          <span class="attr">source_labels:</span> [ <span class="string">__meta_kubernetes_pod_annotation_prometheus_io_port</span>, <span class="string">__meta_kubernetes_pod_container_port_number</span> ]  </span><br><span class="line">        <span class="comment"># 过滤INIT容器  </span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">drop</span>  </span><br><span class="line">          <span class="attr">source_labels:</span> [ <span class="string">__meta_kubernetes_pod_container_init</span> ]  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_annotation_prometheus_io_path</span>]  </span><br><span class="line">          <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">(.+)</span>  </span><br><span class="line">          <span class="attr">target_label:</span> <span class="string">__metrics_path__</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">replace</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__address__</span>, <span class="string">__meta_kubernetes_pod_annotation_prometheus_io_port</span>]  </span><br><span class="line">          <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">([^:]+)(?::\d+)?;(\d+)</span>  </span><br><span class="line">          <span class="attr">target_label:</span> <span class="string">__address__</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1:$2</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">replace</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">__meta_kubernetes_pod_label_(.+)</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">labelmap</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_namespace</span>]  </span><br><span class="line">          <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">(.*)</span>  </span><br><span class="line">          <span class="attr">target_label:</span> <span class="string">kubernetes_namespace</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">replace</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_name</span>]  </span><br><span class="line">          <span class="attr">separator:</span> <span class="string">;</span>  </span><br><span class="line">          <span class="attr">regex:</span> <span class="string">(.*)</span>  </span><br><span class="line">          <span class="attr">target_label:</span> <span class="string">kubernetes_pod_name</span>  </span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">$1</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">replace</span>  </span><br><span class="line">      <span class="attr">vm_scrape_params:</span>  </span><br><span class="line">        <span class="attr">stream_parse:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">namespaceSelector:</span>  </span><br><span class="line">    <span class="attr">any:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>以上是 VM 提供的 CRD</p></blockquote><h1 id="OpenTelemetry-诞生"><a href="#OpenTelemetry-诞生" class="headerlink" title="OpenTelemetry 诞生"></a>OpenTelemetry 诞生</h1><p>到此铺垫完成，不知道有没有发现在可观测性中关键的三个部分：日志、指标、trace 都是使用不同的开源产品，从而会导致技术栈较多，维护起来自然也是比较麻烦的。</p><p>这么一个软件领域的核心能力自然需要提供一个完整方案的，将以上的不同技术栈都整合在一起，更加的方便开发者使用。</p><p>在这之前也有两个社区想要做类似的事情：</p><ul><li>OpenTracing</li><li>OpenCensus</li></ul><p>不过他们并没有统一整个可观测领域，直到 2019 年 CNCF 社区宣布成立 OpenTelemetry，并且将上述两个社区进行合并共同开发 OpenTelemetry。</p><blockquote><p>背靠 CNCF 云原生社区加上许多知名厂商的支持（Google、Amazon、Redhat 等），现在已经正式成为 CNCF 的顶级项目了。</p></blockquote><h1 id="OpenTelemetry-架构介绍"><a href="#OpenTelemetry-架构介绍" class="headerlink" title="OpenTelemetry 架构介绍"></a>OpenTelemetry 架构介绍</h1><p><img src="https://s2.loli.net/2024/04/16/LMUtyG2ZqRbwYr8.png"></p><p>但我们打开 OpenTelemetry 社区的 GitHub 首页时，会看到有许多项目；第一反应应该是比较蒙的，下面我会着重介绍一些比较重要的项目。</p><p>在开始之前还是先简单介绍下 OpenTelemetry 的一些基础组件和概念：<br><img src="https://s2.loli.net/2024/04/16/pHON6Z3eun4IiJv.png"></p><p>整个 OpenTelemetry 系统其实可以简单分为三个部分：</p><ul><li>客户端</li><li>OTel collector</li><li>数据存储</li></ul><p>第一个客户端很好理解，也就是我们的业务应用；如果是 Java 应用只需要挂载一个 agent 就可以自动采集系统的指标、链路信息、日志等上传到 Collector 中。</p><p>也就是上图的左边部分。</p><p>之后就是非常关键的组件 collector，它可以通过 OTLP 协议接收刚才提到的客户端上传的数据，然后再内部进行处理，最终输出到后续的存储系统中。</p><h2 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h2><p><img src="https://s2.loli.net/2024/04/16/l8Jfcak9bsUCwTZ.png"></p><blockquote><p>上图是 collector 的架构图</p></blockquote><p>由于 OpenTelemetry 设计之初就是要做到厂商无关，所以它就得做出更高层级的设计。</p><p>关键点就是这里的 Receiver 和 Exporter 都是模块化的设计，第三方开发者可以基于它的标准开发不同组件从而兼容不同的产品。</p><p>Receiver：用于接收客户端上报的数据，不止是自己 agent 上报的数据，也可能会来自不同的厂商，比如 kubernetes、Kafka 等。</p><p>Exporter：同理，可以将 receiver 收到的数据进行处理之后输出到不同的组件中；比如 Kafka&#x2F;Pulsar&#x2F;Promethus&#x2F;Jaeger 等。</p><p>比如我们可以使用 <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/nginxreceiver">Nginx Receiver</a>接收来着 Nginx 上报的数据。</p><p>使用 <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/mysqlreceiver">MySQL Receiver</a>接收来自 MySQL 的数据。</p><p>当然通常我们使用最多的还是 <a href="https://github.com/open-telemetry/opentelemetry-collector/tree/main/receiver/otlpreceiver">OTLP Receiver</a>，这是官方的 OTLP 协议的接收器，可以接受官方的一些指标，比如我们只使用了 Java Agent 进行数据上报时。<br><img src="https://s2.loli.net/2024/04/16/WP46czTSAdYqKgb.png"><br><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver">https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver</a></p><p>在这里是可以看到目前支持的所有第三方的 Receiver。</p><hr><p><img src="https://s2.loli.net/2024/04/16/JxyICv8wHb7paZW.png"></p><p>OpenTelemetry 所支持的 Exporter 也很多，比如一些常见的存储：</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/clickhouseexporter">clickhouse exporter</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/elasticsearchexporter">elasticsearch exporter</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/pulsarexporter">pulsar exporter</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/prometheusexporter">prometheus exporter</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-collector/tree/main/exporter/otlphttpexporter">otlp http exporter</a></li></ul><p>Exporter 的使用场景很多：如果是指标相关的数据可以直接写入 Prometheus，如果是日志数据也可以直接写入 ElasticSearch。</p><p>如果还有其他的特殊需求（删减属性等）则可以写入消息队列，自行处理完之后再发往 collector 进行后续的处理。</p><p>可能你已经发现了，由于 collector 非常的灵活，所以我们可以像搭积木一样组装我们的 receiver 和 exporter，它会以我们配置的流水线的方式进行调用，这样我们就可以实现任意可定制的处理逻辑。</p><p>而这些流水线的组装对于客户端来说都是透明的，也就是说 collector 的更改完全不会影响到业务；业务只需要按照 OTLP 的格式上报数据即可。</p><p>在之前的从 Skywalking 切换到 OpenTelemetry 的文章中有人问为什么要切换到 OpenTelemetry？</p><p>从这里也能看得出来，OpenTelemetry 的灵活度非常高，借助于 Exporter 可以任意的更换后端存储，或者增加&#x2F;删减一些不需要的指标数据等。</p><hr><p>当然我们也可以统一的在这里进行搜索，可以列出所有的第三方集成的组件：<br><a href="https://opentelemetry.io/ecosystem/registry/">https://opentelemetry.io/ecosystem/registry/</a></p><p><img src="https://s2.loli.net/2024/04/16/XvOx5i9LImhDTe4.png"></p><h1 id="OpenTelemetry-项目介绍"><a href="#OpenTelemetry-项目介绍" class="headerlink" title="OpenTelemetry 项目介绍"></a>OpenTelemetry 项目介绍</h1><h2 id="opentelemetry-java"><a href="#opentelemetry-java" class="headerlink" title="opentelemetry-java"></a>opentelemetry-java</h2><p>介绍完基本的概念后，我们可以看看  OTel 社区的一些主要开源项目。<br><img src="https://s2.loli.net/2024/04/16/t3rWKEuHpTRjL7I.png"></p><p>这里我们还是以刚才的那个架构图从作往右讲起，也就是主要分为客户端和 collector 端。</p><p><img src="https://s2.loli.net/2024/04/16/zWAVoHaZORI83js.png"><br>目前官方支持的客户端语言已经非常齐全了，大部分的版本都已经是 Stable 稳定版，意味着可以进入生产环境。</p><p>这里我们以 Java 客户端为例：<br><img src="https://s2.loli.net/2024/04/16/Oea2KwgZYVS8qPf.png"><br>其中我们重点关注下 opentelemetry-java 和 opentelemetry-java-instrumentation 这两个项目。</p><p>我们用的最多的会是 <code>opentelemetry-java-instrumentation</code>，它会给我们提供一个 java agent 的 JAR 包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:path/to/opentelemetry-javaagent.jar \</span><br><span class="line">     -jar myapp.jar</span><br></pre></td></tr></table></figure><p>我们只需要在 Java 应用中加上该  agent 就可以实现日志、指标、trace 的自动上报。</p><p>而且它还实现了不同框架、库的指标采集与 trace。</p><p>在这里可以查到支持的库与框架列表：<br><img src="https://s2.loli.net/2024/04/17/kMDcrPwxJy4oZYe.png"></p><p><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md#libraries--frameworks">https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md#libraries--frameworks</a></p><blockquote><p>总之几乎就是你能想到和不能想到的都支持了。</p></blockquote><p>而 opentelemetry-java 我们直接使用的几率会小一些，opentelemetry-java-instrumentation 本身也是基于它创建的，可以理解为是 Java 版本的核心基础库，一些社区支持的组件就可以移动到 <code>instrumentation</code> 这个库中。</p><p>比如我在上篇文章：<a href="https://juejin.cn/post/7356138322367266854">从一个 JDK21+OpenTelemetry 不兼容的问题讲起</a>中涉及到的 <code>HostResourceProvider</code> 资源加载就是从 <code>opentelemetry-java</code> 中移动到了 <code>opentelemetry-java-instrumentation</code>。</p><p>具体可以参考：<a href="https://github.com/open-telemetry/opentelemetry-java/issues/4701">https://github.com/open-telemetry/opentelemetry-java/issues/4701</a></p><h2 id="collector"><a href="#collector" class="headerlink" title="collector"></a>collector</h2><p><img src="https://s2.loli.net/2024/04/16/2MaF7IwWvg9f1TS.png"></p><p>之后就是 collector 的组件了，它同样的也有两个库：<br><strong>OpenTelemetry Collector</strong> 和 <strong>OpenTelemetry Collector Contrib</strong></p><p>其实通过他们的名字也可以看得出来，他们的作用与刚才的 Java 库类似：</p><ul><li>opentelemetry-collector：由官方社区维护，提供了一些核心能力；比如只包含了最基本的 otlp 的 receiver 和 exporter。</li><li>opentelemetry-collector-contrib：包含了官方的 collector，同时更多的维护了社区提供的各种 receiver 和 exporter；就如上文提到的，一些社区组件（pulsar、MySQL、Kafka）等都维护在这个仓库。</li></ul><p>而我们生产使用时通常也是直接使用 opentelemetry-collector-contrib，毕竟它所支持的社区组件更多。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为 OpenTelemetry 想要解决的是整个可观测领域的所有需求，所以仓库非常多，社区也很开放，感兴趣的朋友可以直接参与贡献，这么多 repo 总有一个适合你的。</p><p>后续会继续讲解如何安装以及配置我们的 OpenTelemetry。</p><p>参考链接：</p><ul><li><a href="https://github.com/pinpoint-apm/pinpoint">https://github.com/pinpoint-apm/pinpoint</a></li><li><a href="https://github.com/codecentric/spring-boot-admin">https://github.com/codecentric/spring-boot-admin</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java">https://github.com/open-telemetry/opentelemetry-java</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation">https://github.com/open-telemetry/opentelemetry-java-instrumentation</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java/issues/4701">https://github.com/open-telemetry/opentelemetry-java/issues/4701</a></li></ul><p>#Blog #OpenTelemetry </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前陆续写过一些和 OpenTelemetry 相关的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2024/04/07/ob/otel-replace-sw/&quot;&gt;实战：如何优雅的从 Skywalking 切换到 OpenTelemetry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/&quot;&gt;实战：如何编写一个 OpenTelemetry Extensions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7356138322367266854&quot;&gt;从一个 JDK21+OpenTelemetry 不兼容的问题讲起&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些内容的前提是最好有一些 OpenTelemetry 的背景知识，看起来就不会那么枯燥，为此这篇文章就来做一个入门科普，方便一些对 OpenTelemetry 不是那么熟的朋友快速掌握一些 OpenTelemetry 的基本概念。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>从一个 JDK21+OpenTelemetry 不兼容的问题讲起</title>
    <link href="http://crossoverjie.top/2024/05/13/ob/jdk21+springboot+OTel+SPI/"/>
    <id>http://crossoverjie.top/2024/05/13/ob/jdk21+springboot+OTel+SPI/</id>
    <published>2024-05-13T15:31:40.000Z</published>
    <updated>2024-05-13T07:57:01.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间公司领导让我排查一个关于在 JDK21 环境中使用 Spring Boot 配合一个 JDK18 新增的一个 SPI(<code>java.net.spi.InetAddressResolverProvider</code>) 不生效的问题。</p><p>但这个不生效的前置条件有点多：</p><ul><li>JDK 的版本得在 18+</li><li>SpringBoot3.x</li><li>还在额外再配合使用 <code>-javaagent:opentelemetry-javaagent.jar</code> 使用，也就是 OpenTelemetry 提供的 agent。</li></ul><p>才会导致自定义的 <code>InetAddressResolverProvider</code> 无法正常工作。</p><span id="more"></span><hr><p>在复现这个问题之前先简单介绍下 <code>java.net.spi.InetAddressResolverProvider</code> 这个 SPI；它是在 JDK18 之后才提供的，在这之前我们使用 <code>InetAddress</code> 的内置解析器来解析主机名和 IP 地址，但这个解析器之前是不可以自定义的。</p><p>在某些场景下会不太方便，比如我们需要请求 <code>order.service</code> 这个域名时希望可以请求到某一个具体 IP 地址上，我们可以自己配置 host ，或者使用服务发现机制来实现。</p><p>但现在通过 <code>InetAddressResolverProvider</code> 就可以定义在请求这个域名的时候返回一个我们预期的 IP 地址。</p><p>同时由于它是一个 SPI，所以我们只需要编写一个第三方包，任何项目依赖它之后在发起网络请求时都会按照我们预期的 IP 进行请求。</p><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>要使用它也很简单，主要是两个类：</p><ul><li><code>InetAddressResolverProvider</code>：这是一个抽象类，我们可以继承它之后重写它的 get 函数返回一个 <code>InetAddressResolver</code> 对象</li><li><code>InetAddressResolver</code>：一个接口，主要提供了两个函数；一个用于传入域名返回 IP 地址，另一个反之：传入 IP 地址返回域名。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAddressResolverProvider</span> <span class="keyword">extends</span> <span class="title class_">InetAddressResolverProvider</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InetAddressResolver <span class="title function_">get</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyAddressResolver</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyAddressResolverProvider Internet Address Resolver Provider&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAddressResolver</span> <span class="keyword">implements</span> <span class="title class_">InetAddressResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAddressResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====MyAddressResolver&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Stream&lt;InetAddress&gt; <span class="title function_">lookupByName</span><span class="params">(String host, LookupPolicy lookupPolicy)</span></span><br><span class="line">            <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="keyword">if</span> (host.equals(<span class="string">&quot;fedora&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Stream.of(InetAddress.getByAddress(<span class="keyword">new</span> <span class="title class_">byte</span>[] &#123;<span class="number">127</span>, <span class="number">127</span>, <span class="number">10</span>, <span class="number">1</span>&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(InetAddress.getByAddress(<span class="keyword">new</span> <span class="title class_">byte</span>[] &#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">lookupByAddress</span><span class="params">(<span class="type">byte</span>[] addr)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;++++++&quot;</span> + addr[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + addr[<span class="number">1</span>] + <span class="string">&quot; &quot;</span> + addr[<span class="number">2</span>] + <span class="string">&quot; &quot;</span> + addr[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot;fedora&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">```<span class="type">java</span></span><br><span class="line"><span class="variable">addresses</span> <span class="operator">=</span> InetAddress.getAllByName(<span class="string">&quot;fedora&quot;</span>);</span><br><span class="line"><span class="comment">// output: 127 127 10 1</span></span><br></pre></td></tr></table></figure><p>这里我简单实现了一个对域名 fedora 的解析，会直接返回 <code>127.127.10.1</code>。</p><p>如果使用 IP 地址进行查询时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InetAddress</span> <span class="variable">byAddress</span> <span class="operator">=</span> InetAddress.getByAddress(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">127</span>, <span class="number">127</span>, <span class="number">10</span>, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;+++++&quot;</span> + byAddress.getHostName());</span><br><span class="line"><span class="comment">// output: fedora</span></span><br></pre></td></tr></table></figure><p>当然要要使得这个 SPI 生效的前提条件是我们需要新建一个文件：<br><code>META-INF/services/java.net.spi.InetAddressResolverProvider</code><br>里面的内容是我们自定义类的全限定名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.example.demo.MyAddressResolverProvider</span><br></pre></td></tr></table></figure><p>这样一个完整的 SPI 就实现完成了。</p><hr><p>正常情况下我们将应用打包为一个 jar 之后运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>是可以看到输出结果是符合预期的。</p><p>一旦我们使用配合上 spring boot 打包之后，也就是加上以下的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次执行其实也没啥问题，也能按照预期输出结果。</p><p>但我们加上 OpenTelemetry 的 agent 时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java  -javaagent:opentelemetry-javaagent.jar \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>就会发现在执行解析的时候抛出了 <code>java.net.UnknownHostException</code>异常。</p><p><img src="https://s2.loli.net/2024/04/08/owZLIF7yzUpSdjn.png"><br>从结果来看就是没有进入我们自定义的解析器。</p><h1 id="SPI-原理"><a href="#SPI-原理" class="headerlink" title="SPI 原理"></a>SPI 原理</h1><p>在讲排查过程之前还是要先预习下关于 Java SPI 的原理以及应用场景。</p><p>以前写过一个 http 框架 <a href="https://github.com/TogetherOS/cicada">cicada</a>，其中有一个可拔插 IOC 容器的功能：</p><blockquote><p>就是可以自定义实现自己的 IOC 容器，将自己实现的 IOC 容器打包为一个第三方包加入到依赖中，cicada 框架就会自动使用自定义的 IOC 实现。</p></blockquote><p>要实现这个功能本质上就是要定义一个接口，然后根据依赖的不同实现创建接口的实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CicadaBeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register into bean Factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object object)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get bean from bean Factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get bean by class type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * release all beans</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">releaseBean</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取具体的示例代码时就只需要使用 JDK 内置的 <code>ServiceLoader</code> 进行加载即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CicadaBeanFactory <span class="title function_">getCicadaBeanFactory</span><span class="params">()</span> &#123;  </span><br><span class="line">    ServiceLoader&lt;CicadaBeanFactory&gt; cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);  </span><br><span class="line">    <span class="keyword">if</span> (cicadaBeanFactories.iterator().hasNext())&#123;  </span><br><span class="line">        <span class="keyword">return</span> cicadaBeanFactories.iterator().next() ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CicadaDefaultBean</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码也非常的简洁，和刚才提到的 <code>InetAddressResolverProvider</code> 一样我们需要新增一个 <code>META-INF/services/top.crossoverjie.cicada.base.bean.CicadaBeanFactory</code> 文件来配置我们的类名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNextService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// PREFIX = META-INF/services/</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="literal">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ServiceLoader 类中会会去查找 <code>META-INF/services</code> 的文件，然后解析其中的内容从而反射生成对应的接口对象。</p><p>这里还有一个关键是通常我们的代码都会打包为一个 JAR 包，类加载器需要加载这个  JAR 包，同时需要在这个 JAR 包里找到我们之前定义的那个 spi 文件，如果这里查不到文件那就认为没有定义 SPI。</p><p>这个是本次问题的重点，会在后文分析原因的时候用到。</p><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>因为问题就出现在是否使用 opentelemetry-javaagent.jar 上，所以我需要知道在使用了 agent 之后有什么区别。</p><p>从刚才的对 SPI 的原理分析，加上 agent 出现异常，说明理论上就是没有读取到我们配置的文件: <code>java.net.spi.InetAddressResolverProvider</code>。</p><p>于是我便开始 debug，在 ServiceLoader 加载 jar 包的时候是可以看到具体使用的是什么 <code>classLoader</code> 。</p><p>这是不配置 agent 的时候使用的 classLoader：<br><img src="https://s2.loli.net/2024/04/10/kgR1hOzKbnGMJUA.png"><br>使用这个 loader 是可以通过文件路径在 jar 包中查找到我们配置的文件。</p><p>而配置上 agent 之后使用的 classLoader:<br><img src="https://s2.loli.net/2024/04/10/45sUKGr6xeVPNXA.png"><br>却是一个 JarLoader，这样是无法加载到在 springboot 格式下的配置文件的，至于为什么加载不到，那就要提一下 maven 打包后的文件目录和 spring boot 打包后的文件目录的区别了。</p><p><img src="https://s2.loli.net/2024/04/10/ZtDCc7SvXFHmL9J.png"><br>这里我截图了同样的一份代码不同的打包方式：<br>上面的是传统 maven，下图是 spring boot；其实主要的区别就是在 pom 中使用了一个构建插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>或者使用 <code>spring-boot</code> 命令再次打包的效果也是一样的。</p></blockquote><p>会发现 spring boot 打包后会多出一层 <code>BOOT-INF</code> 的文件夹，然后会在 <code>MANIFIST.MF</code> 文件中定义 <code>Main-Class</code> 和 <code>Start-Class</code>.</p><hr><p>通过上面的 debug 其实会发现 JarLoader 只能在加载 maven 打包后的文件，也就是说无法识别 BOOT-INF 这个目录。</p><p>正常情况下 spring boot 中会有一个额外的 <code>java.nio.file.spi.FileSystemProvider</code> 实现:<br><img src="https://s2.loli.net/2024/04/10/iFus4tA1KXEMYkq.png"><br>通过这个类的实现可以直接从 JAR 包中加载资源，比如我们自定义的 SPI 资源等。</p><p>初步判断使用 <code>opentelemetry-javaagent.jar</code>的 agent 之后，它的类加载器优先于了 spring boot ，从而导致后续的加载失败。</p><h2 id="远程-debug"><a href="#远程-debug" class="headerlink" title="远程 debug"></a>远程 debug</h2><p>这里穿插几个 debug 小技巧，其中一个是远程 debug，因为这里我是需要调试 javaagent，正常情况下是无法直接 debug 的。</p><p>所以我们可以使用以下命令启动应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=&quot;transport=dt_socket,server=y,suspend=y,address=5000&quot; -javaagent:opentelemetry-javaagent.jar \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/04/10/D2z4krNyHAanSlC.png"></p><p>然后在 idea 中配置一个 remote 启动。</p><blockquote><p>注意这里的端口得和命令行中的保持一致。</p></blockquote><p>当应用启动之后便可以在 idea 中启动这个 remote 了，这样便可以正常 debug 了。</p><h2 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h2><p>第二个是条件断点也非常有用，有时候我们需要调试一个公共函数，调用的地方非常多。</p><p>而我们只需要关心某一类行为的调用，此时就可以对这个函数中的变量进行判断，当他们满足某些条件时再进入断点，这样可以极大的提高我们的调试效率：<br><img src="https://s2.loli.net/2024/04/10/L9PkNyZprCql6Wd.png"></p><p>配置也很简单，只需要在断点上右键就可以编辑条件了。</p><h1 id="社区咨询"><a href="#社区咨询" class="headerlink" title="社区咨询"></a>社区咨询</h1><p>虽然我根据现象初步可以猜测下原因，但依然不确定如何调整才能解决这个问题，于是便去社区提了一个 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/10921">issue</a>。</p><p><img src="https://s2.loli.net/2024/04/10/YHiIOfvxu1EUMpj.png"><br>最后在社区大佬的帮助下发现我们需要禁用掉 OpenTelemetry agent 中的一个 resource 就可以了。</p><p><img src="https://s2.loli.net/2024/04/10/EiX3mD9k6cwjMUf.png"><br>这个 resource 是由 agent 触发的，它优先于 spring boot 之前进行 SPI 的加载。<br>目的是为了给 metric 和 trace 新增两个属性：<br><img src="https://s2.loli.net/2024/04/10/I39iXt4JfdwVn8S.png"></p><p><img src="https://s2.loli.net/2024/04/10/bH3wfUeCk4K9PJ5.png"><br>加载的核心代码在这里，只要禁用掉之后就不会再加载了。</p><p>禁用前：<br><img src="https://s2.loli.net/2024/04/10/7ZIo2VaqesFXL53.png"></p><p>禁用后：<br><img src="https://s2.loli.net/2024/04/10/k2yQBPxzMHFENjd.png"></p><p>当我们禁用掉之后就不会存在这两个属性了，不过我们目前并没有使用这两个属性，所以为了使得 SPI 生效就只有先禁用掉了，后续再看看社区还有没有其他的方案。</p><p>想要复现 debug 的可以在这里尝试：<br><a href="https://github.com/crossoverJie/demo">https://github.com/crossoverJie/demo</a></p><p>参考连接：</p><ul><li><a href="https://github.com/TogetherOS/cicada">https://github.com/TogetherOS/cicada</a></li><li><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#packaging.repackage-goal">https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#packaging.repackage-goal</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/10921">https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/10921</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/instrumentation/resources/library/README.md#host">https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/instrumentation/resources/library/README.md#host</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间公司领导让我排查一个关于在 JDK21 环境中使用 Spring Boot 配合一个 JDK18 新增的一个 SPI(&lt;code&gt;java.net.spi.InetAddressResolverProvider&lt;/code&gt;) 不生效的问题。&lt;/p&gt;
&lt;p&gt;但这个不生效的前置条件有点多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK 的版本得在 18+&lt;/li&gt;
&lt;li&gt;SpringBoot3.x&lt;/li&gt;
&lt;li&gt;还在额外再配合使用 &lt;code&gt;-javaagent:opentelemetry-javaagent.jar&lt;/code&gt; 使用，也就是 OpenTelemetry 提供的 agent。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;才会导致自定义的 &lt;code&gt;InetAddressResolverProvider&lt;/code&gt; 无法正常工作。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>如何对 kubernetes 应用做 e2e(端到端) 测试</title>
    <link href="http://crossoverjie.top/2024/05/05/ob/operator-e2e-test/"/>
    <id>http://crossoverjie.top/2024/05/05/ob/operator-e2e-test/</id>
    <published>2024-05-05T07:18:05.000Z</published>
    <updated>2024-05-05T13:13:35.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在给 <a href="https://github.com/open-telemetry/opentelemetry-operator/pull/2778">opentelemetry-operator</a>提交一个标签选择器的功能时，因为当时修改的函数是私有的，无法添加单测函数，所以社区建议我补充一个 <code>e2e test</code>.</p><blockquote><p>因为在当前的版本下，只要给 deployment 打上了 <code>instrumentation.opentelemetry.io/inject-java: &quot;true&quot;</code> 这类注解就会给该 deployment 注入 agent。<br>但没办法指定不同的 agent 版本（或者不同的环境变量），所以希望可以新增一个选择器，同时可以针对不同的 deployment 维护不同版本的 <code>Instrumentation</code>(是用于控制需要注入 deployment 的资源)；这样就可以灵活控制了。</p></blockquote><span id="more"></span><p><img src="https://s2.loli.net/2024/03/26/8QEaeXC9YwJp56m.png"></p><p>在这之前我其实也很少做 kubernetes 的 operator 开发，对如何做 kubernetes 的 e2e 测试也比较陌生，好在社区提供了详细的贡献文档。</p><p><img src="https://s2.loli.net/2024/03/26/Fv6SCofEtubZjcH.png"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>简单来说需要两个关键组件：</p><ul><li><a href="https://kind.sigs.k8s.io/">kind</a>: kubernetes in docker，是可以在本地利用 docker 启动一个 kubernetes 集群的工具，通常用于在本地进行开发、测试关于 kubernetes 相关的功能。<ul><li>安装 kind 的前提是本地已经安装好了 docker。</li></ul></li><li><a href="https://kyverno.github.io/chainsaw/latest/">chainsaw</a>: 一个 e2e 测试框架，提供了声明式的方式定义测试用例，也有着丰富断言功能。</li></ul><p>他们的安装都很简单，只要本地安装好了 golang，直接使用 go install 即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go install sigs.k8s.io/kind@v0.22.0</span><br><span class="line">go install github.com/kyverno/chainsaw@latest</span><br></pre></td></tr></table></figure><h2 id="kind-使用"><a href="#kind-使用" class="headerlink" title="kind 使用"></a>kind 使用</h2><p>在开始前还是先预习下 kind 的基本使用。</p><p>安装好 kind 之后，使用 create cluster 命令可以在本地创建一个 <code>kubernetes</code> 集群。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kind create cluster -h</span><br><span class="line">Creates a local Kubernetes cluster using Docker container &#x27;nodes&#x27;</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  kind create cluster [flags]</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/03/27/znDfd3m5HeyrXi4.png"><br>之后只需要等待集群安装成功即可，它会在我们的 <code>cat ~/.kube/config</code> 文件中追加刚才新建集群的连接信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k config get-contexts</span><br><span class="line">k config use-context xxx</span><br></pre></td></tr></table></figure><p>这样就可以使用这两个命令来查看和切换不同的集群了，虽说是一个本地模拟的 kubernetes 集群，但他的核心功能和一个标准的集群没有什么区别。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kind delete clusters --all</span><br></pre></td></tr></table></figure><p>使用完成之后可以使用这个命令将所有集群都删除掉。</p><h1 id="准备集群数据"><a href="#准备集群数据" class="headerlink" title="准备集群数据"></a>准备集群数据</h1><p>在 <code>opentelemetry-operator</code> 中有给我们准备好一个 make 命令: <code>make prepare-e2e</code> ；使用它会帮我们将 operator 的测试环境初始化好。</p><p>大概分为以下几步：</p><ul><li>安装 chainsaw</li><li>修改 controller 的镜像为我们本地构建的镜像名称</li><li>本地 docker 镜像打包</li><li>安装 cert-manager</li><li>安装 Operator 需要的 CRD</li><li>部署 Operator deployment</li><li>等待 Operator 启动成功</li></ul><p>不过这里的安装过程可能会遇到问题（本质上都是我们的网络问题）：<br><img src="https://s2.loli.net/2024/03/25/bYWdfOv9B27c8RE.png"><br><img src="https://s2.loli.net/2024/03/25/kH4b7I3UlngzENA.png"><br>这种情况可以想办法（科学上网）手动先把镜像拉取到本地，然后 kubernetes 就会从本地仓库获取到这个镜像。</p><h1 id="e2e-test"><a href="#e2e-test" class="headerlink" title="e2e test"></a>e2e test</h1><p>通常我们需要将同一类的测试功能放到一个文件夹里，比如这样：<br><img src="https://s2.loli.net/2024/03/27/eh8Rk4uFfWTHtna.png"><br>默认情况下 Chainsaw 会查找目录下名为 <code>chainsaw-test.yaml</code> 作为引导文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">chainsaw.kyverno.io/v1alpha1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Test</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">instrumentation-java</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">steps:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">step-00</span>  </span><br><span class="line">    <span class="attr">try:</span>   </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">command:</span>  </span><br><span class="line">        <span class="attr">entrypoint:</span> <span class="string">kubectl</span>  </span><br><span class="line">        <span class="attr">args:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">annotate</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">namespace</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">$&#123;NAMESPACE&#125;</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">openshift.io/sa.scc.uid-range=1000/1000</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">--overwrite</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">command:</span>  </span><br><span class="line">        <span class="attr">entrypoint:</span> <span class="string">kubectl</span>  </span><br><span class="line">        <span class="attr">args:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">annotate</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">namespace</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">$&#123;NAMESPACE&#125;</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">openshift.io/sa.scc.supplemental-groups=3000/3000</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="string">--overwrite</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">apply:</span>  </span><br><span class="line">        <span class="attr">file:</span> <span class="number">00</span><span class="string">-install-collector.yaml</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">apply:</span>  </span><br><span class="line">        <span class="attr">file:</span> <span class="number">00</span><span class="string">-install-instrumentation-select.yaml</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">step-01</span>  </span><br><span class="line">    <span class="attr">try:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">apply:</span>  </span><br><span class="line">        <span class="attr">file:</span> <span class="number">01</span><span class="string">-install-app-select.yaml</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">assert:</span>  </span><br><span class="line">        <span class="attr">file:</span> <span class="number">01</span><span class="string">-assert*.yaml</span>  </span><br><span class="line">    <span class="attr">catch:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">podLogs:</span>  </span><br><span class="line">          <span class="attr">selector:</span> <span class="string">app=my-java-select</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tests/e2e-instrumentation/instrumentation-select</span><br><span class="line">├── 00-install-collector.yaml</span><br><span class="line">├── 00-install-instrumentation-select.yaml</span><br><span class="line">├── 01-assert-select.yaml</span><br><span class="line">├── 01-assert-without-select.yaml</span><br><span class="line">├── 01-install-app-select.yaml</span><br><span class="line">└── chainsaw-test.yaml</span><br></pre></td></tr></table></figure><p>以我这里的这份文件为例，在其中定义了几个步骤：</p><ul><li>初始化环境信息，包含创建 namespace</li><li>安装我们测试所需要的资源<ul><li>00-install-collector.yaml：这里主要是安装一个 OpenTelemetry 的 collector</li><li>00-install-instrumentation-select.yaml：安装 Instrumentation 注入资源</li><li>01-install-app-select.yaml：应用一个我们需要测试的 deployment 资源</li><li><code>01-assert*.yaml</code>：最后对最终生成的 yaml 资源与 assert*.yaml 的进行断言匹配，只有匹配成功后才能测试成功。</li></ul></li></ul><blockquote><p>这里的测试目的主要是完成一个完整的 Java 应用的 deployment 注入 OpenTelemetry 的 agent 过程还有一些与 OpenTelemetry 相关的环境变量。</p></blockquote><p>以 <code>00-install-instrumentation-select.yaml</code> 文件为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">opentelemetry.io/v1alpha1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Instrumentation</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">java-select</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">my-java-select</span>  </span><br><span class="line">  <span class="attr">env:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_TRACES_EXPORTER</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">otlp</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXPORTER_OTLP_ENDPOINT</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">http://localhost:4317</span>  </span><br><span class="line">  <span class="attr">exporter:</span>  </span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">http://localhost:4317</span>  </span><br><span class="line">  <span class="attr">propagators:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">jaeger</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">b3</span>  </span><br><span class="line">  <span class="attr">sampler:</span>  </span><br><span class="line">    <span class="attr">type:</span> <span class="string">parentbased_traceidratio</span>  </span><br><span class="line">    <span class="attr">argument:</span> <span class="string">&quot;0.25&quot;</span>  </span><br><span class="line">  <span class="attr">java:</span>  </span><br><span class="line">    <span class="attr">env:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_JAVAAGENT_DEBUG</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;true&quot;</span>  </span><br></pre></td></tr></table></figure><p>它的预期效果是选择 <code>app: my-java-select</code> 的 deployment 将这些环境变量都注入进去，同时默认也会在 deployment 的容器中挂载一个 <code>javaagent.jar</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /otel-auto-instrumentation-java/</span><br><span class="line">javaagent.jar</span><br></pre></td></tr></table></figure><p>而我们的 <code>01-assert-select.yaml</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">annotations:</span>  </span><br><span class="line">    <span class="attr">instrumentation.opentelemetry.io/inject-java:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">    <span class="attr">sidecar.opentelemetry.io/inject:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-java-select</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">containers:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">env:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_JAVAAGENT_DEBUG</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">JAVA_TOOL_OPTIONS</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">&#x27; -javaagent:/otel-auto-instrumentation-java/javaagent.jar&#x27;</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_TRACES_EXPORTER</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">otlp</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXPORTER_OTLP_ENDPOINT</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">http://localhost:4317</span>    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_TRACES_SAMPLER</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">parentbased_traceidratio</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_SERVICE_NAME</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">my-java-select</span>   </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_PROPAGATORS</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">jaeger,b3</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_RESOURCE_ATTRIBUTES</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">myapp</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">args:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">--config=env:OTEL_CONFIG</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">otc-container</span>  </span><br><span class="line">  <span class="attr">initContainers:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">opentelemetry-auto-instrumentation-java</span>  </span><br><span class="line"><span class="attr">status:</span>  </span><br><span class="line">  <span class="attr">containerStatuses:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span>  </span><br><span class="line">    <span class="attr">ready:</span> <span class="literal">true</span>  </span><br><span class="line">    <span class="attr">started:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">initContainerStatuses:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">opentelemetry-auto-instrumentation-java</span>  </span><br><span class="line">    <span class="attr">ready:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">phase:</span> <span class="string">Running</span></span><br></pre></td></tr></table></figure><p>最终就是把实际的 <code>deployment</code> 的 yaml 内容和这份文件进行对比。</p><p>所以这个 e2e 测试就有点类似于集成测试，不会测试具体的功能函数，只需要最终结果能匹配就可以。</p><blockquote><p>当然这个和单元测试也是相辅相成的，缺一不可，不能完全只依赖 e2e 测试，也有可能是概率原因导致最终生成的资源相同；单元测试可以保证函数功能与预期相同。</p></blockquote><hr><p>都准备好之后便可以进行测试了，测试的时候也很简单，只需要执行以下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chainsaw test --test-dir ./tests/e2e-multi-instrumentation</span><br></pre></td></tr></table></figure><p>这样它就会遍历该目录下的 <code>chainsaw-test.yaml</code>文件进行测试，执行我们上面定义的那些步骤，最终输出测试结果：</p><p><img src="https://s2.loli.net/2024/03/27/VBwbKLdGjIXODrF.png"></p><p>同时 Chainsaw 也提供了 Github action，可以方便的让我们和 github CI 进行集成。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">example:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">permissions:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Chainsaw</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Chainsaw</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">kyverno/action-install-chainsaw@v0.1.0</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">release:</span> <span class="string">v0.0.9</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Check</span> <span class="string">install</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">chainsaw</span> <span class="string">version</span></span><br></pre></td></tr></table></figure><p>这样我们就可以在 github 中查看我们的测试结果了：<br><img src="https://s2.loli.net/2024/03/27/MaoL7EBmOZfsHd9.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后不得不感叹作为 CNCF 下面的项目 OpenTelemetry 的开发者体验真好，只要我们跟着<a href="https://github.com/open-telemetry/opentelemetry-operator/blob/main/CONTRIBUTING.md">贡献者文档</a>一步步操作都能顺利通过 CI 测试，同时还能避免一些 Code Review 过程中的低级错误。</p><p><img src="https://s2.loli.net/2024/03/27/kQGfWAhYHiyNXUq.png"><br>比如我第一次提 PR 的时候没有添加 changlog 文件，后面在贡献者手册里发现只需要执行 <code>make chlog-new</code> 就会基于当前分支信息帮我们生成一个 changelog 文件模板，然后只需要往里面填写内容即可。</p><p>这些工具链让不同开发者提交的代码和流程都符合规范，同时也降低了贡献难度。</p><p>以上所有的相关源码都可以在 <a href="https://github.com/open-telemetry/opentelemetry-operator">https://github.com/open-telemetry/opentelemetry-operator</a> 中进行查看。</p><p>参考链接：</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-operator/pull/2778">https://github.com/open-telemetry/opentelemetry-operator/pull/2778</a></li><li><a href="https://kind.sigs.k8s.io/">https://kind.sigs.k8s.io/</a></li><li><a href="https://kyverno.github.io/chainsaw/latest/">https://kyverno.github.io/chainsaw/latest/</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-operator/blob/main/CONTRIBUTING.md">https://github.com/open-telemetry/opentelemetry-operator/blob/main/CONTRIBUTING.md</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近在给 &lt;a href=&quot;https://github.com/open-telemetry/opentelemetry-operator/pull/2778&quot;&gt;opentelemetry-operator&lt;/a&gt;提交一个标签选择器的功能时，因为当时修改的函数是私有的，无法添加单测函数，所以社区建议我补充一个 &lt;code&gt;e2e test&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为在当前的版本下，只要给 deployment 打上了 &lt;code&gt;instrumentation.opentelemetry.io/inject-java: &amp;quot;true&amp;quot;&lt;/code&gt; 这类注解就会给该 deployment 注入 agent。&lt;br&gt;但没办法指定不同的 agent 版本（或者不同的环境变量），所以希望可以新增一个选择器，同时可以针对不同的 deployment 维护不同版本的 &lt;code&gt;Instrumentation&lt;/code&gt;(是用于控制需要注入 deployment 的资源)；这样就可以灵活控制了。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="k8s" scheme="http://crossoverjie.top/tags/k8s/"/>
    
    <category term="operator" scheme="http://crossoverjie.top/tags/operator/"/>
    
  </entry>
  
  <entry>
    <title>一次消息队列异常堆积的排查</title>
    <link href="http://crossoverjie.top/2024/04/29/ob/pulsar-slow-consume/"/>
    <id>http://crossoverjie.top/2024/04/29/ob/pulsar-slow-consume/</id>
    <published>2024-04-29T07:47:10.000Z</published>
    <updated>2024-04-29T02:24:24.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前两天收到业务反馈有一个 topic 的分区消息堆积了：<br><img src="https://s2.loli.net/2024/03/24/Ckb3MRswVAvjXfn.png"><br>根据之前的经验来看，要么是业务消费逻辑出现问题导致消费过慢，当然也有小概率是消息队列的 Bug（我们使用的是 pulsar）。</p><span id="more"></span><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p><img src="https://s2.loli.net/2024/03/24/6TBk2Jo9sWZpRGe.png"><br>通过排查，发现确实是在一点多的时候消息堆积了（后面是修复之后堆积开始下降）。</p><p>于是我在刚才堆积处查看了一条堆积消息的列表：<br><img src="https://s2.loli.net/2024/03/24/UeizjIc3brVfnNy.png"></p><p>获取到其中一条消息的 <code>messageId</code>.</p><blockquote><p>这里本质上使用的是 pulsar-admin 的 API。<br><a href="https://pulsar.apache.org/docs/3.2.x/admin-api-topics/#peek-messages"><code>org.apache.pulsar.client.admin.Topics#peekMessages</code></a></p></blockquote><p><img src="https://s2.loli.net/2024/03/24/IEGwRWphsFf6xk2.png"><br>再通过这条消息的 id （为了演示，这里的 messageId 可能不一样）在我们的 pulsar 消息链路系统中找到了消息的发送链路：<br><img src="https://s2.loli.net/2024/03/24/CwQRAWXMu8Hxq5y.png"><br>通过这个链路会发现消息一直在推送，但就是没有收到客户端的 ACK 响应。</p><blockquote><p>相关的消息链路埋点可以参考这里：<a href="https://crossoverjie.top/2023/12/11/ob/Pulsar-Broker-Interceptor/">如何编写一个 Pulsar Broker Interceptor 插件</a></p></blockquote><p>简单来说就是在以下几个 broker 提供的拦截器接口加上埋点数据即可：</p><ul><li>messageProduced</li><li>messageDispatched</li><li>messageAcked</li></ul><p>既然知道了是客户端没有响应 ACK，那就得知道客户端此时在干什么。</p><p>首先排查了 JVM 内存、CPU 等监控情况，发现一切都挺正常的，这段时间没有明显的尖刺。</p><h2 id="Arthas-排查"><a href="#Arthas-排查" class="headerlink" title="Arthas 排查"></a>Arthas 排查</h2><p>于是便准备使用 arthas 查看下线程的运行情况。</p><p>我们进入到对应 Pod 的容器，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p>因为 JVM 内存都没有啥异常，所以先看看 thread 的运行堆栈，考虑到是 pulsar 消费线程卡住了，所以我们需要加上线程状态已经过滤下线程的名称：<br><img src="https://s2.loli.net/2024/03/24/brPcepjMFKaC9d8.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread --state WAITING | grep pulsar</span><br></pre></td></tr></table></figure><p>此时就会列出当前 Java 进程中状态为 WATING 并且线程名称以 pulsar 开头的线程。</p><blockquote><p>我在之前的文章 <a href="https://crossoverjie.top/2023/08/03/ob/Pulsar-Client/">从 Pulsar Client 的原理到它的监控面板</a> 中分析过客户端的原理。</p></blockquote><p><img src="https://s2.loli.net/2023/08/02/vweWVR8fkJgrSMI.png" alt="20230802224400.png"><br><img src="https://s2.loli.net/2024/03/24/h7KQXueLySHYotW.png"></p><p>可以知道 pulsar 客户端在其中使用的是 <code>pulsar-</code>打头的线程名称，所以这样就列出了我们需要重点关注的线程。</p><p>我们以图中列出的线程 Id：320 为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread 320</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/03/24/cT1Eylp6aXd5QeZ.png"><br>此时便会打印当前线程的堆栈。</p><p>从上述堆栈中会发现线程一直处于 IO 操作中，看起来是在操作数据库。</p><p>我们再往下翻一翻，会发现上层调用的业务代码：<br><img src="https://s2.loli.net/2024/03/24/BhFGeJ7X6DLbC1s.png"><br>查阅代码得知这是一个数据库的写入操作，看起来是在这个环节数据库响应过慢导致的 pulsar 线程被阻塞了；从而导致消息没有及时 ACK。</p><p>为了最终确认是否由数据库引起的，于是继续查询了当前应用的慢 SQL 情况：<br><img src="https://s2.loli.net/2024/03/24/vcYDGapUVms82Jl.png"></p><p>发现其中有一个查询语句调用频次和平均耗时都比较高，而且正好这个表也是刚才在堆栈里操作的那张表。</p><p>经过业务排查发现这个慢 SQL 是由一个定时任务触发的，而这个定时任务由于某些原因一直也没有停止，所以为了快速解决这个问题，我们先尝试将这个定时任务停掉。</p><p>果然停掉没多久后消息就开始快速消费了：<br><img src="https://s2.loli.net/2024/03/24/wlDtCeBZL6IjkRM.png"><br>从这个时间线也可以看得出来了，在服务端推送了多次之后终于收到了 ACK。</p><p>修复之后业务再去排查优化这个慢 SQL，这样这个问题就得到根本的解决了。</p><h1 id="更多好用技巧"><a href="#更多好用技巧" class="headerlink" title="更多好用技巧"></a>更多好用技巧</h1><p>当然 arthas 好用的功能还远不止此，我觉得还有以下功能比较好用：</p><h2 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h2><p>profile：可以输出火焰图，在做性能分析的时候非常有用。<br><img src="https://s2.loli.net/2024/03/24/2qsjgQMCRhtxNdm.png"></p><h2 id="动态修改内存数据"><a href="#动态修改内存数据" class="headerlink" title="动态修改内存数据"></a>动态修改内存数据</h2><p>还记得之前我们碰到过一个 pulsar <a href="https://crossoverjie.top/2024/01/09/ob/Pulsar-Delete-Topic/">删除 topic 的 Bug</a>，虽然最终修复了问题，但是在发布修复版本的时候为了避免再次触发老版本的 bug，需要在内存中将某个关键字段的值修改掉。</p><p>而且是不能重启应用的情况下修改，此时使用 arthas 就非常的方便：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar &amp;&amp; java -jar arthas-boot.jar 1 -c &quot;vmtool -x 3 --action getInstances --className org.apache.pulsar.broker.ServiceConfiguration  --express &#x27;instances[0].setTopicLevelPoliciesEnabled(false)&#x27;&quot;</span><br></pre></td></tr></table></figure><p>这里使用的是 <code>vmtool</code> 这个子命令来获取对象，最终再使用 <code>express</code> 表达式将其中的值改为了 false。</p><p>当然这是一个高危操作，不到万不得已不推荐这么使用。</p><h2 id="Arthas-Tunnel-amp-Web-Console"><a href="#Arthas-Tunnel-amp-Web-Console" class="headerlink" title="Arthas Tunnel &amp; Web Console"></a>Arthas Tunnel &amp; Web Console</h2><p>这是一个方便开发者通过网页就可以连接到 arthas 的功能，避免直接登录到服务器进行操作。<br><img src="https://s2.loli.net/2024/03/24/d38vNUbylAhSKxP.png"><br><img src="https://s2.loli.net/2024/03/24/w8RomB4UVOyErvf.png"></p><p>我们在研效普通也内置了该功能，让开发排查问题更加方便。</p><h2 id="CPU-使用过多"><a href="#CPU-使用过多" class="headerlink" title="CPU 使用过多"></a>CPU 使用过多</h2><p>cpu 异常使用排查也是一个非常有用的功能，虽然我们可以通过监控得知 JVM 的 cpu 使用情况，但是没法知道具体是哪个线程以及哪行代码造成的 cpu 过高。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -n 3</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/03/24/SGTLjp8uBOHtJea.png"></p><p>使用以上命令就可以将 cpu 排名前三的线程打印出来，并且列出他的堆栈情况，这样可以很直观的得知 cpu 消耗了在哪些地方了。</p><p>当然还有一些 trace 查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace demo.MathGame run &#x27;#cost &gt; 10&#x27;</span><br></pre></td></tr></table></figure><p>比如这是将调用超过 10ms 的函数打印出来，不过如果我们接入了可观测系统（OpenTelemetry、skywalking等）这个功能就用不太上了。</p><hr><p> 还可以在运行的时候不停机修改日志级别，这种在线上排查一些疑难杂症的时候非常好用（通常情况下 debug 日志是不打印的），我们可以将日志级别调整为 debug 打印出更加详细的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[arthas@2062]$ </span><span class="language-bash">logger --name ROOT --level debug</span></span><br><span class="line">update logger level success.</span><br></pre></td></tr></table></figure><hr><p>如果是在 kubernetes 环境中执行也有可能碰到 Java 进程启动后没有在磁盘中写入 PID 的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar arthas-boot.jar</span>  </span><br><span class="line">[INFO] arthas-boot version: 3.6.7  </span><br><span class="line">[INFO] Can not find java process. Try to pass &lt;pid&gt; in command line.  </span><br><span class="line">Please select an available pid.</span><br></pre></td></tr></table></figure><p>导致直接运行的时候无法找到 Java 进程；此时就需要先 ps 拿到 PID 之后再传入 PID 连入 arthas：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar arthas-boot.jar 1</span></span><br></pre></td></tr></table></figure><p>更多关于 arthas 的用法可以参考官网。</p><p>参考链接：</p><ul><li><a href="https://pulsar.apache.org/docs/3.2.x/admin-api-topics/#peek-messages">https://pulsar.apache.org/docs/3.2.x/admin-api-topics/#peek-messages</a></li><li><a href="https://crossoverjie.top/2023/12/11/ob/Pulsar-Broker-Interceptor/">https://crossoverjie.top/2023/12/11/ob/Pulsar-Broker-Interceptor/</a></li><li><a href="https://arthas.aliyun.com/">https://arthas.aliyun.com/</a></li><li><a href="https://crossoverjie.top/2024/01/09/ob/Pulsar-Delete-Topic/">https://crossoverjie.top/2024/01/09/ob/Pulsar-Delete-Topic/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前两天收到业务反馈有一个 topic 的分区消息堆积了：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/03/24/Ckb3MRswVAvjXfn.png&quot;&gt;&lt;br&gt;根据之前的经验来看，要么是业务消费逻辑出现问题导致消费过慢，当然也有小概率是消息队列的 Bug（我们使用的是 pulsar）。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>在 kubernetes 环境下如何采集日志</title>
    <link href="http://crossoverjie.top/2024/04/21/ob/k8s-log-collect/"/>
    <id>http://crossoverjie.top/2024/04/21/ob/k8s-log-collect/</id>
    <published>2024-04-21T05:07:07.000Z</published>
    <updated>2024-04-21T11:49:07.604Z</updated>
    
    <content type="html"><![CDATA[<p>当我们没有使用云原生方案部署应用时采用的日志方案往往是 ELK 技术栈。<br><img src="https://s2.loli.net/2024/03/16/5pNYcOuxgXzsG1F.png"></p><p>这套技术方案比较成熟，稳定性也很高，所以几乎成为了当时的标配。</p><p>可是随着我们使用 kubernetes 步入云原生的时代后， kubernetes 把以往的操作系统上的许多底层都屏蔽，再由他提供了一些标准接口。</p><p>同时在 kubernetes 中的日志来源也比传统虚拟机多，比如可能有容器、kubernetes 自身的事件、日志等。</p><span id="more"></span><p>我们的日志采集方案也得与时俱进，kubernetes 的官方博客有介绍提供一下几种方案：</p><h1 id="节点采集"><a href="#节点采集" class="headerlink" title="节点采集"></a>节点采集</h1><p><img src="https://s2.loli.net/2024/03/18/EWB1PFJku6x8On3.png"></p><p>第一种方案是在节点中采集日志，我们知道 kubernetes 是分为 master 调度节点以及 worker 工作节点；我们的应用都是运行在 worker 节点中的。</p><blockquote><p>在 kubernetes 环境中更推荐使用标准的 stdout&#x2F;stderr 作为日志输出，这样 kubernetes 更方便做统一处理。</p></blockquote><p><img src="https://s2.loli.net/2024/03/16/iUXB3YQdEAgJmpT.png"></p><p>以我们的 docker 运行时为例，默认情况下我们的标准输入文件会写入到 <code>/var/log</code> 目录中。</p><p><img src="https://s2.loli.net/2024/03/16/48NxKOuQmB5oer1.png"></p><p>如上图所示：我们可以在 kubernetes 的每一个 worker 节点中部署一个 <code>DaemonSet</code> 类型的采集器（filebeat 等），再由他去采集该节点下 <code>/var/log</code> 的日志，最终由他将日志采集后发往日志处理的后端，比如 elasticsearch 等组件中。</p><p>这种方案的好处是资源占用较低，往往是有多少个 worker 节点就可以部署多少个采集器。</p><p>而且和业务的耦合度低，业务和采集器不管谁进行重启或升级互相都不会产生影响。</p><p>但缺点也比较明显，整个节点的日志采集瓶颈都在这个采集器这里了，如果某些 worker 节点的 Pod 数量不均衡，或者是本身日志产生也不平均时就会出现明显的负债不平衡。</p><p>而且也无法针对某些日志高峰场景进行调优（毕竟所有的 Pod 都是使用的一个日志采集器）。</p><p>所以节点级的日志采集更适用与该 worker 节点负债较低的时候使用，也更容易维护。</p><h1 id="Sidecar-代理模式"><a href="#Sidecar-代理模式" class="headerlink" title="Sidecar 代理模式"></a>Sidecar 代理模式</h1><p><img src="https://s2.loli.net/2024/03/16/Xo23G568BevhWKc.png"><br>第二种相对于第一种可以理解为由集中式的日志采集分散到各个应用 Pod 中自行采集。</p><p>需要为每一个业务 Pod 挂载一个边车（sidecar）进行日志采集，由于边车和业务 Pod 共享的是一个存储，所以可以很方便的读取到日志。</p><p>由于它是和应用挂载在一起的，所以资源占用自然会比节点采集更多，同理耦合度也增加了，采集组件的升级可能还会影响的业务 Pod。</p><p>但同样的带来好处就是可以针对单个 Pod 更精细的控制采集方案。</p><p>比如对于一些日志写入频繁的应用，可以将 filebeat 的配置提高，甚至还可以将这种高负载的日志单独写入一个 elasticsearch 中，这样可以与普通负载的日志进行资源隔离。</p><p>这个方案更适用与集群规模较大的场景，需要做一些精细化配置。</p><hr><p>我们其实也是采用的也是这个方案，不过具体细节稍有不同。</p><p>我们没有直接使用标准输入和输出，原因如下：</p><p>日志格式没法统一，导致最终查询的时候无法做一些标准化的限制（比如我们要求每个日志都需要带业务 id、traceId 等，查询时候有这些业务指标就很容易沉淀一些标准的查询语句。）</p><p>最终我们还是采用了 Java 的老朋友，logback 配置了自己的日志格式，所有的应用都会根据这个模版进行日志输出。</p><p>同时利用日志框架的批量写入、缓冲等特性还更容易进行日志的性能调优。（只使用标准输出时对应用来说是黑盒。）</p><p>最终我们的技术方案是：<br><img src="https://s2.loli.net/2024/03/16/V1mf7MBpodq5eRU.png"></p><h1 id="直接写入"><a href="#直接写入" class="headerlink" title="直接写入"></a>直接写入</h1><p>还有一种方案是直接写入，这个其实和 kubernetes 本身就没有太多关系了。</p><p>由业务自己调用 elasticsearch 或者其他的存储组件的 API 进行写入，这种通常适用于对性能要求较高的场景，略过了中间的采集步骤，直接写入存储端。</p><p>这个我在 <a href="https://crossoverjie.top/2023/08/23/ob/VictoriaLogs-Intro/">VictoriaLogs：一款超低占用的 ElasticSearch 替代方案</a>中介绍过，我需要在 broker 的拦截器中埋点消息信息，从而可以生成一个消息🆔的链路信息。</p><p><img src="https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png"></p><p>因为需要拦截消息的发送、消费的各个阶段，加上并发压力较高，所以对日志的写入性能要求还是蛮高的。</p><p>因此就需要在拦截器中直接对写入到日志存储。</p><blockquote><p>这里考虑到我这里的但一场景，以及对资源的消耗，最终选取了 <code>victoriaLog</code> 这个日志存储。</p></blockquote><p>而在发送日志的时候也得用了高性能的日志发生框架，这里选取了<a href="https://github.com/aliyun/aliyun-log-java-producer">aliyun-log-java-producer</a>然后做了一些定制。</p><p>这个库支持以下一些功能：</p><ul><li>高性能：批量发送、多线程等</li><li>自动重试</li><li>异步非阻塞</li><li>资源控制（可以对内存、数量进行控制）</li></ul><p>因为这是为阿里云日志服务的一个组件，代码里硬编码了只能写入阿里的日志服务。</p><p>所以拿来稍加改造后，现在可以支持自定义发送到任意后端，只需要在初始化时自定义实现发送回调接口即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProducerConfig</span> <span class="variable">producerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerConfig</span>();</span><br><span class="line">producerConfig.setSenderArgs(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;vlogUrl, client&#125;);</span><br><span class="line">producerConfig.setSender((batch, args) -&gt; &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (String s : batch.getLogItemsString()) &#123;</span><br><span class="line">        body.append(<span class="string">&quot;&#123;\&quot;create\&quot;:&#123;&#125;&#125;&quot;</span>);</span><br><span class="line">        body.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        body.append(s);</span><br><span class="line">        body.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span></span><br><span class="line">            RequestBody.create(MediaType.parse(<span class="string">&quot;application/json&quot;</span>), body.toString());</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                    .url(String.format(<span class="string">&quot;%s/insert/elasticsearch/_bulk&quot;</span>, args[<span class="number">0</span>]))</span><br><span class="line">                    .post(requestBody)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">    <span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> (OkHttpClient) args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> okHttpClient.newCall(request).execute()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (response.isSuccessful()) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Request failed with error code: &quot;</span> + response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Send vlogs failed&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">logProducer = <span class="keyword">new</span> <span class="title class_">LogProducer</span>(producerConfig);</span><br></pre></td></tr></table></figure><blockquote><p>考虑到这个库只是对阿里云日志服务的一个组件，加上代码已经很久没维护了，所以就没有将这部分代码提交到社区，感兴趣的评论区留言。</p></blockquote><h1 id="日志安全"><a href="#日志安全" class="headerlink" title="日志安全"></a>日志安全</h1><p>日志是一个非常基础但又很敏感的功能，首先是编码规范上要避免打印一些敏感信息；比如身份证、密码等；同时对日志的访问也要最好权限控制。</p><p>在我们内部的研效平台中，对于日志、监控等功能都是和应用权限挂钩的。</p><p>简单来说就是关闭了统一查询 ES 的入口，只在应用层级提供查询，类似于：</p><p><img src="https://s2.loli.net/2024/03/18/ogBTPu47CifOrnp.png"></p><blockquote><p>图来自于 orbit 产品。</p></blockquote><h1 id="OpenTelemetry"><a href="#OpenTelemetry" class="headerlink" title="OpenTelemetry"></a>OpenTelemetry</h1><p>当然讲到日志目前自然也逃不过 OpenTelemetry，作为当前云原生可观测性的标准也提供了对应的日志组件。</p><p><img src="https://s2.loli.net/2024/03/18/VdvhIbzRWxlc79Q.png"><br>OpenTelemetry 也定义了结构化的日志格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;resourceLogs&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span><span class="string">&quot;resource-attr&quot;</span><span class="punctuation">,</span><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;stringValue&quot;</span><span class="punctuation">:</span><span class="string">&quot;resource-attr-val-1&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;scopeLogs&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;logRecords&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;timeUnixNano&quot;</span><span class="punctuation">:</span><span class="string">&quot;1581452773000000789&quot;</span><span class="punctuation">,</span><span class="attr">&quot;severityNumber&quot;</span><span class="punctuation">:</span><span class="number">9</span><span class="punctuation">,</span><span class="attr">&quot;severityText&quot;</span><span class="punctuation">:</span><span class="string">&quot;Info&quot;</span><span class="attr">&quot;body&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;stringValue&quot;</span><span class="punctuation">:</span><span class="string">&quot;This is a log message&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span><span class="string">&quot;app&quot;</span><span class="punctuation">,</span><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;stringValue&quot;</span><span class="punctuation">:</span><span class="string">&quot;server&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span><span class="string">&quot;instance_num&quot;</span><span class="punctuation">,</span><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;intValue&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;droppedAttributesCount&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;traceId&quot;</span><span class="punctuation">:</span><span class="string">&quot;08040201000000000000000000000000&quot;</span><span class="punctuation">,</span><span class="attr">&quot;spanId&quot;</span><span class="punctuation">:</span><span class="string">&quot;0102040800000000&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;timeUnixNano&quot;</span><span class="punctuation">:</span><span class="string">&quot;1581452773000000789&quot;</span><span class="punctuation">,</span><span class="attr">&quot;severityNumber&quot;</span><span class="punctuation">:</span><span class="number">9</span><span class="punctuation">,</span><span class="attr">&quot;severityText&quot;</span><span class="punctuation">:</span><span class="string">&quot;Info&quot;</span><span class="punctuation">,</span><span class="attr">&quot;body&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;stringValue&quot;</span><span class="punctuation">:</span><span class="string">&quot;something happened&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span><span class="string">&quot;customer&quot;</span><span class="punctuation">,</span><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;stringValue&quot;</span><span class="punctuation">:</span><span class="string">&quot;acme&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span><span class="string">&quot;env&quot;</span><span class="punctuation">,</span><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;stringValue&quot;</span><span class="punctuation">:</span><span class="string">&quot;dev&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;droppedAttributesCount&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;traceId&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;spanId&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以配置 <code>otel.logs.exporter=otlp (default)</code> 可以将日志输出到 <code>oetl-collector</code> 中，再由他输出到后端存储中。</p><p>虽然这样 <code>otel-collectoer</code> 就成为瓶颈了，但我们也可以部署多个副本来降低压力。</p><p>同时也可以在应用中指定不同的 <code>endpoint(otel.exporter.otlp.endpoint=http://127.0.0.1:4317)</code> 来区分日志的 collector，与其他类型的 collector 做到资源隔离。</p><p>不过目前社区关于日志的实践还比较少，而且由于版本 1.0 版本 release 的时间也不算长，稳定性和之前的 filebeat 相比还得需要时间检验。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>理想情况下，我们需要将可观测性的三个重要组件都关联起来才能更好的排查定位问题。</p><p>比如当收到监控系统通过指标变化发出的报警时，可以通过链路追踪定位具体是哪个系统触发的问题。</p><p>之后通过 traceID 定位到具体的日志，再通过日志的上下文列出更多日志信息，这样整个链条就可以串联起来，可以极大的提高效率。</p><p>参考链接：</p><ul><li><a href="https://github.com/aliyun/aliyun-log-java-producer">https://github.com/aliyun/aliyun-log-java-producer</a></li><li><a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/">https://kubernetes.io/docs/concepts/cluster-administration/logging/</a></li><li><a href="https://coding.net/help/docs/orbit/env/logs-event/intro.html">https://coding.net/help/docs/orbit/env/logs-event/intro.html</a></li><li><a href="https://opentelemetry.io/docs/concepts/signals/logs/">https://opentelemetry.io/docs/concepts/signals/logs/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;当我们没有使用云原生方案部署应用时采用的日志方案往往是 ELK 技术栈。&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/03/16/5pNYcOuxgXzsG1F.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这套技术方案比较成熟，稳定性也很高，所以几乎成为了当时的标配。&lt;/p&gt;
&lt;p&gt;可是随着我们使用 kubernetes 步入云原生的时代后， kubernetes 把以往的操作系统上的许多底层都屏蔽，再由他提供了一些标准接口。&lt;/p&gt;
&lt;p&gt;同时在 kubernetes 中的日志来源也比传统虚拟机多，比如可能有容器、kubernetes 自身的事件、日志等。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="日志" scheme="http://crossoverjie.top/tags/%E6%97%A5%E5%BF%97/"/>
    
    <category term="kubernetes" scheme="http://crossoverjie.top/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>实战：如何编写一个 OpenTelemetry Extensions</title>
    <link href="http://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/"/>
    <id>http://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/</id>
    <published>2024-04-15T06:14:54.000Z</published>
    <updated>2024-04-15T13:27:35.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间我们从 <code>SkyWalking</code> 切换到了 <code>OpenTelemetry</code> ，与此同时之前使用 SkyWalking 编写的插件也得转移到 OpenTelemetry 体系下。</p><p>我也写了相关介绍文章：<br>实战：<a href="https://juejin.cn/post/7341669201010262053">如何优雅的从 SkyWalking 切换到 OpenTelemetry</a></p><p>好在 OpenTelemetry 社区也提供了 Extensions 的扩展开发，我们可以不用去修改社区发行版：<code>opentelemetry-javaagent.jar</code> 的源码也可以扩展其中的能力。</p><p>比如可以：</p><ul><li>修改一些 trace，某些 span 不想记录等。</li><li>新增 metrics</li></ul><span id="more"></span><p>这次我准备编写的插件也是和 metrics 有关的，因为 pulsar 的 Java sdk 中并没有暴露客户端的一些监控指标，所以我需要在插件中拦截到一些关键函数，然后执行暴露出指标。</p><p>截止到本文编写的时候， Pulsar 社区也已经将 <code>Java-client</code> <a href="https://github.com/apache/pulsar/pull/22178">集成</a>了 OpenTelemetry，后续正式发版后我这个插件也可以光荣退休了。</p><hr><p>由于 OpenTelemetry 社区还处于高速发展阶段，我在中文社区没有找到类似的参考文章（甚至英文社区也没有，只有一些 example 代码，或者是只有去社区成熟插件里去参考代码）</p><p>其中也踩了不少坑，所以觉得非常有必要分享出来帮助大家减少遇到同类问题的机会。</p><h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>OpenTelemetry extension 的写法其实和 <code>skywalking</code> 相似，都是用的 <a href="https://bytebuddy.net/#/">bytebuddy</a>这个字节码增强库，只是在一些 API 上有一些区别。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>首先需要创建一个 Java 项目，这里我直接参考了官方的示例，使用了 gradle 进行管理（理论上 maven 也是可以的，只是要找到在 gradle 使用的 maven 插件）。</p><p>这里贴一下简化版的 <code>build.gradle</code> 文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    id <span class="string">&quot;com.github.johnrengelman.shadow&quot;</span> version <span class="string">&quot;8.1.1&quot;</span></span><br><span class="line">    id <span class="string">&quot;com.diffplug.spotless&quot;</span> version <span class="string">&quot;6.24.0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span> = <span class="string">&#x27;com.xx.otel.extensions&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;1.0.0&#x27;</span></span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    versions = [</span><br><span class="line">            <span class="comment">// this line is managed by .github/scripts/update-sdk-version.sh</span></span><br><span class="line">            opentelemetrySdk           : <span class="string">&quot;1.34.1&quot;</span>,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// these lines are managed by .github/scripts/update-version.sh</span></span><br><span class="line">            opentelemetryJavaagent     : <span class="string">&quot;2.1.0-SNAPSHOT&quot;</span>,</span><br><span class="line">            opentelemetryJavaagentAlpha: <span class="string">&quot;2.1.0-alpha-SNAPSHOT&quot;</span>,</span><br><span class="line"></span><br><span class="line">            junit                      : <span class="string">&quot;5.10.1&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    deps = [</span><br><span class="line">    <span class="comment">// 自动生成服务发现 service 文件</span></span><br><span class="line">            autoservice: <span class="keyword">dependencies</span>.create(<span class="keyword">group</span>: <span class="string">&#x27;com.google.auto.service&#x27;</span>, name: <span class="string">&#x27;auto-service&#x27;</span>, version: <span class="string">&#x27;1.1.1&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    mavenLocal()</span><br><span class="line">    maven &#123; url <span class="string">&quot;https://maven.aliyun.com/repository/public&quot;</span> &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">configurations</span> &#123;</span><br><span class="line">    otel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line"></span><br><span class="line">    implementation(platform(<span class="string">&quot;io.opentelemetry:opentelemetry-bom:$&#123;versions.opentelemetrySdk&#125;&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Interfaces and SPIs that we implement. We use `compileOnly` dependency because during</span></span><br><span class="line"><span class="comment">    runtime all necessary classes are provided by javaagent itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    compileOnly <span class="string">&#x27;io.opentelemetry:opentelemetry-sdk-extension-autoconfigure-spi:1.34.1&#x27;</span></span><br><span class="line">    compileOnly <span class="string">&#x27;io.opentelemetry.instrumentation:opentelemetry-instrumentation-api:1.32.0&#x27;</span></span><br><span class="line">    compileOnly <span class="string">&#x27;io.opentelemetry.javaagent:opentelemetry-javaagent-extension-api:1.32.0-alpha&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Provides @AutoService annotation that makes registration of our SPI implementations much easier</span></span><br><span class="line">    compileOnly deps.autoservice</span><br><span class="line">    annotationProcessor deps.autoservice</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://mvnrepository.com/artifact/org.apache.pulsar/pulsar-client</span></span><br><span class="line">    compileOnly <span class="string">&#x27;org.apache.pulsar:pulsar-client:2.8.0&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后便是要创建  javaagent 的一个核心类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService(InstrumentationModule.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PulsarInstrumentationModule</span> <span class="keyword">extends</span> <span class="title class_">InstrumentationModule</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PulsarInstrumentationModule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;pulsar-client-metrics&quot;</span>, <span class="string">&quot;pulsar-client-metrics-2.8.0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个类中定义我们插件的名称，同时使用 <code>@AutoService</code> 注解可以在打包的时候帮我们在 <code>META-INF/services/</code>目录下生成 SPI 服务发现的文件：<br><img src="https://s2.loli.net/2024/03/10/krqEn7lsIQbKJh6.png"></p><blockquote><p>这是一个 Google 的插件，本质是插件是使用 SPI 的方式进行开发的。</p></blockquote><p>关于 SPI 以前也写过一篇文章，不熟的朋友可以用作参考：</p><ul><li><a href="https://crossoverjie.top/2020/02/24/wheel/cicada8-spi/">Java SPI 的原理与应用</a></li></ul><h2 id="创建-Instrumentation"><a href="#创建-Instrumentation" class="headerlink" title="创建 Instrumentation"></a>创建 Instrumentation</h2><p>之后就需要创建自己的 Instrumentation，这里可以把它理解为自己的拦截器，需要配置对哪个类的哪个函数进行拦截：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerCreateImplInstrumentation</span> <span class="keyword">implements</span> <span class="title class_">TypeInstrumentation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ElementMatcher&lt;TypeDescription&gt; <span class="title function_">typeMatcher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> named(<span class="string">&quot;org.apache.pulsar.client.impl.ProducerBuilderImpl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(TypeTransformer transformer)</span> &#123;</span><br><span class="line">        transformer.applyAdviceToMethod(</span><br><span class="line">                isMethod()</span><br><span class="line">                        .and(named(<span class="string">&quot;createAsync&quot;</span>)),</span><br><span class="line">                ProducerCreateImplInstrumentation.class.getName() + <span class="string">&quot;$ProducerCreateImplConstructorAdvice&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>比如这就是对 <code>ProducerBuilderImpl</code> 类的 createAsync 创建函数进行拦截，拦截之后的逻辑写在了 <code>ProducerCreateImplConstructorAdvice</code> 类中。</p><p>值得注意的是对一些继承和实现类的拦截方式是不相同的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> ElementMatcher&lt;TypeDescription&gt; <span class="title function_">typeMatcher</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> extendsClass(named(ENHANCE_CLASS));  </span><br><span class="line">    <span class="comment">// return implementsInterface(named(ENHANCE_CLASS));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这两个函数名称就能看出，分别是针对继承和实现类进行拦截的。</p><blockquote><p>这里的 API 比 SkyWalking 的更易读一些。</p></blockquote><p>之后需要把我们自定义的 Instrumentation 注册到刚才的 PulsarInstrumentationModule 类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;TypeInstrumentation&gt; <span class="title function_">typeInstrumentations</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ProducerCreateImplInstrumentation</span>(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ProducerCloseImplInstrumentation</span>(),</span><br><span class="line">            );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有多个的话也都得进行注册。</p><h2 id="编写切面代码"><a href="#编写切面代码" class="headerlink" title="编写切面代码"></a>编写切面代码</h2><p>之后便是编写我们自定义的切面逻辑了，也就是刚才自定义的 <code>ProducerCreateImplConstructorAdvice</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ProducerCreateImplConstructorAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Advice</span>.OnMethodEnter(suppress = Throwable.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">onEnter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// inert your code</span></span><br><span class="line">        MetricsRegistration.registerProducer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Advice</span>.OnMethodExit(suppress = Throwable.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Advice</span>.Return CompletableFuture&lt;Producer&gt; completableFuture)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> completableFuture.get();</span><br><span class="line">            CollectionHelper.PRODUCER_COLLECTION.addObject(producer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看得出来其实就是两个核心的注解：</p><ul><li><code>@Advice.OnMethodEnter</code> 切面函数调用之前</li><li><code>@Advice.OnMethodExit</code> 切面函数调用之后</li></ul><p>还可以在 <code>@Advice.OnMethodExit</code>的函数中使用 <code>@Advice.Return</code>获得函数调用的返回值。</p><p>当然也可以使用 <code>@Advice.This</code> 来获取切面的调用对象。</p><h2 id="编写自定义-metrics"><a href="#编写自定义-metrics" class="headerlink" title="编写自定义 metrics"></a>编写自定义 metrics</h2><p>因为我这个插件的主要目的是暴露一些自定义的 metrics，所以需要使用到 <code>io.opentelemetry.api.metrics</code> 这个包：</p><p>这里以 Producer 生产者为例，整体流程如下：</p><ul><li>创建生产者的时候将生产者对象存储起来</li><li>OpenTelemetry 框架会每隔一段时间回调一个自定义的函数</li><li>在这个函数中遍历所有的 producer 获取它的监控指标，然后暴露出去。</li></ul><p>注册函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerObservers</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">Meter</span> <span class="variable">meter</span> <span class="operator">=</span> MetricsRegistration.getMeter();  </span><br><span class="line">  </span><br><span class="line">    meter.gaugeBuilder(<span class="string">&quot;pulsar_producer_num_msg_send&quot;</span>)  </span><br><span class="line">            .setDescription(<span class="string">&quot;The number of messages published in the last interval&quot;</span>)  </span><br><span class="line">            .ofLongs()  </span><br><span class="line">            .buildWithCallback(  </span><br><span class="line">                    r -&gt; recordProducerMetrics(r, ProducerStats::getNumMsgsSent));</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recordProducerMetrics</span><span class="params">(ObservableLongMeasurement observableLongMeasurement, Function&lt;ProducerStats, Long&gt; getter)</span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> (Producer producer : CollectionHelper.PRODUCER_COLLECTION.list()) &#123;  </span><br><span class="line">        <span class="type">ProducerStats</span> <span class="variable">stats</span> <span class="operator">=</span> producer.getStats();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> producer.getTopic();  </span><br><span class="line">        <span class="keyword">if</span> (topic.endsWith(RetryMessageUtil.RETRY_GROUP_TOPIC_SUFFIX)) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;        observableLongMeasurement.record(getter.apply(stats),  </span><br><span class="line">                Attributes.of(PRODUCER_NAME, producer.getProducerName(), TOPIC, topic));  </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>回调函数，在这个函数中遍历所有的生产者，然后读取它的监控指标。</p><p>这样就完成了一个自定义指标的暴露，使用的时候只需要加载这个插件即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent.jar \</span><br><span class="line">     -Dotel.javaagent.extensions=ext.jar</span><br><span class="line">     -jar myapp.jar</span><br></pre></td></tr></table></figure><p><code>-Dotel.javaagent.extensions=/extensions</code><br>当然也可以指定一个目录，该目录下所有的 jar 都会被作为 extensions 被加入进来。</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>使用 <code>./gradlew build</code> 打包，之后可以在<code>build/libs/</code>目录下找到生成物。</p><p>当然也可以将 extension 直接打包到 <code>opentelemetry-javaagent.jar</code>中，这样就可以不用指定 <code>-Dotel.javaagent.extensions</code>参数了。</p><p>具体可以在 gradle 中加入以下 task：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">task <span class="title function_">extendedAgent</span><span class="params">(type: Jar)</span> &#123;</span><br><span class="line">  dependsOn(configurations.otel)</span><br><span class="line">  archiveFileName = <span class="string">&quot;opentelemetry-javaagent.jar&quot;</span></span><br><span class="line">  from <span class="title function_">zipTree</span><span class="params">(configurations.otel.singleFile)</span></span><br><span class="line">  from(tasks.shadowJar.archiveFile) &#123;</span><br><span class="line">    into <span class="string">&quot;extensions&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Preserve MANIFEST.MF file from the upstream javaagent</span></span><br><span class="line">  doFirst &#123;</span><br><span class="line">    manifest.from(</span><br><span class="line">      zipTree(configurations.otel.singleFile).matching &#123;</span><br><span class="line">        include <span class="string">&#x27;META-INF/MANIFEST.MF&#x27;</span></span><br><span class="line">      &#125;.singleFile</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体可以参考这里的配置：<br><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/examples/extension/build.gradle#L125">https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/examples/extension/build.gradle#L125</a></p><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><p>看起来这个开发过程挺简单的，但其中的坑还是不少。</p><h2 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h2><p>首先第一个就是我在调试过程中出现 <code>NoClassDefFoundError</code> 的异常。</p><p>但我把打包好的 extension 解压后明明是可以看到这个类的。</p><p><img src="https://s2.loli.net/2024/03/10/oyfEm27Tz5IJCnF.png"></p><p>排查一段时间后没啥头绪，我就从头仔细阅读了开发文档：<br><img src="https://s2.loli.net/2024/03/10/sLbS7Hum5TUz1VD.png"></p><p>发现我们需要重写 <code>getAdditionalHelperClassNames</code>函数，用于将我们外部的一些工具类加入到应用的 class loader 中，不然在应用在运行的时候就会报 <code>NoClassDefFoundError</code> 的错误。</p><p>因为是字节码增强的关系，所以很多日常开发觉得很常见的地方都不行了，比如：</p><ul><li>如果切面类是一个内部类的时候，必须使用静态函数</li><li>只能包含静态函数</li><li>不能包含任何字段，常量。</li><li>不能使用任何外部类，如果要使用就得使用 <code>getAdditionalHelperClassNames</code> 额外加入到 class loader 中（这一条就是我遇到的问题）</li><li>所有的函数必须使用 <code>@Advice</code> 注解</li></ul><p>以上的内容其实在文档中都有写：<br><img src="https://s2.loli.net/2024/03/10/1bXg6CMZYaUmdsu.png"></p><p>所以还是得仔细阅读文档。</p><h2 id="缺少异常日志"><a href="#缺少异常日志" class="headerlink" title="缺少异常日志"></a>缺少异常日志</h2><p>其实上述的异常刚开始都没有打印出来，只有一个现象就是程序没有正常运行。</p><p>因为没有日志也不知道如何排查，也怀疑是不是运行过程中报错了，所以就尝试把<code>@Advice</code> 注解的函数全部 try catch ，果然打印了上述的异常日志。</p><p><img src="https://s2.loli.net/2024/03/10/RMZbpyvkVc9qmJL.png"></p><p>之后我注意到了注解的这个参数，原来在默认情况下是不会打印任何日志的，需要手动打开。</p><p>比如这样：<code>@Advice.OnMethodExit(suppress = Throwable.class)</code></p><h2 id="调试日志"><a href="#调试日志" class="headerlink" title="调试日志"></a>调试日志</h2><p>最后就是调试功能了，因为我这个插件的是把指标发送到 OpenTelemetry-collector ，再由它发往 <code>VictoriaMetrics/Prometheus</code>；由于整个链路比较长，我想看到最终生成的指标是否正常的干扰条件太多了。</p><p>好在 OpenTelemetry 提供了多种 metrics.exporter 的输出方式：</p><ul><li>-Dotel.metrics.exporter&#x3D;otlp (default)，默认通过 otlp 协议输出到 collector 中。</li><li>-Dotel.metrics.exporter&#x3D;logging，以 stdout 的方式输出到控制台，主要用于调试</li><li>-Dotel.metrics.exporter&#x3D;logging-otlp</li><li>-Dotel.metrics.exporter&#x3D;prometheus，以 Prometheus 的方式输出，还可以配置端口，这样也可以让 Prometheus 进行远程采集，同样的也可以在本地调试。</li></ul><p>采用哪种方式可以根据环境情况自行选择。</p><h1 id="Opentelemetry-operator-配置-extension"><a href="#Opentelemetry-operator-配置-extension" class="headerlink" title="Opentelemetry-operator 配置 extension"></a>Opentelemetry-operator 配置 extension</h1><p>最近在使用 <code>opentelemetry-operator</code>注入 agent 的时候发现 operator 目前并不支持配置 extension，所以在社区也提交了一个<a href="https://github.com/open-telemetry/opentelemetry-operator/issues/1758#issuecomment-1982159356">草案</a>，下周会尝试提交一个 PR 来新增这个特性。</p><blockquote><p>这个需求我在 issue 列表中找到了好几个，时间也挺久远了，不太确定为什么社区还为实现。</p></blockquote><p>目前 operator 只支持在自定义镜像中配置 <code>javaagent.jar</code>，无法配置 extension：</p><blockquote><p>这个原理在之前的<a href="https://juejin.cn/post/7341669201010262053#heading-9">文章</a>中有提到。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">opentelemetry.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Instrumentation</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-instrumentation</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">java:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">your-customized-auto-instrumentation-image:java</span></span><br></pre></td></tr></table></figure><p>我的目的是可以在自定义镜像中把 extension 也复制进去，类似于这样：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> open-telemetry/opentelemetry-javaagent.jar /javaagent.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy extensions to specify a path.</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> open-telemetry/ext-1.0.0.jar /ext-1.0.0.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> -R go+r /javaagent.jar</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> -R go+r /ext-1.0.0.jar</span></span><br></pre></td></tr></table></figure><p>然后在 CRD 中配置这个 <code>extension</code> 的路径：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">opentelemetry.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Instrumentation</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-instrumentation</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">java:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">custom-image:1.0.0</span></span><br><span class="line">    <span class="attr">extensions:</span> <span class="string">/ext-1.0.0.jar</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="comment"># If extension.jar already exists in the container, you can only specify a specific path with this environment variable.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXTENSIONS_DIR</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">/custom-dir</span></span><br></pre></td></tr></table></figure><p>这样 operator 在拿到 extension 的路径时，就可以在环境变量中加入 <code>-Dotel.javaagent.extensions=$&#123;java.extensions&#125;</code> 参数，从而实现自定义 extension 的目的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个过程其实并不复杂，只是由于目前用的人还不算多，所以也很少有人写教程或者文章，相信用不了多久就会慢慢普及。</p><p>这里有一些官方的 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/examples/extension#extensions-examples">example</a>可以参考。</p><p>参考链接：</p><ul><li><a href="https://github.com/apache/pulsar/pull/22178">https://github.com/apache/pulsar/pull/22178</a></li><li><a href="https://opentelemetry.io/docs/languages/java/automatic/extensions/">https://opentelemetry.io/docs/languages/java/automatic/extensions/</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/examples/extension#extensions-examples">https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/examples/extension#extensions-examples</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-operator/issues/1758#issuecomment-1982159356">https://github.com/open-telemetry/opentelemetry-operator/issues/1758#issuecomment-1982159356</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间我们从 &lt;code&gt;SkyWalking&lt;/code&gt; 切换到了 &lt;code&gt;OpenTelemetry&lt;/code&gt; ，与此同时之前使用 SkyWalking 编写的插件也得转移到 OpenTelemetry 体系下。&lt;/p&gt;
&lt;p&gt;我也写了相关介绍文章：&lt;br&gt;实战：&lt;a href=&quot;https://juejin.cn/post/7341669201010262053&quot;&gt;如何优雅的从 SkyWalking 切换到 OpenTelemetry&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好在 OpenTelemetry 社区也提供了 Extensions 的扩展开发，我们可以不用去修改社区发行版：&lt;code&gt;opentelemetry-javaagent.jar&lt;/code&gt; 的源码也可以扩展其中的能力。&lt;/p&gt;
&lt;p&gt;比如可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改一些 trace，某些 span 不想记录等。&lt;/li&gt;
&lt;li&gt;新增 metrics&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>2024年的云原生架构需要哪些技术栈</title>
    <link href="http://crossoverjie.top/2024/04/11/ob/2024-cloud-native/"/>
    <id>http://crossoverjie.top/2024/04/11/ob/2024-cloud-native/</id>
    <published>2024-04-11T02:22:21.000Z</published>
    <updated>2024-04-10T13:34:24.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>时间过得很快啊，一转眼已经到了 2024 年，还记得 15 年刚工作那会掌握个 <code>SSM/H(Spring/Struts2/Mybatis/Hibernate)</code> 框架就能应付大部分面试了。</p><blockquote><p>现在 CS 专业的新同学估计都没听说过 SSM😢</p></blockquote><p>恰好从我刚开始工作时的移动互联网热潮到电商-&gt;共享经济-&gt;toB 大热-&gt;如今我都经历了一遍，技术栈也有由最开始的单体应用+物理机发展到现在的 kubernetes 云原生架构。</p><p>当然中途也经历了几个大的阶段：<br>SOA服务化-&gt; 微服务-&gt; 云原生-&gt; 服务网格-&gt; 无服务等几个阶段。</p><p>最近一份工作又主要是在做基础架构，我认为了解的还算是比较全面的，所以本文我就以我的视角分享下我们在 2024 年应当使用哪些云原生技术栈，因为涉及到的技术组件比较多，就不过多讨论细节了。</p><p>但可以保证的是提到的技术栈都是我所用过的，优缺点都会提到，主打一个真实体验。</p><span id="more"></span><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p> 首先是操作系统，这里有别于以往我们传统的操作系统(Linux&#x2F;Windows Server&#x2F;MacOS)，主要指的是云原生的操作系统，没有太多可以选择的余地，那就是 <code>kubernetes</code>。</p><p>不过怎么维护好 kubernetes 是一个难点问题，还记得去年下半年滴滴出过一次事故，网传就是 kubernetes 升级出现的问题。</p><p>根据我们的经验来看，对于小团队更建议直接托管给云厂商，维护 kubernetes 是一个非常复杂的工作，小团队通常都是一职多能，自己维护更容易出问题。</p><p>当然大团队有专人维护最好，即便是出问题也能快速响应，前提是自己能 cover 住这个风险。</p><blockquote><p>因为我们是小团队，所以考虑到成本和稳定性，我们也只使用了云厂商的 kubernetes 能力，其余的部分可控组件由我们自己维护（具体的后文会讲到）</p></blockquote><h2 id="多云的优势与好处"><a href="#多云的优势与好处" class="headerlink" title="多云的优势与好处"></a>多云的优势与好处</h2><p>既然都用了云厂商的容器服务，那也要考虑到云厂商故障可能带来的问题；比如去年的阿里云故障。</p><p>所以现在一些中大厂也会选择多云方案，将同一份代码部署再多个云服务商，一旦其中一个出现问题可以快速切换。</p><p>但具体的实施过程中也有许多挑战，比如最棘手也是最关键的数据一致性如何保证？</p><p>当然我们可以采用一些支持分布式部署的数据库或中间件，他们本身是支持数据同步的；比如消息队列中的 Pulsar，它就可以跨级群部署以及消息同步。</p><p>同时多云部署对应的成本也会提升，在这个“降本增效”的大背景下也得慎重考虑；所以对此还有一个折中方案：</p><blockquote><p>我们的技术架构需要具备快速迁移到其他云服务的能力，比如我们内部有一些工具可以定期备份资源，比如 MySQL 的 binlog，一些中间件的元数据，同时可以基于这些元数据快速恢复业务。</p></blockquote><p>一般遇到需要切换云服务时都是一些极端情况，所以允许部分运行时的数据丢失也是能接受的，我们只要保证最核心的数据不会丢失从而不影响业务即可。</p><p>这个说起来简单，但也需要我们花时间进行模拟演练；具体是否实施就得看公司是否接受云服务宕机带来的损失以及演练所花的成本了。</p><blockquote><p>我们是具备恢复元数据能力的，但会丢失部分运行时的数据。</p></blockquote><h1 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h1><p>既然我们已经选择 kubernetes 作为我们云原生的操作系统，那我们的持续集成与发布也得围绕着 kubernetes 来做。</p><p><img src="https://s2.loli.net/2024/03/05/P2ducxQtqSCGnDb.png"></p><p>上图是一张使用 Git 配合 gitlab+ArgoCD 的流程图，我们使用 gitlab 来管理源码，同时也可以利用他的 Pipline 帮我们做持续集成，最终使用 Argo 帮我们打通 kubernetes 的流程。</p><blockquote><p>也就是我们常说的 <code>GitOps</code></p></blockquote><p>同时我们的回滚历史版本，扩缩容都由 kubernetes 提供能力，我们的 DevOps 平台只需要调用 kubernetes 的 API 即可。</p><p>当然还有现在流行 FinOps，我的理解主要是做云成本的管理和优化，对应到我的工作就是回收一些不用的资源，在不影响业务的情况下适当的降低一些配置😳。</p><h1 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h1><p><img src="https://s2.loli.net/2024/03/06/mlzdFAHNM6bDGvr.png"></p><p>接下来便是我认为最重要的 Service Mesh 环节了，这个的背景故事就多了，本质上我觉得这都是由 RPC(Remote Process Call) 引起的也是分布式所带来的。</p><p>由最开始的单机的本地函数调用开始：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">local+------&gt;remote +------&gt; micro-service+-----&gt;service-mesh</span><br><span class="line">               +                  |                    +</span><br><span class="line">               v                  v                    v</span><br><span class="line">           +---+----+       +-----+------+        +----+----+</span><br><span class="line">           | motan  |       | SpringCloud|        | Istio   |</span><br><span class="line">           | dubbo  |       | Dubbo3.0   |        | Linkerd |</span><br><span class="line">           | gRPC   |       | SOFA       |        |         |</span><br><span class="line">           +--------+       +------------+        +---------+</span><br></pre></td></tr></table></figure><p>主要经历了以上三个重要的阶段，分别是 RPC 框架到微服务再到现在的服务网格。</p><ul><li>RPC 框架主要帮我们简化了分布式通信，只专注于业务本身</li><li>微服务框架的出现可以更好的帮我们治理大批量的服务，比如一些限流、路由、降级等功能，让我们分布式应用更加健壮。</li><li>而如今的服务网格让我们的应用程序更加适配云原生，专注于业务研发而不再需要去维护微服务框架；将这些基础功能全部下沉到我们的基础层，同时也带来了不弱于微服务框架的功能性。</li></ul><p>但使用 Istio 也有着不低的技术门槛，我觉得如果满足以下条件更推荐使用 Istio：</p><ul><li>应用已经接入 kubernetes 平台</li><li>应用之间采用的是 gRPC 通讯框架</li><li>API 网关也迁移到 Istio Gateway</li><li>公司至少预备一个专人维护 Istio（这里的维护不一定是对代码的了解，但一定要对 Istio 本身的功能和文档足够了解）</li></ul><p>除此之外使用 <code>SpringCloud</code>、<code>Dubbo</code>、<code>kratos</code>、<code>go-zero</code>之类的微服务框架也未尝不可。</p><p>我之前有写过两篇关于 Istio 的 文章，也可以用做参考：</p><ul><li><a href="https://crossoverjie.top/2023/10/16/ob/k8s-grpc-lb/">在 kubernetes 环境中实现 gRPC 负载均衡</a></li><li><a href="https://crossoverjie.top/2023/10/31/ob/k8s-Istio01/">服务网格实战-入门Istio</a></li></ul><h1 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h1><p><img src="https://s2.loli.net/2024/03/06/wOtk3Fb5fhEIWpB.png"><br>现如今可观测系统也变得越来越重要，个人觉得评价一个技术团队重要指标就是他们的可观测系统做的如何。</p><p>一个优秀的可观测系统可以清晰得知系统的运行状态、高效的排查问题、还有及时的故障告警。</p><p>要实现上述标准就需要我们可观测系统的三个核心指标了：</p><p><img src="https://s2.loli.net/2024/03/06/gXQIfcJO1qVWimH.png"></p><ul><li>Metrics，借助它我们可以在 Grafana 中绘制出各种直观的面板，可以更加全面的了解我们系统的运行状态</li></ul><p><img src="https://s2.loli.net/2024/03/06/sWk2gXnTNxuafBF.png"></p><ul><li>Trace则是可以帮助我们构建出系统调用的全貌，通过一个 trace 就可以知道一个请求经历了哪些系统，在哪个环节出了问题。</li><li>Logs 就比较好理解了，就是我们自己在应用里打印的一些日志；只是和以往的开发模式略有不同的是：在云原生体系中更推荐直接输出到标准输出和标准错误流中，一些第三方采集组件可以更方便的进行采集。</li></ul><hr><p>我们自己的可观测系统经历过一次迭代，以往的技术栈是：</p><ul><li><code>Metrics</code> 使用 <code>VictoriaMetrics</code>：这是一个完全兼容 <code>Prometheus</code> 的时序数据库，但相对 <code>Prometheus</code> 来说更加的节省资源。</li><li>Trace 选择的是 <code>SkyWalking</code>，这也是 Java trace 领域比较流行的技术方案。</li><li>Logs：使用 filebeat 采集日志然后输出到 ElasticSearch 中，这也是比较经典的方案。</li></ul><p>去年底我们做了一次比较大的改造，主要就是将 <code>SkyWalking</code> 换为了 <code>OpenTelemetry</code>，这是一个更加开放的社区，也逐渐成为云原生可观测的标准了。</p><p>使用它我们的灵活性更高，不用与某些具体的技术栈进行绑定；目前 logs 还没有切换，社区也还在 beta 测试中，后续成熟后也可以直接用 <code>OpenTelemetry</code> 来收集日志。</p><p>我也写的有一篇 SW 迁移到 <code>OpenTelemetry</code> 的文章，感兴趣的朋友可以参考：</p><ul><li><a href="https://juejin.cn/post/7341669201010262053">实战：如何优雅的从 SkyWalking 切换到 OpenTelemetry</a></li></ul><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>这里单独把消息队列拎出来是因为我目前主要是在维护公司内部的消息队列，同时业务体量大了之后消息队列变得非常重要了，通常会充当各个业务线对接的桥梁，或者是数据库同步 MySQL 的渠道，总之用处非常广泛。</p><p><img src="https://s2.loli.net/2024/03/07/WBeYUK8AVlcrgGs.png"></p><p>这里还是推荐更贴合云原生的消息队列 Pulsar，由于它存算分离的架构特性，配合kubernetes 的特性可以实现快速的扩缩容，相比 kafka 来说更易维护；同时社区活跃度也非常高，在 Bug 修复和支持新特性方面比较积极。</p><p>Pulsar官方支持的客户端也比较全面：</p><table><thead><tr><th>Language</th><th>Documentation</th><th>Release note</th><th>Code repo</th></tr></thead><tbody><tr><td>Java</td><td><a href="client-libraries-java.md">User doc</a>   <br/> <a href="/api/client/">API doc</a></td><td><a href="pathname:///release-notes/client-java">Standalone</a></td><td><a href="https://github.com/apache/pulsar/tree/master/pulsar-client">Bundled</a></td></tr><tr><td>C++</td><td><a href="client-libraries-cpp.md">User doc</a>    <br/> <a href="@pulsar:apidoc:cpp@">API doc</a></td><td><a href="pathname:///release-notes/client-cpp">Standalone</a></td><td><a href="https://github.com/apache/pulsar-client-cpp">Standalone</a></td></tr><tr><td>Python</td><td><a href="client-libraries-python.md">User doc</a> <br/> <a href="@pulsar:apidoc:python@">API doc</a></td><td><a href="pathname:///release-notes/client-python">Standalone</a></td><td><a href="https://github.com/apache/pulsar-client-python">Standalone</a></td></tr><tr><td>Go client</td><td><a href="client-libraries-go.md">User doc</a>   <br/> <a href="https://pkg.go.dev/github.com/apache/pulsar-client-go/pulsar">API doc</a></td><td><a href="pathname:///release-notes/client-go">Standalone</a></td><td><a href="https://github.com/apache/pulsar-client-go">Standalone</a></td></tr><tr><td>Node.js</td><td><a href="client-libraries-node.md">User doc</a>  <br/> <a href="@pulsar:apidoc:js@">API doc</a></td><td><a href="pathname:///release-notes/client-node">Standalone</a></td><td><a href="https://github.com/apache/pulsar-client-node">Standalone</a></td></tr><tr><td>C#&#x2F;DotPulsar</td><td><a href="client-libraries-dotnet.md">User doc</a></td><td><a href="pathname:///release-notes/client-cs">Standalone</a></td><td><a href="https://github.com/apache/pulsar-dotpulsar">Standalone</a></td></tr></tbody></table><p>还有一个问题是：如何部署我们的 Pulsar 集群，是私有化部署还是购买云服务（目前 Pulsar的商业公司 streamnative 和国内的腾讯云都有类似的服务）</p><p>我们之前有咨询过价格，相对来说还是自己部署性价比最高；和前文讲的一样，只使用云厂商的 kubernetes 服务，在这基础上部署我们的自己的服务。</p><p>因为得益于 Pulsar 社区的活跃，即便是自己维护出现问题也可以及时得到反馈；同时自己平时踩的坑也可以反哺社区。</p><p>之前也写过一些关于 Pulsar 的系列文章，感兴趣的可以查阅：</p><ul><li><a href="https://juejin.cn/post/7340195874867904547">在 kubernetes 环境下如何优雅扩缩容 Pulsar</a></li><li><a href="https://crossoverjie.top/2024/01/03/ob/Pulsar3.0-new-feature/">Pulsar3.0新功能介绍</a></li><li><a href="https://crossoverjie.top/2023/02/07/pulsar/pulsar-load-banance/">Pulsar负载均衡原理及优化</a></li><li><a href="https://crossoverjie.top/2024/01/15/ob/Bookkeeper-storage/">白话 Pulsar Bookkeeper 的存储模型</a></li><li><a href="https://crossoverjie.top/2023/01/16/pulsar/pulsar-perf-test/">Pulsar压测及优化</a></li></ul><h1 id="业务框架"><a href="#业务框架" class="headerlink" title="业务框架"></a>业务框架</h1><p>最后是业务框架的选择，决定这个的前提是我们先要确定选择哪个语言作为主力业务语言。</p><p>虽然这点对于 kubernetes 来说无关紧要，下面以我比较熟悉的 Java 和 Golang 进行介绍。</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>Java 可选的技术方案就比较多了，如果我们只是上了 kubernetes 但没有使用服务网格；那完全可以只使用 <code>springboot</code> 开发 http 接口，就和开发一个单体应用一样简单。</p><p>只是这样会缺少一些服务治理的能力，更适用于中小型团队。</p><p>如果团队人员较多，也没使用服务网格时；那就推荐使用前文介绍的微服务框架：比如 Dubbo、SpringCloud 等。</p><p>当有专门的云原生团队时，则更推荐使用服务网格的方案，这样我们就能综合以上两种方案的优点：</p><ul><li>代码简洁，只是需要将 http 换为 gRPC。</li><li>同时利用 Istio 也包含了微服务框架的能力。</li></ul><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><p>Golang 其实也与 Java 类似，中小团队时我们完全可以只使用 Gin 这类 http 框架进行开发。</p><p>而中大型团队在 <code>Golang</code> 生态中也有对标 <code>Dubbo</code> 和 <code>SpringCloud</code> 的框架，比如 <a href="https://github.com/go-kratos/kratos">kratos</a>和 <a href="https://github.com/zeromicro/go-zero">go-zero</a> 等。</p><p>得益于 Golang 的简洁特性，我觉得比使用 Java 开发业务更加简单和“无脑”。</p><p>同样的后续也可以切换到服务网格，直接采用 gRPC 和 Golang 也非常适配，此时团队应该也比较成熟了，完全可以自己基于 gRPC 做一个开发脚手架，或者也可以使用 Kratos 或者是 go-zero 去掉他们的服务调用模块即可。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是个人对目前流行的技术方案的理解，也分别对不同团队规模进行了推荐；确实没有完美的技术方案，只有最合适的，也不要跟风选择一些自己不能把控的技术栈，最终吃亏的可能就是自己。</p><p>参考链接：</p><ul><li><a href="https://levelup.gitconnected.com/gitops-in-kubernetes-with-gitlab-ci-and-argocd-9e20b5d3b55b">https://levelup.gitconnected.com/gitops-in-kubernetes-with-gitlab-ci-and-argocd-9e20b5d3b55b</a></li><li><a href="https://grpc.io/">https://grpc.io/</a></li></ul><p>#Blog #CloudNative </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;时间过得很快啊，一转眼已经到了 2024 年，还记得 15 年刚工作那会掌握个 &lt;code&gt;SSM/H(Spring/Struts2/Mybatis/Hibernate)&lt;/code&gt; 框架就能应付大部分面试了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在 CS 专业的新同学估计都没听说过 SSM😢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;恰好从我刚开始工作时的移动互联网热潮到电商-&amp;gt;共享经济-&amp;gt;toB 大热-&amp;gt;如今我都经历了一遍，技术栈也有由最开始的单体应用+物理机发展到现在的 kubernetes 云原生架构。&lt;/p&gt;
&lt;p&gt;当然中途也经历了几个大的阶段：&lt;br&gt;SOA服务化-&amp;gt; 微服务-&amp;gt; 云原生-&amp;gt; 服务网格-&amp;gt; 无服务等几个阶段。&lt;/p&gt;
&lt;p&gt;最近一份工作又主要是在做基础架构，我认为了解的还算是比较全面的，所以本文我就以我的视角分享下我们在 2024 年应当使用哪些云原生技术栈，因为涉及到的技术组件比较多，就不过多讨论细节了。&lt;/p&gt;
&lt;p&gt;但可以保证的是提到的技术栈都是我所用过的，优缺点都会提到，主打一个真实体验。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="CloudNative" scheme="http://crossoverjie.top/tags/CloudNative/"/>
    
    <category term="k8s" scheme="http://crossoverjie.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>实战：如何优雅的从 Skywalking 切换到 OpenTelemetry</title>
    <link href="http://crossoverjie.top/2024/04/07/ob/otel-replace-sw/"/>
    <id>http://crossoverjie.top/2024/04/07/ob/otel-replace-sw/</id>
    <published>2024-04-07T09:16:21.000Z</published>
    <updated>2024-04-07T15:27:53.792Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/03/04/8YFIh7suTirZacj.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近公司将我们之前使用的链路工具切换为了 <code>OpenTelemetry</code>.</p><p><img src="https://s2.loli.net/2024/03/03/9V1aUnpOd8EAG2Y.png"></p><span id="more"></span><p>我们的技术栈是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        OTLP                               </span><br><span class="line">Client──────────►Collect────────►StartRocks</span><br><span class="line">(Agent)                               ▲    </span><br><span class="line">                                      │    </span><br><span class="line">                                      │    </span><br><span class="line">                                   Jaeger                                       </span><br></pre></td></tr></table></figure><p>其中客户端使用 OpenTelemetry 提供的 Java Agent 进行埋点收集数据，再由 Agent 通过 OTLP(OpenTelemetry Protocol) 协议将数据发往 Collector，在 <code>Collector</code> 中我们可以自行任意处理数据，并决定将这些数据如何存储（这点在以往的 SkyWalking 体系中是很难自定义的）</p><p>这里我们将数据写入 StartRocks 中，供之后的 UI 层进行查看。</p><blockquote><p><code>OpenTelemetry</code> 是可观测系统的新标准，基于它可以兼容以前使用的 Prometheus、 victoriametrics、skywalking 等系统，同时还可以灵活扩展，不用与任何但一生态或技术栈进行绑定。<br>更多关于 OTel 的内容会在今后介绍。</p></blockquote><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><p>其中有一个关键问题就是：如何在线上进行<strong>无缝切换</strong>。</p><p>虽然我们内部的发布系统已经支持重新发布后就会切换到新的链路，也可以让业务自行发布然后逐步的切换到新的系统，这样也是最保险的方式。</p><p>但这样会有几个问题：</p><ul><li>当存在调用依赖的系统没有全部切换为新链路时，再查询的时候就会出现断层，整个链路无法全部串联起来。</li><li>业务团队没有足够的动力去推动发布，可能切换的周期较长。</li></ul><p>所以最好的方式还是由我们在后台统一发布，对外没有任何感知就可以一键全部切换为 OpenTelemetry。</p><p>仔细一看貌似也没什么难的，无非就是模拟用户点击发布按钮而已。</p><p>但这事由我们自动来做就不一样了，用户点击发布的时候会选择他们认为可以发布的分支进行发布，我们不能自作主张的比如选择 main 分支，有可能只是合并了但还不具备发布条件。</p><p>所以保险的方式还是得用当前项目上一次发布时所使用的 git hash 值重新打包发布。</p><p>但这也有几个问题：</p><ul><li>重复打包发布太慢了，线上几十上百个项目，每打包发布一次就得几分钟，虽然可以并发，但考虑到 kubernetes 的压力也不能调的太高。</li><li>保不准业务镜像中有单独加入一些环境变量，这样打包可能会漏。</li></ul><h1 id="切换方案"><a href="#切换方案" class="headerlink" title="切换方案"></a>切换方案</h1><p>所以思来想去最保险的方法还是将业务镜像拉取下来，然后手动删除镜像中的 skywalking 包以及 JVM 参数，全部替换为 OpenTelemetry 的包和 JVM 参数。</p><p>整体的方案如下：</p><ol><li>遍历 namespace 的 <code>pod ＞0</code> 的 deployment</li><li>遍历 deployment 中的所有 container，获得业务镜像<ol><li>跳过 istio 和日志采集 container，获取到业务容器</li><li>判断该容器是否需要替换，其实就是判断环境变量中是否有 skywalking ，如果有就需要替换。</li><li>获取业务容器的镜像</li></ol></li><li>基于该 Image 重新构建一个 OpenTelemetry 的镜像<br>   3.1 新的镜像包含新的启动脚本.<br>   3.1.1 新的启动脚本中会删除原有的 skywalking agent<br>   3.2 新镜像会包含 OpenTelemetry 的 jar 包以及我们自定义的 OTel 扩展包<br>   3.3 替换启动命令为新的启动脚本</li><li>修改 deployment 中的 JVM 启动参数</li><li>修改 deployment 的镜像后滚动更新</li><li>开启一个 goroutine 定时检测更新之后是否启动成功<ol><li>如果长时间 (比如五分钟) 都没有启动成功，则执行回滚流程</li></ol></li></ol><h1 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h1><p>因为需要涉及到操作 kubernetes，所以整体就使用 Golang 实现了。</p><h2 id="遍历-deployment-得到需要替换的容器镜像"><a href="#遍历-deployment-得到需要替换的容器镜像" class="headerlink" title="遍历 deployment 得到需要替换的容器镜像"></a>遍历 deployment 得到需要替换的容器镜像</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessDeployment</span><span class="params">(ctx context.Context, finish []<span class="type">string</span>, deployment v1.Deployment, clientSet kubernetes.Interface)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">deploymentName := deployment.Name</span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> finish &#123;</span><br><span class="line"><span class="keyword">if</span> s == deploymentName &#123;</span><br><span class="line">klog.Infof(<span class="string">&quot;Skip finish deployment:%s&quot;</span>, deploymentName)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Write finish deployment name to a file</span></span><br><span class="line"><span class="keyword">defer</span> writeDeploymentName2File(deploymentName, fmt.Sprintf(<span class="string">&quot;finish-%s.log&quot;</span>, deployment.Namespace))</span><br><span class="line"></span><br><span class="line">appName := deployment.GetObjectMeta().GetLabels()[<span class="string">&quot;appName&quot;</span>]</span><br><span class="line">klog.Infof(<span class="string">&quot;Begin to process deployment:%s, appName:%s&quot;</span>, deploymentName, appName)</span><br><span class="line"></span><br><span class="line">upgrade, err := checkContainIstio(ctx, deployment, clientSet)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> upgrade == <span class="literal">false</span> &#123;</span><br><span class="line">klog.Infof(<span class="string">&quot;Don&#x27;t have istio, No need to upgrade deployment:%s appName:%s&quot;</span>, deploymentName, appName)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, container := <span class="keyword">range</span> deployment.Spec.Template.Spec.Containers &#123;</span><br><span class="line"><span class="keyword">if</span> strings.HasPrefix(deploymentName, container.Name) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if container has sw jvm</span></span><br><span class="line"><span class="keyword">for</span> _, envVar := <span class="keyword">range</span> container.Env &#123;</span><br><span class="line"><span class="keyword">if</span> envVar.Name == <span class="string">&quot;CATALINA_OPTS&quot;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.Contains(envVar.Value, <span class="string">&quot;skywalking&quot;</span>) &#123;</span><br><span class="line">klog.Infof(<span class="string">&quot;Skip upgrade don&#x27;t have sw jvm deployment:%s container:%s&quot;</span>, deploymentName, container.Name)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">upgrade(container)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check newDeployment status</span></span><br><span class="line"><span class="keyword">go</span> checkNewDeploymentStatus(ctx, clientSet, newDeployment)</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete from image</span></span><br><span class="line">deleteImage(container.Image)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数需要传入一个 deployment ，同时还有一个已经完成了的列表进来。</p><blockquote><p>已完成列表用于多次运行的时候可以快速跳过已经执行的 deployment。</p></blockquote><p><code>checkContainIstio()</code> 函数很简单，判断是否包含了 Istio 容器，如果没有包含说明不是后端应用（可能是前端、大数据之类的任务），就可以直接跳过了。</p><hr><p><img src="https://s2.loli.net/2024/03/03/xzHPV9mgCJkZ4cY.png"><br>而判断是否需要替换的前提这事判断环境变量 <code>CATALINA_OPTS</code> 中是否包含了 skywalking 的内容，如果包含则说明需要进行替换。</p><h2 id="Upgrade-核心函数"><a href="#Upgrade-核心函数" class="headerlink" title="Upgrade 核心函数"></a>Upgrade 核心函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upgrade</span><span class="params">(container Container)</span></span>&#123;</span><br><span class="line">klog.Infof(<span class="string">&quot;Begin to upgrade deployment:%s container:%s&quot;</span>, deploymentName, container.Name)</span><br><span class="line">newImageName := fmt.Sprintf(<span class="string">&quot;%s-otel-%s&quot;</span>, container.Image, generateRandomString(<span class="number">4</span>))</span><br><span class="line">err := BuildNewOtelImage(container.Image, newImageName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update deployment jvm ENV</span></span><br><span class="line"><span class="keyword">for</span> e, envVar := <span class="keyword">range</span> container.Env &#123;</span><br><span class="line"><span class="keyword">if</span> envVar.Name == <span class="string">&quot;CATALINA_OPTS&quot;</span> &#123;</span><br><span class="line">otelJVM := replaceSWAgent2OTel(envVar.Value, appName)</span><br><span class="line">deployment.Spec.Template.Spec.Containers[i].Env[e].Value = otelJVM</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Update deployment image</span></span><br><span class="line">deployment.Spec.Template.Spec.Containers[i].Image = newImageName</span><br><span class="line"></span><br><span class="line">newDeployment, err := clientSet.AppsV1().Deployments(deployment.Namespace).Update(ctx, &amp;deployment, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">klog.Infof(<span class="string">&quot;Finish upgrade deployment:%s container:%s&quot;</span>, deploymentName, container.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一共分为以下几部：</p><ul><li>基于老镜像构建新镜像</li><li>更新原有的 <code>CATALINA_OPTS</code> 环境变量，也就是替换 skywalking 的参数</li><li>更新 deployment 镜像，触发滚动更新</li></ul><h2 id="构建新镜像"><a href="#构建新镜像" class="headerlink" title="构建新镜像"></a>构建新镜像</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">dockerfile = fmt.Sprintf(<span class="string">`FROM %s</span></span><br><span class="line"><span class="string">COPY %s /home/admin/%s</span></span><br><span class="line"><span class="string">COPY otel.tar.gz /home/admin/otel.tar.gz</span></span><br><span class="line"><span class="string">RUN tar -zxvf /home/admin/otel.tar.gz -C /home/admin</span></span><br><span class="line"><span class="string">RUN rm -rf /home/admin/skywalking-agent</span></span><br><span class="line"><span class="string">ENTRYPOINT [&quot;/bin/sh&quot;, &quot;/home/admin/start.sh&quot;]</span></span><br><span class="line"><span class="string">`</span>, fromImage, script, script)</span><br><span class="line"></span><br><span class="line">idx := strings.LastIndex(newImageName, <span class="string">&quot;/&quot;</span>) + <span class="number">1</span></span><br><span class="line">dockerFileName := newImageName[idx:]</span><br><span class="line">create, err := os.Create(fmt.Sprintf(<span class="string">&quot;Dockerfile-%s&quot;</span>, dockerFileName))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">create.Close()</span><br><span class="line">os.Remove(create.Name())</span><br><span class="line">&#125;()</span><br><span class="line">_, err = create.WriteString(dockerfile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmd := exec.Command(<span class="string">&quot;docker&quot;</span>, <span class="string">&quot;build&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;-f&quot;</span>, create.Name(), <span class="string">&quot;-t&quot;</span>, newImageName)</span><br><span class="line">cmd.Stdin = strings.NewReader(dockerfile)</span><br><span class="line"><span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里的重点就是构建这个新镜像，从这个 dockerfile 中也能看出具体的逻辑，也就是上文提到的删除原有的 skywalking 资源同时将新的 OpenTelemetry 资源打包进去。</p><p>最后再将这个镜像上传到私服。</p><p><img src="https://s2.loli.net/2024/03/03/s7fryhQSPJgcuvj.png"><br>其中的替换 JVM 参数也比较简单，直接删除 skywalking 的内容，然后再追加上 OpenTelemetry 需要的参数即可。</p><h2 id="定时检测替换是否成功"><a href="#定时检测替换是否成功" class="headerlink" title="定时检测替换是否成功"></a>定时检测替换是否成功</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkNewDeploymentStatus</span><span class="params">(ctx context.Context, clientSet kubernetes.Interface, newDeployment *v1.Deployment)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">ready := <span class="literal">true</span></span><br><span class="line">tick := time.Tick(<span class="number">10</span> * time.Second)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">30</span>; i++ &#123;</span><br><span class="line">&lt;-tick</span><br><span class="line">originPodList, err := clientSet.CoreV1().Pods(newDeployment.Namespace).List(ctx, metav1.ListOptions&#123;</span><br><span class="line">LabelSelector: metav1.FormatLabelSelector(&amp;metav1.LabelSelector&#123;</span><br><span class="line">MatchLabels: newDeployment.Spec.Selector.MatchLabels,</span><br><span class="line">&#125;),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if there are any Pods</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(originPodList.Items) == <span class="number">0</span> &#123;</span><br><span class="line">klog.Infof(<span class="string">&quot;No Pod in deployment:%s, Skip&quot;</span>, newDeployment.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> originPodList.Items &#123;</span><br><span class="line"><span class="comment">// Check Pod running</span></span><br><span class="line"><span class="keyword">for</span> _, status := <span class="keyword">range</span> item.Status.ContainerStatuses &#123;</span><br><span class="line"><span class="keyword">if</span> status.RestartCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">ready = <span class="literal">false</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">klog.Infof(<span class="string">&quot;Check deployment:%s namespace:%s status:%t&quot;</span>, newDeployment.Name, newDeployment.Namespace, ready)</span><br><span class="line"><span class="keyword">if</span> ready == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ready == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="comment">// rollback</span></span><br><span class="line">klog.Infof(<span class="string">&quot;=======Rollback deployment:%s namespace:%s&quot;</span>, newDeployment.Name, newDeployment.Namespace)</span><br><span class="line">writeDeploymentName2File(newDeployment.Name, fmt.Sprintf(<span class="string">&quot;rollback-%s.log&quot;</span>, newDeployment.Namespace))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会启动一个 10s 执行一次的定时任务，每次都会检测是否有容器发生了重启（正常情况下是不会出现重启的）</p><p>如果检测了 30 次都没有重启的容器，那就说明本次替换成功了，不然就记录一个日志文件，然后人工处理。</p><blockquote><p>这种通常是原有的镜像与 OpenTelemetry 不兼容，比如里面写死了一些 skywalking 的 API，导致启动失败。</p></blockquote><p>所以替换任务跑完之后我还会检测这个 <code>rollback-$namespace</code> 的日志文件，人工处理这些失败的应用。</p><h2 id="分批处理-deployment"><a href="#分批处理-deployment" class="headerlink" title="分批处理 deployment"></a>分批处理 deployment</h2><p>最后讲讲如何单个调用刚才的 <code>ProcessDeployment()</code> 函数。</p><p>考虑到不能对 kubernetes 产生影响，所以我们需要限制并发处理 deployment 的数量（我这里的限制是 10 个）。</p><p>所以就得分批进行替换，每次替换 10 个，而且其中有一个执行失败就得暂停后续任务，由人工检测失败原因再决定是否继续处理。</p><blockquote><p>毕竟处理的是线上应用，需要小心谨慎。</p></blockquote><p>所以触发的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessDeploymentList</span><span class="params">(ctx context.Context, data []v1.Deployment, clientSet kubernetes.Interface)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">file, err := os.ReadFile(fmt.Sprintf(<span class="string">&quot;finish-%s.log&quot;</span>, data[<span class="number">0</span>].Namespace))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">split := strings.Split(<span class="type">string</span>(file), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">batchSize := <span class="number">10</span></span><br><span class="line">start := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> start &lt; <span class="built_in">len</span>(data) &#123;</span><br><span class="line"></span><br><span class="line">end := start + batchSize</span><br><span class="line"><span class="keyword">if</span> end &gt; <span class="built_in">len</span>(data) &#123;</span><br><span class="line">end = <span class="built_in">len</span>(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">batch := data[start:end]</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待goroutine结束</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">klog.Infof(<span class="string">&quot;Start process batch size %d&quot;</span>, <span class="built_in">len</span>(batch))</span><br><span class="line"></span><br><span class="line">errs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="built_in">len</span>(batch))</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="built_in">len</span>(batch))</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> batch &#123;</span><br><span class="line">d := item</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">if</span> err := ProcessDeployment(ctx, split, d, clientSet); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">&quot;!!!Process deployment name:%s error: %v&quot;</span>, d.Name, err)</span><br><span class="line">errs &lt;- err</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(errs)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">//任何一个失败就返回</span></span><br><span class="line"><span class="keyword">for</span> err := <span class="keyword">range</span> errs &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start = end</span><br><span class="line">klog.Infof(<span class="string">&quot;Deal next batch&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>WaitGroup</code> 来控制一组任务，使用一个 chan 来传递异常；这类分批处理的代码在一些批处理框架中还蛮常见的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后只需要查询某个 namespace 下的所有 deployment 列表传入这个批处理函数即可。</p><p>不过整个过程中还是有几个点需要注意：</p><ul><li>因为需要替换镜像的前提是要把现有的镜像拉取到本地，所以跑这个任务的客户端需要有充足的磁盘，同时和镜像服务器的网络条件较好。</li><li>不然执行的过程会比较慢，同时磁盘占用满了也会影响任务。</li></ul><p>其实这个功能依然有提升空间，考虑到后续会升级 OpenTelemetry  agent 的版本，甚至也需要增减一些 JVM 参数。</p><p>所以最后有一个统一的工具，可以直接升级 Agent，而不是每次我都需要修改这里的代码。</p><p><img src="https://s2.loli.net/2024/03/03/lLIqQtmD2AdfGyv.png"></p><p>后来在网上看到了得物的相关分享，他们可以远程加载配置来解决这个问题。</p><p>这也是一种解决方案，直到我们看到了 OpenTelemetry 社区提供了 <a href="https://github.com/open-telemetry/opentelemetry-operator/#opentelemetry-auto-instrumentation-injection">Operator</a>，其中也包含了注入 agent 的功能。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">opentelemetry.io/v1alpha1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Instrumentation</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-instrumentation</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">exporter:</span>  </span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">http://otel-collector:4317</span>  </span><br><span class="line">  <span class="attr">propagators:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">tracecontext</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">baggage</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">b3</span>  </span><br><span class="line">  <span class="attr">sampler:</span>  </span><br><span class="line">    <span class="attr">type:</span> <span class="string">parentbased_traceidratio</span>  </span><br><span class="line">    <span class="attr">argument:</span> <span class="string">&quot;0.25&quot;</span>  </span><br><span class="line">  <span class="attr">java:</span>  </span><br><span class="line">    <span class="attr">image:</span> <span class="string">private/autoinstrumentation-java:1.32.0-1</span></span><br></pre></td></tr></table></figure><p>我们可以使用他提供的 CRD 来配置我们 agent，只要维护好自己的镜像就好了。</p><p>使用起来也很简单，只要安装好了 OpenTelemetry-operator ，然后再需要注入 Java Agent 的 Pod 中使用注解：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">instrumentation.opentelemetry.io/inject-java:</span> <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure><p> operator 就会自动从刚才我们配置的镜像中读取 agent，然后复制到我们的业务容器。</p><p>再配置上环境变量 <code>$JAVA_TOOL_OPTIONS=/otel/javaagent.java</code>, 这是一个 Java 内置的环境变量，应用启动的时候会自动识别，这样就可以自动注入 agent 了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">envJavaToolsOptions   = <span class="string">&quot;JAVA_TOOL_OPTIONS&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set env value</span></span><br><span class="line">idx := getIndexOfEnv(container.Env, envJavaToolsOptions)  </span><br><span class="line"><span class="keyword">if</span> idx == <span class="number">-1</span> &#123;  </span><br><span class="line">    container.Env = <span class="built_in">append</span>(container.Env, corev1.EnvVar&#123;  </span><br><span class="line">       Name:  envJavaToolsOptions,  </span><br><span class="line">       Value: javaJVMArgument,  </span><br><span class="line">    &#125;)&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    container.Env[idx].Value = container.Env[idx].Value + javaJVMArgument  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy javaagent.jar</span></span><br><span class="line">pod.Spec.InitContainers = <span class="built_in">append</span>(pod.Spec.InitContainers, corev1.Container&#123;  </span><br><span class="line">    Name:      javaInitContainerName,  </span><br><span class="line">    Image:     javaSpec.Image,  </span><br><span class="line">    Command:   []<span class="type">string</span>&#123;<span class="string">&quot;cp&quot;</span>, <span class="string">&quot;/javaagent.jar&quot;</span>, javaInstrMountPath + <span class="string">&quot;/javaagent.jar&quot;</span>&#125;,  </span><br><span class="line">    Resources: javaSpec.Resources,  </span><br><span class="line">    VolumeMounts: []corev1.VolumeMount&#123;&#123;  </span><br><span class="line">       Name:      javaVolumeName,  </span><br><span class="line">       MountPath: javaInstrMountPath,  </span><br><span class="line">    &#125;&#125;,&#125;)</span><br></pre></td></tr></table></figure><p>大致的运行原理是当有 Pod 的事件发生了变化（重启、重新部署等），operator 就会检测到变化，此时会判断是否开启了刚才的注解：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">instrumentation.opentelemetry.io/inject-java:</span> <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure><p>接着会写入环境变量 <code>JAVA_TOOL_OPTIONS</code>，同时将 jar 包从 InitContainers 中复制到业务容器中。</p><blockquote><p>这里使用到了 kubernetes 的初始化容器，该容器是用于做一些准备工作的，比如依赖安装、配置检测或者是等待其他一些组件启动成功后再启动业务容器。</p></blockquote><p>目前这个 operator 还处于使用阶段，同时部分功能还不满足（比如支持自定义扩展），今后有时间也可以分析下它的运行原理。</p><p>参考链接：</p><ul><li><a href="https://xie.infoq.cn/article/e6def1e245e9d67735bd00dd5">https://xie.infoq.cn/article/e6def1e245e9d67735bd00dd5</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-operator/#opentelemetry-auto-instrumentation-injection">https://github.com/open-telemetry/opentelemetry-operator/#opentelemetry-auto-instrumentation-injection</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/03/04/8YFIh7suTirZacj.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近公司将我们之前使用的链路工具切换为了 &lt;code&gt;OpenTelemetry&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/03/03/9V1aUnpOd8EAG2Y.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="k8s" scheme="http://crossoverjie.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>在 kubernetes 环境下如何优雅扩缩容 Pulsar</title>
    <link href="http://crossoverjie.top/2024/03/27/ob/k8s-pulsar-scale/"/>
    <id>http://crossoverjie.top/2024/03/27/ob/k8s-pulsar-scale/</id>
    <published>2024-03-27T08:13:42.000Z</published>
    <updated>2024-05-13T07:46:08.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在整个大环境的降本增效的熏陶下，我们也不得不做好应对方案。</p><p>根据对线上流量、存储以及系统资源的占用，发现我们的 Pulsar 集群有许多的冗余，所以考虑进行缩容从而减少资源浪费，最终也能省一些费用。</p><p>不过在缩容之前很有必要先聊聊扩容，Pulsar 一开始就是存算分离的架构（更多关于 Pulsar 架构的内容本文不做过多介绍，感兴趣的可以自行搜索），天然就非常适合 kubernetes 环境，也可以利用 <code>kubernetes</code> 的能力进行快速扩容。</p><span id="more"></span><h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p>Pulsar 的扩容相对比较简单，在 kubernetes 环境下只需要修改副本即可。</p><h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p>当我们的 broker 层出现瓶颈时（比如 CPU、内存负载较高、GC 频繁时）可以考虑扩容。</p><blockquote><p>计算层都扩容了，也需要根据流量计算下存储层是否够用。</p></blockquote><p>如果我们使用的是 helm 安装的 Pulsar 集群，那只需要修改对于的副本数即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">broker:</span>  </span><br><span class="line">  <span class="string">configuration</span>  </span><br><span class="line">  <span class="attr">component:</span> <span class="string">broker</span>  </span><br><span class="line">  <span class="attr">replicaCount:</span> <span class="number">3</span><span class="string">-&gt;5</span></span><br></pre></td></tr></table></figure><p>当我们将副本数从 3 增加到 5 之后 kubernetes 会自动拉起新增的两个 Pod，之后我们啥也不需要做了。</p><p>Pulsar 的负载均衡器会自动感知到新增两个 broker 的加入，从而帮我们将一些负载高的节点的流量迁移到新增的节点中。</p><h2 id="Bookkeeper"><a href="#Bookkeeper" class="headerlink" title="Bookkeeper"></a>Bookkeeper</h2><p>在介绍 bookkeeper 扩容前先简单介绍些 Bookkeeper 的一些基本概念。</p><ul><li>Ensemble size (E)：当前 Bookkeeper 集群的节点数量</li><li>Write quorum size (QW)：一条消息需要写入到几个 Bookkeeper 节点中</li><li>ACK quorum size (QA)：有多少个 Bookkeeper 节点 ACK 之后表示写入成功</li></ul><p>对应到我们在 <code>broker.conf</code> 中的配置如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">managedLedgerDefaultEnsembleSize</span>: <span class="string">&quot;2&quot;  </span></span><br><span class="line"><span class="attr">managedLedgerDefaultWriteQuorum</span>: <span class="string">&quot;2&quot;  </span></span><br><span class="line"><span class="attr">managedLedgerDefaultAckQuorum</span>: <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure><p>这个三个参数表示一条消息需要同时写入两个 Bookkeeper 节点，同时都返回 ACK 之后才能表示当前消息写入成功。</p><p>从这个配置也可以看出，Bookkeeper 是多副本写入模型，适当的降低 QW 和 QA 的数量可以提高写入吞吐率。</p><p>大部分场景下 Bookkeeper 有三个节点然后 E&#x2F;QW&#x2F;QA 都配置为 2 就可以满足消息多副本写入了。</p><blockquote><p>多副本可以保证当某个节点宕机后，这个节点的消息在其他节点依然有存放，消息读取不会出现问题。</p></blockquote><p>那什么情况下需要扩容 Bookkeeper 了，当然如果单个 Bookkeeper 的负载较高也是可以扩容的。</p><p>但我们当时扩容 Bookkeeper 的场景是想利用 Pulsar 的资源隔离功能。</p><p>因为有部分业务的消息量明显比高于其他的 topic，这样会导致某个 Broker 的负载较高，同时也可能影响到其他正常的 topic。</p><p>最好的方式就将这部分数据用单独的 broker 和 Bookkeeper 来承载，从而实现硬件资源的隔离。</p><p>这样的需求如果使用其他消息队列往往不太好实现，到后来可能就会部署多个集群来实现隔离，但这样也会增加运维的复杂度。</p><p>好在 Pulsar 天然就支持资源隔离，只需要一个集群就可以实现不同 namespace 的流量隔离。</p><p>此时就可以额外扩容几个 Bookkeeper 节点用于特定的 namespace 使用。<br><img src="https://s2.loli.net/2024/02/27/qA89EUDHpxNmK7O.png"></p><p>从上图可以看到：我们可以将 broker 和 Bookkeeper 分别进行分组，然后再配置对应的 namespace，这样就能实现资源隔离了。</p><blockquote><p>更多关于资源隔离的细节本文就不过多赘述了。</p></blockquote><p>铺垫了这么多，其实 Bookkeeper 的扩容也蛮简单的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bookkeeper:</span></span><br><span class="line">  <span class="attr">component:</span> <span class="string">bookie</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="comment"># requests:</span></span><br><span class="line">    <span class="comment"># memory: 4Gi</span></span><br><span class="line">    <span class="comment"># cpu: 2</span></span><br><span class="line">  <span class="attr">replicaCount:</span> <span class="number">3</span><span class="string">-&gt;5</span></span><br></pre></td></tr></table></figure><p>和 broker 扩容类似，提高副本数量后，Pulsar 的元数据中心会感知到新的 Bookkeeper 节点加入，从而更新 broker 中的节点数据，这样就会根据我们配置的隔离策略分配流量。</p><h1 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h1><p>其实本文的重点在于缩容，特别是 Bookkeeper 的缩容，这部分内容我在互联网上很少看到有人提及。</p><h2 id="Broker-1"><a href="#Broker-1" class="headerlink" title="Broker"></a>Broker</h2><p>Broker 的缩容相对简单，因为存算分离的特点：broker 作为计算层是无状态的，并不承载任何的数据。</p><blockquote><p>其实是承载数据的，只是 Pulsar 会自动迁移数据，从而体感上觉得是无状态的。</p></blockquote><p>只是当一个 broker 下线后，它上面所绑定的 topic 会自动转移到其他在线的 broker 中。</p><p>这个过程会导致连接了这个 broker 的 client 触发重连，从而短暂的影响业务。</p><blockquote><p>正因为 broker 的下线会导致 topic 的归属发生转移，所以在下线前最好是先通过监控面板观察需要下线的 broker topic 是否过多，如果过多则可以先手动 unload 一些数据，尽量避免一次性大批量的数据转移。</p></blockquote><p><img src="https://s2.loli.net/2024/02/27/1SzKpNiACdZIbrq.png" alt="image.png"></p><blockquote><p>观察各个broker 的 topic 数量</p></blockquote><h2 id="Bookkeeper-1"><a href="#Bookkeeper-1" class="headerlink" title="Bookkeeper"></a>Bookkeeper</h2><p>而 Bookkeeper 的缩容则没那么容易了，由于它是作为存储层，本身是有状态的，下线后节点上存储的数据是需要迁移到其他的 Bookkeeper 节点中的。</p><p>不然就无法满足之前提到的 Write quorum size (QW) 要求；因此缩容还有一个潜在条件需要满足：</p><p>缩容后的 Bookkeeper 节点数量需要大于broker 中的配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">managedLedgerDefaultEnsembleSize</span>: <span class="string">&quot;2&quot;  </span></span><br><span class="line"><span class="attr">managedLedgerDefaultWriteQuorum</span>: <span class="string">&quot;2&quot;  </span></span><br><span class="line"><span class="attr">managedLedgerDefaultAckQuorum</span>: <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure><p>不然写入会失败，整个集群将变得不可用。</p><p>Pulsar 提供了两种 Bookkeeper 的下线方案：</p><h3 id="不需要迁移数据"><a href="#不需要迁移数据" class="headerlink" title="不需要迁移数据"></a>不需要迁移数据</h3><p>其实两种方案主要区别在于是否需要迁移数据，第一种比较简单，就是不迁移数据的方案。</p><p>首先需要将 Bookkeeper 设置为 read-only 状态，此时该节点将不会接受写请求，直到这个 Bookkeeper 上的数据全部过期被回收后，我们就可以手动下线该节点。</p><p>使用 <code>forceReadOnlyBookie=true</code> 可以强制将 Bookkeeper 设置为只读。</p><p>但这个方案存在几个问题：</p><ul><li>下线时间不确定，如果该 <code>Bookkeeper</code> 上存储的数据生命周期较长，则无法预估什么时候可以下线该节点。</li><li>该配置修改后需要重启才能生效，在 kubernetes 环境中这些配置都是写在了 configmap 中，一旦刷新后所有节点都会读取到该配置，无法针对某一个节点生效；所以可能会出现将不该下线的节点设置为了只读状态。</li></ul><p>但该方案的好处是不需要迁移数据，人工介入的流程少，同样也就减少了出错的可能。</p><p>比较适合于用虚拟机部署的集群。</p><h3 id="迁移数据"><a href="#迁移数据" class="headerlink" title="迁移数据"></a>迁移数据</h3><p>第二种就是需要迁移数据的方案，更适用于 kubernetes 环境。</p><h4 id="迁移原理"><a href="#迁移原理" class="headerlink" title="迁移原理"></a>迁移原理</h4><p>先来看看迁移的原理：</p><ol><li>当 bookkeeper 停机后，AutoRecovery Auditor 会检测到 zookeeper 节点<code>/ledger/available</code> 发生变化，将下线节点的 ledger 信息写入到 zookeeper 的 <code>/ledgers/underreplicated</code> 节点中。</li><li>AutoRecovery ReplicationWorker 会检测 <code>/ledgers/underreplicated</code>节点信息，然后轮训这些 ledger 信息从其他在线的 BK 中复制数据到没有该数据的节点，保证 QW 数量不变。<ol><li>每复制一条数据后都会删除 <code>/ledgers/underreplicated</code> 节点信息。</li><li>所有 <code>/ledgers/underreplicated</code> 被删除后说明迁移任务完成。</li></ol></li><li>执行 <code>bin/bookkeeper shell decommissionbookie</code> 下线命令：<ol><li>会等待 <code>/ledgers/underreplicated</code> 全部删除</li><li> 然后删除 zookeeper 中的元数据</li><li>元数据删除后 bookkeeper 才是真正下线成功，此时 broker 才会感知到 Bookkeeper 下线。</li></ol></li></ol><p><code>AutoRecovery</code> 是 Bookkeeper 提供的一个自动恢复程序，他会在后台检测是否有数据需要迁移。</p><blockquote><p>简单来说就是当某个Bookkeeper 停机后，它上面所存储的 ledgerID 会被写入到元数据中心，此时会有一个单独的线程来扫描这些需要迁移的数据，最终将这些数据写入到其他在线的 Bookkeeper 节点。</p></blockquote><p>Bookkeeper 中的一些关键代码：<br><img src="https://s2.loli.net/2024/02/27/QqtYUBvadWpDmnR.png" alt="image.png"><br><img src="https://s2.loli.net/2024/02/27/gi9JLdMmYxunHTE.png" alt="image.png"></p><h4 id="下线步骤"><a href="#下线步骤" class="headerlink" title="下线步骤"></a>下线步骤</h4><p>下面来看具体的下线流程：</p><ol><li>副本数-1<ol><li><code>bin/bookkeeper shell listunderreplicated</code> 检测有多少 ledger 需要被迁移</li></ol></li><li>执行远程下线元数据<ol><li><code>nohup bin/bookkeeper shell decommissionbookie -bookieid bkid:3181 &gt; bk.log 2&gt;&amp;1 &amp;</code></li><li>这个命令会一直后台运行等待数据迁移完成，比较耗时</li></ol></li><li>查看下线节点是否已被剔除<ol><li><code>bin/bookkeeper shell listbookies -a</code></li></ol></li><li>循环第一步</li></ol><p>第一步是检测一些现在有多少数据需要迁移：<br><code>bin/bookkeeper shell listunderreplicated</code> 命令查看需要被迁移的 ledger 数据也是来自于 <code>/ledgers/underreplicated</code>节点<br><img src="https://s2.loli.net/2024/02/27/FiWJ8b27QD6w5E1.png" alt="image.png"></p><blockquote><p>正常情况下是 0</p></blockquote><p>第二步的命令会等待数据迁移完成后从 zookeeper 中删除节点信息，这个进程退出后表示下线成功。</p><p><img src="https://s2.loli.net/2024/02/27/TuK7FPXCm1fcgJS.png" alt="image.png"></p><blockquote><p>这个命令最好是后台执行，并输出日志到专门的文件，因为周期较长，很有可能终端会话已经超时了。</p></blockquote><p>我们登录 zookeeper 可以看到需要迁移的 ledger 数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/pulsar zookeeper-shell -server pulsar-zookeeper:2181</span><br><span class="line"></span><br><span class="line">get /ledgers/underreplication/ledgers/0000/0000/0000/0002/urL0000000002</span><br><span class="line">replica: &quot;pulsar-test-2-bookie-0.pulsar-test-2-bookie.pulsar-test-2.svc.cluster.local:3181&quot;</span><br><span class="line">ctime: 1708507296519</span><br></pre></td></tr></table></figure><p>underreplication 的节点路径中存放了 ledgerId，通过 ledgerId 计算路径：<br><img src="https://s2.loli.net/2024/02/27/bAx8nqeKQT7F4HV.png"><br><img src="https://s2.loli.net/2024/02/27/GiVlDP2M85pafAO.png"></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>下线过程中我们可以查看 <code>nohup bin/bookkeeper shell decommissionbookie -bookieid bkid:3181 &gt; bk.log 2&gt;&amp;1 &amp;</code>这个命令写入的日志来确认迁移的进度，日志中会打印当前还有多少数量的 ledger 没有迁移。</p><p>同时需要观察 zookeeper、Bookkeeper 的资源占用情况。</p><p>因为迁移过程中写入大量数据到 zookeeper 节点，同时迁移数时也会有大量流量写入 Bookkeeper。</p><p>不要让迁移过程影响到了正常的业务使用。</p><p>根据我的迁移经验来看，通常 2w 的ledger 数据需要 2～3 小时不等的时间，具体情况还得根据你的集群来确认。</p><h4 id="回滚方案"><a href="#回滚方案" class="headerlink" title="回滚方案"></a>回滚方案</h4><p>当然万一迁移比较耗时，或者影响了业务使用，所以还是要有一个回滚方案：</p><p>这里有一个大的前提：<br><strong>只要 BK 节点元数据、PVC（也就是磁盘中的数据） 没有被删除就可以进行回滚。</strong></p><p>所以只要上述的 decommissionbookie 命令没有完全执行完毕，我们就可以手动 kill 该进程，然后恢复副本数据。</p><p>这样恢复的 Bookkeeper 节点依然可以提供服务，同时数据也还存在；只是浪费了一些 autorecovery 的资源。</p><p>最后当 bookkeeper 成功下线后，我们需要删除 PVC，不然如果今后需要扩容的时候是无法启动 bookkeeper 的，因为在启动过程中会判断挂载的磁盘是否有数据。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说 Pulsar 的扩缩容还是非常简单的，只是对于有状态节点的数据迁移稍微复杂一些，但只要跟着流程走就不会有什么问题。</p><p>参考链接：</p><ul><li><a href="https://pulsar.apache.org/docs/next/administration-isolation/">https://pulsar.apache.org/docs/next/administration-isolation/</a></li><li><a href="https://bookkeeper.apache.org/docs/4.13.0/admin/decomission">https://bookkeeper.apache.org/docs/4.13.0/admin/decomission</a></li><li><a href="https://bookkeeper.apache.org/docs/4.13.0/admin/autorecovery">https://bookkeeper.apache.org/docs/4.13.0/admin/autorecovery</a></li></ul><p>#Blog #Pulsar </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在整个大环境的降本增效的熏陶下，我们也不得不做好应对方案。&lt;/p&gt;
&lt;p&gt;根据对线上流量、存储以及系统资源的占用，发现我们的 Pulsar 集群有许多的冗余，所以考虑进行缩容从而减少资源浪费，最终也能省一些费用。&lt;/p&gt;
&lt;p&gt;不过在缩容之前很有必要先聊聊扩容，Pulsar 一开始就是存算分离的架构（更多关于 Pulsar 架构的内容本文不做过多介绍，感兴趣的可以自行搜索），天然就非常适合 kubernetes 环境，也可以利用 &lt;code&gt;kubernetes&lt;/code&gt; 的能力进行快速扩容。&lt;/p&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    <category term="OB" scheme="http://crossoverjie.top/categories/Pulsar/OB/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>顶级开源社区都能吵起来？</title>
    <link href="http://crossoverjie.top/2024/03/20/ob/about-opensource-argument/"/>
    <id>http://crossoverjie.top/2024/03/20/ob/about-opensource-argument/</id>
    <published>2024-03-20T03:15:51.000Z</published>
    <updated>2024-03-21T14:08:20.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>因为订阅了 Pulsar 的开发者邮件，前段时间看到一封标题为<a href="https://lists.apache.org/thread/gzx4j9q0xdtcvrfvvq72t9tm2rt9h3r7">《(Apache committer criteria) [ANNOUNCE] New Committer: Asaf Mesika》</a>的邮件。</p><p>乍一看以为是欢迎 <code>Asaf Mesika</code> 成为 Committer，但仔细一看不太对劲，这内容也太多了，以往的欢迎都是简单的 <code>Congratulations!</code> 作为回复，这篇内容明显有点多了，于是便仔细看了下。</p><span id="more"></span><p><img src="https://s2.loli.net/2024/03/20/aASNcDpnwVIjHFv.png"></p><h1 id="争论"><a href="#争论" class="headerlink" title="争论"></a>争论</h1><p>大概的意思是这封邮件的作者 <code>Kalwit</code> 对成为 Committer 的标准产生了疑问：</p><blockquote><p>他觉得本次提名成为 Committer 的大部分贡献都是一些文档相关的内容，还有少部分是与监控相关的提案。<br>他们团队使用 Pulsar 有一段时间了，但目前还未发现稳定的 Pulsar 版本；大部分的 Review 都是来自同一公司（streamnative）。<br>看起来是整个 Pulsar 项目由某一家公司控制了，他们当初选择从 Kafka 切换到 Pulsar 就是因为 Kafka 由 Confluent 控制，才选择一个更加开放的社区。</p></blockquote><p>这样的一封有着“讨伐”意味的邮件一经发出，自然是一石激起千层浪，社区里很多成员都发表了回复。</p><p>这里我挑选了几个代表性的回复：<br><img src="https://s2.loli.net/2024/03/21/8ZEBJrVpiW6KYXk.png"><br>大概意思就是 Pulsar 是一个开放性项目，任何人都可以参加，每两周也有 Zoom 会议，也是每个人都可以参加。</p><p>在远程的社区异步沟通过程中，很有可能你的请求没有得到及时的响应，这很正常。</p><p>Pulsar 是由社区开发负责维护的，没有公司对此负责，因此没有得到响应时是没有公司可以责怪的；需要大家一起来解决问题，并不一定是需要 PMC（项目管理委员会成员）还是 committer才能提出意见，任何人都可以发表自己的看法。</p><p>但这个过程中大家的身份都是志愿者，需要大家自发的去做这些事情。</p><p>后续 Kalwit 又继续回复了一些邮件，总体内容就是对社区治理存在疑惑；特别是担心社区背后由某一家公司作为主导，从而导致社区和公司的利益进行绑定。</p><p>当然社区的观点依然是，Pulsar 社区不受某一具体公司掌控，并举了具体数据：<br><img src="https://s2.loli.net/2024/03/21/UDiRHjMWdO8xsSI.png"><br>在 41 个 PMC 成员中，只有 9 位是 StreamNative 的员工，41 位 committer 中有 13 位是 StreamNative 的员工。</p><blockquote><p>其实以我目前在社区的观感，确实是 streamnative 公司社区维护者更加活跃，其他的一些 committer 可能由于工作变动啥的很少再贡献项目了。</p></blockquote><h2 id="提案被否"><a href="#提案被否" class="headerlink" title="提案被否"></a>提案被否</h2><p><code>Kalwit</code> 举了一些例子认为这些 PIP 提案没有获得通过，但是 SN 团队提出的提案大部分都能通过。</p><p>我觉得这确实是一种客观现象，但可能更多的原因并不是 SN 公司想要主导 Pulsar 社区的进展，而是他们在社区之外（不管是线上还是线下）进行过额外的沟通，也许在提交草案之前就已经达成了初步一致了，所以在提案审核阶段只需要做一些具体的调整就很容易被通过。</p><p>我自己也提过一些提案，大概提交了三个只有一个通过了；我个人的感受是这个过程中响应时间确实不可控（毕竟是异步沟通），但并不会存在某个团队想要控制哪些提案可以通过，哪些提案不行的这种说法。</p><p>都是在就事论事的讨论事情，而且不通过的话也会由相关的回复和建议，确实大部分情况也是我考虑不周。</p><p>我也看过 asafm 的贡献，其中关于 Pulsar 集成 <a href="https://github.com/apache/pulsar/pull/21080">OpenTelemetry</a> 的提案确实是下了功夫的（一万多字的内容），从头讲解了 OpenTelemetry 的概念，以及 Pulsar 需要做哪些事情来集成。</p><h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><h2 id="厂商绑定"><a href="#厂商绑定" class="headerlink" title="厂商绑定"></a>厂商绑定</h2><p>看完之后我个人的感受是 <code>Kalwit</code> 或者他的团队在参与社区的时候应该是进展不顺利，一些提案或者改动没有得到支持，但看到 SN 公司提交的内容更快得到响应，所以得出了以上的结论：Pulsar 社区由 SN 公司进行了主导。</p><p>他的顾虑也不是没有道理，就像他说的 Kafka 社区由 confluence 公司主导，类似的还有 Dubbo 社区由阿里主导、Golang 由 google 主导。</p><p>但项目如果加入了 Apache 那他原本的公司其实已经失去了对项目的所有权，只是刚开始的一些 PMC&#x2F;committer 大部分会是这个公司的员工，毕竟他们是项目的发起者，也更加熟悉整个系统。</p><p>如果社区发展的健康，后续应该会补充一些其他开发者，这些开发者不受雇于之前发起的项目的公司，甚至是以个人身份加入；只有这样社区就会更加多样化，出现“一言堂”的几率就会大大降低。</p><p>我觉得造成这种现象的原因和一开始该项目是由某一个特定公司发起有有很大的原因，比如 Dubbo、Golang，所以他们公司在社区的声浪更大，自己公司的需求优先级也会更高，毕竟会有来自同一公司的更多的人来审核这些需求。</p><p>虽说如前面邮件里回复的：<code>社区是由志愿者自愿维护的</code>，但不可否认的是在这些做开源项目商业化的公司内有一批人就在专门维护社区工作。</p><p>他们会把自己商业化过程中遇到的一些问题，或者是新的 feature 也提交给社区，但这里的区别是他们是拿工资的，积极性肯定要比在社区用爱发电的开发者更积极。</p><p>这样就会导致社区中最活跃的那批人大概率是靠社区养活自己的人，但这也不是什么坏事；如果你个人或者公司强依赖于某一个开源项目，那也可以想办法多做贡献，成为 committer，这样在一些需要投票的环节也能有一席之位。</p><h2 id="厂商无关"><a href="#厂商无关" class="headerlink" title="厂商无关"></a>厂商无关</h2><p>当然也有对应的不是由某一个厂商发起的项目，比如我最近参与较多的 <code>OpenTelemetry</code> 社区。</p><p><img src="https://s2.loli.net/2024/03/21/DZ2KAX5Wklpm7tr.png"><br>按照官方说法有着 1000 多位独立的开发者，代表了超过 180 家公司，在维护者的列表中也可以看到大多数都是来自于不同的公司：<br><img src="https://s2.loli.net/2024/03/21/jHgCdyoanmzGR8D.png"></p><p>所以自然也就没有某一厂商主导的说法，所以想要避免这类事情再次发生，最好的方法还是吸纳更多的开发者加入，只有社区成员丰富起来社区才好良性发展。</p><p>参考链接：</p><ul><li><a href="https://lists.apache.org/thread/gzx4j9q0xdtcvrfvvq72t9tm2rt9h3r7">https://lists.apache.org/thread/gzx4j9q0xdtcvrfvvq72t9tm2rt9h3r7</a></li><li><a href="https://github.com/apache/pulsar/pull/21080">https://github.com/apache/pulsar/pull/21080</a></li><li><a href="https://opentelemetry.io/blog/2024/opentelemetry-announced-support-for-profiling/">https://opentelemetry.io/blog/2024/opentelemetry-announced-support-for-profiling/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;因为订阅了 Pulsar 的开发者邮件，前段时间看到一封标题为&lt;a href=&quot;https://lists.apache.org/thread/gzx4j9q0xdtcvrfvvq72t9tm2rt9h3r7&quot;&gt;《(Apache committer criteria) [ANNOUNCE] New Committer: Asaf Mesika》&lt;/a&gt;的邮件。&lt;/p&gt;
&lt;p&gt;乍一看以为是欢迎 &lt;code&gt;Asaf Mesika&lt;/code&gt; 成为 Committer，但仔细一看不太对劲，这内容也太多了，以往的欢迎都是简单的 &lt;code&gt;Congratulations!&lt;/code&gt; 作为回复，这篇内容明显有点多了，于是便仔细看了下。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="OpenSource" scheme="http://crossoverjie.top/tags/OpenSource/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读周刊第十四期：常用的 Git 配置</title>
    <link href="http://crossoverjie.top/2024/02/29/ob/newsletter/Newsletter14-20240223/"/>
    <id>http://crossoverjie.top/2024/02/29/ob/newsletter/Newsletter14-20240223/</id>
    <published>2024-02-29T09:28:25.000Z</published>
    <updated>2024-02-29T14:09:37.281Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/01/11/YMoyEKwUubfZA9a.png"></p><p><strong>技术阅读周刊，每周更新。</strong></p><span id="more"></span><h2 id="历史更新"><a href="#历史更新" class="headerlink" title="历史更新"></a>历史更新</h2><ul><li><a href="https://crossoverjie.top/2023/12/22/ob/newsletter/Newsletter10-20231222/">20231122：第十一期</a></li><li><a href="https://crossoverjie.top/2023/12/29/ob/newsletter/Newsletter12-20231229/">20231129：第十二期</a></li><li><a href="https://crossoverjie.top/2024/01/05/ob/newsletter/Newsletter12-20240105/">20240105：第十三期：一些提高生产力的终端命令</a></li><li><a href="https://crossoverjie.top/2024/01/12/ob/newsletter/Newsletter12-202401012/">20240112：第十四期：Golang 作者 Rob Pike 在 GopherConAU 上的分享</a></li></ul><h1 id="How-I-write-HTTP-services-in-Go-after-13-years"><a href="#How-I-write-HTTP-services-in-Go-after-13-years" class="headerlink" title="How I write HTTP services in Go after 13 years"></a>How I write HTTP services in Go after 13 years</h1><p><img src="https://s2.loli.net/2024/02/27/SJIHKtpc5m1u7vs.png"></p><ol><li>使用NewServer函数构建服务实例,利用依赖注入方式将所有的依赖参数包含进来。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">logger *Logger</span></span></span><br><span class="line"><span class="params"><span class="function">config *Config</span></span></span><br><span class="line"><span class="params"><span class="function">commentStore *commentStore</span></span></span><br><span class="line"><span class="params"><span class="function">anotherStore *anotherStore</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> http.Handler &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">addRoutes(</span><br><span class="line">mux,</span><br><span class="line">Logger,</span><br><span class="line">Config,</span><br><span class="line">commentStore,</span><br><span class="line">anotherStore,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> handler http.Handler = mux</span><br><span class="line">handler = someMiddleware(handler)</span><br><span class="line">handler = someMiddleware2(handler)</span><br><span class="line">handler = someMiddleware3(handler)</span><br><span class="line"><span class="keyword">return</span> handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在routes.go文件中统一定义所有路由函数。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addRoutes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">mux                 *http.ServeMux,</span></span></span><br><span class="line"><span class="params"><span class="function">logger              *logging.Logger,</span></span></span><br><span class="line"><span class="params"><span class="function">config              Config,</span></span></span><br><span class="line"><span class="params"><span class="function">tenantsStore        *TenantsStore,</span></span></span><br><span class="line"><span class="params"><span class="function">commentsStore       *CommentsStore,</span></span></span><br><span class="line"><span class="params"><span class="function">conversationService *ConversationService,</span></span></span><br><span class="line"><span class="params"><span class="function">chatGPTService      *ChatGPTService,</span></span></span><br><span class="line"><span class="params"><span class="function">authProxy           *authProxy</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">mux.Handle(<span class="string">&quot;/api/v1/&quot;</span>, handleTenantsGet(logger, tenantsStore))</span><br><span class="line">mux.Handle(<span class="string">&quot;/oauth2/&quot;</span>, handleOAuth2Proxy(logger, authProxy))</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/healthz&quot;</span>, handleHealthzPlease(logger))</span><br><span class="line">mux.Handle(<span class="string">&quot;/&quot;</span>, http.NotFoundHandler())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>主函数只调用run函数来运行服务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(ctx context.Context, w io.Writer, args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">ctx, cancel := signal.NotifyContext(ctx, os.Interrupt)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"><span class="keyword">if</span> err := run(ctx, os.Stdout, os.Args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%s\n&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回闭包 handle</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleSomething handles one of those web requests</span></span><br><span class="line"><span class="comment">// that you hear so much about.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleSomething</span><span class="params">(logger *Logger)</span></span> http.Handler &#123;</span><br><span class="line">thing := prepareThing()</span><br><span class="line"><span class="keyword">return</span> http.HandlerFunc(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// use thing to handle request</span></span><br><span class="line">logger.Info(r.Context(), <span class="string">&quot;msg&quot;</span>, <span class="string">&quot;handleSomething&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>定义通用的encode和decode函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encode</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(w http.ResponseWriter, r *http.Request, status <span class="type">int</span>, v T)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">w.WriteHeader(status)</span><br><span class="line"><span class="keyword">if</span> err := json.NewEncoder(w).Encode(v); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;encode json: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decode</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(r *http.Request)</span></span> (T, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> v T</span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;v); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> v, fmt.Errorf(<span class="string">&quot;decode json: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供一个抽象的 Validator 接口用于验证</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Validator is an object that can be validated.</span></span><br><span class="line"><span class="keyword">type</span> Validator <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Valid checks the object and returns any</span></span><br><span class="line"><span class="comment">// problems. If len(problems) == 0 then</span></span><br><span class="line"><span class="comment">// the object is valid.</span></span><br><span class="line">Valid(ctx context.Context) (problems <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeValid</span>[<span class="title">T</span> <span class="title">Validator</span>]<span class="params">(r *http.Request)</span></span> (T, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> v T</span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;v); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> v, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;decode json: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> problems := v.Valid(r.Context()); <span class="built_in">len</span>(problems) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> v, problems, fmt.Errorf(<span class="string">&quot;invalid %T: %d problems&quot;</span>, v, <span class="built_in">len</span>(problems))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>自定义校验需要实现 <code>Validator</code> 接口。</p><ol start="8"><li>使用 Once 延迟调用来提高启动性能。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleTemplate</span><span class="params">(files <span class="type">string</span>...)</span></span> http.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">init    sync.Once</span><br><span class="line">tpl     *template.Template</span><br><span class="line">tplerr  <span class="type">error</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">init.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">tpl, tplerr = template.ParseFiles(files...)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> tplerr != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(w, tplerr.Error(), http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use tpl</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="What-is-OpenTelemetry"><a href="#What-is-OpenTelemetry" class="headerlink" title="What is OpenTelemetry?"></a>What is OpenTelemetry?</h1><p><img src="https://s2.loli.net/2024/02/27/w13m5cQqdinLDIP.png"></p><blockquote><p>这是一篇 OTel 的科普文章</p></blockquote><p>OpenTelemetry 提供一个统一、可扩展的框架，用于收集、分析和观察分布式系统的性能数据。它包括一组API、库、代理和收集器，这些组件可以跨多种编程语言和平台实现对应用程序的监控。</p><p>OpenTelemetry 整合 OpenTracing 和 OpenCensus。</p><p><img src="https://s2.loli.net/2024/02/27/3C1VLqIBGgAwdeR.png"></p><blockquote><p>2019年，两个社区进行了合并。</p></blockquote><p>同时 OTel 具备以下特征：</p><ol><li><p><strong>统一性</strong>：OpenTelemetry 提供了一个统一的API，使得开发者可以在不同的编程语言和框架中以一致的方式实现监控。</p></li><li><p><strong>可扩展性</strong>：可以编写自己的扩展来满足个性化需要</p></li><li><p><strong>跨平台</strong>：OpenTelemetry 支持多种编程语言，如 Java、Python、Go、.NET 等，以及多种云服务和容器平台。</p></li><li><p><strong>社区驱动</strong>：作为一个开源项目，OpenTelemetry 由一个活跃的社区支持，社区成员贡献代码、文档和最佳实践。</p></li><li><p><strong>与现有工具的兼容性</strong>：OpenTelemetry 设计时考虑了与现有监控工具的兼容性，如 Prometheus、Jaeger、Zipkin 等，这使得它可以轻松地集成到现有的监控基础设施中。</p></li></ol><p>提供了一种名为：OTLP（OpenTelemetry Protocol）的通讯协议，基于 gRPC。</p><p>使用该协议用于客户端与 Collector 采集器进行交互。</p><p>Collector 是 OpenTelemetry 架构中的一个关键组件，它负责接收、处理和导出数据(Trace&#x2F;log&#x2F;metrics)。</p><p><img src="https://s2.loli.net/2024/02/27/fFOnesN4zhQIPR2.png"></p><p>它可以接受从客户端发出的数据进行处理，同时可以导出为不同格式的数据。</p><blockquote><p>总的来说 OTel 是可观测系统的新标准，基于它可以兼容以前使用的 Prometheus、 victoriametrics、skywalking 等系统，同时还可以灵活扩展，不用与任何但一生态或技术栈进行绑定。</p></blockquote><h1 id="Popular-git-config-options"><a href="#Popular-git-config-options" class="headerlink" title="Popular git config options"></a>Popular git config options</h1><p><img src="https://s2.loli.net/2024/02/29/d9x7T2yhFfcjluO.png"></p><blockquote><p>本文总结了一些常用的 git 配置</p></blockquote><ol><li><p><code>pull.ff only</code> 或 <code>pull.rebase true</code>：这两个选项都可以避免在执行<code>git pull</code>时意外创建合并提交，特别是当上游分支已经发生了变化的时候。</p></li><li><p><code>merge.conflictstyle diff3</code>：这个选项使得合并冲突更易于阅读，通过在冲突中显示原始代码版本，帮助用户更好地解决冲突。</p></li><li><p><code>rebase.autosquash true</code> 和 <code>rebase.autostash true</code>：这些选项使得修改旧提交变得更容易，并且自动处理stash。</p></li><li><p><code>push.default simple</code> 或 <code>push.default current</code>：这些选项告诉<code>git push</code>自动推送当前分支到同名的远程分支。</p></li><li><p><code>init.defaultBranch main</code>：创建新仓库时，默认创建<code>main</code>分支而不是<code>master</code>分支。</p></li><li><p><code>commit.verbose true</code>：在提交时显示整个提交差异。</p></li><li><p><code>rerere.enabled true</code>：启用<code>rerere</code>功能，自动解决冲突</p></li><li><p><code>help.autocorrect</code>：设置自动矫正的级别，以自动运行建议的命令。</p></li><li><p><code>core.pager delta</code>：设置Git使用的分页器，例如使用<code>delta</code>来查看带有语法高亮的diff。</p></li><li><p><code>diff.algorithm histogram</code>：设置Git的diff算法，以改善函数重排时的diff显示。</p></li></ol><p>文章链接：</p><ul><li><a href="https://grafana.com/blog/2024/02/09/how-i-write-http-services-in-go-after-13-years/">https://grafana.com/blog/2024/02/09/how-i-write-http-services-in-go-after-13-years/</a></li><li><a href="https://codeboten.medium.com/what-is-opentelemetry-6a7e5c6901c5">https://codeboten.medium.com/what-is-opentelemetry-6a7e5c6901c5</a></li><li><a href="https://jvns.ca/blog/2024/02/16/popular-git-config-options/">https://jvns.ca/blog/2024/02/16/popular-git-config-options/</a></li></ul><p>#Newletters </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/01/11/YMoyEKwUubfZA9a.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术阅读周刊，每周更新。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Newsletter" scheme="http://crossoverjie.top/categories/OB/Newsletter/"/>
    
    
  </entry>
  
  <entry>
    <title>【译】Apache Pulsar 3.2.0 发布</title>
    <link href="http://crossoverjie.top/2024/02/27/ob/translate-pulsar-3.2.0/"/>
    <id>http://crossoverjie.top/2024/02/27/ob/translate-pulsar-3.2.0/</id>
    <published>2024-02-27T02:37:24.000Z</published>
    <updated>2024-02-27T06:31:23.848Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://pulsar.apache.org/blog/2024/02/12/announcing-apache-pulsar-3-2/">原文链接</a></p><p>Pulsar3.2.0 于 2024-02-05 发布，提供了一些新特性和修复了一些 bug ，共有 57 位开发者提交了 88 次 commit。</p><p>以下是一些关键特性介绍.</p><span id="more"></span><h1 id="速率限制"><a href="#速率限制" class="headerlink" title="速率限制"></a>速率限制</h1><p>在 3.2 中对速率限制做了重构：<br><a href="https://github.com/apache/pulsar/blob/master/pip/pip-322.md">PIP-322 Pulsar Rate Limiting Refactoring</a>.</p><p>速率限制器是 Pulsar 服务质量（Qos）保证的重要渠道，主要解决了以下问题：</p><ul><li>速率限制器的高 CPU 负载</li><li>大量的锁竞争会影响 <code>Netty IO</code> 线程，从而增加其他 topic 的发送延迟</li><li>更好的代码封装</li></ul><h1 id="Topic-压缩时会删除-Null-key-消息"><a href="#Topic-压缩时会删除-Null-key-消息" class="headerlink" title="Topic 压缩时会删除 Null-key 消息"></a>Topic 压缩时会删除 Null-key 消息</h1><p>Pulsar 支持 <a href="https://pulsar.apache.org/docs/3.2.x/concepts-topic-compaction/">Topic 压缩</a>，在 3.2 之前的版本中 topic 压缩时会保留 Null key 的消息。</p><p>从 3.2.0 开始将会修改默认行为，默认不会保留，这可以减少存储。如果想要恢复以前的策略可以在 broker.conf 中新增配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">topicCompactionRetainNullKey</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>具体信息请参考：<a href="https://github.com/apache/pulsar/blob/master/pip/pip-318.md">PIP-318</a>.</p><h1 id="WebSocket-的新特性"><a href="#WebSocket-的新特性" class="headerlink" title="WebSocket 的新特性"></a>WebSocket 的新特性</h1><ul><li>支持多个 topic 消费：<a href="https://github.com/apache/pulsar/blob/master/pip/pip_307.md">PIP-307</a>.</li><li>端对端加密 <a href="https://github.com/apache/pulsar/blob/master/pip/pip-290.md">PIP-290</a>.</li></ul><h1 id="CLI-的用户体验改进"><a href="#CLI-的用户体验改进" class="headerlink" title="CLI 的用户体验改进"></a>CLI 的用户体验改进</h1><ul><li><a href="https://github.com/apache/pulsar/pull/20663">CLI 可以配置内存限制</a></li><li><a href="https://github.com/apache/pulsar/pull/21664">允许通过正则或者是文件批量删除 topic</a></li><li><a href="https://github.com/apache/pulsar/pull/20614">通过 <code>pulsar-admin clusters list</code> 可以打印当前使用的 cluster</a></li></ul><h1 id="构建系统的改进"><a href="#构建系统的改进" class="headerlink" title="构建系统的改进"></a>构建系统的改进</h1><p>3.2.0 中引入了PIP-326: <a href="https://github.com/apache/pulsar/blob/master/pip/pip-326.md">Bill of Materials(BOM)</a> 来简化依赖管理。</p><h1 id="参与其中"><a href="#参与其中" class="headerlink" title="参与其中"></a>参与其中</h1><p>Pulsar 是发展最快的开源项目之一，被 Apache 基金会评选为参与度前五的项目，社区欢迎对开源、消息系统、streaming 感兴趣的参与贡献🎉，可以通过以下资源与社区保持联系：</p><ul><li>阅读贡献手册  <a href="https://pulsar.apache.org/contribute/">Apache Pulsar Contribution Guide</a> 开始你的第一个贡献。</li><li>访问 <a href="https://github.com/apache/pulsar">Pulsar GitHub repository</a>, 关注 <a href="https://twitter.com/apache_pulsar">@apache_pulsar</a> 的 Twitter&#x2F;X , 加入 slack 社区 <a href="https://apache-pulsar.slack.com/">Pulsar community on Slack</a>.</li></ul><p>🔗参考链接：</p><ul><li><a href="https://github.com/apache/pulsar/blob/master/pip/pip-318.md">https://github.com/apache/pulsar/blob/master/pip/pip-318.md</a></li><li><a href="https://pulsar.apache.org/docs/3.2.x/concepts-topic-compaction/">https://pulsar.apache.org/docs/3.2.x/concepts-topic-compaction/</a></li><li><a href="https://github.com/apache/pulsar/blob/master/pip/pip-322.md">https://github.com/apache/pulsar/blob/master/pip/pip-322.md</a></li><li><a href="https://github.com/apache/pulsar/blob/master/pip/pip_307.md">https://github.com/apache/pulsar/blob/master/pip/pip_307.md</a></li><li><a href="https://github.com/apache/pulsar/blob/master/pip/pip-290.md">https://github.com/apache/pulsar/blob/master/pip/pip-290.md</a></li><li><a href="https://github.com/apache/pulsar/pull/20663">https://github.com/apache/pulsar/pull/20663</a></li><li><a href="https://github.com/apache/pulsar/pull/20614">https://github.com/apache/pulsar/pull/20614</a></li><li><a href="https://github.com/apache/pulsar/blob/master/pip/pip-326.md">https://github.com/apache/pulsar/blob/master/pip/pip-326.md</a></li><li><a href="https://pulsar.apache.org/contribute/">https://pulsar.apache.org/contribute/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://pulsar.apache.org/blog/2024/02/12/announcing-apache-pulsar-3-2/&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Pulsar3.2.0 于 2024-02-05 发布，提供了一些新特性和修复了一些 bug ，共有 57 位开发者提交了 88 次 commit。&lt;/p&gt;
&lt;p&gt;以下是一些关键特性介绍.&lt;/p&gt;</summary>
    
    
    
    <category term="翻译" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>我的 2023</title>
    <link href="http://crossoverjie.top/2024/02/17/annual-summary/2023/"/>
    <id>http://crossoverjie.top/2024/02/17/annual-summary/2023/</id>
    <published>2024-02-17T07:59:49.000Z</published>
    <updated>2024-02-21T13:46:59.929Z</updated>
    
    <content type="html"><![CDATA[<p>今天是春节的最后一天，因为工作上临时有点事，很不情愿的打开电脑看着也就 10 天没看代码觉得非常陌生。</p><span id="more"></span><p>之后便准备将迟迟未写的 2023 总结补完，这个传统从16年至今已经坚持将近 7 年时间了，今年当然也不能意外。</p><p><img src="https://s2.loli.net/2024/02/17/AgYLTPxs7u35RqB.png"></p><h1 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h1><p>今年要说最让我印象深刻的事就是健身了，为此我投入了大量的时间。</p><p><img src="https://s2.loli.net/2024/02/17/NB6dLUxZRnQPCAS.jpg"><br><img src="https://s2.loli.net/2024/02/17/gWe2p7LQITDuCh5.jpg"><br>我记得是在 22 年四月份当时是因为确实长胖太明显了，下定决心找个教练进行训练，效果确实也有。</p><p>去年也分享过，最后从 75kg 减到 66kg；但大部分时间都是被动的进行训练，所以到了 23 年初的时候其实就反弹不少了。</p><p>而今年最大的不同是我由原先的被动健身改为主动了，甚至到后面一天不练还浑身不舒服。</p><p>所以今年我大部分时间都是自己锻炼，因为我是个 I 人，比较喜欢一个人，所以夏天的时候是每天早上 7 点多去健身房然后再去公司。 </p><p>到了冬天早上确实是起不来，就改为了中午去训练。</p><p>就这样不知不觉就坚持了大半年，直到现在。</p><p>训练日志见文末。</p><blockquote><p>甚至现在偶尔找教练训练时，他说我比他练的都勤🤣。</p></blockquote><p>最终达到的效果就是生活作息更加规律，同时身体素质也是肉眼可见的提升。</p><ul><li>自重引体从一个不能做-&gt;反握-&gt;对握-&gt;正握-&gt;正握做组</li><li>俯卧撑从 5 个-&gt;10个&#x2F;组-&gt;15个&#x2F;组-&gt;25个&#x2F;组-&gt;一次最多做 40 个-&gt;钻石俯卧撑 15&#x2F;组</li></ul><p>其余的就是胸肌有些轮廓、肩部也比以往更圆润一些，腹肌在某些特定角度也可以若隐若现（当然这个得体脂足够低才行），今年的主要目标是上半年认真刷刷脂。</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>工作今年大体上没有什么变化，但经济不景气应该每个人都能感受到；目前我能苟着的同时还能学一些自己感兴趣的东西就非常满足了。</p><p><img src="https://s2.loli.net/2024/02/18/yoqsN3S1LWalw8P.png"></p><blockquote><p>到现在依然很怀恋在上家公司的日子。</p></blockquote><p>今年在公司主要还是维护 Pulsar，同时也给社区贡献了一些代码，算是这么些年来最认真参与开源的一年。</p><p>感兴趣的可以看看之前写的文章：</p><ul><li><a href="https://crossoverjie.top/2023/12/21/ob/Pulsar%20Proposal/">如何给开源项目发起提案</a></li><li><a href="https://crossoverjie.top/2023/08/05/ob/novice-contribute-open-source/">新手如何快速参与开源项目</a></li></ul><p>相比我以前的工作来说，现在的岗位是基础架构，所以接触的几乎都是一些开源产品，这也是我个人感兴趣的方向。</p><p>所以虽然同事之间的交流没有之前的公司那么频繁（我们部门和业务团队在不同的城市），但因为由兴趣驱动，所以也没那么枯燥。</p><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>对了，年中的时候还头脑发热去报了一个英语线下培训班，上了两月后发现除非是连续每天上 8 小时突击几个月，不然别想一下子速成。</p><p>平时没有使用英语的环境，那就只能自己创造了，我现在会坚持每天看一个油管的科技视频，目前看生肉有字幕的情况下勉强可以理解。</p><p>同时又因为今年长期都在水开源社区，导致我现在看英文文档、邮件之类的不借助翻译也没那么吃力，算是开了一个好头。</p><p>今年争取再多听听英文播客，虽然暂时无法通过英语找到远程工作，但利用英文确实可以打开新世界。</p><h2 id="播客"><a href="#播客" class="headerlink" title="播客"></a>播客</h2><p><img src="https://s2.loli.net/2024/02/20/wMLS5luy8HDKerf.jpg"><br>今年算是播客的重度用户，其实听播客的习惯前几年就有了，但那时候大部分是再开车的时候听，今年因为每天有1~2小时的健身时间，所以健身的时候几乎都是听播客过来的。</p><p>个人觉得播客是非常好的内容输入源，比很多视频内容的质量还高；这里推荐几个我常听的频道：</p><ul><li>枫言枫语</li><li>硬地骇客</li><li>爱否科技</li><li>开源面对面</li><li>捕蛇者说</li><li>皮蛋漫游记等</li></ul><h2 id="副业"><a href="#副业" class="headerlink" title="副业"></a>副业</h2><p>在年底的时候无意间利用 Pulsar 完成了我人生的第一笔咨询服务，当时还发了个朋友圈。<br><img src="https://s2.loli.net/2024/02/18/d6PnUej5DSrJZ8R.png" alt="image.png"><br>没想到之后又有个朋友来咨询了一些关于职场的问题，完事后客户满意度还挺高。</p><p>于是我今年也准备好好筹备下，说不定真能做成一个副业。</p><blockquote><p>打个广告，感兴趣的也可以私聊。</p></blockquote><hr><p>年底还好运获得了掘金的<a href="https://juejin.cn/post/7328012551756464139">签约</a>资格：<br><img src="https://s2.loli.net/2024/02/18/25xMEJANaRIbHgP.png"><br>我算是掘金最早一批用户了，记得是 16 年就开始在上面发布文章，这也是长期坚持获得的肯定。</p><p>而且掘金由于被字节收购后资金明显比前几年宽裕，参与过几次征文活动还是收获了一些现金奖励。</p><p>现在和掘金签约后还能获得更多的现金和流量奖励，对作者和平台来说都是双赢，只是今后的文章需要先在掘金发布三个月后才可以同步到其他平台。</p><p>所以掘金还没关注的我的朋友赶紧关注一波吧：<br><a href="https://juejin.cn/user/835284565229597">https://juejin.cn/user/835284565229597</a></p><h1 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h1><p>技能上除了刚才在工作中提到的 Pulsar 外还额外学习了：</p><ul><li><code>VictoriaMetrics</code> 入门到安装<ul><li><code>VictoriaLog</code> 一个新的日志存储数据库，之前也写过一篇介绍使用<a href="https://crossoverjie.top/2023/08/23/ob/VictoriaLogs-Intro/">文章</a>。</li><li>还给 <code>VictoriaLog</code> 做过一点贡献。</li></ul></li><li>Grafana 更熟练了</li><li>kubernetes 的一些知识点也数量了，写过几个小工具：<ul><li><a href="https://crossoverjie.top/2023/10/19/ob/k8s-restart-pod/">优雅重启 Pod</a></li><li>批量替换应用镜像</li></ul></li><li>Istio 的应用，包含网关和服务调用等</li><li>在公司内部做过两次分享（关于 Pulsar 和开源的内容）</li><li>年底的时候还写过一个 <code>OTel</code> 的 <code>extension</code>，熟悉了 <code>OTel</code> 的一些概念和实践。</li></ul><p><img src="https://s2.loli.net/2024/02/21/kYTHJLrnVmvlxMB.png"><br>从今年长期使用的 tag 来看，果然还是 <code>Pulsar</code> 和 <code>kubernetes</code> 使用的最多。</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p><img src="https://s2.loli.net/2024/02/20/B2kATswN7ZGQSzd.png"><br>今年的博客数据产量算是比较多的了，确实也是有我工作的关系，平时接触到的大部分都是些技术问题，所以能写的东西也就比较多了。</p><p>同时也再尝试每周发布技术周刊：<br><img src="https://s2.loli.net/2024/02/20/B1zoHZUNd6iKw48.png"></p><p>目前发了十几期，效果不错，大部分都是一些英文文章，自己也能学到一些东西。</p><h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>之前也提到了今年算是我比较深入的参与开源项目，以往大部分都是发布一些个人作品，当然也有给一些个人或者小项目提过 PR，现在看来多少有点”小打小闹“了。</p><p><img src="https://s2.loli.net/2024/02/20/y84mXRtDJYz7HuG.png"><br>因为在公司主要维护 Pulsar，所以不可避免的就需要和社区沟通，不管是反馈 Bug 还是修复问题流程都比以往正规，毕竟这也是一个 Apache 顶级项目。</p><p><img src="https://s2.loli.net/2024/02/20/IZKxknlzdO9Gcys.png"></p><p>主要活跃的是 <a href="https://github.com/apache/pulsar/pulls?q=is:pr+sort:updated-desc+author:crossoverJie+is:merged">Pulsar</a> 主仓库，合并了 14 个 PR。</p><p><img src="https://s2.loli.net/2024/02/20/xbmp8hLZnCkBuMR.png"></p><p>其次是 <a href="https://github.com/apache/pulsar-client-go/pulls?q=is:pr+sort:updated-desc+author:crossoverJie+is:merged">pulsar-client-go</a> 也就是 Pulsar 的 Go 客户端，合并了 6 个 PR。</p><hr><p><img src="https://s2.loli.net/2024/02/20/vpfMGde6gq4hsRm.png"></p><p><img src="https://s2.loli.net/2024/02/20/83zZDhX9arGu6Yo.jpg"></p><p>然后是 <code>VictoriaMetrics</code>，其实主要就是给他们新发布的 <code>VictoriaLogs</code> 修了个 Bug，也是第一次被单独提及的贡献。</p><hr><p>最后就是年底的时候在一个做可观测性大佬的公众号下看到的项目：<a href="https://github.com/cprobe/cprobe/">cprobe</a></p><p><img src="https://s2.loli.net/2024/02/20/luc9yaMvW18wHdF.png"><br>主要是贡献了一个 helm 安装仓库以及几个插件，这是一个对新手很友好的项目，对开源感兴趣的都可以来参与下。</p><p>当然贡献数量不能作为评判参与开源的唯一标准，但确实比较好量化的指标，今年加油继续贡献。</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>又到了给往年打分的环节了：<br><img src="https://s2.loli.net/2024/02/21/Flfrmn4Tp6qYVWI.png"></p><p>去年算是完成了 60%，今年的定一些容易实现的目标：</p><ul><li>卧推 80kg</li><li>体脂保持在 13% 左右（误差不能多于 2）</li><li>去海外玩估计有点难度，那就先定国内吧，哪里都行.</li><li>年底开源社区争取提名一个 Committer</li><li>英语可以达到生肉油管的程度</li><li>做一个副业试试</li></ul><h2 id="往年记录"><a href="#往年记录" class="headerlink" title="往年记录"></a>往年记录</h2><ul><li><a href="https://crossoverjie.top/2023/01/18/annual-summary/2022/">2022</a></li><li><a href="https://crossoverjie.top/2022/01/27/annual-summary/2021/">2021</a></li><li><a href="https://crossoverjie.top/2021/03/02/annual-summary/2020/">2020</a></li><li><a href="https://crossoverjie.top/2019/12/30/annual-summary/2019/">2019</a></li><li><a href="https://crossoverjie.top/2018/12/30/annual-summary/2018/">2018</a></li><li><a href="https://crossoverjie.top/2018/12/30/annual-summary/2018/">2016</a></li></ul><blockquote><p><strong>长图预警</strong></p></blockquote><p><img src="https://s2.loli.net/2024/02/17/8Tl19muAntiXg4a.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天是春节的最后一天，因为工作上临时有点事，很不情愿的打开电脑看着也就 10 天没看代码觉得非常陌生。&lt;/p&gt;</summary>
    
    
    
    <category term="annual-summary" scheme="http://crossoverjie.top/categories/annual-summary/"/>
    
    
  </entry>
  
  <entry>
    <title>【译】Apache Pulsar 2023 年度回顾</title>
    <link href="http://crossoverjie.top/2024/01/26/ob/translate-pulsar-2023-year-in-review/"/>
    <id>http://crossoverjie.top/2024/01/26/ob/translate-pulsar-2023-year-in-review/</id>
    <published>2024-01-26T02:37:24.000Z</published>
    <updated>2024-01-26T06:58:04.544Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://pulsar.apache.org/blog/2024/01/12/pulsar-2023-year-in-review/">原文链接</a><br>前两天 Pulsar 社区发布了 2023 年年度回顾，去年我也花了一些时间参与社区，所以其中一些内容感受挺明显的，以下就是对一些重点内容的提炼。</p><span id="more"></span><p>2023 年是一个重要的里程碑，参与<a href="https://github.com/apache/pulsar">主仓库</a>贡献的开发者达到了 600 位。<br>自从 Pulsar 从 2018 毕业成为 Apache 顶级项目至今一共又 12K+ 的代码提交次数、639 位贡献者、12.2k star、3.5k fork、10k+ 的 slack 用户。</p><h1 id="2023-高光时刻"><a href="#2023-高光时刻" class="headerlink" title="2023 高光时刻"></a>2023 高光时刻</h1><h2 id="第一个-LTS-3-0-里程碑版本"><a href="#第一个-LTS-3-0-里程碑版本" class="headerlink" title="第一个 LTS 3.0 里程碑版本"></a>第一个 LTS 3.0 里程碑版本</h2><p><img src="https://s2.loli.net/2024/01/26/BRvYSLPOnxoQ614.png"><br>社区发布 Apache Pulsar 3.0，这是第一个长期支持 （LTS） 版本，从 Pulsar 3.0 开始，可以满足不同用户对稳定性和新功能的需求，同时减轻维护历史版本的负担。</p><p>以往的版本发布周期很短，一般是 3～4 个月，为了可以跟上社区新版，往往需要不停的升级，对维护中的负担较大。</p><p>今后的维护时间表如上图，以稳定为主的团队可以选择 LTS 版本，追求新功能的团队可以选择 feature 版本。</p><h2 id="新的官方网站"><a href="#新的官方网站" class="headerlink" title="新的官方网站"></a>新的官方网站</h2><p><a href="https://pulsar.apache.org/">https://pulsar.apache.org/</a>官方网站得到了新的设计。</p><h2 id="Pulsar-Admin-Go-Library"><a href="#Pulsar-Admin-Go-Library" class="headerlink" title="Pulsar Admin Go Library"></a>Pulsar Admin Go Library</h2><p>提供了 Pulsar Admin Go 的客户端，方便 Go 用户管理 Pulsar 资源</p><h2 id="使用-OTel-增强-Pulsar-的可观测系统"><a href="#使用-OTel-增强-Pulsar-的可观测系统" class="headerlink" title="使用 OTel 增强 Pulsar 的可观测系统"></a>使用 OTel 增强 Pulsar 的可观测系统</h2><p><a href="https://github.com/apache/pulsar/blob/master/pip/pip-264.md">PIP-264</a> 提案已经获得了社区批准开始开发，它将解决 topic 数量达到 50k~100M 的可观测性问题。<br>同时 Pulsar 社区已经为 OpenTelemetry 提交了两个特性 <a href="https://github.com/open-telemetry/opentelemetry-java/issues/5105">Near-zero memory allocations</a> <a href="https://github.com/open-telemetry/opentelemetry-java/issues/6107">metric filtering upon collection</a> 已经作为了 OpenTelemetry 的规范。</p><h1 id="主要事件回顾"><a href="#主要事件回顾" class="headerlink" title="主要事件回顾"></a>主要事件回顾</h1><p>2023 年，Pulsar 社区在全球范围内举办了一系列活动。</p><ul><li><a href="https://streamnative.io/blog/pulsar-virtual-summit-europe-2023-key-takeaways">Pulsar Summit Europe 2023</a></li><li><a href="https://pulsar.apache.org/blog/2023/08/28/pulsar-sessions-in-communityovercode-aisa-2023/">CommunityOverCode Asia 2023</a></li><li><a href="https://communityovercode.org/past-sessions/community-over-code-na-2023/">CommunityOverCode NA 2023</a></li><li><a href="https://streamnative.io/blog/pulsar-summit-north-america-2023-a-deep-dive-into-the-on-demand-summit-videos">Pulsar Summit NA 2023</a></li></ul><h1 id="社区成长"><a href="#社区成长" class="headerlink" title="社区成长"></a>社区成长</h1><p>没有贡献者社区很难发展，2023年加入了许多新面孔。</p><ul><li>639 位贡献者</li><li>13.4k Github star</li><li>3.5k fork</li><li>新增 8 位 Committers</li><li>新增 6 位 PMC</li><li>10k+ slack 用户</li><li>20M+ docker pulls</li></ul><h1 id="项目发布"><a href="#项目发布" class="headerlink" title="项目发布"></a>项目发布</h1><p>2023年，社区发布了两个 major version 和 12 个 minor version 版本；最大的里程碑依然是发布了首个 LTS 版本 <a href="https://pulsar.apache.org/blog/2023/05/02/announcing-apache-pulsar-3-0/">Pulsar3.0</a>。<br>超过了 140 个贡献者提交了大约 1500 次提交。</p><p>同时也带来了一些重要的特性，比如新版本的<a href="https://github.com/apache/pulsar/issues/16691">负载均衡器</a>，<a href="https://github.com/apache/pulsar/issues/16763">大规模的延时消息支持</a>。</p><p>更新了以下一些客户端：</p><ul><li><a href="https://github.com/apache/pulsar-client-cpp/releases/tag/v3.4.2">Pulsar C++ Client 3.4.2</a></li><li><a href="https://github.com/apache/pulsar-client-go/releases/tag/v0.11.1">Pulsar Go Client 0.11.1</a></li><li><a href="https://github.com/apache/pulsar-client-node/releases/tag/v1.9.0">Pulsar Node.js Client 1.9.0</a></li><li><a href="https://github.com/apache/pulsar-client-python/releases/tag/v3.3.0">Pulsar Python Client 3.3.0</a></li><li><a href="https://github.com/apache/pulsar-manager/releases/tag/v0.4.0">Pulsar Manager 0.4.0</a></li><li><a href="https://github.com/apache/pulsar-helm-chart/releases/tag/pulsar-3.1.0">Pulsar Helm Chart 3.1.0</a></li><li><a href="https://github.com/apache/pulsar-dotpulsar/blob/master/CHANGELOG.md#311---2023-12-11">Pulsar dotnet Client 3.1.1</a></li><li><a href="https://github.com/apache/pulsar-client-reactive/releases/tag/v0.5.1">Reactive Client for Apache Pulsar 0.1.0</a></li></ul><h1 id="生态系统"><a href="#生态系统" class="headerlink" title="生态系统"></a>生态系统</h1><p>2023 年Pulsar 社区也与多个开源项目进行了集成：</p><ul><li><a href="https://quarkus.io/guides/pulsar">Quarkus Extension for Apache Pulsar</a>，通过事件驱动在 Quarkus 使用 Pulsar。</li><li><a href="https://spring.io/blog/2023/11/21/spring-for-apache-pulsar-1-0-0-goes-ga/">Spring for Apache Pulsar</a> 提供了 PulsarTemplate 用于生产消息，PulsarListener 注解可以方便的消费消息，在 spring 生态下更容易集成 Pulsar</li><li><a href="https://github.com/streamnative/oxia">Oxia</a>:可以使用 Oxia 提到 zookeeper 从而突破 Pulsar 支持 1M topic 的限制。</li></ul><h1 id="2024年计划"><a href="#2024年计划" class="headerlink" title="2024年计划"></a>2024年计划</h1><h2 id="OTel"><a href="#OTel" class="headerlink" title="OTel"></a>OTel</h2><p>继续推进使用 OpenTelemetry 替换现有的可观测性系统</p><h2 id="限流重构"><a href="#限流重构" class="headerlink" title="限流重构"></a>限流重构</h2><p><a href="https://github.com/apache/pulsar/blob/master/pip/pip-322.md">PIP-322 Pulsar Rate Limiting Refactoring</a>限流重构已经被合并，将在 3.2 版本中发布。</p><h2 id="移除-Pulsar-SQL-模块"><a href="#移除-Pulsar-SQL-模块" class="headerlink" title="移除 Pulsar SQL 模块"></a>移除 Pulsar SQL 模块</h2><p>将 SQL 模块移除后有效的减少了镜像大小以及构建时间。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>2024 年将会继续举办活动，包括 Pulsar Summit North America 和 Pulsar Summit APAC。<a href="https://youtube.com/playlist?list=PLqRma1oIkcWhOZ6W-g4D_3JNxJzYnwLNX&si=o6G-fRcNgW9zqHGa">在这里可以查看以往的活动</a>。</p><p>🔗参考链接：</p><ul><li><a href="https://youtube.com/playlist?list=PLqRma1oIkcWhOZ6W-g4D_3JNxJzYnwLNX&amp;si=o6G-fRcNgW9zqHGa">https://youtube.com/playlist?list=PLqRma1oIkcWhOZ6W-g4D_3JNxJzYnwLNX&amp;si=o6G-fRcNgW9zqHGa</a></li><li><a href="https://github.com/apache/pulsar/wiki/Community-Meetings">https://github.com/apache/pulsar/wiki/Community-Meetings</a></li><li><a href="https://pulsar.apache.org/blog/2024/01/12/pulsar-2023-year-in-review/">https://pulsar.apache.org/blog/2024/01/12/pulsar-2023-year-in-review/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://pulsar.apache.org/blog/2024/01/12/pulsar-2023-year-in-review/&quot;&gt;原文链接&lt;/a&gt;&lt;br&gt;前两天 Pulsar 社区发布了 2023 年年度回顾，去年我也花了一些时间参与社区，所以其中一些内容感受挺明显的，以下就是对一些重点内容的提炼。&lt;/p&gt;</summary>
    
    
    
    <category term="翻译" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你为开源项目贡献代码</title>
    <link href="http://crossoverjie.top/2024/01/25/ob/create-a-plugin-for-cprobe/"/>
    <id>http://crossoverjie.top/2024/01/25/ob/create-a-plugin-for-cprobe/</id>
    <published>2024-01-25T11:49:09.000Z</published>
    <updated>2024-01-25T15:56:28.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间无意间看到一篇公众号 <a href="https://mp.weixin.qq.com/s/T8B3XnXd30vT7OvsFTnaFw">招贤令：一起来搞一个新开源项目</a>，作者介绍他想要做一个开源项目：<a href="https://github.com/cprobe/cprobe">cprobe</a> 用于整合目前市面上散落在各地的 <code>Exporter</code>，统一进行管理。</p><p>比如我们常用的 <code>blackbox_exporter/mysqld_exporter</code> 等。</p><blockquote><p>以往的每一个 Exporter 都需要单独部署运维。</p></blockquote><span id="more"></span><p>同时又完全兼容 <code>Prometheus</code> 生态，也可以复用现有的监控面板。</p><p>恰好这段时间我也在公司从事可观测性相关的业务，发现这确实是一个痛点。</p><p>于是便一直在关注这个项目，同时也做了些贡献；因为该项目的核心是用于整合 exporter，所以为其编写插件也是非常重要的贡献了。</p><h1 id="编写插件"><a href="#编写插件" class="headerlink" title="编写插件"></a>编写插件</h1><p>整个项目执行流程图如下：<br><img src="https://s2.loli.net/2024/01/25/SihX4C5PN8IeR3Z.png"></p><p>可以看到编写插件最核心的便是自定义插件解析自定义的配置文件、抓取指标的逻辑。</p><p>比如我们需要在配置中指定抓取目标的域名、抓取规则等。</p><p>这里  <code>cprobe</code> 已经抽象出了两个接口，我们只需要做对应的实现即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;  </span><br><span class="line">    <span class="comment">// ParseConfig is used to parse config  </span></span><br><span class="line">    ParseConfig(baseDir <span class="type">string</span>, bs []<span class="type">byte</span>) (any, <span class="type">error</span>)  </span><br><span class="line">    <span class="comment">// Scrape is used to scrape metrics, cfg need to be cast specific cfg  </span></span><br><span class="line">    Scrape(ctx context.Context, target <span class="type">string</span>, cfg any, ss *types.Samples) <span class="type">error</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就以我之前编写的 <a href="https://github.com/cprobe/cprobe/pull/29">Consul</a> 为例。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Allows any Consul server (non-leader) to service a read.  </span></span><br><span class="line"><span class="string">allow_stale</span> <span class="string">=</span> <span class="literal">true</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># === CA  </span></span><br><span class="line"><span class="comment"># File path to a PEM-encoded certificate authority used to validate the authenticity of a server certificate.  </span></span><br><span class="line"><span class="string">ca_file</span> <span class="string">=</span> <span class="string">&quot;/etc/consul.d/consul-agent-ca.pem&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># File path to a PEM-encoded certificate used with the private key to verify the exporter&#x27;s authenticity.  </span></span><br><span class="line"><span class="string">cert_file</span> <span class="string">=</span> <span class="string">&quot;/etc/consul.d/consul-agent.pem&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Generate a health summary for each service instance. Needs n+1 queries to collect all information.  </span></span><br><span class="line"><span class="string">health_summary</span> <span class="string">=</span> <span class="literal">true</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># File path to a PEM-encoded private key used with the certificate to verify the exporter&#x27;s authenticity  </span></span><br><span class="line"><span class="string">key_file</span> <span class="string">=</span> <span class="string">&quot;/etc/consul.d/consul-agent-key.pem&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Disable TLS host verification.  </span></span><br><span class="line"><span class="string">insecure</span> <span class="string">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这里每个插件的配置都不相同，所以我们需要将配置解析到具体的结构体中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Consul)</span></span> ParseConfig(baseDir <span class="type">string</span>, bs []<span class="type">byte</span>) (any, <span class="type">error</span>) &#123;  </span><br><span class="line">    <span class="keyword">var</span> c Config  </span><br><span class="line">    err := toml.Unmarshal(bs, &amp;c)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, err  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> c.Timeout == <span class="number">0</span> &#123;  </span><br><span class="line">       c.Timeout = time.Millisecond * <span class="number">500</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析配置文件没啥好说的，根据自己的逻辑实现即可，可能会配置一些默认值而已。</p><hr><p>下面是核心的抓取逻辑，本质上就是使用对应插件的 <code>Client</code> 获取一些核心指标封装为 <code>Prometheus</code> 的 <code>Metric</code>，然后由 <code>cprobe</code> 写入到远端的 <code>Prometheus</code> 中(或者是兼容 <code>Prometheus</code> 的数据库中)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Create client</span></span><br><span class="line">config.HttpClient.Timeout = opts.Timeout  </span><br><span class="line">config.HttpClient.Transport = transport  </span><br><span class="line">  </span><br><span class="line">client, err := consul_api.NewClient(config)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> requestLimitChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line"><span class="keyword">if</span> opts.RequestLimit &gt; <span class="number">0</span> &#123;  </span><br><span class="line">    requestLimitChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, opts.RequestLimit)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/25/Hbnqz36wSDohuBJ.png"><br>所有的指标数据都是通过对应的客户端获取。</p><p>如果是迁移一个存在的  export 到 cprobe 中时，这些抓取代码我们都可以直接复制对应 <a href="https://github.com/prometheus/consul_exporter">repo</a> 中的代码。</p><p>比如我就是参考的：<a href="https://github.com/prometheus/consul_exporter">https://github.com/prometheus/consul_exporter</a></p><p>除非我们是重新写一个插件，不然对于一些流行的库或者是中间件都已经有对应的 <code>exporter</code> 了。</p><p>具体的列表可以参考这里：<br><a href="https://prometheus.io/docs/instrumenting/exporters/">https://prometheus.io/docs/instrumenting/exporters/</a></p><p><img src="https://s2.loli.net/2024/01/25/6DEKwyWqA3MBm8f.png"></p><p>之后便需要在对应的插件目录(<code>./conf.d</code>)创建我们的配置文件：<br><img src="https://s2.loli.net/2024/01/25/BJuyoqNtmvZ15wr.png"></p><p>为了方便测试，可以在启动 cprobe 时添加 <code>-no-writer</code> 让指标打印在控制台，从而方便调试。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>之前就有人问我有没有毕竟好上手的开源项目，这不就来了吗？</p><p>正好目前项目创建时间不长，代码和功能也比较简单，同时还有可观察系统大佬带队，确实是一个非常适合新手参与的开源项目。</p><p>项目地址：</p><p><a href="https://github.com/cprobe/cprobe">https://github.com/cprobe/cprobe</a></p><h1 id="私货"><a href="#私货" class="headerlink" title="私货"></a>私货</h1><p><img src="https://s2.loli.net/2024/01/25/2K3um8dPlfneyLw.png"></p><p>最后夹带一点私货：前两天帮一个读者朋友做了一次付费的技术咨询（主要是关于 Pulsar 相关的），也是我第一次做付费内容，这种拿人钱财替人消灾难道就是知识付费的味道吗😂？</p><p><img src="https://s2.loli.net/2024/01/25/LJq6xlowRmdnrHv.png"></p><p>所以我就趁热打铁在朋友圈发了个广告，没想到又有个朋友找我做关于职场相关咨询，最后能帮助到对方自己也很开心。</p><p>其实经常也有人通过社媒、邮件等渠道找我帮忙看问题，一些简单的我通常也会抽时间回复。</p><p>但后面这位朋友也提到，如果我不是付费，他也不好意思来找我聊这些内容，毕竟涉及到一些隐私，同时也需要占用双方 1～2 小时的时间。</p><p>这样明码标价的方式确实也能更方便的沟通，同时也能减轻对方的心里负担，直接从白嫖转为付费大佬。</p><p>铺垫了这么多，主要目的是想进行一个小范围的尝试，如果对以下内容感兴趣的朋友欢迎加我微信私聊：</p><blockquote><p>包括但不限于技术、职场、开源等我有经验的行业都可以聊。</p></blockquote><p><img src="https://s2.loli.net/2024/01/25/brqMxl5ZBvRz3mu.jpg"></p><p>反馈不错的话也需要可以作为我的长期副业做下去。<br>#Blog </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间无意间看到一篇公众号 &lt;a href=&quot;https://mp.weixin.qq.com/s/T8B3XnXd30vT7OvsFTnaFw&quot;&gt;招贤令：一起来搞一个新开源项目&lt;/a&gt;，作者介绍他想要做一个开源项目：&lt;a href=&quot;https://github.com/cprobe/cprobe&quot;&gt;cprobe&lt;/a&gt; 用于整合目前市面上散落在各地的 &lt;code&gt;Exporter&lt;/code&gt;，统一进行管理。&lt;/p&gt;
&lt;p&gt;比如我们常用的 &lt;code&gt;blackbox_exporter/mysqld_exporter&lt;/code&gt; 等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以往的每一个 Exporter 都需要单独部署运维。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="OpenSource" scheme="http://crossoverjie.top/tags/OpenSource/"/>
    
    <category term="开源" scheme="http://crossoverjie.top/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>白话 Pulsar Bookkeeper 的存储模型</title>
    <link href="http://crossoverjie.top/2024/01/15/ob/Bookkeeper-storage/"/>
    <id>http://crossoverjie.top/2024/01/15/ob/Bookkeeper-storage/</id>
    <published>2024-01-15T11:20:59.000Z</published>
    <updated>2024-01-15T15:30:41.385Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/01/15/xU7FZCPjckRMBAD.png"></p><p>最近我们的 Pulsar 存储有很长一段时间数据一直得不到回收，但消息确实已经是 ACK 了，理论上应该是会被回收的，随着时间流逝不但没回收还一直再涨，最后在没找到原因的情况下就只有一直不停的扩容。</p><blockquote><p>最后磁盘是得到了回收，过程先不表，之后再讨论。</p></blockquote><p>为了防止类似的问题再次发生，我们希望可以监控到磁盘维度，能够列出各个日志文件的大小以及创建时间。</p><p>这时就需要对 <code>Pulsar</code> 的存储模型有一定的了解，也就有了这篇文章。</p><span id="more"></span><p><img src="https://s2.loli.net/2024/01/15/EjpuQKJN5MVIW8r.png" alt="image.png"><br>讲到 Pulsar 的存储模型，本质上就是 Bookkeeper 的存储模型。</p><p>Pulsar 所有的消息读写都是通过 Bookkeeper 实现的。</p><blockquote><p><code>Bookkeeper</code> 是一个可扩展、可容错、低延迟的日志存储数据库，基于 Append Only 模型。（数据只能追加不能修改）</p></blockquote><p><img src="https://s2.loli.net/2024/01/15/tMITYocL89ZapVG.png" alt="image.png"></p><p>这里我利用 Pulsar 和 Bookkeeper 的 Admin API 列出了 Broker 和 BK 中 Ledger 分别占用的磁盘空间。</p><blockquote><p>关于这个如何获取和计算的，后续也准备提交给社区。</p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>但和我们实际 <code>kubernetes</code> 中的磁盘占用量依然对不上，所以就想看看在 BK 中实际的存储日志和 <code>Ledger</code> 到底差在哪里。</p><blockquote><p>知道 Ledger 就可以通过 Ledger 的元数据中找到对应的 topic，从而判断哪些 topic 的数据导致统计不能匹配。</p></blockquote><p>Bookkeeper 有提提供一个Admin API 可以返回当前 BK 所使用了哪些日志文件的接口:<br><a href="https://bookkeeper.apache.org/docs/admin/http#endpoint-apiv1bookielist_disk_filefile_typetype">https://bookkeeper.apache.org/docs/admin/http#endpoint-apiv1bookielist_disk_filefile_typetype</a></p><p><img src="https://s2.loli.net/2024/01/15/ZOMcNSG53Ttz4eo.png"></p><p>从返回的结果可以看出，落到具体的磁盘上只有一个文件名称，是无法知道具体和哪些 Ledger 进行关联的，也就无法知道具体的 topic 了。</p><p>此时只能大胆假设，应该每个文件和具体的消息 ID 有一个映射关系，也就是索引。<br>所以需要搞清楚这个索引是如何运行的。</p><h1 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h1><p><img src="https://s2.loli.net/2024/01/15/uvPC1Y8kdOJ3m5B.png"></p><p>我查阅了一些网上的文章和源码大概梳理了一个存储流程：</p><ol><li>BK 收到写入请求，数据会异步写入到 <code>Journal</code>&#x2F;<code>Entrylog</code></li><li>Journal 直接顺序写入，并且会快速清除已经写入的数据，所以需要的磁盘空间不多（所以从监控中其实可以看到 Journal 的磁盘占有率是很低的）。</li><li>考虑到会随机读消息，EntryLog 在写入前进行排序，保证落盘的数据中同一个 Ledger 的数据尽量挨在一起，充分利用 PageCache.</li><li>最终数据的索引通过 <code>LedgerId+EntryId</code> 生成索引信息存放到 <code>RockDB</code> 中（<code>Pulsar</code> 的场景使用的是 <code>DbLedgerStorage</code> 实现）。</li><li>读取数据时先从获取索引，然后再从磁盘读取数据。</li><li>利用 <code>Journal</code> 和 <code>EntryLog</code> 实现消息的读写分离。</li></ol><p>简单来说 BK 在存储数据的时候会进行双写，<code>Journal</code> 目录用于存放写的数据，对消息顺序没有要求，写完后就可以清除了。</p><p>而 <code>Entry</code> 目录主要用于后续消费消息进行读取使用，大部分场景都是顺序读，毕竟我们消费消息的时候很少会回溯，所以需要充分利用磁盘的 PageCache，将顺序的消息尽量的存储在一起。</p><blockquote><p>同一个日志文件中可能会存放多个 Ledger 的消息，这些数据如果不排序直接写入就会导致乱序，而消费时大概率是顺序的，但具体到磁盘的表现就是随机读了，这样读取效率较低。</p></blockquote><p>所以我们使用 <code>Helm</code> 部署 <code>Bookkeeper</code> 的时候需要分别指定 <code>journal</code> 和 <code>ledgers</code> 的目录</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span>  </span><br><span class="line">  <span class="comment"># use a persistent volume or emptyDir  </span></span><br><span class="line">  <span class="attr">persistence:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">journal:</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">journal</span>  </span><br><span class="line">    <span class="attr">size:</span> <span class="string">20Gi</span>  </span><br><span class="line">    <span class="attr">local_storage:</span> <span class="literal">false</span>  </span><br><span class="line">    <span class="attr">multiVolumes:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">journal0</span>  </span><br><span class="line">        <span class="attr">size:</span> <span class="string">10Gi</span>  </span><br><span class="line">        <span class="comment"># storageClassName: existent-storage-class  </span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/pulsar/data/bookkeeper/journal0</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">journal1</span>  </span><br><span class="line">        <span class="attr">size:</span> <span class="string">10Gi</span>  </span><br><span class="line">        <span class="comment"># storageClassName: existent-storage-class  </span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/pulsar/data/bookkeeper/journal1</span>  </span><br><span class="line">  <span class="attr">ledgers:</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">ledgers</span>  </span><br><span class="line">    <span class="attr">size:</span> <span class="string">50Gi</span>  </span><br><span class="line">    <span class="attr">local_storage:</span> <span class="literal">false</span>  </span><br><span class="line">    <span class="attr">storageClassName:</span> <span class="string">sc</span></span><br><span class="line">    <span class="comment"># storageClass:  </span></span><br><span class="line">      <span class="comment"># ...    useMultiVolumes: false  </span></span><br><span class="line">    <span class="attr">multiVolumes:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ledgers0</span>  </span><br><span class="line">        <span class="attr">size:</span> <span class="string">1000Gi</span>  </span><br><span class="line">        <span class="comment"># storageClassName: existent-storage-class  </span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/pulsar/data/bookkeeper/ledgers0</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ledgers1</span>  </span><br><span class="line">        <span class="attr">size:</span> <span class="string">1000Gi</span>  </span><br><span class="line">        <span class="comment"># storageClassName: existent-storage-class  </span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/pulsar/data/bookkeeper/ledgers1</span></span><br></pre></td></tr></table></figure><hr><p><img src="https://s2.loli.net/2024/01/15/nJeNDFbu2MIQp5a.png"><br>每次在写入和读取数据的时候都需要通过消息 ID 也就是 ledgerId 和 entryId 来获取索引信息。</p><blockquote><p>也印证了之前索引的猜测。</p></blockquote><p>所以借助于 BK 读写分离的特性，我们还可以单独优化存储。</p><p>比如写入 <code>Journal</code> 的磁盘因为是顺序写入，所以即便是普通的 <code>HDD</code> 硬盘速度也很快。</p><p>大部分场景下都是读大于写，所以我们可以单独为 <code>Ledger</code> 分配高性能 SSD 磁盘，按需使用。</p><blockquote><p>因为在最底层的日志文件中无法直接通过 ledgerId 得知占用磁盘的大小，所以我们实际的磁盘占用率对不上的问题依然没有得到解决，这个问题我还会持续跟进，有新的进展再继续同步。</p></blockquote><p>#Blog #Pulsar </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/01/15/xU7FZCPjckRMBAD.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近我们的 Pulsar 存储有很长一段时间数据一直得不到回收，但消息确实已经是 ACK 了，理论上应该是会被回收的，随着时间流逝不但没回收还一直再涨，最后在没找到原因的情况下就只有一直不停的扩容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后磁盘是得到了回收，过程先不表，之后再讨论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了防止类似的问题再次发生，我们希望可以监控到磁盘维度，能够列出各个日志文件的大小以及创建时间。&lt;/p&gt;
&lt;p&gt;这时就需要对 &lt;code&gt;Pulsar&lt;/code&gt; 的存储模型有一定的了解，也就有了这篇文章。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
    <category term="Bookkeeper" scheme="http://crossoverjie.top/tags/Bookkeeper/"/>
    
  </entry>
  
</feed>
