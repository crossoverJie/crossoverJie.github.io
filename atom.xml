<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverJie&#39;s Blog</title>
  
  <subtitle>baller</subtitle>
  <link href="http://crossoverjie.top/atom.xml" rel="self"/>
  
  <link href="http://crossoverjie.top/"/>
  <updated>2023-09-19T06:36:40.881Z</updated>
  <id>http://crossoverjie.top/</id>
  
  <author>
    <name>crossoverJie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Github commit 签名+合并 Commit</title>
    <link href="http://crossoverjie.top/2023/09/18/ob/git-tips-rebase/"/>
    <id>http://crossoverjie.top/2023/09/18/ob/git-tips-rebase/</id>
    <published>2023-09-18T09:56:51.000Z</published>
    <updated>2023-09-19T06:36:40.881Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/18/gCjw9hZx4Y6cPSn.png" alt="Github的一个奇技淫巧.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间给 <code>VictoriaLogs</code> 提交了一个 PR：<br><a href="https://github.com/VictoriaMetrics/VictoriaMetrics/pull/4934">https://github.com/VictoriaMetrics/VictoriaMetrics/pull/4934</a></p><p>本来一切都很顺利，只等合并了，但在临门一脚的时候社区维护人员问我可否给 <code>git</code> <code>commit</code> 加上签名。</p><blockquote><p>于是我就默默的调试到了凌晨四点😭</p></blockquote><p><img src="https://s2.loli.net/2023/09/18/VXhjU9ypuKP1ZWg.png" alt="image.png"></p><span id="more"></span><p>以前我也没怎么注意过这个选项，经过 <code>Google</code> 后发现 <code>Idea</code> 在提交的时候可以自行设置。</p><p><img src="https://s2.loli.net/2023/09/18/QdTetRSNG5c3KVr.png" alt="image.png"><br>当我勾选了这个提交新的代码后，依然被告知没有正确的签名，这时我才发现理解错误了。</p><h1 id="为-GitHub-的提交签名"><a href="#为-GitHub-的提交签名" class="headerlink" title="为 GitHub 的提交签名"></a>为 GitHub 的提交签名</h1><p>结合这位社区大佬给的文档，他所需要的是每次提交的代码都是有签名的，类似于这样：<br><img src="https://s2.loli.net/2023/09/18/26vgVMZmNrPCkqo.png" alt="image.png"></p><p>如果我们想要 <code>GitHub</code> 现实 <code>Verified</code> 这个标签，那就需要对 <code>commit</code> 或者是打的 <code>tag</code> 进行签名。</p><p>而签名的方式有三种：<code>GPG</code>, <code>SSH</code>, <code>S/MIME</code>，这里我以 GPG 签名为例，整体流程如下：</p><p><img src="https://s2.loli.net/2023/09/18/HwDIlL94c51Uz3e.png" alt="image.png"></p><p>先在<a href="https://www.gnupg.org/download/">https://www.gnupg.org/download/</a>这里下载安装 GPG 的命令行程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --full-generate-key</span><br></pre></td></tr></table></figure><p>使用这个命令生成 key，之后会根据提示录入一些信息，包含你的 ID 和邮箱，建议都和 GitHub 的 ID 邮箱保持一致即可，然后一路回车完事。</p><p>之后可以使用这个命令查看刚才创建的 Key：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gpg --list-secret-keys --keyid-format=long</span><br><span class="line">------------------------------------</span><br><span class="line">sec   4096R/3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]</span><br><span class="line">uid                          Hubot &lt;hubot@example.com&gt;</span><br><span class="line">ssb   4096R/4BB6D45482678BE3 2016-03-10</span><br></pre></td></tr></table></figure><p>我们需要将 <code>3AA5C34371567BD2</code> 这个 Key 的 ID 字符串复制，之后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --armor --export 3AA5C34371567BD2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Prints the GPG key ID, <span class="keyword">in</span> ASCII armor format</span></span><br></pre></td></tr></table></figure><p>此时会打印出公钥，我们将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PGP PUBLIC KEY BLOCK-----</span><br><span class="line">-----END PGP PUBLIC KEY BLOCK-----</span><br></pre></td></tr></table></figure><p>这些数据复制到 GitHub 的个人设置页面：<br><img src="https://s2.loli.net/2023/09/18/zvMgJcqAnRQjYxG.png" alt="image.png"></p><p>此时还没完，如果我们直接提交代码的也不会有 <code>Verified</code> 的标签。</p><p><img src="https://s2.loli.net/2023/09/18/eST5f1Vad4x8Ou7.png" alt="image.png"></p><p>我们还需要打开 git 的 config 设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config commit.gpgsign true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局打开</span></span><br><span class="line">git config --global commit.gpgsign true</span><br><span class="line">git commit -S -m &quot;YOUR_COMMIT_MESSAGE&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>这样提交的 Commit 就会打上验证的标签了。<br><img src="https://s2.loli.net/2023/09/18/HKcvrfMozC9YEnx.png" alt="image.png"></p><blockquote><p>-S 的效果和在 idea 中选中 Sign-off 的效果一样。</p></blockquote><p>官方文档也有详细的步骤：<br><a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/about-commit-signature-verification">https://docs.github.com/en/authentication/managing-commit-signature-verification/about-commit-signature-verification</a></p><h1 id="Squash-合并提交"><a href="#Squash-合并提交" class="headerlink" title="Squash 合并提交"></a>Squash 合并提交</h1><p>不过在我这个 <code>PR</code> 的背景下还有一个步骤没有完成，就是我之前提交的 <code>Commit</code> 都没要验证，我需要将他们都合并为一个验证的 Commit 然后在强制推送上去，这样整个 <code>git log</code> 看起来才足够简洁。</p><p>最终效果如下，只有一个 Commit 存在。<br><img src="https://s2.loli.net/2023/09/18/1OzjkDwhdWuJS8n.png"></p><p>这时候就得需要 git rebase 出马了。</p><p><img src="https://s2.loli.net/2023/09/18/vaOPw3gQTtVSoxC.png" alt="image.png"><br>以刚才测试的这两个提交为例，我需要将他们合并为一个提交。</p><p>我们先使用这个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~N</span><br><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure><p>N 就是我们需要合并几个提交，在我这里就是 2.</p><p><img src="https://s2.loli.net/2023/09/18/PN6nUE3BVu48TWF.png" alt="image.png"><br>我们需要将除了第一个 commit 之外的都修改为 s，也就是下面注释里的 <code>squash</code> 的简写（压缩的意思）。</p><p>这是一个 vim 的交互编辑模式，编辑完成之后保存退出。</p><blockquote><p>不会还有程序员不知道如何保存 vim 退出吧🐕。</p></blockquote><p>保存后又会弹出一个编辑页面，让我们填写这次压缩之后的提交记录，默认会帮我生成好，当然你也可以全部删掉后重写。</p><p><img src="https://s2.loli.net/2023/09/18/YCx5ablcrBmsdiD.png" alt="image.png"></p><p>我这里就直接使用它生成好的就可以了，依然还是保存退出。</p><p>最后再强行推送到我所在的分支即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin test-rebase -f</span><br></pre></td></tr></table></figure><p>在这个分支的提交页面也只会看到刚才强行推送的记录了，刚才的两个提交已经合并为这一个了。</p><p><img src="https://s2.loli.net/2023/09/18/ULO3kxgSYErPqle.png" alt="image.png"></p><h1 id="将修改提交到其他分支"><a href="#将修改提交到其他分支" class="headerlink" title="将修改提交到其他分支"></a>将修改提交到其他分支</h1><p>有时候线上出现问题需要马上修复的时候，我会不下意识的直接就开始改了，等真的提交代码被拒的时候才发现是在主分支上。</p><p>我觉得有类似需求的场景还不少，这时候就需要将当前分支的修改提交到一个新的分支上，总不能 revert 之后重新再写吧。</p><p>所以通常我的流程是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个分支</span></span><br><span class="line">git branch newbranch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将当前分支的修改临时保存到暂缓区，同时回滚当前分支。</span></span><br><span class="line">git stash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到新的分支</span></span><br><span class="line">git checkout newbranch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从暂缓区中取出刚才的修改</span></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>这样之前分支的修改就会同步到新的分支上了，借着便在新的分支上继续开发了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>借着这个机会也了解了 <code>rebase</code> 的骚操作挺多的，不过我平时用的最多的还是 <code>merge</code>，这个倒没有好坏之分，只要同组的开发者都达成一致即可。</p><p>#Blog #Github #Git</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/18/gCjw9hZx4Y6cPSn.png&quot; alt=&quot;Github的一个奇技淫巧.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间给 &lt;code&gt;VictoriaLogs&lt;/code&gt; 提交了一个 PR：&lt;br&gt;&lt;a href=&quot;https://github.com/VictoriaMetrics/VictoriaMetrics/pull/4934&quot;&gt;https://github.com/VictoriaMetrics/VictoriaMetrics/pull/4934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本来一切都很顺利，只等合并了，但在临门一脚的时候社区维护人员问我可否给 &lt;code&gt;git&lt;/code&gt; &lt;code&gt;commit&lt;/code&gt; 加上签名。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;于是我就默默的调试到了凌晨四点😭&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/18/VXhjU9ypuKP1ZWg.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="http://crossoverjie.top/categories/git/"/>
    
    
    <category term="rebase" scheme="http://crossoverjie.top/tags/rebase/"/>
    
  </entry>
  
  <entry>
    <title>k8s入门到实战-使用Ingress</title>
    <link href="http://crossoverjie.top/2023/09/15/ob/k8s-Ingress/"/>
    <id>http://crossoverjie.top/2023/09/15/ob/k8s-Ingress/</id>
    <published>2023-09-15T09:13:37.000Z</published>
    <updated>2023-09-21T01:36:12.470Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/14/Pe7DWCIS2UMKHQ8.png" alt="ingress.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前两章中我们将应用<a href="https://crossoverjie.top/2023/08/31/ob/k8s-0-start/">部署</a>到了 k8s 中，同时不同的服务之间也可以通过 <a href="https://crossoverjie.top/2023/09/05/ob/k8s-service/">service</a> 进行调用，现在还有一个步骤就是将我们的应用暴露到公网，并提供域名的访问。</p><p>这一步类似于我们以前配置 Nginx 和绑定域名，提供这个能力的服务在 k8s 中成为 Ingress。</p><p>通过这个描述其实也能看出 Ingress 是偏运维的工作，但也不妨碍我们作为研发去了解这部分的内容；了解整个系统是如何运转的也是研发应该掌握的技能。</p><span id="more"></span><h1 id="安装-Ingress-控制器"><a href="#安装-Ingress-控制器" class="headerlink" title="安装 Ingress 控制器"></a>安装 Ingress 控制器</h1><p>在正式使用 Ingress 之前需要给 k8s 安装一个 Ingress 控制器，我们这里安装官方提供的 Ingress-nginx 控制器。</p><p>当然还有社区或者企业提供的各种控制器：<br><img src="https://s2.loli.net/2023/09/14/i1ebXQNUjxPkLEZ.png" alt="image.png"></p><p>有两种安装方式: helm 或者是直接 apply 一个资源文件。</p><p>关于 <code>helm</code> 我们会在后面的章节单独讲解。</p><p>这里就直接使用资源文件安装即可，我已经上传到 GitHub 可以在这里访问：<br><a href="https://github.com/crossoverJie/k8s-combat/blob/main/deployment/ingress-nginx.yaml">https://github.com/crossoverJie/k8s-combat/blob/main/deployment/ingress-nginx.yaml</a></p><p>其实这个文件也是直接从官方提供的复制过来的，也可以直接使用这个路径进行安装：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/cloud/deploy.yaml</span></span><br></pre></td></tr></table></figure><blockquote><p>yaml 文件的内容是一样的。</p></blockquote><p>不过要注意安装之后可能容器状态一直处于 Pending 状态，查看容器的事件时会发现镜像拉取失败。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k describe pod ingress-nginx-controller-7cdfb9988c-lbcst -n ingress-nginx</span><br></pre></td></tr></table></figure><blockquote><p>describe 是一个用于查看 k8s 对象详细信息的命令。</p></blockquote><p>在刚才那份 yaml 文件中可以看到有几个镜像需要拉取，我们可以先在本地手动拉取镜像：<br><img src="https://s2.loli.net/2023/09/14/3IsRe2QWcmjTY41.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.k8s.io/ingress-nginx/controller:v1.8.2</span><br></pre></td></tr></table></figure><p>如果依然无法拉取，可以尝试配置几个国内镜像源镜像拉取：</p><p><img src="https://s2.loli.net/2023/09/14/uTNDACSWdPp7BVt.png" alt="image.png"></p><blockquote><p>我这里使用的 docker-desktop 自带的 k8s，推荐读者朋友也使用这个工具。</p></blockquote><h1 id="创建-Ingress"><a href="#创建-Ingress" class="headerlink" title="创建 Ingress"></a>创建 Ingress</h1><p>使用刚才的 yaml 安装成功之后会在 <code>ingress-nginx</code> 命名空间下创建一个 Pod，通过 get 命令查看状态为 Running 即为安装成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">k get pod -n ingress-nginx</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS      AGE</span><br><span class="line">ingress-nginx-controller-7cdf   1/1     Running   2 (35h ago)   3d</span><br></pre></td></tr></table></figure><blockquote><p>Namespace 也是 k8s 内置的一个对象，可以简单理解为对资源进行分组管理，我们通常可以使用它来区分各个不同的环境，比如 dev&#x2F;test&#x2F;prod 等，不同命名空间下的资源不会互相干扰，且相互独立。</p></blockquote><p>之后便可以创建 Ingress 资源了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-ingress</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span>  </span><br><span class="line">  <span class="attr">rules:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.service1.io</span>  </span><br><span class="line">      <span class="attr">http:</span>  </span><br><span class="line">        <span class="attr">paths:</span>  </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">backend:</span>  </span><br><span class="line">              <span class="attr">service:</span>  </span><br><span class="line">                <span class="attr">name:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line">                <span class="attr">port:</span>  </span><br><span class="line">                  <span class="attr">number:</span> <span class="number">8081</span>  </span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span>  </span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.service2.io</span>  </span><br><span class="line">      <span class="attr">http:</span>  </span><br><span class="line">        <span class="attr">paths:</span>  </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">backend:</span>  </span><br><span class="line">              <span class="attr">service:</span>  </span><br><span class="line">                <span class="attr">name:</span> <span class="string">k8s-combat-service-2</span>  </span><br><span class="line">                <span class="attr">port:</span>  </span><br><span class="line">                  <span class="attr">number:</span> <span class="number">8081</span>  </span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span>  </span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br></pre></td></tr></table></figure><p>看这个内容也很容易理解，创建了一个 <code>Ingress</code> 的对象，其中的重点就是这里的规则是如何定义的。</p><blockquote><p>在 k8s 中今后还会接触到各种不同的 Kind</p></blockquote><p>这里的 <code>ingressClassName: nginx</code>   也是在刚开始安装的控制器里定义的名字，由这个资源定义。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">IngressClass</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app.kubernetes.io/component:</span> <span class="string">controller</span>  </span><br><span class="line">    <span class="attr">app.kubernetes.io/instance:</span> <span class="string">ingress-nginx</span>  </span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span>  </span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span>  </span><br><span class="line">    <span class="attr">app.kubernetes.io/version:</span> <span class="number">1.8</span><span class="number">.2</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>咱们这个规则很简单，就是将两个不同的域名路由到两个不同的 service。</p><blockquote><p>这里为了方便测试又创建了一个 <code>k8s-combat-service-2</code> 的 service，和 <code>k8s-combat-service</code> 是一样的，只是改了个名字而已。</p></blockquote><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>也是为了方便测试，我在应用镜像中新增了一个接口，用于返回当前 Pod 的 hostname。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">   name, _ := os.Hostname()  </span><br><span class="line">   fmt.Fprint(w, name)  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于我实际并没有 <code>www.service1.io/www.service2.io</code> 这两个域名，所以只能在本地配置 host 进行模拟。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.37 www.service1.io</span><br><span class="line">10.0.0.37 www.service2.io</span><br></pre></td></tr></table></figure><blockquote><p>我测试所使用的 k8s 部署在我家里一台限制的 Mac 上，所以这里的 IP 它的地址。</p></blockquote><p>当我们反复请求两次这个接口，会拿到两个不同的 hostname，也就是将我们的请求轮训负载到了这两个 service 所代理的两个 Pod 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">❯ curl http://www.service1.io/</span><br><span class="line"><span class="meta prompt_">k8s-combat-service-79c5579587-b6nlj%</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">❯ curl http://www.service1.io/</span></span><br><span class="line"><span class="meta prompt_">k8s-combat-service-79c5579587-bk7nw%</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">❯ curl http://www.service2.io/</span></span><br><span class="line"><span class="meta prompt_">k8s-combat-service-2-7bbf56b4d9-dkj9b%</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">❯ curl http://www.service2.io/</span></span><br><span class="line">k8s-combat-service-2-7bbf56b4d9-t5l4g</span><br></pre></td></tr></table></figure><p>我们也可以直接使用 describe 查看我们的 ingress 定义以及路由规则：<br><img src="https://s2.loli.net/2023/09/14/pgZzVb1L4aQTMwn.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">k describe ingress k8s-combat-ingress</span></span><br><span class="line">Name:             k8s-combat-ingress</span><br><span class="line">Labels:           &lt;none&gt;</span><br><span class="line">Namespace:        default</span><br><span class="line">Address:          localhost</span><br><span class="line">Ingress Class:    nginx</span><br><span class="line">Default backend:  &lt;default&gt;</span><br><span class="line">Rules:</span><br><span class="line">  Host             Path  Backends</span><br><span class="line">  ----             ----  --------</span><br><span class="line">  www.service1.io</span><br><span class="line">                   /   k8s-combat-service:8081 (10.1.0.65:8081,10.1.0.67:8081)</span><br><span class="line">  www.service2.io</span><br><span class="line">                   /   k8s-combat-service-2:8081 (10.1.0.63:8081,10.1.0.64:8081)</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure><p>如果我们手动新增一个域名解析：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.37 www.service3.io</span><br><span class="line">❯ curl http://www.service3.io/</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>会直接 404，这是因为没有找到这个域名的规则。</p><h1 id="访问原理"><a href="#访问原理" class="headerlink" title="访问原理"></a>访问原理</h1><p><img src="https://s2.loli.net/2023/09/14/9JTfp6GP24VmzAK.png" alt="image.png"><br>整个的请求路径如上图所示，其实我们的 Ingress 本质上也是一个 service（所以它也可以启动多个副本来进行负载），只是他的类型是 <code>LoadBalancer</code>，通常这种类型的 service 会由云厂商绑定一个外部 IP，这样就可以通过这个外部 IP 访问 Ingress 了。</p><blockquote><p>而我们应用的 service 是 ClusterIP，只能在应用内部访问</p></blockquote><p><img src="https://s2.loli.net/2023/09/14/Bu67SlMLak1hirc.png" alt="image.png"></p><p>通过 service 的信息也可以看到，我们 ingress 的 service 绑定的外部 IP 是 <code>localhost</code>（本地的原因）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Ingress 通常是充当网关的作用，后续我们在使用 Istio 时，也可以使用 Istio 所提供的控制器来替换掉 Ingress-nginx，可以更方便的管理内外网流量。</p><p>本文的所有源码在这里可以访问：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/14/Pe7DWCIS2UMKHQ8.png&quot; alt=&quot;ingress.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前两章中我们将应用&lt;a href=&quot;https://crossoverjie.top/2023/08/31/ob/k8s-0-start/&quot;&gt;部署&lt;/a&gt;到了 k8s 中，同时不同的服务之间也可以通过 &lt;a href=&quot;https://crossoverjie.top/2023/09/05/ob/k8s-service/&quot;&gt;service&lt;/a&gt; 进行调用，现在还有一个步骤就是将我们的应用暴露到公网，并提供域名的访问。&lt;/p&gt;
&lt;p&gt;这一步类似于我们以前配置 Nginx 和绑定域名，提供这个能力的服务在 k8s 中成为 Ingress。&lt;/p&gt;
&lt;p&gt;通过这个描述其实也能看出 Ingress 是偏运维的工作，但也不妨碍我们作为研发去了解这部分的内容；了解整个系统是如何运转的也是研发应该掌握的技能。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/k8s/"/>
    
    
    <category term="Ingress" scheme="http://crossoverjie.top/tags/Ingress/"/>
    
  </entry>
  
  <entry>
    <title>Golang 基础面试题 01</title>
    <link href="http://crossoverjie.top/2023/09/12/ob/Golang-interview-01/"/>
    <id>http://crossoverjie.top/2023/09/12/ob/Golang-interview-01/</id>
    <published>2023-09-12T12:58:03.000Z</published>
    <updated>2023-09-15T18:42:21.149Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/12/xJgnyReWs2mp7Pr.png" alt="Golang 面试题合集.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在之前的文章中分享了 <a href="https://crossoverjie.top/2023/08/17/ob/k8s-question-01/">k8s</a> 相关的面试题，本文我们重点来讨论和 k8s 密切相关的 Go 语言面试题。</p><p>这几年随着云原生的兴起，大部分后端开发者，特别是 Java 开发者都或多或少的想学习一些 Go 相关的技能，所以今天分享的内容比较初级，适合 Go 语言初学者。</p><p><img src="https://s2.loli.net/2023/09/12/oheqNwJt3KvsgDM.png" alt="image.png"></p><p>本文内容依然来自于这个仓库<br><a href="https://github.com/bregman-arie/devops-exercises">https://github.com/bregman-arie/devops-exercises</a></p><span id="more"></span><p>以下是具体内容：</p><blockquote><p>（）的内容是我的补充部分。</p></blockquote><h1 id="Go-101"><a href="#Go-101" class="headerlink" title="Go 101"></a>Go 101</h1><h2 id="Go-语言有哪些特点"><a href="#Go-语言有哪些特点" class="headerlink" title="Go 语言有哪些特点"></a>Go 语言有哪些特点</h2><ul><li>Go 是一种强类型静态语言，变量的类型必须在声明的时候指定（但可以使用类型推导），在运行时不能修改变量类型（与 <code>Python</code> 这类动态类型语言不同）。</li><li>足够的简单，通常一个周末就能学会</li><li>编译速度够快</li><li>内置并发（相对于 Java 的并发来说非常简单）</li><li>内置垃圾收集</li><li>多平台支持</li><li>可以打包到一个二进制文件中，所有运行时需要依赖的库都会被打包进这个二进制文件中，非常适合于分发。</li></ul><h2 id="Go-是一种编译型的静态类型语言，正确还是错误"><a href="#Go-是一种编译型的静态类型语言，正确还是错误" class="headerlink" title="Go 是一种编译型的静态类型语言，正确还是错误"></a>Go 是一种编译型的静态类型语言，正确还是错误</h2><p>正确✅</p><h2 id="为什么有些函数是以大写字母开头的"><a href="#为什么有些函数是以大写字母开头的" class="headerlink" title="为什么有些函数是以大写字母开头的"></a>为什么有些函数是以大写字母开头的</h2><p>这是因为 Go 语言中首字母大写的函数和变量是可以导出的，也就是可以被其他包所引用；类似于 Java 中的 <code>public</code> 和 <code>private</code> 关键字。</p><h1 id="变量和数据类型"><a href="#变量和数据类型" class="headerlink" title="变量和数据类型"></a>变量和数据类型</h1><h2 id="简洁和常规声明变量方式"><a href="#简洁和常规声明变量方式" class="headerlink" title="简洁和常规声明变量方式"></a>简洁和常规声明变量方式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x := <span class="number">2</span> <span class="comment">// 只能在函数内使用，自动类型推导</span></span><br><span class="line">  <span class="keyword">var</span> y <span class="type">int</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">&quot;x: %v. y: %v&quot;</span>, x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正确✅还是错误❌"><a href="#正确✅还是错误❌" class="headerlink" title="正确✅还是错误❌"></a>正确✅还是错误❌</h2><ul><li>可以重复声明变量❌（强类型语言的特性）</li><li>变量一旦声明，就必须使用✅（避免声明无效变量，增强代码可读性）</li></ul><h2 id="下面这段代码的结果是什么？"><a href="#下面这段代码的结果是什么？" class="headerlink" title="下面这段代码的结果是什么？"></a>下面这段代码的结果是什么？</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> userName</span><br><span class="line">    userName = <span class="string">&quot;user&quot;</span></span><br><span class="line">    fmt.Println(userName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误，变量 <code>userName</code> 没有声明类型；修改为这样是可以的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> userName <span class="type">string</span></span><br><span class="line">    userName = <span class="string">&quot;user&quot;</span></span><br><span class="line">    fmt.Println(userName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="var-x-int-2-and-x-2-这两种声明变量的区别"><a href="#var-x-int-2-and-x-2-这两种声明变量的区别" class="headerlink" title="var x int = 2 and x := 2 这两种声明变量的区别"></a><code>var x int = 2</code> and <code>x := 2</code> 这两种声明变量的区别</h2><p>结果上来说是相等的，但 <code>x := 2</code>  只能在函数体类声明。</p><h2 id="下面这段代码的结果是声明？"><a href="#下面这段代码的结果是声明？" class="headerlink" title="下面这段代码的结果是声明？"></a>下面这段代码的结果是声明？</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">x := <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x = <span class="number">3</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误，<code>x := 2</code>  不能在函数体外使用， <code>x = 3</code> 没有指定类型，除非使用 <code>x := 3</code> 进行类型推导。</p><h2 id="如何使用变量声明块（至少三个变量）"><a href="#如何使用变量声明块（至少三个变量）" class="headerlink" title="如何使用变量声明块（至少三个变量）"></a>如何使用变量声明块（至少三个变量）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  x <span class="type">bool</span>   = <span class="literal">false</span></span><br><span class="line">  y <span class="type">int</span>    = <span class="number">0</span></span><br><span class="line">  z <span class="type">string</span> = <span class="string">&quot;false&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;The type of x: %T. The value of x: %v\n&quot;</span>, x, x)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;The type of y: %T. The value of y: %v\n&quot;</span>, y, y)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;The type of z: %T. The value of z: %v\n&quot;</span>, y, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量块配合 <code>go fmt</code> 格式化之后的代码对齐的非常工整，强迫症的福音。</p><p>Go 的基础面试题也蛮多的，我们先从基础的开始，今后后继续更新相关面试题，难度也会逐渐提高，感兴趣的朋友请持续关注。<br>#GO #面试 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/12/xJgnyReWs2mp7Pr.png&quot; alt=&quot;Golang 面试题合集.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在之前的文章中分享了 &lt;a href=&quot;https://crossoverjie.top/2023/08/17/ob/k8s-question-01/&quot;&gt;k8s&lt;/a&gt; 相关的面试题，本文我们重点来讨论和 k8s 密切相关的 Go 语言面试题。&lt;/p&gt;
&lt;p&gt;这几年随着云原生的兴起，大部分后端开发者，特别是 Java 开发者都或多或少的想学习一些 Go 相关的技能，所以今天分享的内容比较初级，适合 Go 语言初学者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/12/oheqNwJt3KvsgDM.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文内容依然来自于这个仓库&lt;br&gt;&lt;a href=&quot;https://github.com/bregman-arie/devops-exercises&quot;&gt;https://github.com/bregman-arie/devops-exercises&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="http://crossoverjie.top/categories/Golang/"/>
    
    
    <category term="面试" scheme="http://crossoverjie.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>k8s入门到实战--跨服务调用</title>
    <link href="http://crossoverjie.top/2023/09/05/ob/k8s-service/"/>
    <id>http://crossoverjie.top/2023/09/05/ob/k8s-service/</id>
    <published>2023-09-05T13:13:28.000Z</published>
    <updated>2023-09-15T18:42:21.018Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/05/GbZ1vKQNHY32wzD.png" alt="service.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在做传统业务开发的时候，当我们的服务提供方有多个实例时，往往我们需要将对方的服务列表保存在本地，然后采用一定的算法进行调用；当服务提供方的列表变化时还得及时通知调用方。</p><span id="more"></span><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">student:</span>  </span><br><span class="line">   <span class="attr">url:</span>     </span><br><span class="line">   <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span><span class="string">:8081</span>     </span><br><span class="line">   <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.2</span><span class="string">:8081</span></span><br></pre></td></tr></table></figure><p>这样自然是对双方都带来不少的负担，所以后续推出的服务调用框架都会想办法解决这个问题。</p><p>以 <code>spring cloud</code> 为例：<br><img src="https://s2.loli.net/2023/09/06/IW1jaidQ25Xk9u4.png" alt="image.png"></p><p>服务提供方会向一个服务注册中心注册自己的服务（名称、IP等信息），客户端每次调用的时候会向服务注册中心获取一个节点信息，然后发起调用。</p><p>但当我们切换到 <code>k8s</code> 后，这些基础设施都交给了 <code>k8s</code> 处理了，所以 <code>k8s</code> 自然得有一个组件来解决服务注册和调用的问题。</p><p>也就是我们今天重点介绍的 <code>service</code>。</p><h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p>在介绍 <code>service</code> 之前我先调整了源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   http.HandleFunc(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">      name, _ := os.Hostname()  </span><br><span class="line">      log.Printf(<span class="string">&quot;%s ping&quot;</span>, name)  </span><br><span class="line">      fmt.Fprint(w, <span class="string">&quot;pong&quot;</span>)  </span><br><span class="line">   &#125;)  </span><br><span class="line">   http.HandleFunc(<span class="string">&quot;/service&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">      resp, err := http.Get(<span class="string">&quot;http://k8s-combat-service:8081/ping&quot;</span>)  </span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         log.Println(err)  </span><br><span class="line">         fmt.Fprint(w, err)  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">      fmt.Fprint(w, resp.Status)  </span><br><span class="line">   &#125;)  </span><br><span class="line">  </span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, <span class="literal">nil</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增了一个 <code>/service</code> 的接口，这个接口会通过 service 的方式调用服务提供者的服务，然后重新打包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make docker</span><br></pre></td></tr></table></figure><p>同时也新增了一个 <code>deployment-service.yaml</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat-service</span> <span class="comment"># 通过标签选择关联  </span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line">  <span class="attr">template:</span>  </span><br><span class="line">    <span class="attr">metadata:</span>  </span><br><span class="line">      <span class="attr">labels:</span>  </span><br><span class="line">        <span class="attr">app:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line">    <span class="attr">spec:</span>  </span><br><span class="line">      <span class="attr">containers:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line">          <span class="attr">image:</span> <span class="string">crossoverjie/k8s-combat:v1</span>  </span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span>  </span><br><span class="line">          <span class="attr">resources:</span>  </span><br><span class="line">            <span class="attr">limits:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">100Mi</span>  </span><br><span class="line">            <span class="attr">requests:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;0.1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">10Mi</span>  </span><br><span class="line"><span class="meta">---  </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat-service</span> <span class="comment"># 通过标签选择关联  </span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span>  </span><br><span class="line">  <span class="attr">ports:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8081</span>        <span class="comment"># 本 Service 的端口  </span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8081</span>  <span class="comment"># 容器端口  </span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">app</span></span><br></pre></td></tr></table></figure><p>使用相同的镜像部署一个新的 deployment，名称为 <code>k8s-combat-service</code>，重点是新增了一个<code>kind: Service</code> 的对象。</p><p>这个就是用于声明 <code>service</code> 的组件，在这个组件中也是使用 <code>selector</code> 标签和 <code>deployment</code> 进行了关联。</p><p>也就是说这个 <code>service</code> 用于服务于名称等于 <code>k8s-combat-service</code> 的 <code>deployment</code>。</p><p>下面的两个端口也很好理解，一个是代理的端口， 另一个是  service 自身提供出去的端口。</p><p>至于 <code>type: ClusterIP</code> 是用于声明不同类型的 <code>service</code>，除此之外的类型还有：</p><ul><li><a href="https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport"><code>NodePort</code></a></li><li><a href="https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer"><code>LoadBalancer</code></a></li><li><a href="https://kubernetes.io/docs/concepts/services-networking/service/#externalname"><code>ExternalName</code></a><br>等类型，默认是 <code>ClusterIP</code>，现在不用纠结这几种类型的作用，后续我们在讲到 <code>Ingress</code> 的时候会具体介绍。</li></ul><h2 id="负载测试"><a href="#负载测试" class="headerlink" title="负载测试"></a>负载测试</h2><p>我们先分别将这两个 <code>deployment</code> 部署好：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k apply -f deployment/deployment.yaml</span><br><span class="line">k apply -f deployment/deployment-service.yaml</span><br><span class="line"></span><br><span class="line">❯ k get pod</span><br><span class="line">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">k8s-combat-7867bfb596-67p5m           1/1     Running   0          3h22m</span><br><span class="line">k8s-combat-service-5b77f59bf7-zpqwt   1/1     Running   0          3h22m</span><br></pre></td></tr></table></figure><p>由于我新增了一个 <code>/service</code> 的接口，用于在 <code>k8s-combat</code> 中通过 <code>service</code> 调用 <code>k8s-combat-service</code> 的接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://k8s-combat-service:8081/ping&quot;</span>)</span><br></pre></td></tr></table></figure><p>其中 <code>k8s-combat-service</code> 服务的域名就是他的服务名称。</p><blockquote><p>如果是跨 namespace 调用时，需要指定一个完整名称，在后续的章节会演示。</p></blockquote><p>我们整个的调用流程如下：<br><img src="https://s2.loli.net/2023/09/06/i12pR3DjC6wnIXQ.png" alt="image.png"></p><p>相信大家也看得出来相对于 <code>spring cloud</code> 这类微服务框架提供的客户端负载方式，<code>service</code> 是一种服务端负载，有点类似于 <code>Nginx</code> 的反向代理。</p><p>为了更直观的验证这个流程，此时我将 <code>k8s-combat-service</code> 的副本数增加到 2：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>只需要再次执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ k apply -f deployment/deployment-service.yaml</span><br><span class="line">deployment.apps/k8s-combat-service configured</span><br><span class="line">service/k8s-combat-service unchanged</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/09/06/ZC8UrjEz6ia1Qgo.png" alt="image.png"></p><blockquote><p>不管我们对 <code>deployment</code> 的做了什么变更，都只需要 <code>apply</code> 这个 <code>yaml</code>  文件即可， k8s 会自动将当前的 <code>deployment</code> 调整为我们预期的状态（比如这里的副本数量增加为 2）；这也就是 <code>k8s</code> 中常说的<strong>声明式 API</strong>。</p></blockquote><p>可以看到此时 <code>k8s-combat-service</code> 的副本数已经变为两个了。<br>如果我们此时查看这个 <code>service</code> 的描述时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ k describe svc k8s-combat-service |grep Endpoints</span><br><span class="line">Endpoints:         192.168.130.133:8081,192.168.130.29:8081</span><br></pre></td></tr></table></figure><p>会发现它已经代理了这两个 <code>Pod</code> 的 IP。</p><p><img src="https://s2.loli.net/2023/09/06/HbjyEcnaeCK6uMJ.png" alt="image.png"><br>此时我进入了 <code>k8s-combat-7867bfb596-67p5m</code> 的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k exec -it k8s-combat-7867bfb596-67p5m bash</span><br><span class="line">curl http://127.0.0.1:8081/service</span><br></pre></td></tr></table></figure><p>并执行两次 <code>/service</code> 接口，发现请求会轮训进入 <code>k8s-combat-service</code> 的代理的 IP 中。</p><p>由于 <code>k8s service</code> 是基于 <code>TCP/UDP</code> 的四层负载，所以在 <code>http1.1</code>  中是可以做到请求级的负载均衡，但如果是类似于 <code>gRPC</code> 这类长链接就无法做到请求级的负载均衡。</p><p>换句话说 <code>service</code> 只支持连接级别的负载。</p><p>如果要支持 <code>gRPC</code>，就得使用 Istio 这类服务网格，相关内容会在后续章节详解。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说 <code>k8s service</code> 提供了简易的服务注册发现和负载均衡功能，当我们只提供 http 服务时是完全够用的。</p><p>相关的源码和 yaml 资源文件都存在这里：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/05/GbZ1vKQNHY32wzD.png&quot; alt=&quot;service.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在做传统业务开发的时候，当我们的服务提供方有多个实例时，往往我们需要将对方的服务列表保存在本地，然后采用一定的算法进行调用；当服务提供方的列表变化时还得及时通知调用方。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/k8s/"/>
    
    
    <category term="Go" scheme="http://crossoverjie.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>k8s 入门到实战--部署应用到 k8s</title>
    <link href="http://crossoverjie.top/2023/08/31/ob/k8s-0-start/"/>
    <id>http://crossoverjie.top/2023/08/31/ob/k8s-0-start/</id>
    <published>2023-08-31T14:42:32.000Z</published>
    <updated>2023-09-15T18:42:21.018Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/04/ymUpcXZrxfNsT91.png" alt="k8s 入门到实战 01.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近这这段时间更新了一些 k8s 相关的博客和视频，也收到了一些反馈；大概分为这几类：</p><ul><li>公司已经经历过服务化改造了，但还未接触过云原生。</li><li>公司部分应用进行了云原生改造，但大部分工作是由基础架构和运维部门推动的，自己只是作为开发并不了解其中的细节，甚至 k8s 也接触不到。</li><li>还处于比较传统的以虚拟机部署的传统运维为主。</li></ul><p>其中以第二种占大多数，虽然公司进行了云原生改造，但似乎和纯业务研发同学来说没有太大关系，自己工作也没有什么变化。</p><p>恰好我之前正好从业务研发的角度转换到了基础架构部门，两个角色我都接触过，也帮助过一些业务研发了解公司的云原生架构；</p><p>为此所以我想系统性的带大家以<strong>研发</strong>的角度对 k8s 进行实践。</p><p>因为 k8s 部分功能其实是偏运维的，对研发来说优先级并不太高；<br>所以我不太会涉及一些 k8s 运维的知识点，比如安装、组件等模块；主要以我们日常开发会使用到的组件讲起。</p><span id="more"></span><h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul><li>部署应用到 k8s</li><li>跨服务调用</li><li>集群外部访问</li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><ul><li>如何使用配置</li><li>服务网格实战</li></ul><h2 id="运维你的应用"><a href="#运维你的应用" class="headerlink" title="运维你的应用"></a>运维你的应用</h2><ul><li>应用探针</li><li>滚动更新与回滚</li><li>优雅采集日志</li><li>应用可观测性<ul><li>指标可视化</li></ul></li></ul><h2 id="k8s-部署常见中间件"><a href="#k8s-部署常见中间件" class="headerlink" title="k8s 部署常见中间件"></a>k8s 部署常见中间件</h2><ul><li>helm 一键部署</li><li>编写 Operator 自动化应用生命周期</li></ul><p><img src="https://s2.loli.net/2023/09/02/BtYcF6jp8u3nzJs.png" alt="image.png"><br>这里我整理了一下目录，每个章节都有博客+视频配合观看，大家可以按照喜好选择。</p><p>因为还涉及到了视频，所以只能争取一周两更，在两个月内全部更新完毕。</p><p>根据我自己的经验，以上内容都掌握的话对 k8s 的掌握会更进一步。</p><h1 id="部署应用到-k8s"><a href="#部署应用到-k8s" class="headerlink" title="部署应用到 k8s"></a>部署应用到 k8s</h1><p>首先从第一章【部署应用到 k8s】开始，我会用 Go 写一个简单的 Web 应用，然后打包为一个 Docker 镜像，之后部署到 k8s 中，并完成其中的接口调用。</p><h2 id="编写应用"><a href="#编写应用" class="headerlink" title="编写应用"></a>编写应用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   http.HandleFunc(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">      log.Println(<span class="string">&quot;ping&quot;</span>)  </span><br><span class="line">      fmt.Fprint(w, <span class="string">&quot;pong&quot;</span>)  </span><br><span class="line">   &#125;)  </span><br><span class="line">  </span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, <span class="literal">nil</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 应用非常简单就是提供了一个 <code>ping</code>  接口，然后返回了一个 <code>pong</code>.</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一阶段：编译 Go 程序  </span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.19</span> AS dependencies  </span><br><span class="line"><span class="keyword">ENV</span> GOPROXY=https://goproxy.cn,direct  </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/app  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> go.mod .  </span></span><br><span class="line"><span class="comment">#COPY ../../go.sum .  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=ssh go mod download  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 第二阶段：构建可执行文件  </span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.19</span> AS builder  </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/app  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .  </span></span><br><span class="line"><span class="comment">#COPY --from=dependencies /go/pkg /go/pkg  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 第三阶段：部署  </span></span><br><span class="line"><span class="keyword">FROM</span> debian:stable-slim  </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y curl  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /go/src/app/k8s-combat /go/bin/k8s-combat  </span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/go/bin:$&#123;PATH&#125;&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 启动 Go 程序  </span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;k8s-combat&quot;</span>]</span></span><br></pre></td></tr></table></figure><p> 之后编写了一个 <code>dockerfile</code> 用于构建 <code>docker</code> 镜像。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">docker:  </span></span><br><span class="line">   @echo <span class="string">&quot;Docker Build...&quot;</span>  </span><br><span class="line">   docker build . -t crossoverjie/k8s-combat:v1 &amp;&amp; docker image push crossoverjie/k8s-combat:v1</span><br></pre></td></tr></table></figure><p>使用 <code>make docker</code>  会在本地构建镜像并上传到 <code>dockerhub</code></p><h2 id="编写-deployment"><a href="#编写-deployment" class="headerlink" title="编写 deployment"></a>编写 deployment</h2><p>下一步便是整个过程中最重要的环节了，也是唯一和 k8s 打交道的地方，那就是编写 deployment。</p><iframe src="//player.bilibili.com/player.html?aid=702346697&bvid=BV1Cm4y1n7yG&cid=1235124452&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>在之前的视频《一分钟了解 k8s》中讲过常见的组件：<br><img src="https://s2.loli.net/2023/09/04/hrOUSVsmP2KkNlC.png" alt="image.png"></p><p>其中我们最常见的就是 deployment，通常用于部署无状态应用；现在还不太需要了解其他的组件，先看看 deployment 如何编写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">  <span class="attr">template:</span>  </span><br><span class="line">    <span class="attr">metadata:</span>  </span><br><span class="line">      <span class="attr">labels:</span>  </span><br><span class="line">        <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">    <span class="attr">spec:</span>  </span><br><span class="line">      <span class="attr">containers:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">          <span class="attr">image:</span> <span class="string">crossoverjie/k8s-combat:v1</span>  </span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span>  </span><br><span class="line">          <span class="attr">resources:</span>  </span><br><span class="line">            <span class="attr">limits:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">300Mi</span>  </span><br><span class="line">            <span class="attr">requests:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;0.1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">30Mi</span></span><br></pre></td></tr></table></figure><p>开头两行的 <code>apiVersion</code>  和 <code>kind</code> 可以暂时不要关注，就理解为 deployment 的固定写法即可。</p><p>metadata：顾名思义就是定义元数据的地方，告诉 <code>Pod</code> 我们这个 <code>deployment</code> 叫什么名字，这里定义为：<code>k8s-combat</code></p><p>中间的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat</span></span><br></pre></td></tr></table></figure><p>也很容易理解，就是给这个 <code>deployment</code> 打上标签，通常是将这个标签和其他的组件进行关联使用才有意义，不然就只是一个标签而已。</p><blockquote><p>标签是键值对的格式，key, value 都可以自定义。</p></blockquote><p>而这里的  <code>app: k8s-combat</code> 便是和下面的 spec 下的 selector 选择器匹配，表明都使用  <code>app: k8s-combat</code>  进行关联。</p><p>而 template 中所定义的标签也是为了让选择器和 template 中的定义的 Pod 进行关联。</p><blockquote><p>Pod 是 k8s 中相同功能容器的分组，一个 Pod 可以绑定多个容器，这里就只有我们应用容器一个了；后续在讲到 istio 和日志采集时便可以看到其他的容器。</p></blockquote><p>template 中定义的内容就很容易理解了，指定了我们的容器拉取地址，以及所占用的资源(<code>cpu/ memory</code>)。</p><p><code>replicas: 1</code>：表示只部署一个副本，也就是只有一个节点的意思。</p><h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><p>之后我们使用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f deployment/deployment.yaml</span><br></pre></td></tr></table></figure><blockquote><p>生产环境中往往会使用云厂商所提供的 k8s 环境，我们本地可以使用 <a href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a> minikube 来模拟。</p></blockquote><p>就会应用这个 deployment 同时将容器部署到 k8s 中，之后使用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure><blockquote><p> 在后台 k8s 会根据我们填写的资源选择一个合适的节点，将当前这个 Pod 部署过去。</p></blockquote><p> 就会列出我们刚才部署的 Pod:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ kubectl get pod</span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">k8s-combat-57f794c59b-7k58n         1/1     Running   0          17h</span><br></pre></td></tr></table></figure><p>我们使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it k8s-combat-57f794c59b-7k58n  bash</span><br></pre></td></tr></table></figure><p>就会进入我们的容器，这个和使用 docker 类似。</p><p>之后执行 curl 命令便可以访问我们的接口了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-combat-57f794c59b-7k58n:/# curl http://127.0.0.1:8081/ping</span><br><span class="line">pong</span><br><span class="line">root@k8s-combat-57f794c59b-7k58n:/#</span><br></pre></td></tr></table></figure><p>这时候我们再开一个终端执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ kubectl logs -f k8s-combat-57f794c59b-7k58n</span><br><span class="line">2023/09/03 09:28:07 ping</span><br></pre></td></tr></table></figure><p>便可以打印容器中的日志，当然前提是应用的日志是写入到了标准输出中。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是这一章节的主要内容，重点就是将我们应用程序员打包为 docker 镜像后上传到镜像仓库，再配置好 deployment 由 k8s 进行调度运行。</p><p>下一章主要会涉及服务内部的调用，感兴趣的朋友可以先关注起来。</p><p>相关的源码和 yaml 资源文件都存在这里：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p><p>#Blog #K8s </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/04/ymUpcXZrxfNsT91.png&quot; alt=&quot;k8s 入门到实战 01.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近这这段时间更新了一些 k8s 相关的博客和视频，也收到了一些反馈；大概分为这几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公司已经经历过服务化改造了，但还未接触过云原生。&lt;/li&gt;
&lt;li&gt;公司部分应用进行了云原生改造，但大部分工作是由基础架构和运维部门推动的，自己只是作为开发并不了解其中的细节，甚至 k8s 也接触不到。&lt;/li&gt;
&lt;li&gt;还处于比较传统的以虚拟机部署的传统运维为主。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中以第二种占大多数，虽然公司进行了云原生改造，但似乎和纯业务研发同学来说没有太大关系，自己工作也没有什么变化。&lt;/p&gt;
&lt;p&gt;恰好我之前正好从业务研发的角度转换到了基础架构部门，两个角色我都接触过，也帮助过一些业务研发了解公司的云原生架构；&lt;/p&gt;
&lt;p&gt;为此所以我想系统性的带大家以&lt;strong&gt;研发&lt;/strong&gt;的角度对 k8s 进行实践。&lt;/p&gt;
&lt;p&gt;因为 k8s 部分功能其实是偏运维的，对研发来说优先级并不太高；&lt;br&gt;所以我不太会涉及一些 k8s 运维的知识点，比如安装、组件等模块；主要以我们日常开发会使用到的组件讲起。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/k8s/"/>
    
    
    <category term="Go" scheme="http://crossoverjie.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>使用 SQL 的方式查询消息队列数据以及踩坑指南</title>
    <link href="http://crossoverjie.top/2023/08/30/ob/Pulsar-SQL/"/>
    <id>http://crossoverjie.top/2023/08/30/ob/Pulsar-SQL/</id>
    <published>2023-08-30T01:31:53.000Z</published>
    <updated>2023-09-15T18:42:21.017Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/30/3iz9yqfuSCn18xk.png" alt="Pulsar-sql.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>为了让业务团队可以更好的跟踪自己消息的生产和消费状态，需要一个类似于表格视图的消息列表，用户可以直观的看到发送的消息；同时点击详情后也能查到消息的整个轨迹。</p><blockquote><p> 消息列表<br><img src="https://s2.loli.net/2023/08/02/l9uvSnqAOxfPer7.png" alt="20230802234405.png"></p></blockquote><span id="more"></span><blockquote><p>点击详情后查看轨迹<br><img src="https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png" alt="20230802234058.png"></p></blockquote><h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p>由于 <code>Pulsar</code> 并没有关系型数据库中表的概念，所有的数据都是存储在 <code>Bookkeeper</code> 中，为了模拟使用 SQL 查询的效果 Pulsar 提供了 <code>Presto</code> (现在已经更名为 <code>Trino</code>)的插件。</p><blockquote><p>Trino 是一个分布式的 SQL 查询引擎，它也提供了插件能力，如果我们想通过 SQL 从自定义数据源查询数据时，基于它的 SPI 编写一个插件是很方便的。</p></blockquote><p>这样便可以类似于查询数据库一样查询 <code>Pulsar</code> 数据：<br><img src="https://s2.loli.net/2023/08/30/1YEtorbwaZAXylL.png" alt="image.png"></p><hr><p><img src="https://s2.loli.net/2023/08/30/u6gc3YxvH94ZDPG.png" alt="image.png"><br>Pulsar 插件的运行流程如上图所示：</p><ul><li>启动的时候通过 <code>Pulsar-Admin</code> 接口获取一些元数据，比如 Scheme，topic 分区信息等。</li><li>然后会创建一个只读的 Bookkeeper 客户端，用于获取数据。</li><li>之后根据 SQL 条件过滤数据即可。</li></ul><p>相关代码：<br><img src="https://s2.loli.net/2023/08/30/vr7ED6BYgOsoqxz.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/30/Np2XD7T9cJAwxQC.png" alt="image.png"></p><h1 id="使用-Pulsar-SQL"><a href="#使用-Pulsar-SQL" class="headerlink" title="使用 Pulsar-SQL"></a>使用 Pulsar-SQL</h1><p><img src="https://s2.loli.net/2023/08/30/UBqocsjFvC2yXEe.png" alt="image.png"></p><p>使用起来也很简单，官方提供了两个命令：</p><ul><li>sql-worker: 会启动一个 trino 服务端同时运行了 Pulsar 插件</li><li>sql: 就是一个 SQL 命令行终端。</li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>自己在本地运行的时候自然是没问题，可是一旦想在生产运行，同时如果你的 <code>Pulsar</code> 集群是运行再 <code>k8s</code> 环境中时就会碰到一些问题。</p><h3 id="无法使用现有-Trino-集群"><a href="#无法使用现有-Trino-集群" class="headerlink" title="无法使用现有 Trino 集群"></a>无法使用现有 Trino 集群</h3><p>首先第一个问题是如果生产环境已经有了一个 <code>Trino</code> 集群想要复用的时候就会碰到问题，常规流程是将 <code>Pulsar</code> 的插件复制到 <code>Trino</code> 的 <code>Plugin</code> 目录，然后重启 <code>Trino</code> 后就能使用该插件。</p><p>当然社区也是支持这么做的：<br><img src="https://s2.loli.net/2023/08/30/RqtIvwy5HNsr27M.png" alt="image.png"><br>但是当我将 Pulsar-plugin 复制到 Trino 中运行的时候却失败了，整体的流程可以参考这个 issue：<br><a href="https://github.com/apache/pulsar/discussions/20941">https://github.com/apache/pulsar/discussions/20941</a></p><p>简单来说 <code>Trino</code> 的官方镜像和 <code>pulsar-plugin</code> 并不能兼容，这个问题直接影响到我们是否可以在生产环境使用它。</p><p>但是手动编译出来的 <code>Trino</code> 服务和插件是兼容的，可以直接运行。</p><p><img src="https://s2.loli.net/2023/08/30/MswBlVXi12DICr9.png" alt="image.png"></p><p>因此我只能在本地编译出 Trino 服务端和 <code>pulsar-plugin</code> 然后打包成一个镜像来运行了，当然这样的坏处就是无法利用到我们现有的 <code>Trino</code> 集群，又得重新部署一个了。</p><p><img src="https://s2.loli.net/2023/08/30/vG83bleTf1EcCPp.png" alt="image.png"></p><p>流程也比较麻烦：</p><ul><li>首先是本地编译 <code>Pulsar-SQL</code> 模块</li><li>将生成物复制到当前目录</li><li>执行 <code>make docker</code> 打出 docker 镜像并上传到私服</li><li>再执行 <code>kubectl</code> 将 trino 部署到 <code>k8s</code> 环境中</li></ul><p>整个流程做下来加上和社区的沟通，更加确定这个功能应该是很少有人在生产环境使用的，毕竟第一个坑就很麻烦，更别提后续的问题了😂。</p><h3 id="Presto-插件不支持-AuthToken"><a href="#Presto-插件不支持-AuthToken" class="headerlink" title="Presto 插件不支持 AuthToken"></a>Presto 插件不支持 AuthToken</h3><p>第二个问题也是个深坑，当我把 Trino 部署好查询数据的时候直接抛了一个调用 <code>pulsar-admin</code>  接口连接超时的异常。</p><p>结果排查了半天发现原来是 <code>pulsar-plugin</code> 里没有提供 <code>JWT</code> 的验证方式，而我们的 Pulsar 集群恰好是打开了 <code>JWT</code> 验证的。</p><p>为此我只能先在本地修复了这个问题，同时也提交了 PR，预计会在下一个大版本合并吧：<br><a href="https://github.com/apache/pulsar/pull/20860">https://github.com/apache/pulsar/pull/20860</a></p><h3 id="新创建的-topic-查询失败"><a href="#新创建的-topic-查询失败" class="headerlink" title="新创建的 topic 查询失败"></a>新创建的 topic 查询失败</h3><p>第二个问题是当查询一个新创建的 topic 时，客户端会直接 block，相关的复现流程在这里：<br><a href="https://github.com/apache/pulsar/issues/20910">https://github.com/apache/pulsar/issues/20910</a></p><p><img src="https://s2.loli.net/2023/08/30/nYestcQqRax1NVv.png" alt="image.png"></p><p>这个问题还好，不是很致命，是我在本地测试的时候无意间发现的。</p><p>本地我已经修复了，后面也提交了一个 PR，目前还在讨论中：<br><a href="https://github.com/apache/pulsar/pull/20911">https://github.com/apache/pulsar/pull/20911</a></p><h3 id="查询消息会丢失最后一条"><a href="#查询消息会丢失最后一条" class="headerlink" title="查询消息会丢失最后一条"></a>查询消息会丢失最后一条</h3><p>这个问题也不是很严重，数据量少的时候会发现，就是在指定了消息发送时间的查询条件时，最后一条消息会被过滤掉，相关 issue 在这里：<br><a href="https://github.com/apache/pulsar/issues/20919">https://github.com/apache/pulsar/issues/20919</a><br><img src="https://s2.loli.net/2023/08/30/MPamvyduxrTZRkY.png" alt="image.png"><br>这个我只是定位到了原因，但不太清楚 为什么要这么做(-1)，影响也不是很大，就放在这里搁置了。</p><h3 id="Schema-不兼容"><a href="#Schema-不兼容" class="headerlink" title="Schema 不兼容"></a>Schema 不兼容</h3><p>最后发现的一个问题是我们线上某些 topic 查询数据的时候会抛出 <code>Not a record: &quot;string&quot;</code>的异常，但只是部分 topic，也排查了很久，整个源码中没有任何一个地方有这个异常。</p><p><a href="!%5B%5D(https://s2.loli.net/2023/08/30/UBl6OPGzASnfqT2.png)">https://github.com/apache/pulsar/issues/20945</a></p><p><img src="https://s2.loli.net/2023/08/30/UBl6OPGzASnfqT2.png" alt="image.png"></p><p>根本原因是生产者生成的 schema 有问题，类型已经是 JSON 了，但是 schema 却是 string，这样导致 <code>pulsar-plugin</code>  在反序列化 schema 的时候抛出了异常，由于是 pb 反序列化抛出的异常，所以源码中都搜索不到。</p><blockquote><p>没有问题的 topic 使用了正确的 schema</p></blockquote><p>后续我也在本地修复了这个问题，当抛出异常后就将 schema 降级为基本类型进行解析。<br><img src="https://s2.loli.net/2023/08/30/XZfWG2EYHpj5QJb.png" alt="image.png"></p><p>不过本质问题还是客户端使用有误，如果对 <code>schema</code> 理解不准确的话还是建议使用 <code>byte[]</code> 吧，这样至少兼容性不会有问题。<br>相关 PR：<br><a href="https://github.com/apache/pulsar/pull/20955">https://github.com/apache/pulsar/pull/20955</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Pulsar-SQL</code> 是一个非常有用的功能，只是我们使用过程中确实发现了一些问题，大部分都已经修复了；<br>希望对后续使用该功能的朋友有所帮助。<br>#Pulsar </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/30/3iz9yqfuSCn18xk.png&quot; alt=&quot;Pulsar-sql.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;为了让业务团队可以更好的跟踪自己消息的生产和消费状态，需要一个类似于表格视图的消息列表，用户可以直观的看到发送的消息；同时点击详情后也能查到消息的整个轨迹。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 消息列表&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/02/l9uvSnqAOxfPer7.png&quot; alt=&quot;20230802234405.png&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="SQL" scheme="http://crossoverjie.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>VictoriaLogs：一款超低占用的 ElasticSearch 替代方案</title>
    <link href="http://crossoverjie.top/2023/08/23/ob/VictoriaLogs-Intro/"/>
    <id>http://crossoverjie.top/2023/08/23/ob/VictoriaLogs-Intro/</id>
    <published>2023-08-23T07:46:25.000Z</published>
    <updated>2023-09-15T18:42:21.017Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/23/t5soejn8vw1aZil.png" alt="image.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间我们想实现 <code>Pulsar</code> 消息的追踪流程，追踪实现的效果图如下：<br><img src="https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png" alt="image.png"></p><p>实现其实比较简单，其中最重要的就是如何存储消息。</p><blockquote><p>消息的读取我们是通过 Pulsar 自带的 BrokerInterceptor 实现的，对这个感兴趣的朋友后面会单独做一个分享。</p></blockquote><span id="more"></span><p>根据这里的显示内容我们大概需要存储这些信息：</p><ul><li>客户端地址</li><li>消息发布时间</li><li>分发消费者、订阅者名称</li><li>ACK 消费者、订阅者名称</li><li>消息 ID<br>最终捋了下：<br><img src="https://s2.loli.net/2023/08/23/MWbVcu6dm1NfaAB.png" alt="image.png"></li></ul><p>都以两个 <code>consumer</code> 计算：<br>一条消息占用内存：<code>140+ 535*2 + 536*2 =2282byte</code><br>存储三天：<code>TPS * 86400 * 3</code>&#x3D;<code>TPS*259200</code> 条<br>总存储：<br><code>2282*TPS*259200≈ 百GB</code></p><p>根据我们的 <code>TPS</code> 计算，三天的大概会使用到 上百 G 的存储，这样首先就排除了 <code>Redis</code> 这种内存型数据库。</p><p>同样的换成 <code>MySQL</code> 存储也不划算，因为其实这些数据并不算那么重要。</p><p>做了几个技术选型都不太满意，不是资源开销太大就是没有相关的运维经验。</p><p>后面在领导的提醒下，我们使用的 <code>VictoriaMetrics</code> 开源了一个 <code>VictoriaLogs</code>，虽然当时的版本还是 <code>0.1.0</code>，使用过他们家 Metrics 的应该都会比较信任他们的技术能力，所以就调研了一下。</p><p>具体的信息可以查看官方文档：<br><a href="https://docs.victoriametrics.com/VictoriaLogs/">https://docs.victoriametrics.com/VictoriaLogs/</a></p><p><img src="https://s2.loli.net/2023/08/23/8LDNOGEC6Aslvzn.png" alt="image.png"></p><p>简单来说就是它也是一个日志存储数据库，并且有着极低的资源占有率，相对于 <code>ElasticSearch</code> 来说内存、磁盘、CPU 都是几十倍的下降率。</p><p><img src="https://s2.loli.net/2023/08/23/U9v1HCgRDtLsdif.png" alt="image.png"></p><p>通过官方的压测对比图会发现确实在各方面对 ES 都是碾压。<br><img src="https://s2.loli.net/2023/08/23/3Epxdzie8q5tVmY.png" alt="image.png"></p><p>官方宣传的第一反应是不能全信，于是我自己压测了一下，果然 CPU 内存 磁盘的占用都是极低的。</p><blockquote><p> 同时也发现运维部署确实简单，直接一个 helm install 就搞定，就是一个二进制文件，不会依赖第二个组件。</p></blockquote><p>按照刚才同样的数据存储三天，只需要不到 6G 的磁盘空间，我们生产环境已经平稳运行一段时间了。<br><img src="https://s2.loli.net/2023/08/23/kzrxA89EeNnQ7Ro.png" alt="image.png"><br>因为我们是批量写入数据的，所以在最高峰 20K 的 <code>TPS</code> 下 <code>CPU</code> 使用不到 0.1 核，内存使用最高 <code>120M</code>，这点确实是对 ES 碾压了。</p><p><img src="https://s2.loli.net/2023/08/23/wn2BduNX63PyYV9.png" alt="image.png"><br>磁盘占用也是非常少。</p><p>这些有点得归功于它有些的压缩、编解码算法，以及 <code>Golang</code>  带来的相对于 <code>Java</code> 的极低资源占用。</p><h1 id="还存在的问题"><a href="#还存在的问题" class="headerlink" title="还存在的问题"></a>还存在的问题</h1><p>如果一切都这么完美的话那 <code>VictoriaLogs</code>  确实也太变态了， 自然他也有一些不太完美的地方。</p><h2 id="分词功能有限"><a href="#分词功能有限" class="headerlink" title="分词功能有限"></a>分词功能有限</h2><p>首先第一个是分词功能有限，只能做简单的搜索，无法做到类似于 ES 的各种分词，插件当然也别想了。</p><h2 id="不支持集群"><a href="#不支持集群" class="headerlink" title="不支持集群"></a>不支持集群</h2><p>当前版本不支持集群部署，也就是无法横向扩展了；不过幸好他的的单机性能已经非常强了。</p><p>这也是目前阶段部署简单的原因。</p><h2 id="过期时间无法混用"><a href="#过期时间无法混用" class="headerlink" title="过期时间无法混用"></a>过期时间无法混用</h2><p><code>VictoriaLogs</code> 支持为数据配置过期时间自动删除，有点类似于 Redis，它会在后台启动一个协程定期判断数据是否过期，但只能对所有数据统一设置。</p><p>比如我想在 <code>VictoriaLogs</code> 中存放两种不同类型的数据，同时他们的过期删除时间也不相同；比如一个是三天删除，一个是三月后删除。</p><p>这样的需求目前是无法实现的，只能部署两个 <code>VictoriaLogs</code>.</p><h2 id="默认无法查询所有字段"><a href="#默认无法查询所有字段" class="headerlink" title="默认无法查询所有字段"></a>默认无法查询所有字段</h2><p><img src="https://s2.loli.net/2023/08/24/2Wk6VUXQoEYvZJ1.png" alt="image.png"></p><p>由于 <code>VictoriaLogs</code>  可以存储非结构化数据，默认情况下只能查询内置的三个字段，我们自定义的字段目前没法自动查询，需要我们手动指定。</p><p>这个倒不是致命问题，只是使用起来稍微麻烦一些；社区也有一些反馈，相信不久就会优化该功能。<br><img src="https://s2.loli.net/2023/08/24/XYxz8tTDmw6arf9.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/24/pgQCPsLvXfMc7nF.png" alt="image.png"></p><ul><li><a href="https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4780">https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4780</a></li><li><a href="https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4513">https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4513</a></li></ul><h2 id="没有官方-SDK"><a href="#没有官方-SDK" class="headerlink" title="没有官方 SDK"></a>没有官方 SDK</h2><p><img src="https://s2.loli.net/2023/08/24/bXPKRIy7Ojf1elE.png" alt="image.png"></p><p>这也是个有了更好的一个功能，目前只能根据 REST API 自己编写。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当前我们只用来存储 <code>Pulsar</code> 链路追踪数据，目前看来非常稳定，各方面资源占用极少；所以后续我们会陆续讲一些日志类型的数据迁移过来，比如审计日志啥的。</p><p>之后再逐步完善功能后，甚至可以将所有应用存放在 <code>ElasticSeach</code> 中的日志也迁移过来，这样确实能省下不少资源。</p><p>总得来说 <code>VictoriaLogs</code>  资源占用极少，如果只是拿来存储日志相关的数据，没有很强的分词需求那它将非常合适。</p><p>截止到目前最新版也才 <code>0.3.0</code> 还有很大的进步空间，有类似需求的可以持续关注。<br>#Blog #Vlogs #CloudNative </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/23/t5soejn8vw1aZil.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间我们想实现 &lt;code&gt;Pulsar&lt;/code&gt; 消息的追踪流程，追踪实现的效果图如下：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;实现其实比较简单，其中最重要的就是如何存储消息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;消息的读取我们是通过 Pulsar 自带的 BrokerInterceptor 实现的，对这个感兴趣的朋友后面会单独做一个分享。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="VictoriaLogs" scheme="http://crossoverjie.top/categories/VictoriaLogs/"/>
    
    
    <category term="CloudNative" scheme="http://crossoverjie.top/tags/CloudNative/"/>
    
  </entry>
  
  <entry>
    <title>k8s 常见面试题 01</title>
    <link href="http://crossoverjie.top/2023/08/17/ob/k8s-question-01/"/>
    <id>http://crossoverjie.top/2023/08/17/ob/k8s-question-01/</id>
    <published>2023-08-17T14:33:43.000Z</published>
    <updated>2023-09-15T18:42:21.018Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/17/hnWciw54ml6oPdg.jpg"></p><p>前段时间在这个视频中分享了 <a href="https://github.com/bregman-arie/devops-exercises">https://github.com/bregman-arie/devops-exercises</a> 这个知识仓库。</p><iframe src="//player.bilibili.com/player.html?aid=532004472&bvid=BV1Wu411n7U7&cid=1227759877&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>这次继续分享里面的内容，本次主要以 k8s 相关的问题为主。</p><span id="more"></span><h2 id="k8s-是什么，为什么企业选择使用它"><a href="#k8s-是什么，为什么企业选择使用它" class="headerlink" title="k8s 是什么，为什么企业选择使用它"></a>k8s 是什么，为什么企业选择使用它</h2><p>k8s 是一个开源应用，给用户提供了管理、部署、扩展容器的能力，以下几个例子更容易理解：</p><ul><li>你可以将容器运行在不同的机器或节点中，并且可以将一些变化同步给这些容器，简单来说我们只需要编写 <code>yaml</code> 文件，告诉 <code>k8s</code> 我的预期是什么，其中同步变化的过程全部都交给 k8s 去完成。<blockquote><p>其实就是我们常说的声明式 API</p></blockquote></li><li>第二个特点刚才已经提到了，它可以帮我们一键管理多个容器，同步所有的变更。</li><li>可以根据当前的负载调整应用的副本数，负载高就新创建几个应用实例，低就降低几个，这个可以手动或自动完成。</li></ul><h2 id="什么时候使用或者不使用-k8s"><a href="#什么时候使用或者不使用-k8s" class="headerlink" title="什么时候使用或者不使用 k8s"></a>什么时候使用或者不使用 k8s</h2><ul><li>如果主要还是使用物理机这种低级别的基础设施的话，不太建议使用 <code>k8s</code>，这种情况通常是比较传统的业务，没有必要使用 <code>k8s</code>。</li><li>第二种情况是如果是小团队，或者容器规模较小时也不建议使用，除非你想使用 k8s 的滚动发布和自扩容能力，<blockquote><p>不过这些功能运维自己写工具也能实现。</p></blockquote></li></ul><h2 id="k8s-有哪些特性"><a href="#k8s-有哪些特性" class="headerlink" title="k8s 有哪些特性"></a>k8s 有哪些特性</h2><ul><li>是自我修复，<code>k8s</code> 对容器有着健康检测，比如使用启动探针、存活探针等，或者是容器 <code>OOM</code> 后也会重启应用尝试修复。</li><li>自带负载均衡，使用 <code>service</code> 可以将流量自动负载到后续 Pod 中，如果 Pod 提供的是 http 服务这个够用了，但如果是 grpc 这样的长链接，就需要使用 istio 这类服务网格，他可以识别出协议类型，从而做到请求级别的负载均衡。</li><li><code>Operator</code> 自动运维能力：k8s 可以根据应用的运行情况自动调整当前集群的 Pod 数量、存储等，拿 <code>Pulsar</code> 举例，当流量激增后自动新增 <code>broker</code>，磁盘不足时自动扩容等。</li><li>滚动更新能力：当我们发版或者是回滚版本的时候，k8s 会等待新的容器启动之后才会将流量切回来，同时逐步停止老的实例。</li><li>水平扩展能力：可以灵活的新增或者是减少副本的数量，当然也可以自动控制。</li><li>数据加密：使用 <code>secret</code> 可以保存一些敏感的配置或者文件。</li></ul><h2 id="k8s-有着哪些对象"><a href="#k8s-有着哪些对象" class="headerlink" title="k8s 有着哪些对象"></a>k8s 有着哪些对象</h2><p>这个就是考察我们对 <code>k8s</code> 是否是熟悉了，常用的有：</p><ul><li>Pod</li><li>Service</li><li>ReplicationController</li><li>DaemonSet</li><li>namespace</li><li>ConfigMap<br>这个其实知道没有太多作用，主要还是得知道在不同场景如何使用不同的组件。</li></ul><h2 id="哪些字段是必须的"><a href="#哪些字段是必须的" class="headerlink" title="哪些字段是必须的"></a>哪些字段是必须的</h2><p>这个问题我也觉得意义不大，只要写过 <code>yaml</code> 就会知道了，<code>metadata, kind, apiVersion</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">app</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app</span></span><br></pre></td></tr></table></figure><h2 id="kubectl-是什么"><a href="#kubectl-是什么" class="headerlink" title="kubectl 是什么"></a>kubectl 是什么</h2><p>其实就是一个 k8s 的 命令行客户端。</p><h2 id="当你部署应用的时候哪些对象用的比较多"><a href="#当你部署应用的时候哪些对象用的比较多" class="headerlink" title="当你部署应用的时候哪些对象用的比较多"></a>当你部署应用的时候哪些对象用的比较多</h2><ul><li>第一个肯定是 <code>deployment</code>，这应该是最常见的部署方式。</li><li><code>service</code>: 可以将流量负载到 Pod 中。</li><li><code>Ingress</code>: 如果需要从集群外访问 Pod 就得需要 <code>Ingress</code> 然后 配合域名访问。</li></ul><h2 id="为什么没有-k-get-containers-这个命令"><a href="#为什么没有-k-get-containers-这个命令" class="headerlink" title="为什么没有 k get containers 这个命令"></a>为什么没有 <code>k get containers</code> 这个命令</h2><p>这个问题主要是看对 <code>Pod</code> 的理解，因为在 <code>k8s</code> 中 <code>Pod</code> 就是最小的单位了，如果想要访问容器可以在 Pod 中访问。</p><p>我们可以加上 <code>-c</code> 参数进入具体的容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it app -c istio-proxy</span><br></pre></td></tr></table></figure><h2 id="你认为使用使用-k8s-的最佳实践是什么"><a href="#你认为使用使用-k8s-的最佳实践是什么" class="headerlink" title="你认为使用使用 k8s 的最佳实践是什么"></a>你认为使用使用 k8s 的最佳实践是什么</h2><p>这个主要是看日常使用时有没有遇到什么坑了：</p><ul><li>第一个就是要验证 <code>yaml</code> 内容是否正确，这个确实很重要，一旦执行错了后果很严重，比如使用 helm 的时候最好岂容 <code>dry-run</code> 和 <code>debug</code>，先看看生成的 <code>yaml</code> 是否是预期想要的。<blockquote><p>helm upgrade app –dry-run –debug</p></blockquote></li><li>第二个限制资源的使用，比如 CPU 和 内存，这个也很重要，如果不设置一旦应用出现 bug 可能导致整个 k8s 集群都受到影响。</li><li>为 Pod，deployment 指定标签，用于分组。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 资源限制</span></span><br><span class="line"><span class="attr">resources:</span>  </span><br><span class="line">  <span class="attr">limits:</span>  </span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">200m</span>  </span><br><span class="line">    <span class="attr">memory:</span> <span class="string">200Mi</span>  </span><br><span class="line">  <span class="attr">requests:</span>  </span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">100m</span>  </span><br><span class="line">    <span class="attr">memory:</span> <span class="string">100Mi</span></span><br></pre></td></tr></table></figure><blockquote><p>参考来源：<a href="https://github.com/bregman-arie/devops-exercises/blob/master/topics/kubernetes/README.md#kubernetes-101">https://github.com/bregman-arie/devops-exercises/blob/master/topics/kubernetes/README.md#kubernetes-101</a></p></blockquote><p>后续部分内容也有出视频版，强烈建议大家关注我的 B 站或者是视频号：<br><img src="https://s2.loli.net/2023/08/17/joO3wpCAEMtY2yW.jpg" alt="image.png"><br><img src="https://s2.loli.net/2023/08/17/2gcNDC4M3x91Sbh.jpg" alt="image.png"></p><p>#Blog #K8s </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/17/hnWciw54ml6oPdg.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;前段时间在这个视频中分享了 &lt;a href=&quot;https://github.com/bregman-arie/devops-exercises&quot;&gt;https://github.com/bregman-arie/devops-exercises&lt;/a&gt; 这个知识仓库。&lt;/p&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=532004472&amp;bvid=BV1Wu411n7U7&amp;cid=1227759877&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;

&lt;p&gt;这次继续分享里面的内容，本次主要以 k8s 相关的问题为主。&lt;/p&gt;</summary>
    
    
    
    <category term="Interview" scheme="http://crossoverjie.top/categories/Interview/"/>
    
    
    <category term="k8s" scheme="http://crossoverjie.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>新手如何快速参与开源项目</title>
    <link href="http://crossoverjie.top/2023/08/05/ob/novice-contribute-open-source/"/>
    <id>http://crossoverjie.top/2023/08/05/ob/novice-contribute-open-source/</id>
    <published>2023-08-05T05:37:58.000Z</published>
    <updated>2023-09-15T18:42:21.019Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/05/5mXrStCDVHNxF7f.png" alt="image.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开源这件事情在软件开发领域一直是一个高频话题，我们工作中不管是使用到的工具还是第三方库都离不开开源的支持。</p><p>近期由于工作的原因，我需要经常和 <code>Apache Pulsar</code> 社区沟通，同时也会将日常碰到的问题反馈给社区，包括一些 <code>bug</code> ，一些我能修的也是顺带就提了一些 <code>PR</code>。</p><span id="more"></span><p>之前或多或少我也参与过其他的开源社区，但和现在的还是有些许的不同：</p><ul><li>以前我更多的是个人开源项目，偶尔也会有其他开发者向我的仓库贡献代码。</li><li>也参与过其他个人作者或者是社区性质的项目，但流程上没有那么正规或者是<code>标准</code>。</li></ul><p>简单来说就是以前就是小打小闹，<code>Pulsar</code> 毕竟是 <code>Apache</code> 社区的顶级项目，参与的整个流程要求也会比较复杂，当然学到的知识也会更多。</p><p><img src="https://s2.loli.net/2023/08/05/uSRKlvh8q4sTpWj.png" alt="image.png"></p><p><img src="https://s2.loli.net/2023/08/05/DJm145yigIhEvwe.png" alt="image.png"><br>这半年时间大大小小提了十几个 PR ，也逐渐捋清楚了一些上手的方法和套路，所以如果你也想参与开源，但苦于不知道如何入门，看完后希望对你有所帮助。</p><h1 id="为什么参与开源"><a href="#为什么参与开源" class="headerlink" title="为什么参与开源"></a>为什么参与开源</h1><p>首先还是来聊聊参与开源的好处，了解之后也许会让你有路转粉。</p><p>首先最明显的一点就是让你对贡献的这个项目更加深入的了解，我们常常都在面试的时候被问到对 XX 框架的熟悉程度，哪怕你在简历里写的天花乱坠也没有是这个项目  <code>Contributor</code> 更具有说服力。</p><p>其次是沟通交流能力也会得到锻炼，开源社区往往都是以 <code>github issue/PR</code>，或者是 <code>Mailing List</code> 的方式沟通交流，这样的沟通方式和我们常用的微信、QQ 这类及时通讯工具有着本质的区别。</p><p>往往需要我们有了冷静的思考加上清晰的描述才会将自己的观点发布出去，这样不自觉的就会养成自己的总结能力，这个能力对于<code>内容创意内容工作者</code>来说非常重要。</p><p>还有一个更明显的好处就是对个人的能力背书，大家常说的 <code>show me the code</code>，而 <code>GitHub</code> 就是最好的方式。</p><p>当你是某个知名开源项目的 <code>Contributor</code> 甚至是 <code>Committer/PMC</code> 就已经足够证明自己的能力了。</p><h1 id="如何参与"><a href="#如何参与" class="headerlink" title="如何参与"></a>如何参与</h1><p>如何参与呢，其实也很简单，不外乎有以下几种方式（由易到难）：</p><ul><li>一些 <code>typo</code> 类的修复。</li><li>回答社区中用户的问题。</li><li>使用过程中遇到 <code>bug</code>，直接反馈，有兴趣的话最好是自己能修复。</li><li>修复现有 <code>issue</code> 列表中未解决的 <code>bug</code>。</li><li>软件不具备自己需要的功能时提交 <code>feature</code> 提案并实现。</li></ul><p>不管是哪种方式我的建议是在准备贡献之前都应该先看看官方提供的贡献指南，通常在官网就能查看。</p><blockquote><p>即便是最简单的修复 typo，因为越是专业的项目每个 PR 的合并都是严谨的，提前了解后可以避免犯一些基本错误从而影响积极性。</p></blockquote><p>这里我以 <code>Pulsar</code> 为例：<br><img src="https://s2.loli.net/2023/08/05/8TGyjSXChsaoPc6.png" alt="image.png"><br>官网有着详细的贡献指南，包括环境搭建、代码约定、<code>PR/git commit</code> 语义等各种规范。</p><p>这里我重点强调 PR 的语义，一个好的 PR 规范更容易引起社区成员的注意，毕竟我们每一次提交都需要 <code>Committer</code> 的同意才能合并。</p><p><img src="https://s2.loli.net/2023/08/05/gfbEBjc4dXVLPtw.png" alt="image.png"><br>还是以 <code>Pulsar</code> 为例，在提交 PR 前一定得先看看这里的规范要求，不然很可能第一步就会吃瘪。</p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><p>下面讲讲贡献过程中可能会碰到的问题。</p><p>在上面讲到的难度排序中将修复个人 issue 排在了其他 issue 之前了，这是因为往往对自己提交的 bug 更熟悉，而社区其他人反馈的问题大概率会被老手认领。</p><p>加上自己也不熟悉，可能在自己研究复现的过程中就把自己劝退了。</p><h3 id="认领-issue"><a href="#认领-issue" class="headerlink" title="认领 issue"></a>认领 issue</h3><p>这里还有个小技巧，当我们准备修复一个不是自己提交的 issue 时，最好是在评论区让 <code>Committer</code> 将这个任务分配给你，这样社区成员就不会做重复工作了。</p><p><img src="https://s2.loli.net/2023/08/05/KBh1HRd8EyziuQP.png" alt="image.png"><br>类似于这样。</p><p>同时我们在查找可以修复的 <code>issue</code> 时也要注意这个 issue 有没有被认领以及是否有 PR 关联。</p><p><img src="https://s2.loli.net/2023/08/05/pOPybK7lmX1v8oU.png" alt="image.png"></p><p>有时候 <code>issue</code> 并没有被指定但也有相关 <code>PR</code> 在处理该问题了，这时我们就可以过滤掉这个 <code>issue</code>。</p><h3 id="help-want"><a href="#help-want" class="headerlink" title="help want"></a>help want</h3><p><img src="https://s2.loli.net/2023/08/05/QMwDlTWd3iFPU7c.png" alt="image.png"><br>也可以找找带有  <code>help want</code> 标签的 <code>issue</code>，这类问题往往会相对简单，修复起来也更容易。</p><h3 id="社区反馈较慢"><a href="#社区反馈较慢" class="headerlink" title="社区反馈较慢"></a>社区反馈较慢</h3><p>还有一个比较常见的问题是自己提交的 issue 或者是 PR 迟迟没有人处理。</p><p>我们可以先看看这个 issue 对应的代码最近主要是哪些人在维护，这个在 IDE 中配合 <code>GitToolBox</code> 插件就很容易看出来。</p><p><img src="https://s2.loli.net/2023/08/05/ojErZnigXbqFvam.png" alt="image.png"><br>后面的 ID 往往是 <code>PR</code> 号，我们可以通过这个 <code>PR</code> 找到对应的作者，然后尝试在 <code>issue</code> 评论区艾特对方。</p><p>如果依然没有回复，那我们也可以给开发组发送邮件。<br><img src="https://s2.loli.net/2023/08/05/SuT5Fb4wG2BnrV1.png" alt="image.png"><br>如果还是没有回复，比如我这个😂</p><p>那也还有一个办法，就是尝试在社交媒体（GitHub 首页、技术群）上找到 Committer 的微信，直接私聊的方式让对方帮忙推进。<br><img src="https://s2.loli.net/2023/08/05/J8r6lBbhMgziFGv.png" alt="image.png"></p><p>当然也有一些项目长期没有维护了，这种 PR 要做好心里准备，很有可能对方不会理你；这点在国内某个企业的开源项目中比较常见。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说想要做好开源得有耐心和长期坚持，同时给自己带来的好处也是物超所值的，<code>Apache</code> 这类专业的社区我也才参与了半年，后续也会长期坚持下去，也希望哪天可以积累到成为 <code>Committer</code> 后再和大家分享。</p><p>#Pulsar #OpenSource</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/05/5mXrStCDVHNxF7f.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;开源这件事情在软件开发领域一直是一个高频话题，我们工作中不管是使用到的工具还是第三方库都离不开开源的支持。&lt;/p&gt;
&lt;p&gt;近期由于工作的原因，我需要经常和 &lt;code&gt;Apache Pulsar&lt;/code&gt; 社区沟通，同时也会将日常碰到的问题反馈给社区，包括一些 &lt;code&gt;bug&lt;/code&gt; ，一些我能修的也是顺带就提了一些 &lt;code&gt;PR&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenSource" scheme="http://crossoverjie.top/categories/OpenSource/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>从 Pulsar Client 的原理到它的监控面板</title>
    <link href="http://crossoverjie.top/2023/08/03/ob/Pulsar-Client/"/>
    <id>http://crossoverjie.top/2023/08/03/ob/Pulsar-Client/</id>
    <published>2023-08-03T03:47:52.000Z</published>
    <updated>2023-09-15T18:42:21.017Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/02/GipDPSlbycQxqFd.png" alt="image.png"></p><p>#Blog #Pulsar </p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间业务团队偶尔会碰到一些 Pulsar 使用的问题，比如消息阻塞不消费了、生产者消息发送缓慢等各种问题。</p><p>虽然我们有个监控页面可以根据 topic 维度查看他的发送状态，比如速率、流量、消费状态等信息。</p><span id="more"></span><p><img src="https://s2.loli.net/2023/08/02/UNZVawH4QYSu3Ko.png" alt="image.png"></p><p>但也有几个问题：</p><ul><li>无法在应用维度查看他所依赖的所有  topic 的各种状态。</li><li>监控的信息还不够，比如发送&#x2F;消费延迟、发送&#x2F;消费失败等数据。</li></ul><p>总之就是缺少一个全局的监控视角，通过这些指标可以很方便的分析出当时的运行情况。</p><p>基于这个需求经过一段时间的折腾，现在已经上线使用几个月，目前比较稳定，效果图如下：<br><img src="https://s2.loli.net/2023/08/02/byv4RDZnruSjo9h.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/TtufOpwHB86PFhK.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/d21IaNzbFQpnrkA.png" alt="image.png"></p><p>现在就可以在每个应用的监控面板里看到自己使用了哪些 topic，分别的生产消费情况如何。</p><h1 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h1><p>要实现这些功能就得在应用的 <code>metrics</code> 中加入相关的监控信息，但官方的 Java client 是没有暴露出这些指标的。</p><p><img src="https://s2.loli.net/2023/08/02/DlfkQo1Lmt8J7Iq.png" alt="image.png"></p><blockquote><p>但 pulsar-client-go 是自带了这些指标的</p></blockquote><p>由于 <code>SDK</code> 不支持所以只能自己想办法实现了，为此其实有两种实现方案：</p><ul><li>魔改 <code>Java client</code>，在需要监控的地方手动埋点指标。</li><li>由于我们使用了 <code>SkyWalking</code>，所以可以编写插件，以 <code>agent</code> 的方式获取数据、埋点指标。</li></ul><p>不过第一种方案有以下一些问题：</p><ul><li>需要自己维护一个代码分支，还需要定期和官方保持一致，难免会出现代码冲突。</li><li>需要推动业务方进行依赖升级，线上有着几百个应用，推动起来时间太慢。</li></ul><p>第二种方案的好处就不言而喻了：</p><ul><li>升级无感知，只需要在我们的基础镜像中加上插件即可。</li><li>Java client 的版本也更容易统一。</li></ul><h2 id="Client-原理"><a href="#Client-原理" class="headerlink" title="Client 原理"></a>Client 原理</h2><p>但其实不管是哪种方案我们都得熟悉 Java Client 的实现原理，才能知道哪些数据是我们需要重点关注的，可以帮助我们更好的定位问题。</p><p><img src="https://s2.loli.net/2023/08/02/vweWVR8fkJgrSMI.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/S2DNUb768rJRMLm.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/8Byvq4LXtACoIg5.png" alt="image.png"></p><blockquote><p>本文重点不在于此，具体代码就不仔细分析了。</p></blockquote><p>从上图可以看出，如果我们想要监控消费是否存在阻塞的情况，这几个内部队列是需要重点监控的，一旦他们出现堆积，那就会出现消费阻塞。</p><p>其实这些数据都可以通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.apache.pulsar.client.api.ProducerStats</span><br><span class="line">org.apache.pulsar.client.api.ConsumerStats</span><br></pre></td></tr></table></figure><p>这两个接口获取到生产者和消费者的大部分指标，只是这里还有一个小插曲。</p><p>那就是在获取消费者队列大小的时候，获取到的数据一直为空。</p><p>最终经过源码排查，原来是我们大量使用的 <code>messageListener</code> 在获取队列大小时有 bug，导致获取到的数据一直都为 0.</p><p>相关的 issue 和 PR 可以在这两个链接查看，问题原因和修复过程都有具体描述：<br><a href="https://github.com/apache/pulsar/issues/20076">https://github.com/apache/pulsar/issues/20076</a><br><a href="https://github.com/apache/pulsar/pull/20245">https://github.com/apache/pulsar/pull/20245</a></p><blockquote><p>但这个修复得在新版本才能使用，就导致我们现在的监控页面一直显示为空。</p></blockquote><h1 id="开发-SkyWalking-插件"><a href="#开发-SkyWalking-插件" class="headerlink" title="开发 SkyWalking 插件"></a>开发 SkyWalking 插件</h1><p>然后就是开发一个 <code>SkyWalking</code> 的插件了，其实直接使用 SW 开发插件是上手 <code>Java-Agent</code> 比较快的方式。</p><p><code>SW</code> 的 SDK 封装了许多 <code>agent</code> 原生接口，使得开发起来非常容易；当然缺点也有，就是得集成整个 <code>SW</code> 的 <code>agent</code>。</p><p>这里我简单介绍下这个插件的运行流程：<br><img src="https://s2.loli.net/2023/08/02/tW8QSqdU1yZf25A.png" alt="image.png"></p><ul><li>在创建和删除 consumer 的时候维护 consumerPool</li><li>启动一个定时任务，定期从这些 consumer 中获取指标数据。<br><img src="https://s2.loli.net/2023/08/02/ndhi3yH7CzS9FLA.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/WtZNTClh8Y3wj1F.png" alt="image.png"></li></ul><blockquote><p>当消费多分区 topic 时，为了能唯一标志一个 consumer，所以给每个消费者都加了一个 hashcode 的 label。</p></blockquote><p>因为我们所有的 Java 技术栈都是使用的 <code>Prometheus</code> 的包来生成 <code>metrics</code> ，所以该插件也是使用该包生成的数据。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了兼容一些特殊 Java 应用没有该包时会启动报错，所以在初始化插件的时候需要检测当前 <code>classpath</code> 下是否存在该依赖。</p><p><img src="https://s2.loli.net/2023/08/02/IBwdhH9b1tc8aoE.png" alt="image.png"></p><p>这些功能 SW 已经封装好了，对我们来说也是开箱即用。</p><blockquote><p>其实 SW 插件自己也是支持 metrics 的，由于我们只是使用了它的 trace 功能，所以这里就没有使用它的 API。</p></blockquote><p>关于开发一个 SW 插件的流程也比较简单，可以参考官方文档或者是一些现成的插件源码。<br><a href="https://skywalking.apache.org/docs/skywalking-java/next/en/setup/service-agent/java-agent/java-plugin-development-guide/">https://skywalking.apache.org/docs/skywalking-java/next/en/setup/service-agent/java-agent/java-plugin-development-guide/</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有了这个监控面板后，对于 Pulsar 客户端内部的一些运行情况就不再是黑盒了，还可以基于此做一些报警，比如消费堆积、发送延迟过大等。</p><p>当然仅仅只有这个面板依然是不够的，后续我们又开发了可以通过 <code>messageId</code> 查询它的整个生命周期，包括：</p><ul><li>生产者、消费者信息</li><li>消息生产时间</li><li>推送时间</li><li>ack 时间等</li></ul><p><img src="https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png" alt="image.png"></p><p>同时借助与 Pulsar-SQL 的能力，还能以列表的形式展示当前 topic 的消息列表。<br><img src="https://s2.loli.net/2023/08/02/l9uvSnqAOxfPer7.png" alt="image.png"><br>当然在实现这两个功能的同时也踩了不少坑，提了几个 PR ，后面在抽时间做具体的分享。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/02/GipDPSlbycQxqFd.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;#Blog #Pulsar &lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间业务团队偶尔会碰到一些 Pulsar 使用的问题，比如消息阻塞不消费了、生产者消息发送缓慢等各种问题。&lt;/p&gt;
&lt;p&gt;虽然我们有个监控页面可以根据 topic 维度查看他的发送状态，比如速率、流量、消费状态等信息。&lt;/p&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="Metrics" scheme="http://crossoverjie.top/tags/Metrics/"/>
    
  </entry>
  
  <entry>
    <title>使用 ChatGPT 碰到的坑</title>
    <link href="http://crossoverjie.top/2023/07/18/ob/ChatGPT-hole/"/>
    <id>http://crossoverjie.top/2023/07/18/ob/ChatGPT-hole/</id>
    <published>2023-07-18T03:47:52.000Z</published>
    <updated>2023-09-15T18:42:21.016Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/07/14/YtqXVJmfNokCwyE.png"></p><p>最近在使用 ChatGPT 的时候碰到一个小坑，因为某些特殊情况我需要使用 <code>syslog</code> 向 <code>logbeat</code> 中发送日志。</p><p>由于这是一个比较古老的协议，确实也没接触过，所以就想着让 ChatGPT 帮我生成个例子。</p><span id="more"></span><p>原本我已经在  Go  中将这个流程跑通，所以其实只需要将代码转换为 Java 就可以了，这个我还是很信任 <code>ChatGPT</code> 的；</p><blockquote><p>现在我挺多结构化数据的转换都交给了 ChatGPT，省去了不少小工具。</p></blockquote><p>于是便有了这段对话：<br><img src="https://s2.loli.net/2023/07/17/6MHlRKOtZ2rJocd.png" alt="image.png"><br><img src="https://s2.loli.net/2023/07/17/SzCGBuiN6AvR7Zo.png" alt="image.png"><br>看起来挺正常的，我那过来改改确实也能用。</p><hr><p>直到快上线的时候，我发现一些元信息丢失了，比如日志生产者的 <code>hostname, PID</code> 等，然而这个信息在 Go 却没有丢失。</p><p>于是我反复调试了之前生成的代码，依然没有找到问题。</p><p>没办法，就只有去翻翻 Go 源码，想看看最终发出去的数据长什么样子，最后看到这样几行代码：<br><img src="https://s2.loli.net/2023/07/17/kJnoR4stKwYvCg8.png"><br><img src="https://s2.loli.net/2023/07/17/tOHvgx2ZzyrAEh9.png" alt="image.png"></p><p>这样一看就很清晰了，只是按照 <code>&lt;%d&gt;%s %s %s[%d]: %s%s</code> 的格式将生成的字符串通过网络发送出去。</p><p>既然这样 Java 代码也很好写了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(hostname,port);</span><br><span class="line">socket.setKeepAlive(<span class="literal">true</span>);</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(os, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> String.format(<span class="string">&quot;&lt;%d&gt;%s %s %s[%d]: %s%s&quot;</span>, <span class="number">6</span> , rfc3164DateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()), <span class="string">&quot;test&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="number">0</span>, message, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">pw.println(format);</span><br></pre></td></tr></table></figure><p>经过测试数据终于对了。</p><p>之后我就在想这么简单的一个问题 Google 上不可能没有吧，于是直接搜索了 <code>Java syslog</code> 关键字，结果直接就有一个现成的库。<br><img src="https://s2.loli.net/2023/07/17/Fm6XBnOdxQ9PAKY.png"></p><p><img src="https://s2.loli.net/2023/07/17/c7PCjmZnboReQtp.png"></p><p>而且实现也是类似的。</p><p>我相信应该有不少朋友也有被 ChatGPT 一本正经的胡说八道误导过，至少在当前的环境下一些简单的东西我还是决定优先 <code>Google</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/07/14/YtqXVJmfNokCwyE.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在使用 ChatGPT 的时候碰到一个小坑，因为某些特殊情况我需要使用 &lt;code&gt;syslog&lt;/code&gt; 向 &lt;code&gt;logbeat&lt;/code&gt; 中发送日志。&lt;/p&gt;
&lt;p&gt;由于这是一个比较古老的协议，确实也没接触过，所以就想着让 ChatGPT 帮我生成个例子。&lt;/p&gt;</summary>
    
    
    
    <category term="ChatGPT" scheme="http://crossoverjie.top/categories/ChatGPT/"/>
    
    
    <category term="Go" scheme="http://crossoverjie.top/tags/Go/"/>
    
    <category term="Syslog" scheme="http://crossoverjie.top/tags/Syslog/"/>
    
  </entry>
  
  <entry>
    <title>Grafana 变量转义处理</title>
    <link href="http://crossoverjie.top/2023/06/26/k8s/grafana-variable/"/>
    <id>http://crossoverjie.top/2023/06/26/k8s/grafana-variable/</id>
    <published>2023-06-26T00:08:08.000Z</published>
    <updated>2023-09-15T18:42:21.015Z</updated>
    
    <content type="html"><![CDATA[<p>Grafana 是一款强大的可视化工具，不止是用于 Prometheus 做数据源，还可以集成数据库、日志等作为数据源整体使用。</p><p>最近我在配置一个监控面板，其中的数据由 Prometheus 和 MySQL 组成；简单来说就是一个指标的查询条件是从数据库中来的。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pulsar_subscription_back_log_no_delayed&#123;topic=~&quot;$topic&quot;,subscription=~&quot;$subscription&quot;&#125;</span><br></pre></td></tr></table></figure><p>其中的 topic 数据是从  MySQL 中来的，其实就是在 Grafana 声明一个变量，从数据库返回了一个列表。</p><p><img src="https://s2.loli.net/2023/06/25/OE37acurFIQjVNH.png"></p><p>因为我们的查询条件是 <code>topic=~&quot;$topic&quot;</code>是正则匹配，所以理论上应该把所有的 <code>topic</code> 关联的数据都查询出来。</p><p><img src="https://s2.loli.net/2023/06/25/WMetKBAvg24hzZk.png"></p><p>但实际情况是任何数据都查不到。</p><p>查看发出去的原始请求后才发现问题出在哪里：</p><p><img src="https://s2.loli.net/2023/06/25/AUXs9lnHoYMQjhO.png"></p><p>原来是选择所有 topic 后 grafana 会~~~~自动对参数转义，这个我查了好多资料包括咨询 ChatGPT 都没有得到解决。</p><p>经过多次测试，发现只要开启多选 grafana 就会自动转义。<br><img src="https://s2.loli.net/2023/06/25/ao51AysPEeiTQNr.png"></p><p>最后我只能想到一个不需要生成多行记录的办法：将所有数据合并成一条记录。</p><p><img src="https://s2.loli.net/2023/06/25/o7Xaf3NKD1rystn.png"></p><p>这样的话就只会生成一条数据，其中包含了所有的 topic，也就避免了被转义。</p><blockquote><p>SQL 中的 CONCAT 函数其实我也不知道怎么使用，还是 ChatGPT 告诉我的。</p></blockquote><p><img src="https://s2.loli.net/2023/06/25/InPYWyiqAL1xRfK.png"></p><p>最后便能完美的查询出数据了。</p><p>有碰到类似问题的朋友可以尝试这个方法，我估计用到这个场景的并不多，不然 ChatGPT 也不会不知道。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Grafana 是一款强大的可视化工具，不止是用于 Prometheus 做数据源，还可以集成数据库、日志等作为数据源整体使用。&lt;/p&gt;
&lt;p&gt;最近我在配置一个监控面板，其中的数据由 Prometheus 和 MySQL 组成；简单来说就是一个指标的查询条件是从数据库中来的。&lt;/p&gt;</summary>
    
    
    
    <category term="cloudnative" scheme="http://crossoverjie.top/categories/cloudnative/"/>
    
    
    <category term="Grafana" scheme="http://crossoverjie.top/tags/Grafana/"/>
    
  </entry>
  
  <entry>
    <title>在这个大环境下我是如何找工作的</title>
    <link href="http://crossoverjie.top/2023/06/20/personal/find-job-experience/"/>
    <id>http://crossoverjie.top/2023/06/20/personal/find-job-experience/</id>
    <published>2023-06-19T17:10:12.000Z</published>
    <updated>2023-09-15T18:42:20.879Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/06/19/SQP9LxtXNhGwyev.png"><br>蛮久没更新了，本次我想聊聊找工作的事情，相信大家都能感受到从去年开始到现在市场是一天比一天差，特别是在我们互联网 IT 行业。<br>已经过了 18 年之前的高速发展的红利期，能做的互联网应用几乎已经被各大公司做了个遍，现在已经进入稳定的存量市场，所以在这样的大背景下再加上全世界范围内的经济不景气我想每个人都能感受到寒意。</p><p>我还记得大约在 20 年的时候看到网上经常说的一句话：今年将是未来十年最好的一年。</p><p>由于当时我所在的公司业务发展还比较顺利，丝毫没有危机意识，对这种言论总是嗤之以鼻，直到去年国庆节附近。</p><span id="more"></span><p>虽然我们做的是海外业务，但是当时受到各方面的原因公司的业务也极速收缩（被收购，资本不看好），所以公司不得不进行裁员；<br>其实到我这里的时候前面已经大概有 2～3 波的优化，我们是最后一波，几乎等于是全军覆没，只留下少数的人维护现有系统。</p><p>这家公司也是我工作这么多年来少数能感受到人情味的公司，虽有不舍，但现实的残酷并不是由我们个人所决定的。</p><p>之后便开始漫长的找工作之旅，到现在也已经入职半年多了；最近看到身边朋友以及网上的一些信息，往往是坏消息多于好消息。</p><p>市场经历半年多的时间，裁员的公司反而增多，岗位也越来越少，所以到现在不管是在职还是离职的朋友或多或少都有所焦虑，我也觉得有必要分享一下我的经历。</p><h1 id="我的预期目标"><a href="#我的预期目标" class="headerlink" title="我的预期目标"></a>我的预期目标</h1><p>下面重点聊聊找工作的事情；其实刚开始得知要找工作的时候我并不是特别慌，因为当时手上有部分积蓄加上公司有 N+1 的赔偿，同时去年 10 月份的时候岗位相对于现在还是要多一些。</p><p>所以我当时的目标是花一个月的时间找一个我觉得靠谱的工作，至少能长期稳定的工作 3 年以上。</p><p>工作性质可以是纯研发或者是偏管理岗都可以，结合我个人的兴趣纯研发岗的话我希望是可以做纯技术性质的工作，相信大部分做业务研发的朋友都希望能做一些看似“高大上”的内容。<br>这一点我也不例外，所以中间件就和云相关的内容就是我的目标。</p><p>不过这点在重庆这个大洼地中很难找到对口工作，所以我的第二目标是技术 leader，或者说是核心主程之类的，毕竟考虑到 3 年后我也 30+ 了，如果能再积累几年的管理经验后续的路会更好走一些。</p><p>当然还有第三个选项就是远程，不过远程的岗位更少，大部分都是和 web3，区块链相关的工作；我对这块一直比较谨慎所以也没深入了解。</p><h1 id="找工作流水账"><a href="#找工作流水账" class="headerlink" title="找工作流水账"></a>找工作流水账</h1><p>因为我从入职这家公司到现在其实还没出来面试过，也不太知道市场行情，所以我的想法是先找几家自己不是非去不可的公司练练手。</p><blockquote><p>有一个我个人的偏好忘记讲到，因为最近的一段时间写 Go 会多一些，所以我优先看的是 Go 相关的岗位。</p></blockquote><h2 id="第一家"><a href="#第一家" class="headerlink" title="第一家"></a>第一家</h2><p>首先第一家是一个 ToB 教育行业的公司，大概的背景是在重庆新成立的研发中心，技术栈也是 Go；</p><p>我现在还记得最后一轮我问研发负责人当初为啥选 Go，他的回答是：</p><blockquote><p>Java 那种臃肿的语言我们首先就不考虑，PHP 也日落西山，未来一定会是 Go 的天下。</p></blockquote><p>由于是新成立的团队，对方发现我之前有管理相关的经验，加上面试印象，所以是期望我过去能做重庆研发 Leader。</p><p>为此还特地帮我申请了薪资调整，因为我之前干过 ToB 业务，所以我大概清楚其中的流程，这种确实得领导特批，所以最后虽然没成但依然很感谢当时的 HR 帮我去沟通。</p><h2 id="第二家"><a href="#第二家" class="headerlink" title="第二家"></a>第二家</h2><p>第二家主要是偏年轻人的 C 端产品，技术栈也是 Go；给我印象比较深的是，去到公司怎么按电梯都不知道🤣</p><blockquote><p>他们办公室在我们这里的 CBD，我长期在政府赞助的产业园里工作确实受到了小小的震撼，办公环境比较好。</p></blockquote><p>当然面试过程给我留下的印象依然非常深刻，我现在依然记得我坐下后面试官也就是 CTO 给我说的第一句话：</p><blockquote><p>我看过你的简历后就决定今天咱们不聊技术话题了，直接聊聊公司层面和业务上是否感兴趣，以及解答我的疑虑，因为我已经看过你写的很多博客和 GitHub，技术能力方面比较放心。</p></blockquote><p>之后就是常规流程，聊聊公司情况个人意愿等。</p><p>最后我也问了为什么选 Go，这位 CTO 给我的回答和上一家差不多😂</p><p>虽然最终也没能去成，但也非常感谢这位 CTO，他是我碰到为数不多会在面试前认真看你的简历，博客和 GitHub 都会真的点进去仔细阅读👍🏼。</p><blockquote><p>其实这两家我都没怎么讲技术细节，因为确实没怎么聊这部分内容；这时就突出维护自己的技术博客和 GitHub 的优势了，技术博客我从 16 年到现在写了大约 170 篇，GitHub 上开源过一些高 star 项目，也参与过一些开源项目，这些都是没有大厂经历的背书，对招聘者来说也是节约他的时间。</p></blockquote><p><img src="https://s2.loli.net/2023/06/19/Hixaf5ZLTrS6EoR.png"><br><img src="https://s2.loli.net/2023/06/19/wRELfbKx5TYkB7z.png"></p><p>当然有好处自然也有“坏处”，这个后续会讲到。</p><h2 id="第三家"><a href="#第三家" class="headerlink" title="第三家"></a>第三家</h2><p>第三家是找朋友推荐的，在业界算是知名的云原生服务提供商，主要做 ToB 业务；因为主要是围绕着 k8s 社区生态做研发，所以就是纯技术的工作，面试的时候也会问一些技术细节。</p><blockquote><p>我还记得有一轮 leader 面，他说你入职后工作内容和之前完全不同，甚至数据库都不需要安装了。</p></blockquote><p>整体大概 5、6 轮，后面两轮都是 BOSS 面，几乎没有问技术问题，主要是聊聊我的个人项目。</p><p>我大概记得一些技术问题：</p><ul><li>k8s 相关的一些组件、Operator</li><li>Go 相关的放射、接口、如何动态修改类实现等等。</li><li>Java 相关就是一些常规的，主要是一些常用特性和 Go 做比较，看看对这两门语言的理解。</li></ul><p>其实这家公司是比较吸引我的，几乎就是围绕着开源社区做研发，工作中大部分时间也是在做开源项目，所以可以说是把我之前的业余爱好和工作结合起来了。</p><p>在贡献开源社区的同时还能收到公司的现金奖励，不可谓是双赢。</p><p>对我不太友好的是工作地在成都，入职后得成渝两地跑；而且在最终发 offer 的前两小时，公司突然停止 HC 了，这点确实没想到，所以阴差阳错的我也没有去成。</p><h2 id="第四家"><a href="#第四家" class="headerlink" title="第四家"></a>第四家</h2><p>第四家也就是我现在入职的公司，当时是我在招聘网站上看到的唯一一家做中间件的岗位，抱着试一试的态度我就投了。<br>面试过程也比较顺利，一轮同事面，一轮 Leader 面。</p><p>技术上也没有聊太多，后来我自己猜测大概率也和我的博客和 Github 有关。</p><hr><p>当然整个过程也有不太友好的经历，比如有一家成都的“知名”旅游公司；面试的时候那个面试官给我的感觉是压根没有看我的简历，所有的问题都是在读他的稿子，根本没有上下文联系。</p><p>还有一家更离谱，直接在招聘软件上发了一个加密相关的算法，让我解释下；因为当时我在外边逛街，所以没有注意到消息；后来加上微信后说我为什么没有回复，然后整个面试就在微信上打字进行。</p><p>其中问了一个很具体的问题，我记得好像是 MD5 的具体实现，说实话我不知道，从字里行间我感觉对方的态度并不友好，也就没有必要再聊下去；最后给我说之所以问这些，是因为看了我的博客后觉得我技术实力不错，所以对我期待较高；我只能是地铁老人看手机。</p><p>最终看来八股文确实是绕不开的，我也花了几天时间整理了 Java 和 Go 的相关资料；不过我觉得也有应对的方法。</p><p>首先得看你面试的岗位，如果是常见的业务研发，从招聘的 JD 描述其实是可以看出来的，比如有提到什么 Java 并发、锁、Spring等等，大概率是要问八股的；这个没办法，别人都在背你不背就落后一截了。</p><p>之后我建议自己平时在博客里多记录八股相关的内容，并且在简历上着重标明博客的地址，尽量让面试官先看到；这样先发制人，你想问的我已经总结好了😂。</p><p>但这个的前提是要自己长期记录，不能等到面试的时候才想起去更新，长期维护也能加深自己的印象，按照 “艾宾浩斯遗忘曲线” 进行复习。</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p><img src="https://s2.loli.net/2023/06/19/haAR4PYjzFGlde2.png"><br>这是我当时记录的面试情况，最终根据喜好程度选择了现在这家公司。</p><p>不过也有一点我现在觉得但是考虑漏了，那就是行业前景。</p><p>现在的 C 端业务真的不好做，相对好做的是一些 B 端，回款周期长，同时不太吃现金流；这样的业务相对来说活的会久一些，我现在所在的公司就是纯做 C 端，在我看来也没有形成自己的护城河，只要有人愿意砸钱随时可以把你干下去。</p><p>加上现在的资本也不敢随意投钱，公司哪天不挣钱的话首先就是考虑缩减产研的成本，所以裁员指不定就会在哪一天到来。</p><p>现在庆幸的是入职现在这家公司也没有选错，至少短期内看来不会再裁员，同时我做的事情也是比较感兴趣的；和第三家有些许类似，只是做得是内部的基础架构，也需要经常和开源社区交流。</p><h1 id="面对裁员能做的事情"><a href="#面对裁员能做的事情" class="headerlink" title="面对裁员能做的事情"></a>面对裁员能做的事情</h1><p>说到裁员，这也是我第一次碰上，只能分享为数不多的经验。</p><h2 id="避免裁员"><a href="#避免裁员" class="headerlink" title="避免裁员"></a>避免裁员</h2><p>当然第一条是尽量避免进入裁员名单，这个我最近在播客 <a href="https://www.xiaoyuzhoufm.com/episode/647d43b41672628240e2187d">作为曾经的老板，我们眼中的裁员和那些建议</a> 讲到在当下的市场情况下哪些人更容易进入裁员名单：</p><ul><li>年纪大的，这类收入不低，同时收益也没年轻人高，确实更容易进入名单。</li><li>未婚女性，这点确实有点政治不正确，但确实就是现在的事实，这个需要整个社会，政府来一起解决。</li><li>做事本本分分，没有贡献也没出啥事故。</li><li>边缘业务，也容易被优化缩减成本。</li></ul><p>那如何避免裁员呢，当然首先尽量别和以上特征重合，一些客观情况避免不了，但我们可以在第三点上主动“卷”一下，当然这个的前提是你还想在这家公司干。</p><p>还有一个方法是提前向公司告知降薪，这点可能很多人不理解，因为我们大部分人的收入都是随着跳槽越来越高的；但这些好处是否是受到前些年互联网过于热门的影响呢？</p><p>当然个人待遇是由市场决定的，现在互联网不可否认的降温了，如果你觉得各方面呆在这家公司都比出去再找一个更好，那这也不失为一个方法；除非你有信心能找到一个更好的，那就另说了。</p><h1 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h1><p>我觉得只要一家公司只要有裁员的风声传出来后，即便是没被裁，你也会处于焦虑之中；要想避免这种焦虑确实也很简单，只要有稳定的被动收入那就无所谓了。</p><p>这个确实也是说起来轻松做起来难，我最近也一直在思考能不能在工作之余做一些小的 side project，这话题就大了，只是我觉得我们程序员先天就有自己做一个产品的机会和能力，与其把生杀大权给别人，不如握在自己手里。</p><p>当然这里得提醒下，在国内的企业，大部分老板都认为签了合同你的 24 小时都是他的，所以这些业务项目最好是保持低调，同时不能影响到本职工作。</p><blockquote><p>欢迎关注作者公众号于我交流🤗。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/06/19/SQP9LxtXNhGwyev.png&quot;&gt;&lt;br&gt;蛮久没更新了，本次我想聊聊找工作的事情，相信大家都能感受到从去年开始到现在市场是一天比一天差，特别是在我们互联网 IT 行业。&lt;br&gt;已经过了 18 年之前的高速发展的红利期，能做的互联网应用几乎已经被各大公司做了个遍，现在已经进入稳定的存量市场，所以在这样的大背景下再加上全世界范围内的经济不景气我想每个人都能感受到寒意。&lt;/p&gt;
&lt;p&gt;我还记得大约在 20 年的时候看到网上经常说的一句话：今年将是未来十年最好的一年。&lt;/p&gt;
&lt;p&gt;由于当时我所在的公司业务发展还比较顺利，丝毫没有危机意识，对这种言论总是嗤之以鼻，直到去年国庆节附近。&lt;/p&gt;</summary>
    
    
    
    <category term="Interview" scheme="http://crossoverjie.top/categories/Interview/"/>
    
    <category term="Person" scheme="http://crossoverjie.top/categories/Interview/Person/"/>
    
    
  </entry>
  
  <entry>
    <title>云原生背景下如何配置 JVM 内存</title>
    <link href="http://crossoverjie.top/2023/05/15/k8s/cloudnative-java/"/>
    <id>http://crossoverjie.top/2023/05/15/k8s/cloudnative-java/</id>
    <published>2023-05-15T00:08:08.000Z</published>
    <updated>2023-09-15T18:42:20.739Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/05/12/IAxSF3oZ1j8GHbi.png" alt="image.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间业务研发反馈说是他的应用内存使用率很高，导致频繁的重启，让我排查下是怎么回事；</p><p>在这之前我也没怎么在意过这个问题，正好这次排查分析的过程做一个记录。</p><span id="more"></span><p>首先我查看了监控面板里的 Pod 监控：<br><img src="https://s2.loli.net/2023/05/14/wyYu8SI7eGprqmQ.png" alt="WeChatWorkScreenshot_ac6f8d80-bdb4-469e-af1a-b2199c9ee288.png"></p><p>发现确实是快满了，而此时去查看应用的 JVM 占用情况却只有30%左右；说明并不是应用内存满了导致 JVM 的 OOM，而是 Pod 的内存满了，导致 Pod 的内存溢出，从而被 k8s 杀掉了。</p><p>而 <code>k8s</code> 为了维持应用的副本数量就得重启一个 Pod，所以看起来就是应用运行一段时间后就被重启。</p><hr><p><img src="https://s2.loli.net/2023/05/14/Lhkjys1TEQUKV86.png" alt="WeChatWorkScreenshot_6213e2f8-c429-4d33-acdd-e639275dd92b.png"><br>而这个应用配置的是 JVM 8G，容器申请的内存是16G，所以 Pod 的内存占用看起来也就 50% 左右。</p><h1 id="容器的原理"><a href="#容器的原理" class="headerlink" title="容器的原理"></a>容器的原理</h1><p>在解决这个问题之前还是先简单了解下容器的运行原理，因为在 k8s 中所有的应用都是运行在容器中的，而容器本质上也是运行在宿主机上的一个个进程而已。</p><p>但我们使用 Docker 的时候会感觉每个容器启动的应用之间互不干扰，从文件系统、网络、CPU、内存这些都能完全隔离开来，就像两个运行在不同的服务器中的应用。</p><p>其实这一点也不是啥黑科技，Linux 早就支持 2.6.x 的版本就已经支持 <code>namespace</code> 隔离了，使用 <code>namespace</code> 可以将两个进程完全隔离。</p><p>仅仅将资源隔离还不够，还需要限制对资源的使用，比如 CPU、内存、磁盘、带宽这些也得做限制；这点也可以使用 <code>cgroups</code> 进行配置。</p><p>它可以限制某个进程的资源，比如宿主机是 4 核 CPU，8G 内存，为了保护其他容器，必须给这个容器配置使用上限：1核 CPU，2G内存。</p><p><img src="https://s2.loli.net/2023/05/14/dzcHK6G8VZQuFC5.png" alt="image.png"></p><p>这张图就很清晰的表示了 <code>namespace</code>  和 <code>cgroups</code> 在容器技术中的作用，简单来说就是：</p><ul><li>namespace 负责隔离</li><li>cgroups 负责限制</li></ul><p>在 k8s 中也有对应的提现：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="number">0.1</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这个资源清单表示该应用至少需要为一个容器分配一个 0.1 核和 1024M 的资源，CPU 的最高上限为 4 个核心。</p><h1 id="不同的OOM"><a href="#不同的OOM" class="headerlink" title="不同的OOM"></a>不同的OOM</h1><p>回到本次的问题，可以确认是容器发生了 OOM 从而导致被 k8s 重启，这也是我们配置 limits 的作用。</p><blockquote><p>k8s 内存溢出导致容器退出会出现 exit code 137 的一个 event 日志。</p></blockquote><p>因为该应用的 JVM 内存配置和容器的配置大小是一样的，都是8GB，但 Java 应用还有一些非 JVM 管理的内存，比如堆外内存之类的，这样很容易就导致容器内存大小超过了限制的 8G 了，也就导致了容器内存溢出。</p><h1 id="云原生背景的优化"><a href="#云原生背景的优化" class="headerlink" title="云原生背景的优化"></a>云原生背景的优化</h1><p>因为这个应用本身使用的内存不多，所以建议将堆内存限制到 4GB，这样就避免了容器内存超限，从而解决了问题。</p><p>当然之后我们也会在应用配置栏里加上建议：推荐 JVM 的配置小于容器限制的 2&#x2F;3，预留一些内存。</p><p>其实本质上还是开发模式没有转变过来，以传统的 Java 应用开发模式甚至都不会去了解容器的内存大小，因为以前大家的应用都是部署在一个内存较大的虚拟机上，所以感知不到容器内存的限制。</p><p>从而误以为将两者画了等号，这一点可能在 Java 应用中尤为明显，毕竟多了一个 JVM；甚至在老版本的 JDK 中如果没有设置堆内存大小，无法感知到容器的内存限制，从而自动生成的 Xmx 大于了容器的内存大小，以致于 OOM。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/05/12/IAxSF3oZ1j8GHbi.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间业务研发反馈说是他的应用内存使用率很高，导致频繁的重启，让我排查下是怎么回事；&lt;/p&gt;
&lt;p&gt;在这之前我也没怎么在意过这个问题，正好这次排查分析的过程做一个记录。&lt;/p&gt;</summary>
    
    
    
    <category term="cloudnative" scheme="http://crossoverjie.top/categories/cloudnative/"/>
    
    
    <category term="Java" scheme="http://crossoverjie.top/tags/Java/"/>
    
    <category term="K8s" scheme="http://crossoverjie.top/tags/K8s/"/>
    
    <category term="JVM" scheme="http://crossoverjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>从源码彻底理解 Prometheus/VictoriaMetrics 中的 relabel_configs/metric_relabel_configs 配置</title>
    <link href="http://crossoverjie.top/2023/03/13/metrics/relabel_configs_%20metric_relabel_configs/"/>
    <id>http://crossoverjie.top/2023/03/13/metrics/relabel_configs_%20metric_relabel_configs/</id>
    <published>2023-03-13T00:08:08.000Z</published>
    <updated>2023-03-12T10:44:16.552Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/03/11/Xxp5yNTH1ASBk3Z.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近接手维护了公司的指标监控系统，之后踩到坑就没站起来过。。<br><img src="https://s2.loli.net/2023/03/11/UwBJ28ZafziRsQS.png"></p><span id="more"></span><p>本次问题的起因是我们配置了一些指标的删除策略没有生效：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">action:</span> <span class="string">drop_metrics</span></span><br><span class="line">  <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br></pre></td></tr></table></figure><p>与这两个容易引起误解的配置<code>relabel_configs/metric_relabel_configs</code>有关。</p><p>他们都是对抓取的数据进行重命名、过滤、新增、删除等操作，但应用场景却完全不同。</p><blockquote><p>我们使用了 VictoriaMetrics 替换了 Prometheus，VM 完全兼容 Prometheus ，所以本文也对 Prometheus 同样适用。</p></blockquote><h1 id="理解错误1"><a href="#理解错误1" class="headerlink" title="理解错误1"></a>理解错误1</h1><p><img src="https://s2.loli.net/2023/03/12/9oYRlCGTZaNuc5j.png" alt="image.png"><br>但这里其实是有一个错误理解的，我是通过 VM 的服务发现页面的指标响应页面查询指标的，打开之后确实能搜到需要被删除的相关指标。</p><p>但其实即便是真的删除了数据这个页面也会有数据存在，删除的数据只是不会写入 VM 的时序数据库中。</p><blockquote><p>这一点是在后续查源码时才发现；后面我配置对了依然在这里查看数据，发现还是没有删除，这个错误理解浪费了不少时间😂。</p></blockquote><h1 id="理解错误2"><a href="#理解错误2" class="headerlink" title="理解错误2"></a>理解错误2</h1><p>为了解决问题，通过 <code>drop metrics</code> 这类关键字在 VM 的官方文档中查询，最终找到一篇文章。<br><a href="https://www.robustperception.io/dropping-metrics-at-scrape-time-with-prometheus/">https://www.robustperception.io/dropping-metrics-at-scrape-time-with-prometheus/</a><br><img src="https://s2.loli.net/2023/03/12/oRQKnf7u6j3Ulq5.png"></p><p>按照这里的介绍，将删除的配置加入到 <code>metric_relabel_configs</code> 配置下，经过测试确实有效。</p><p>不过为啥将同样的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">drop_metrics</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br></pre></td></tr></table></figure><p>加入到 <code>relabel_configs</code> 未能生效呢？</p><p>估计确实容易令人误导，在文档中也找到了相关的解释：<br><a href="https://www.robustperception.io/relabel_configs-vs-metric_relabel_configs/">https://www.robustperception.io/relabel_configs-vs-metric_relabel_configs&#x2F;</a><br><img src="https://s2.loli.net/2023/03/12/xyaqKjkf85YZzeA.png"><br>这篇文章主要是表达几个重点：</p><ul><li><code>relabel_configs</code> 用于配置哪个目标需要被抓取，发生在指标抓取之前。</li><li><code>metric_relabel_configs</code> 发生在指标抓取之后，写入存储之前。</li><li>如果其中一个没生效，就换一个（这句话很容易让人犯迷糊）</li></ul><p>但说实话当时我看到这里还是一脸懵，为了彻底了解两则的区别还是看源码来的直接。</p><h2 id="阅读源码理解本质原因"><a href="#阅读源码理解本质原因" class="headerlink" title="阅读源码理解本质原因"></a>阅读源码理解本质原因</h2><h3 id="metric-relabel-configs"><a href="#metric-relabel-configs" class="headerlink" title="metric_relabel_configs"></a>metric_relabel_configs</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metric_relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">drop_metrics</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br></pre></td></tr></table></figure><p>首先看下<code>metric_relabel_configs</code>配置生效的原因。</p><p><img src="https://s2.loli.net/2023/03/12/dWA4a3kzGPIxFEX.png"></p><p><code>metric_relabel_configs</code> 配置的整体流程如上图：</p><ul><li>启动 VM 时加载配置到内存</li><li>根据配置的抓取间隔时间(<code>scrape_interval</code>)抓取数据，拿到的每一条数据都需要通过 <code>metric_relabel_configs</code> 的应用。</li><li>针对于这里的 <code>drop_metrics</code> 来说，就是判断是否需要删除掉所有的 <code>Label</code>。</li><li>如果可以匹配删除，那就不会写入存储。</li></ul><p>其中的关键代码如下：<br><img src="https://s2.loli.net/2023/03/12/ZlIKFDbhLVpx8Om.png"></p><p>这里还有一个小细节，源码里判断的 <code>action</code> 是 <code>drop</code>，而我们配置的是 <code>drop_metrics</code>，其实 <code>drop_metrics</code> 也是 drop 的一个封装而已。</p><p><img src="https://s2.loli.net/2023/03/12/2kQ9rSBsJ3IuAwm.png"><br>在解析配置的时候会进行转换。</p><p>与这个写法是等价的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">source_labels:</span> [ <span class="string">__name__</span> ]</span><br><span class="line">  <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br><span class="line">  <span class="attr">action:</span> <span class="string">drop</span></span><br></pre></td></tr></table></figure><h3 id="relabel-configs"><a href="#relabel-configs" class="headerlink" title="relabel_configs"></a>relabel_configs</h3><p>然后来看看 <code>relabel_configs</code> 没有按照预期生效的原因。</p><p><img src="https://s2.loli.net/2023/03/12/itlzeXC8DNhpQf4.png"></p><p>其实核心的应用配置就是同一份代码，只是触发点不一样。</p><p><code>relabel_configs</code> 是在应用启动的时候根据我们配置的抓取目标的数据当做数据源，所以这里的 <code>action: drop</code> 删除的是抓取目标，而不是真正的抓取数据。<br><img src="https://s2.loli.net/2023/03/12/qXbwjh5e3uRds4z.png"></p><p>而且它的目的是在应用启动的时候，用于生成抓取目标的任务，<strong>只会运行一次</strong>。</p><p>假设我这里改写为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [ <span class="string">__address__</span> ]</span><br><span class="line">      <span class="attr">regex:</span> <span class="string">&#x27;192.xx.xx.xx:443&#x27;</span></span><br><span class="line">      <span class="attr">action:</span> <span class="string">drop</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/12/SfJnMP547ltQohW.png"><br>那么我这个抓取任务就会被删除掉，而不是删除这个指标了。</p><p>因此之前我在这里配置的是一些业务指标 <code>regex: &quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</code>，在所有元数据里自然是没有任何一个可以匹配了，所以也就无事发生。</p><blockquote><p>元数据都是以 <code>__</code> 开头。</p></blockquote><hr><p>其实 VM 也有提供一个 Debug 页面用于调试 <code>relabel_configs</code>，但如果知道怎么用这个调试页面其实也理解了他的运行原理😂<br><img src="https://s2.loli.net/2023/03/12/q8KAwpOsBMIEXT3.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://www.robustperception.io/relabelling-can-discard-targets-timeseries-and-alerts/">https://www.robustperception.io/relabelling-can-discard-targets-timeseries-and-alerts/</a> </p><p><img src="https://s2.loli.net/2023/03/12/lJsntMyoCruRYi7.png"><br>后面我查到这篇文章也有相关解释，理解了两者的区别后再看这里的分析会更加容易理解。</p><p>总的来说：</p><ul><li><code>relabel_configs</code> 用于对抓取目标元数据的增删改；如果删除后连后续的抓取任务也会被取消。</li><li><code>metric_relabel_configs</code> 用于对抓取到的数据增删改，对于不需要的业务指标可以在这里配置。</li></ul><p>也就是前文讲到的 <code>relabel_configs</code> 应用于指标抓取前，<code>metric_relabel_configs</code> 应用于指标抓取后。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/03/11/Xxp5yNTH1ASBk3Z.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近接手维护了公司的指标监控系统，之后踩到坑就没站起来过。。&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/03/11/UwBJ28ZafziRsQS.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="metrics" scheme="http://crossoverjie.top/categories/metrics/"/>
    
    
    <category term="K8s" scheme="http://crossoverjie.top/tags/K8s/"/>
    
    <category term="Prometheus" scheme="http://crossoverjie.top/tags/Prometheus/"/>
    
    <category term="VictoriaMetrics" scheme="http://crossoverjie.top/tags/VictoriaMetrics/"/>
    
  </entry>
  
  <entry>
    <title>通过 Pulsar 源码彻底解决重复消费问题</title>
    <link href="http://crossoverjie.top/2023/02/27/pulsar/pulsar-repeat-consume/"/>
    <id>http://crossoverjie.top/2023/02/27/pulsar/pulsar-repeat-consume/</id>
    <published>2023-02-27T00:08:08.000Z</published>
    <updated>2023-02-26T13:42:52.831Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/02/26/Oz94bQasM2Einok.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近真是和 <code>Pulsar</code> 杠上了，业务团队反馈说是线上有个应用消息重复消费。</p><p><img src="https://s2.loli.net/2023/02/26/c2eZuTPUvrlB1YF.png"></p><p>而且在测试环境是可以稳定复现的，根据经验来看一般能稳定复现的都比较好解决。</p><span id="more"></span><h1 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h1><p>接着便是定位问题了，根据之前的经验让业务按照这几种情况先排查一下：<br><img src="https://s2.loli.net/2023/02/26/IrvxGDQuaSt7AOE.png"></p><p>通过排查：1,2可以排除了。</p><ol><li>没有相关日志</li><li>存在异常，但最外层也捕获了，所以不管有无异常都会 ACK。</li></ol><p>第三个也在消费的入口和提交消息出计算了时间，最终发现都是在2s左右 ACK 的。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> client.newConsumer()</span><br><span class="line">        .subscriptionType(SubscriptionType.Shared)</span><br><span class="line">        .enableRetry(<span class="literal">true</span>)</span><br><span class="line">        .topic(topic)</span><br><span class="line">        .ackTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">        .subscriptionName(<span class="string">&quot;my-sub&quot;</span>)</span><br><span class="line">        .messageListener(<span class="keyword">new</span> <span class="title class_">MessageListener</span>&lt;<span class="type">byte</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@SneakyThrows</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">received</span><span class="params">(Consumer&lt;<span class="type">byte</span>[]&gt; consumer, Message&lt;<span class="type">byte</span>[]&gt; msg)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;msg_id&#123;&#125;&quot;</span>,msg.getMessageId().toString());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                consumer.acknowledge(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure><p>那这就很奇怪了，因为代码里配置的 ackTimeout 是 30s，理论上来说是不会存在超时导致消息重发的。</p><p>为了排除是否是超时引起的，直接将业务代码注释掉了，等于是消息收到后立即就 ACK，经过测试发现这样确实就没有重复消费了。</p><p>为了再次确认是不是和 ackTimeout 有关，直接将 <code>.ackTimeout(30, TimeUnit.SECONDS)</code> 注释掉后测试，发现也没有重复消费了。</p><h1 id="确认原因"><a href="#确认原因" class="headerlink" title="确认原因"></a>确认原因</h1><p>既然如此那一定是和这个配置有关了，但看代码确实没有超时，为了定位具体原因只有去看 client 的源码了。</p><p>这里简单梳理下消息的消费的流程：</p><ol><li>根据 <code>.receiverQueueSize(1000)</code> 的配置，默认情况下 broker 会直接给客户端推送 1000 条消息。</li><li>客户端将这 1000 条消息保存到内部队列中。</li><li>如果使用同步消费 <code>receive()</code> 时，本质上就是去 <code>take</code> 这个内部队列。</li><li>如果是使用的是 <code>messageListener</code> 异步消费并配置 <code>ackTimeout</code>，每当从队列里获得一条消息后便会把这条消息加入 <code>UnAckedMessageTracker</code> 内部的一个时间轮中，定时检测顶部是否存在消息，如果存在则会触发重新投递。<br>4.1 加入时间轮后，<code>异步</code>调用我们自定义的事件，这个异步操作是提交到一个无界队列中由单个线程依次排队执行（这点是这次问题的关键）</li><li>业务 ACK 的时候会从时间轮中删除消息，所以如果消息 ACK 的足够快，在第四步就不会获取到消息进行重新投递。</li></ol><p><img src="https://s2.loli.net/2023/02/26/2PuOadlU6oRqHVN.png"></p><p>整体流程如上图，代码细节如下图：<br><img src="https://s2.loli.net/2023/02/26/jMOqBUe912cdEWg.png"></p><p>所以问题的根本原因就是写入时间轮（<code>UnAckedMessageTracker</code>）开始倒计时的线程和回调业务逻辑的不是同一个线程。</p><p>如果业务执行耗时，等到消息从那个单线程的无界队列中取出来的时候很有可能已经过了 ackTimeou 的时间，从而导致了超时重发。</p><p>也就是用户所理解的 <code>ackTimeout</code> 周期（应该进入回调时候开始计时）和 SDK 实现的不一致造成的。</p><p>之后我再次确认同样的代码换为同步消费是没有问题的，不会导致重复消费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> consumer.receive();</span><br><span class="line">            log.info(</span><br><span class="line">                    <span class="string">&quot;consumer Message received: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(msg.getData()) + msg.getMessageId().toString());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            consumer.acknowledge(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看代码后发现同步代码的获取消息和加入 <code>UnAckedMessageTracker</code> 时间轮是同步的，也就不会出现超时的问题。<br><img src="https://s2.loli.net/2023/02/26/AUiDgXYO7QvINTF.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以其实 是<code>messageListener</code> 异步消费的 ackTimeout 的语义是有问题的，需要将加入 <code>UnAckedMessageTracker</code> 处移动到回调函数中同步调用。</p><p>我查看了最新的 <code>2.11.x</code> 版本的代码依然没有修复，正准备提个 PR 切换到 master 时才发现已经有相关的 PR 了，只是还没有发版。</p><p>修复的背景和思路也是类似的，具体参考：</p><p><a href="https://github.com/apache/pulsar/pull/18911">https://github.com/apache/pulsar/pull/18911</a></p><p>其实业务中并不推荐使用 ackTimeout 这个配置了，不好预估时间从而导致超时，而且我相信大部分业务配置好 <code>ackTImeout</code> 后直到后续出问题的时候才想起来要改。<br>所以干脆一开始就不要使用。</p><p>在 go 版本的 SDK 中直接废弃掉了这个参数，推荐使用 nack API 替换。</p><p><img src="https://s2.loli.net/2023/02/26/kQaZAcJi6WjNDXq.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/26/Oz94bQasM2Einok.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近真是和 &lt;code&gt;Pulsar&lt;/code&gt; 杠上了，业务团队反馈说是线上有个应用消息重复消费。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/26/c2eZuTPUvrlB1YF.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;而且在测试环境是可以稳定复现的，根据经验来看一般能稳定复现的都比较好解决。&lt;/p&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="Consumer" scheme="http://crossoverjie.top/tags/Consumer/"/>
    
  </entry>
  
  <entry>
    <title>一个诡异的 Pulsar InterruptedException 异常</title>
    <link href="http://crossoverjie.top/2023/02/23/pulsar/pulsar-interrupted/"/>
    <id>http://crossoverjie.top/2023/02/23/pulsar/pulsar-interrupted/</id>
    <published>2023-02-23T00:08:08.000Z</published>
    <updated>2023-02-22T17:11:31.775Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/02/22/mQaCJMopS1WAjVN.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><img src="https://s2.loli.net/2023/02/22/Lw3UbtiJ1GKyg6x.png"><br>今天收到业务团队反馈线上有个应用往 Pulsar 中发送消息失败了，经过日志查看得知是发送消息时候抛出了 <code>java.lang.InterruptedException</code> 异常。</p><p>和业务沟通后得知是在一个 <code>gRPC</code> 接口中触发的消息发送，大约持续了半个小时的异常后便恢复正常了，这是整个问题的背景。</p><span id="more"></span><h1 id="前置排查"><a href="#前置排查" class="headerlink" title="前置排查"></a>前置排查</h1><p>拿到该问题后首先排查下是否是共性问题，查看了其他的应用没有发现类似的异常；同时也查看了 Pulsar broker 的监控大盘，在这个时间段依然没有波动和异常；</p><p>这样可以初步排除是 Pulsar 服务端的问题。</p><p>接着便是查看应用那段时间的负载情况，从应用 QPS 到 JVM 的各个内存情况依然没发现有什么明显的变化。</p><h1 id="Pulsar-源码排查"><a href="#Pulsar-源码排查" class="headerlink" title="Pulsar 源码排查"></a>Pulsar 源码排查</h1><p>既然看起来应用本身和 Pulsar broker 都没有问题的话那就只能从异常本身来排查了。</p><p>首先第一步要得知具体使用的是 <code>Pulsar-client</code> 是版本是多少，因为业务使用的是内部基于官方 SDK 封装 <code>springboot starter</code> 所以第一步还得排查这个 <code>starter</code> 是否有影响。</p><p>通过查看源码基本排除了 <code>starter</code> 的嫌疑，里面只是简单的封装了 <code>SDK</code> 的功能而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">org.apache.pulsar.client.api.PulsarClientException: java.util.concurrent.ExecutionException: org.apache.pulsar.client.api.PulsarClientException: java.lang.InterruptedException at org.apache.pulsar.client.api.PulsarClientException.unwrap(PulsarClientException.java:<span class="number">1027</span>) at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.send(TypedMessageBuilderImpl.java:<span class="number">91</span>) at </span><br><span class="line">java.base/java.lang.Thread.run(Thread.java:<span class="number">834</span>) Caused by: java.util.concurrent.ExecutionException: org.apache.pulsar.client.api.PulsarClientException: java.lang.InterruptedException at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:<span class="number">395</span>) </span><br><span class="line">at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:<span class="number">1999</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.send(TypedMessageBuilderImpl.java:<span class="number">89</span>) ... <span class="number">49</span> common frames omitted Caused by: org.apache.pulsar.client.api.PulsarClientException: java.lang.InterruptedException </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.canEnqueueRequest(ProducerImpl.java:<span class="number">775</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.sendAsync$original$BWm7PPlZ(ProducerImpl.java:<span class="number">393</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.sendAsync$original$BWm7PPlZ$accessor$i7NYMN6i(ProducerImpl.java) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl$auxiliary$EfuVvJLT.call(Unknown Source) </span><br><span class="line">at org.apache.skywalking.apm.agent.core.plugin.interceptor.enhance.InstMethodsInter.intercept(InstMethodsInter.java:<span class="number">86</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.sendAsync(ProducerImpl.java) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.internalSendAsync(ProducerImpl.java:<span class="number">292</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.internalSendWithTxnAsync(ProducerImpl.java:<span class="number">363</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.PartitionedProducerImpl.internalSendWithTxnAsync(PartitionedProducerImpl.java:<span class="number">191</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.PartitionedProducerImpl.internalSendAsync(PartitionedProducerImpl.java:<span class="number">167</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.sendAsync(TypedMessageBuilderImpl.java:<span class="number">103</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.send(TypedMessageBuilderImpl.java:<span class="number">82</span>) ... <span class="number">49</span> common frames omitted Caused by: java.lang.InterruptedException: <span class="literal">null</span></span><br><span class="line">at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">1343</span>) </span><br><span class="line">at java.base/java.util.concurrent.Semaphore.acquire(Semaphore.java:<span class="number">318</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.canEnqueueRequest(ProducerImpl.java:<span class="number">758</span>)</span><br></pre></td></tr></table></figure><p>接下来便只能是分析堆栈了，因为 Pulsar-client 的部分实现源码是没有直接打包到依赖中的，反编译的话许多代码行数对不上，所以需要将官方的源码拉到本地，切换到对于的分支进行查看。</p><blockquote><p>这一步稍微有点麻烦，首先是代码库还挺大的，加上之前如果没有准备好 Pulsar 的开发环境的话估计会劝退一部分人；但其实大部分问题都是网络造成的，只要配置一些 Maven 镜像多试几次总会编译成功。</p></blockquote><p>我这里直接将分支切换到 <code>branch-2.8</code>。</p><p>从堆栈的顶部开始排查 <code>TypedMessageBuilderImpl.java:91</code>：<br><img src="https://s2.loli.net/2023/02/23/Q53Vm1Fkau9Yn2c.png"><br>看起来是内部异步发送消息的时候抛了异常。</p><p>接着往下看到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.canEnqueueRequest(ProducerImpl.java:<span class="number">775</span>) at</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/23/LdJspv5CfaRm3EW.png"><br>看起来是这里没错，但是代码行数明显不对；因为 2.8 这个分支也是修复过几个版本，所以中间有修改导致代码行数与最新代码对不上也正常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphore.get().acquire();</span><br></pre></td></tr></table></figure><p>不过初步来看应该是这行代码抛出的线程终端异常，这里看起来只有他最有可能了。</p><p><img src="https://s2.loli.net/2023/02/23/V3mFAuRKzgWnN5T.png"><br>为了确认是否是真的是这行代码，这个文件再往前翻了几个版本最终确认了就是这行代码没错了。</p><p>我们点开<code>java.util.concurrent.Semaphore#acquire()</code>的源码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;has its interrupted status set on entry to this method; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while waiting</span></span><br><span class="line"><span class="comment"> * for a permit,</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread&#x27;s</span></span><br><span class="line"><span class="comment"> * interrupted status is cleared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted() ||</span><br><span class="line">        (tryAcquireShared(arg) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         acquire(<span class="literal">null</span>, arg, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0L</span>) &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>通过源码会发现 <code>acquire()</code> 函数确实会响应中断，一旦检测到当前线程被中断后便会抛出 <code>InterruptedException</code> 异常。</p><h1 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h1><p>所以问题的原因基本确定了，就是在 Pulsar 的发送消息线程被中断了导致的，但为啥会被中断还需要继续排查。</p><p>我们知道线程中断是需要调用 <code>Thread.currentThread().interrupt();</code> API的，首先猜测是否 Pulsar 客户端内部有个线程中断了这个发送线程。</p><p>于是我在 <code>pulsar-client</code> 这个模块中搜索了相关代码：<br><img src="https://s2.loli.net/2023/02/23/w6USaRvMqAIjCfm.png"><br>排除掉和 producer 不相关的地方，其余所有中断线程的代码都是在有了该异常之后继续传递而已；所以初步来看 pulsar-client 内部没有主动中断的操作。</p><p>既然 Pulsar 自己没有做，那就只可能是业务做的了？</p><p>于是我在业务代码中搜索了一下：<br><img src="https://s2.loli.net/2023/02/23/lVzJPf9ZWBGmuti.png"></p><p>果然在业务代码中搜到了唯一一处中断的地方，而且通过调用关系得知这段代码是在消息发送前执行的，并且和 Pulsar 发送函数处于同一线程。</p><p>大概的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).stream().map(e -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    ).collect(Collectors.toList()).forEach(f -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> f.get();</span><br><span class="line">            log.info(<span class="string">&quot;====&quot;</span> + integer);</span><br><span class="line">            <span class="keyword">if</span> (integer==<span class="number">3</span>)&#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="type">MessageId</span> <span class="variable">send</span> <span class="operator">=</span> producer.newMessage().value(msg.getBytes()).send();</span><br></pre></td></tr></table></figure><p>执行这段代码可以完全复现同样的堆栈。</p><p>幸好中断这里还打得有日志：</p><p><img src="https://s2.loli.net/2023/02/23/nHE4WcfaKD8iqSb.png"><br><img src="https://s2.loli.net/2023/02/23/4df5ehMBwj9DyQV.png"></p><p>通过日志搜索发现异常的时间和这个中断的日志时间点完全重合，这样也就知道根本原因了。</p><p>因为业务线程和消息发送线程是同一个，在某些情况下会执行 <code>Thread.currentThread().interrupt();</code>，其实单纯执行这行函数并不会发生什么，只要没有去响应这个中断，也就是 <code>Semaphore</code> 源码中的判断了线程中断的标记：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted() ||</span><br><span class="line">        (tryAcquireShared(arg) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         acquire(<span class="literal">null</span>, arg, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0L</span>) &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但恰好这里业务中断后自己并没有去判断这个标记，导致 Pulsar 内部去判断了，最终抛出了这个异常。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以归根结底还是这里的代码不合理导致的，首先是自己中断了线程但也没使用，从而导致有被其他基础库使用的可能，所以会造成了一些不可预知的后果。</p><p>再一个是不建议在业务代码中使用 <code>Thread.currentThread().interrupt();</code> 这类代码，第一眼根本不知道是要干啥，也不易维护。</p><p>其实本质上线程中断也是线程间通信的一种手段，有这类需求完全可以换为内置的 <code>BlockQueue</code> 这类函数来实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/22/mQaCJMopS1WAjVN.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/22/Lw3UbtiJ1GKyg6x.png&quot;&gt;&lt;br&gt;今天收到业务团队反馈线上有个应用往 Pulsar 中发送消息失败了，经过日志查看得知是发送消息时候抛出了 &lt;code&gt;java.lang.InterruptedException&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;和业务沟通后得知是在一个 &lt;code&gt;gRPC&lt;/code&gt; 接口中触发的消息发送，大约持续了半个小时的异常后便恢复正常了，这是整个问题的背景。&lt;/p&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="InterruptedException" scheme="http://crossoverjie.top/tags/InterruptedException/"/>
    
  </entry>
  
  <entry>
    <title>Istio 升级后踩的坑</title>
    <link href="http://crossoverjie.top/2023/02/20/istio/istio1.12-upgrade-fix/"/>
    <id>http://crossoverjie.top/2023/02/20/istio/istio1.12-upgrade-fix/</id>
    <published>2023-02-20T00:08:08.000Z</published>
    <updated>2023-02-19T13:42:29.744Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/02/19/FwgABGdDrhR4a3j.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间我们将 istio 版本升级到 1.12 后导致现有的应用监控有部分数据丢失（页面上显示不出来）。</p><ul><li>一个是应用基础信息丢失。</li><li>再一个是应用 JVM 数据丢失。</li><li>接口维度的监控数据丢失。</li></ul><span id="more"></span><p><img src="https://s2.loli.net/2023/02/19/6eSAIF1Jcjhrp4x.png"></p><hr><p><img src="https://s2.loli.net/2023/02/19/Lyr4cSxVmutjJU6.png"></p><hr><p><img src="https://s2.loli.net/2023/02/19/aPzD9t7L1mGqiJR.png"></p><hr><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p>首先是第一个基础信息丢失的问题，页面上其实显示的是我们的一个聚合指标<code>istio_requests_total:source:rate1m</code>。</p><blockquote><p>聚合后可以将多个指标合并为一个，减少系统压力</p></blockquote><p>具体可以参考 Istio 的最佳实践 <a href="https://istio.io/latest/docs/ops/best-practices/observability/#workload-level-aggregation-via-recording-rules">Observability Best Practices</a> 有详细说明。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">groups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">istio.service.source.istio_requests_total</span></span><br><span class="line">      <span class="attr">rules:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">expr:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            sum(irate(istio_requests_total&#123;reporter=&quot;source&quot;&#125;[1m]))</span></span><br><span class="line"><span class="string">            by (</span></span><br><span class="line"><span class="string">              destination_app,</span></span><br><span class="line"><span class="string">              source_workload_namespace,</span></span><br><span class="line"><span class="string">              response_code,</span></span><br><span class="line"><span class="string">              source_app</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string"></span>          <span class="attr">record:</span> <span class="string">istio_requests_total:source:rate1m</span></span><br></pre></td></tr></table></figure><p>本质上是通过以上四个维度进行统计 <code>istio_requests_total</code>；但在升级之后查看原始数据发现丢失了 <code>destination_app, source_app</code> 这两个 tag。</p><p>至于为啥丢失，查了许久，最后在升级后的资源文件 <code>stats-filter-1.12.yaml</code> 中找到了答案:<br><img src="https://s2.loli.net/2023/02/19/B7a6sH9CYznVGUI.png"><br>升级后新增了 <code>tags_to_remove</code> 标记，将我们所需要的两个 tag 直接删掉了。</p><p>后续在当前 namespace 下重新建一个 <code>EnvoyFilter</code> 资源覆盖掉默认的便能恢复这两个 tag，修复后监控页面也显示正常了。</p><blockquote><p>EnvoyFilter 是实时生效的，并不需要重建应用 Pod。</p></blockquote><h3 id="JVM-监控"><a href="#JVM-监控" class="headerlink" title="JVM 监控"></a>JVM 监控</h3><p><code>JVM</code> 数据丢失的这个应用，直接进入 <code>Pod</code> 查看暴露出的 <code>metric</code>，发现数据都有，一切正常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;Code Cache&quot;,&#125; 1.32126784E8</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;Metaspace&quot;,&#125; 2.74250552E8</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;Compressed Class Space&quot;,&#125; 3.1766024E7</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;G1 Eden Space&quot;,&#125; 1.409286144E9</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;G1 Survivor Space&quot;,&#125; 2.01326592E8</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;G1 Old Gen&quot;,&#125; 2.583691248E9</span><br></pre></td></tr></table></figure><p>说明不是数据源的问题，那就可能是数据采集节点的问题了。</p><p>进入<code>VictoriaMetrics</code> 的 <code>target</code> 页面发现应用确实已经下线，原来是采集的端口不通导致的。</p><blockquote><p>我们使用 VictoriaMetrics 代替了 Prometheus。</p></blockquote><p><img src="https://s2.loli.net/2023/02/19/Hhj6LutlvUsycES.png"></p><p>而这个端口 15020 之前并未使用，我们使用的是另外一个自定义端口和端点来采集数据。</p><p>经过查阅发现 15020 是 istio 默认的端口：<br><img src="https://s2.loli.net/2023/02/19/LjOewSXl5IVPv6q.png"></p><p>原来在默认情况下 Istio 会为所有的数据面 Pod 加上：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">prometheus.io/path:</span> <span class="string">/stats/prometheus</span></span><br><span class="line">    <span class="attr">prometheus.io/port:</span> <span class="string">&quot;15020&quot;</span></span><br></pre></td></tr></table></figure><p>这个注解用于采集数据，由于我们是自定义的端点，所以需要修改默认行为：<br><img src="https://s2.loli.net/2023/02/19/R7v8rG6f2XixlBU.png"></p><p>在控制面将 <code>--set meshConfig.enablePrometheusMerge=false</code> 设置为 false，其实官方文档已经说明，如果不是使用的标准 <code>prometheus.io</code> 注解，需要将这个设置为 false。</p><blockquote><p>修改后需要重建应用 Pod 方能生效。</p></blockquote><p>有了 url 这个 tag 后，接口监控页也恢复了正常。</p><h3 id="接口维度"><a href="#接口维度" class="headerlink" title="接口维度"></a>接口维度</h3><p>接口维度的数据丢失和基本数据丢失的原因类似，本质上也是原始数据中缺少了 url 这个 tag，因为我们所聚合的指标使用了 url：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio.service.source.url.istio_requests_total</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">expr:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        sum(irate(istio_requests_total&#123;reporter=&quot;source&quot;&#125;[1m]))</span></span><br><span class="line"><span class="string">        by (</span></span><br><span class="line"><span class="string">          destination_app,</span></span><br><span class="line"><span class="string">          source_workload_namespace,</span></span><br><span class="line"><span class="string">          response_code,</span></span><br><span class="line"><span class="string">          source_app,</span></span><br><span class="line"><span class="string">          url</span></span><br><span class="line"><span class="string">        )</span></span><br></pre></td></tr></table></figure><p>最终参考了 <a href="https://istio.io/latest/docs/reference/config/proxy_extensions/stats/#MetricConfig">MetricConfig</a> 自定义了 URL 的tag.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;dimensions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;request.url_path&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/19/tERXzV3TI1oe7bJ.png"><br>但这也有个大前提，当我们 tag 的指标没有在默认 tag 列表中时，需要在 Deployment 或者是 Istio 控制面中全局加入我们自定义的 tag 声明。</p><p>比如这里新增了 url 的 tag，那么就需要在控制面中加入：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">meshConfig:</span></span><br><span class="line">  <span class="attr">defaultConfig:</span></span><br><span class="line">    <span class="attr">extraStatTags:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">url</span></span><br></pre></td></tr></table></figure><blockquote><p>修改了控制面后需要重新构建 Pod 后才会生效。</p></blockquote><h2 id="EnvoyFilter的问题"><a href="#EnvoyFilter的问题" class="headerlink" title="EnvoyFilter的问题"></a>EnvoyFilter的问题</h2><p>查看<a href="https://istio.io/latest/docs/reference/config/proxy_extensions/stats/#MetricConfig">MetricConfig</a>的配置后发现是可以直接去掉指标以及去掉指标中的 tag ，这个很有用，能够大大减低指标采集系统 <code>VictoriaMetrics</code> 的系统负载。</p><p>于是参考了官方的示例，去掉了一些 tag，同时还去掉了指标：<code>istio_request_messages_total</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      <span class="attr">&quot;tags_to_remove&quot;:</span> [</span><br><span class="line">        <span class="string">&quot;source_principal&quot;</span>,</span><br><span class="line">        <span class="string">&quot;source_version&quot;</span>,</span><br><span class="line">        <span class="string">&quot;destination_principal&quot;</span>,</span><br><span class="line">        <span class="string">&quot;destination_version&quot;</span>,</span><br><span class="line">        <span class="string">&quot;source_workload&quot;</span>,</span><br><span class="line">        <span class="string">&quot;source_cluster&quot;</span>,</span><br><span class="line">      ]</span><br><span class="line">&#125;<span class="string">,</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;:</span> <span class="string">&quot;istio_request_messages_total&quot;</span>,</span><br><span class="line"><span class="attr">&quot;drop&quot;:</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但并没有生效，于是换成了在 <code>v1.12</code> 中新增的 <code>Telemetry API</code>。</p><h1 id="使用-Telemetry-API"><a href="#使用-Telemetry-API" class="headerlink" title="使用 Telemetry API"></a>使用 Telemetry API</h1><p><img src="https://s2.loli.net/2023/02/19/bN4LiwQZm7rJHXW.png"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">telemetry.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Telemetry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mesh-istio-test</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># no selector specified, applies to all workloads</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">overrides:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">metric:</span> <span class="string">GRPC_REQUEST_MESSAGES</span></span><br><span class="line">            <span class="attr">mode:</span> <span class="string">CLIENT_AND_SERVER</span></span><br><span class="line">          <span class="attr">disabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>但是参考了官方文档后发现依然不能生效，<code>GRPC_REQUEST_MESSAGES</code> 所对应的 <code>istio_request_messages_total</code> 指标依然存在。</p><p>接着在我领导查看 <code>Istio</code> 源码以及相关 <a href="https://github.com/istio/istio/issues/37645">issue</a> 后发现 <code>Telemetry API</code> 和 <code>EnvoyFilter</code> 是不能同时存在的，也就是说会优先使用 <code>EnvoyFilter</code>；这也就是为什么我之前配置没有生效的原因。<br><img src="https://s2.loli.net/2023/02/19/M3uevVscNk5XOTd.png"></p><blockquote><p>后初始化 EnvoyFilter</p></blockquote><p><img src="https://s2.loli.net/2023/02/19/sbkrBdRwULSo9Yg.png"><br>正如这个 issue 中所说，需要删掉现在所有的 EnvoyFilter；删除后果然就生效了。</p><p>新的 <code>Telemetry API</code> 不但语义更加清晰，功能也一样没少，借助他我们依然可以自定义、删除指标、tag 等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">telemetry.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Telemetry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mesh-istio-telemetry-test</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">overrides:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">metric:</span> <span class="string">GRPC_RESPONSE_MESSAGES</span></span><br><span class="line">            <span class="attr">mode:</span> <span class="string">CLIENT_AND_SERVER</span></span><br><span class="line">          <span class="attr">disabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">tagOverrides:</span></span><br><span class="line">            <span class="attr">url:</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;request.url_path&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">metric:</span> <span class="string">ALL_METRICS</span></span><br><span class="line">          <span class="attr">tagOverrides:</span></span><br><span class="line">            <span class="attr">source_workload:</span></span><br><span class="line">              <span class="attr">operation:</span> <span class="string">REMOVE</span></span><br></pre></td></tr></table></figure><p>比如以上配置便可以删除掉 <code>GRPC_RESPONSE_MESSAGES</code> 指标，新增一个 url 的指标，同时在所有指标中删除了 <code>source_workload</code> 这个 tag。</p><p>借助于这一个声明文件便能满足我们多个需求。</p><h2 id="裁剪指标"><a href="#裁剪指标" class="headerlink" title="裁剪指标"></a>裁剪指标</h2><p>后续根据我们实际需求借助于 <code>Telemetry API</code> 裁剪掉了许多指标和 tag，使得指标系统负载下降了一半左右。<br><img src="https://s2.loli.net/2023/02/19/rLqd3lUTgOK9RbS.png"><br>效果相当明显。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次定位修复 <code>Istio</code> 升级后带来的指标系统问题收获巨大，之前对 Istio 一直只停留在理论阶段，只知道他可以实现传统微服务中对接口粒度的控制，完美弥补了 <code>k8s</code> 只有服务层级的粗粒度控制；</p><p>这两周下来对一个现代云原生监控系统也有了系统的认识，从 <code>App-&gt;Pod-&gt;sidecar-&gt;VictoriaMetrics(Prometheus)-&gt;Grafana</code> 这一套流程中每个环节都可能会出错；</p><p>所以学无止境吧，幸好借助公司业务场景后续还有更多机会参与实践。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/19/FwgABGdDrhR4a3j.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间我们将 istio 版本升级到 1.12 后导致现有的应用监控有部分数据丢失（页面上显示不出来）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个是应用基础信息丢失。&lt;/li&gt;
&lt;li&gt;再一个是应用 JVM 数据丢失。&lt;/li&gt;
&lt;li&gt;接口维度的监控数据丢失。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Istio" scheme="http://crossoverjie.top/categories/Istio/"/>
    
    
    <category term="K8s" scheme="http://crossoverjie.top/tags/K8s/"/>
    
    <category term="云原生" scheme="http://crossoverjie.top/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Pulsar负载均衡原理及优化</title>
    <link href="http://crossoverjie.top/2023/02/07/pulsar/pulsar-load-banance/"/>
    <id>http://crossoverjie.top/2023/02/07/pulsar/pulsar-load-banance/</id>
    <published>2023-02-07T00:12:26.000Z</published>
    <updated>2023-02-07T01:38:09.189Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/02/04/d4NqxaoulEXnr5s.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间我们在升级 Pulsar 版本的时候发现升级后最后一个节点始终没有流量。<br><img src="https://s2.loli.net/2023/02/07/ZwQ7sfVhuzb4tyv.jpg"></p><blockquote><p>虽然对业务使用没有任何影响，但负载不均会导致资源的浪费。</p></blockquote><p>和同事沟通后得知之前的升级也会出现这样的情况，最终还是人工调用 Pulsar 的 <code>admin API</code> 完成的负载均衡。</p><p>这个问题我尝试在 Google 和 Pulsar 社区都没有找到类似的，不知道是大家都没碰到还是很少升级集群。</p><blockquote><p>我之前所在的公司就是一个版本走到黑😂</p></blockquote><span id="more"></span><h1 id="Pulsar-负载均衡原理"><a href="#Pulsar-负载均衡原理" class="headerlink" title="Pulsar 负载均衡原理"></a>Pulsar 负载均衡原理</h1><p>当一个集群可以水平扩展后负载均衡就显得非常重要，根本目的是为了让每个提供服务的节点都能均匀的处理请求，不然扩容就没有意义了。</p><p>在分析这个问题的原因之前我们先看看 Pulsar 负载均衡的实现方案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Enable load balancer</span><br><span class="line">loadBalancerEnabled=true</span><br></pre></td></tr></table></figure><p>我们可以通过这个 broker 的这个配置来控制负载均衡器的开关，默认是打开。</p><p>但具体使用哪个实现类来作为负载均衡器也可以在配置文件中指定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Name of load manager to use</span><br><span class="line">loadManagerClassName=org.apache.pulsar.broker.loadbalance.impl.ModularLoadManagerImpl</span><br></pre></td></tr></table></figure><p>默认使用的是 <code>ModularLoadManagerImpl</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> LoadManager <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> PulsarService pulsar)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServiceConfiguration</span> <span class="variable">conf</span> <span class="operator">=</span> pulsar.getConfiguration();</span><br><span class="line">        <span class="comment">// Assume there is a constructor with one argument of PulsarService.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">loadManagerInstance</span> <span class="operator">=</span> Reflections.createInstance(conf.getLoadManagerClassName(),</span><br><span class="line">                Thread.currentThread().getContextClassLoader());</span><br><span class="line">        <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> LoadManager) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> (LoadManager) loadManagerInstance;</span><br><span class="line">            casted.initialize(pulsar);</span><br><span class="line">            <span class="keyword">return</span> casted;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> ModularLoadManager) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModularLoadManagerWrapper</span>((ModularLoadManager) loadManagerInstance);</span><br><span class="line">            casted.initialize(pulsar);</span><br><span class="line">            <span class="keyword">return</span> casted;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Error when trying to create load manager: &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If we failed to create a load manager, default to SimpleLoadManagerImpl.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleLoadManagerImpl</span>(pulsar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>broker</code> 启动时会从配置文件中读取配置进行加载，如果加载失败会使用 <code>SimpleLoadManagerImpl</code> 作为兜底策略。</p><p>当 broker 是一个集群时，只有 leader 节点的 broker 才会执行负载均衡器的逻辑。</p><blockquote><p>Leader 选举是通过 Zookeeper 实现的。</p></blockquote><p>默然情况下成为 Leader 节点的 broker 会每分钟读取各个 broker 的数据来判断是否有节点负载过高需要做重平衡。</p><p>而是否重平衡的判断依据是由 <code>org.apache.pulsar.broker.loadbalance.LoadSheddingStrategy</code> 接口提供的，它其实只有一个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadSheddingStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Recommend that all of the returned bundles be unloaded.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A map from all selected bundles to the brokers on which they reside.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Multimap&lt;String, String&gt; <span class="title function_">findBundlesForUnloading</span><span class="params">(LoadData loadData, ServiceConfiguration conf)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据所有 broker 的负载信息计算出一个需要被 unload 的 broker 以及 bundle。</p><p>这里解释下 unload 和 bundle 的概念：</p><ul><li><code>bundle</code> 是一批 <code>topic</code> 的抽象，将 <code>bundle</code> 和 <code>broker</code> 进行关联后客户端才能知道应当连接哪个 broker；而不是直接将 topic 与 <code>broker</code> 绑定，这样才能实现海量 topic 的管理。</li><li>unload 则是将已经与 broker 绑定的 bundle 手动解绑，从而触发负载均衡器选择一台合适的 broker 重新进行绑定；通常是整个集群负载不均的时候触发。</li></ul><h2 id="ThresholdShedder-原理"><a href="#ThresholdShedder-原理" class="headerlink" title="ThresholdShedder 原理"></a>ThresholdShedder 原理</h2><p><code>LoadSheddingStrategy</code> 接口目前有三个实现，这里以官方默认的 <code>ThresholdShedder</code> 为例：<br><img src="https://s2.loli.net/2023/02/07/9xqNPs31RtHOC2u.jpg"></p><p>它的实现算法是根据带宽、内存、流量等各个指标的权重算出每个节点的负载值，之后为整个集群计算出一个平均负载值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 阈值</span><br><span class="line">loadBalancerBrokerThresholdShedderPercentage=10</span><br></pre></td></tr></table></figure><p>当集群中有某个节点的负载值超过平均负载值达到一定程度（可配置的阈值）时，就会触发 unload，以上图为例就会将最左边节点中红色部分的 bundle 卸载掉，然后再重新计算一个合适的 broker 进行绑定。</p><blockquote><p>阈值存在的目的是为了避免频繁的 unload，从而影响客户端的连接。</p></blockquote><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>当某些 topic 的流量突然爆增的时候这种负载策略确实可以处理的很好，但在我们集群升级的情况就不一定了。</p><p>假设我这里有三个节点：</p><ul><li>broker0</li><li>broker1</li><li>broker2</li></ul><p><img src="https://s2.loli.net/2023/02/07/9fpusPqY8BmkGdl.png"><br>集群升级时会从 <code>broker2-&gt;0</code> 进行镜像替换重启，假设在升级前每个 broker 的负载值都是 10。</p><ul><li>重启 broker2 时，它所绑定的 bundle 被 broker0&#x2F;1 接管。</li><li>升级 broker1 时，它所绑定的 bundle 又被 broker0&#x2F;2 接管。</li><li>最后升级 broker0, 它所绑定的 bundle 会被broker1&#x2F;2 接管。</li></ul><p>只要在这之后没有发生流量激增到触发负载的阈值，那么当前的负载情况就会一直保留下去，也就是 <code>broker0</code> 会一直没有流量。</p><p>经过我反复测试，现象也确实如此。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./pulsar-perf monitor-brokers --connect-string pulsar-test-zookeeper:2181</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/07/nDaOlsMprJ1hCwg.png"><br>通过这个工具也可以查看各个节点的负载情况</p><h1 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h1><p>这种场景是当前 <code>ThresholdShedder</code> 所没有考虑到的，于是我在我们所使用的版本 2.10.3 的基础上做了简单的优化：<br><img src="https://s2.loli.net/2023/02/07/iRkm2FaBz4wtbG6.png"></p><ul><li>当原有逻辑走完之后也没有获取需要需要卸载的 bundle，同时也存在一个负载极低的 broker 时(<code>emptyBundle</code>)，再触发一次 bundle 查询。</li><li>按照 broker 所绑定的数量排序，选择一个数量最多的 broker 的 第一个 bundle 进行卸载。</li></ul><p>修改后打包发布，再走一遍升级流程后整个集群负载就是均衡的了。<br><img src="https://s2.loli.net/2023/02/07/oCYzJBj7xavkLub.jpg"></p><p>但其实这个方案并不严谨，第二步选择的重点是筛选出负载最高的集群中负载最高的 bundle；这里只是简单的根据数量来判断，并不够准确。</p><p>正当我准备持续优化时，鬼使神差的我想看看 master 上有人修复这个问题没，结果一看还真有人修复了；只是还没正式发版。</p><p><a href="https://github.com/apache/pulsar/pull/17456">https://github.com/apache/pulsar/pull/17456</a></p><p><img src="https://s2.loli.net/2023/02/07/7TKxPv8BfblngRc.png"></p><p>整体思路是类似的，只是筛选负载需要卸载 bundle 时是根据 bundle 自身的流量来的，这样会更加精准。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不过看社区的进度等这个优化最终能用还不知道得多久，于是我们就自己参考这个思路在管理台做了类似的功能，当升级后出现负载不均衡时人工触发一个逻辑：</p><ul><li>系统根据各个节点的负载情况计算出一个负载最高的节点和 bundle 在页面上展示。</li><li>人工二次确认是否要卸载，确认无误后进行卸载。</li></ul><p>本质上只是将上述优化的自动负载流程改为人工处理了，经过测试效果是一样的。</p><p>Pulsar 整个项目其实非常庞大，有着几十上百个模块，哪怕每次我只改动一行代码准备发布测试时都得经过漫长的编译+ Docker镜像打包+上传私服这些流程，通常需要1~2个小时；但总的来说收获还是很大的，最近也在提一些 issue 和 PR，希望后面能更深入的参与进社区。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/04/d4NqxaoulEXnr5s.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间我们在升级 Pulsar 版本的时候发现升级后最后一个节点始终没有流量。&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/07/ZwQ7sfVhuzb4tyv.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然对业务使用没有任何影响，但负载不均会导致资源的浪费。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和同事沟通后得知之前的升级也会出现这样的情况，最终还是人工调用 Pulsar 的 &lt;code&gt;admin API&lt;/code&gt; 完成的负载均衡。&lt;/p&gt;
&lt;p&gt;这个问题我尝试在 Google 和 Pulsar 社区都没有找到类似的，不知道是大家都没碰到还是很少升级集群。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我之前所在的公司就是一个版本走到黑😂&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="消息队列" scheme="http://crossoverjie.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="负载均衡" scheme="http://crossoverjie.top/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>2022 年度总结</title>
    <link href="http://crossoverjie.top/2023/01/18/annual-summary/2022/"/>
    <id>http://crossoverjie.top/2023/01/18/annual-summary/2022/</id>
    <published>2023-01-18T00:08:08.000Z</published>
    <updated>2023-01-17T13:00:54.832Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/17/C9tczrjDlwfVqvR.png"></p><p>一转眼 2022 年又过去了，不多不少距离上次写年终总结过去了 365 天；今年的艰难情况想必大家都亲身经历过了；如果要举行卖惨大会的话今年也许我能排的上号。</p><span id="more"></span><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>今年对大家影响最大的事应该都是疫情了，在年底的最后几天家里的老人还是没顶住疫情的冲击离开了，原以为成年后我已经看淡了生老病死，直到我现在敲下这几行字时才发现这么难过。</p><p>悲伤的事暂且不提，还是聊聊今年生活上的好事吧。</p><h2 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h2><p>首先是健身这个我念叨了几年的运动今年终于被我提上了议程。</p><blockquote><p>本质原因是请了私教，果然是花自己的钱才会心疼。</p></blockquote><p><img src="https://s2.loli.net/2023/01/17/ojP8sQXracSHM3u.png"><br><img src="https://s2.loli.net/2023/01/17/LWSkPHGEMf1R2UO.png"></p><p>体重也由巅峰的 75kg 降到了66kg 左右。<br><img src="https://s2.loli.net/2023/01/17/R38tM2FOocjHGxI.png"></p><iframe src="//player.bilibili.com/player.html?aid=685069016&bvid=BV1aU4y1X7Ya&cid=749168314&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>一段视频便能看出差距。</p><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>今年不记得被哪个视频安利了微软的 XGP 服务，冲动下单了 xbox，顺道集齐了御三家的全家桶。<br><img src="https://s2.loli.net/2023/01/17/DzUT7yHYm59iZ2R.jpg"></p><p>不得不说 XGP 服务是真的香，游戏也很多，我玩的最多的就是光环、地平线5、奥日这几款游戏；原以为 xbox 后续会成为我的主力机，直到几个月后我在 tb 奸商那儿购买的 XGP 服务被微软退款后我就没怎么碰了。</p><p>后面老头环上线，也是我唯一一款花钱购买的 xbox 游戏，在被老头环揉拧了几周后手残党也被劝退，一直到现在估计三个月没开过机了。</p><p>不过最近倒还喜欢上玩 Steam 上的一些独立小游戏，特别是肉鸽类型的，比如这个“吸血鬼幸存者”玩着真的非常上头。</p><p><img src="https://s2.loli.net/2023/01/17/6Y7lmhtQRMy2TiU.png"></p><p>当然今年最期待依然是那个带我入主机坑的“塞尔达传说”，恨不得现在马上快进到5月12号发售日。</p><h2 id="世界杯"><a href="#世界杯" class="headerlink" title="世界杯"></a>世界杯</h2><p>今年还有件大事那就是世界杯的召开，真没想到我还会对足球这么感兴趣；因为当时是封控在家远程工作，所以我几乎把凌晨三点场的都看完了。</p><p>那段时间因为离职心情还比较 EMO，感谢世界杯带给了我一个月的快乐时间。</p><p>当然不出意外的在世界杯期间发生了意外。</p><p><img src="https://s2.loli.net/2023/01/17/jUMOHidkxapyRbW.jpg"></p><p>大半夜睡得好好的，眼睛被我老婆的手指甲刨到了，连夜赶往医院，最后就成了“带土”的 cos 低配版。</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>经常都有大佬说三年是在一家公司的敏感时间，如果感觉不到提升那就需要适当的跳出舒适圈，其实我压根没这个打算，但生活总在你没准备好的时候推你一把。</p><p><img src="https://s2.loli.net/2023/01/17/3MGYFZ1fCvLsXBz.png"><br><img src="https://s2.loli.net/2023/01/17/qcZoD2Mr7YX1Ble.jpg"></p><p>由于不可抗力因素，我还是离开了这家我有生以来呆的最开心的一家公司；虽然有许多不舍，但江湖总会相见。</p><p><img src="https://s2.loli.net/2023/01/17/ztTP1F9ChJ23AR8.png"><br><strong>这不我微信里最活跃的依然还是那个群。</strong></p><hr><p>后面我花了一个月的时间把重庆大大小小的公司几乎都看了一遍，甚至还差点去成都工作了；最后阴差阳错的来到了现在的公司做我之前非常向往的基础架构+中间件研发，目前也比较满意。</p><blockquote><p>找工作那段时间也碰到许多有意思的和狗血的事情，年后单独分享。</p></blockquote><h1 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h1><h2 id="GScript"><a href="#GScript" class="headerlink" title="GScript"></a><a href="https://github.com/crossoverJie/gscript">GScript</a></h2><p><img src="https://s2.loli.net/2023/01/17/9O4pzlC6T2ISKkA.png"></p><p>今年个人最满意的就是恶补了编译原理的知识，顺带还做了一个<a href="https://gscript.crossoverjie.top/">脚本语言</a>；现在已经可以拿来编写网站了；也算是一个小目标达成吧。</p><p>回想起开发 gscript 的那段时间，真的是没日没夜的干，每完成一个功能就开心的飞起。</p><h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2><p><img src="https://s2.loli.net/2023/01/17/kHa4Demu15OiytE.png"><br>除此之外在来到现在这家公司后接触了大量 k8s 相关的知识点，也算是把之前学到的理论实践上了；这不昨晚上才在生产环境升级了 Pulsar，这个技能树终于点亮了一些叶子节点。</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p><img src="https://s2.loli.net/2023/01/17/q3CLIhWoM8yEtGY.png"><br><img src="https://s2.loli.net/2023/01/17/hSxHZDsEArRFow1.png"></p><p>今年的技术博客产出居然 23 篇，其中大部分都是和编译原理相关的，也是我一步步学习编译原理到实现脚本语言的过程。</p><hr><p><img src="https://s2.loli.net/2023/01/17/mEPTMByJIAKaiwX.png"><br>同时今年也养成了每日看一篇英文博客的习惯，坚持了几个月效果还是很明显的；比如以前我非常排斥看一些英文资料，要么靠一键翻译，要么就直接只看中文内容。</p><p>现在几乎没有这种排斥的感觉了，大部分英文内容也会耐心的阅读完，这点在我订阅了 Pulsar 的开发组邮件后越发明显，明显的能够知道他们在讲些什么，这点与我多年前订阅 Dubbo 社区邮件的感觉完全不同。</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>以上就是整年的流水账式的回顾，又到了经典的保留立 flag 环节。</p><ul><li>首先是健身保持，都说健身是按年算的，希望到今年四月份为期一年的时候能看到健身的痕迹。</li><li>今年好歹的出去玩一玩，比如港澳地区或是日本，念叨几年了。</li><li>工作技术上能够再提交几个 Pulsar 的 PR，最好是能融入社区；混个脸熟。</li><li>云原生和编译原理相关的继续学起来，下半年把 GScript 实现为编写型语言。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/17/C9tczrjDlwfVqvR.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;一转眼 2022 年又过去了，不多不少距离上次写年终总结过去了 365 天；今年的艰难情况想必大家都亲身经历过了；如果要举行卖惨大会的话今年也许我能排的上号。&lt;/p&gt;</summary>
    
    
    
    <category term="annual-summary" scheme="http://crossoverjie.top/categories/annual-summary/"/>
    
    
  </entry>
  
</feed>
