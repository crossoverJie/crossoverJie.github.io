<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverJie&#39;s Blog</title>
  
  <subtitle>baller</subtitle>
  <link href="http://crossoverjie.top/atom.xml" rel="self"/>
  
  <link href="http://crossoverjie.top/"/>
  <updated>2024-09-26T13:39:32.089Z</updated>
  <id>http://crossoverjie.top/</id>
  
  <author>
    <name>crossoverJie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenTelemetry 实战：从 0 到 1 编写一个 Instrumentation</title>
    <link href="http://crossoverjie.top/2024/09/26/ob/OpenTelemetry-create-instrumentation/"/>
    <id>http://crossoverjie.top/2024/09/26/ob/OpenTelemetry-create-instrumentation/</id>
    <published>2024-09-26T05:14:01.000Z</published>
    <updated>2024-09-26T13:39:32.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>因为公司内部在使用 <a href="https://github.com/PowerJob/PowerJob">PowerJob</a> 作为我们的分布式调度系统，同时又是使用 OpenTelemetry 作为可观测的底座，但目前 OpenTelemetry 还没有对 PowerJob 提供支持，目前社区只对同类型的 XXL-JOB 有支持。<br><img src="https://s2.loli.net/2024/08/26/qfdloarJ7iNzPXy.png"></p><p>恰好公司内部也有一些开发同学有类似的需求：<br><img src="https://s2.loli.net/2024/08/26/6aIFxlEyKt7OfsC.png"></p><p>于是在这个背景下我便开始着手开发 PowerJob 的 instrumentation，最终的效果如下：<br><img src="https://s2.loli.net/2024/08/26/r7xgSHKCftqvuXw.png"><br><img src="https://s2.loli.net/2024/08/26/KNnWPzm5rU9By3c.png"></p><span id="more"></span><p>从这个链路图中可以看到 grpc-consumer 提供了调度的入口函数，然后在内部发送了 Pulsar 消息，最终又调用了 grpc-provider 的 <code>gRPC</code> 接口。</p><p>这样就可以把整个链路串起来，同时还能查看 <code>PowerJob</code> 调度的 JobId、以及调用参数等数据，这样排查问题时也更加直观。</p><h1 id="开发-Instrumentation-的前置知识"><a href="#开发-Instrumentation-的前置知识" class="headerlink" title="开发 Instrumentation 的前置知识"></a>开发 Instrumentation 的前置知识</h1><p>在正式开发 Instrumentation 之前还需要了解一些前置知识点。</p><p><img src="https://s2.loli.net/2024/08/26/K43Ix8LCkQWAao5.png"><br><img src="https://s2.loli.net/2024/08/26/29DQxfMgFViuHYa.png"></p><p>这里我们以现有的  <code>gRPC</code> 和我编写的 PowerJob instrumentation 为例，可以看到 <code>gRPC</code> 的 instrumentation 中多了一个 library 的模块。</p><p>这里就引申出了两种埋点方式：</p><ul><li><strong>Library instrumentation</strong></li><li><strong>Java agent instrumentation</strong></li></ul><p>通常我们对一个框架或者一个库进行埋点时，首先需要找到它的埋点入口。</p><p>以 <em><code>grpc</code></em> 为例，我们首先需要看他是否有提供扩展的 API 可以供我们埋点，恰好 grpc 是有提供客户端和服务端的拦截器的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io.grpc.ClientInterceptor</span><br><span class="line">io.grpc.ServerInterceptor</span><br></pre></td></tr></table></figure><p>我们便可以在这些拦截中加入埋点逻辑，比如客户端的埋点代码如下 <code>io.opentelemetry.instrumentation.grpc.v1_6.TracingClientInterceptor</code> ：</p><p><img src="https://s2.loli.net/2024/08/26/FJgRjf1ACVlmG3D.png"></p><p>这部分代码便是写在 <code>grpc-1.6/library</code> 模块下的。</p><p>这样做有一个好处是：当我们的业务代码不想使用 <code>javaagent</code> 时还可以手动引入 <code>grpc-1.6/library</code> 包，然后使用 <code>TracingClientInterceptor</code> 拦截器也可以实现 trace 埋点的功能。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(project(<span class="string">&quot;:instrumentation:grpc-1.6:library&quot;</span>))</span><br></pre></td></tr></table></figure><p>之后 <code>javaagent</code> 这个模块也会引入 <code>library</code> ，然后直接使用它提供的 API 实现 agent 级别的埋点。</p><p>而如果一些库或者中间件并没有提供这种扩展 API 时，我们就只能使用 agent 的方式在字节码层面上进行埋点，这样就不会限制框架了，理论上任何 Java 代码都可以埋点。</p><p>所以总的来说一个库可能会没有 library instrumentation，但一定会有 agent instrumentation，我们可以根据当前框架的代码进行选择。</p><blockquote><p>而这里的 PowerJob 因为并没有提供扩展接口，所有只有 agent 的 instrumentation。</p></blockquote><h1 id="找到埋点入口"><a href="#找到埋点入口" class="headerlink" title="找到埋点入口"></a>找到埋点入口</h1><p>在开始编码之前我们需要对要埋点的库或者框架有一个清晰的理解，至少得知道它的核心逻辑在哪里。</p><p>以 PowerJob 的调度执行逻辑为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBasicProcessor</span> <span class="keyword">implements</span> <span class="title class_">BasicProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">process</span><span class="params">(TaskContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;======== BasicProcessor#process ========&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;TaskContext: &quot;</span> + JsonUtils.toJSONString(context) + <span class="string">&quot;;time = &quot;</span> + System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>, System.currentTimeMillis() + <span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这是一个最简单的调度执行器的实现逻辑。</p></blockquote><p>从这里看出：如果我们想要在执行器中埋点，那最核心的就是这里的 process 函数。</p><p>需要在 process 的执行前后拿到 context 数据，写入到 OpenTelemetry 中的 span 即可。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCustomizedHandler</span> <span class="keyword">extends</span> <span class="title class_">IJobHandler</span> &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">execute</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;&gt;(<span class="string">&quot;Hello World&quot;</span>);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 xxl-job 中，它的核心逻辑就是这里的 <code>execute</code> 函数。</p><h1 id="选择合适的版本"><a href="#选择合适的版本" class="headerlink" title="选择合适的版本"></a>选择合适的版本</h1><p>找到核心的埋点逻辑后还有一个很重要的工作要做：那就是<strong>选择你需要支持的版本</strong>。</p><p>选择版本的原因是有可能框架或库在版本迭代过程中核心 API 发生了变化，比如：</p><ul><li>函数签名发生了改变</li><li>包名也发生了改变</li></ul><p>以 xxl-job 为例，它在迭代过程中就发生了几次函数签名的修改，所以我们需要针对不同的版本做兼容处理：</p><p><img src="https://s2.loli.net/2024/08/26/yLhmXBKDzVaYjJ5.png"></p><p>而我这里选择支持 <code>PowerJob:4.0+</code> 的版本，因为社区在 4.0 之后做了大量重构，导致修改了包名，同时核心逻辑的函数签名也没发生过变化。</p><p><img src="https://s2.loli.net/2024/08/26/MuRmI9e28pghzNH.png"></p><blockquote><p>4.0 之前的版本我就没做兼容了，感兴趣的朋友可以自行实现。</p></blockquote><h1 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h1><p>首先第一步需要创建一个 <code>InstrumentationModule</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService(InstrumentationModule.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerJobInstrumentationModule</span> <span class="keyword">extends</span> <span class="title class_">InstrumentationModule</span> &#123;  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PowerJobInstrumentationModule</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;powerjob&quot;</span>, <span class="string">&quot;powerjob-4.0&quot;</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">public</span> List&lt;TypeInstrumentation&gt; <span class="title function_">typeInstrumentations</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> asList(<span class="keyword">new</span> <span class="title class_">BasicProcessorInstrumentation</span>());  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/26/AxGWtdflEI5NmKn.png"></p><blockquote><p>这里的 @AutoService 注解，会在代码编译之后生成一份 SPI 文件。</p></blockquote><p>之后便是实现这里最核心的 <code>BasicProcessorInstrumentation</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicProcessorInstrumentation</span> <span class="keyword">implements</span> <span class="title class_">TypeInstrumentation</span> &#123;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">public</span> ElementMatcher&lt;TypeDescription&gt; <span class="title function_">typeMatcher</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> implementsInterface(named(<span class="string">&quot;tech.powerjob.worker.core.processor.sdk.BasicProcessor&quot;</span>));  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(TypeTransformer transformer)</span> &#123;  </span><br><span class="line">    transformer.applyAdviceToMethod(  </span><br><span class="line">        named(<span class="string">&quot;process&quot;</span>).and(isPublic()).and(takesArguments(<span class="number">1</span>)),  </span><br><span class="line">        BasicProcessorInstrumentation.class.getName() + <span class="string">&quot;$ProcessAdvice&quot;</span>);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>从它的代码也可以看出，这里主要是指定我们需要对哪个方法的哪个函数进行埋点，然后埋点之后的处理逻辑是在哪个类(<code>ProcessAdvice</code>)中实现的。</p><p>之后便是 <code>ProcessAdvice</code> 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ProcessAdvice</span> &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span>  </span><br><span class="line">  <span class="meta">@Advice</span>.OnMethodEnter(suppress = Throwable.class)  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">onSchedule</span><span class="params">(  </span></span><br><span class="line"><span class="params">      <span class="meta">@Advice</span>.This BasicProcessor handler,  </span></span><br><span class="line"><span class="params">      <span class="meta">@Advice</span>.Argument(<span class="number">0</span>)</span> TaskContext taskContext,  </span><br><span class="line">      <span class="meta">@Advice</span>.Local(<span class="string">&quot;otelRequest&quot;</span>) PowerJobProcessRequest request,  </span><br><span class="line">      <span class="meta">@Advice</span>.Local(<span class="string">&quot;otelContext&quot;</span>) Context context,  </span><br><span class="line">      <span class="meta">@Advice</span>.Local(<span class="string">&quot;otelScope&quot;</span>) Scope scope) &#123;  </span><br><span class="line">    <span class="type">Context</span> <span class="variable">parentContext</span> <span class="operator">=</span> currentContext();  </span><br><span class="line">    request = PowerJobProcessRequest.createRequest(taskContext.getJobId(), handler, <span class="string">&quot;process&quot;</span>);  </span><br><span class="line">    request.setInstanceParams(taskContext.getInstanceParams());  </span><br><span class="line">    request.setJobParams(taskContext.getJobParams());  </span><br><span class="line">    context = helper().startSpan(parentContext, request);  </span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span>;  </span><br><span class="line">    &#125;    scope = context.makeCurrent();  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span>  </span><br><span class="line">  <span class="meta">@Advice</span>.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">stopSpan</span><span class="params">(  </span></span><br><span class="line"><span class="params">      <span class="meta">@Advice</span>.Return ProcessResult result,  </span></span><br><span class="line"><span class="params">      <span class="meta">@Advice</span>.Thrown Throwable throwable,  </span></span><br><span class="line"><span class="params">      <span class="meta">@Advice</span>.Local(<span class="string">&quot;otelRequest&quot;</span>)</span> PowerJobProcessRequest request,  </span><br><span class="line">      <span class="meta">@Advice</span>.Local(<span class="string">&quot;otelContext&quot;</span>) Context context,  </span><br><span class="line">      <span class="meta">@Advice</span>.Local(<span class="string">&quot;otelScope&quot;</span>) Scope scope) &#123;  </span><br><span class="line">    helper().stopSpan(result, request, throwable, scope, context);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最主要的就是使用 <code>OpenTelemetry</code> 提供 SDK 在入口处调用 <code>startSpan</code> 开始一个 span，然后在函数退出时调用 <code>stopSpan</code> 函数。</p><p>同时在执行前将一些请求信息存起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request = PowerJobProcessRequest.createRequest(taskContext.getJobId(), handler, <span class="string">&quot;process&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样可以根据这些请求信息生成 span 的 attribute，也就是 jobId, jobParam 等数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PowerJobExperimentalAttributeExtractor</span>  </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">AttributesExtractor</span>&lt;PowerJobProcessRequest, Void&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(  </span></span><br><span class="line"><span class="params">      AttributesBuilder attributes,  </span></span><br><span class="line"><span class="params">      Context parentContext,  </span></span><br><span class="line"><span class="params">      PowerJobProcessRequest powerJobProcessRequest)</span> &#123;  </span><br><span class="line">    attributes.put(POWERJOB_JOB_ID, powerJobProcessRequest.getJobId());  </span><br><span class="line">    attributes.put(POWERJOB_JOB_PARAM, powerJobProcessRequest.getJobParams());  </span><br><span class="line">    attributes.put(POWERJOB_JOB_INSTANCE_PARAM, powerJobProcessRequest.getInstanceParams());  </span><br><span class="line">    attributes.put(POWERJOB_JOB_INSTANCE_TRPE, powerJobProcessRequest.getJobType());  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>比如这里的 jobId&#x2F; jobParams 数据都是从刚才写入的 <code>PowerJobProcessRequest</code> 中获取的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CAPTURE_EXPERIMENTAL_SPAN_ATTRIBUTES) &#123;  </span><br><span class="line">  builder.addAttributesExtractor(  </span><br><span class="line">      AttributesExtractor.constant(AttributeKey.stringKey(<span class="string">&quot;job.system&quot;</span>), <span class="string">&quot;powerjob&quot;</span>));  </span><br><span class="line">  builder.addAttributesExtractor(<span class="keyword">new</span> <span class="title class_">PowerJobExperimentalAttributeExtractor</span>());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时只需要将刚才的 <code>PowerJobExperimentalAttributeExtractor</code> 在初始化 Instrumenter 时进行配置，这样 <code>OpenTelemetry</code> 的 SDK 就会自动回调这个接口，从而获取到 Span 的 attribute。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.bytebuddy.matcher.ElementMatchers.isPublic;  </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.bytebuddy.matcher.ElementMatchers.named;  </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.bytebuddy.matcher.ElementMatchers.takesArguments;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.asm.Advice;</span><br></pre></td></tr></table></figure><blockquote><p>其实这里大部分的 API 都是 bytebuddy 提供的。</p></blockquote><p>不知道大家是否觉得眼熟，Instrumentation 的写法其实和 spring 的拦截器有异曲同工之妙：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AroundExample</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around(&quot;execution(* com.xyz..service.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doBasicProfiling</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">// start stopwatch</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line"><span class="comment">// stop stopwatch</span></span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>毕竟 Spring 的拦截器也是使用 <code>bytebuddy</code> 实现的。</p></blockquote><h1 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h1><p>其实整个埋点过程非常简单，我们可以参考一些现有的 instrumentation 就可以很快实现逻辑；真正麻烦的时候在提交 PR 时需要通过 CI 校验。</p><p><img src="https://s2.loli.net/2024/08/26/ynupP2g5UMWGD3Z.png"></p><blockquote><p>我这里大概提交了 8次才把  CI 全部跑通过。</p></blockquote><p>这里面有各种小坑，只有自己提交过才能感受得到，下面我就一一列举一些大家可能会碰到的问题。</p><h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><p>首先第一个是创建模块的时候记得使用 kotlin 作为 gradle 的 DSL。</p><p><img src="https://s2.loli.net/2024/08/26/ku9e3vhG5mSYPc4.png"></p><p>IDEA 这里默认选择的是 Groovy 作为 DSL；我当时没有注意，后面在项目构建过程中一直在报错，仔细核对后发现是 DSL 的问题，修改之后就能编译通过了。</p><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><p>第二个是 module 的命名规则。</p><p><img src="https://s2.loli.net/2024/08/26/NZgl4GUR327IXW5.png"></p><p>我们需要遵守 v4_0_0 的规则，同时还得与 <code>PowerJobInstrumentationModule</code> 中定义的名称相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PowerJobInstrumentationModule</span><span class="params">()</span> &#123;  </span><br><span class="line">  <span class="built_in">super</span>(<span class="string">&quot;powerjob&quot;</span>, <span class="string">&quot;powerjob-4.0&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如如果我们的包名称是 <code>powerjob.v1.1.0</code> ，那这里的名称也得是 <code>&quot;powerjob-1.1.0&quot;</code></p><h1 id="Muzzle"><a href="#Muzzle" class="headerlink" title="Muzzle"></a>Muzzle</h1><p>第三个是 <code>Muzzle</code> 校验，<code>Muzzle</code> 是为了保证 <code>javaagent</code> 在业务代码中使用时和运行时的依赖不发生冲突而定义的一个校验规则。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">muzzle &#123;  </span><br><span class="line">  pass &#123;  </span><br><span class="line">    group.<span class="keyword">set</span>(<span class="string">&quot;tech.powerjob&quot;</span>)  </span><br><span class="line">    module.<span class="keyword">set</span>(<span class="string">&quot;powerjob-worker&quot;</span>)  </span><br><span class="line">    versions.<span class="keyword">set</span>(<span class="string">&quot;[4.0.0,)&quot;</span>)  </span><br><span class="line">    assertInverse.<span class="keyword">set</span>(<span class="literal">true</span>)  </span><br><span class="line">    extraDependency(<span class="string">&quot;tech.powerjob:powerjob-official-processors:1.1.0&quot;</span>)  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以我这个为例，它的含义是兼容 <code>tech.powerjob:powerjob-worker:4.0.0+</code>以上的版本。</p><p><code>assertInverse.set(true)</code>: 的作用是与之相反的版本，也就是 4.0.0 以下的版本都不做支持，如果在这些版本中运行 javaagent 是不会生效的。</p><blockquote><p>因为这些低版本的 powerjob 不兼容我们的埋点代码。</p></blockquote><p><code>extraDependency</code>：的作用是额外需要依赖的包，我这里额外使用了这个包里的一些类，如果不加上的话在做 <code>Muzzle</code> 校验时也会失败。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>最后便是单元测试了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBasicProcessor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">jobId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">jobParam</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  <span class="type">TaskContext</span> <span class="variable">taskContext</span> <span class="operator">=</span> genTaskContext(jobId, jobParam);</span><br><span class="line">  <span class="type">BasicProcessor</span> <span class="variable">testBasicProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestBasicProcessor</span>();</span><br><span class="line">  testBasicProcessor.process(taskContext);</span><br><span class="line">  testing.waitAndAssertTraces(</span><br><span class="line">      trace -&gt; &#123;</span><br><span class="line">        trace.hasSpansSatisfyingExactly(</span><br><span class="line">            span -&gt; &#123;</span><br><span class="line">              span.hasName(String.format(<span class="string">&quot;%s.process&quot;</span>, TestBasicProcessor.class.getSimpleName()));</span><br><span class="line">              span.hasKind(SpanKind.INTERNAL);</span><br><span class="line">              span.hasStatus(StatusData.unset());</span><br><span class="line">              span.hasAttributesSatisfying(</span><br><span class="line">                  attributeAssertions(</span><br><span class="line">                      TestBasicProcessor.class.getName(), jobId, jobParam, BASIC_PROCESSOR));</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;AttributeAssertion&gt; <span class="title function_">attributeAssertions</span><span class="params">(</span></span><br><span class="line"><span class="params">    String codeNamespace, <span class="type">long</span> jobId, String jobParam, String jobType)</span> &#123;</span><br><span class="line">  List&lt;AttributeAssertion&gt; attributeAssertions =</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">          asList(</span><br><span class="line">              equalTo(AttributeKey.stringKey(<span class="string">&quot;code.namespace&quot;</span>), codeNamespace),</span><br><span class="line">              equalTo(AttributeKey.stringKey(<span class="string">&quot;code.function&quot;</span>), <span class="string">&quot;process&quot;</span>),</span><br><span class="line">              equalTo(AttributeKey.stringKey(<span class="string">&quot;job.system&quot;</span>), <span class="string">&quot;powerjob&quot;</span>),</span><br><span class="line">              equalTo(AttributeKey.longKey(<span class="string">&quot;scheduling.powerjob.job.id&quot;</span>), jobId),</span><br><span class="line">              equalTo(AttributeKey.stringKey(<span class="string">&quot;scheduling.powerjob.job.type&quot;</span>), jobType)));</span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isNullOrEmpty(jobParam)) &#123;</span><br><span class="line">    attributeAssertions.add(</span><br><span class="line">        equalTo(AttributeKey.stringKey(<span class="string">&quot;scheduling.powerjob.job.param&quot;</span>), jobParam));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> attributeAssertions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的逻辑很简单，就是模拟一下核心逻辑的调用，然后断言是否存在我们预期的 Span，同时还得校验它的 attribute 是否符合我们的预期。</p><p>这个单测当时也调了许久，因为 <code>versions.set(&quot;[4.0.0,)&quot;)</code> 这个配置，有一个 CI workflow 会校验最新版本的 powerjob 是否也能正常运行。</p><p><img src="https://s2.loli.net/2024/08/26/vDSXq9tpGW7LAdb.png"></p><p>比如它会拉取目前最新的依赖进行测试：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(<span class="string">&quot;tech.powerjob:powerjob-worker:5.1.0&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果我们在单测中依赖了某些版本不存在的类，或者是函数签名发生过变化的函数用于测试，那这个 CI 就会执行失败。</p><p><img src="https://s2.loli.net/2024/08/26/HjIi5dBKlw9FxQy.png"></p><p>因为这里的构建日志非常多，同时还是并发测试的，如果我们想直接查看日志来定位问题会非常麻烦。</p><p>当然社区也考虑到了，可以在 <code>“Build scan”</code> 这个步骤中查看 <code>gradle</code> 的构建日志。</p><p><img src="https://s2.loli.net/2024/08/26/4xmRqFZi6NpkPML.png"></p><p><a href="https://scans.gradle.com/s/meywfxnvhhqtc/console-log/task/:instrumentation:powerjob-4.0:javaagent:compileTestJava?anchor=37&page=1">这里</a>会直接输出具体是哪里构建出了问题，通过它我们就能很快定位到原因。</p><p>我这里也是因为使用的某些帮助函数在最新的版本中发生了变化，为了测试通过，就不得不调整测试代码了。</p><p>如果你发现必须得依赖这些类或者函数来配合测试，那就只有考虑分为多个不同的版本进行测试，类似于 xxl-job：</p><p><img src="https://s2.loli.net/2024/08/26/yLhmXBKDzVaYjJ5.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是整个 instrumentation 的编写过程，其中核心的埋点过程并不复杂，只要我们对需要埋点的库或框架比较熟悉，都可以实现埋点。</p><p>真正麻烦的是需要通过社区复杂且严谨的 CI 流程，好在不管是哪一步的 CI 失败都可以查到具体的原因，有点类似于升级打怪，跟着错误信息走，最终都能验证通过。</p><p>参考链接：</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/CONTRIBUTING.md">https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/CONTRIBUTING.md</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/contributing/writing-instrumentation.md">https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/contributing/writing-instrumentation.md</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;因为公司内部在使用 &lt;a href=&quot;https://github.com/PowerJob/PowerJob&quot;&gt;PowerJob&lt;/a&gt; 作为我们的分布式调度系统，同时又是使用 OpenTelemetry 作为可观测的底座，但目前 OpenTelemetry 还没有对 PowerJob 提供支持，目前社区只对同类型的 XXL-JOB 有支持。&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/26/qfdloarJ7iNzPXy.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;恰好公司内部也有一些开发同学有类似的需求：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/26/6aIFxlEyKt7OfsC.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;于是在这个背景下我便开始着手开发 PowerJob 的 instrumentation，最终的效果如下：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/26/r7xgSHKCftqvuXw.png&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/26/KNnWPzm5rU9By3c.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>我用我的270篇文章做了一个数字 AI 替身</title>
    <link href="http://crossoverjie.top/2024/09/23/ob/Build-ower-AI-robot/"/>
    <id>http://crossoverjie.top/2024/09/23/ob/Build-ower-AI-robot/</id>
    <published>2024-09-23T13:54:01.000Z</published>
    <updated>2024-09-23T14:55:08.624Z</updated>
    
    <content type="html"><![CDATA[<p>23 年在 ChatGPT 刚出来的时候就在 <a href="https://www.v2ex.com/t/931521">V 站</a>上看到有一个看到有大佬用自己的微信聊天记录和博客文章生成了一个 AI 替身：</p><span id="more"></span><p><img src="https://s2.loli.net/2024/09/23/7xPdy54cIEm6pnR.png" alt="image.png"></p><p>当时就想着自己做一个，不过当时实现起来还比较复杂，直到如今 AI 已经越来越普及，想做一个自己的 AI 替身成本也非常低了。</p><p>于是就有了下图里的效果：<br><img src="https://s2.loli.net/2024/09/23/vmJhURZKsg96yaY.png"><br><img src="https://s2.loli.net/2024/09/23/tOzlgqvEMdm6LFo.png"></p><p>和自己的内容这么对话还挺有意思的，现在大家就可以直接在我公众号回复消息和”他“聊天。<br><img src="https://s2.loli.net/2024/09/23/7CiykumvIdALDZe.jpg"></p><blockquote><p>也可以通过小程序来使用：<br><img src="https://s2.loli.net/2024/09/23/9bdLkeP6XGorKAJ.png"></p></blockquote><h2 id="如何搭建"><a href="#如何搭建" class="headerlink" title="如何搭建"></a>如何搭建</h2><p>这里使用的数据源全都是我发布在公众号里的 260 篇文章。<br><img src="https://s2.loli.net/2024/09/23/NWae9gRJbPHO6M8.png"></p><p>能够直接获取到微信公众号的数据一定是腾讯自己的产品，其实这个产品叫做：<a href="https://yuanqi.tencent.com/">腾讯元器</a>，是腾讯大模型团队基于混元大模型推出的智能创作工具。</p><p>我们可以自定义 prompt、数据源、插件来实现自己的 AI 机器人，或者类似的交互产品。</p><p>直接创建一个智能体，然后编写对应的提示词即可，使用起来非常简单，官方也提供了一些 <code>prompt</code> 的示例：<br><img src="https://s2.loli.net/2024/09/23/sOhwLG28i9qTcBz.png" alt="image.png"></p><p>根据自己的需求来填写就可以了。</p><p>最主要的还是创建一个知识库，也就是你的数据源，好在这里直接整合了公众号的数据；<br><img src="https://s2.loli.net/2024/09/23/sXALurKi5BRET23.png"></p><p>直接授权就可以使用，同时还可以每天定时更新，非常方便。</p><p><img src="https://s2.loli.net/2024/09/23/TEJZ56MNCBV3aLh.png"></p><p>它会根据你的问题来判断是否用知识库的内容来回答，所以即便是问一些知识库不存在的内容也能拿到结果。</p><hr><p><img src="https://s2.loli.net/2024/09/23/AJbU4s1FXq7rSxO.png"><br>除此之外还可以上传你本地的文件，所以即便是你没有写公众号也可以上传自己整理的内容。</p><p>有兴趣的朋友可以试试尝尝鲜，后续我可以持续完善这个知识库，比如输入一些代码，之后再有向我咨询问题的朋友就可以先去问问”他“，</p><p>大家可以直接在公众号里和”对话“，说不定还有意外收获🐶。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;23 年在 ChatGPT 刚出来的时候就在 &lt;a href=&quot;https://www.v2ex.com/t/931521&quot;&gt;V 站&lt;/a&gt;上看到有一个看到有大佬用自己的微信聊天记录和博客文章生成了一个 AI 替身：&lt;/p&gt;</summary>
    
    
    
    <category term="AI" scheme="http://crossoverjie.top/categories/AI/"/>
    
    
    <category term="AI" scheme="http://crossoverjie.top/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>OpenTelemetry在企业内部应用所需要的技术栈</title>
    <link href="http://crossoverjie.top/2024/09/15/ob/OpenTelemetry-enterprise/"/>
    <id>http://crossoverjie.top/2024/09/15/ob/OpenTelemetry-enterprise/</id>
    <published>2024-09-15T07:54:11.000Z</published>
    <updated>2024-09-17T11:50:48.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可观测性概念"><a href="#可观测性概念" class="headerlink" title="可观测性概念"></a>可观测性概念</h1><p><img src="https://s2.loli.net/2024/08/08/Sdot1TJUfWgNZyu.png"><br>当一个软件或系统出于运行状态时，如果我们不对他加以观测，那它的运行状态对我们来说就是一个黑盒。</p><blockquote><p>如上图所示。</p></blockquote><p>我们只能通过业务的表象来判断它是否正常运行，无法在故障发生前进行预判，从而只能被动解决问题。</p><span id="more"></span><p>这类问题在微服务时代体现的更加明显，即便是业务已经出现问题，在没有可观测性系统的前提下想要定位问题更是难上加难。</p><p><img src="https://s2.loli.net/2024/08/08/eUFuwnPxf3cVrCL.png"><br>好在可观测性这个概念由来已久，已经由一些业界大佬抽象出几个基本概念：</p><ul><li>Logs：离散的日志信息</li><li>Metrics：聚合的指标</li><li>Trace：请求基本的链路追踪</li></ul><p>结合这三个指标，我们排查问题的流程一般如下：<br><img src="https://s2.loli.net/2024/08/08/Ixqt2WnBaz9jAQ4.png"></p><p>首先根据 metrics 来判断是否有异常，这点可以通过在 Prometheus 的 AlertManager 配置一些核心的告警指标。</p><p>比如当 CPU、内存使用率超过 80% 或者某个应用 Down 机后就发出告警。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">AllInstances</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">InstanceDown</span></span><br><span class="line">    <span class="comment"># Condition for alerting</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">up</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">1m</span></span><br><span class="line">    <span class="comment"># Annotation - additional informational labels to store more information</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">&#x27;Instance <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> down&#x27;</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">&#x27;<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> of job <span class="template-variable">&#123;&#123; $labels.job &#125;&#125;</span> has been down for more than 1 minute.&#x27;</span></span><br><span class="line">    <span class="comment"># Labels - additional labels to be attached to the alert</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">severity:</span> <span class="string">&#x27;critical&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/15/vh4t8nLk2NaXKu9.png"></p><p>这可以让我们尽早发现故障。</p><p>之后我们可以通过链路信息找到发生故障的节点。<br><img src="https://s2.loli.net/2024/08/15/A4C8xQour2WqpLO.png"></p><p>然后通过这里的 trace_id 在应用中找到具体的日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdc.trace_id:4a686dedcdf4e95b1a83b36e62563a96</span><br></pre></td></tr></table></figure><p>再根据日志中的上下文确定具体的异常原因。</p><p>这就是一个完整的排查问题的流程。</p><h1 id="OpenTelemetry-发展历史"><a href="#OpenTelemetry-发展历史" class="headerlink" title="OpenTelemetry 发展历史"></a>OpenTelemetry 发展历史</h1><p><img src="https://s2.loli.net/2024/08/08/p5WkVbSarUdIQwT.png" alt="image.png"><br><img src="https://s2.loli.net/2024/08/08/pvMEBObGgHcdRom.png"><br>在 OpenTelemetry 开始之前还是先回顾下可观测性的发展历史，其中有几个重要时间点：</p><ul><li>2010 年 Google 发布了 Dapper 论文，给业界带来了实现分布式追踪的理论支持，之后的许多分布式链路追踪实现都有它的影子</li><li>kubernetes 的发布奠定了后续云原生社区的基础</li><li>Jaeger 发布后成为了主流的链路存储系统</li><li>2019 年 OpenTracing 和 OpenCensus 合并为 OpenTelemetry</li><li>2021 年底 OpenTelemetry 发布第一个 GA release 版本</li></ul><h2 id="OpenTelemetry-是什么？"><a href="#OpenTelemetry-是什么？" class="headerlink" title="OpenTelemetry 是什么？"></a>OpenTelemetry 是什么？</h2><p><img src="https://s2.loli.net/2024/08/08/FDzVTSqruLxY8EX.png"></p><p>以前我们所接触到的类似于阿里的ARMS、美团的 CAT、Pinpoint 这类系统大多都有一个公司在背后进行驱动，与厂商绑定的非常紧密。</p><p>而 OpenTelemetry 则相反，它主要由社区驱动，参与的公司众多；同时它定义和提供了一套可观测性的标准（包括 API、SDK、规范等数据）。</p><p>使用它你可以灵活的选择和搭配任意的开源或商业产品来组成你的可观测性技术栈。</p><p><img src="https://s2.loli.net/2024/08/08/8RJ6H75hsICWgcD.png"></p><p>因为社区非常活跃，所以当前也几乎支持主流的开发语言。</p><h2 id="OpenTelemetry-的架构"><a href="#OpenTelemetry-的架构" class="headerlink" title="OpenTelemetry 的架构"></a>OpenTelemetry 的架构</h2><p><img src="https://s2.loli.net/2024/08/08/DMd1JfcCrO7Pm52.png"><br>OpenTelemetry 的架构主要分为三个部分：</p><ul><li>左侧的客户端 Agent，用于采集客户端的数据，通常就是我们的应用。</li><li>中间的是 Collector-Service，用于接受客户端的数据、内部处理、导出数据到各种存储</li><li>右侧的则是各种存储层，用于存储 Metrics、Logs、Traces 这些数据。</li></ul><p>我们基于官方推荐的技术架构选型了我们的技术栈：<br><img src="https://s2.loli.net/2024/08/09/XTzCOPBI6HYNta1.png" alt="image.png"><br>主要的区别就是使用 VictoriaMetrics 存储指标、StackRocks 存储 Trace，ElasticSearch 存储日志。</p><blockquote><p>只是目前我们的日志链路还没有完全切换到 OpenTelemetry 的链路，依然是在 Pod 中挂载了一个 sidecar，在这个 sidecar 中通过 filebeat 采集日志输出到 elasticsearch，后续也会逐步迁移。</p></blockquote><h2 id="核心项目"><a href="#核心项目" class="headerlink" title="核心项目"></a>核心项目</h2><h3 id="Collecotor"><a href="#Collecotor" class="headerlink" title="Collecotor"></a>Collecotor</h3><p>OpenTelemetry 社区的项目众多，其中大部分都是各种语言的 SDK 和 API，其中最为关键的应该就是 <a href="https://github.com/open-telemetry?q=opentelemetry-collector&type=all&language=&sort=">opentelemetry-collector</a></p><p>也就是刚才架构图中的中间部分，我们可以把它理解为类似 APIGateway 的角色，所有上报的 OTel 数据都得经过它的处理。</p><p><img src="https://s2.loli.net/2024/08/16/UfuI2wHtojqNS96.png"></p><p>主要由以下三部分组成：</p><ul><li>Receiver：用于接受客户端上报的数据</li><li>Process：内部的数据处理器</li><li>Exporter：将数据导出到不同的存储</li></ul><p>由于 OpenTelemetry 社区非常的活跃，所以这里支持的 <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver">Receiver</a>、<a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor">Processor</a> 和 <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter">Exporter</a> 类型非常多。</p><p><img src="https://s2.loli.net/2024/08/16/hTeuXskGMitYFCr.png"><br><img src="https://s2.loli.net/2024/08/16/EqPcjxK3Myr2LUC.png"><br><img src="https://s2.loli.net/2024/08/16/btqTu9gAl7heJra.png"></p><h3 id="其他核心项目"><a href="#其他核心项目" class="headerlink" title="其他核心项目"></a>其他核心项目</h3><p>我们以 Java 为例，对业务开发最重要的库就是 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/">opentelemetry-java-instrumentation</a></p><p>它可以打包一个 javaagent 给我们使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Java example</span></span><br><span class="line">java -javaagent:path/to/opentelemetry-javaagent.jar \  </span><br><span class="line">     -jar myapp.jar</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/16/YjzfWKFxPOqH5N6.png"></p><p>同时也支持了我们日常开发的绝大多数框架和中间件。</p><blockquote><p>支持的<a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md">库与框架</a>列表</p></blockquote><p>如果我们需要在应用中自定义打桩一些 Span、Metrics ，就还需要 <a href="https://github.com/open-telemetry/opentelemetry-java">opentelemetry-java</a> 这个项目。</p><p>它提供了具体的 SDK 可以方便的创建 Span 和 Metrics。</p><h1 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h1><p>之后来看看 <code>OpenTelemetry</code> 中具体的三个维度的概念和应用，首先是 Trace。</p><p><img src="https://s2.loli.net/2024/08/16/DAB7J5Rpx8OFs6L.png"></p><p>Trace 这个概念首先是 <a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf">Google Dapper</a> 论文中提到。</p><p>如上图所示：一次用户请求经历了 4 次 PRC 调用，分别也属于不同的系统。</p><p>每一次 RPC 调用就会产生一个 Span，将这些 span 串联起来就能形成一个调用链路。</p><p>这个 Span 主要包含以下信息：</p><ul><li>SpanName</li><li>ParentID</li><li>SpanID</li></ul><p>当我们将一个 Span 放大后会看到更加具体的信息：</p><ul><li>TraceId</li><li>SpanName</li><li>ParentID</li><li>SpanID</li><li>开始时间</li><li>结束时间<br>在 Dapper 论文中使用 Annotations 来存放 span 的属性，当然也可以自定义存放一些数据，比如图中的 <code>&quot;foo&quot;</code>。</li></ul><blockquote><p>在 OpenTelemetry 的 SDK 中称为  attribute，而在 Jaeger 的 UI 中又称为 tag，虽然叫法不同，但本质上是一个东西。</p></blockquote><p>最终就会形成上图中的树状结构的调用关系。</p><h2 id="Span-Kind"><a href="#Span-Kind" class="headerlink" title="Span Kind"></a>Span Kind</h2><p><img src="https://s2.loli.net/2024/08/16/XSAGlCY7F4f1pu5.png"><br>Span 中还有一个非常重要的概念，就是 Span Kind，也就是 Span 的类型，这个类型可以在排查问题时很容易得知该服务的类型。</p><p><img src="https://s2.loli.net/2024/08/16/cqezfgKSylJipRB.png"><br>按照官方的定义，Span 的类型分为：</p><ul><li>Client</li><li>Server</li><li>Internal</li><li>Producer</li><li>Consumer</li></ul><p>对于 RPC 的客户端和服务端自然就对应 Client 和 Server，而使用了消息队列的生产者消费者对应的就是 Produce 和 Consumer。</p><p>除此之外发生在应用内部的一些关键 Span 的类型就是 Internal，比如我们需要对业务的某些关键函数生成 Span 时，此时的 Span 类型通常也都是 Internal。</p><h2 id="上下文传递"><a href="#上下文传递" class="headerlink" title="上下文传递"></a>上下文传递</h2><p><img src="https://s2.loli.net/2024/08/09/v1mwnLEGNlKMbsq.png" alt="image.png"></p><p>在 Trace 中有一个关键技术问题需要被解决，也就是 Context 的上下文传递。</p><p>这个特别是在分布式系统中必须要解决，我们可以简单把它理解为如何把上游生成的 trace_id 传递到下游，这样才能在追踪的链路追踪系统中串联起来。</p><p>这个关键的技术名词在 OpenTelemetry 中称为：<a href="https://opentelemetry.io/docs/concepts/context-propagation/">Context Propagation</a>.</p><p>在分布式系统中，数据都是通过网络传递的，所以这里的本质问题依然是如何将上下文数据序列化之后，在下游可以反序列化到 <code>Context</code> 中。</p><p>聪明的小伙伴应该已经想到，我们可以将 trace_id 写入到跨进程调用的元数据中：</p><ul><li>http 可以存放在 http header 中</li><li>gRPC 可以存放在 meta 中</li><li>Pulsar 可以存放在消息的 properties 中</li><li>其余的中间件和框架也是同理</li></ul><p>然后在远程调用之前使用 <code>Inject</code> 将数据注入到这些元数据里，下游在接收到请求后再通过一个<code>Extract</code> 函数将元数据解析到 <code>Context</code> 中，这样 <code>trace_id</code> 就可以串联起来了。</p><p><img src="https://s2.loli.net/2024/08/08/wfKZNacuBJeMDO1.png" alt="image.png"></p><p><img src="https://s2.loli.net/2024/08/08/NHOYS9R1EIZrBhd.png" alt="image.png"></p><p>上图就是 Pulsar 和 gRPC 传递 trace_id 的过程，数据都是存放在元数据中的，这里的 <code>traceparent</code> 的值本质上就是 trace_id.</p><blockquote><p>具体的代码细节我会在下一篇继续分析。</p></blockquote><h1 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h1><p><img src="https://s2.loli.net/2024/08/09/HfFnubtAKvJ8hVy.png"></p><p>Metrics 相对于 Trace 来说则是要简单许多，OpenTelemetry 定义了许多命名规范和标准，这样大家在复用社区的一些监控模板时就要更加容易一些。</p><h2 id="Metrics-Exemplars"><a href="#Metrics-Exemplars" class="headerlink" title="Metrics Exemplars"></a>Metrics Exemplars</h2><p><img src="https://s2.loli.net/2024/08/09/tOlkQFZBH421wri.png"></p><p>Metrics 还提供了一个 Exemplar 的功能，它的主要作用是可以将 Metrics 和 Trace 关联在一起，这样在通过 Metrics 发现问题时，就可以直接跳转到链路系统。</p><p>因为 trace_id 可以通过 MDC 和日志关联，所以我们可以直接通过 Metrics 定位具体应用的日志，这样排查问题的效率将会非常高。</p><h1 id="扩展信息"><a href="#扩展信息" class="headerlink" title="扩展信息"></a>扩展信息</h1><p>以上就是关于 OpenTelemetry 的整体架构，下面来扩展一些内容。</p><h2 id="eBPF"><a href="#eBPF" class="headerlink" title="eBPF"></a>eBPF</h2><p><img src="https://s2.loli.net/2024/08/16/KPxF6kvcBCX4JER.png"><br>eBPF 是一个运行在 Linux 内核中的虚拟机，它提供一套特殊的指令集并允许我们在不重新编译内核、也不需要重启应用的情况下加载自定义的逻辑。</p><p>eBPF 技术具有三大特点：</p><ul><li>第一是<strong>无侵入</strong>，动态挂载，目标进程无需重启，而且因为是 Linux 内核提供功能，所以与语言无关，任何语言都可以支持。</li><li>第二是<strong>高性能</strong>，eBPF 字节码会被 JIT 成机器码后执行，效率非常高；</li><li>第三是更加<strong>安全</strong>，它会运行在自己的沙箱环境中，不会导致目标进程崩溃。</li></ul><p>eBPF 虽然有很多优点，同时也有一些局限性，比如我想监控业务代码中的某个具体指标（订单创建数量），此时它就难以实现了，所以还得看我们的应用场景。<br>更适合一些云平台，或者更偏向底层的应用。</p><p>目前 eBPF 的应用场景还不够广泛，但假以时日一定会成为可观测领域的未来之星。</p><h2 id="SigNoz"><a href="#SigNoz" class="headerlink" title="SigNoz"></a><a href="https://signoz.io/">SigNoz</a></h2><p>不知道大家发现没有，如果我们直接 OpenTelemetry 技术栈会需要为 Trace、Metrics、Logs 选择不同的存储，而且他们的查询界面也分散在不同的地方。</p><p>那有没有一个统一的平台可以给我们提供完整的可观测体验呢？</p><p>有这样的需求那就有对应的厂商实现了：<br><img src="https://s2.loli.net/2024/08/09/YZbT3CrlGwoceDE.png"></p><p><a href="https://signoz.io/">SigNoz</a> 就是这样的平台，它将 OpenTelemetry-collector 和数据存储全部整合在了一起，同时全面兼容  OpenTelemetry；可以说它就是基于 OpenTelemetry 构建的一个可观测产品。</p><p>对于一些中小厂商，不想单独维护这些组件时是非常有用的。</p><h2 id="OpenObserve"><a href="#OpenObserve" class="headerlink" title="OpenObserve"></a><a href="https://openobserve.ai/">OpenObserve</a></h2><p><img src="https://s2.loli.net/2024/08/16/CuzXT7ts6vWQAEO.png" alt="image.png"></p><p><a href="https://openobserve.ai/">OpenObserve</a>在 SigNoz 的基础上做的更加极致一些，它提供了一个统一的存储可以存放日志、Trace、Metrics 等数据。</p><p>这样我们就可以只使用一个数据库存放所有的数据，同时它也提供了完整的 UI，并且也全面兼容 OpenTelemetry。</p><p>这样对于运维来说会更加简单，只是可能带来的副作用就是需要与它完全绑定。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是 OpenTelemetry 在企业的应用，大家可以根据自己的情况选择自建 OTel 的技术栈，还是选择 SigNoz 和 OpenObserve 这类的标准化产品。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;可观测性概念&quot;&gt;&lt;a href=&quot;#可观测性概念&quot; class=&quot;headerlink&quot; title=&quot;可观测性概念&quot;&gt;&lt;/a&gt;可观测性概念&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/08/Sdot1TJUfWgNZyu.png&quot;&gt;&lt;br&gt;当一个软件或系统出于运行状态时，如果我们不对他加以观测，那它的运行状态对我们来说就是一个黑盒。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如上图所示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们只能通过业务的表象来判断它是否正常运行，无法在故障发生前进行预判，从而只能被动解决问题。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>日志与追踪的完美融合：OpenTelemetry MDC 实践指南</title>
    <link href="http://crossoverjie.top/2024/09/05/ob/OpenTelemetry-client-log-mdc/"/>
    <id>http://crossoverjie.top/2024/09/05/ob/OpenTelemetry-client-log-mdc/</id>
    <published>2024-09-05T06:50:33.000Z</published>
    <updated>2024-09-10T13:41:32.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前面两篇实战文章中：</p><ul><li><a href="https://juejin.cn/post/7391744486979076146">OpenTelemetry 实战：从零实现分布式链路追踪</a></li><li><a href="https://juejin.cn/post/7394395254566846475">OpenTelemetry 实战：从零实现应用指标监控</a></li></ul><p>覆盖了可观测中的指标追踪和 <code>metrics</code> 监控，下面理应开始第三部分：<strong>日志</strong>。</p><p>但在开始日志之前还是要先将链路追踪和日志结合起来看看应用实际使用的实践。</p><p>通常我们排查问题的方式是先查询异常日志，判断是否是当前系统的问题。</p><p>如果不是，则在日志中捞出 <code>trace_id</code> 再到链路查询系统中查询链路，看看具体是哪个系统的问题，然后再做具体的排查。</p><p>类似于这样：<br><img src="https://s2.loli.net/2024/08/05/mP97tShHKrGXge2.png"><br>日志中会打印 <code>trace_id</code> 和 <code>span_id</code>。</p><blockquote><p>如果日志系统做的比较完善的话，还可以直接点击 <code>trace_id</code> 跳转到链路系统里直接查询链路信息。</p></blockquote><span id="more"></span><h1 id="MDC"><a href="#MDC" class="headerlink" title="MDC"></a>MDC</h1><p>这里的日志里关联 trace 信息的做法有个专有名词：MDC:(Mapped Diagnostic Context)。</p><p>简单来说就是用于排查问题的上下文信息，通常是由键值对组成，类似于这样的数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2024-08-05 17:27:31.097&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;level&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;INFO&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;thread&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;http-nio-9191-exec-1&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;mdc&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span>  </span><br><span class="line">    <span class="attr">&quot;trace_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;26242f945af80b044a60226af00211fb&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="attr">&quot;trace_flags&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="attr">&quot;span_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;3a7842b3e28ed5c8&quot;</span>  </span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;logger&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;com.example.demo.DemoApplication&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;message&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;request: name: \&quot;1232\&quot;\n&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;context&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;default&quot;</span>  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在 Java 中的 Log4j 和 Logback 都有提供对应的实现。</p><p>如果我们使用了 OpenTelemetry 提供的 <code>javaagent</code> 再配合 <code>logback</code> 或者 <code>Log4j</code> 时就会自动具备打印 <code>MDC</code> 的能力：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:/Users/chenjie/Downloads/blog-img/demo/opentelemetry-javaagent-2.4.0-SNAPSHOT.jar xx.jar</span><br></pre></td></tr></table></figure><p>比如我们只需要这样配置这样一个JSON 输出的 logback 即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;PROJECT_LOG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;PATH&#125;/demo.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;PATH&#125;/demo_%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.contrib.json.classic.JsonLayout&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">jsonFormatter</span>  </span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.contrib.jackson.JacksonJsonFormatter&quot;</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">prettyPrint</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prettyPrint</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">jsonFormatter</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">timestampFormat</span>&gt;</span>yyyy-MM-dd&#x27; &#x27;HH:mm:ss.SSS<span class="tag">&lt;/<span class="name">timestampFormat</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">layout</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;PROJECT_LOG&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/05/ba195iyS2hgnOVx.png"></p><p>就会在日志文件中输出 <code>JSON</code> 格式的日志，并且带上 <code>MDC</code> 的信息。</p><h1 id="自动-MDC-的原理"><a href="#自动-MDC-的原理" class="headerlink" title="自动 MDC 的原理"></a>自动 MDC 的原理</h1><p>我也比较好奇 OpenTelemetry 是如何自动写入 MDC 信息的，这里以 <code>logback</code> 为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> ElementMatcher&lt;TypeDescription&gt; <span class="title function_">typeMatcher</span><span class="params">()</span> &#123;  </span><br><span class="line">  <span class="keyword">return</span> implementsInterface(named(<span class="string">&quot;ch.qos.logback.classic.spi.ILoggingEvent&quot;</span>));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(TypeTransformer transformer)</span> &#123;  </span><br><span class="line">  transformer.applyAdviceToMethod(  </span><br><span class="line">      isMethod()  </span><br><span class="line">          .and(isPublic())  </span><br><span class="line">          .and(namedOneOf(<span class="string">&quot;getMDCPropertyMap&quot;</span>, <span class="string">&quot;getMdc&quot;</span>))  </span><br><span class="line">          .and(takesArguments(<span class="number">0</span>)),  </span><br><span class="line">      LoggingEventInstrumentation.class.getName() + <span class="string">&quot;$GetMdcAdvice&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会在调用 <code>ch.qos.logback.classic.spi.ILoggingEvent.getMDCPropertyMap()/getMdc()</code> 这两个函数中进行埋点。</p><blockquote><p>这些逻辑都是写在 javaagent 中的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">getMDCPropertyMap</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="comment">// populate mdcPropertyMap if null  </span></span><br><span class="line">    <span class="keyword">if</span> (mdcPropertyMap == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="type">MDCAdapter</span> <span class="variable">mdc</span> <span class="operator">=</span> MDC.getMDCAdapter();  </span><br><span class="line">        <span class="keyword">if</span> (mdc <span class="keyword">instanceof</span> LogbackMDCAdapter)  </span><br><span class="line">            mdcPropertyMap = ((LogbackMDCAdapter) mdc).getPropertyMap();  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            mdcPropertyMap = mdc.getCopyOfContextMap();  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// mdcPropertyMap still null, use emptyMap()  </span></span><br><span class="line">    <span class="keyword">if</span> (mdcPropertyMap == <span class="literal">null</span>)  </span><br><span class="line">        mdcPropertyMap = Collections.emptyMap();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> mdcPropertyMap;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数其实默认情况下会返回一个 logback 内置 MDC 的 map 数据（这里的数据我们可以自定义配置）。</p><p>而这里要做的就是将 trace 的上下文信息写入这个 mdcPropertyMap 中。</p><p>以下是 OpenTelemetry agent 中的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; spanContextData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line"><span class="type">SpanContext</span> <span class="variable">spanContext</span> <span class="operator">=</span> Java8BytecodeBridge.spanFromContext(context).getSpanContext();  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (spanContext.isValid()) &#123;  </span><br><span class="line">  spanContextData.put(traceIdKey(), spanContext.getTraceId());  </span><br><span class="line">  spanContextData.put(spanIdKey(), spanContext.getSpanId());  </span><br><span class="line">  spanContextData.put(traceFlagsKey(), spanContext.getTraceFlags().asHex());  </span><br><span class="line">&#125;  </span><br><span class="line">spanContextData.putAll(ConfiguredResourceAttributesHolder.getResourceAttributes());  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (LogbackSingletons.addBaggage()) &#123;  </span><br><span class="line">  <span class="type">Baggage</span> <span class="variable">baggage</span> <span class="operator">=</span> Java8BytecodeBridge.baggageFromContext(context);  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// using a lambda here does not play nicely with instrumentation bytecode process  </span></span><br><span class="line">  <span class="comment">// (Java 6 related errors are observed) so relying on for loop instead  for (Map.Entry&lt;String, BaggageEntry&gt; entry : baggage.asMap().entrySet()) &#123;  </span></span><br><span class="line">    spanContextData.put(  </span><br><span class="line">        <span class="comment">// prefix all baggage values to avoid clashes with existing context  </span></span><br><span class="line">        <span class="string">&quot;baggage.&quot;</span> + entry.getKey(), entry.getValue().getValue());  </span><br><span class="line">  &#125;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (contextData == <span class="literal">null</span>) &#123;  </span><br><span class="line">  contextData = spanContextData;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">  contextData = <span class="keyword">new</span> <span class="title class_">UnionMap</span>&lt;&gt;(contextData, spanContextData);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是核心的写入逻辑，从这个代码中也可以看出直接从上线文中获取的 span 的 context，而我们所需要的 <code>trace_id/span_id</code>  都是存放在 context 中的，只需要 get 出来然后写入进 map 中即可。</p><p>从源码里还得知，只要我们开启 <code>-Dotel.instrumentation.logback-mdc.add-baggage=true</code> 配置还可以将 baggage 中的数据也写入到 MDC 中。</p><p>而得易于 OpenTelemetry 中的 trace 是可以跨线程传输的，所以即便是我们在多线程里打印日志时 MDC 数据依然可以准确无误的传递。</p><h2 id="MDC-的原理"><a href="#MDC-的原理" class="headerlink" title="MDC 的原理"></a>MDC 的原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MDC_ATTR_NAME</span> <span class="operator">=</span> <span class="string">&quot;mdc&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/05/e7PIASyowDGO1sQ.png"></p><p>在 <code>logback</code> 的实现中是会调用刚才的 <code>getMDCPropertyMap()</code> 然后写入到一个 key 为 <code>mdc</code> 的 <code>map</code> 里，最终可以写入到文件或者控制台。</p><p>这样整个原理就可以串起来了。</p><h2 id="自定义日志-数据"><a href="#自定义日志-数据" class="headerlink" title="自定义日志 数据"></a>自定义日志 数据</h2><p>提到可以自定义 MDC 数据其实也是有使用场景的，比如我们的业务系统经常有类似的需求，需要在日志中打印一些常用业务数据：</p><ul><li>userId、userName</li><li>客户端 IP等信息时</li></ul><p>此时我们就可以创建一个 <code>Layout</code> 类来继承 <code>ch.qos.logback.contrib.json.classic.JsonLayout</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomJsonLayout</span> <span class="keyword">extends</span> <span class="title class_">JsonLayout</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomJsonLayout</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addCustomDataToJsonMap</span><span class="params">(Map&lt;String, Object&gt; map, ILoggingEvent event)</span> &#123;</span><br><span class="line">        map.put(<span class="string">&quot;user_name&quot;</span>, context.getProperty(<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">        map.put(<span class="string">&quot;user_id&quot;</span>, context.getProperty(<span class="string">&quot;userId&quot;</span>));</span><br><span class="line">        map.put(<span class="string">&quot;trace_id&quot;</span>, TraceContext.traceId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomJsonLayoutEncoder</span> <span class="keyword">extends</span> <span class="title class_">LayoutWrappingEncoder</span>&lt;ILoggingEvent&gt; &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomJsonLayoutEncoder</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">CustomJsonLayout</span> <span class="variable">jsonLayout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomJsonLayout</span>();  </span><br><span class="line">        jsonLayout.setContext(<span class="built_in">this</span>.context);  </span><br><span class="line">        jsonLayout.setIncludeContextName(<span class="literal">false</span>);  </span><br><span class="line">        jsonLayout.setAppendLineSeparator(<span class="literal">true</span>);  </span><br><span class="line">        jsonLayout.setJsonFormatter(<span class="keyword">new</span> <span class="title class_">JacksonJsonFormatter</span>());  </span><br><span class="line">        jsonLayout.start();  </span><br><span class="line">        <span class="built_in">super</span>.setCharset(StandardCharsets.UTF_8);  </span><br><span class="line">        <span class="built_in">super</span>.setLayout(jsonLayout);  </span><br><span class="line">        <span class="built_in">super</span>.start();  </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的 trace_id 是之前使用 skywalking 的时候由 skywalking 提供的函数：org.apache.skywalking.apm.toolkit.trace.TraceContext#traceId</p></blockquote><p>接着只需要在 <code>logback.xml</code> 中配置这个 <code>CustomJsonLayoutEncoder</code> 就可以按照我们自定义的数据输出日志了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;PROJECT_LOG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;PATH&#125;/app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;PATH&#125;/app_%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;xx.CustomJsonLayoutEncoder&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;PROJECT_LOG&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然这个功能也可以使用日志切面来打印，但还是没有直接在日志中输出更加方便，它可以直接和我们的日志关联在一起，只是多加了这几个字段而已。</p><h2 id="Spring-Boot-使用"><a href="#Spring-Boot-使用" class="headerlink" title="Spring Boot 使用"></a>Spring Boot 使用</h2><p><code>OpenTelemetry</code> 有给 springboot 应用提供一个 <code>spring-boot-starter</code> 包，用于在不使用  <code>javaagent</code> 的情况下也可以自动埋点。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.opentelemetry.instrumentation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opentelemetry-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>OPENTELEMETRY_VERSION<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但在早<a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/discussions/7653">期的版本</a>中还不支持直接打印 MDC 日志：<br><img src="https://s2.loli.net/2024/08/05/aunR8ApiMEoeJ1O.png" alt="image.png"></p><blockquote><p>最新的版本已经支持</p></blockquote><p>即便已经支持默认输出 MDC 后，我们依然可以自定义的内容，比如我们想修改一下 key 的名称，由 <code>trace_id</code> 修改为 <code>otel_trace_id</code> 等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;OTEL&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.opentelemetry.instrumentation.logback.mdc.v1_0.OpenTelemetryAppender&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">traceIdKey</span>&gt;</span>otel_trace_id<span class="tag">&lt;/<span class="name">traceIdKey</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spanIdKey</span>&gt;</span>otel_span_id<span class="tag">&lt;/<span class="name">spanIdKey</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">traceFlagsKey</span>&gt;</span>otel_trace_flags<span class="tag">&lt;/<span class="name">traceFlagsKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还是和之前类似，修改下 logback.xml 即可。</p><p><img src="https://s2.loli.net/2024/08/05/Y3zvfm6rUbxwtOK.png" alt="image.png"><br>他的实现逻辑其实和之前的 auto instrument 中的类似，只不过使用的 API 不同而已。</p><p>auto instrument 是直接拦截代码逻辑修改 map 的返回值，而 <code>OpenTelemetryAppender</code> 是继承了 <code>ch.qos.logback.core.UnsynchronizedAppenderBase</code> 接口，从而获得了重写 <code>MDC</code> 的能力，但本质上都是一样的，没有太大区别。</p><p>不过使用它的前提是我们需要引入以下一个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.opentelemetry.instrumentation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opentelemetry-logback-mdc-1.0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>OPENTELEMETRY_VERSION<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果不想修改 logback.yaml ，对于 <code>springboot</code> 来说还有更简单的方案，我们只需要使用以下配置即可自定义 MDC 数据：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.pattern.level</span> = <span class="string">trace_id=%mdc&#123;trace_id&#125; span_id=%mdc&#123;span_id&#125; trace_flags=%mdc&#123;trace_flags&#125; %5p</span></span><br></pre></td></tr></table></figure><p>这里的 key 也可以自定义，只要占位符没有取错即可。</p><blockquote><p>使用这个的前提是需要加载  javaagent，因为这里的数据是 javaagent 里写进去的。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于 <code>MDC</code> 在 <code>OpenTelemetry</code> 中的使用，从使用和源码逻辑上都分析了一遍，希望对 <code>MDC</code> 和 <code>OpenTelemetry</code> 的理解更加深刻一些。</p><p>关于 MDC 相关的概念与使用还是很有用的，是日常排查问题必不可少的一个工具。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在前面两篇实战文章中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7391744486979076146&quot;&gt;OpenTelemetry 实战：从零实现分布式链路追踪&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7394395254566846475&quot;&gt;OpenTelemetry 实战：从零实现应用指标监控&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;覆盖了可观测中的指标追踪和 &lt;code&gt;metrics&lt;/code&gt; 监控，下面理应开始第三部分：&lt;strong&gt;日志&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但在开始日志之前还是要先将链路追踪和日志结合起来看看应用实际使用的实践。&lt;/p&gt;
&lt;p&gt;通常我们排查问题的方式是先查询异常日志，判断是否是当前系统的问题。&lt;/p&gt;
&lt;p&gt;如果不是，则在日志中捞出 &lt;code&gt;trace_id&lt;/code&gt; 再到链路查询系统中查询链路，看看具体是哪个系统的问题，然后再做具体的排查。&lt;/p&gt;
&lt;p&gt;类似于这样：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/05/mP97tShHKrGXge2.png&quot;&gt;&lt;br&gt;日志中会打印 &lt;code&gt;trace_id&lt;/code&gt; 和 &lt;code&gt;span_id&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果日志系统做的比较完善的话，还可以直接点击 &lt;code&gt;trace_id&lt;/code&gt; 跳转到链路系统里直接查询链路信息。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>OpenTelemetry 实战：gRPC 监控的实现原理</title>
    <link href="http://crossoverjie.top/2024/08/29/ob/OpenTelemetry-grpc-principle/"/>
    <id>http://crossoverjie.top/2024/08/29/ob/OpenTelemetry-grpc-principle/</id>
    <published>2024-08-29T06:50:33.000Z</published>
    <updated>2024-09-03T15:08:51.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://s2.loli.net/2024/07/29/uUTYr8lziEABk4d.png"></p><p>最近在给 <code>opentelemetry-java-instrumentation</code> 提交了一个 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/11833">PR</a>，是关于给 gRPC 新增四个 metrics：</p><ul><li><code>rpc.client.request.size</code>: 客户端请求包大小</li><li><code>rpc.client.response.size</code>：客户端收到的响应包大小</li><li><code>rpc.server.request.size</code>：服务端收到的请求包大小</li><li><code>rpc.server.response.size</code>：服务端响应的请求包大小</li></ul><p>这个 PR 的主要目的就是能够在指标监控中拿到 <code>RPC</code> 请求的包大小，而这里的关键就是如何才能拿到这些包的大小。</p><span id="more"></span><p>首先支持的是 <code>gRPC</code>（目前在云原生领域使用的最多），其余的 RPC 理论上也是可以支持的：<br><img src="https://s2.loli.net/2024/07/29/efGYRktoK8IESzP.png"></p><p>在实现的过程中我也比较好奇 <code>OpenTelemetry</code> 框架是如何给 <code>gRPC</code> 请求创建 <code>span</code> 调用链的，如下图所示：<br><img src="https://s2.loli.net/2024/07/15/skNmSDJaPfHh3GB.png" alt="image.png"><br><img src="https://s2.loli.net/2024/07/15/xoG2finOmFlDReE.png" alt="image.png"></p><blockquote><p>这是一个 gRPC 远程调用，java-demo 是 gRPC 的客户端，k8s-combat 是 gRPC 的服务端</p></blockquote><p>在开始之前我们可以根据 <code>OpenTelemetry</code> 的运行原理大概猜测下它的实现过程。</p><p>首先我们应用可以创建这些链路信息的前提是：使用了 <code>OpenTelemetry</code> 提供的 <code>javaagent</code>，这个 agent 的原理是在运行时使用了 <a href="https://github.com/raphw/byte-buddy">byte-buddy</a> 增强了我们应用的字节码，在这些字节码中代理业务逻辑，从而可以在不影响业务的前提下增强我们的代码（只要就是创建 span、metrics 等数据）</p><blockquote><p>Spring 的一些代理逻辑也是这样实现的</p></blockquote><h1 id="gRPC-增强原理"><a href="#gRPC-增强原理" class="headerlink" title="gRPC 增强原理"></a>gRPC 增强原理</h1><p>而在工程实现上，我们最好是不能对业务代码进行增强，而是要找到这些框架提供的扩展接口。</p><p>拿 <code>gRPC</code> 来说，我们可以使用它所提供的 <code>io.grpc.ClientInterceptor</code> 和 <code>io.grpc.ServerInterceptor</code> 接口来增强代码。</p><p>打开 <code>io.opentelemetry.instrumentation.grpc.v1_6.TracingClientInterceptor</code> 类我们可以看到它就是实现了 <code>io.grpc.ClientInterceptor</code>：<br><img src="https://s2.loli.net/2024/07/29/dVaESmoXIwJC6Li.png"></p><p>而其中最关键的就是要实现 <code>io.grpc.ClientInterceptor#interceptCall</code> 函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> &lt;REQUEST, RESPONSE&gt; ClientCall&lt;REQUEST, RESPONSE&gt; <span class="title function_">interceptCall</span><span class="params">(  </span></span><br><span class="line"><span class="params">    MethodDescriptor&lt;REQUEST, RESPONSE&gt; method, CallOptions callOptions, Channel next)</span> &#123;  </span><br><span class="line">  <span class="type">GrpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GrpcRequest</span>(method, <span class="literal">null</span>, <span class="literal">null</span>, next.authority());  </span><br><span class="line">  <span class="type">Context</span> <span class="variable">parentContext</span> <span class="operator">=</span> Context.current();  </span><br><span class="line">  <span class="keyword">if</span> (!instrumenter.shouldStart(parentContext, request)) &#123;  </span><br><span class="line">    <span class="keyword">return</span> next.newCall(method, callOptions);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> instrumenter.start(parentContext, request);  </span><br><span class="line">  ClientCall&lt;REQUEST, RESPONSE&gt; result;  </span><br><span class="line">  <span class="keyword">try</span> (<span class="type">Scope</span> <span class="variable">ignored</span> <span class="operator">=</span> context.makeCurrent()) &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">      <span class="comment">// call other interceptors  </span></span><br><span class="line">      result = next.newCall(method, callOptions);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;  </span><br><span class="line">      instrumenter.end(context, request, Status.UNKNOWN, e);  </span><br><span class="line">      <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125;  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TracingClientCall</span>&lt;&gt;(result, parentContext, context, request);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口是 <code>gRPC</code> 提供的拦截器接口，对于 <code>gRPC</code> 客户端来说就是在发起真正的网络调用前后会执行的方法。</p><p>所以在这个接口中我们就可以实现创建 span 获取包大小等逻辑。</p><h2 id="使用-byte-buddy-增强代码"><a href="#使用-byte-buddy-增强代码" class="headerlink" title="使用 byte-buddy 增强代码"></a>使用 byte-buddy 增强代码</h2><p>不过有一个问题是我们实现的 <code>io.grpc.ClientInterceptor</code> 类需要加入到拦截器中才可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">managedChannel</span> <span class="operator">=</span> ManagedChannelBuilder.forAddress(host, port) .intercept(<span class="keyword">new</span> <span class="title class_">TracingClientInterceptor</span>()) <span class="comment">// 加入拦截器</span></span><br><span class="line">.usePlaintext()</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure><p>但在 <code>javaagent</code> 中是没法给业务代码中加上这样的代码的。</p><p>此时就需要 <a href="https://bytebuddy.net/#/">byte-buddy</a> 登场了，它可以动态修改字节码从而实现类似于修改源码的效果。</p><p>在 <code>io.opentelemetry.javaagent.instrumentation.grpc.v1_6.GrpcClientBuilderBuildInstr umentation</code>  类里可以看到 <code>OpenTelemetry</code> 是如何使用 <code>byte-buddy</code> 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ElementMatcher&lt;TypeDescription&gt; <span class="title function_">typeMatcher</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> extendsClass(named(<span class="string">&quot;io.grpc.ManagedChannelBuilder&quot;</span>))</span><br><span class="line">      .and(declaresField(named(<span class="string">&quot;interceptors&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(TypeTransformer transformer)</span> &#123;</span><br><span class="line">  transformer.applyAdviceToMethod(</span><br><span class="line">      isMethod().and(named(<span class="string">&quot;build&quot;</span>)),</span><br><span class="line">      GrpcClientBuilderBuildInstrumentation.class.getName() + <span class="string">&quot;$AddInterceptorAdvice&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AddInterceptorAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Advice</span>.OnMethodEnter(suppress = Throwable.class)</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addInterceptor</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="meta">@Advice</span>.This ManagedChannelBuilder&lt;?&gt; builder,</span></span><br><span class="line"><span class="params">      <span class="meta">@Advice</span>.FieldValue(<span class="string">&quot;interceptors&quot;</span>)</span> List&lt;ClientInterceptor&gt; interceptors) &#123;</span><br><span class="line">    VirtualField&lt;ManagedChannelBuilder&lt;?&gt;, Boolean&gt; instrumented =</span><br><span class="line">        VirtualField.find(ManagedChannelBuilder.class, Boolean.class);</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.TRUE.equals(instrumented.get(builder))) &#123;</span><br><span class="line">      interceptors.add(<span class="number">0</span>, GrpcSingletons.CLIENT_INTERCEPTOR);</span><br><span class="line">      instrumented.set(builder, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里的源码可以看出，使用了 <code>byte-buddy</code> 拦截了 <code>io.grpc.ManagedChannelBuilder#intercept(java.util.List&lt;io.grpc.ClientInterceptor&gt;)</code> 函数。</p><blockquote><p>io.opentelemetry.javaagent.extension.matcher.AgentElementMatchers#extendsClass&#x2F; isMethod 等函数都是 byte-buddy 库提供的函数。</p></blockquote><p>而这个函数正好就是我们需要在业务代码里加入拦截器的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interceptors.add(<span class="number">0</span>, GrpcSingletons.CLIENT_INTERCEPTOR);</span><br><span class="line">GrpcSingletons.CLIENT_INTERCEPTOR = <span class="keyword">new</span> <span class="title class_">TracingClientInterceptor</span>(clientInstrumenter, propagators);</span><br></pre></td></tr></table></figure><p>通过这行代码可以手动将 <code>OpenTelemetry</code> 里的 <code>TracingClientInterceptor</code> 加入到拦截器列表中，并且作为第一个拦截器。</p><p>而这里的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extendsClass(named(<span class="string">&quot;io.grpc.ManagedChannelBuilder&quot;</span>))</span><br><span class="line">        .and(declaresField(named(<span class="string">&quot;interceptors&quot;</span>)))</span><br></pre></td></tr></table></figure><p>通过函数的名称也可以看出是为了找到 继承了<code>io.grpc.ManagedChannelBuilder</code> 类中存在成员变量 <code>interceptors</code> 的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transformer.applyAdviceToMethod(  </span><br><span class="line">    isMethod().and(named(<span class="string">&quot;build&quot;</span>)),  </span><br><span class="line">    GrpcClientBuilderBuildInstrumentation.class.getName() + <span class="string">&quot;$AddInterceptorAdvice&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后在调用 <code>build</code> 函数后就会进入自定义的 <code>AddInterceptorAdvice</code> 类，从而就可以拦截到添加拦截器的逻辑，然后把自定义的拦截器加入其中。</p><h1 id="获取-span-的-attribute"><a href="#获取-span-的-attribute" class="headerlink" title="获取 span 的 attribute"></a>获取 span 的 attribute</h1><p><img src="https://s2.loli.net/2024/07/29/dawSY4uQGmJo6qi.png"></p><p>我们在 gRPC 的链路中还可以看到这个请求的具体属性，比如：</p><ul><li>gRPC 服务提供的 IP 端口。</li><li>请求的响应码</li><li>请求的 service 和 method</li><li>线程等信息。<blockquote><p>这些信息在问题排查过程中都是至关重要的。</p></blockquote></li></ul><p>可以看到这里新的 <code>attribute</code> 主要是分为了三类：</p><ul><li><code>net.*</code> 是网络相关的属性</li><li><code>rpc.*</code> 是和 grpc 相关的属性</li><li><code>thread.*</code> 是线程相关的属性</li></ul><p>所以理论上我们在设计 API 时最好可以将这些不同分组的属性解耦开，如果是 MQ 相关的可能还有一些 topic 等数据，所以各个属性之间是互不影响的。</p><p>带着这个思路我们来看看 gRPC 这里是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clientInstrumenterBuilder</span><br><span class="line">.setSpanStatusExtractor(GrpcSpanStatusExtractor.CLIENT)</span><br><span class="line">.addAttributesExtractors(additionalExtractors)</span><br><span class="line">        .addAttributesExtractor(RpcClientAttributesExtractor.create(rpcAttributesGetter))</span><br><span class="line">        .addAttributesExtractor(ServerAttributesExtractor.create(netClientAttributesGetter))</span><br><span class="line">        .addAttributesExtractor(NetworkAttributesExtractor.create(netClientAttributesGetter))</span><br></pre></td></tr></table></figure><p><code>OpenTelemetry</code> 会提供一个 <code>io.opentelemetry.instrumentation.api.instrumenter.InstrumenterBuilder#addAttributesExtractor</code>构建器函数，用于存放自定义的属性解析器。</p><p>从这里的源码可以看出分别传入了网络相关、RPC 相关的解析器；正好也就对应了图中的那些属性，也满足了我们刚才提到的解耦特性。</p><p>而每一个自定义属性解析器都需要实现接口 <code>io.opentelemetry.instrumentation.api.instrumenter.AttributesExtractor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AttributesExtractor</span>&lt;REQUEST, RESPONSE&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们以 <code>GrpcRpcAttributesGetter</code> 为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">GrpcRpcAttributesGetter</span> <span class="keyword">implements</span> <span class="title class_">RpcAttributesGetter</span>&lt;GrpcRequest&gt; &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getSystem</span><span class="params">(GrpcRequest request)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;grpc&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getService</span><span class="params">(GrpcRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fullMethodName</span> <span class="operator">=</span> request.getMethod().getFullMethodName();</span><br><span class="line">    <span class="type">int</span> <span class="variable">slashIndex</span> <span class="operator">=</span> fullMethodName.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (slashIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullMethodName.substring(<span class="number">0</span>, slashIndex);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到 system 是写死的 <code>grpc</code>，也就是对于到页面上的 <code>rpc.system</code> 属性。</p><p>而这里的 <code>getService</code> 函数则是拿来获取 <code>rpc.service</code> 属性的，可以看到它是通过 <code>gRPC</code> <code>的method</code> 信息来获取 <code>service</code> 的。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RpcAttributesGetter</span>&lt;REQUEST&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Nullable</span>  </span><br><span class="line">  String <span class="title function_">getService</span><span class="params">(REQUEST request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这里 <code>REQUEST</code> 其实是一个泛型，在 gRPC 里是 <code>GrpcRequest</code>，在其他 RPC 里这是对应的 RPC 的数据。</p><p>这个 <code>GrpcRequest</code> 是在我们自定义的拦截器中创建并传递的。<br><img src="https://s2.loli.net/2024/07/29/46mOv7XMoT81Bxl.png"></p><p>而我这里需要的请求包大小也是在拦截中获取到数据然后写入进 GrpcRequest。</p><p><img src="https://s2.loli.net/2024/07/29/A1zk79tVOr3DxnQ.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Long <span class="title function_">getBodySize</span><span class="params">(T message)</span> &#123;  </span><br><span class="line">  <span class="keyword">if</span> (message <span class="keyword">instanceof</span> MessageLite) &#123;  </span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>) ((MessageLite) message).getSerializedSize();  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// Message is not a protobuf message  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><p>这样就可以实现不同的 RPC 中获取自己的 <code>attribute</code>，同时每一组 <code>attribute</code> 也都是隔离的，互相解耦。</p><h1 id="自定义-metrics"><a href="#自定义-metrics" class="headerlink" title="自定义 metrics"></a>自定义 metrics</h1><p>每个插件自定义 Metrics 的逻辑也是类似的，需要由框架层面提供 API 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InstrumenterBuilder&lt;REQUEST, RESPONSE&gt; <span class="title function_">addOperationMetrics</span><span class="params">(OperationMetrics factory)</span> &#123;  </span><br><span class="line">  operationMetrics.add(requireNonNull(factory, <span class="string">&quot;operationMetrics&quot;</span>));  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端的 metrics</span></span><br><span class="line">.addOperationMetrics(RpcClientMetrics.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端的 metrics</span></span><br><span class="line">.addOperationMetrics(RpcServerMetrics.get());</span><br></pre></td></tr></table></figure><p>之后也会在框架层面回调这些自定义的 <code>OperationMetrics</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (operationListeners.length != <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// operation listeners run after span start, so that they have access to the current span</span></span><br><span class="line">     <span class="comment">// for capturing exemplars</span></span><br><span class="line">     <span class="type">long</span> <span class="variable">startNanos</span> <span class="operator">=</span> getNanos(startTime);</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; operationListeners.length; i++) &#123;</span><br><span class="line">       context = operationListeners[i].onStart(context, attributes, startNanos);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (operationListeners.length != <span class="number">0</span>) &#123;  </span><br><span class="line">  <span class="type">long</span> <span class="variable">endNanos</span> <span class="operator">=</span> getNanos(endTime);  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> operationListeners.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">    operationListeners[i].onEnd(context, attributes, endNanos);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中最关键的就是两个函数 onStart 和 onEnd，分别会在当前这个 span 的开始和结束时进行回调。</p><p>所以通常的做法是在 <code>onStart</code> 函数中初始化数据，然后在 <code>onEnd</code> 结束时统计结果，最终可以拿到 metrics 所需要的数据。</p><p>以这个 <code>rpc.client.duration</code> 客户端的请求耗时指标为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Context <span class="title function_">onStart</span><span class="params">(Context context, Attributes startAttributes, <span class="type">long</span> startNanos)</span> &#123;  </span><br><span class="line">  <span class="keyword">return</span> context.with(  </span><br><span class="line">      RPC_CLIENT_REQUEST_METRICS_STATE,  </span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">AutoValue_RpcClientMetrics_State</span>(startAttributes, startNanos));  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEnd</span><span class="params">(Context context, Attributes endAttributes, <span class="type">long</span> endNanos)</span> &#123;  </span><br><span class="line">  <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> context.get(RPC_CLIENT_REQUEST_METRICS_STATE);</span><br><span class="line"><span class="type">Attributes</span> <span class="variable">attributes</span> <span class="operator">=</span> state.startAttributes().toBuilder().putAll(endAttributes).build();  </span><br><span class="line">clientDurationHistogram.record(  </span><br><span class="line">    (endNanos - state.startTimeNanos()) / NANOS_PER_MS, attributes, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开始时记录下当前的时间，结束时获取当前时间和结束时间的差值正好就是这个 span 的执行时间，也就是 rpc client 的处理时间。</p><p>在 <code>OpenTelemetry</code> 中绝大多数的请求时间都是这么记录的。</p><h1 id="Golang-增强"><a href="#Golang-增强" class="headerlink" title="Golang 增强"></a>Golang 增强</h1><p>而在 <code>Golang</code> 中因为没有 <a href="https://bytebuddy.net/#/">byte-buddy</a> 这种魔法库的存在，不可以直接修改源码，所以通常的做法还是得硬编码才行。</p><p>还是以 <code>gRPC</code> 为例，我们在创建 gRPC server 时就得指定一个 <code>OpenTelemetry</code> 提供的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := grpc.NewServer(  </span><br><span class="line">    grpc.StatsHandler(otelgrpc.NewServerHandler()),  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/29/RP9LWQVKSOF1d4Z.png"></p><p> 在这个 SDK 中也会实现刚才在 Java 里类似的逻辑，限于篇幅具体逻辑就不细讲了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是 <code>gRPC</code> 在 <code>OpenTelemetry</code> 中的具体实现，主要就是在找到需要增强框架是否有提供扩展的接口，如果有就直接使用该接口进行埋点。</p><p>如果没有那就需要查看源码，找到核心逻辑，再使用 <code>byte-buddy</code> 进行埋点。</p><p><img src="https://s2.loli.net/2024/07/30/h1uvr3EjA9fGmzR.png"></p><p>比如 Pulsar 并没有在客户端提供一些扩展接口，只能找到它的核心函数进行埋点。</p><p>而在具体埋点过程中 <code>OpenTelemetry</code> 提供了许多解耦的 API，方便我们实现埋点所需要的业务逻辑，也会在后续的文章继续分析 <code>OpenTelemetry</code> 的一些设计原理和核心 API 的使用。</p><p>这部分 API 的设计我觉得是 <code>OpenTelemetry</code> 中最值得学习的地方。</p><p>参考链接：</p><ul><li><a href="https://bytebuddy.net/#/">https://bytebuddy.net/#/</a></li><li><a href="https://opentelemetry.io/docs/specs/semconv/rpc/rpc-metrics/#metric-rpcserverrequestsize">https://opentelemetry.io/docs/specs/semconv/rpc/rpc-metrics/#metric-rpcserverrequestsize</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/07/29/uUTYr8lziEABk4d.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在给 &lt;code&gt;opentelemetry-java-instrumentation&lt;/code&gt; 提交了一个 &lt;a href=&quot;https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/11833&quot;&gt;PR&lt;/a&gt;，是关于给 gRPC 新增四个 metrics：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rpc.client.request.size&lt;/code&gt;: 客户端请求包大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rpc.client.response.size&lt;/code&gt;：客户端收到的响应包大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rpc.server.request.size&lt;/code&gt;：服务端收到的请求包大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rpc.server.response.size&lt;/code&gt;：服务端响应的请求包大小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个 PR 的主要目的就是能够在指标监控中拿到 &lt;code&gt;RPC&lt;/code&gt; 请求的包大小，而这里的关键就是如何才能拿到这些包的大小。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>OpenTelemetry 实战：从零实现应用指标监控</title>
    <link href="http://crossoverjie.top/2024/08/27/ob/OpenTelemetry-02-metrics/"/>
    <id>http://crossoverjie.top/2024/08/27/ob/OpenTelemetry-02-metrics/</id>
    <published>2024-08-27T06:53:35.000Z</published>
    <updated>2024-08-27T14:42:10.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇文章：<a href="https://juejin.cn/post/7391744486979076146">OpenTelemetry 实战：从零实现分布式链路追踪</a>讲解了链路相关的实战，本次我们继续跟进如何使用 OpenTelemetry 集成 metrics 监控。</p><blockquote><p>建议对指标监控不太熟的朋友可以先查看这篇前菜文章：<a href="https://crossoverjie.top/2024/06/13/ob/OpenTelemetry-metrics-concept/">从 Prometheus 到 OpenTelemetry：指标监控的演进与实践</a></p></blockquote><span id="more"></span><table><thead><tr><th>名称</th><th>作用</th><th>语言</th><th>版本</th></tr></thead><tbody><tr><td>java-demo</td><td>发送 gRPC 请求的客户端</td><td>Java</td><td>opentelemetry-agent: 2.4.0&#x2F;SpringBoot: 2.7.14</td></tr><tr><td><a href="https://github.com/crossoverJie/k8s-combat">k8s-combat</a></td><td>提供 gRPC 服务的服务端</td><td>Golang</td><td>go.opentelemetry.io&#x2F;otel: 1.28&#x2F; Go: 1.22</td></tr><tr><td><a href="https://www.jaegertracing.io/">Jaeger</a></td><td>trace 存储的服务端以及 TraceUI 展示</td><td>Golang</td><td>jaegertracing&#x2F;all-in-one:1.56</td></tr><tr><td><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib">opentelemetry-collector-contrib</a></td><td>OpenTelemetry 的 collector 服务端，用于收集 trace&#x2F;metrics&#x2F;logs 然后写入到远端存储</td><td>Golang</td><td>otel&#x2F;opentelemetry-collector-contrib:0.98.0</td></tr><tr><td><a href="https://prometheus.io/">Prometheus</a></td><td>作为 metrics 的存储和展示组件，也可以用 <a href="https://github.com/VictoriaMetrics/VictoriaMetrics">VictoriaMetrics</a> 等兼容 Prometheus 的存储替代。</td><td>Golang</td><td>quay.io&#x2F;prometheus&#x2F;prometheus:v2.49.1</td></tr></tbody></table><p><img src="https://s2.loli.net/2024/07/22/oUPjd4KlX7niBaI.png" alt="image.png"></p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>以上是加入 metrics 之后的流程图，在原有的基础上会新增一个 <code>Prometheus</code> 组件，collector 会将 metrics 指标数据通过远程的 remote write 的方式写入到 Prometheus 中。</p><p>Prometheus 为了能兼容 OpenTelemetry 写入过来的数据，需要开启相关<a href="https://prometheus.io/docs/prometheus/latest/feature_flags/#otlp-receiver">特性</a>才可以。</p><p>如果是 docker 启动的话需要传入相关参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run  -d -p 9292:9090 --name prometheus \</span><br><span class="line">-v /prometheus/prometheus.yml:/etc/prometheus/prometheus.yml \</span><br><span class="line">quay.io/prometheus/prometheus:v2.49.1 \</span><br><span class="line">--config.file=/etc/prometheus/prometheus.yml \</span><br><span class="line">--storage.tsdb.path=/prometheus \</span><br><span class="line">--web.console.libraries=/etc/prometheus/console_libraries \</span><br><span class="line">--web.console.templates=/etc/prometheus/consoles \</span><br><span class="line">--enable-feature=exemplar-storage \</span><br><span class="line">--enable-feature=otlp-write-receiver</span><br></pre></td></tr></table></figure><p><code>--enable-feature=otlp-write-receiver</code> 最主要的就是这个参数，用于开启接收 OTLP 格式的数据。</p><p>但使用这个 Push 特性就会丧失掉 Prometheus 的许多 Pull 特性，比如服务发现，定时抓取等，不过也还好，Push 和 Pull 可以同时使用，原本使用 Pull 抓取的组件依然不受影响。</p><h2 id="修改-OpenTelemetry-Collector"><a href="#修改-OpenTelemetry-Collector" class="headerlink" title="修改 OpenTelemetry-Collector"></a>修改 OpenTelemetry-Collector</h2><p>接着我们需要修改下 Collector 的配置:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">exporters:</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">&quot;jaeger:4317&quot;</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">otlphttp/prometheus:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">http://prometheus:9292/api/v1/otlp</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">insecure:</span> <span class="literal">true</span>      </span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="attr">batch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">pipelines:</span></span><br><span class="line">    <span class="attr">traces:</span></span><br><span class="line">      <span class="attr">receivers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlp</span></span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">debug</span>        </span><br><span class="line">    <span class="attr">metrics:</span></span><br><span class="line">      <span class="attr">exporters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlphttp/prometheus</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">debug</span></span><br><span class="line">      <span class="attr">processors:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">batch</span></span><br><span class="line">      <span class="attr">receivers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlp</span></span><br></pre></td></tr></table></figure><p>这里我们在 <code>exporter</code> 中新增了一个 <code>otlphttp/prometheus</code> 的节点，用于指定导出 <code>prometheus</code> 的 <code>endpoint</code> 地址。</p><p>同时我们还需要在 <code>server.metrics.exporters</code> 中配置相同的 key: <code>otlphttp/prometheus</code>。</p><p>需要注意的是这里我们一定得是配置在 <code>metrics.exporters</code> 这个节点下，如果配置在 <code>traces.exporters</code> 下时，相当于是告诉 collector 讲 trace 的数据导出到 <code>otlphttp/prometheus.endpoint</code> 这个 endpoint 里了。</p><blockquote><p>所以重点是需要理解这里的配对关系。</p></blockquote><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p>这样我们只需要将应用启动之后就可以在 Prometheus 中查询到应用上报的指标了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.traces.exporter=otlp \</span><br><span class="line">-Dotel.metrics.exporter=otlp \</span><br><span class="line">-Dotel.logs.exporter=none \</span><br><span class="line">-Dotel.service.name=java-demo \</span><br><span class="line">-Dotel.exporter.otlp.protocol=grpc \</span><br><span class="line">-Dotel.propagators=tracecontext,baggage \</span><br><span class="line">-Dotel.exporter.otlp.endpoint=http://127.0.0.1:5317 -jar target/demo-0.0.1-SNAPSHOT.jar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run go app</span></span><br><span class="line">export OTEL_EXPORTER_OTLP_ENDPOINT=http://127.0.0.1:5317 OTEL_RESOURCE_ATTRIBUTES=service.name=k8s-combat</span><br><span class="line">./k8s-combat</span><br></pre></td></tr></table></figure><p>因为我们在 collector 中开启了 Debug 的 exporter，所以可以看到以下日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024-07-22T06:34:08.060ZinfoMetricsExporter&#123;&quot;kind&quot;: &quot;exporter&quot;, &quot;data_type&quot;: &quot;metrics&quot;, &quot;name&quot;: &quot;debug&quot;, &quot;resource metrics&quot;: 1, &quot;metrics&quot;: 18, &quot;data points&quot;: 44&#125;</span><br></pre></td></tr></table></figure><p>此时是可以说明指标上传成功的。</p><p>然后我们打开 <code>Prometheus</code> 的地址：<a href="http://127.0.0.1:9292/graph">http://127.0.0.1:9292/graph</a><br>便可以查询到 Java 应用和 Go 应用上报的指标。<br><img src="https://s2.loli.net/2024/07/22/O4TuE5WlFJ8Gyk1.png"></p><blockquote><p>OpenTelemetry 的 javaagent 会自动上报 JVM 相关的指标。</p></blockquote><hr><p>而在 Go 程序中我们还是需要显式的配置一些埋点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMeterProvider</span><span class="params">()</span></span> *sdkmetric.MeterProvider &#123;  </span><br><span class="line">    ctx := context.Background()  </span><br><span class="line">  </span><br><span class="line">    exporter, err := otlpmetricgrpc.New(ctx)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Printf(<span class="string">&quot;new otlp metric grpc exporter failed: %v&quot;</span>, err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    mp := sdkmetric.NewMeterProvider(  </span><br><span class="line">       sdkmetric.WithReader(sdkmetric.NewPeriodicReader(exporter)),  </span><br><span class="line">       sdkmetric.WithResource(initResource()),  </span><br><span class="line">    )    otel.SetMeterProvider(mp)  </span><br><span class="line">    <span class="keyword">return</span> mp  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mp := initMeterProvider()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := mp.Shutdown(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error shutting down meter provider: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>和 Tracer 类似，我们首先也得在 main 函数中调用 <code>initMeterProvider()</code> 函数来初始化 Meter，此时它会返回一个 <code>sdkmetric.MeterProvider</code> 对象。</p><p>OpenTelemetry Go 的 SDK 中已经提供了对 go runtime 的自动埋点，我们只需要调用相关函数即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := runtime.Start(runtime.WithMinimumReadMemStatsInterval(time.Second))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们启动应用，在 Prometheus 中就可以看到  Go  应用上报的相关指标了。<br><img src="https://s2.loli.net/2024/07/21/FAHrsZ5ap6SWNU7.png" alt="image.png"><br><img src="https://s2.loli.net/2024/07/22/pxWu4UREZ5PXng1.png"></p><blockquote><p>runtime_uptime_milliseconds_total  Go 的运行时指标</p></blockquote><p><code>Prometheus</code> 中展示指标的 UI 能力有限，通常我们都是配合 <code>grafana</code> 进行展示的。<br><img src="https://s2.loli.net/2024/07/22/A7HNl1zbfeI4JuR.png" alt="image.png"></p><h2 id="手动上报指标"><a href="#手动上报指标" class="headerlink" title="手动上报指标"></a>手动上报指标</h2><p>当然除了 SDK 自动上报的指标之外，我们也可以类似于 trace 那样手动上报一些指标；</p><p>比如我就想记录某个函数调用的次数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> meter =  otel.Meter(<span class="string">&quot;test.io/k8s/combat&quot;</span>)  </span><br><span class="line">apiCounter, err = meter.Int64Counter(  </span><br><span class="line">    <span class="string">&quot;api.counter&quot;</span>,  </span><br><span class="line">    metric.WithDescription(<span class="string">&quot;Number of API calls.&quot;</span>),  </span><br><span class="line">    metric.WithUnit(<span class="string">&quot;&#123;call&#125;&quot;</span>),  </span><br><span class="line">)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    log.Err(err)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, <span class="type">error</span>) &#123;  </span><br><span class="line">    <span class="keyword">defer</span> apiCounter.Add(ctx, <span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: fmt.Sprintf(<span class="string">&quot;hostname:%s, in:%s, md:%v&quot;</span>, name, in.Name, md)&#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要创建一个 <code>Int64Counter</code> 类型的指标，然后在需要埋点处调用它的函数 <code>apiCounter.Add(ctx, 1)</code> 即可。</p><p><img src="https://s2.loli.net/2024/07/21/cSwCa4U7WuoJ82n.png" alt="image.png"><br>之后便可以在 <code>Prometheus</code> 中查到这个指标了。</p><p>除此之外 OpenTelemetry 中的 metrics 定义和 Prometheus 也是类似的，还有以下几种类型：</p><ul><li><strong>Counter</strong>：单调递增计数器，比如可以用来记录订单数、总的请求数。</li><li><strong>UpDownCounter</strong>：与 Counter 类似，只不过它可以递减。</li><li><strong>Gauge</strong>：用于记录随时在变化的值，比如内存使用量、CPU 使用量等。</li><li><strong>Histogram</strong>：通常用于记录请求延迟、响应时间等。</li></ul><p>在 Java 中也提供有类似的 API 可以完成自定义指标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">messageInCounter = meter    </span><br><span class="line">        .counterBuilder(MESSAGE_IN_COUNTER)    </span><br><span class="line">        .setUnit(<span class="string">&quot;&#123;message&#125;&quot;</span>)    </span><br><span class="line">        .setDescription(<span class="string">&quot;The total number of messages received for this topic.&quot;</span>)    </span><br><span class="line">        .buildObserver();</span><br></pre></td></tr></table></figure><p>对于 Gauge 类型的数据用法如下，使用 <code>buildWithCallback</code> 回调函数上报数据，<code>OpenTelemetry</code> 会在框架层面每 30s 回调一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerObservers</span><span class="params">()</span> &#123;      </span><br><span class="line">    <span class="type">Meter</span> <span class="variable">meter</span> <span class="operator">=</span> MetricsRegistration.getMeter();      </span><br><span class="line">      </span><br><span class="line">    meter.gaugeBuilder(<span class="string">&quot;pulsar_producer_num_msg_send&quot;</span>)      </span><br><span class="line">            .setDescription(<span class="string">&quot;The number of messages published in the last interval&quot;</span>)      </span><br><span class="line">            .ofLongs()      </span><br><span class="line">            .buildWithCallback(      </span><br><span class="line">                    r -&gt; recordProducerMetrics(r, ProducerStats::getNumMsgsSent));  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recordProducerMetrics</span><span class="params">(ObservableLongMeasurement observableLongMeasurement, Function&lt;ProducerStats, Long&gt; getter)</span> &#123;      </span><br><span class="line">    <span class="keyword">for</span> (Producer producer : CollectionHelper.PRODUCER_COLLECTION.list()) &#123;      </span><br><span class="line">        <span class="type">ProducerStats</span> <span class="variable">stats</span> <span class="operator">=</span> producer.getStats();      </span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> producer.getTopic();      </span><br><span class="line">        <span class="keyword">if</span> (topic.endsWith(RetryMessageUtil.RETRY_GROUP_TOPIC_SUFFIX)) &#123;      </span><br><span class="line">            <span class="keyword">continue</span>;      </span><br><span class="line">        &#125;        observableLongMeasurement.record(getter.apply(stats),      </span><br><span class="line">                Attributes.of(PRODUCER_NAME, producer.getProducerName(), TOPIC, topic));      </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>更多具体用法可以参考官方文档链接：<br><a href="https://opentelemetry.io/docs/languages/java/instrumentation/#metrics">https://opentelemetry.io/docs/languages/java/instrumentation/#metrics</a></p><p>如果我们不想将数据通过 collector 而是直接上报到 Prometheus 中，使用 OpenTelemetry 框架也是可以实现的。</p><p>我们只需要配置下环境变量:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export OTEL_METRICS_EXPORTER=prometheus</span><br></pre></td></tr></table></figure><p>这样我们就可以访问 <a href="http://127.0.0.1:9464/metrics">http://127.0.0.1:9464/metrics</a> 获取到当前应用暴露出来的指标，此时就可以在 <code>Prometheus</code> 里配置好采集 job 来获取数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&quot;k8s-combat&quot;</span></span><br><span class="line">    <span class="comment"># metrics_path defaults to &#x27;/metrics&#x27;</span></span><br><span class="line">    <span class="comment"># scheme defaults to &#x27;http&#x27;.</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&quot;k8s-combat:9464&quot;</span>]   </span><br></pre></td></tr></table></figure><p>这就是典型的 Pull 模型，而 OpenTelemetry 推荐使用的是 Push 模型，数据由 OpenTelemetry 进行采集然后推送到 Prometheus。</p><p>这两种模式各有好处：</p><table><thead><tr><th></th><th>Pull模型</th><th>Push 模型</th></tr></thead><tbody><tr><td>优点</td><td>可以在一个集中的配置里管理所有的抓取端点，也可以为每一个应用单独配置抓取频次等数据。</td><td>在 OpenTelemetry 的 collector中可以集中对指标做预处理之后再将过滤后的数据写入 Prometheus，更加的灵活。</td></tr><tr><td>缺点</td><td>1. 预处理指标比较麻烦，所有的数据是到了 Prometheus 后再经过relabel处理后再写入存储。<br>2. 需要配置服务发现</td><td>1. 额外需要维护一个类似于 collector 这样的指标网关的组件</td></tr></tbody></table><p>比如我们是用和 Prometheus 兼容的 VictoriaMetrics 采集了 istio 的相关指标，但里面的指标太多了，我们需要删除掉一部分。</p><p>就需要在采集任务里编写规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">operator.victoriametrics.com/v1beta1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">VMPodScrape</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">isito-pod-scrape</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">podMetricsEndpoints:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">scheme:</span> <span class="string">http</span>  </span><br><span class="line">      <span class="attr">scrape_interval:</span> <span class="string">&quot;30s&quot;</span>  </span><br><span class="line">      <span class="attr">scrapeTimeout:</span> <span class="string">&quot;30s&quot;</span>  </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/stats/prometheus</span>  </span><br><span class="line">      <span class="attr">metricRelabelConfigs:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">regex:</span> <span class="string">^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum|istio_request_bytes_count|istio_response_bytes_sum|istio_request_bytes_sum|istio_request_duration_milliseconds_sum|istio_response_bytes_count|istio_request_duration_milliseconds_count|^ostrich_apigateway.*|istio_request_messages_total|istio_response_messages_total</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">drop_metrics</span>  </span><br><span class="line">  <span class="attr">namespaceSelector:</span>  </span><br><span class="line">    <span class="attr">any:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>换成在 collector 中处理后，这些逻辑都可以全部移动到 collector 中集中处理。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>metrics 的使用相对于 trace 更简单一些，不需要理解复杂的 context、span 等概念，只需要搞清楚有哪几种 metrics 类型，分别应用在哪些不同的场景即可。</p><p>参考链接：</p><ul><li><a href="https://prometheus.io/docs/prometheus/latest/feature_flags/#otlp-receiver">https://prometheus.io/docs/prometheus/latest/feature_flags/#otlp-receiver</a></li><li><a href="https://opentelemetry.io/docs/languages/java/instrumentation/#metrics">https://opentelemetry.io/docs/languages/java/instrumentation/#metrics</a></li><li><a href="https://opentelemetry.io/docs/languages/go/instrumentation/#metrics">https://opentelemetry.io/docs/languages/go/instrumentation/#metrics</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇文章：&lt;a href=&quot;https://juejin.cn/post/7391744486979076146&quot;&gt;OpenTelemetry 实战：从零实现分布式链路追踪&lt;/a&gt;讲解了链路相关的实战，本次我们继续跟进如何使用 OpenTelemetry 集成 metrics 监控。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;建议对指标监控不太熟的朋友可以先查看这篇前菜文章：&lt;a href=&quot;https://crossoverjie.top/2024/06/13/ob/OpenTelemetry-metrics-concept/&quot;&gt;从 Prometheus 到 OpenTelemetry：指标监控的演进与实践&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>OpenTelemetry 实战：从零实现分布式链路追踪</title>
    <link href="http://crossoverjie.top/2024/08/20/ob/OpenTelemetry-01-trace/"/>
    <id>http://crossoverjie.top/2024/08/20/ob/OpenTelemetry-01-trace/</id>
    <published>2024-08-20T06:53:35.000Z</published>
    <updated>2024-08-20T06:35:59.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前写过一篇 <a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅</a>的文章，主要是从概念上讲解了 Trace 在 OpenTelemetry 的中的场景和使用。</p><p>也写过一篇 <a href="https://crossoverjie.top/2024/05/26/ob/OTel-demo/">实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术</a>：如何从一个 demo 开始集成 OpenTelemetry。</p><p>但还是有不少小伙伴反馈说无法快速上手（可能也是这个 demo 的项目比较多），于是我准备从 0 开始从真实的代码一步步带大家集成 <code>OpenTelemetry</code>，因为 OpenTelemetry 本身是跨多种语言的，所以也会以两种语言为（Java、Golang）主进行讲解。</p><blockquote><p>使用这两种语言主要是因为 Java 几乎全是自动埋点，而 Golang 因为语言特性，大部分都得硬编码埋点；覆盖到这两种场景后其他语言也是类似的，顶多只是 API 名称有些许区别。</p></blockquote><p>在这个过程中也会穿插一些 OpenTelemetry 的原理，希望整个过程下来大家可以在项目中实际运用起来，同时也能知其所以然。</p><span id="more"></span><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>在这个过程中会涉及到以下项目：</p><table><thead><tr><th>名称</th><th>作用</th><th>语言</th><th>版本</th></tr></thead><tbody><tr><td>java-demo</td><td>发送 gRPC 请求的客户端</td><td>Java</td><td>opentelemetry-agent: 2.4.0&#x2F;SpringBoot: 2.7.14</td></tr><tr><td>k8s-combat</td><td>提供 gRPC 服务的服务端</td><td>Golang</td><td>go.opentelemetry.io&#x2F;otel: 1.28&#x2F; Go: 1.22</td></tr><tr><td>Jaeger</td><td>trace 存储的服务端以及 TraceUI 展示</td><td>Golang</td><td>jaegertracing&#x2F;all-in-one:1.56</td></tr><tr><td>opentelemetry-collector-contrib</td><td>OpenTelemetry 的 collector 服务端，用于收集 trace&#x2F;metrics&#x2F;logs 然后写入到远端存储</td><td>Golang</td><td>otel&#x2F;opentelemetry-collector-contrib:0.98.0</td></tr></tbody></table><p><img src="https://s2.loli.net/2024/07/15/u4BYXOkztqyUoEK.png" alt="image.png"></p><p>在开始之前我们先看看实际的效果，我们需要先把 collector 和 Jaeger 部署好：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -d --name jaeger \</span><br><span class="line">  -e COLLECTOR_ZIPKIN_HOST_PORT=:9411 \</span><br><span class="line">  -p 6831:6831/udp \</span><br><span class="line">  -p 6832:6832/udp \</span><br><span class="line">  -p 5778:5778 \</span><br><span class="line">  -p 16686:16686 \</span><br><span class="line">  -p 4317:4317 \</span><br><span class="line">  -p 4318:4318 \</span><br><span class="line">  -p 14250:14250 \</span><br><span class="line">  -p 14268:14268 \</span><br><span class="line">  -p 14269:14269 \</span><br><span class="line">  -p 9411:9411 \</span><br><span class="line">  jaegertracing/all-in-one:1.56</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run --rm -d -v $(pwd)/coll-config.yaml:/etc/otelcol-contrib/config.yaml --name coll \</span><br><span class="line">-p 5318:4318 \</span><br><span class="line">-p 5317:4317 \</span><br><span class="line">otel/opentelemetry-collector-contrib:0.98.0</span><br></pre></td></tr></table></figure><p>这里有一个 <code>coll-config</code> 的配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">receivers:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">protocols:</span></span><br><span class="line">      <span class="attr">grpc:</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line"><span class="attr">exporters:</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">&quot;127.0.0.1:4317&quot;</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="attr">batch:</span></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">pipelines:</span></span><br><span class="line">    <span class="attr">traces:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">otlp</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">otlp</span>, <span class="string">debug</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重点是这里的 <code>endpoint: &quot;127.0.0.1:4317&quot;</code> 我们需要配置位 Jaeger 的 IP 和端口。</p><blockquote><p>更多关于这里的配置会在后续单独的 collector 章节中讲解。</p></blockquote><p>这两个服务都启动成功后再启动我们的 Java 客户端和  Go  服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.traces.exporter=otlp \</span><br><span class="line">-Dotel.metrics.exporter=otlp \</span><br><span class="line">-Dotel.logs.exporter=none \</span><br><span class="line">-Dotel.service.name=demo \</span><br><span class="line">-Dotel.exporter.otlp.protocol=grpc \</span><br><span class="line">-Dotel.propagators=tracecontext,baggage \</span><br><span class="line">-Dotel.exporter.otlp.endpoint=http://127.0.0.1:5317 \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Golang</span></span><br><span class="line">export OTEL_EXPORTER_OTLP_ENDPOINT=http://127.0.0.1:5317</span><br><span class="line">export OTEL_RESOURCE_ATTRIBUTES=service.name=k8s-combat</span><br><span class="line">./k8s-combat</span><br></pre></td></tr></table></figure><p>可以看到不管是 Java 还是 Golang 应用都是需要配置 <code>OTEL_EXPORTER_OTLP_ENDPOINT</code> 参数，也就是 <code>opentelemetry-collector-contrib</code> 的地址。</p><blockquote><p>其余的一些配置在后面会讲到。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:9191/request\?name\=1232</span><br></pre></td></tr></table></figure><p>然后我们触发一下 Java 客户端的入口，就可以在 JaegerUI 中查询到刚才的链路了。<br><code>http://localhost:16686/search</code></p><p><img src="https://s2.loli.net/2024/07/15/skNmSDJaPfHh3GB.png" alt="image.png"><br><img src="https://s2.loli.net/2024/07/15/xoG2finOmFlDReE.png" alt="image.png"><br>这样整个 <code>trace</code> 链路就串起来了。</p><h1 id="Java-应用"><a href="#Java-应用" class="headerlink" title="Java 应用"></a>Java 应用</h1><p>下面来看看具体的应用代码里是如何编写的。</p><blockquote><p>Java 是基于 springboot 编写的，具体 springboot 的使用就不再赘述了。</p></blockquote><p>因为我们应用是使用 gRPC 通信的，所以需要提供一个 <code>helloworld.proto</code> 的 pb 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;  </span><br><span class="line">  </span><br><span class="line">option go_package = &quot;google.golang.org/grpc/examples/helloworld/helloworld&quot;;  </span><br><span class="line">option java_multiple_files = true;  </span><br><span class="line">option java_package = &quot;io.grpc.examples.helloworld&quot;;  </span><br><span class="line">option java_outer_classname = &quot;HelloWorldProto&quot;;  </span><br><span class="line">  </span><br><span class="line">package helloworld;  </span><br><span class="line">  </span><br><span class="line">// The greeting service definition.  </span><br><span class="line">service Greeter &#123;  </span><br><span class="line">  // Sends a greeting  </span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// The request message containing the user&#x27;s name.  </span><br><span class="line">message HelloRequest &#123;  </span><br><span class="line">  string name = 1;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// The response message containing the greetings  </span><br><span class="line">message HelloReply &#123;  </span><br><span class="line">  string message = 1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件也没啥好说的，就定义了一个简单的 <code>SayHello</code> 接口。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.devh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-stub<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-protobuf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Java 中使用了 <code>grpc-spring-boot-starter</code> 这个库来处理 gRPC 的客户端和服务端请求。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">grpc:</span>  </span><br><span class="line">  <span class="attr">server:</span>  </span><br><span class="line">    <span class="attr">port:</span> <span class="number">9192</span>  </span><br><span class="line">  <span class="attr">client:</span>  </span><br><span class="line">    <span class="attr">greeter:</span>  </span><br><span class="line">      <span class="attr">address:</span> <span class="string">&#x27;static://127.0.0.1:50051&#x27;</span>  </span><br><span class="line">      <span class="attr">enableKeepAlive:</span> <span class="literal">true</span>  </span><br><span class="line">      <span class="attr">keepAliveWithoutCalls:</span> <span class="literal">true</span>  </span><br><span class="line">      <span class="attr">negotiationType:</span> <span class="string">plaintext</span></span><br></pre></td></tr></table></figure><p>然后我们定义了一个接口用于接收请求触发 <code>gRPC</code> 的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/request&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;  </span><br><span class="line">   log.info(<span class="string">&quot;request: &#123;&#125;&quot;</span>, request);    </span><br><span class="line">   <span class="type">HelloReply</span> <span class="variable">abc</span> <span class="operator">=</span> greeterStub.sayHello(io.grpc.examples.helloworld.HelloRequest.newBuilder().setName(request.getName()).build());   </span><br><span class="line">   <span class="keyword">return</span> abc.getMessage();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 应用的实现非常简单，和我们日常日常开发没有任何区别；唯一的区别就是在启动时需要加入一个 <code>javaagent</code>以及一些启动参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.traces.exporter=otlp \</span><br><span class="line">-Dotel.metrics.exporter=otlp \</span><br><span class="line">-Dotel.logs.exporter=none \</span><br><span class="line">-Dotel.service.name=demo \</span><br><span class="line">-Dotel.exporter.otlp.protocol=grpc \</span><br><span class="line">-Dotel.propagators=tracecontext,baggage \</span><br><span class="line">-Dotel.exporter.otlp.endpoint=http://127.0.0.1:5317 \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>下面来仔细看看这些参数</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar</td><td>这个没啥好说的，指定一个 javaagent</td></tr><tr><td>otel.traces.exporter</td><td>指定 trace 以什么格式传输（默认是这里的 <code>otlp</code>)；当然还有其他的值：<code>logging/jaeger/zipkin</code> 等，我们这里使用 otlp 会将数据传输到 collector 中。</td></tr><tr><td>otel.metrics.exporter</td><td>同上，只是指定的是 metrics 的传输方式，我们在之后讲解指标的时候会用到。</td></tr><tr><td>otel.service.name</td><td>定义在 trace 中的应用名称，springboot 会默认使用 <code>spring.application.name</code> 这个变量。</td></tr><tr><td>otel.exporter.otlp.protocol</td><td>指定传输协议；除了 grpc 之外还有 <code>http/protobuf</code>，当然我们也可以根据 trace 和 metrics 分开指定：<code>otel.exporter.otlp.traces.protocol/otel.exporter.otlp.metrics.protocol</code></td></tr><tr><td>otel.propagators</td><td>指定我们跨服务传播上下文的时候使用哪种格式，默认是 <a href="https://www.w3.org/TR/trace-context/">W3C Trace Context</a>,<a href="https://www.w3.org/TR/baggage/">baggage</a>，当然也有其他的- <code>&quot;b3&quot;</code>: <a href="https://github.com/openzipkin/b3-propagation#single-header">B3 Single</a>，- <code>&quot;xray&quot;</code>: <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader">AWS X-Ray</a>，<code>&quot;jaeger&quot;</code>: <a href="https://www.jaegertracing.io/docs/1.21/client-libraries/#propagation-format">Jaeger</a>等</td></tr><tr><td>otel.exporter.otlp.endpoint</td><td>指定 collector 的 endpoint</td></tr><tr><td>更多细节的参数大家可以在这里找到：</td><td></td></tr><tr><td><a href="https://opentelemetry.io/docs/languages/java/configuration/">https://opentelemetry.io/docs/languages/java/configuration/</a></td><td></td></tr></tbody></table><h1 id="Golang-应用"><a href="#Golang-应用" class="headerlink" title="Golang 应用"></a>Golang 应用</h1><p>接着我们来看看 Go 是如何集成 <code>OpenTelemetry</code> 的。</p><p>在创建好项目之后我们需要添加 <code>OpenTelemetry</code> 所提供的包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go get &quot;go.opentelemetry.io/otel&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/propagation&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/sdk/metric&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/sdk/resource&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/sdk/trace&quot; \       &quot;go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc&quot;\</span><br></pre></td></tr></table></figure><p>然后我们需要创建一个初始化 <code>tracer</code> 的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initTracerProvider</span><span class="params">()</span></span> *sdktrace.TracerProvider &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">exporter, err := otlptracegrpc.New(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;new otlp trace grpc exporter failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">tp := sdktrace.NewTracerProvider(</span><br><span class="line">sdktrace.WithBatcher(exporter),</span><br><span class="line">sdktrace.WithResource(initResource()),</span><br><span class="line">)</span><br><span class="line">otel.SetTracerProvider(tp)</span><br><span class="line">otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext&#123;&#125;, propagation.Baggage&#123;&#125;))</span><br><span class="line"><span class="keyword">return</span> tp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们使用的是 <code>grpc</code> 协议上报 <code>otlp</code> 数据，所以这里使用的是 <code>exporter, err := otlptracegrpc.New(ctx)</code>  创建了一个 <code>exporter</code>。</p><p><code>otel.SetTextMapPropagator()</code> 这个函数里配置数据和刚才 Java 里配置的 <code>-Dotel.propagators=tracecontext,baggage</code> 是一样的效果。</p><p>与此同时我们还需要提供一个 <code>initResource()</code> 的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initResource</span><span class="params">()</span></span> *sdkresource.Resource &#123;</span><br><span class="line">initResourcesOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">extraResources, _ := sdkresource.New(</span><br><span class="line">context.Background(),</span><br><span class="line">sdkresource.WithOS(),</span><br><span class="line">sdkresource.WithProcess(),</span><br><span class="line">sdkresource.WithContainer(),</span><br><span class="line">sdkresource.WithHost(),</span><br><span class="line">)</span><br><span class="line">resource, _ = sdkresource.Merge(</span><br><span class="line">sdkresource.Default(),</span><br><span class="line">extraResources,</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数用来告诉 trace 需要暴露那些 resource，也就是我们在这里看到进程相关的属性：<br><img src="https://s2.loli.net/2024/07/15/Gveu4hNjWdYLiBo.png" alt="image.png"><br>比如这里的 <code>sdkresource.WithOS(),</code> 就会显示 OS 的类型和描述。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithOS</span><span class="params">()</span></span> Option &#123;  </span><br><span class="line">    <span class="keyword">return</span> WithDetectors(  </span><br><span class="line">       osTypeDetector&#123;&#125;,  </span><br><span class="line">       osDescriptionDetector&#123;&#125;,  </span><br><span class="line">    )&#125;</span><br></pre></td></tr></table></figure><p>而 <code>sdkresource.WithProcess(),</code> 显示的数据就更多了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithProcess</span><span class="params">()</span></span> Option &#123;  </span><br><span class="line">    <span class="keyword">return</span> WithDetectors(  </span><br><span class="line">       processPIDDetector&#123;&#125;,  </span><br><span class="line">       processExecutableNameDetector&#123;&#125;,  </span><br><span class="line">       processExecutablePathDetector&#123;&#125;,  </span><br><span class="line">       processCommandArgsDetector&#123;&#125;,  </span><br><span class="line">       processOwnerDetector&#123;&#125;,  </span><br><span class="line">       processRuntimeNameDetector&#123;&#125;,  </span><br><span class="line">       processRuntimeVersionDetector&#123;&#125;,  </span><br><span class="line">       processRuntimeDescriptionDetector&#123;&#125;,  </span><br><span class="line">    )&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上这些代码在 Java 中都是由 agent 指定创建的。</p></blockquote><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init OpenTelemetry start  </span></span><br><span class="line">tp := initTracerProvider()  </span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> err := tp.Shutdown(context.Background()); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Printf(<span class="string">&quot;Error shutting down tracer provider: %v&quot;</span>, err)  </span><br><span class="line">    &#125;&#125;()  </span><br><span class="line">   </span><br><span class="line">err := runtime.Start(runtime.WithMinimumReadMemStatsInterval(time.Second))  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    log.Err(err)  </span><br><span class="line">&#125;</span><br><span class="line">tracer = tp.Tracer(<span class="string">&quot;k8s-combat&quot;</span>)</span><br><span class="line"><span class="comment">// Init OpenTelemetry end</span></span><br></pre></td></tr></table></figure><p>之后我们需要在 main 函数一开始就初始化 <code>traceProvider</code>。</p><p>对于 <code>grpc</code> 来说，<code>OpenTelemetry</code> 的 Go-SDK 提供了自动埋点，但我们也得手动配置一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := grpc.NewServer(  </span><br><span class="line">    grpc.StatsHandler(otelgrpc.NewServerHandler()),  </span><br><span class="line">)  </span><br><span class="line">pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br></pre></td></tr></table></figure><p>使用 <code>grpc.StatsHandler(otelgrpc.NewServerHandler()),</code>  将 <code>OTel</code> 的 <code>serverHandle</code> 加入进去，这个 handle 会自动创建 <code>grpc</code> 服务端的 <code>span</code>。</p><blockquote><p>对 trace&#x2F;span 概念还有不了解的朋友可以查看这篇<a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">文章</a>。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> port = <span class="string">&quot;:50051&quot;</span>  </span><br><span class="line">lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    log.Fatal().Msgf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)  </span><br><span class="line">&#125;  </span><br><span class="line">s := grpc.NewServer(  </span><br><span class="line">    grpc.StatsHandler(otelgrpc.NewServerHandler()),  </span><br><span class="line">)  </span><br><span class="line">pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)  </span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    log.Fatal().Msgf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    log.Printf(<span class="string">&quot;served on %s \n&quot;</span>, port)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们只需要启动这个 grpc 服务即可，就算完成了 Go 服务的集成。</p><p>从这里可以看出 Java 相对于 Go 来说会简单许多，只需要配置一个 agent 就可以不该一行代码支持目前市面上流行的绝大多数框架。<br><img src="https://s2.loli.net/2024/04/17/kMDcrPwxJy4oZYe.png"></p><h1 id="自定义-span-的-attribute"><a href="#自定义-span-的-attribute" class="headerlink" title="自定义  span 的 attribute"></a>自定义  span 的 attribute</h1><p>我们在看链路信息的时候其实看的最多的是某个 <code>span</code> 里的 <code>attribute</code> 数据（有些地方又称为 <code>tag</code>)<br>如下图所示：<br><img src="https://s2.loli.net/2024/07/15/jrdkNCAZhi6UIvP.png"></p><p>这里会展示当前 <code>span</code> 的各种信息，但如果我们想要额外加一些自己关心的数据应该如何添加呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message HelloRequest &#123;  </span><br><span class="line">  string name = 1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们想知道这个 grpc 接口里的 name 参数，如上图所示那样展示在 span 中。</p><p>好在 <code>OpenTelemetry</code> 已经考虑到类似的需求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">span := trace.SpanFromContext(ctx)  </span><br><span class="line">span.SetAttributes(attribute.String(<span class="string">&quot;request.name&quot;</span>, in.Name))</span><br></pre></td></tr></table></figure><p>我们使用 <code>span := trace.SpanFromContext(ctx)</code>  获取到当前的 span，然后调用 <code>SetAttributes</code> 就可以添加自定义的数据了。</p><blockquote><p>对应的 Java 也有类似的函数。</p></blockquote><p>除了新增 <code>attribute</code> 之外还可以新增 Event，Link 等数据，使用方式也是类似的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddEvent adds an event with the provided name and options.  </span></span><br><span class="line">AddEvent(name <span class="type">string</span>, options ...EventOption)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// AddLink adds a link.  </span></span><br><span class="line"><span class="comment">// Adding links at span creation using WithLinks is preferred to calling AddLink  </span></span><br><span class="line"><span class="comment">// later, for contexts that are available during span creation, because head  </span></span><br><span class="line"><span class="comment">// sampling decisions can only consider information present during span creation.  </span></span><br><span class="line">AddLink(link Link)</span><br></pre></td></tr></table></figure><h1 id="自定义新增-span"><a href="#自定义新增-span" class="headerlink" title="自定义新增 span"></a>自定义新增 span</h1><p>同理我们可能不局限于为某个 span 新增 attribute，也有可能想要新增一个新的 span 来记录关键的调用信息。</p><blockquote><p>默认情况下只有 OpenTelemetry 实现过的组件的核心函数才会有 span，自己代码里的函数调用是不会创建span 的。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> span(ctx context.Context) &#123;  </span><br><span class="line">    ctx, span := tracer.Start(ctx, <span class="string">&quot;hello-span&quot;</span>)  </span><br><span class="line">    <span class="keyword">defer</span> span.End()  </span><br><span class="line">    <span class="comment">// do some work  </span></span><br><span class="line">    log.Printf(<span class="string">&quot;create span&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在  Go 中只需要手动 Start 一个 span 即可。</p><p>对应到 <code>Java</code> 稍微简单一些，只需要为函数添加一个注解即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WithSpan(&quot;span&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">span</span><span class="params">(<span class="meta">@SpanAttribute(&quot;request.name&quot;)</span> String name)</span> &#123;  </span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);  </span><br><span class="line">    log.info(<span class="string">&quot;span:&#123;&#125;&quot;</span>, name);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过得单独引入一个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.opentelemetry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opentelemetry-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.opentelemetry.instrumentation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opentelemetry-instrumentation-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终我们在 Jaeger UI 上看到的效果如下：</p><p><img src="https://s2.loli.net/2024/07/15/1tLlYezQwInZWDX.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://s2.loli.net/2024/07/15/WXPp1MUkdHo4zam.png"></p><p>最后总结一下，OpenTelemetry 支持许多流行的语言，主要分为两类：是否支持自动埋点。</p><p><img src="https://s2.loli.net/2024/07/15/fvu67rdoxtZkq5m.png"></p><blockquote><p>这里 Go 也可以零代码埋点，是使用了 eBPF，本文暂不做介绍。</p></blockquote><p>对于支持自动埋点的语言就很简单，只需要配置下 agent 即可；而原生的 Go 语言不支持自动埋点就得手动使用 OpenTelemetry 提供的 SDK 处理一些关键步骤；总体来说也不算复杂。</p><p>下一期会重点讲解如何使用 Metrics。</p><p>感兴趣的朋友可以在这里查看 Go 相关的源码：</p><ul><li><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></li></ul><p>参考链接：</p><ul><li><a href="https://opentelemetry.io/docs/languages/java/configuration/">https://opentelemetry.io/docs/languages/java/configuration/</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md">https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md</a></li><li><a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前写过一篇 &lt;a href=&quot;https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/&quot;&gt;从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅&lt;/a&gt;的文章，主要是从概念上讲解了 Trace 在 OpenTelemetry 的中的场景和使用。&lt;/p&gt;
&lt;p&gt;也写过一篇 &lt;a href=&quot;https://crossoverjie.top/2024/05/26/ob/OTel-demo/&quot;&gt;实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术&lt;/a&gt;：如何从一个 demo 开始集成 OpenTelemetry。&lt;/p&gt;
&lt;p&gt;但还是有不少小伙伴反馈说无法快速上手（可能也是这个 demo 的项目比较多），于是我准备从 0 开始从真实的代码一步步带大家集成 &lt;code&gt;OpenTelemetry&lt;/code&gt;，因为 OpenTelemetry 本身是跨多种语言的，所以也会以两种语言为（Java、Golang）主进行讲解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用这两种语言主要是因为 Java 几乎全是自动埋点，而 Golang 因为语言特性，大部分都得硬编码埋点；覆盖到这两种场景后其他语言也是类似的，顶多只是 API 名称有些许区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这个过程中也会穿插一些 OpenTelemetry 的原理，希望整个过程下来大家可以在项目中实际运用起来，同时也能知其所以然。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>深入理解单元测试：技巧与最佳实践</title>
    <link href="http://crossoverjie.top/2024/08/15/ob/unit-test/"/>
    <id>http://crossoverjie.top/2024/08/15/ob/unit-test/</id>
    <published>2024-08-15T02:43:09.000Z</published>
    <updated>2024-08-14T13:55:07.855Z</updated>
    
    <content type="html"><![CDATA[<p>之前分享过如何快速上手开源项目以及如何在开源项目里做集成测试，但还没有讲过具体的实操。</p><p>今天来详细讲讲如何写单元测试。</p><h1 id="🤔什么情况下需要单元测试"><a href="#🤔什么情况下需要单元测试" class="headerlink" title="🤔什么情况下需要单元测试"></a>🤔什么情况下需要单元测试</h1><p>这个大家应该是有共识的，对于一些功能单一、核心逻辑、同时变化不频繁的公开函数才有必要做单元测试。</p><p>对于业务复杂、链路繁琐但也是核心流程的功能通常建议做 e2e 测试，这样可以保证最终测试结果的一致性。</p><span id="more"></span><h1 id="💀具体案例"><a href="#💀具体案例" class="headerlink" title="💀具体案例"></a>💀具体案例</h1><p>我们都知道单测的主要目的是模拟执行你写过的每一行代码，目的就是要覆盖到主要分支，做到自己的每一行代码都心中有数。</p><p>下面以 <code>Apache HertzBeat</code> 的一些单测为例，讲解如何编写一个单元测试。</p><p><img src="https://s2.loli.net/2024/07/02/SbqCvHVZk6f5tB1.png"><br>先以一个最简单的 <code>org.apache.hertzbeat.collector.collect.udp.UdpCollectImpl#preCheck</code> 函数测试为例。<br>这里的 <code>preCheck</code> 函数就是简单的检测做参数校验。<br>测试时只要我们手动将 <code>metrics</code> 设置为 <code>null</code> 就可以进入这个 if 条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UdpCollectImplTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> UdpCollectImpl udpCollect;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testPreCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; aliasField = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        aliasField.add(<span class="string">&quot;responseTime&quot;</span>);</span><br><span class="line">        <span class="type">Metrics</span> <span class="variable">metrics</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Metrics</span>();</span><br><span class="line">        metrics.setAliasFields(aliasField);</span><br><span class="line">        assertThrows(IllegalArgumentException.class, () -&gt; udpCollect.preCheck(metrics));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>来看具体的单测代码，我们一行行的来看：</p><p><code>@ExtendWith(MockitoExtension.class)</code> 是 <code>Junit5</code> 提供的一个注解，里面传入的 <code>MockitoExtension.class</code> 是我们单测 mock 常用的框架。</p><p>简单来说就是告诉 <code>Junit5</code> ，当前的测试类会使用 mockito 作为扩展运行，从而可以 <code>mock</code> 我们运行时的一些对象。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InjectMocks</span>  </span><br><span class="line"><span class="keyword">private</span> UdpCollectImpl udpCollect;</span><br></pre></td></tr></table></figure><p><code>@InjectMocks</code> 也是 <code>mockito</code> 这个库提供的注解，通常用于声明需要测试的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InjectMocks</span>  </span><br><span class="line"><span class="keyword">private</span> AbstractCollect udpCollect;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/02/zSocET9f5y6lqC3.png"></p><p>需要注意的是这个注解必须是一个具体的类，不可以是一个抽象类或者是接口。</p><p>其实当我们了解了他的原理就能知道具体的原因：<br><img src="https://s2.loli.net/2024/07/02/5DwRyVsBHd1EmpA.png"></p><p>当我们 debug 运行时会发现 <code>udpCollect</code> 对象是有值的，而如果我们去掉这个注解 <code>@InjectMocks</code> 再运行就会抛空指针异常。</p><blockquote><p>因为并没有初始化 udpCollect</p></blockquote><p>而使用 <code>@InjectMocks</code>注解后，<code>mockito</code> 框架会自动给 <code>udpCollect</code> 注入一个代理对象；而如果是一个接口或者是抽象类，mockito 框架是无法知道创建具体哪个对象。</p><p>当然在这个简单场景下，我们直接 <code>udpCollect = new UdpCollectImpl()</code> 进行测试也是可以的。</p><h1 id="🔥配合-jacoco-输出单测覆盖率"><a href="#🔥配合-jacoco-输出单测覆盖率" class="headerlink" title="🔥配合 jacoco 输出单测覆盖率"></a>🔥配合 jacoco 输出单测覆盖率</h1><p><img src="https://s2.loli.net/2024/07/02/fgv3O4RbnHsQTWV.png"><br><img src="https://s2.loli.net/2024/07/02/coXOGkjyE2zKsYa.png"></p><p>在 IDEA 中我们可以以 <code>Coverage</code> 的方式运行，<code>IDEA</code> 就将我们的单测覆盖情况显示在源代码中，绿色的部分就代表在实际在运行时执行到的地方。</p><p>我们也可以在 <code>maven</code> 项目中集成 <code>jacoco</code>，只需要添加一个根目录的 <code>pom.xml</code> 中添加一个 <code>plugin</code> 就可以了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jacoco<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jacoco-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jacoco-maven-plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>prepare-agent<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>report<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>test<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>report<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后运行 <code>mvn test</code> 就会在 target 目录下生成测试报告了。</p><p><img src="https://s2.loli.net/2024/07/02/GiBrPjtLcXhgDbp.png"></p><p>我们还可以在 GitHub 的 CI 中集成 <code>Codecov</code>，他会直接读取 jacoco 的测试数据，并且在 PR 的评论区加上测试报告。<br><img src="https://s2.loli.net/2024/07/02/ujdGke4gf5mAW3x.png"></p><p><img src="https://s2.loli.net/2024/07/02/nFt5SukAjMPZ96W.png"></p><p><img src="https://s2.loli.net/2024/07/02/KcXJUs3mehxFAYz.png"></p><p>需要从 <code>Codecov</code> 里将你项目的 token 添加到 repo 的 环境变量中即可。</p><p>具体可以参考这个 PR：<a href="https://github.com/apache/hertzbeat/pull/1985">https://github.com/apache/hertzbeat/pull/1985</a></p><h1 id="☀️复杂一点的单测"><a href="#☀️复杂一点的单测" class="headerlink" title="☀️复杂一点的单测"></a>☀️复杂一点的单测</h1><p>刚才展示的是一个非常简单的场景，下面来看看稍微复杂的。</p><p>我们以这个单测为例：<br><code>org.apache.hertzbeat.collector.collect.redis.RedisClusterCollectImplTest</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClusterCollectImplTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> RedisCommonCollectImpl redisClusterCollect;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> StatefulRedisClusterConnection&lt;String, String&gt; connection;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> RedisAdvancedClusterCommands&lt;String, String&gt; cmd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> RedisClusterClient client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个单测在刚才的基础上多了一个 <code>@Mock</code> 的注解。</p><p>这是因为我们需要测试的 <code>RedisCommonCollectImpl</code> 类中需要依赖 <code>StatefulRedisClusterConnection/RedisAdvancedClusterCommands/RedisClusterClient</code> 这几个类所提供的服务。</p><p>单测的时候需要使用 <code>mockito</code> 创建一个他们的对象，并且注入到需要被测试的 <code>RedisCommonCollectImpl</code>类中。</p><blockquote><p>不然我们就需要准备单测所需要的资源，比如可以使用的 Redis、MySQL 等。</p></blockquote><h2 id="🚤模拟行为"><a href="#🚤模拟行为" class="headerlink" title="🚤模拟行为"></a>🚤模拟行为</h2><p>只是注入进去还不够，我们还需要模拟它的行为：</p><ul><li>比如调用某个函数可以模拟返回数据</li><li>模拟函数调用抛出异常</li><li>模拟函数调用耗时</li></ul><p>这里以最常见的模拟函数返回为例：</p><p><img src="https://s2.loli.net/2024/07/02/3lnFxsQmcWqao5u.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">clusterNodes</span> <span class="operator">=</span> connection.sync().clusterInfo();</span><br></pre></td></tr></table></figure><p>在源码里看到会使用 connection 的 <code>clusterInfo()</code> 函数返回集群信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">clusterKnownNodes</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">clusterInfoTemp</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        cluster_slots_fail:0</span></span><br><span class="line"><span class="string">        cluster_known_nodes:%s</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">clusterInfo</span> <span class="operator">=</span> String.format(clusterInfoTemp, clusterKnownNodes);</span><br><span class="line">Mockito.when(cmd.clusterInfo()).thenReturn(clusterInfo);        </span><br></pre></td></tr></table></figure><p>此时我们就可以使用 <code>Mockito.when().thenReturn()</code> 来模拟这个函数的返回数据。</p><p>而其中的 <code>cmd</code> 自然也是需要模拟返回的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Mockito.mockStatic(RedisClusterClient.class).when(()-&gt;RedisClusterClient.create(Mockito.any(ClientResources.class),</span><br><span class="line">        Mockito.any(RedisURI.class))).thenReturn(client);</span><br><span class="line">Mockito.when(client.connect()).thenReturn(connection);</span><br><span class="line"></span><br><span class="line">Mockito.when(connection.sync()).thenReturn(cmd);</span><br><span class="line">Mockito.when(cmd.info(metrics.getName())).thenReturn(info);</span><br><span class="line">Mockito.when(cmd.clusterInfo()).thenReturn(clusterInfo);</span><br></pre></td></tr></table></figure><p><code>cmd</code> 是通过 <code>Mockito.when(connection.sync()).thenReturn(cmd);</code>返回的，而 <code>connection</code> 又是从 <code>client.connect()</code> 返回的。</p><p>最终就像是套娃一样，<code>client</code> 在源码中是通过一个静态函数创建的。</p><h3 id="⚡模拟静态函数"><a href="#⚡模拟静态函数" class="headerlink" title="⚡模拟静态函数"></a>⚡模拟静态函数</h3><p>我依稀记得在我刚接触 <code>mockito</code> 的 16～17 年那段时间还不支持模拟调用静态函数，不过如今已经支持了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mock</span>  </span><br><span class="line"><span class="keyword">private</span> RedisClusterClient client;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mockito.mockStatic(RedisClusterClient.class).when(()-&gt;RedisClusterClient.create(Mockito.any(ClientResources.class),  </span><br><span class="line">        Mockito.any(RedisURI.class))).thenReturn(client);</span><br></pre></td></tr></table></figure><p>这样就可以模拟静态函数的返回值了，但前提是返回的 <code>client</code> 需要使用 <code>@Mock</code> 注解。</p><h3 id="💥模拟构造函数"><a href="#💥模拟构造函数" class="headerlink" title="💥模拟构造函数"></a>💥模拟构造函数</h3><p><img src="https://s2.loli.net/2024/07/02/aFiCLRyYh4IU83o.png"><br>有时候我们也需要模拟构造函数，从而可以模拟后续这个对象的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MockedConstruction&lt;FTPClient&gt; mocked = Mockito.mockConstruction(FTPClient.class,</span><br><span class="line">        (ftpClient, context) -&gt; &#123;</span><br><span class="line">            Mockito.doNothing().when(ftpClient).connect(ftpProtocol.getHost(),</span><br><span class="line">                    Integer.parseInt(ftpProtocol.getPort()));</span><br><span class="line"></span><br><span class="line">            Mockito.doAnswer(invocationOnMock -&gt; <span class="literal">true</span>).when(ftpClient)</span><br><span class="line">                    .login(ftpProtocol.getUsername(), ftpProtocol.getPassword());</span><br><span class="line">            Mockito.when(ftpClient.changeWorkingDirectory(ftpProtocol.getDirection())).thenReturn(isActive);</span><br><span class="line">            Mockito.doNothing().when(ftpClient).disconnect();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>可以使用 <code>Mockito.mockConstruction</code> 来进行模拟，该对象的一些行为就直接写在这个模拟函数内。</p><p>需要注意的是返回的 <code>mocked</code> 对象需要记得关闭。</p><h3 id="不需要-Mock"><a href="#不需要-Mock" class="headerlink" title="不需要 Mock"></a>不需要 Mock</h3><p>当然也不是所有的场景都需要 <code>mock</code>。</p><p>比如刚才第一个场景，没有依赖任何外部服务时就不需要 <code>mock</code>。</p><p><img src="https://s2.loli.net/2024/07/02/mW3gxERBc4qoz2L.png"></p><p>类似于这个 <a href="https://github.com/apache/hertzbeat/pull/2021">PR</a> 里的测试，只是依赖一个基础的内存缓存组件，就没必要 mock，但如果依赖的是 <code>Redis</code> 缓存组件还是需要 mock 的。<br><a href="https://github.com/apache/hertzbeat/pull/2021">https://github.com/apache/hertzbeat/pull/2021</a></p><h3 id="⚙️修改源码"><a href="#⚙️修改源码" class="headerlink" title="⚙️修改源码"></a>⚙️修改源码</h3><p>如果有些测试场景下需要获取内部变量方便后续的测试，但是该测试类也没有提供获取变量的函数，我们就只有修改源码来配合测试了。</p><p>比如这个 <a href="https://github.com/apache/hertzbeat/pull/">PR</a>：<br><img src="https://s2.loli.net/2024/07/02/bxfQgsymWVcnawE.png"></p><p>当然如果只是给测试环境下使用的函数或变量，我们可以加上 <code>@VisibleForTesting</code>注解标明一下，这个注解没有其他作用，可以让后续的维护者更清楚的知道这是做什么用的。</p><h1 id="📈集成测试"><a href="#📈集成测试" class="headerlink" title="📈集成测试"></a>📈集成测试</h1><p>单元测试只能测试一些功能单一的函数，要保证整个软件的质量仅依赖单测是不够的，我们还需要集成测试。</p><p>通常是需要对外提供服务的开源项目都需要集成测试：</p><ul><li>Pulsar</li><li>Kafka</li><li>Dubbo 等</li></ul><p>以我接触到的服务型应用主要分为两类：一个是 Java 应用一个是 Golang 应用。</p><h1 id="🐳Golang"><a href="#🐳Golang" class="headerlink" title="🐳Golang"></a>🐳Golang</h1><p><img src="https://s2.loli.net/2024/07/11/vZISu9Qg3foKhsU.png"></p><p><code>Golang</code> 因为工具链没有 Java 那么强大，所以大部分的集成测试的功能都是通过编写 Makefile 和 shell 脚本实现的。</p><p>还是以我熟悉的 Pulsar 的 <code>go-client</code> 为例，它在 GitHub 的集成测试是通过 GitHub action 触发的，定义如下：<br><img src="https://s2.loli.net/2024/05/20/f2196pujo8m7KRe.png"><br>最终调用的是 Makefile 中的 test 命令，并且把需要测试的 Golang 版本传入进去。</p><p><img src="https://s2.loli.net/2024/05/20/YpwtSHnLXqU1xQj.png"></p><p><code>Dockerfile</code>：<br><img src="https://s2.loli.net/2024/05/20/1ySGWF46U7EC2rk.png"></p><p>这个镜像简单来说就是将 Pulsar 的镜像作为基础运行镜像（这里面包含了 Pulsar 的服务端），然后将这个 pulsar-client-go 的代码复制进去编译。</p><p>接着运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /pulsar/pulsar-client-go &amp;&amp; ./scripts/run-ci.sh</span><br></pre></td></tr></table></figure><p>也就是测试脚本。</p><p><img src="https://s2.loli.net/2024/05/20/2Afmdu8ozRvH9FC.png"></p><p>测试脚本的逻辑也很简单：</p><ul><li>启动 pulsar 服务端</li><li>运行测试代码<br>因为所有的测试代码里连接服务端的地址都是 <code>localhost</code>，所以可以直接连接。<br><img src="https://s2.loli.net/2024/05/20/C1RHxTkuz25Mlj8.png"></li></ul><p>通过这里的 <a href="https://github.com/apache/pulsar-client-go/actions/runs/9014510238/job/24768797555">action</a> 日志可以跟踪所有的运行情况。</p><h1 id="☕Java"><a href="#☕Java" class="headerlink" title="☕Java"></a>☕Java</h1><p><img src="https://s2.loli.net/2024/07/11/KlqzSwJ6f895A4n.png"></p><p>Java 因为工具链强大，所以集成测试几乎不需要用 Makefile 和脚本配合执行。</p><p>还是以 Pulsar 为例，它的集成测试是需要模拟在本地启动一个服务端（因为 Pulsar 的服务端源码和测试代码都是 Java 写的，更方便做测试），然后再运行测试代码。</p><blockquote><p>这个的好处是任何一个单测都可以在本地直接运行，而  Go 的代码还需要先在本地启动一个服务端，测试起来比较麻烦。</p></blockquote><p>来看看它是如何实现的，我以其中一个 <a href="https://github.com/apache/pulsar/blob/631b13ad23d7e48c6e82d38f97c23d129062cb7c/pulsar-broker/src/test/java/org/apache/pulsar/client/impl/BrokerClientIntegrationTest.java#L117">BrokerClientIntegrationTest</a>为例：<br><img src="https://s2.loli.net/2024/05/20/9PbioA3RQLMBy6J.png"><br><img src="https://s2.loli.net/2024/05/20/blKePdxTUIkgRD3.png"><br>会在单测启动的时候先启动服务端。</p><p><img src="https://s2.loli.net/2024/05/20/gzY3lyTGuEDUwZF.png"></p><p>最终会调用 <code>PulsarTestContext</code> 的 <code>build</code> 函数启动 <code>broker</code>（服务端），而执行单测也只需要使用 <code>mvn test</code> 就可以自动触发这些单元测试。<br><img src="https://s2.loli.net/2024/05/20/N15amZihWI73Qyw.png"><br>只是每一个单测都需要启停服务端，所以要把 Pulsar 的所有单测跑完通常需要 1～2 个小时。</p><p>以上就是日常编写单测可能会碰到的场景，希望对大家有所帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前分享过如何快速上手开源项目以及如何在开源项目里做集成测试，但还没有讲过具体的实操。&lt;/p&gt;
&lt;p&gt;今天来详细讲讲如何写单元测试。&lt;/p&gt;
&lt;h1 id=&quot;🤔什么情况下需要单元测试&quot;&gt;&lt;a href=&quot;#🤔什么情况下需要单元测试&quot; class=&quot;headerlink&quot; title=&quot;🤔什么情况下需要单元测试&quot;&gt;&lt;/a&gt;🤔什么情况下需要单元测试&lt;/h1&gt;&lt;p&gt;这个大家应该是有共识的，对于一些功能单一、核心逻辑、同时变化不频繁的公开函数才有必要做单元测试。&lt;/p&gt;
&lt;p&gt;对于业务复杂、链路繁琐但也是核心流程的功能通常建议做 e2e 测试，这样可以保证最终测试结果的一致性。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="单测" scheme="http://crossoverjie.top/tags/%E5%8D%95%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>Pulsar升级自动化：一键搞定集群升级与测试</title>
    <link href="http://crossoverjie.top/2024/08/06/ob/Pulsar%20test%20framework/"/>
    <id>http://crossoverjie.top/2024/08/06/ob/Pulsar%20test%20framework/</id>
    <published>2024-08-06T03:15:50.000Z</published>
    <updated>2024-08-06T02:22:27.446Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/07/01/xZSMlpJPWTRGkge.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于我在公司内部负责维护 <code>Pulsar</code>，需要时不时的升级 <code>Pulsar</code> 版本从而和社区保持一致。</p><p>而每次升级过程都需要做相同的步骤：</p><ul><li>安装一个新版本的集群</li><li>触发功能性测试</li><li>触发性能测试</li><li>查看监控是否正常<ul><li>应用有无异常日志</li><li>流量是否正常</li><li>各个组件的内存占用是否正常</li><li>写入延迟是否正常</li></ul></li></ul><span id="more"></span><h1 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><p>以上的流程步骤最好是全部一键完成，我们只需要人工检测下监控是否正常即可。</p><p>于是我便写了一个命令行工具，执行流程如下：<br><img src="https://s2.loli.net/2024/07/01/cmXCqk6nyj2DpZA.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pulsar-upgrade-cli -h                                                                                                  ok | at 10:33:18 </span><br><span class="line">A cli app for upgrading Pulsar</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  pulsar-upgrade-cli [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  completion  Generate the autocompletion script for the specified shell</span><br><span class="line">  help        Help about any command</span><br><span class="line">  install     install a target version</span><br><span class="line">  scale       scale statefulSet of the cluster</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">      --burst-limit int                 client-side default throttling limit (default 100)</span><br><span class="line">      --debug                           enable verbose output</span><br><span class="line">  -h, --help                            help for pulsar-upgrade-cli</span><br><span class="line">      --kube-apiserver string           the address and the port for the Kubernetes API server</span><br><span class="line">      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.</span><br><span class="line">      --kube-as-user string             username to impersonate for the operation</span><br></pre></td></tr></table></figure><p>真实使用的 <code>example</code> 如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pulsar-upgrade-cli install \                                                   </span><br><span class="line">        --values ./charts/pulsar/values.yaml \</span><br><span class="line">        --set namespace=pulsar-test \</span><br><span class="line">        --set initialize=true \</span><br><span class="line">        --debug \</span><br><span class="line">        --test-case-schema=http \</span><br><span class="line">        --test-case-host=127.0.0.1 \</span><br><span class="line">        --test-case-port=9999 \</span><br><span class="line">    pulsar-test ./charts/pulsar -n pulsar-test</span><br></pre></td></tr></table></figure><p>它的安装命令非常类似于 <code>helm</code>，也是直接使用 helm 的 <code>value.yaml</code> 进行安装；只是在安装成功后（等待所有的 Pod 都处于 Running 状态）会再触发 test-case 测试，也就是请求一个 endpoint。</p><blockquote><p>这个 endpoint 会在内部处理所有的功能测试和性能测试，具体细节就在后文分析。</p></blockquote><p>同时还提供了一个 scale（扩、缩容） 命令，可以用修改集群规模：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缩容集群规模为0</span></span><br><span class="line">./pulsar-upgrade-cli scale --replicase 0 -n pulsar-test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缩容为最小集群</span></span><br><span class="line">./pulsar-upgrade-cli scale --replicase 1 -n pulsar-test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复为最满集群</span></span><br><span class="line">./pulsar-upgrade-cli scale --replicase 2 -n pulsar-test</span><br></pre></td></tr></table></figure><p>这个需求是因为我们的 <code>Pulsar</code> 测试集群部署在了一个 <code>servless</code> 的 <code>kubernetes</code> 集群里，它是按照使用量收费的，所以在我不需要的使用的时候可以通过这个命令将所有的副本数量修改为 0，从而减少使用成本。</p><p>当只需要做简单的功能测试时便回将集群修改为最小集群，将副本数修改为只可以提供服务即可。</p><p>而当需要做性能测试时就需要将集群修改为最高配置。</p><p>这样可以避免每次都安装新集群，同时也可以有效的减少测试成本。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">require (  </span><br><span class="line">    github.com/spf13/cobra v1<span class="number">.6</span><span class="number">.1</span>  </span><br><span class="line">    github.com/spf13/pflag v1<span class="number">.0</span><span class="number">.5</span>   </span><br><span class="line">    helm.sh/helm/v3 v3<span class="number">.10</span><span class="number">.2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个命令行工具本质上是参考了 helm 的命令行实现的，所有主要也是依赖了 <code>helm</code> 和 <code>cobra</code>。</p><p><img src="https://s2.loli.net/2024/07/01/rouTSUBDIWciElx.png"><br>下面以最主要的安装命令为例，核心的是以下的步骤：</p><ul><li>执行 <code>helm</code> 安装（这里是直接使用的 helm 的源码逻辑进行安装）</li><li>等待所有的 <code>Pod</code> 成功运行</li><li>触发 <code>test-case</code> 执行</li><li>等待测试用例执行完毕</li><li>检测是否需要卸载安装的集群</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *installEvent)</span></span> FinishInstall(cfg *action.Configuration, name <span class="type">string</span>) <span class="type">error</span> &#123;  </span><br><span class="line">    bar.Increment()  </span><br><span class="line">    bar.Finish()  </span><br><span class="line">  </span><br><span class="line">    clientSet, err := cfg.KubernetesClientSet()  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> err  </span><br><span class="line">    &#125;  </span><br><span class="line">    ctx := context.Background()  </span><br><span class="line">    ip, err := GetServiceExternalIp(ctx, clientSet, settings.Namespace(), fmt.Sprintf(<span class="string">&quot;%s-proxy&quot;</span>, name))  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> err  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    token, err := GetPulsarProxyToken(ctx, clientSet, settings.Namespace(), fmt.Sprintf(<span class="string">&quot;%s-token-proxy-admin&quot;</span>, name))  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> err  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// trigger testcase  </span></span><br><span class="line">    err = e.client.Trigger(context.Background(), ip, token)  </span><br><span class="line">    <span class="keyword">return</span> err  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>FinishInstall</code> 需要获取到新安装的 Pulsar 集群的 proxy IP 地址和鉴权所使用的 <code>token</code>(<code>GetServiceExternalIp()</code>&#x2F;<code>GetPulsarProxyToken()</code>)。</p><p>将这两个参数传递给 <code>test-case</code> 才可以构建出 <code>pulsar-client</code>.</p><p>这个命令的核心功能就是安装集群和触发测试，以及一些集群的基本运维能力。</p><h1 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h1><p>而关于这里的测试用例也有一些小伙伴咨询过，如何对 Pulsar 进行功能测试。</p><p>其实 Pulsar 源码中已经包含了几乎所有我们会使用到的测试代码，理论上只要新版本的官方镜像已经推送了那就是跑了所有的单测，质量是可以保证的。</p><p>那为什么还需要做功能测试呢？</p><p>其实很很简单，<code>Pulsar</code> 这类基础组件官方都有提供基准测试，但我们想要用于生产环境依然需要自己做压测得出一份属于自己环境下的性能测试报告；</p><p>根本目的是要看在自己的业务场景下是否可以满足（包括公司的软硬件，不同的业务代码）。</p><p>所以这里的功能测试代码有一个很重要的前提就是：<strong>需要使用真实的业务代码进行测试</strong>。</p><p>也就是业务在线上使用与 Pulsar 相关的代码需要参考功能测试里的代码实现，不然有些问题就无法在测试环节覆盖到。</p><blockquote><p>这里我就踩过坑，因为在功能测试里用的是官方的 example 代码进行测试的，自然是没有问题；但业务在实际使用时，使用到了一个 Schema 的场景，并没有在功能测试里覆盖到（官方的测试用例里也没有😂），就导致升级到某个版本后业务功能无法正常使用（虽然用法确实是有问题），但应该在我测试阶段就暴露出来。</p></blockquote><h2 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h2><p><img src="https://s2.loli.net/2024/07/01/3vZiGABjkYh5LUJ.png"><br>以上是一个集群的功能测试报告，这里我只有 8 个测试场景（结合实际业务使用），考虑到未来可能会有新的测试用例，所以在设计这个测试框架时就得考虑到扩展性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job5</span> <span class="operator">=</span>  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FailoverConsumerTest</span>(event, <span class="string">&quot;故障转移消费测试&quot;</span>, pulsarClient, <span class="number">20</span>, admin);  </span><br><span class="line">CompletableFuture&lt;Void&gt; c5 = CompletableFuture.runAsync(job5::start, EXECUTOR);  </span><br><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchemaTest</span>(event,<span class="string">&quot;schema测试&quot;</span>,pulsarClient,<span class="number">20</span>,prestoService);  </span><br><span class="line">CompletableFuture&lt;Void&gt; c6 = CompletableFuture.runAsync(job6::start, EXECUTOR);  </span><br><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VlogsTest</span>(event,<span class="string">&quot;vlogs test&quot;</span>,pulsarClient,<span class="number">20</span>, vlogsUrl);  </span><br><span class="line">CompletableFuture&lt;Void&gt; c7 = CompletableFuture.runAsync(job7::start, EXECUTOR);  </span><br><span class="line">  </span><br><span class="line">CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(c1, c2, c3, c4, c5, c6, c7);  </span><br><span class="line">all.whenComplete((___, __) -&gt; &#123;  </span><br><span class="line">    event.finishAll();  </span><br><span class="line">    pulsarClient.closeAsync();  </span><br><span class="line">    admin.close();  </span><br><span class="line">&#125;).get();</span><br></pre></td></tr></table></figure><p>对外提供的 trigger 接口就不贴代码了，重点就是在这里构建测试任务，然后等待他们全部执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractJobDefine</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Event event;</span><br><span class="line">    <span class="keyword">private</span> String jobName;</span><br><span class="line">    <span class="keyword">private</span> PulsarClient pulsarClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PulsarAdmin admin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractJobDefine</span><span class="params">(Event event, String jobName, PulsarClient pulsarClient, <span class="type">int</span> timeout, PulsarAdmin admin)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.event = event;</span><br><span class="line">        <span class="built_in">this</span>.jobName = jobName;</span><br><span class="line">        <span class="built_in">this</span>.pulsarClient = pulsarClient;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.admin = admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        event.addJob();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">                <span class="type">StopWatch</span> <span class="variable">watch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    watch.start(jobName);</span><br><span class="line">                    run(pulsarClient, admin);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    event.oneException(<span class="built_in">this</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    watch.stop();</span><br><span class="line">                    event.finishOne(jobName, StrUtil.format(<span class="string">&quot;cost: &#123;&#125;s&quot;</span>, watch.getTotalTimeSeconds()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, TestCase.EXECUTOR).get(timeout, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            event.oneException(<span class="built_in">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** run busy code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pulsarClient pulsar client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> admin pulsar admin client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(PulsarClient pulsarClient, PulsarAdmin admin)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码就是这个抽象的任务定义类，其中的 start 函数用于定义任务执行的模版：</p><ul><li>添加任务：具体实现是任务计数器+1</li><li>开始计时</li><li>执行抽血的 run 函数，具体实现交给子类</li><li>异常时记录事件</li><li>正常执行完毕后也记录事件</li></ul><p>下面来看一个普通用例的实现情况：<br><img src="https://s2.loli.net/2024/07/01/rdU5mPbfOJxv4TL.png"></p><p>就是重写了 <code>run()</code> 函数，然后在其中实现具体的测试用例，断言测试结果。</p><p>这样当我们需要再添加用例的时候只需要再新增一个子类实现即可。</p><p>同时还需要定义一个事件接口，用于处理一些关键的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Event</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 新增一个任务  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addJob</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 获取运行中的任务数量  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取运行中的任务数量  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    TestCaseRuntimeResponse <span class="title function_">getRuntime</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 单个任务执行完毕  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobName    任务名称  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> finishCost 任务完成耗时  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">finishOne</span><span class="params">(String jobName, String finishCost)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**单个任务执行异常  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobDefine 任务  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 异常  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">oneException</span><span class="params">(AbstractJobDefine jobDefine, Exception e)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 所有任务执行完毕  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">finishAll</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>getRuntime</code> 接口是用于在 cli 那边查询任务是否执行完毕的接口，只有任务执行完毕之后才能退出 <code>cli</code>。</p><h1 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h1><p>当这些任务运行完毕后我们需要重点查看应用客户端和 Pulsar broker 端是否有异常日志。</p><p>同时还需要观察一些关键的监控面板：</p><p><img src="https://s2.loli.net/2024/07/01/sGxOjRWnScPl5oZ.png"><br><img src="https://s2.loli.net/2024/07/01/E6hcSxHrRmNVFoi.png"><br><img src="https://s2.loli.net/2024/07/01/UeFZ73yRbpkAsEH.png"></p><p>包含但不限于：</p><ul><li>消息吞吐量</li><li><code>broker</code> 写入延迟</li><li><code>Bookkeeper</code> 的写入、读取成功率，以及延迟。</li></ul><p>当然还有 <code>zookeeper</code> 的运行情况也需要监控，限于篇幅就不一一粘贴了。</p><p>以上就是测试整个 Pulsar 集群的流程，当然还有一些需要优化的地方。</p><p>比如使用命令行还是有些不便，后续可能会切换到网页上就可以操作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/07/01/xZSMlpJPWTRGkge.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;由于我在公司内部负责维护 &lt;code&gt;Pulsar&lt;/code&gt;，需要时不时的升级 &lt;code&gt;Pulsar&lt;/code&gt; 版本从而和社区保持一致。&lt;/p&gt;
&lt;p&gt;而每次升级过程都需要做相同的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装一个新版本的集群&lt;/li&gt;
&lt;li&gt;触发功能性测试&lt;/li&gt;
&lt;li&gt;触发性能测试&lt;/li&gt;
&lt;li&gt;查看监控是否正常&lt;ul&gt;
&lt;li&gt;应用有无异常日志&lt;/li&gt;
&lt;li&gt;流量是否正常&lt;/li&gt;
&lt;li&gt;各个组件的内存占用是否正常&lt;/li&gt;
&lt;li&gt;写入延迟是否正常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>Pulsar客户端消费模式揭秘：Go 语言实现 ZeroQueueConsumer</title>
    <link href="http://crossoverjie.top/2024/07/29/ob/pulsar-client-zero-consumer/"/>
    <id>http://crossoverjie.top/2024/07/29/ob/pulsar-client-zero-consumer/</id>
    <published>2024-07-29T14:31:57.000Z</published>
    <updated>2024-07-29T03:08:42.394Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在 <a href="https://github.com/apache/pulsar-client-go">pulsar-client-go</a> 社区里看到这么一个 <a href="https://github.com/apache/pulsar-client-go/issues/1223">issue</a>：<br><img src="https://s2.loli.net/2024/06/24/KNsvV7jeZYSaiPq.png"></p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/apache/pulsar-client-go/pulsar&quot;</span></span><br><span class="line"></span><br><span class="line">client, err := pulsar.NewClient(pulsar.ClientOptions&#123;</span><br><span class="line">    URL: <span class="string">&quot;pulsar://localhost:6650&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">consumer, err := client.Subscribe(pulsar.ConsumerOptions&#123;</span><br><span class="line">    Topic:             <span class="string">&quot;persistent://public/default/mq-topic-1&quot;</span>,</span><br><span class="line">    SubscriptionName:  <span class="string">&quot;sub-1&quot;</span>,</span><br><span class="line">    Type:              pulsar.Shared,</span><br><span class="line">    ReceiverQueueSize: <span class="number">0</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小于等于 0 时会设置为 1000</span></span><br><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">    defaultReceiverQueueSize = <span class="number">1000</span>  </span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> options.ReceiverQueueSize &lt;= <span class="number">0</span> &#123;  </span><br><span class="line">    options.ReceiverQueueSize = defaultReceiverQueueSize  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他发现手动将 pulsar-client-go 客户端的 <code>ReceiverQueueSize</code> 设置为 0 的时候，客户端在初始化时会再将其调整为 1000.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> options.ReceiverQueueSize &lt; <span class="number">0</span> &#123;  </span><br><span class="line">    options.ReceiverQueueSize = defaultReceiverQueueSize  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果手动将源码修改为可以设置为 0 时，却不能正常消费，消费者会一直处于 waiting 状态，获取不到任何数据。</p><p>经过我的排查发现是 Pulsar 的  Go  客户端缺少了一个 <a href="https://github.com/apache/pulsar/blob/83b86abcb74595d7e8aa31b238a7dbb19a04dde2/pulsar-client/src/main/java/org/apache/pulsar/client/impl/ConsumerImpl.java#L268-L272">ZeroQueueConsumerImpl</a>的实现类，这个类主要用于可以精细控制消费逻辑。</p><blockquote><p>If you’d like to have tight control over message dispatching across consumers, set the <strong>consumers’ receiver queue size very low (potentially even to 0 if necessary)</strong>. Each consumer has a receiver queue that determines how many messages the consumer attempts to fetch at a time. For example, a receiver queue of 1000 (the default) means that the consumer attempts to process 1000 messages from the topic’s backlog upon connection. Setting the receiver queue to 0 essentially means ensuring that each consumer is only doing one thing at a time.</p></blockquote><p><a href="https://pulsar.apache.org/docs/next/cookbooks-message-queue/#client-configuration-changes">https://pulsar.apache.org/docs/next/cookbooks-message-queue/#client-configuration-changes</a></p><p>正如官方文档里提到的那样，可以将 ReceiverQueueSize 设置为 0；这样消费者就可以一条条的消费数据，而不会将消息堆积在客户端队列里。</p><h1 id="客户端消费逻辑"><a href="#客户端消费逻辑" class="headerlink" title="客户端消费逻辑"></a>客户端消费逻辑</h1><p>借此机会需要再回顾下 pulsar 客户端的消费逻辑，这样才能理解 <code>ReceiverQueueSize</code> 的作用以及如何在 pulsar-client-go 如何实现这个 <code>ZeroQueueConsumerImpl</code>。</p><p>Pulsar 客户端的消费模式是基于推拉结合的：</p><p><img src="https://s2.loli.net/2024/06/24/bTP1WGVJUR9wzYe.png"><br>如这张图所描述的流程，消费者在启动的时候会主动向服务端发送一个 Flow 的命令，告诉服务端需要下发多少条消息给客户端。</p><p>同时会使用刚才的那个 <code>ReceiverQueueSize</code>参数作为内部队列的大小，将客户端下发的消息存储在内部队列里。</p><p>然后在调用 <code>receive</code> 函数的时候会直接从这个队列里获取数据。</p><p><img src="https://s2.loli.net/2024/06/24/e3AabLk4FqB8VTo.png"><br><img src="https://s2.loli.net/2024/06/24/ZGHiaXBJfEyxh5d.png"></p><p>每次消费成功后都会将内部的一个 <code>AvailablePermit+1</code>，直到大于 <code>MaxReceiveQueueSize / 2</code> 就会再次向 broker 发送 flow 命令，告诉 broker 再次下发消息。</p><p>所以这里有一个很关键的事件：就是向 broker 发送 <code>flow</code> 命令，这样才会有新的消息下发给客户端。</p><p>之前经常都会有研发同学让我排查无法消费的问题，最终定位到的原因几乎都是消费缓慢，导致这里的 <code>AvailablePermit</code> 没有增长，从而也就不会触发 broker 给客户端推送新的消息。</p><p>看到的现象就是消费非常缓慢。</p><h1 id="ZeroQueueConsumerImpl-原理"><a href="#ZeroQueueConsumerImpl-原理" class="headerlink" title="ZeroQueueConsumerImpl 原理"></a>ZeroQueueConsumerImpl 原理</h1><p>下面来看看 <code>ZeroQueueConsumerImpl</code> 是如何实现队列大小为 0 依然是可以消费的。</p><p><img src="https://s2.loli.net/2024/06/24/Vmk9l2nucP31bNX.png"><br>在构建 consumer 的时候，就会根据队列大小从而来创建普通消费者还是 <code>ZeroQueueConsumerImpl</code> 消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">protected</span> CompletableFuture&lt;Message&lt;T&gt;&gt; <span class="title function_">internalReceiveAsync</span><span class="params">()</span> &#123;  </span><br><span class="line">    CompletableFuture&lt;Message&lt;T&gt;&gt; future = <span class="built_in">super</span>.internalReceiveAsync();  </span><br><span class="line">    <span class="keyword">if</span> (!future.isDone()) &#123;  </span><br><span class="line">        <span class="comment">// We expect the message to be not in the queue yet  </span></span><br><span class="line">        increaseAvailablePermits(cnx());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> future;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 <code>ZeroQueueConsumerImpl</code> 重写的一个消费函数，其中关键的就是 <code>increaseAvailablePermits(cnx());</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">increaseAvailablePermits</span><span class="params">(ClientCnx currentCnx)</span> &#123;</span><br><span class="line">    increaseAvailablePermits(currentCnx, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">increaseAvailablePermits</span><span class="params">(ClientCnx currentCnx, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> AVAILABLE_PERMITS_UPDATER.addAndGet(<span class="built_in">this</span>, delta);</span><br><span class="line">    <span class="keyword">while</span> (available &gt;= getCurrentReceiverQueueSize() / <span class="number">2</span> &amp;&amp; !paused) &#123;</span><br><span class="line">        <span class="keyword">if</span> (AVAILABLE_PERMITS_UPDATER.compareAndSet(<span class="built_in">this</span>, available, <span class="number">0</span>)) &#123;</span><br><span class="line">            sendFlowPermitsToBroker(currentCnx, available);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            available = AVAILABLE_PERMITS_UPDATER.get(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码里可以得知这里的逻辑就是将 AvailablePermit 自增，达到阈值后请求 broker 下发消息。</p><p>因为在 <code>ZeroQueueConsumerImpl</code> 中队列大小为 0，所以 <code>available &gt;= getCurrentReceiverQueueSize() / 2</code>永远都会为 true。</p><p>也就是说每消费一条消息都会请求 broker 让它再下发一条消息，这样就达到了每一条消息都精确控制的效果。</p><h1 id="pulsar-client-go-中的实现"><a href="#pulsar-client-go-中的实现" class="headerlink" title="pulsar-client-go 中的实现"></a>pulsar-client-go 中的实现</h1><p>为了在 pulsar-client-go 实现这个需求，我提交了一个 <a href="https://github.com/apache/pulsar-client-go/pull/1225">PR</a> 来解决这个问题。</p><p>其实从上面的分析已经得知为啥手动将 <code>ReceiverQueueSize</code> 设置为 0 无法消费消息了。</p><p>根本原因还是在初始化的时候优于队列为 0，导致不会给 broker 发送 flow 命令，这样就不会有消息推送到客户端，也就无法消费到数据了。</p><p>所以我们依然得参考 Java 的 <code>ZeroQueueConsumerImpl</code> 在每次消费的时候都手动增加  <code>availablePermits</code>。</p><p>为此我也新增了一个消费者 <code>zeroQueueConsumer</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EnableZeroQueueConsumer, if enabled, the ReceiverQueueSize will be 0.  </span></span><br><span class="line"><span class="comment">// Notice: only non-partitioned topic is supported.  </span></span><br><span class="line"><span class="comment">// Default is false.  </span></span><br><span class="line">EnableZeroQueueConsumer <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">consumer, err := client.Subscribe(ConsumerOptions&#123;  </span><br><span class="line">    Topic:                   topicName,  </span><br><span class="line">    SubscriptionName:        <span class="string">&quot;sub-1&quot;</span>,  </span><br><span class="line">    Type:                    Shared,  </span><br><span class="line">    NackRedeliveryDelay:     <span class="number">1</span> * time.Second,  </span><br><span class="line">    EnableZeroQueueConsumer: <span class="literal">true</span>,  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> options.EnableZeroQueueConsumer &#123;  </span><br><span class="line">    options.ReceiverQueueSize = <span class="number">0</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建消费者的时候需要指定是否开启 <code>ZeroQueueConsumer</code>，当开启后会手动将 ReceiverQueueSize 设置为 0.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以设置默认值。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">receiverQueueSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在 Go 中无法像 Java 那样在结构体初始化化的时候就指定默认值，再加上 Go 的 int 类型具备零值（也就是0），所以无法区分出 ReceiverQueueSize&#x3D;0 是用户主动设置的，还是没有传入这个参数使用的零值。</p></blockquote><p>所以才需要新增一个参数来手动区分是否使用 <code>ZeroQueueConsumer</code>。</p><p><img src="https://s2.loli.net/2024/06/24/TK2fJVEFlnL4dIy.png"><br>之后在创建 <code>consumer</code> 的时候进行判断，只有使用的是单分区的 <code>topic</code> 并且开启了 <code>EnableZeroQueueConsumer</code> 才能创建  <code>zeroQueueConsumer</code>。</p><hr><p><img src="https://s2.loli.net/2024/06/24/Aq5onPKOjIgserx.png"></p><blockquote><p>使用 PARTITIONED_METADATA 命令可以让 broker 返回分区数量。</p></blockquote><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *zeroQueueConsumer)</span></span> Receive(ctx context.Context) (Message, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> state := z.pc.getConsumerState(); state == consumerClosed || state == consumerClosing &#123;</span><br><span class="line">z.log.WithField(<span class="string">&quot;state&quot;</span>, state).Error(<span class="string">&quot;Failed to ack by closing or closed consumer&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;consumer state is closed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">z.Lock()</span><br><span class="line"><span class="keyword">defer</span> z.Unlock()</span><br><span class="line">z.pc.availablePermits.inc()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-z.closeCh:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, newError(ConsumerClosed, <span class="string">&quot;consumer closed&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> cm, ok := &lt;-z.messageCh:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, newError(ConsumerClosed, <span class="string">&quot;consumer closed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cm.Message, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的关键代码：<code>z.pc.availablePermits.inc()</code></p><p>消费时的逻辑其实和 Java 的 <code>ZeroQueueConsumerImpl</code> 逻辑保持了一致，也是每消费一条数据之前就增加一次 <code>availablePermits</code>。</p><p>pulsar-client-go 的运行原理与 Java 客户端的类似，也是将消息存放在了一个内部队列里，所以每次消费消息只需要从这个队列 <code>messageCh</code> 里获取即可。</p><p>值得注意的是， pulsar-client-go 版本的 <code>zeroQueueConsumer</code> 就不支持直接读取内部的队列了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *zeroQueueConsumer)</span></span> Chan() &lt;-<span class="keyword">chan</span> ConsumerMessage &#123;  </span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;zeroQueueConsumer cannot support Chan method&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会直接 panic，因为直接消费 channel 在客户端层面就没法帮用户主动发送 flow 命令了，所以这个功能就只能屏蔽掉了，只可以主动的 <code>receive</code> 消息。</p><p><img src="https://s2.loli.net/2024/06/24/dDlr3RWM6iYHFbc.png"></p><p>许久之前我也画过一个关于 pulsar client 的消费流程图，后续考虑会再写一篇关于 pulsar client 的原理分析文章。</p><p>参考链接：</p><ul><li><a href="https://github.com/apache/pulsar-client-go/issues/1223">https://github.com/apache/pulsar-client-go/issues/1223</a></li><li><a href="https://cloud.tencent.com/developer/article/2307608">https://cloud.tencent.com/developer/article/2307608</a></li><li><a href="https://pulsar.apache.org/docs/next/cookbooks-message-queue/#client-configuration-changes">https://pulsar.apache.org/docs/next/cookbooks-message-queue/#client-configuration-changes</a></li><li><a href="https://github.com/apache/pulsar-client-go/pull/1225">https://github.com/apache/pulsar-client-go/pull/1225</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间在 &lt;a href=&quot;https://github.com/apache/pulsar-client-go&quot;&gt;pulsar-client-go&lt;/a&gt; 社区里看到这么一个 &lt;a href=&quot;https://github.com/apache/pulsar-client-go/issues/1223&quot;&gt;issue&lt;/a&gt;：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/06/24/KNsvV7jeZYSaiPq.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/OB/Pulsar/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>如何监控 Nginx</title>
    <link href="http://crossoverjie.top/2024/07/23/ob/how-to-monitoring-nginx/"/>
    <id>http://crossoverjie.top/2024/07/23/ob/how-to-monitoring-nginx/</id>
    <published>2024-07-23T02:46:30.000Z</published>
    <updated>2024-07-23T03:18:06.688Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间接到一个需求，希望可以监控 Nginx 的运行状态。</p><p>我们都知道 Nginx 作为一个流行的 Web 服务器提供了多种能力，包括反向代理、负载均衡；也支持了许多协议，包括：</p><ul><li>gRPC</li><li>http</li><li>WebSocket 等<br>作为一个流量入口的中间件，对其的监控就显得至关重要了。</li></ul><span id="more"></span><p>市面上也有一些现成的产品可以监控 Nginx，比如知名的监控服务商 <code>datadog</code> 也提供了 Nginx 的监控。</p><p><img src="https://s2.loli.net/2024/06/21/BEjyS4ZQHKCrPqx.png"></p><p>但是我这是一个内网服务，并不能使用这些外部的云厂商，所有就只能在内部搭建 Nginx 的监控服务了。</p><p>不过 Nginx 默认情况下并没有提供 <code>/metrics</code> 的 endpoint，但好在它提供了一个额外的模块：<code>stub_status</code> 可以用于获取监控数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server</span> &#123;</span><br><span class="line">  <span class="string">listen</span> <span class="number">80</span><span class="string">;</span></span><br><span class="line">  <span class="string">server_name</span> <span class="string">_;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">location</span> <span class="string">/status</span> &#123;</span><br><span class="line">    <span class="string">stub_status</span> <span class="string">on;</span></span><br><span class="line">    <span class="string">access_log</span> <span class="string">off;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">      <span class="string">root</span> <span class="string">/usr/share/nginx/html;</span></span><br><span class="line">      <span class="string">index</span> <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/06/21/ZRIPyN2UxXuiCdE.png"><br>这样访问 <code>http://127.0.0.1:80/status</code> 就可以拿到一些基本的运行数据。</p><p>但这个格式明显不是 Prometheus 所支持的 metrics 格式，无法直接将数据采集到 Prometheus 中然后通过 Grafana 进行查看。</p><p>所以还得需要一个中间层来将这些数据转换为 Prometheus 可以接收的 metrics 数据。</p><h1 id="nginx-prometheus-exporter"><a href="#nginx-prometheus-exporter" class="headerlink" title="nginx-prometheus-exporter"></a>nginx-prometheus-exporter</h1><p>好在社区已经提供了类似的工具：<a href="https://github.com/nginxinc/nginx-prometheus-exporter">nginx-prometheus-exporter</a> 它读取刚才 status endpoint 所暴露的数据，然后转换为 Prometheus 格式，并对外提供了一个 <code>/metrics</code> 的 endpoint 供 Prometheus 来采集。</p><h2 id="转换数据"><a href="#转换数据" class="headerlink" title="转换数据"></a>转换数据</h2><p>我们在启动这个 <code>nginx-exporter</code> 时需要传入刚才 <code>Nginx</code> 暴露的 <code>/status</code> endpoint。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9113:9113 nginx/nginx-prometheus-exporter:1.1.0 --nginx.scrape-uri=http://&lt;nginx&gt;:8080/stub_status</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> templateMetrics <span class="type">string</span> = <span class="string">`Active connections: %d</span></span><br><span class="line"><span class="string">server accepts handled requests</span></span><br><span class="line"><span class="string">%d %d %d</span></span><br><span class="line"><span class="string">Reading: %d Writing: %d Waiting: %d</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 Nginx status 数据</span></span><br><span class="line">body, err := io.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to read the response body: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r := bytes.NewReader(body)</span><br><span class="line">stats, err := parseStubStats(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to parse response body %q: %w&quot;</span>, <span class="type">string</span>(body), err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 Nginx status 数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseStubStats</span><span class="params">(r io.Reader)</span></span> (*StubStats, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> s StubStats</span><br><span class="line"><span class="keyword">if</span> _, err := fmt.Fscanf(r, templateMetrics,</span><br><span class="line">&amp;s.Connections.Active,</span><br><span class="line">&amp;s.Connections.Accepted,</span><br><span class="line">&amp;s.Connections.Handled,</span><br><span class="line">&amp;s.Requests,</span><br><span class="line">&amp;s.Connections.Reading,</span><br><span class="line">&amp;s.Connections.Writing,</span><br><span class="line">&amp;s.Connections.Waiting); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to scan template metrics: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后会把刚才解析到的数据生成 metrics：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_active&quot;</span>],  </span><br><span class="line">    prometheus.GaugeValue, <span class="type">float64</span>(stats.Connections.Active))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_accepted&quot;</span>],  </span><br><span class="line">    prometheus.CounterValue, <span class="type">float64</span>(stats.Connections.Accepted))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_handled&quot;</span>],  </span><br><span class="line">    prometheus.CounterValue, <span class="type">float64</span>(stats.Connections.Handled))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_reading&quot;</span>],  </span><br><span class="line">    prometheus.GaugeValue, <span class="type">float64</span>(stats.Connections.Reading))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_writing&quot;</span>],  </span><br><span class="line">    prometheus.GaugeValue, <span class="type">float64</span>(stats.Connections.Writing))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_waiting&quot;</span>],  </span><br><span class="line">    prometheus.GaugeValue, <span class="type">float64</span>(stats.Connections.Waiting))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;http_requests_total&quot;</span>],  </span><br><span class="line">    prometheus.CounterValue, <span class="type">float64</span>(stats.Requests))</span><br></pre></td></tr></table></figure><p>这些 metrics 是一开始就定义好的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewNginxCollector creates an NginxCollector.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNginxCollector</span><span class="params">(nginxClient *client.NginxClient, namespace <span class="type">string</span>, constLabels <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, logger log.Logger)</span></span> *NginxCollector &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;NginxCollector&#123;</span><br><span class="line">nginxClient: nginxClient,</span><br><span class="line">logger:      logger,</span><br><span class="line">metrics: <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc&#123;</span><br><span class="line"><span class="string">&quot;connections_active&quot;</span>:   newGlobalMetric(namespace, <span class="string">&quot;connections_active&quot;</span>, <span class="string">&quot;Active client connections&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;connections_accepted&quot;</span>: newGlobalMetric(namespace, <span class="string">&quot;connections_accepted&quot;</span>, <span class="string">&quot;Accepted client connections&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;connections_handled&quot;</span>:  newGlobalMetric(namespace, <span class="string">&quot;connections_handled&quot;</span>, <span class="string">&quot;Handled client connections&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;connections_reading&quot;</span>:  newGlobalMetric(namespace, <span class="string">&quot;connections_reading&quot;</span>, <span class="string">&quot;Connections where NGINX is reading the request header&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;connections_writing&quot;</span>:  newGlobalMetric(namespace, <span class="string">&quot;connections_writing&quot;</span>, <span class="string">&quot;Connections where NGINX is writing the response back to the client&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;connections_waiting&quot;</span>:  newGlobalMetric(namespace, <span class="string">&quot;connections_waiting&quot;</span>, <span class="string">&quot;Idle client connections&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;http_requests_total&quot;</span>:  newGlobalMetric(namespace, <span class="string">&quot;http_requests_total&quot;</span>, <span class="string">&quot;Total http requests&quot;</span>, constLabels),</span><br><span class="line">&#125;,</span><br><span class="line">upMetric: newUpMetric(namespace, constLabels),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个函数是在 exporter 启动时候会调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;github.com/prometheus/client_golang/prometheus&quot;</span></span><br><span class="line"></span><br><span class="line">prometheus.MustRegister(collector.NewNginxCollector(ossClient, <span class="string">&quot;nginx&quot;</span>, labels, logger))</span><br></pre></td></tr></table></figure><p>使用的是 <code>prometheus</code> 包提供的注册函数，将我们刚才自定义的获取 <code>metrics</code> 的逻辑注册进去，这样当我们在 Prometheus 中配置好采集任务之后就可以定期扫描 <code>/status</code> 的数据然后转换为 Prometheus 指标返回。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">10s</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">nginx-exportor</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;127.0.0.1:9113&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这样就可以将 nginx status 的数据定期采集到 Prometheus 中了，最后使用社区提供的 grafana 面板便可以可视化的查看这些监控数据：<br><img src="https://s2.loli.net/2024/06/21/NvlwuAdDZHUznrC.png"></p><h2 id="Nginx-Plus"><a href="#Nginx-Plus" class="headerlink" title="Nginx Plus"></a>Nginx Plus</h2><p>同时这个 nginx-exporter 还支持 <code>Nginx Plus</code>(这是 Nginx 的商用增强版)，它的实现原理类似，只是它支持的指标更多一些而已。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NginxPlusCollector <span class="keyword">struct</span> &#123;  </span><br><span class="line">    upMetric                       prometheus.Gauge  </span><br><span class="line">    logger                         log.Logger  </span><br><span class="line">    cacheZoneMetrics               <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    workerMetrics                  <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    nginxClient                    *plusclient.NginxClient  </span><br><span class="line">    streamServerZoneMetrics        <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    streamZoneSyncMetrics          <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    streamUpstreamMetrics          <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    streamUpstreamServerMetrics    <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    locationZoneMetrics            <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    resolverMetrics                <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    limitRequestMetrics            <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    limitConnectionMetrics         <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    streamLimitConnectionMetrics   <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    upstreamServerMetrics          <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    upstreamMetrics                <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    streamUpstreamServerPeerLabels <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    serverZoneMetrics              <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    upstreamServerLabels           <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    streamUpstreamServerLabels     <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    serverZoneLabels               <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    streamServerZoneLabels         <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    upstreamServerPeerLabels       <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    workerLabels                   <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    cacheZoneLabels                <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    totalMetrics                   <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    variableLabelNames             VariableLabelNames  </span><br><span class="line">    variableLabelsMutex            sync.RWMutex  </span><br><span class="line">    mutex                          sync.Mutex  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://prometheus.io/docs/instrumenting/exporters/">Prometheus</a> 社区中提供不少这类 <code>exporter</code>：<br><img src="https://s2.loli.net/2024/06/21/ztuCr8FgJvcSbis.png"></p><p>这些 <code>exporter</code> 要解决的问题都是类似的，对于一些没有暴露 <code>/metrics</code> 的中间件通过他们提供的客户端直连，然后将获取到的数据转换为 Prometheus 所支持的格式。</p><blockquote><p>需要单独的 exporter 支持的中间件大部分都是一些老牌产品，在设计之初就没有考虑可观测性的需求，现在一些新的中间件几乎都原生支持 metrics，这种产品只需要在 Prometheus 中配置采集任务即可。</p></blockquote><h1 id="Cprobe"><a href="#Cprobe" class="headerlink" title="Cprobe"></a>Cprobe</h1><p>不知道大家发现没有，社区中提供的 <code>exporter</code> 还是挺多的，但如果我们都需要在自己的生产环境将这些 exporter 部署起来多少会有些繁琐：</p><ul><li>不同的 exporter 需要的参数可能不同</li><li>暴露的端口可能不同</li><li>配置文件难以统一管理</li></ul><p>在这个背景下社区有大佬发起了一个 <a href="https://github.com/cprobe/cprobe">cprobe</a> 项目，这是一个大而全的项目，可以将散落在各处的 <code>exporter</code> 都整合在一起。</p><p>并且统一抽象了接入方式，使得所有的插件都可以用类似的配置书写方式来维护这些插件。</p><p>目前已经支持以下一些常用的中间件：</p><p><img src="https://s2.loli.net/2024/06/21/eC75lpg2fBmstjS.png"></p><p>这里的 Nginx 就是本次监控的需求贡献的，因为还需要监控这里支持的一些其他中间件，所以最终也是使用 cprobe 来部署监控。</p><h2 id="整合-Nginx-exporter-到-Cprobe-中"><a href="#整合-Nginx-exporter-到-Cprobe-中" class="headerlink" title="整合 Nginx exporter 到 Cprobe 中"></a>整合 Nginx exporter 到 Cprobe 中</h2><p>下面来看看如何将社区中已经存在的 Nginx exporter 整合到  cprobe 中：</p><p>在开始之前我们先要抽象出这个插件需要哪些配置？</p><p>这个其实很好解决，我们直接看看需要实现的 exporter 中提供了哪些参数，这里以 Nginx 的为例：<br><img src="https://s2.loli.net/2024/06/21/zsY2F563pPglNcS.png"></p><p>排除掉一些我们不需要的，比如端口、日志级别、endpoint等配置之外，就只需要一些关于 SSL 的配置，所以最终我们需要的配置文件如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nginx_plus</span> = <span class="literal">false</span>  </span><br><span class="line"><span class="comment"># Path to the PEM encoded CA certificate file used to validate the servers SSL certificate.  </span></span><br><span class="line"><span class="attr">ssl_ca_cert</span> = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line"><span class="comment"># Path to the PEM encoded client certificate file to use when connecting to the server.  </span></span><br><span class="line"><span class="attr">ssl_client_cert</span> = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line"><span class="comment"># Path to the PEM encoded client certificate key file to use when connecting to the server.  </span></span><br><span class="line"><span class="attr">ssl_client_key</span> = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line"><span class="comment"># Perform SSL certificate verification.  </span></span><br><span class="line"><span class="attr">ssl_verify</span> = <span class="literal">false</span>  </span><br><span class="line"><span class="attr">timeout</span> = <span class="string">&#x27;5s&#x27;</span></span><br></pre></td></tr></table></figure><p>然后将这个 toml 里的配置转换为一个 struct。</p><p>在 cprobe 中有一个核心的接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// ParseConfig is used to parse config</span></span><br><span class="line">ParseConfig(baseDir <span class="type">string</span>, bs []<span class="type">byte</span>) (any, <span class="type">error</span>)</span><br><span class="line"><span class="comment">// Scrape is used to scrape metrics, cfg need to be cast specific cfg</span></span><br><span class="line">Scrape(ctx context.Context, target <span class="type">string</span>, cfg any, ss *types.Samples) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ParseConfig</code> 用于将刚才的配置文件流格式化为插件所需要的配置。</p><p><code>Scrape</code> 函数则是由 cprobe 定时调用的函数，会传入抓取的目标地址，每个插件将抓到的数据写入 <code>*types.Samples</code> 中即可。</p><p><code>cprobe</code> 会将 <code>*types.Samples</code> 的数据发送到 remote 的 Prometheus 中。</p><p>接下来看看 Nginx 插件的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">NginxPlus     <span class="type">bool</span>          <span class="string">`toml:&quot;nginx_plus&quot;`</span></span><br><span class="line">SSLCACert     <span class="type">string</span>        <span class="string">`toml:&quot;ssl_ca_cert&quot;`</span></span><br><span class="line">SSLClientCert <span class="type">string</span>        <span class="string">`toml:&quot;ssl_client_cert&quot;`</span></span><br><span class="line">SSLClientKey  <span class="type">string</span>        <span class="string">`toml:&quot;ssl_client_key&quot;`</span></span><br><span class="line">SSLVerify     <span class="type">bool</span>          <span class="string">`toml:&quot;ssl_verify&quot;`</span></span><br><span class="line">Timeout       time.Duration <span class="string">`toml:&quot;timeout&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Nginx)</span></span> ParseConfig(baseDir <span class="type">string</span>, bs []<span class="type">byte</span>) (any, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> c Config</span><br><span class="line">err := toml.Unmarshal(bs, &amp;c)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.Timeout == <span class="number">0</span> &#123;</span><br><span class="line">c.Timeout = time.Millisecond * <span class="number">500</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ParseConfig</code> 很简单，就是将配置文件转换为 struct。</p><p>抓取函数 <code>Scrape</code> 也很简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">collect, err := registerCollector(transport, target, <span class="literal">nil</span>, conf)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> err  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> prometheus.Metric)  </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    collect.Collect(ch)  </span><br><span class="line">    <span class="built_in">close</span>(ch)  </span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>就是构建之前在 <code>nginx exporter</code> 中的 <code>prometheus.Collector</code>，其实代码大部分也是从那边复制过来的。<br><img src="https://s2.loli.net/2024/06/21/4yHQgL1EAiZXwju.png"><br><img src="https://s2.loli.net/2024/06/21/1OloLxpEnbqiaXA.png"><br>所以其实迁移一个 exporter 到 cprobe 中非常简单，只需要：</p><ul><li>定义好需要的配置。</li><li>去掉不需要的代码，比如日志、端口之类的。</li><li>适配好刚才那两个核心函数 <code>ParseConfig/Scrape</code> 即可。</li></ul><p>但这样也有些小问题，现有的一些 exporter 还在迭代，那边更新的版本需要有人及时同步过来。</p><p>除非有一天 cprobe 可以作为一个标准，版本更新都在 cprobe 这边完成，这样就真的是做大做强了。</p><p>不过这些依旧是适配老一代的中间件产品，逐步都会适配现代的可观测体系，这些 exporter 也会逐渐走下历史舞台。</p><p>参考链接：</p><ul><li><a href="https://prometheus.io/docs/instrumenting/exporters/">https://prometheus.io/docs/instrumenting/exporters/</a></li><li><a href="https://github.com/nginxinc/nginx-prometheus-exporter">https://github.com/nginxinc/nginx-prometheus-exporter</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间接到一个需求，希望可以监控 Nginx 的运行状态。&lt;/p&gt;
&lt;p&gt;我们都知道 Nginx 作为一个流行的 Web 服务器提供了多种能力，包括反向代理、负载均衡；也支持了许多协议，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gRPC&lt;/li&gt;
&lt;li&gt;http&lt;/li&gt;
&lt;li&gt;WebSocket 等&lt;br&gt;作为一个流量入口的中间件，对其的监控就显得至关重要了。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="Nginx" scheme="http://crossoverjie.top/tags/Nginx/"/>
    
    <category term="Monitor" scheme="http://crossoverjie.top/tags/Monitor/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统如何做负载均衡</title>
    <link href="http://crossoverjie.top/2024/07/15/ob/Pulsar-loadbalance/"/>
    <id>http://crossoverjie.top/2024/07/15/ob/Pulsar-loadbalance/</id>
    <published>2024-07-15T02:22:14.000Z</published>
    <updated>2024-07-15T14:03:51.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Pulsar 有提供一个查询 Broker 负载的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get load for this broker.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> PulsarAdminException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">LoadManagerReport <span class="title function_">getLoadReport</span><span class="params">()</span> <span class="keyword">throws</span> PulsarAdminException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadManagerReport</span> <span class="keyword">extends</span> <span class="title class_">ServiceLookupData</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getCpu</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getMemory</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getDirectMemory</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getBandwidthIn</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getBandwidthOut</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以返回一些 broker 的负载数据，比如 CPU、内存、流量之类的数据。</p><span id="more"></span><blockquote><p>我目前碰到的问题是目前会遇到部分节点的负债不平衡，导致资源占用不均衡，所以想要手动查询所有节点的负载数据，然后人工进行负载。</p></blockquote><p>理论上这些数据是在运行时实时计算的数据，如果对于单机的倒还好说，每次请求这个接口直接实时计算一次就可以了。</p><p>但对于集群的服务来说会有多个节点，目前 Pulsar 提供的这个接口只能查询指定节点的负载数据，也就是说每次得传入目标节点的 IP 和端口。</p><p><img src="https://s2.loli.net/2024/06/07/ephIgndx54sFlLa.png"></p><p>所以我的预期是可以提供一个查询所有节点负载的接口，已经提了 <code>issue</code>，最近准备写 Purpose 把这个需求解决了。</p><p>实现这个需求的方案有两种：</p><ol><li>拿到所有 broker 也就是服务节点信息，依次遍历调用接口，然后自己组装信息。</li><li>从 zookeeper 中获取负载信息。</li></ol><p>理论上第二种更好，第一种实现虽然更简单，但每次都发起一次 http 请求，多少有些浪费。</p><p>第二种方案直接从源头获取负载信息，只需要请求一次就可以了。</p><p>而正好社区提供了一个命令行工具可以直接打印所有的 <code>broker</code> 负载数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pulsar-perf monitor-brokers --connect-string &lt;zookeeper host:port&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/06/07/UN8gpW915RfcODb.png"></p><h1 id="分布式系统常用组件"><a href="#分布式系统常用组件" class="headerlink" title="分布式系统常用组件"></a>分布式系统常用组件</h1><p>提供的命令行工具其实就是直接从 zookeeper 中查询的数据。</p><p>在分布式系统中需要一个集中的组件来管理各种数据，比如：</p><ol><li>可以利用该组件来选举 leader 节点</li><li>使用该组件来做分布式锁</li><li>为分布式系统同步数据</li><li>统一的存放和读取某些数据</li></ol><p>可以提供该功能的组件其实也不少：</p><ul><li><a href="https://zookeeper.apache.org/">zookeeper</a></li><li><a href="https://etcd.io/">etcd</a></li><li><a href="https://github.com/streamnative/oxia">oxia</a></li></ul><p>Zookeeper 是老牌的分布式协调组件，可以做 leader 选举、配置中心、分布式锁、服务注册与发现等功能。</p><p>在许多中间件和系统中都有应用，比如：</p><ul><li><a href="https://github.com/apache/pulsar">Apache Pulsar</a> 中作为协调中心</li><li><a href="https://github.com/apache/kafka">Kafka</a> 中也有类似的作用。</li><li>在 <a href="https://github.com/apache/dubbo">Dubbo</a> 中作为服务注册发现组件。</li></ul><hr><p>etcd 的功能与 zookeeper 类似，可以用作服务注册发现，也可以作为 Key Value 键值对存储系统；在 kubernetes 中扮演了巨大作用，经历了各种考验，稳定性已经非常可靠了。</p><hr><p><a href="https://github.com/streamnative/oxia">Oxia</a> 则是 StreamNative 开发的一个用于替换 Zookeeper 的中间件，功能也与 Zookeeper 类似；目前已经可以在 Pulsar 中替换 Zookeeper，只是还没有大规模的使用。</p><h1 id="Pulsar-中的应用"><a href="#Pulsar-中的应用" class="headerlink" title="Pulsar 中的应用"></a>Pulsar 中的应用</h1><p>下面以 Pulsar 为例（使用 zookeeper），看看在这类大型分布式系统中是如何处理负载均衡的。</p><p>再开始之前先明确下负载均衡大体上会做哪些事情。</p><ol><li>首先上报自己节点的负载数据</li><li>Leader 节点需要定时收集所有节点的负载数据。<ol><li>这些负载数据中包括：<ol><li><code>CPU</code>、堆内存、堆外内存等通用数据的使用量</li><li>流出、流入流量</li><li>一些系统特有的数据，比如在 <code>Pulsar</code> 中就是：<ol><li>每个 <code>broker</code> 中的 <code>topic</code>、<code>consumer</code>、<code>producer</code>、<code>bundle</code> 等数据。</li></ol></li></ol></li></ol></li><li>再由 leader 节点读取到这些数据后选择负载较高的节点，将数据迁移到负载较低的节点。</li></ol><p>以上就是一个完整的负载均衡的流程，下面我们依次看看在 <code>Pulsar</code> 中是如何实现这些逻辑的。</p><p>在 Pulsar 中提供了多种负载均衡策略，以下是加载负载均衡器的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> LoadManager <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> PulsarService pulsar)</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServiceConfiguration</span> <span class="variable">conf</span> <span class="operator">=</span> pulsar.getConfiguration();  </span><br><span class="line">        <span class="comment">// Assume there is a constructor with one argument of PulsarService.  </span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">loadManagerInstance</span> <span class="operator">=</span> Reflections.createInstance(conf.getLoadManagerClassName(),  </span><br><span class="line">                Thread.currentThread().getContextClassLoader());  </span><br><span class="line">        <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> LoadManager) &#123;  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> (LoadManager) loadManagerInstance;  </span><br><span class="line">            casted.initialize(pulsar);  </span><br><span class="line">            <span class="keyword">return</span> casted;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> ModularLoadManager) &#123;  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModularLoadManagerWrapper</span>((ModularLoadManager) loadManagerInstance);  </span><br><span class="line">            casted.initialize(pulsar);  </span><br><span class="line">            <span class="keyword">return</span> casted;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        LOG.warn(<span class="string">&quot;Error when trying to create load manager: &quot;</span>, e);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// If we failed to create a load manager, default to SimpleLoadManagerImpl.  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleLoadManagerImpl</span>(pulsar);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认使用的是 <code>ModularLoadManagerImpl</code>， 如果出现异常那就会使用 <code>SimpleLoadManagerImpl</code> 作为兜底。</p><p>他们两个的区别是 <code>ModularLoadManagerImpl</code> 的功能更全，可以做更为细致的负载策略。</p><p>接下来以默认的 <code>ModularLoadManagerImpl</code> 为例讲解上述的流程。</p><h2 id="上报负载数据"><a href="#上报负载数据" class="headerlink" title="上报负载数据"></a>上报负载数据</h2><p>在负载均衡器启动的时候就会收集节点数据然后进行上报：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> PulsarServerException &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="type">String</span> <span class="variable">brokerId</span> <span class="operator">=</span> pulsar.getBrokerId();</span><br><span class="line">         brokerZnodePath = LoadManager.LOADBALANCE_BROKERS_ROOT + <span class="string">&quot;/&quot;</span> + brokerId;</span><br><span class="line">         <span class="comment">// 收集本地负载数据</span></span><br><span class="line">         updateLocalBrokerData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上报 zookeeper</span></span><br><span class="line">         brokerDataLock = brokersData.acquireLock(brokerZnodePath, localData).join();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         log.error(<span class="string">&quot;Unable to acquire lock for broker: [&#123;&#125;]&quot;</span>, brokerZnodePath, e);</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PulsarServerException</span>(e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先获取到当前 broker 的 Id 然后拼接一个 zookeeper 节点的路径，将生成的 localData 上传到 zookeeper 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 存放 broker 的节点信息</span><br><span class="line">ls /loadbalance/brokers</span><br><span class="line"></span><br><span class="line">[broker-1:8080, broker-2:8080]</span><br><span class="line"></span><br><span class="line">// 根据节点信息查询负载数据</span><br><span class="line">get /loadbalance/brokers/broker-1:8080</span><br></pre></td></tr></table></figure><p>上报的数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;webServiceUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://broker-1:8080&quot;</span><span class="punctuation">,</span><span class="attr">&quot;pulsarServiceUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;pulsar://broker-1:6650&quot;</span><span class="punctuation">,</span><span class="attr">&quot;persistentTopicsEnabled&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="attr">&quot;nonPersistentTopicsEnabled&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">7.311714728372232</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">800.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;memory&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">124.0</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">2096.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;directMemory&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">36.0</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">256.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;bandwidthIn&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">0.8324254085661579</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">1.0E7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;bandwidthOut&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">0.7155446715644209</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">1.0E7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgRateIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgRateOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;lastUpdate&quot;</span><span class="punctuation">:</span><span class="number">1690979816792</span><span class="punctuation">,</span><span class="attr">&quot;lastStats&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;my-tenant/my-namespace/0x4ccccccb_0x66666664&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;msgRateIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgRateOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;consumerCount&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;producerCount&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;topics&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;cacheSize&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;numTopics&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;numBundles&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;numConsumers&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;numProducers&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;bundles&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;my-tenant/my-namespace/0x4ccccccb_0x66666664&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;lastBundleGains&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;lastBundleLosses&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;brokerVersionString&quot;</span><span class="punctuation">:</span><span class="string">&quot;3.1.0-SNAPSHOT&quot;</span><span class="punctuation">,</span><span class="attr">&quot;protocols&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;advertisedListeners&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;internal&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;brokerServiceUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;pulsar://broker-1:6650&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;loadManagerClassName&quot;</span><span class="punctuation">:</span><span class="string">&quot;org.apache.pulsar.broker.loadbalance.impl.ModularLoadManagerImpl&quot;</span><span class="punctuation">,</span><span class="attr">&quot;startTimestamp&quot;</span><span class="punctuation">:</span><span class="number">1690940955211</span><span class="punctuation">,</span><span class="attr">&quot;maxResourceUsage&quot;</span><span class="punctuation">:</span><span class="number">0.140625</span><span class="punctuation">,</span><span class="attr">&quot;loadReportType&quot;</span><span class="punctuation">:</span><span class="string">&quot;LocalBrokerData&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="采集数据"><a href="#采集数据" class="headerlink" title="采集数据"></a>采集数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SystemResourceUsage <span class="title function_">getSystemResourceUsage</span><span class="params">(<span class="keyword">final</span> BrokerHostUsage brokerHostUsage)</span> &#123;  </span><br><span class="line">    <span class="type">SystemResourceUsage</span> <span class="variable">systemResourceUsage</span> <span class="operator">=</span> brokerHostUsage.getBrokerHostUsage();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Override System memory usage and limit with JVM heap usage and limit  </span></span><br><span class="line">    <span class="type">double</span> <span class="variable">maxHeapMemoryInBytes</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory();  </span><br><span class="line">    <span class="type">double</span> <span class="variable">memoryUsageInBytes</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();  </span><br><span class="line">    <span class="type">double</span> <span class="variable">memoryUsage</span> <span class="operator">=</span> memoryUsageInBytes / MIBI;  </span><br><span class="line">    <span class="type">double</span> <span class="variable">memoryLimit</span> <span class="operator">=</span> maxHeapMemoryInBytes / MIBI;  </span><br><span class="line">    systemResourceUsage.setMemory(<span class="keyword">new</span> <span class="title class_">ResourceUsage</span>(memoryUsage, memoryLimit));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Collect JVM direct memory  </span></span><br><span class="line">    systemResourceUsage.setDirectMemory(<span class="keyword">new</span> <span class="title class_">ResourceUsage</span>((<span class="type">double</span>) (getJvmDirectMemoryUsed() / MIBI),  </span><br><span class="line">            (<span class="type">double</span>) (DirectMemoryUtils.jvmMaxDirectMemory() / MIBI)));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> systemResourceUsage;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会在运行时获取一些 JVM 和 堆外内存的数据。</p><h2 id="收集所有节点数据"><a href="#收集所有节点数据" class="headerlink" title="收集所有节点数据"></a>收集所有节点数据</h2><p>作为 <code>leader</code> 节点还需要收集所有节点的负载数据，然后根据一些规则选择将负载较高的节点移动到负债较低的节点中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateAllBrokerData</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 从 zookeeper 中获取所有节点</span></span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; activeBrokers = getAvailableBrokers();</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, BrokerData&gt; brokerDataMap = loadData.getBrokerData();</span><br><span class="line">    <span class="keyword">for</span> (String broker : activeBrokers) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s/%s&quot;</span>, LoadManager.LOADBALANCE_BROKERS_ROOT, broker);</span><br><span class="line">            <span class="comment">// 依次读取各个节点的负载数据</span></span><br><span class="line">            Optional&lt;LocalBrokerData&gt; localData = brokersData.readLock(key).get();</span><br><span class="line">            <span class="keyword">if</span> (!localData.isPresent()) &#123;</span><br><span class="line">                brokerDataMap.remove(broker);</span><br><span class="line">                log.info(<span class="string">&quot;[&#123;&#125;] Broker load report is not present&quot;</span>, broker);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brokerDataMap.containsKey(broker)) &#123;</span><br><span class="line">                <span class="comment">// Replace previous local broker data.</span></span><br><span class="line">                brokerDataMap.get(broker).setLocalData(localData.get());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Initialize BrokerData object for previously unseen</span></span><br><span class="line">                <span class="comment">// brokers.</span></span><br><span class="line">                <span class="comment">// 将数据写入到本地缓存</span></span><br><span class="line">                brokerDataMap.put(broker, <span class="keyword">new</span> <span class="title class_">BrokerData</span>(localData.get()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Error reading broker data from cache for broker - [&#123;&#125;], [&#123;&#125;]&quot;</span>, broker, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove obsolete brokers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> String broker : brokerDataMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!activeBrokers.contains(broker)) &#123;</span><br><span class="line">            brokerDataMap.remove(broker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会从 zookeeper 的节点中获取到所有的 broker 列表（broker 会在启动时将自身的信息注册到 zookeeper 中。）</p><p>然后依次读取各自节点的负载数据，也就是在负载均衡器启动的时候上报的数据。</p><h2 id="筛选出所有-broker-中需要-unload-的-bundle"><a href="#筛选出所有-broker-中需要-unload-的-bundle" class="headerlink" title="筛选出所有 broker 中需要 unload 的 bundle"></a>筛选出所有 broker 中需要 unload 的 bundle</h2><p>在 Pulsar 中 topic 是最核心的概念，而为了方便管理大量 topic，提出了一个 Bundle 的概念； Bundle 是一批 topic 的集合，管理 Bundle 自然会比 topic 更佳容易。</p><p>所以在 Pulsar 中做负载均衡最主要的就是将负载较高节点中的 bundle 转移到低负载的 broker 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateAllBrokerData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; activeBrokers = getAvailableBrokers();</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, BrokerData&gt; brokerDataMap = loadData.getBrokerData();</span><br><span class="line">    <span class="keyword">for</span> (String broker : activeBrokers) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s/%s&quot;</span>, LoadManager.LOADBALANCE_BROKERS_ROOT, broker);</span><br><span class="line">            Optional&lt;LocalBrokerData&gt; localData = brokersData.readLock(key).get();</span><br><span class="line">            <span class="keyword">if</span> (!localData.isPresent()) &#123;</span><br><span class="line">                brokerDataMap.remove(broker);</span><br><span class="line">                log.info(<span class="string">&quot;[&#123;&#125;] Broker load report is not present&quot;</span>, broker);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brokerDataMap.containsKey(broker)) &#123;</span><br><span class="line">                <span class="comment">// Replace previous local broker data.</span></span><br><span class="line">                brokerDataMap.get(broker).setLocalData(localData.get());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Initialize BrokerData object for previously unseen</span></span><br><span class="line">                <span class="comment">// brokers.</span></span><br><span class="line">                brokerDataMap.put(broker, <span class="keyword">new</span> <span class="title class_">BrokerData</span>(localData.get()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Error reading broker data from cache for broker - [&#123;&#125;], [&#123;&#125;]&quot;</span>, broker, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove obsolete brokers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> String broker : brokerDataMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!activeBrokers.contains(broker)) &#123;</span><br><span class="line">            brokerDataMap.remove(broker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负载均衡器在启动的时候就会查询所有节点的数据，然后写入到 <code>brokerDataMap</code> 中。</p><p><img src="https://s2.loli.net/2024/06/12/ASoLedKVlgRbCFO.png"><br>同时也会注册相关的 zookeeper 事件，当注册的节点发生变化时（一般是新增或者删减了 broker 节点）就会更新内存中缓存的负载数据。</p><p>之后 leader 节点会定期调用 <code>org.apache.pulsar.broker.loadbalance.impl.ModularLoadManagerImpl#doLoadShedding</code> 函数查询哪些数据需要卸载，然后进行重新负载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Multimap&lt;String, String&gt; bundlesToUnload = loadSheddingStrategy.findBundlesForUnloading(loadData, conf);</span><br></pre></td></tr></table></figure><p>最核心的就是调用这个 <code>findBundlesForUnloading</code> 函数，会返回需要卸载 bundle 集合，最终会遍历这个集合调用 admin API 进行卸载和重平衡。</p><p>而这个函数会有多种实现，本质上就是根据传入的各个节点的负载数据，然后根据自定义的规则返回一批需要卸载的数据。</p><p>以默认的 <code>org.apache.pulsar.broker.loadbalance.impl.ThresholdShedder</code> 规则为例：</p><p><img src="https://s2.loli.net/2024/06/12/hg751LtwZMrUyFb.png"><br>它是根据带宽、内存、流量等各个指标的权重算出每个节点的负载值，之后为整个集群计算出一个平均负载值。</p><p>以上图为例：超过 <code>ShedBundles</code> 的数据就需要被卸载掉，然后转移到低负载的节点中。</p><p>所以最左边节点和超出的 bundle 部分就需要被返回。</p><p>具体的计算逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">filterAndSelectBundle</span><span class="params">(LoadData loadData, Map&lt;String, Long&gt; recentlyUnloadedBundles, String broker,</span></span><br><span class="line"><span class="params">                                   LocalBrokerData localData, <span class="type">double</span> minimumThroughputToOffload)</span> &#123;</span><br><span class="line">    <span class="type">MutableDouble</span> <span class="variable">trafficMarkedToOffload</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutableDouble</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">MutableBoolean</span> <span class="variable">atLeastOneBundleSelected</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutableBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">    loadData.getBundleDataForLoadShedding().entrySet().stream()</span><br><span class="line">            .map((e) -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">bundle</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">BundleData</span> <span class="variable">bundleData</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="type">TimeAverageMessageData</span> <span class="variable">shortTermData</span> <span class="operator">=</span> bundleData.getShortTermData();</span><br><span class="line">                <span class="type">double</span> <span class="variable">throughput</span> <span class="operator">=</span> shortTermData.getMsgThroughputIn() + shortTermData.getMsgThroughputOut();</span><br><span class="line">                <span class="keyword">return</span> Pair.of(bundle, throughput);</span><br><span class="line">            &#125;).filter(e -&gt;</span><br><span class="line">                    !recentlyUnloadedBundles.containsKey(e.getLeft())</span><br><span class="line">            ).filter(e -&gt;</span><br><span class="line">                    localData.getBundles().contains(e.getLeft())</span><br><span class="line">            ).sorted((e1, e2) -&gt;</span><br><span class="line">                    Double.compare(e2.getRight(), e1.getRight())</span><br><span class="line">            ).forEach(e -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (trafficMarkedToOffload.doubleValue() &lt; minimumThroughputToOffload</span><br><span class="line">                        || atLeastOneBundleSelected.isFalse()) &#123;</span><br><span class="line">                    selectedBundlesCache.put(broker, e.getLeft());</span><br><span class="line">                    trafficMarkedToOffload.add(e.getRight());</span><br><span class="line">                    atLeastOneBundleSelected.setTrue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码里看的出来就是在一个备选集合中根据各种阈值和判断条件筛选出需要卸载的 bundle。</p><hr><p>而 <code>SimpleLoadManagerImpl</code> 的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (currentLoadReports) &#123;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;ResourceUnit, LoadReport&gt; entry : currentLoadReports.entrySet()) &#123;</span><br><span class="line"><span class="type">ResourceUnit</span> <span class="variable">overloadedRU</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"><span class="type">LoadReport</span> <span class="variable">lr</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"><span class="comment">// 所有数据做一个简单的筛选，超过阈值的数据需要被 unload</span></span><br><span class="line"><span class="keyword">if</span> (isAboveLoadLevel(lr.getSystemResourceUsage(), overloadThreshold)) &#123;</span><br><span class="line"><span class="type">ResourceType</span> <span class="variable">bottleneckResourceType</span> <span class="operator">=</span> lr.getBottleneckResourceType();</span><br><span class="line">Map&lt;String, NamespaceBundleStats&gt; bundleStats = lr.getSortedBundleStats(bottleneckResourceType);</span><br><span class="line"><span class="keyword">if</span> (bundleStats == <span class="literal">null</span>) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;Null bundle stats for bundle &#123;&#125;&quot;</span>, lr.getName());</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是很简单的通过将判断节点的负载是否超过了阈值 <code>isAboveLoadLevel</code>，然后做一个简单的排序就返回了。</p><p>从这里也看得出来 <code>SimpleLoadManagerImpl</code> 和 <code>ModularLoadManager</code> 的区别，<code>SimpleLoadManagerImpl</code> 更简单，并没有提供多个 <code>doLoadShedding</code> 的筛选实现。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说对于无状态的服务来说，理论上我们只需要做好负载算法即可（轮训、一致性哈希、低负载优先等）就可以很好的平衡各个节点之间的负载。</p><p>而对于有状态的服务来说，负载均衡就是将负载较高节点中的数据转移到负载低的节点中。</p><p>其中的关键就是需要存储各个节点的负载数据（业界常用的是存储到 zookeeper 中），然后再由一个 leader 节点从这些节点中根据某种负载算法选择出负载较高的节点以及负载较低的节点，最终把数据迁移过去即可。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Pulsar 有提供一个查询 Broker 负载的接口：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * Get load for this broker.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; PulsarAdminException&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LoadManagerReport &lt;span class=&quot;title function_&quot;&gt;getLoadReport&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; PulsarAdminException;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;LoadManagerReport&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceLookupData&lt;/span&gt; &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getCpu&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getMemory&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getDirectMemory&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getBandwidthIn&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getBandwidthOut&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以返回一些 broker 的负载数据，比如 CPU、内存、流量之类的数据。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/OB/Pulsar/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>🎉我是如何从零到成为 Apache 顶级项目的 Committer</title>
    <link href="http://crossoverjie.top/2024/07/11/ob/%F0%9F%8E%89how-to-be-committer/"/>
    <id>http://crossoverjie.top/2024/07/11/ob/%F0%9F%8E%89how-to-be-committer/</id>
    <published>2024-07-11T15:45:32.000Z</published>
    <updated>2024-07-11T15:46:29.320Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/07/07/bj8NHqYFegTx1WU.png" alt="image.png"><br><img src="https://s2.loli.net/2024/07/07/a86fbuopri9mDeS.png"></p><p>最近收到了 <a href="https://github.com/apache/pulsar/">Apache Pulsar</a> 和 <a href="https://github.com/apache/hertzbeat/">Apache HertzBeat</a>社区的邀请邮件，成为了这两个项目的 <code>Committer</code>。</p><span id="more"></span><p>一路走来我从最开始的打游击战的闲散人员到如今活跃在各个开源项目里的“老兵”，用现在流行的话来说 <code>Apache</code> 的这两个 <code>Committer</code> 就相当于是拿到了编制，进入了正规军。</p><p>下面就分享一下我的个人开源经历，希望对想要参与开源或者已经在其中的开发者有所帮助。</p><h1 id="我的-GitHub-开源故事"><a href="#我的-GitHub-开源故事" class="headerlink" title="我的 GitHub 开源故事"></a>我的 GitHub 开源故事</h1><h2 id="初识-GitHub"><a href="#初识-GitHub" class="headerlink" title="初识 GitHub"></a>初识 GitHub</h2><p><img src="https://s2.loli.net/2024/07/08/CylX9TKcQY12MWI.png"><br>我这个 <code>Github</code> 账号是在 15 年 9月份注册的，那时候刚出来参与工作。</p><p>其实在这之前我压根没有听说过 GitHub、对开源也是知之甚少；只是知道老师和同事经常让我在网上可以下载到一些第三方包（现在回想起来几乎都是好 Apache 的提供的包）来解决日常的一些常见需求。</p><p>当时只是觉得非常方便，没想到大部分的工作互联网上都有相关的解决方案。</p><p>直到第二年也就是 16 年我才提交第一行代码，记得当时是需要和同学共享一些代码。</p><p>在学校的时候大家都是把文件打包然后通过 QQ 发送的，因为我之前在 GitHub 上看到大家都是把源码公开的，所以当时的想法是不是可以直接使用 GitHub 把代码发给同学，这样就省去了打包解压的步骤了。</p><blockquote><p>现在想想还好都是一些非业务代码，不然就违反公司安全规定了。</p></blockquote><p>所以其实自己没有任何开源的概念，只是觉得分享代码很方便。</p><p>后续在网上看了 <code>Richard Matthew Stallman</code> 发起的<a href="https://zh.wikipedia.org/zh-hans/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%BF%90%E5%8A%A8">自由软件运动</a>才对开源的由来有了更多的认识，也越发佩服这些参与开源的大佬们。</p><h2 id="托管-Blog"><a href="#托管-Blog" class="headerlink" title="托管 Blog"></a>托管 Blog</h2><p><img src="https://s2.loli.net/2024/07/08/zhYcH9RmxkpWEA2.png" alt="image.png"><br><img src="https://s2.loli.net/2024/07/08/Cv86gmrlhxoDqBK.png" alt="image.png"></p><p>当时还非常流行在 GitHub 上搭建个人博客，我自然也跟上了这个潮流；直到现在也没有断更。<br>陆续写了 240+ 篇博客。</p><blockquote><p>记得当时最喜欢干的事就是折腾各种主题，可以在 GitHub 免费托管一个博客，对当时的我也是震撼蛮大的。</p></blockquote><p>关于博客的话题还有不少内容可以讲，放到后面继续分享。</p><h2 id="提交第一个项目"><a href="#提交第一个项目" class="headerlink" title="提交第一个项目"></a>提交第一个项目</h2><p><img src="https://s2.loli.net/2024/07/08/NtExsU8Z2ryWdzT.png"><br>因为当时在公司刚开始接触到 SSM(spring+springmvc+mybatis)，所以就想把日常学到的东西沉淀下来。</p><p>于是就把一些非业务代码整理后提交了第一个项目，以更新博客的方式陆续更新了各种解决方案：<br><img src="https://s2.loli.net/2024/07/08/BITYfjNS7oaEpJl.png"><br>至今已经全部更新完毕，所以我就将它归档了。</p><p>这也是我第一次正儿八经做开源项目，在这个过程中也结实到了不少朋友，沉淀了许多内容；对于刚工作一两年的我来说意义还是很重大的。</p><h1 id="参与正规军-Apache"><a href="#参与正规军-Apache" class="headerlink" title="参与正规军(Apache)"></a>参与正规军(Apache)</h1><p>时间点回到现在，因为工作原因我需要在公司内部维护 Pulsar 消息队列；当时 Pulsar 在公司还有着一些细枝末节的问题需要解决。</p><p>在解决这些问题的过程中就想着看能不能给社区贡献些代码，这样也可以更熟悉整个项目。</p><blockquote><p>其实 20 年左右在之前的公司就有使用 Pulsar，只是当时还没有意识到要向社区贡献代码。</p></blockquote><p>于是我先尝试做一些无关紧要的修改：<br><img src="https://s2.loli.net/2024/07/08/WLkOP5KhvBHmg7E.png"><br>因为这个还被大佬拒过几个 PR，与此同时我也在持续输出一个 Pulsar 相关的博客，当时也得到了大佬的认可：<br><img src="https://s2.loli.net/2024/07/08/spUaV8yPZMYbHAe.png"></p><p>之后我又根据日常工作中遇到的一些问题或者优化持续给社区提交 PR：<br><img src="https://s2.loli.net/2024/07/08/LPQ2RSHNotfJclY.png"></p><p>这个过程从第一个 PR 到社区大佬提名我大概经历了一年半的时间。</p><p>越大型、严谨的项目在处理这些 PR 时就是缓慢的，所以如果你真的想深度参与某个项目时就一定要有充分的耐心。</p><p>首先坚持下去，收获自然就来了。</p><hr><h3 id="Apache-HertzBeat"><a href="#Apache-HertzBeat" class="headerlink" title="Apache HertzBeat"></a>Apache HertzBeat</h3><p>今年四月份的时候我在朋友圈还看到另外一个项目：<a href="https://github.com/apache/hertzbeat">Apache HertzBeat</a>。</p><p>因为当时我也在做一些可观测性的内容，正好这个项目是和监控相关的；于是我就跟着文档走了一遍。</p><p>发现功能很强也很全，当时也是刚加入 Apache 的孵化器，所以还是有许多可以完善的地方。</p><p>我就开始以单测作为切入点尝试贡献源码，社区的响应速度也非常快。</p><p>之后逐渐将我在其他社区学到一些经验也复制到 HertzBeat 中，慢慢的贡献的代码越多，对 HertzBeat 也就更加熟悉了。</p><p>两个多月的时间我贡献了 30 个左右的 PR，后来也受到项目发起者的邀请：<br><img src="https://s2.loli.net/2024/07/08/L9SI6rO17TxkDaH.png" alt="image.png"></p><p>因为是相对更年轻的项目，才更需要大家群策群力；所以如果你也对监控系统感兴趣，或者比较熟悉前端技术栈（HertzBeat 有后台管理界面）都欢迎前来贡献，后续获得提名的机会要比已经发展稳定的项目更大一些。</p><h1 id="成为-Committer-的好处"><a href="#成为-Committer-的好处" class="headerlink" title="成为 Committer 的好处"></a>成为 Committer 的好处</h1><p>讲到这里顺便再讲讲成为  Committer 的一些好处了，虽然开源经常和免费白嫖划等号，大部分人都是用爱发电的，但因为也有许多大公司得到了开源的好处，所以也给活跃在社区里的贡献者提供了一些免费福利。</p><p>当然要拿到这些福利肯定是得有一个评判标准，最简单也最直观的就是你是否已经是 Apache 组织的 Committer。</p><h2 id="Github-Copilot"><a href="#Github-Copilot" class="headerlink" title="Github Copilot"></a>Github Copilot</h2><p>首先第一个好处是提供免费个人使用 Copilot，当然这不全是 Committer 的权益，如果你是某个开源项目的活跃贡献者也是可以申请的（不一定能申请过，目前好像没看到通过的标准），只是已经是 Committer 后肯定是能享受这个权益。</p><h2 id="Jetbrains-全家桶-IDE"><a href="#Jetbrains-全家桶-IDE" class="headerlink" title="Jetbrains 全家桶 IDE"></a>Jetbrains 全家桶 IDE</h2><p><img src="https://s2.loli.net/2024/07/08/kc9Ovp1u7M4DxWE.png"></p><p>JB 作为一个和开发者强绑定的公司，也提供了对应的福利，只要使用 Apache 的邮箱就可以免费使用他们的全家桶。</p><h2 id="Apache-邮箱"><a href="#Apache-邮箱" class="headerlink" title="Apache 邮箱"></a>Apache 邮箱</h2><p>提到了邮箱那就不得不提到 Apache 给每个 Committer 都会提供一个专属邮箱：<br><img src="https://s2.loli.net/2024/07/08/TQVkIhbUcAtpfCX.png"><br>虽然市面上有各种的免费邮箱注册服务，但当你使用 Apache 的邮箱和其他人沟通交流时，大概率对方潜意识里都会对你高看一点。</p><p>这虽然是一些虚无缥缈的东西，但有时候就是会让沟通更加顺畅（比如求职面试时）。</p><h2 id="项目的写权限"><a href="#项目的写权限" class="headerlink" title="项目的写权限"></a>项目的写权限</h2><p>还有一个好处就是有了项目的写权限，当你参与过开源项目就知道这个的重要性了，有些时候一些 PR 迟迟得不到回复和合并，自己只能干着急。</p><p>有了这个权限之后，只要你的 PR 有人 <code>Approve</code> 之后，在风险可控的情况下不用等着 maintainer 来合并，自己就可以操作。</p><p>同时得益于在社区的活跃程度，你再提交到 PR 会更得到重视，同时也能更好的推进某些 feature；这对于依赖某个开源项目的公司来说受益非常大。</p><h1 id="Apache-贡献阶梯"><a href="#Apache-贡献阶梯" class="headerlink" title="Apache 贡献阶梯"></a>Apache 贡献阶梯</h1><p>相信看到这里应该有不少人对成为 Apache Committer 感兴趣了，也比较好奇什么样的标准才能成为 Committer。</p><p>以下是我根据一些已经是 Committer 的大佬和 Apache 官方给的一个贡献阶梯作为参考总结出来的。</p><p><img src="https://s2.loli.net/2024/07/08/tlEuhMR85AmLasn.png"></p><p>参与开源的人主要分为以下几种角色：</p><ul><li>普通用户</li><li>贡献者</li><li>Committer</li><li>PMC 项目管理人员</li><li>基金会管理人员</li><li>基金会董事</li></ul><p>整个路径还是比较清晰的，只是从 PMC 开始到后面的董事难度都是指数级增加。</p><blockquote><p>目前整个国内当选过董事的都是屈指可数。</p></blockquote><p>而关于成为 Committer 的要求某些社区会有明显的标准：<br><img src="https://s2.loli.net/2024/07/08/qdfeaXc6gRlF5tN.png"></p><p>当然这个标准也不是一成不变的，只要持续的在社区活跃，有脸熟之后自然会有相关的 PMC 为你提名；当然这里的前提条件都是“持续活跃”。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后再总结下，为爱发电的开源项目也是可以获得回报的；特别是当你合并一个 PR 进入某个项目时带来的愉悦感非常强烈。</p><p>随着时间推进，在之后合并的 PR 可能没有前几次那么强烈，但只要达到一个范围，社区开始提名你为 Committer 时，这个多巴胺又会持续分泌。</p><p>同样的后续成为 PMC、管理人员、董事又会持续带来愉悦，当然难度也一个比一个大。</p><p>后面的层级离我还很远，如果今后有达到的一天再来和大家分享。</p><p>参考链接：</p><ul><li><a href="https://community.apache.org/contributor-ladder.html">https://community.apache.org/contributor-ladder.html</a></li><li><a href="https://hertzbeat.apache.org/zh-cn/docs/community/become_committer">https://hertzbeat.apache.org/zh-cn/docs/community/become_committer</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%BF%90%E5%8A%A8">https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%BF%90%E5%8A%A8</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/07/07/bj8NHqYFegTx1WU.png&quot; alt=&quot;image.png&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/07/07/a86fbuopri9mDeS.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近收到了 &lt;a href=&quot;https://github.com/apache/pulsar/&quot;&gt;Apache Pulsar&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/apache/hertzbeat/&quot;&gt;Apache HertzBeat&lt;/a&gt;社区的邀请邮件，成为了这两个项目的 &lt;code&gt;Committer&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
  </entry>
  
  <entry>
    <title>✅开源项目如何做集成测试</title>
    <link href="http://crossoverjie.top/2024/07/09/ob/%E2%9C%85%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%81%9A%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/"/>
    <id>http://crossoverjie.top/2024/07/09/ob/%E2%9C%85%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%81%9A%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/</id>
    <published>2024-07-09T03:15:25.000Z</published>
    <updated>2024-07-09T03:16:37.821Z</updated>
    
    <content type="html"><![CDATA[<p>之前有朋友问如何做集成测试，今天就重点讲讲这个集成测试在开源项目中是如何做的。</p><p>通常是需要对外提供服务的开源项目都需要集成测试：</p><ul><li>Pulsar</li><li>Kafka</li><li>Dubbo 等<span id="more"></span></li></ul><p>而只提供本地类库的项目通常只需要编写单元测试即可：</p><ul><li>Hutool</li><li>Apache Commmon</li></ul><p>以我接触到的服务型应用主要分为两类：一个是 Java 应用一个是 Golang 应用。</p><h1 id="🐳Golang"><a href="#🐳Golang" class="headerlink" title="🐳Golang"></a>🐳Golang</h1><p>Golang 因为工具链没有 Java 那么强大，所以大部分的集成测试的功能都是通过编写 Makefile 和 shell 脚本实现的。</p><p>还是以我熟悉的 Pulsar 的 go-client 为例，它在 GitHub 的集成测试是通过 GitHub action 触发的，定义如下：<br><img src="https://s2.loli.net/2024/05/20/f2196pujo8m7KRe.png"><br>最终调用的是 Makefile 中的 test 命令，并且把需要测试的 Golang 版本传入进去。</p><p><img src="https://s2.loli.net/2024/05/20/YpwtSHnLXqU1xQj.png"></p><p><code>Dockerfile</code>：<br><img src="https://s2.loli.net/2024/05/20/1ySGWF46U7EC2rk.png"></p><p>这个镜像简单来说就是将 Pulsar 的镜像作为基础运行镜像（这里面包含了 Pulsar 的服务端），然后将这个 pulsar-client-go 的代码复制进去编译。</p><p>接着运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /pulsar/pulsar-client-go &amp;&amp; ./scripts/run-ci.sh</span><br></pre></td></tr></table></figure><p>也就是测试脚本。</p><p><img src="https://s2.loli.net/2024/05/20/2Afmdu8ozRvH9FC.png"></p><p>测试脚本的逻辑也很简单：</p><ul><li>启动 pulsar 服务端</li><li>运行测试代码<br>因为所有的测试代码里连接服务端的地址都是 <code>localhost</code>，所以可以直接连接。<br><img src="https://s2.loli.net/2024/05/20/C1RHxTkuz25Mlj8.png"></li></ul><p>通过这里的 <a href="https://github.com/apache/pulsar-client-go/actions/runs/9014510238/job/24768797555">action</a> 日志可以跟踪所有的运行情况。</p><h1 id="☕Java"><a href="#☕Java" class="headerlink" title="☕Java"></a>☕Java</h1><p>Java 因为工具链强大，所以集成测试几乎不需要用 Makefile 和脚本配合执行。</p><p>还是以 Pulsar 为例，它的集成测试是需要模拟在本地启动一个服务端，然后再运行测试代码。</p><blockquote><p>这个的好处是任何一个单测都可以在本地直接运行，而  Go 的代码还需要先在本地启动一个服务端，测试起来比较麻烦。</p></blockquote><p>来看看它是如何实现的，我以其中一个 <a href="https://github.com/apache/pulsar/blob/631b13ad23d7e48c6e82d38f97c23d129062cb7c/pulsar-broker/src/test/java/org/apache/pulsar/client/impl/BrokerClientIntegrationTest.java#L117">BrokerClientIntegrationTest</a>为例：<br><img src="https://s2.loli.net/2024/05/20/9PbioA3RQLMBy6J.png"><br><img src="https://s2.loli.net/2024/05/20/blKePdxTUIkgRD3.png"><br>会在单测启动的时候先启动服务端。</p><p><img src="https://s2.loli.net/2024/05/20/gzY3lyTGuEDUwZF.png"></p><p>最终会调用 PulsarTestContext 的 build 函数启动 broker（服务端），而执行单测也只需要使用 mvn 就可以自动触发这些单元测试。<br><img src="https://s2.loli.net/2024/05/20/N15amZihWI73Qyw.png"><br>只是每一个单测都需要启停服务端，所以要把 Pulsar 的所有单测跑完通常需要 1～2 个小时。</p><p>所以这些集成测试本质上都是先要把测试环境构建出来，再跑对应的测试代码；后续也打算给 <a href="https://github.com/crossoverJie/cim">cim</a> 加上集成测试实操一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前有朋友问如何做集成测试，今天就重点讲讲这个集成测试在开源项目中是如何做的。&lt;/p&gt;
&lt;p&gt;通常是需要对外提供服务的开源项目都需要集成测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pulsar&lt;/li&gt;
&lt;li&gt;Kafka&lt;/li&gt;
&lt;li&gt;Dubbo 等</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
  </entry>
  
  <entry>
    <title>从 Helm 到 Operator：Kubernetes应用管理的进化</title>
    <link href="http://crossoverjie.top/2024/07/08/ob/how-operator-working/"/>
    <id>http://crossoverjie.top/2024/07/08/ob/how-operator-working/</id>
    <published>2024-07-08T03:19:51.000Z</published>
    <updated>2024-07-07T07:45:26.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🧰Helm-的作用"><a href="#🧰Helm-的作用" class="headerlink" title="🧰Helm 的作用"></a>🧰Helm 的作用</h1><p>在开始前需要先对 kubernetes  Operator 有个简单的认识。</p><p>以为我们在编写部署一些简单 <code>Deployment</code> 的时候只需要自己编写一个 yaml 文件然后 <code>kubectl apply</code> 即可。</p><span id="more"></span><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">  <span class="attr">template:</span>  </span><br><span class="line">    <span class="attr">metadata:</span>  </span><br><span class="line">      <span class="attr">labels:</span>  </span><br><span class="line">        <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">    <span class="attr">spec:</span>  </span><br><span class="line">      <span class="attr">containers:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">          <span class="attr">image:</span> <span class="string">crossoverjie/k8s-combat:v1</span>  </span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span>  </span><br><span class="line">          <span class="attr">resources:</span>  </span><br><span class="line">            <span class="attr">limits:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">300Mi</span>  </span><br><span class="line">            <span class="attr">requests:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;0.1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">30Mi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f deployment.yaml</span><br></pre></td></tr></table></figure><p>这对于一些并不复杂的项目来说完全够用了，但组件一多就比较麻烦了。</p><p><img src="https://s2.loli.net/2024/06/01/9EtzrfIAvcXm4aJ.png"><br>这里以 Apache Pulsar 为例：它的核心组件有:</p><ul><li>Broker</li><li>Proxy</li><li>Zookeeper</li><li>Bookkeeper</li><li>Prometheus(可选)</li><li>Grafana(可选)<br>等组件，每个组件的启动还有这依赖关系。<blockquote><p>必须需要等 Zookeeper 和 Bookkeeper 启动之后才能将流量放进来。</p></blockquote></li></ul><p>此时如何还继续使用 yaml 文件一个个部署就会非常繁琐，好在社区有提供 Helm 一键安装程序，使用它我们只需要在一个同意的 yaml 里简单的配置一些组件，配置就可以由 helm 来部署整个复杂的 Pulsar 系统。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">components:</span>  </span><br><span class="line">  <span class="comment"># zookeeper  </span></span><br><span class="line">  <span class="attr">zookeeper:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># bookkeeper  </span></span><br><span class="line">  <span class="attr">bookkeeper:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># bookkeeper - autorecovery  </span></span><br><span class="line">  <span class="attr">autorecovery:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># broker  </span></span><br><span class="line">  <span class="attr">broker:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># functions  </span></span><br><span class="line">  <span class="attr">functions:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="comment"># proxy  </span></span><br><span class="line">  <span class="attr">proxy:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># toolset  </span></span><br><span class="line">  <span class="attr">toolset:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># pulsar manager  </span></span><br><span class="line">  <span class="attr">pulsar_manager:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">monitoring:</span>  </span><br><span class="line">  <span class="comment"># monitoring - prometheus  </span></span><br><span class="line">  <span class="attr">prometheus:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># monitoring - grafana  </span></span><br><span class="line">  <span class="attr">grafana:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># monitoring - node_exporter  </span></span><br><span class="line">  <span class="attr">node_exporter:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># alerting - alert-manager  </span></span><br><span class="line">  <span class="attr">alert_manager:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>比如在 helm 的 yaml 中我们可以选择使用哪些 components，以及是否启用监控组件。</p><p>最后直接使用这个文件进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">helm install pulsar apache/pulsar \</span><br><span class="line">--values charts/pulsar/values.yaml \</span><br><span class="line">--<span class="built_in">set</span> namespace=pulsar \</span><br><span class="line">    --<span class="built_in">set</span> initialize=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>它就会自动生成各个组件的 yaml 文件，然后统一执行。</p><p>所以 helm 的本质上和 <code>kubectl apply yaml</code> 一样的，只是我们在定义 value.yaml 时帮我们处理了许多不需要用户低频修改的参数。</p><p>我们可以使用 helm 将要执行的 yaml 输出后人工审核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install pulsar apache/pulsar --dry-run --debug &gt; debug.yaml</span><br></pre></td></tr></table></figure><h1 id="🤔Operator-是什么"><a href="#🤔Operator-是什么" class="headerlink" title="🤔Operator 是什么"></a>🤔Operator 是什么</h1><h2 id="💔Helm-的痛点"><a href="#💔Helm-的痛点" class="headerlink" title="💔Helm 的痛点"></a>💔Helm 的痛点</h2><p>Helm 虽然可以帮我们部署或者升级一个大型应用，但他却没法帮我们运维这个应用。</p><p>举个例子：比如我希望当 Pulsar Broker 的流量或者内存达到某个阈值后就指定扩容 Broker，闲时再自动回收。</p><p>或者某个 Bookkeeper 的磁盘使用率达到阈值后可以自动扩容磁盘，这些仅仅使用 Helm 时都是无法实现的。</p><p>以上这些需求我们目前也是通过监控系统发出报警，然后再由人工处理。</p><p>其中最大的痛点就是进行升级：</p><ul><li>升级ZK</li><li>关闭auto recovery</li><li>升级Bookkeeper</li><li>升级Broker</li><li>升级Proxy</li><li>开启auto recovery</li></ul><p>因为每次升级是有先后顺序的，需要依次观察每个组件运行是否正常才能往后操作。</p><p>如果有 Operator 理性情况下下我们只需要更新一下镜像版本，它就可以自动执行以上的所有步骤最后将集群升级完毕。</p><p>所以相对于 Helm 来说 Operator 是可以站在一个更高的视角俯视整个应用系统，它能发现系统哪个地方需要它从而直接修复。</p><h2 id="💎CRD-Custom-Resource-Definitions"><a href="#💎CRD-Custom-Resource-Definitions" class="headerlink" title="💎CRD(Custom Resource Definitions)"></a>💎CRD(Custom Resource Definitions)</h2><p>而提到 Operator 那就不得不提到 CRD(Custom Resource Definitions)翻译过来就是自定义资源。</p><p>这是 kubernetes 提供的一个 API 扩展机制，类似于内置的 <code>Deployment/StatefulSet/Services</code> 资源，CRD 是一种自定义的资源。</p><p>这里以我们常用的 <code>prometheus-operator</code> 和 <code>VictoriaMetrics-operator</code> 为例：</p><p>Prometheus：</p><ul><li>**<code>Prometheus</code>**：用于定义 Prometheus 的 Deployment</li><li>**<code>Alertmanager</code>**：用于定义 <strong><code>Alertmanager</code></strong></li><li>**<code>ScrapeConfig</code>**：用于定会抓取规则</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">monitoring.coreos.com/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ScrapeConfig</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">static-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">my-namespace</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">prometheus:</span> <span class="string">system-monitoring-prometheus</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">staticConfigs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">job:</span> <span class="string">prometheus</span></span><br><span class="line">      <span class="attr">targets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">prometheus.demo.do.prometheus.io:9090</span></span><br></pre></td></tr></table></figure><p>使用时的一个很大区别就是资源的 <code>kind: ScrapeConfig</code> 为自定义的类型。</p><p>VictoriaMetrics 的 CRD：</p><ul><li>VMPodScrape：Pod 的抓取规则</li><li>VMCluster：配置 VM 集群</li><li>VMAlert：配置 VM 的告警规则</li><li>等等</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vmcluster.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">operator.victoriametrics.com/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VMCluster</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">retentionPeriod:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">  <span class="attr">replicationFactor:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">vmstorage:</span></span><br><span class="line">    <span class="attr">replicaCount:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">storageDataPath:</span> <span class="string">&quot;/vm-data&quot;</span></span><br><span class="line">    <span class="attr">storage:</span></span><br><span class="line">      <span class="attr">volumeClaimTemplate:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">storage:</span> <span class="string">&quot;10Gi&quot;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">  <span class="attr">vmselect:</span></span><br><span class="line">    <span class="attr">replicaCount:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">cacheMountPath:</span> <span class="string">&quot;/select-cache&quot;</span></span><br><span class="line">    <span class="attr">storage:</span></span><br><span class="line">      <span class="attr">volumeClaimTemplate:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">storage:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;0.5&quot;</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;500Mi&quot;</span></span><br><span class="line">  <span class="attr">vminsert:</span></span><br><span class="line">    <span class="attr">replicaCount:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>以上是用于创建一个 VM 集群的 CRD 资源，应用之后就会自动创建一个集群。</p><h1 id="Operator-原理"><a href="#Operator-原理" class="headerlink" title="Operator 原理"></a>Operator 原理</h1><p><img src="https://s2.loli.net/2024/06/01/t4ZnXcS9wokMPER.png"><br>Operator 通常是运行在 kubernetes API server 的 <code>webhook</code> 之上，简单来说就是在一些内置资源的关键节点 API-server 会调用我们注册的一个 <code>webhook</code>，在这个 <code>webhook</code> 中我们根据我们的 CRD 做一些自定义的操作。</p><p>理论上我们可以使用任何语言都可以写 Operator，只需要能处理 api-server 的回调即可。</p><p>只是 Go 语言有很多成熟的工具，比如常用的 <a href="https://kubebuilder.io/">kubebuilder</a> 和 <a href="https://sdk.operatorframework.io/">operator-sdk</a>.</p><p>他们内置了许多命令行工具，可以帮我们节省需要工作量。</p><p>这里以 operator-sdk 为例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ operator-sdk create webhook --group cache --version v1alpha1 --kind Memcached --defaulting --programmatic-validation</span><br></pre></td></tr></table></figure><p>会直接帮我们创建好一个标准的 operator 项目:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├── Dockerfile</span><br><span class="line">├── Makefile</span><br><span class="line">├── PROJECT</span><br><span class="line">├── api</span><br><span class="line">│   └── v1alpha1</span><br><span class="line">│       ├── memcached_webhook.go</span><br><span class="line">│       ├── webhook_suite_test.go</span><br><span class="line">├── config</span><br><span class="line">│   ├── certmanager</span><br><span class="line">│   │   ├── certificate.yaml</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── kustomizeconfig.yaml</span><br><span class="line">│   ├── default</span><br><span class="line">│   │   ├── manager_webhook_patch.yaml</span><br><span class="line">│   │   └── webhookcainjection_patch.yaml</span><br><span class="line">│   └── webhook</span><br><span class="line">│       ├── kustomization.yaml</span><br><span class="line">│       ├── kustomizeconfig.yaml</span><br><span class="line">│       └── service.yaml</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── main.go</span><br></pre></td></tr></table></figure><p>其中 Makefile 中包含了开发过程中常用的工具链（包括根据声明的结构体自动生成 CRD 资源、部署k8s 环境测试等等）、Dockerfile 等等。</p><p>这样我们就只需要专注于开发业务逻辑即可。</p><p>因为我前段时间给 <a href="https://github.com/open-telemetry/opentelemetry-operator">https://github.com/open-telemetry/opentelemetry-operator</a> 贡献过两个 feature，所以就以这个 Operator 为例：</p><p>它有一个 CRD: <code>kind: Instrumentation</code>，在这个 CRD 中可以将 OpenTelemetry 的 agent 注入到应用中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">opentelemetry.io/v1alpha1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Instrumentation</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">instrumentation-test-order</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">env:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_SERVICE_NAME</span>  </span><br><span class="line">      <span class="attr">value:</span> <span class="string">order</span></span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">order</span>  </span><br><span class="line">  <span class="attr">java:</span>  </span><br><span class="line">    <span class="attr">image:</span> <span class="string">autoinstrumentation-java:2.4.0-release</span>  </span><br><span class="line">    <span class="attr">extensions:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">autoinstrumentation-java:2.4.0-release</span>  </span><br><span class="line">        <span class="attr">dir:</span> <span class="string">/extensions</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="attr">env:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_RESOURCE_ATTRIBUTES</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">service.name=order</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_INSTRUMENTATION_MESSAGING_EXPERIMENTAL_RECEIVE_TELEMETRY_ENABLED</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;true&quot;</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_TRACES_EXPORTER</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">otlp</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_METRICS_EXPORTER</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">otlp</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_LOGS_EXPORTER</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">none</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXPORTER_OTLP_ENDPOINT</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">http://open-telemetry-opentelemetry-collector.otel.svc.cluster.local:4317</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXPORTER_OTLP_COMPRESSION</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">gzip</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTEL_EXPERIMENTAL_EXPORTER_OTLP_RETRY_ENABLED</span>  </span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure><p>它的运行规则是当我们的 Pod 在启动过程中会判断 Pod 的注解中是否开启了注入 OpenTelemetry 的配置。</p><p>如果开启则会将我们在 CRD 中自定义的镜像里的 javaagent 复制到业务容器中，同时会将下面的那些环境变量也一起加入的业务容器中。</p><p>要达到这样的效果就需要我们注册一个回调 endpoint。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mgr.GetWebhookServer().Register(<span class="string">&quot;/mutate-v1-pod&quot;</span>, &amp;webhook.Admission&#123;  </span><br><span class="line">    Handler: podmutation.NewWebhookHandler(cfg, ctrl.Log.WithName(<span class="string">&quot;pod-webhook&quot;</span>), decoder, mgr.GetClient(),  </span><br><span class="line">       []podmutation.PodMutator&#123;  </span><br><span class="line">          sidecar.NewMutator(logger, cfg, mgr.GetClient()),  </span><br><span class="line">          instrumentation.NewMutator(logger, mgr.GetClient(), mgr.GetEventRecorderFor(<span class="string">&quot;opentelemetry-operator&quot;</span>), cfg),  </span><br><span class="line">       &#125;),&#125;)</span><br></pre></td></tr></table></figure><p>当 Pod 创建或有新的变更请求时就会回调我们的接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *instPodMutator)</span></span> Mutate(ctx context.Context, ns corev1.Namespace, pod corev1.Pod) (corev1.Pod, <span class="type">error</span>) &#123;  </span><br><span class="line">    logger := pm.Logger.WithValues(<span class="string">&quot;namespace&quot;</span>, pod.Namespace, <span class="string">&quot;name&quot;</span>, pod.Name)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这个接口中我们就可以拿到 Pod 的信息，然后再获取 CRD <code>Instrumentation</code> 做我们的业务逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> otelInsts v1alpha1.InstrumentationList  </span><br><span class="line"><span class="keyword">if</span> err := pm.Client.List(ctx, &amp;otelInsts, client.InNamespace(ns.Name)); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 CRD 中将数据复制到业务容器中。</span></span><br><span class="line">pod.Spec.InitContainers = <span class="built_in">append</span>(pod.Spec.InitContainers, corev1.Container&#123;</span><br><span class="line">Name:      javaInitContainerName,</span><br><span class="line">Image:     javaSpec.Image,</span><br><span class="line">Command:   []<span class="type">string</span>&#123;<span class="string">&quot;cp&quot;</span>, <span class="string">&quot;/javaagent.jar&quot;</span>, javaInstrMountPath + <span class="string">&quot;/javaagent.jar&quot;</span>&#125;,</span><br><span class="line">Resources: javaSpec.Resources,</span><br><span class="line">VolumeMounts: []corev1.VolumeMount&#123;&#123;</span><br><span class="line">Name:      javaVolumeName,</span><br><span class="line">MountPath: javaInstrMountPath,</span><br><span class="line">&#125;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, extension := <span class="keyword">range</span> javaSpec.Extensions &#123;</span><br><span class="line">pod.Spec.InitContainers = <span class="built_in">append</span>(pod.Spec.InitContainers, corev1.Container&#123;</span><br><span class="line">Name:      initContainerName + fmt.Sprintf(<span class="string">&quot;-extension-%d&quot;</span>, i),</span><br><span class="line">Image:     extension.Image,</span><br><span class="line">Command:   []<span class="type">string</span>&#123;<span class="string">&quot;cp&quot;</span>, <span class="string">&quot;-r&quot;</span>, extension.Dir + <span class="string">&quot;/.&quot;</span>, javaInstrMountPath + <span class="string">&quot;/extensions&quot;</span>&#125;,</span><br><span class="line">Resources: javaSpec.Resources,</span><br><span class="line">VolumeMounts: []corev1.VolumeMount&#123;&#123;</span><br><span class="line">Name:      javaVolumeName,</span><br><span class="line">MountPath: javaInstrMountPath,</span><br><span class="line">&#125;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不过需要注意的是想要在测试环境中测试 operator 是需要安装一个 <a href="https://kubebuilder.io/quick-start">cert-manage</a>，这样 <code>webhook</code> 才能正常的回调。</p></blockquote><p><img src="https://s2.loli.net/2024/06/01/IUjriqye6EMFCT8.png"><br>要使得 CRD 生效，我们还得先将 CRD 安装进 kubernetes 集群中，不过这些 operator-sdk 这类根据已经考虑周到了。</p><p>我们只需要定义好 CRD 的结构体：<br><img src="https://s2.loli.net/2024/06/01/RBKp15lhkHsbeEY.png"></p><p>然后使用 Makefile 中的工具 <code>make bundle</code> 就会自动将结构体转换为 CRD。</p><p>参考链接：</p><ul><li><a href="https://github.com/VictoriaMetrics/operator">https://github.com/VictoriaMetrics/operator</a></li><li><a href="https://github.com/prometheus-operator/prometheus-operator">https://github.com/prometheus-operator/prometheus-operator</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;🧰Helm-的作用&quot;&gt;&lt;a href=&quot;#🧰Helm-的作用&quot; class=&quot;headerlink&quot; title=&quot;🧰Helm 的作用&quot;&gt;&lt;/a&gt;🧰Helm 的作用&lt;/h1&gt;&lt;p&gt;在开始前需要先对 kubernetes  Operator 有个简单的认识。&lt;/p&gt;
&lt;p&gt;以为我们在编写部署一些简单 &lt;code&gt;Deployment&lt;/code&gt; 的时候只需要自己编写一个 yaml 文件然后 &lt;code&gt;kubectl apply&lt;/code&gt; 即可。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="kubernetes" scheme="http://crossoverjie.top/categories/OB/kubernetes/"/>
    
    <category term="kubernetes" scheme="http://crossoverjie.top/categories/OB/kubernetes/kubernetes/"/>
    
    
    <category term="kubernetes" scheme="http://crossoverjie.top/tags/kubernetes/"/>
    
    <category term="Operator" scheme="http://crossoverjie.top/tags/Operator/"/>
    
  </entry>
  
  <entry>
    <title>【译】五个我最近在 Go 里学到的小技巧</title>
    <link href="http://crossoverjie.top/2024/07/02/ob/go-5-tips/"/>
    <id>http://crossoverjie.top/2024/07/02/ob/go-5-tips/</id>
    <published>2024-07-02T10:42:39.000Z</published>
    <updated>2024-07-02T11:11:48.928Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://medium.com/@andreiboar/5-small-tips-i-recently-learned-in-go-cf52d50cf129">https:&#x2F;&#x2F;medium.com&#x2F;@andreiboar&#x2F;5-small-tips-i-recently-learned-in-go-cf52d50cf129</a></p><h1 id="让编译器计算数组数量"><a href="#让编译器计算数组数量" class="headerlink" title="让编译器计算数组数量"></a>让编译器计算数组数量</h1><p>我们在 Go 通常很少使用数组 arrays，一般使用切片 Slice 来代替；</p><p>但是当你需要使用的时候，如果你对需要指定数量大小感到很烦时可以使用 <code>[...]</code> 让编译器自动帮我们计算数组大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  </span><br><span class="line">sameArr := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// Use ... instead of 3  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Arrays are equivalent  </span></span><br><span class="line">fmt.Println(arr)  </span><br><span class="line">fmt.Println(sameArr)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="使用-go-run-替换-go-run-main-go"><a href="#使用-go-run-替换-go-run-main-go" class="headerlink" title="使用 go run . 替换 go run main.go"></a>使用 go run . 替换 go run main.go</h1><p>每当我用 Go 写第一行代码时，我都习惯于开始写 <code>main.go</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>但是当 <code>main.go</code> 变得越来越大时，我喜欢把一些结构体移动到新的文件里，还是在 main 这个包中。</p><p>main.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">sayHello()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>say_hello.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;  </span><br><span class="line">fmt.Println(<span class="string">&quot;Hello!&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时使用 <code>go run main.go</code> 将会得到以下的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">command-line-arguments</span>  </span><br><span class="line">./main.go:4:2: undefined: sayHello</span><br></pre></td></tr></table></figure><p>此时可以使用 <code>go run .</code> 来解决这个问题。</p><h1 id="使用下划线让你的数字变得更易读"><a href="#使用下划线让你的数字变得更易读" class="headerlink" title="使用下划线让你的数字变得更易读"></a>使用下划线让你的数字变得更易读</h1><p>你知道可以使用下划线使得你的长数字更易读吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    number := <span class="number">10000000</span></span><br><span class="line">    better := <span class="number">10</span>_000_000</span><br><span class="line"></span><br><span class="line">    fmt.Println(number == better)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="可以在同一个包下有不同的测试包"><a href="#可以在同一个包下有不同的测试包" class="headerlink" title="可以在同一个包下有不同的测试包"></a>可以在同一个包下有不同的测试包</h1><p>在 Go 中我通常认为一个目录下只能有一个包，但也不是完全正确的。</p><p>假设你有一个包名为：<code>yourpackage</code> 此时你可以还可以在同一个目录下创建一个名为 <code>yourpackage_test</code> 的包，同时在这个包里编写你的测试代码。</p><p>这样做的好处是，那些没有被 exporter 的函数在 <code>yourpackage_test</code> 包下是不能直接访问的，确保测试的是被暴露的函数。</p><h1 id="多次传递相同参数的简单方法"><a href="#多次传递相同参数的简单方法" class="headerlink" title="多次传递相同参数的简单方法"></a>多次传递相同参数的简单方法</h1><p>在使用字符串格式化函数时，我总是觉得必须重复一个多次使用的参数很烦人：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Bob&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;My name is %s. Yes, you heard that right: %s\n&quot;</span>, name, name)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>还好还有更简便的方法，这样只需要传递一次参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">name := <span class="string">&quot;Bob&quot;</span>  </span><br><span class="line">fmt.Printf(<span class="string">&quot;My name is %[1]s. Yes, you heard that right: %[1]s\n&quot;</span>, name)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 Twitter 里发现的：<br><img src="https://s2.loli.net/2024/07/02/vaMP9CXwTEFcGKI.png"></p><p>希望你今天学到了一些新东西，最近有没有发现一些你从来不知道的 Golang 小技巧？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文链接：&lt;a href=&quot;https://medium.com/@andreiboar/5-small-tips-i-recently-learned-in-go-cf52d50cf129&quot;&gt;https:&amp;#x2F;&amp;#x2F;medium.com&amp;#x2F;@andreiboar&amp;#x2F;5-small-tips-i-recently-learned-in-go-cf52d50cf129&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;让编译器计算数组数量&quot;&gt;&lt;a href=&quot;#让编译器计算数组数量&quot; class=&quot;headerlink&quot; title=&quot;让编译器计算数组数量&quot;&gt;&lt;/a&gt;让编译器计算数组数量&lt;/h1&gt;&lt;p&gt;我们在 Go 通常很少使用数组 arrays，一般使用切片 Slice 来代替；&lt;/p&gt;
&lt;p&gt;但是当你需要使用的时候，如果你对需要指定数量大小感到很烦时可以使用 &lt;code&gt;[...]&lt;/code&gt; 让编译器自动帮我们计算数组大小：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr := [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sameArr := [...]&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125; &lt;span class=&quot;comment&quot;&gt;// Use ... instead of 3  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Arrays are equivalent  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fmt.Println(arr)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fmt.Println(sameArr)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="翻译" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="Go" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/Go/"/>
    
    
    <category term="Go" scheme="http://crossoverjie.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>如何找到并快速上手一个开源项目</title>
    <link href="http://crossoverjie.top/2024/07/01/ob/how-to-involve-OpenSource/"/>
    <id>http://crossoverjie.top/2024/07/01/ob/how-to-involve-OpenSource/</id>
    <published>2024-07-01T02:55:00.000Z</published>
    <updated>2024-07-31T02:19:26.123Z</updated>
    
    <content type="html"><![CDATA[<p>以前有写过两篇文章来简单聊过如何做开源的事情，最近我自己组了一个社区里面也有不少朋友对开源感兴趣，于是我便根据自己的经验系统的梳理了一些关于开源的事情。</p><ul><li><a href="https://crossoverjie.top/2023/08/05/ob/novice-contribute-open-source/">新手如何快速参与开源项目</a></li><li><a href="https://crossoverjie.top/2024/01/25/ob/create-a-plugin-for-cprobe/">手把手教你为开源项目贡献代码</a></li></ul><blockquote><p>有兴趣的可以先看看之前这两篇。</p></blockquote><span id="more"></span><h1 id="🔎如何找到自己感兴趣的开源项目"><a href="#🔎如何找到自己感兴趣的开源项目" class="headerlink" title="🔎如何找到自己感兴趣的开源项目"></a>🔎如何找到自己感兴趣的开源项目</h1><p>首先第一步先想清楚自己搞开源的目的是什么：</p><ul><li>参考社区大佬的代码，提升技术</li><li>丰富个人履历，提高面试通过率<ul><li>更功利一点就是想成为某个项目的 <code>Committer</code>&#x2F;<code>PMC</code></li></ul></li><li>单纯喜欢分享，热爱开源，认可开源改变世界💪。</li></ul><p>我认为前面三种都是一个目的，提升自己获得后续的好处；最后一种则是妥妥的纯热爱。</p><p>以我个人来说，我两者都沾一点；我相信大部分人都是前面三类的目的，到这里我可能要先浇点冷水。</p><blockquote><p>往往一个开源项目从你熟悉它开始到提第一个 PR 然后到合并中间经历的时间可能是大大超出你的预期的。</p></blockquote><p>特别是越大型越专业的项目（我相信你也是想加入这类有一定知名度的项目）。</p><p>因为开源社区大部分都是执行异步沟通，与即时通讯的快速反馈不同，甚至还有不少 reviewer 处于不同的时区。</p><p>所以一开始就想做好心理预期，不要指望着我给某个项目提交一个很牛逼的功能，然后他们快速 review 合并，然后给你 commit 权限。</p><p>而且有不少开源项目是由某一个公司主导的，比如（Pulsar、Golang、Kafka），他们可能对于外部社区来的新手并不那么上心，一个 PR 晾在那里几个月没人理都是很正常的。</p><p>所以我建议一开始选择的项目有以下几个筛选标准：</p><ul><li>尽量是自己日常在用，熟悉的项目。</li><li>最近有在及时更新维护的项目。</li><li>对社区新人的接纳程度是否足够包容。<ul><li>这点可以在 Github 里查找标签为 <code>help want/contribution welcome</code> 的 issue 或者是 PR。</li><li>查看这些 issue&#x2F; PR 最近的活跃时间，贡献者是否为新人。</li><li>往往一个包容度较高的项目以上信息都是很活跃的。</li></ul></li><li>项目主要维护者是否来着不同的公司，是否足够活跃。</li></ul><p><img src="https://s2.loli.net/2024/05/25/PIL8a5CoMbxRiwJ.png"><br><img src="https://s2.loli.net/2024/05/25/7CQaVFiAR4tyMbs.png"></p><p>推荐几个我认为比较符合我刚才提到的条件的项目：</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/7195">https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/7195</a></li><li><a href="https://github.com/apache/pulsar-client-go/issues?q=is:open+label:type/feature+sort:updated-desc">https://github.com/apache/pulsar-client-go/issues?q=is%3Aopen+label%3Atype%2Ffeature+sort%3Aupdated-desc</a></li><li><a href="https://github.com/apache/hertzbeat/">https://github.com/apache/hertzbeat/</a></li></ul><h1 id="🖐如何快速上手一个开源项目"><a href="#🖐如何快速上手一个开源项目" class="headerlink" title="🖐如何快速上手一个开源项目"></a>🖐如何快速上手一个开源项目</h1><p>如果找到了自己想贡献的项目，如果自己还不太熟悉的话，那就可以尝试以下步骤来快速上手它。</p><h2 id="✅单元测试"><a href="#✅单元测试" class="headerlink" title="✅单元测试"></a>✅单元测试</h2><p>首先第一个就是单元测试，单元测试是一个非常不错的方式来上手一个新的开源项目，<strong>但重点不是去看现有的单测，而是自己去写✍️</strong>。</p><p>写过单元测试的小伙伴就知道，如果要达到 90% 以上的覆盖率时需要对自己写的每一行代码都得了解，甚至在写的过程中会发现部分代码是不是没有必要，从而再帮助自己梳理一遍业务。</p><p>所以写单测确实是快速熟悉某个项目的方法，但这针对于一些逻辑简单的项目；对于一些业务复杂的项目建议还是快速跑通官方推荐一个功能。</p><h2 id="🌟以-Pulsar-为例"><a href="#🌟以-Pulsar-为例" class="headerlink" title="🌟以 Pulsar 为例"></a>🌟以 Pulsar 为例</h2><p>以 <a href="https://pulsar.apache.org/">Apache Pulsar</a>为例，那就先跑一个消息的生产者和消费者 demo；跑通了之后再尝试看看它客户端已有的单测代码，然后尝试改一些断言，此时就会发现预期值为什么会这么定义。<br><a href="https://github.com/apache/pulsar/blob/631b13ad23d7e48c6e82d38f97c23d129062cb7c/pulsar-broker/src/test/java/org/apache/pulsar/client/impl/BrokerClientIntegrationTest.java#L1077">https://github.com/apache/pulsar/blob/631b13ad23d7e48c6e82d38f97c23d129062cb7c/pulsar-broker/src/test/java/org/apache/pulsar/client/impl/BrokerClientIntegrationTest.java#L1077</a><br><img src="https://s2.loli.net/2024/05/17/CrITHSWeY1sP8dL.png"></p><p><img src="https://s2.loli.net/2024/05/17/J6DmLxQMZvuAqW7.png"></p><p>比如这里的一个 consumer 取消订阅两次时候就会抛出异常，此时我们就可以根据异常的地方找到源码里对连接状态的判断条件。</p><p>就可以得知：当客户端取消订阅时会修改连接状态。</p><h2 id="💓HertzBeat"><a href="#💓HertzBeat" class="headerlink" title="💓HertzBeat"></a>💓HertzBeat</h2><p>下面以 <a href="https://hertzbeat.apache.org/">Apache HertzBeat</a>为例来看看当时我是如何贡献单元测试的。</p><p><img src="https://s2.loli.net/2024/05/17/dixDGIQO2sZfh98.png"><br>通过官方的架构图可以得知 HertzBeat 是通过一个 collector 去直连目标采集数据的。</p><p>比如通过 Redis 的客户端去获取监控数据，然后再存放到自己的时序数据库中进行展示。</p><p>所以这个采集的过程就是比较核心的逻辑，我们可以看看他的接口定义。</p><p><img src="https://s2.loli.net/2024/05/17/3quVop5vSr6KzPY.png"><br>一共就三个接口，分别是：</p><ul><li>collect采集接口：在 Metrics 中定义了采集的目标信息（地址、端口等）<ul><li>采集完后的数据写入到 Builder 供后续的写入存储</li></ul></li><li>preCheck：提前做一些参数校验</li><li>supportProtocol：返回定义的协议类型，通过这个类型找到对应采集器</li></ul><p><img src="https://s2.loli.net/2024/05/17/hQZaFV2qo3176uf.png"></p><p>然后就交由不同的实现类去采集不同的指标。</p><p>这里我以 <code>RedisCommonCollectImpl</code>为例，主要的单测逻辑就是模拟 Redis 客户端的返回数据，然后在 Collect 的代码里查看不同的处理逻辑，其实就是要覆盖各种分支以及异常的情况。</p><p>最后再断言采集到的数据与预期是否匹配即可，贴一段核心逻辑：<br><img src="https://s2.loli.net/2024/05/17/EnrZxdDR5kLtMIG.png"></p><p>至于应该返回什么预期结果，有些 collector 可能会在代码注释里写清楚，但这个 Redis 没有写。</p><p>不过也有办法，我们可以把代码在本地跑起来之后进入管理台查看内置的监控模版。</p><p><img src="https://s2.loli.net/2024/05/17/g4EL7AdGfbrpXKU.png"><br>这里是用于定义会监控哪些字段的地方，这样我们就可以在代码预先生成好预期返回值了。</p><p><img src="https://s2.loli.net/2024/05/17/OCEYUZHscP6waI3.png"></p><p>具体的单测代码请看这里：<br><a href="https://github.com/apache/hertzbeat/blob/master/collector/src/test/java/org/apache/hertzbeat/collector/collect/redis/RedisClusterCollectImplTest.java#L46">https://github.com/apache/hertzbeat/blob/master/collector/src/test/java/org/apache/hertzbeat/collector/collect/redis/RedisClusterCollectImplTest.java#L46</a></p><h1 id="📝总结"><a href="#📝总结" class="headerlink" title="📝总结"></a>📝总结</h1><p>参与一个成熟社区的开源有一点一定要记住，<strong>就是要仔细阅读<a href="https://hertzbeat.apache.org/zh-cn/docs/community/contribution">贡献者文档</a>。</strong></p><p>里面往往会写清楚如何构建代码、代码规范、提交规范等信息，这些都捋清楚后提交的 PR 才更容易被社区接受。</p><p>后面会继续更新集成测试与 <code>e2e</code> 测试等内容。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前有写过两篇文章来简单聊过如何做开源的事情，最近我自己组了一个社区里面也有不少朋友对开源感兴趣，于是我便根据自己的经验系统的梳理了一些关于开源的事情。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2023/08/05/ob/novice-contribute-open-source/&quot;&gt;新手如何快速参与开源项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2024/01/25/ob/create-a-plugin-for-cprobe/&quot;&gt;手把手教你为开源项目贡献代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;有兴趣的可以先看看之前这两篇。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
  </entry>
  
  <entry>
    <title>OpenTelemetry 深度定制：跨服务追踪的实战技巧</title>
    <link href="http://crossoverjie.top/2024/06/26/ob/OpenTelemetry-custom-instrument/"/>
    <id>http://crossoverjie.top/2024/06/26/ob/OpenTelemetry-custom-instrument/</id>
    <published>2024-06-26T11:58:03.000Z</published>
    <updated>2024-07-01T01:33:40.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><img src="https://s2.loli.net/2024/05/19/7CnOFegSu4TLbhd.png"></p><p>在上一篇<a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">《从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅》</a>中在最后提到在做一些 Trace 的定制开发。</p><p>到现在差不多算是完成了，可以和大家分享一下。</p><p>我们的需求是这样的：</p><p><img src="https://s2.loli.net/2024/05/19/qex6IFcOnQ591gT.png"><br>假设现在有三个服务：ServiceA、ServiceB、ServiceC</p><span id="more"></span><p><code>ServiceA</code> 对外提供了一个 http 接口 <code>request</code>，在这个接口会调用 <code>ServiceB</code> 的 <code>order</code> 订单接口创建订单，同时 <code>serviceB</code> 调用 <code>serviceC</code> 的 pay 接口。</p><p><img src="https://s2.loli.net/2024/05/19/GtljX3BLVcePWFn.png"><br>整个调用关系如上图所示。</p><p>默认情况下 span 中的 attribute 会记录当前 span 的一些信息，比如：<br><img src="https://s2.loli.net/2024/05/19/tvgdT1Mke7OjPGp.png"><br>这些都是当前一些当前 span 内置的信息，比如当前 gRPC 接口的一些基本数据：服务名、ip、端口等信息。</p><p>但这里并没有上游的一些信息，虽然我们可以通过 Jaeger 的树状图得知上游是哪个应用调用过来的，但是一旦某个 span 下有多个子 span 的调用，就没办法很直观知道这个子 span 的上游是由谁发起的调用。</p><p>比如如下这个链路：<br><img src="https://s2.loli.net/2024/05/19/3rOdKfBmhSjz1GF.png"><br>当一个调用链非常长，同时也非常复杂时，没办法第一时间知道某一个 span 的上游到底是谁发起的，需要手动一层层的去折叠，或者全靠眼睛去找。</p><h2 id="预期效果"><a href="#预期效果" class="headerlink" title="预期效果"></a>预期效果</h2><p><img src="https://s2.loli.net/2024/05/19/9v3cGMrez8XA2ZH.png"></p><p>为此我们希望的效果是可以通过给每一个子 span 中加入两个 attribute，来标明它的父调用来源。</p><p>比如在 serviceB 中的所有 span 中都会加上两个标签：来源是 serviceA，同时是 serviceA 的 request 接口发起的请求。</p><p>而在 serviceC 中同样可以知道来源是 serviceB 的 Order 接口发起的调用。</p><p>我启动了三个 demo 应用，分别是 create1，create2，create3.</p><p>create1 中会提供一个 <code>request</code> 接口，在这里面调用 create2 的 <code>create2</code> 接口，<code>create2</code> 的接口里接着调用 create3 的 <code>create3</code> 接口。</p><p>create1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/request&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;  </span><br><span class="line">   <span class="type">HelloRequest</span> <span class="variable">request</span> <span class="operator">=</span> HelloRequest.newBuilder()  </span><br><span class="line">         .setName(name)  </span><br><span class="line">         .build();  </span><br><span class="line">   log.info(<span class="string">&quot;request: &#123;&#125;&quot;</span>, request);  </span><br><span class="line">   <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> myServiceStub.create2(request).getMessage();  </span><br><span class="line">   Executors.newFixedThreadPool(<span class="number">1</span>).execute(() -&gt; &#123;  </span><br><span class="line">      myServiceStub.create2(request).getMessage();  </span><br><span class="line">   &#125;);       <span class="keyword">return</span> message;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create2</span><span class="params">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;  </span><br><span class="line">    <span class="type">HelloReply</span> <span class="variable">reply</span> <span class="operator">=</span> HelloReply.newBuilder()  </span><br><span class="line">            .setMessage(<span class="string">&quot;Create2 ==&gt; &quot;</span> + request.getName())  </span><br><span class="line">            .build();  </span><br><span class="line">    log.info(<span class="string">&quot;Create2: &#123;&#125;&quot;</span>, reply.getMessage());  </span><br><span class="line">    myMethod(request.getName());  </span><br><span class="line">    myServiceStub.create3(request);</span><br><span class="line">    responseObserver.onNext(reply);  </span><br><span class="line">    responseObserver.onCompleted();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create3:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create3</span><span class="params">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;  </span><br><span class="line">    <span class="type">HelloReply</span> <span class="variable">reply</span> <span class="operator">=</span> HelloReply.newBuilder()  </span><br><span class="line">            .setMessage(<span class="string">&quot;Create3 ==&gt; &quot;</span> + request.getName())  </span><br><span class="line">            .build();  </span><br><span class="line">    log.info(<span class="string">&quot;Create3: &#123;&#125;&quot;</span>, reply.getMessage());  </span><br><span class="line">    myMethod(request.getName());  </span><br><span class="line">    responseObserver.onNext(reply);  </span><br><span class="line">    responseObserver.onCompleted();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.javaagent.extensions=otel-extensions-custom-context-1.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.traces.exporter=otlp \</span><br><span class="line">-Dotel.logs.exporter=none \</span><br><span class="line">-Dotel.service.name=create2 \</span><br><span class="line">-Dotel.exporter.otlp.protocol=grpc \</span><br><span class="line">-Dotel.propagators=tracecontext,baggage,demo \</span><br><span class="line">-Dotel.exporter.otlp.endpoint=http://127.0.0.1:5317 \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar --spring.application.name=create2 --server.port=9191 --grpc.server.port=9292 --grpc.client.myService.address=static://127.0.0.1:9393</span><br></pre></td></tr></table></figure><p>只是每个应用都需要使用我这边单独打的 agent 包以及一个 <code>extension</code>(tel-extensions-custom-context-1.0-SNAPSHOT.jar) 才能生效。</p><p>最终的效果如下：<br><img src="https://s2.loli.net/2024/05/19/4o5mEhjnMbZWL62.png"></p><h1 id="Baggage"><a href="#Baggage" class="headerlink" title="Baggage"></a>Baggage</h1><p>在讲具体的实现之前需要先了解几个 Trace 中的概念，在这里主要用到的是一个称为 Baggage 的对象。</p><p>在之前的文章中其实提到过它的原理以及使用场景：<br><a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/?highlight=%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%BD%E8%B8%AA%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E6%97%85#Baggage">从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅</a></p><p><img src="https://s2.loli.net/2024/05/19/gv2YEoO6LkiGIF9.png"></p><p>Baggage 的中文翻译是：包裹📦；简单来说就是我们可以通过自定义 baggage 可以将我们想要的数据存放在其中，这样再整个 Trace 的任意一个 Span 中都可以读取到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/request&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;  </span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">    Baggage.current().toBuilder().  </span><br><span class="line">          put(<span class="string">&quot;request.name&quot;</span>, name).build()  </span><br><span class="line">          .storeInContext(Context.current()).makeCurrent();</span><br><span class="line">&#125;         </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> Baggage.current().getEntryValue(<span class="string">&quot;request.name&quot;</span>);  </span><br><span class="line">log.info(<span class="string">&quot;request.name: &#123;&#125;&quot;</span>, value);</span><br></pre></td></tr></table></figure><p>理解了这个之后，我们要实现的将上游的信息传递到下游就可以通过这个组件实现了。</p><p>只需要在上游创建 span 时将它自身数据写入到 Baggage 中，再到下游 span 取出来写入到 attribute 中即可。</p><h1 id="ContextCustomizer"><a href="#ContextCustomizer" class="headerlink" title="ContextCustomizer"></a>ContextCustomizer</h1><p>这里的关键就是在哪里写入这个 Baggage，因为对第三方组件的 Instrumentation 的实现都是在 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation">opentelemetry-java-instrumentation</a>项目中。</p><blockquote><p>javaagent.jar 包也是通过该项目打包出来的。</p></blockquote><p>所以在该项目的 <code>io.opentelemetry.instrumentation.api.instrumenter.Instrumenter#doStart</code> 这个函数中我们发现一段逻辑：</p><p><img src="https://s2.loli.net/2024/05/20/FYiAnq2G3voIyR4.png"></p><hr><blockquote><p>这个函数是在创建一个 span 的时候调用的，通常这个创建函数是在这些第三方库的拦截器中创建的。</p></blockquote><p><img src="https://s2.loli.net/2024/05/20/b3cxYekiUGaSlO9.png"><br>比如这是在 grpc 的拦截器中调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context customizers run before span start, so that they can have access to the parent span  </span></span><br><span class="line"><span class="comment">// context, and so that their additions to the context will be visible to span processors  </span></span><br><span class="line"><span class="keyword">for</span> (ContextCustomizer&lt;? <span class="built_in">super</span> REQUEST&gt; contextCustomizer : contextCustomizers) &#123;  </span><br><span class="line">  context = contextCustomizer.onStart(context, request, attributes);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ContextCustomizer</code> 是一个接口只提供了一个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContextCustomizer</span>&lt;REQUEST&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** Allows to customize the operation &#123;<span class="doctag">@link</span> Context&#125;. */</span>  </span><br><span class="line">  Context <span class="title function_">onStart</span><span class="params">(Context parentContext, REQUEST request, Attributes startAttributes)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Context</code> 是上下文信息，可以在自定义的 ContextCustomizer 继续往上下文中追加信息。</li><li><code>REQUEST</code> 是一个泛型：一般是当前第三方组件的请求信息：<ul><li>比如是 <code>HTTP</code> 时，这个 <code>request</code> 就是 HTTP 的请求信息。</li><li>而如果是 <code>gRPC</code> ，则是 <code>gRPC</code> 的请求信息。</li><li>其他的请求类型同理。</li></ul></li><li><code>startAttributes</code> 则是预先写入的一些属性，比如在上图中看到的一些 <code>rpc.service/rpc.method</code>等字段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context customizers run before span start, so that they can have access to the parent span  </span></span><br><span class="line"><span class="comment">// context, and so that their additions to the context will be visible to span processors</span></span><br></pre></td></tr></table></figure><p>从这个接口的调用注释可以看出：<br>这个自定义的 context 会在 span 开始之前调用，所以在这里是可以访问到当前创建的 span 的父 context，同时在这里的 context 中新增的数据可以在 <code>SpanProcessor</code> 访问到。</p><h1 id="SpanProcessor"><a href="#SpanProcessor" class="headerlink" title="SpanProcessor"></a>SpanProcessor</h1><p>而 SpanProcessor 又是一个非常的重要的组件，我们接着刚才的 <code>contextCustomizer</code> 处往后跟踪代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context = contextCustomizer.onStart(context, request, attributes);</span><br><span class="line">---&gt;<span class="type">Span</span> <span class="variable">span</span> <span class="operator">=</span> spanBuilder.setParent(context).startSpan();</span><br><span class="line">---&gt;io.opentelemetry.sdk.trace.SdkSpanBuilder#startSpan</span><br><span class="line">---&gt;io.opentelemetry.sdk.trace.SdkSpan#startSpan</span><br><span class="line">---&gt;spanProcessor.onStart(parentContext, span);</span><br></pre></td></tr></table></figure><p>可以看到 <code>spanProcessor.onStart</code> 这个函数会在 contextCustomizer 之后调用。</p><p><img src="https://s2.loli.net/2024/05/20/vpxHt34TUbgfShz.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * SpanProcessor is the interface &#123;<span class="doctag">@link</span> SdkTracer&#125; uses to allow synchronous hooks for when a  </span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Span&#125; is started or when a &#123;<span class="doctag">@code</span> Span&#125; is ended.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//==========================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Called when a &#123;<span class="doctag">@link</span> io.opentelemetry.api.trace.Span&#125; is started, if the &#123;<span class="doctag">@link</span>  </span></span><br><span class="line"><span class="comment"> * Span#isRecording()&#125; returns true.  </span></span><br><span class="line"><span class="comment"> * * &lt;p&gt;This method is called synchronously on the execution thread, should not throw or block the  </span></span><br><span class="line"><span class="comment"> * execution thread. * * <span class="doctag">@param</span> parentContext the parent &#123;<span class="doctag">@code</span> Context&#125; of the span that just started.  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> span the &#123;<span class="doctag">@code</span> Span&#125; that just started.  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(Context parentContext, ReadWriteSpan span)</span>;</span><br></pre></td></tr></table></figure><p>从注释中可以知道 SpanProcessor 是作为一个 span 的生命周期中的关键节点的 hook 函数。</p><p>在这些函数中我们可以自定义一些 span 的数据，比如在 <code>onStart</code> 还可以往 span 中写入一些自定义的 attribute。</p><p>这也是我们这次会用到的一个接口，我们的方案是：</p><p>在 gRPC 构建 Instrument 时自定义一个 <code>GrpcServerContextCustomizer</code> ，在这个自定义的 <code>ContextCustomizer</code> 中写入一个 <code>Baggage</code>。</p><p>然后在 <code>io.opentelemetry.sdk.trace.SpanProcessor#onStart</code> 接口中取出这个 <code>Baggage</code> 写入到当前 span 的 attribute 中。</p><p>这样我们就可以看到之前提到的那些数据上游信息了。<br><img src="https://s2.loli.net/2024/05/19/4o5mEhjnMbZWL62.png"></p><h1 id="为-gRPC-添加上下文"><a href="#为-gRPC-添加上下文" class="headerlink" title="为 gRPC 添加上下文"></a>为 gRPC 添加上下文</h1><p>先来看看如何为 gRPC 添加 <code>Baggage</code>：</p><p>我们先自定义一个 <code>GrpcServerContextCustomizer</code> 实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrpcServerContextCustomizer</span> <span class="keyword">implements</span> <span class="title class_">ContextCustomizer</span>&lt;GrpcRequest&gt; &#123;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String currentServiceName;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARENT_RPC_KEY</span> <span class="operator">=</span> <span class="string">&quot;parent_rpc&quot;</span>;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CURRENT_RPC_KEY</span> <span class="operator">=</span> <span class="string">&quot;current_rpc&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CURRENT_HTTP_URL_PATH</span> <span class="operator">=</span> <span class="string">&quot;current_http_url_path&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">GrpcServerContextCustomizer</span><span class="params">(String serviceName)</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>.currentServiceName = serviceName;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">public</span> Context <span class="title function_">onStart</span><span class="params">(Context parentContext, GrpcRequest grpcRequest,  </span></span><br><span class="line"><span class="params">      Attributes startAttributeds)</span> &#123;  </span><br><span class="line">    <span class="type">BaggageBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Baggage.fromContext(parentContext).toBuilder();  </span><br><span class="line">  </span><br><span class="line">    <span class="type">String</span> <span class="variable">currentRpc</span> <span class="operator">=</span> Baggage.fromContext(parentContext).getEntryValue(CURRENT_RPC_KEY);  </span><br><span class="line">    <span class="type">String</span> <span class="variable">fullMethodName</span> <span class="operator">=</span> startAttributeds.get(AttributeKey.stringKey(<span class="string">&quot;rpc.method&quot;</span>));  </span><br><span class="line">    <span class="type">String</span> <span class="variable">rpcService</span> <span class="operator">=</span> startAttributeds.get(AttributeKey.stringKey(<span class="string">&quot;rpc.service&quot;</span>));  </span><br><span class="line">    <span class="comment">// call from grpc  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> rpcService + <span class="string">&quot;:&quot;</span> + fullMethodName;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">baggageInfo</span> <span class="operator">=</span> getBaggageInfo(currentServiceName, method);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">String</span> <span class="variable">httpUrlPath</span> <span class="operator">=</span> Baggage.fromContext(parentContext).getEntryValue(CURRENT_HTTP_URL_PATH);  </span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isNullOrEmpty(httpUrlPath)) &#123;  </span><br><span class="line">      <span class="comment">// call from http  </span></span><br><span class="line">      <span class="comment">// currentRpc = currentRpc;  currentRpc = create1|GET:/request      // clear current_http_url_path      builder.put(CURRENT_HTTP_URL_PATH, &quot;&quot;);  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">Baggage</span> <span class="variable">baggage</span> <span class="operator">=</span> builder  </span><br><span class="line">        .put(PARENT_RPC_KEY, currentRpc)  </span><br><span class="line">        .put(CURRENT_RPC_KEY, baggageInfo)  </span><br><span class="line">        .build();  </span><br><span class="line">    <span class="keyword">return</span> parentContext.with(baggage);  </span><br><span class="line">  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getBaggageInfo</span><span class="params">(String serviceName, String method)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNullOrEmpty(serviceName)) &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  </span><br><span class="line">    &#125;    <span class="keyword">return</span> serviceName + <span class="string">&quot;|&quot;</span> + method;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个代码中可以看出，我们需要先从上下文中获取 <code>CURRENT_RPC_KEY</code> ，从而得知当前的 span 是不是 root span。</p><p>所以我们其实是把当前的 span 信息作为一个 <code>PARENT_RPC_KEY</code> 写入到 Baggage 中。</p><p>这样在 <code>SpanProcessor</code> 中便可以直接取出 <code>PARENT_RPC_KEY</code> 作为上游的信息写入 span 的 attribute 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(Context parentContext, ReadWriteSpan span)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">parentRpc</span> <span class="operator">=</span> Baggage.fromContext(parentContext).getEntryValue(<span class="string">&quot;parent_rpc&quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isNullOrEmpty(parentRpc)) &#123;  </span><br><span class="line">        String[] split = parentRpc.split(<span class="string">&quot;\\|&quot;</span>);  </span><br><span class="line">        span.setAttribute(<span class="string">&quot;parent_rpc&quot;</span>, parentRpc);  </span><br><span class="line">        span.setAttribute(<span class="string">&quot;parent_service_name&quot;</span>, split[<span class="number">0</span>]);  </span><br><span class="line">        span.setAttribute(<span class="string">&quot;parent_service_method&quot;</span>, split[<span class="number">1</span>]); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，这里的 Baggage 需要使用 <code>Baggage.fromContext(parentContext)</code> 才能拿到刚才写入 Baggage 信息。</p></blockquote><p>之后我们找到构建 <a href="https://github.com/crossoverjie/opentelemetry-java-instrumentation/blob/715220c8d5e52001f9af9afbeb00bb87b4db0197/instrumentation/grpc-1.6/library/src/main/java/io/opentelemetry/instrumentation/grpc/v1_6/GrpcTelemetryBuilder.java#L31">gRPCServerInstrumenterBuilder</a> 的地方，写入我们刚才自定义的 <code>GrpcServerContextCustomizer</code> 即可。</p><p><img src="https://s2.loli.net/2024/05/20/rwSc8HmvqKL9ZQl.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.addContextCustomizer(<span class="keyword">new</span> <span class="title class_">GrpcServerContextCustomizer</span>(serviceName))</span><br></pre></td></tr></table></figure><p>这里我们选择写入到是 <code>serverInstrumenterBuilder</code> 而不是<code>clientInstrumenterBuilder</code>，因为在服务端的入口就知道是从哪个接口进来的请求。</p><h1 id="为-spring-boot-的-http-接口添加上下文"><a href="#为-spring-boot-的-http-接口添加上下文" class="headerlink" title="为 spring boot 的 http 接口添加上下文"></a>为 spring boot 的 http 接口添加上下文</h1><p>如果只存在 gRPC 调用时只添加 <code>gRPC</code> 的上下文也够用了，但是我们也不排除由外部接口是通过 HTTP 访问进来的，然后再调用内部的 <code>gRPC</code> 接口；这也是非常常见的架构模式。</p><p>所以我们还需要在 HTTP 中增加 <code>ContextCustomizer</code> 将自身的数据写入到 <code>Baggage</code> 中。</p><p>好在 <code>HttpServerRouteBuilder</code> 自身是实现了 <code>ContextCustomizer</code> 接口的，我们只需要往里面写入 <code>Baggage</code> 数据即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ContextCustomizer&lt;REQUEST&gt; <span class="title function_">build</span><span class="params">()</span> &#123;  </span><br><span class="line">  Set&lt;String&gt; knownMethods = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="built_in">this</span>.knownMethods);  </span><br><span class="line">  <span class="keyword">return</span> (context, request, startAttributes) -&gt; &#123;  </span><br><span class="line">    <span class="keyword">if</span> (HttpRouteState.fromContextOrNull(context) != <span class="literal">null</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> context;  </span><br><span class="line">    &#125;    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> getter.getHttpRequestMethod(request);  </span><br><span class="line">    <span class="keyword">if</span> (method == <span class="literal">null</span> || !knownMethods.contains(method)) &#123;  </span><br><span class="line">      method = <span class="string">&quot;HTTP&quot;</span>;  </span><br><span class="line">    &#125;    <span class="type">String</span> <span class="variable">urlPath</span> <span class="operator">=</span> getter.getUrlPath(request);  </span><br><span class="line">    <span class="type">String</span> <span class="variable">methodPath</span> <span class="operator">=</span> method + <span class="string">&quot;:&quot;</span> + urlPath;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">String</span> <span class="variable">currentRpc</span> <span class="operator">=</span> Baggage.fromContext(context).getEntryValue(CURRENT_RPC_KEY);  </span><br><span class="line">    <span class="type">String</span> <span class="variable">baggageInfo</span> <span class="operator">=</span> getBaggageInfo(serviceName, methodPath);  </span><br><span class="line">    <span class="type">Baggage</span> <span class="variable">baggage</span> <span class="operator">=</span> Baggage.fromContext(context).toBuilder()  </span><br><span class="line">        .put(PARENT_RPC_KEY, currentRpc)  </span><br><span class="line">        .put(CURRENT_RPC_KEY, baggageInfo)  </span><br><span class="line">        .put(CURRENT_HTTP_URL_PATH, methodPath)  </span><br><span class="line">        .build();   </span><br><span class="line">    <span class="keyword">return</span> context.with(HttpRouteState.create(method, <span class="literal">null</span>, <span class="number">0</span>))  </span><br><span class="line">        .with(baggage);  </span><br><span class="line">  &#125;;&#125;</span><br></pre></td></tr></table></figure><p>这里新增了 <code>CURRENT_HTTP_URL_PATH</code> 用于标记当前的请求来源是 HTTP，在 grpc 的 <code>ContextCustomizer</code> 解析时会判断这个值是否为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">httpUrlPath</span> <span class="operator">=</span> Baggage.fromContext(parentContext).getEntryValue(CURRENT_HTTP_URL_PATH);  </span><br><span class="line"><span class="keyword">if</span> (!StringUtils.isNullOrEmpty(httpUrlPath)) &#123;  </span><br><span class="line">  <span class="comment">// call from http  </span></span><br><span class="line">  <span class="comment">// currentRpc = currentRpc;  currentRpc = create1|GET:/request  // clear current_http_url_path  builder.put(CURRENT_HTTP_URL_PATH, &quot;&quot;);  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><img src="https://s2.loli.net/2024/05/20/ionwTD9EAr3CROL.png"></p><p>这样就可以在 grpc 的下游接口拿到入口的 HTTP 接口数据了。</p><hr><p>当然也有可能是在 grpc 接口中调用 HTTP 的接口的场景，只是我们的业务中没有这种情况，所以就没有适配这类的场景。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>ContextCustomizer</code> 接口没有提供对应的扩展，但是 <code>SpanProcessor</code> 是提供了扩展接口的。</p><blockquote><p>原本是想尽量别维护自己的 javaagent，但也好在 OpenTelemetry 是提供的接口，所以也并不会去修改原本的代码。</p></blockquote><p>所以我们还是需要创建一个 extensions 的项目在实现 <code>SpanProcessor</code>，这个在之前的 <a href="https://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/">《实战：如何编写一个 OpenTelemetry Extensions》</a>有详细讲到。</p><p>所以最后的应用启动方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.javaagent.extensions=otel-extensions-custom-context-1.0-SNAPSHOT.jar \</span><br></pre></td></tr></table></figure><p>需要使用我们手动打包的 javaagent 以及一个自定义扩展包。</p><p>打包方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew assemble</span><br></pre></td></tr></table></figure><blockquote><p><code>opentelemetry-java-instrumentation</code> 项目比较大，所以打包过程可能比较久。</p></blockquote><p>因为这其实是一些定制需求，所以就没提交到上游，感兴趣的可以自行合并代码测试。</p><p>最后可以这个分支中查看到修改的部分：<br><a href="https://github.com/crossoverJie/opentelemetry-java-instrumentation/compare/main...add-grpc-context">https://github.com/crossoverJie/opentelemetry-java-instrumentation/compare/main...add-grpc-context</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/05/19/7CnOFegSu4TLbhd.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一篇&lt;a href=&quot;https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/&quot;&gt;《从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅》&lt;/a&gt;中在最后提到在做一些 Trace 的定制开发。&lt;/p&gt;
&lt;p&gt;到现在差不多算是完成了，可以和大家分享一下。&lt;/p&gt;
&lt;p&gt;我们的需求是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/05/19/qex6IFcOnQ591gT.png&quot;&gt;&lt;br&gt;假设现在有三个服务：ServiceA、ServiceB、ServiceC&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>从 Prometheus 到 OpenTelemetry：指标监控的演进与实践</title>
    <link href="http://crossoverjie.top/2024/06/13/ob/OpenTelemetry-metrics-concept/"/>
    <id>http://crossoverjie.top/2024/06/13/ob/OpenTelemetry-metrics-concept/</id>
    <published>2024-06-13T10:22:48.000Z</published>
    <updated>2024-07-21T14:36:43.951Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇：<a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅</a>我们讲解了 Trace 的一些核心概念：</p><ul><li>Trace</li><li>Span</li><li>Context</li><li>Baggage 等</li></ul><p>这次我们来讲另一个话题 <code>Metrics</code>。</p><span id="more"></span><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>关于 metrics 我最早接触相关概念的就是 prometheus，它是第二个加入 CNCF（云原生）社区的项目（第一个是 kubernetes），可见在云原生领域 Metrics 指标监控从诞生之初就是一个非常重要的组件。</p><p>现实也确实如此，如今只要使用到了 kubernetes 相关的项目，对其监控就是必不可少的。</p><p>当然也不止是云原生的项目才需要 Metrics 指标监控，我们任何一个业务都是需要的，不然我们的服务运行对开发运维来说都是一个黑盒，无法知道此时系统的运行情况，因此才需要我们的业务系统将一些关键运行指标暴露出来。</p><p><img src="https://s2.loli.net/2024/05/12/1QWEAdFHqYzhl4g.png"></p><p>业务数据：比如订单的增长率、销售金额等业务数据；同时还有应用自身的资源占用情况：</p><ul><li>QPS</li><li>Latency</li><li>内存</li><li>CPU 等信息。</li></ul><p> 在使用 OpenTelemetry 之前，因为 prometheus 是这部分的绝对标准，所以我们通常都会使用 prometheus 的包来暴露这些指标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- The client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Hotspot JVM metrics--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_hotspot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>暴露一个自定义的指标也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.prometheus.client.Counter;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YourClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Counter</span> <span class="variable">requests</span> <span class="operator">=</span> Counter.build()</span><br><span class="line">     .name(<span class="string">&quot;requests_total&quot;</span>).help(<span class="string">&quot;Total requests.&quot;</span>).register();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    requests.inc();</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这是暴露一个单调递增的指标，prometheus 还提供了其他几种指标类型：</p></blockquote><ul><li>Counter</li><li>Gauge</li><li>Histogram</li></ul><p>之后我们只需要在 prometheus 中配置一些抓取规则即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;springboot&#x27;</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:8080&#x27;</span>] <span class="comment"># Spring Boot ip+port</span></span><br></pre></td></tr></table></figure><blockquote><p>当然如果是运行在 kubernetes 环境，prometheus 也可以基于服务发现配置一些规则，自动抓取我们的 Pod 的数据，由于不是本文的重点就不过多介绍。</p></blockquote><h1 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h1><p>在 OpenTelemetry 中自然也提供了 Metrics 这个组件，同时它也是完全兼容 Prometheus，所以我们理解和使用起来并不复杂。</p><h2 id="MeterProvider"><a href="#MeterProvider" class="headerlink" title="MeterProvider"></a>MeterProvider</h2><p>不同于 prometheus 客户端中直接提供了 Counter 就可以创建指标了，在 OpenTelemetry 中会提供一个 <code>MeterProvider</code> 的接口，使用这个接口可以获取 Meter，再使用 Meter 才可以创建 Counter、Gauge、Histogram 等数据。</p><p>下面来看看具体如何使用，这里我以 Pulsar 源码的代码进行演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InstrumentProvider</span><span class="params">(OpenTelemetry otel)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (otel == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// By default, metrics are disabled, unless the OTel java agent is configured.  </span></span><br><span class="line">        <span class="comment">// This allows to enable metrics without any code change.        otel = GlobalOpenTelemetry.get();  </span></span><br><span class="line">    &#125;    <span class="built_in">this</span>.meter = otel.getMeterProvider()  </span><br><span class="line">            .meterBuilder(<span class="string">&quot;org.apache.pulsar.client&quot;</span>)  </span><br><span class="line">            .setInstrumentationVersion(PulsarVersion.getVersion())  </span><br><span class="line">            .build();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">LongCounterBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> meter.counterBuilder(name)  </span><br><span class="line">        .setDescription(description)  </span><br><span class="line">        .setUnit(unit.toString());</span><br></pre></td></tr></table></figure><h2 id="Meter-Exporter"><a href="#Meter-Exporter" class="headerlink" title="Meter Exporter"></a>Meter Exporter</h2><p>Meter Exporter 则是一个 OpenTelemetry 独有的概念，与我们之前讲到的一样：OpenTelemetry 作为厂商无关的平台，允许我们将数据写入到任何兼容的产品里。</p><p>所以我们在使用 Metrics 时需要指定一个 exporter：</p><table><thead><tr><th>Exporter 类型</th><th>作用</th><th>备注</th><th>参数</th></tr></thead><tbody><tr><td>OTLP Exporter</td><td>通过 OpenTelemetry Protocol（OTLP） 发送指标数据到 collect。</td><td>默认生产环境中推荐使用，需要将数据发送到支持 OTLP 的后端，如 OpenTelemetry Collector。</td><td>-Dotel.metrics.exporter&#x3D;otlp (default)</td></tr><tr><td>Console Exporter</td><td>将指标数据打印到控制台的导出器。</td><td>开发和调试，快速查看指标数据。</td><td>-Dotel.metrics.exporter&#x3D;console</td></tr><tr><td>Prometheus Exporter</td><td>将指标数据以 Prometheus 抓取的格式暴露给 Prometheus 服务。</td><td>与 Prometheus 集成，适用于需要 Prometheus 监控的场景，这个可以无缝和以往使用 prometheus 的场景兼容</td><td>-Dotel.metrics.exporter&#x3D;prometheus</td></tr></tbody></table><h2 id="Metric-Instruments"><a href="#Metric-Instruments" class="headerlink" title="Metric Instruments"></a>Metric Instruments</h2><p>与 prometheus 类似，OpenTelemetry 也提供了以下几种指标类型：</p><ul><li><strong>Counter</strong>：单调递增计数器，比如可以用来记录订单数、总的请求数。</li><li><strong>UpDownCounter</strong>：与 Counter 类似，只不过它可以递减。</li><li><strong>Gauge</strong>：用于记录随时在变化的值，比如内存使用量、CPU 使用量等。</li><li><strong>Histogram</strong>：通常用于记录请求延迟、响应时间等。</li></ul><p>同时每个指标还有以下几个字段：</p><ul><li>Name：名称，必填。</li><li>Kind：类型，必填。</li><li>Unit：单位，可选。</li><li>Description：描述，可选。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">messageInCounter = meter  </span><br><span class="line">        .counterBuilder(MESSAGE_IN_COUNTER)  </span><br><span class="line">        .setUnit(<span class="string">&quot;&#123;message&#125;&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;The total number of messages received for this topic.&quot;</span>)  </span><br><span class="line">        .buildObserver();</span><br></pre></td></tr></table></figure><p>还是以 Pulsar 的为例，<code>messageInCounter</code> 是一个记录总的消息接收数量的 Counter 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subscriptionCounter = meter  </span><br><span class="line">        .upDownCounterBuilder(SUBSCRIPTION_COUNTER)  </span><br><span class="line">        .setUnit(<span class="string">&quot;&#123;subscription&#125;&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;The number of Pulsar subscriptions of the topic served by this broker.&quot;</span>)  </span><br><span class="line">        .buildObserver();</span><br></pre></td></tr></table></figure><p>这是记录一个订阅者数量的指标，类型是 UpDownCounter，也就是可以增加减少的指标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Double&gt; latencyHistogramBuckets =  </span><br><span class="line">        Lists.newArrayList(<span class="number">.0005</span>, <span class="number">.001</span>, <span class="number">.0025</span>, <span class="number">.005</span>, <span class="number">.01</span>, <span class="number">.025</span>, <span class="number">.05</span>, <span class="number">.1</span>, <span class="number">.25</span>, <span class="number">.5</span>, <span class="number">1.0</span>, <span class="number">2.5</span>, <span class="number">5.0</span>, <span class="number">10.0</span>, <span class="number">30.0</span>, <span class="number">60.0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">DoubleHistogramBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> meter.histogramBuilder(<span class="string">&quot;pulsar.client.producer.message.send.duration&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;Publish latency experienced by the application, includes client batching time&quot;</span>)  </span><br><span class="line">        .setUnit(Unit.Seconds.toString())  </span><br><span class="line">        .setExplicitBucketBoundariesAdvice(latencyHistogramBuckets);</span><br></pre></td></tr></table></figure><p>这是一个记录 Pulsar producer 发送延迟的指标，类型是 <code>Histogram</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">backlogQuotaAge = meter  </span><br><span class="line">        .gaugeBuilder(BACKLOG_QUOTA_AGE)  </span><br><span class="line">        .ofLongs()  </span><br><span class="line">        .setUnit(<span class="string">&quot;s&quot;</span>)  </span><br><span class="line">        .setDescription(<span class="string">&quot;The age of the oldest unacknowledged message (backlog).&quot;</span>)  </span><br><span class="line">        .buildObserver();</span><br></pre></td></tr></table></figure><p>这是一个记录最大 unack 也就是 backlog 时间的指标，类型是 <code>Gauge</code>。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>在之前的文章：<a href="https://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/">实战：如何编写一个 OpenTelemetry Extensions</a>中讲过如何开发一个 OpenTelemetry 的 extension，其实当时我就是开发了一个用于在 Pulsar 客户端中暴露指标的一个插件。</p><blockquote><p>不过目前 Pulsar 社区已经集成了该功能。</p></blockquote><p>其中的核心代码与上面讲到的类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerObservers</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="type">Meter</span> <span class="variable">meter</span> <span class="operator">=</span> MetricsRegistration.getMeter();    </span><br><span class="line">    </span><br><span class="line">    meter.gaugeBuilder(<span class="string">&quot;pulsar_producer_num_msg_send&quot;</span>)    </span><br><span class="line">            .setDescription(<span class="string">&quot;The number of messages published in the last interval&quot;</span>)    </span><br><span class="line">            .ofLongs()    </span><br><span class="line">            .buildWithCallback(    </span><br><span class="line">                    r -&gt; recordProducerMetrics(r, ProducerStats::getNumMsgsSent));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recordProducerMetrics</span><span class="params">(ObservableLongMeasurement observableLongMeasurement, Function&lt;ProducerStats, Long&gt; getter)</span> &#123;    </span><br><span class="line">    <span class="keyword">for</span> (Producer producer : CollectionHelper.PRODUCER_COLLECTION.list()) &#123;    </span><br><span class="line">        <span class="type">ProducerStats</span> <span class="variable">stats</span> <span class="operator">=</span> producer.getStats();    </span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> producer.getTopic();    </span><br><span class="line">        <span class="keyword">if</span> (topic.endsWith(RetryMessageUtil.RETRY_GROUP_TOPIC_SUFFIX)) &#123;    </span><br><span class="line">            <span class="keyword">continue</span>;    </span><br><span class="line">        &#125;        observableLongMeasurement.record(getter.apply(stats),    </span><br><span class="line">                Attributes.of(PRODUCER_NAME, producer.getProducerName(), TOPIC, topic));    </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>只是这里使用了 <code>buildWithCallback</code> 回调函数，OpenTelemetry 会每隔 30s 调用一次这个函数，通常适用于 Gauge 类型的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent.jar \  </span><br><span class="line">     -Dotel.javaagent.extensions=ext.jar  \</span><br><span class="line">     -Dotel.metrics.exporter=prometheus \</span><br><span class="line">     -Dotel.exporter.prometheus.port=<span class="number">18180</span> \</span><br><span class="line">     -jar myapp.jar</span><br></pre></td></tr></table></figure><p>配合上 Prometheus 的两个启动参数就可以在本地 18180 中获取到指标数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:18180/metrics</span><br></pre></td></tr></table></figure><p>当然也可以直接发往 OpenTelemetry-Collector 中，再由它发往 prometheus，只是这样需要额外在 collector 中配置一下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">exporters:</span></span><br><span class="line">  <span class="attr">debug:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">otlphttp:</span></span><br><span class="line">    <span class="attr">metrics_endpoint:</span> <span class="string">http://promethus:8480/insert/0/opentelemetry/api/v1/push</span></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">pipelines:</span></span><br><span class="line">    <span class="attr">metrics:</span></span><br><span class="line">      <span class="attr">exporters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlphttp</span></span><br><span class="line">      <span class="attr">processors:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">k8sattributes</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">batch</span></span><br><span class="line">      <span class="attr">receivers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlp</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/12/4iMpax5Ptod2Nws.png"></p><p>这样我们就可以在 Grafana 中通过 prometheus 查询到数据了。</p><p>有一点需要注意，如果我们自定义的指标最好是参考官方的<a href="https://opentelemetry.io/docs/specs/semconv/general/metrics/">语义和命名规范</a>来定义这些指标名称。</p><p><img src="https://s2.loli.net/2024/05/12/vCDZY3ygX7MrzGH.png"></p><p>比如 OpenTelemetry 的规范中名称是用 <strong>.</strong> 来进行分隔的。</p><blockquote><p>切换为 OpenTelemetry 之后自然就不需要依赖 prometheus 的包，取而代之的是 OTel 的包：</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compileOnly <span class="string">&#x27;io.opentelemetry:opentelemetry-sdk-extension-autoconfigure-spi:1.34.1&#x27;</span>  </span><br><span class="line">compileOnly <span class="string">&#x27;io.opentelemetry.instrumentation:opentelemetry-instrumentation-api:1.32.0&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相对来说 Metrics 的使用比 Trace 简单的多，同时 Metrics 其实也可以和 Trace 进行关联，也就是 <a href="https://opentelemetry.io/docs/specs/otel/metrics/data-model/#exemplars">Exemplars</a>，限于篇幅就不在本文展开了，感兴趣的可以自行查阅。</p><p>参考链接：</p><ul><li><a href="https://github.com/apache/pulsar/blob/master/pulsar-client/src/main/java/org/apache/pulsar/client/impl/metrics/InstrumentProvider.java">https://github.com/apache/pulsar/blob/master/pulsar-client/src/main/java/org/apache/pulsar/client/impl/metrics/InstrumentProvider.java</a></li><li><a href="https://opentelemetry.io/docs/specs/semconv/general/metrics/">https://opentelemetry.io/docs/specs/semconv/general/metrics/</a></li><li><a href="https://opentelemetry.io/docs/specs/otel/metrics/data-model/#exemplars">https://opentelemetry.io/docs/specs/otel/metrics/data-model/#exemplars</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一篇：&lt;a href=&quot;https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/&quot;&gt;从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅&lt;/a&gt;我们讲解了 Trace 的一些核心概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trace&lt;/li&gt;
&lt;li&gt;Span&lt;/li&gt;
&lt;li&gt;Context&lt;/li&gt;
&lt;li&gt;Baggage 等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这次我们来讲另一个话题 &lt;code&gt;Metrics&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅</title>
    <link href="http://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/"/>
    <id>http://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/</id>
    <published>2024-06-05T16:55:16.000Z</published>
    <updated>2024-06-06T13:00:48.174Z</updated>
    
    <content type="html"><![CDATA[<p>在之前写过两篇比较系统的关于 OpenTelemetry 的文章：</p><ul><li><a href="https://juejin.cn/post/7358450927110357026">OpenTelemetry 实践指南：历史、架构与基本概念</a></li><li><a href="https://juejin.cn/post/7360216766373068837">实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术</a></li></ul><p>从基本概念到如何部署 demo 实战了解 OpenTelemetry，从那个 demo 中也可以得知整个 OpenTelemetry 体系的复杂性，包含了太多的组件和概念。</p><p>为了能更清晰的了解每个关键组件的作用以及原理，我打算分为几期来讲解 OpenTelemetry 的三个核心组件：</p><ul><li>Trace</li><li>Metrics</li><li>Logs</li></ul><p>首先以 Trace 讲起。</p><span id="more"></span><h1 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h1><p>开始之前还是先复习一下 Trace 的历史背景。</p><p>如今现代的分布式追踪的起源源自于 Google 在 2010 年发布的一篇论文：</p><ul><li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf">Dapper, a Large-Scale Distributed Systems Tracing Infrastructure</a></li></ul><p>在这篇论文中提出了分布式追踪的几个核心概念：</p><ul><li>Trace</li><li>Span<ul><li>Span 的一些基础数据结构</li></ul></li><li>可视化追踪以及展示</li></ul><p>之后 Twitter 受到了 Dapper 的启发开源了现在我们熟知的 <a href="https://zipkin.io/">Zipkin</a>，包含了存储和可视化 UI 展示我们的追踪链路。</p><p>Uber 也在 2015 年开源了 <a href="https://www.jaegertracing.io/">Jaeger</a> 项目，它的功能和 Zipkin 类似，但目前我们用的较多的还是 Jaeger；现在已经成为 CNCF 的托管项目。</p><p>之后陆续出现过 <strong>OpenTracing</strong> 和 <strong>OpenCensus</strong> 项目，他们都企图统一分布式追踪这一领域。</p><p>直到 <code>OpenTelemetry</code> 的出现整合了以上两个项目，并且逐渐成为可观测领域的标准。</p><blockquote><p>更多历史背景可以参考之前的文章：<a href="https://juejin.cn/post/7358450927110357026">OpenTelemetry 实践指南：历史、架构与基本概念</a></p></blockquote><p><img src="https://s2.loli.net/2024/05/05/ljQ6yNhKzn3b1c9.png"></p><p><img src="https://s2.loli.net/2024/05/05/NOEbTamR67x83nS.png"></p><p>这里我们结合 Dapper 论文中的资料进行分析，在这个调用中用户发起了一次请求，内部系统经历了 4 次 RPC 调用。</p><p>从第二张图会看到一些关键信息：</p><ul><li>spanName</li><li>parentId</li><li>spanId</li></ul><p>parentId 很好理解，主要是定义调用的主次关系；要注意的是并行调用时 parentId 是同一个。</p><p>spanId 在可以理解为每一个独立的操作，在这里就是一次 RPC 调用；同理一次数据库操作、消息的收发都是一个 span。</p><blockquote><p>span 的更多内容在后文继续讲解。</p></blockquote><h1 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h1><p><img src="https://s2.loli.net/2024/05/05/wyzLpbhYkjOUFav.png"><br>当我们把某一个具体的 span 放大会看到更加详细的信息，其中最关键的如下：</p><ul><li>traceId</li><li>spanName</li><li>spanId</li><li>parentId</li><li>开始时间</li><li>结束时间</li></ul><p>由于一个完整的 trace 链路由 N 个 span 组成，所以这个链路必须得有一个唯一的 traceId 将这些 span 串联起来。<br>这样才可以在可视化的时候更好的展示链路信息。</p><p>以上的这些字段很容易理解，都是一些必须的信息。</p><p>在 Dapper 论文中使用 Annotations 来存放 span 的属性，也就是刚才那些字段，当然也可以自定义存放一些数据，比如图中的 <code>&quot;foo&quot;</code>。</p><h2 id="OpenTelemetry-中的-Span"><a href="#OpenTelemetry-中的-Span" class="headerlink" title="OpenTelemetry 中的 Span"></a>OpenTelemetry 中的 Span</h2><p>OpenTelemetry 的 trace 自然也是基于 Dapper 的，只是额外做了一些优化，比如在刚才那些字段的基础上新增了一些概念：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/v1/sys/health&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;context&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;trace_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7bba9f33312b3dbb8b2c2c62bb7abe2d&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;span_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;086e83747d0e381e&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parent_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;start_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-10-22 16:04:01.209458162 +0000 UTC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;end_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-10-22 16:04:01.209514132 +0000 UTC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;STATUS_CODE_OK&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status_message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;net.transport&quot;</span><span class="punctuation">:</span> <span class="string">&quot;IP.TCP&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.peer.ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.17.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.peer.port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;51820&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.host.ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.177.2.152&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;net.host.port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;26040&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GET&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/v1/sys/health&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.server_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mortar-gateway&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.route&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/v1/sys/health&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.user_agent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Consul Health Check&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.scheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.177.2.152:26040&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http.flavor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;events&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OK&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-10-22 16:04:01.209512872 +0000 UTC&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以这个 JSON 为例，新增了：</p><ul><li><input disabled="" type="checkbox"> <code>Span Context</code><ul><li><code>Span</code> 的上下文，存放的都是不可变的数据，因为每个 Span 之间是存在关联关系的，这些关联关系都是存放在 context 中，主要就是 trace_id, span_id.</li></ul></li><li><code>Attributes</code>: 可以理解为 Dapper 中的 Annotations，存放的是我们自定义的键值对，通常是由我们常用第三方开源 Instrumentation 内置的一些属性。</li><li><code>Span Events</code>: Span 的一些关键事件。</li></ul><p><img src="https://s2.loli.net/2024/05/05/3C49thIJOZTuf82.png"><br>比如我们常用的 Redis 客户端 lettuce，它就会自己记录一些 Attributes。</p><hr><p>如果有多个 span 存在依赖关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       [Span A]  ←←←(the root span)</span><br><span class="line">           |</span><br><span class="line">    +------+------+</span><br><span class="line">    |             |</span><br><span class="line">[Span B]      [Span C] ←←←(Span C is a `child` of Span A)</span><br><span class="line">    |             |</span><br><span class="line">[Span D]      +---+-------+</span><br><span class="line">              |           |</span><br><span class="line">          [Span E]    [Span F]</span><br></pre></td></tr></table></figure><p>大部分的可视化工具都是以时间线的方式进行展示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–&gt; time</span><br><span class="line"></span><br><span class="line"> [Span A···················································]</span><br><span class="line">   [Span B··········································]</span><br><span class="line">      [Span D······································]</span><br><span class="line">    [Span C····················································]</span><br><span class="line">         [Span E·······]        [Span F··]</span><br></pre></td></tr></table></figure><p>这些和 Dapper 中描述的概念没有本质区别。</p><hr><h3 id="Span-Status"><a href="#Span-Status" class="headerlink" title="Span Status"></a>Span Status</h3><p>Span 还内置了一些 Status：</p><ul><li><code>Unset</code></li><li><code>Error</code></li><li><code>Ok</code></li></ul><p>默认情况下是 Unset，出现错误时则是 Error，一切正常时则是 Ok。</p><p><img src="https://s2.loli.net/2024/05/05/glkIuxbFDBcai36.png"><br>通过可视化页面很容易得知某个 trace 中 span 的异常情况，点进去后可以看到具体的异常 span 以及它的错误日志。</p><h3 id="Span-Kind"><a href="#Span-Kind" class="headerlink" title="Span Kind"></a>Span Kind</h3><p>最后是 Span 的类型：</p><ul><li>Client</li><li>Server</li><li>Internal</li><li>Producer</li><li>Consumer</li></ul><p><img src="https://s2.loli.net/2024/05/05/rMjV9qsveNEKORW.png"></p><p>Client 和 Server 非常好理解，比如我们有一个 gRPC 接口，调用方的 Span 是 client，而服务端的 Span 自然就是 Server。</p><p>Internal 则是内部组件调用产生的 Span，这类 Span 相对会少一些。</p><p>Producer 和 Consumer 一般指的是发起异步调用时的 Span，我们常见的就是往消息队列里生产和消费消息。</p><p>通过这几种类型的 Span 也可以了解到什么情况下会创建 Span，通常是以下几种场景：</p><ul><li>RPC 调用</li><li>数据库（Redis、MySQL、Mongo 等等）操作</li><li>生产和消费消息</li><li>有意义的内部调用</li></ul><p>通常在一个函数内部再调用其他的本地函数是不用创建 span 的，不然这个链路会非常的长。</p><h2 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h2><p>当然也有一些特殊情况，比如我的某个内部函数非常重要，需要单独关心它的调用时长。</p><p>此时我们就可以使用 Annotations 来单独创建自己的 Span。</p><blockquote><p>这个 Annotations 和 Dapper 中的不是同一个，只是 Java 中的注解。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;  </span><br><span class="line">    Executors.newFixedThreadPool(<span class="number">1</span>).execute(() -&gt; &#123;  </span><br><span class="line">        myMethod(request.getName());  </span><br><span class="line">    &#125;);    </span><br><span class="line">    </span><br><span class="line">    <span class="type">HelloReply</span> <span class="variable">reply</span> <span class="operator">=</span> HelloReply.newBuilder()  </span><br><span class="line">            .setMessage(<span class="string">&quot;Hello ==&gt; &quot;</span> + request.getName())  </span><br><span class="line">            .build();  </span><br><span class="line">    responseObserver.onNext(reply);  </span><br><span class="line">    responseObserver.onCompleted();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@SneakyThrows</span>  </span><br><span class="line"><span class="meta">@WithSpan</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">(<span class="meta">@SpanAttribute(&quot;request.name&quot;)</span> String name)</span> &#123;  </span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);  </span><br><span class="line">    log.info(<span class="string">&quot;myMethod:&#123;&#125;&quot;</span>, name);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这段代码为例，这是一个 gRPC 的服务端接口，在这个接口中调用了一个函数 <code>myMethod</code>，默认情况下并不会为它单独创建一个 Span。</p><p>但如果我们想单独记录它，就可以使用 <code>@WithSpan</code> 这个注解，同时也可以使用  <code>@SpanAttribute</code> 来自定义 attribute。</p><p>最终的效果如下：<br><img src="https://s2.loli.net/2024/05/05/aBd1ubsS2kxMzGf.png"><br>此时就会单独为这个函数创建一个 Span。</p><blockquote><p>需要单独引入一个依赖:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.opentelemetry.instrumentation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opentelemetry-instrumentation-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Context-Propagation"><a href="#Context-Propagation" class="headerlink" title="Context Propagation"></a>Context Propagation</h1><p>上下文传播也是 Trace 中非常重要的概念，刚才提到了每个 Span 都有自己不可变的上下文，那么后续的 Span 如何和上游的 Span 进行关联呢？</p><p>这里有两种情况：</p><ul><li>同一进程</li><li>垮进程</li></ul><h2 id="同一进程"><a href="#同一进程" class="headerlink" title="同一进程"></a>同一进程</h2><p>同一个进程也分为两种情况：</p><ul><li>单线程</li><li>多线程</li></ul><p>单线程的比较好处理，我们只需要把数据写入 <code>ThreadLocal</code> 中就可以做到线程隔离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Context&gt; THREAD_LOCAL_STORAGE = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line"><span class="keyword">public</span> Context <span class="title function_">current</span><span class="params">()</span> &#123;  </span><br><span class="line">  <span class="keyword">return</span> THREAD_LOCAL_STORAGE.get();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这点我们可以通过源码 <code>io.opentelemetry.context.ThreadLocalContextStorage</code>看到具体的实现过程。</p><p>而如果是多线程时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executors.newFixedThreadPool(<span class="number">1</span>).execute(() -&gt; &#123;  </span><br><span class="line">    myMethod(request.getName());  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>则需要对使用的线程池进行单独处理，将父线程中 threadlocal 中的数据拷贝出来进行传递，比如有阿里提供的 <code>TransmittableThreadLocal</code>，可以提供对线程池的支持。</p><h2 id="跨进程"><a href="#跨进程" class="headerlink" title="跨进程"></a>跨进程</h2><p>而如果是垮进程的场景，就需要将 context 的信息进行序列化传递。</p><p>如果是 gRPC 调用会将信息存放到 metadata 中。</p><p>HTTP 调用则是存放在 header 中。</p><p>消息队列，比如 Pulsar 也可以将数据存放在消息中的 header 中进行传递。</p><p>数据一旦跨进程传输成功后，就和单进程一样的处理方式了。</p><h2 id="Baggage"><a href="#Baggage" class="headerlink" title="Baggage"></a>Baggage</h2><p><img src="https://s2.loli.net/2024/05/05/3c6LNtIbSkpQlRU.png"></p><p>有时候我们需要通过垮 Span 传递信息，比如如上图所示：<br>我们需要在 serverB 中拿到 serverA 中收到的一个请求参数： <code>http://127.0.0.1:8181/request\?name\=1232</code></p><p><img src="https://s2.loli.net/2024/05/05/hISQNv91KP85WFC.png"></p><p>这个数据默认会作为 span 的 attribute ，但只会存在于第一个 span。</p><p>如果我们想要在后续的 span 中也能拿到这个数据，甚至是垮进程也能获取到。</p><p>那就需要使用 <code>Baggage</code> 这个对象了。</p><p>它的使用也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/request&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;  </span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">    Baggage.current().toBuilder().  </span><br><span class="line">          put(<span class="string">&quot;request.name&quot;</span>, name).build()  </span><br><span class="line">          .storeInContext(Context.current()).makeCurrent();</span><br><span class="line">&#125;         </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> Baggage.current().getEntryValue(<span class="string">&quot;request.name&quot;</span>);  </span><br><span class="line">log.info(<span class="string">&quot;request.name: &#123;&#125;&quot;</span>, value);</span><br></pre></td></tr></table></figure><p>只要是属于同一个 trace 的调用就可以直接获取到数据。<br><img src="https://s2.loli.net/2024/05/05/Lz1hY8pflRebANx.png"></p><blockquote><p>traceId 也是垮 Span 传递的。</p></blockquote><p>而它的原理也是通过往 context 中写入数据实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span>  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaggageContextKey</span> &#123;  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ContextKey&lt;Baggage&gt; KEY = ContextKey.named(<span class="string">&quot;opentelemetry-baggage-key&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">BaggageContextKey</span><span class="params">()</span> &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/05/vIHtBxGATKOg13l.png"><br>而这个 context 是通过一个 entries 数据存储数据的，不管是在内部还是外部的跨进程调用，OpenTelemetry 都会将 context 通过 <code>Context Propagation</code> 传递出去。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Trace 这部分的内容我觉得比 Metrics 和 Logs 更加复杂一些，毕竟多了一些数据结构；现在的内容也只是冰山一角，现在也在做 trace 的一些定制化开发，后续有新的进展会接着更新。</p><p>参考链接：</p><ul><li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf">https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf</a></li><li><a href="https://opentelemetry.io/docs/languages/java/automatic/annotations/">https://opentelemetry.io/docs/languages/java/automatic/annotations/</a></li><li><a href="https://opentelemetry.io/docs/specs/otel/overview/#tracing-signal">https://opentelemetry.io/docs/specs/otel/overview/#tracing-signal</a></li><li><a href="https://opentelemetry.io/docs/concepts/context-propagation/">https://opentelemetry.io/docs/concepts/context-propagation/</a></li><li><a href="https://opentelemetry.io/docs/concepts/observability-primer/#distributed-traces">https://opentelemetry.io/docs/concepts/observability-primer/#distributed-traces</a></li><li><a href="https://tech.meituan.com/2023/04/20/traceid-google-dapper-mtrace.html">https://tech.meituan.com/2023/04/20/traceid-google-dapper-mtrace.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前写过两篇比较系统的关于 OpenTelemetry 的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7358450927110357026&quot;&gt;OpenTelemetry 实践指南：历史、架构与基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7360216766373068837&quot;&gt;实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从基本概念到如何部署 demo 实战了解 OpenTelemetry，从那个 demo 中也可以得知整个 OpenTelemetry 体系的复杂性，包含了太多的组件和概念。&lt;/p&gt;
&lt;p&gt;为了能更清晰的了解每个关键组件的作用以及原理，我打算分为几期来讲解 OpenTelemetry 的三个核心组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trace&lt;/li&gt;
&lt;li&gt;Metrics&lt;/li&gt;
&lt;li&gt;Logs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先以 Trace 讲起。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
</feed>
