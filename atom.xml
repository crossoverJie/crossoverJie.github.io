<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverJie&#39;s Blog</title>
  
  <subtitle>baller</subtitle>
  <link href="http://crossoverjie.top/atom.xml" rel="self"/>
  
  <link href="http://crossoverjie.top/"/>
  <updated>2024-11-20T09:07:50.027Z</updated>
  <id>http://crossoverjie.top/</id>
  
  <author>
    <name>crossoverJie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>推荐一些值得学习的开源项目和框架</title>
    <link href="http://crossoverjie.top/2024/11/20/ob/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%BA%9B%E5%80%BC%E5%BE%97%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%92%8C%E6%A1%86%E6%9E%B6/"/>
    <id>http://crossoverjie.top/2024/11/20/ob/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%BA%9B%E5%80%BC%E5%BE%97%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%92%8C%E6%A1%86%E6%9E%B6/</id>
    <published>2024-11-20T09:06:46.000Z</published>
    <updated>2024-11-20T09:07:50.027Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/11/06/YtoOV3dMNEsqw4u.png" alt="image.png"><br>今天收到球友的问题，让推荐一些值得看的开源项目，觉得 netty 这些太复杂了不太好上手。</p><p>确实如此，我们日常常用的 Spring、Netty 确实由于发展了多年，看起来比较头大。</p><p>下面我来推荐一些我看过同时觉得不错的项目(几乎都是我参与过的），由易到难，其中也会包含 Java 和 Go 的项目，包含主流的中间件和云原生项目。</p><span id="more"></span><h1 id="Java-项目"><a href="#Java-项目" class="headerlink" title="Java 项目"></a>Java 项目</h1><h2 id="xxl-job"><a href="#xxl-job" class="headerlink" title="xxl-job"></a>xxl-job</h2><p>难度：🌟🌟<br>推荐指数：🌟🌟🌟</p><p><img src="https://s2.loli.net/2024/11/06/xuLRoCfVhiFcjbz.png"></p><p><a href="https://github.com/xuxueli/xxl-job">xxl-job</a> 是一个很经典的调度框架，目前在 GitHub 上也有 27k star 的关注，因为功能不复杂所以最近也没有怎么更新了。</p><p>大家日常都会使用这类调度框架，所以理解难度非常低，加上他的实现也比较简单，比如：</p><ul><li>使用 MySQL 的锁来简单粗暴的解决分布式锁的问题</li><li>线程池的使用：因为每个任务的调度都需要尽可能的互相不影响，所以里面大量使用了线程池，同时对如何获取异步任务结果也有一些最佳实践。</li><li>RPC 调用：里面内置了一个 <a href="https://github.com/xuxueli/xxl-rpc">RPC</a> 框架，也是作者编写的，其中的实现原理也不复杂，建议看看源码，可以更好的理解我们在工作中用到 rpc 框架。</li></ul><h2 id="cim"><a href="#cim" class="headerlink" title="cim"></a>cim</h2><p>难度：🌟🌟🌟<br>推荐指数：🌟🌟🌟<br>这里夹了一点私货，就是我自己开源的一个<a href="https://github.com/crossoverJie/cim">分布式即时通讯系统</a>，其实现在来看上一个版本的代码写的挺烂的，不过好在最近发布了 v2.0.0，提升了不少代码质量。</p><p><img src="https://s2.loli.net/2024/10/14/pBvDML4HVgyYZxS.gif" alt="Oct-14-2024 11-09-54-min.gif"><br>它具备 IM 即时通讯的基本功能，同时基于它可以实现：</p><ul><li>即时通讯</li><li>消息推送</li><li>IOT 消息平台</li></ul><p>通过 cim 你可以学习到分布式系统中：</p><ul><li>元数据是如何存放和同步的。</li><li>RPC 调用如何实现。</li><li>长链接系统如何实现。</li><li>复杂的分布式系统如何做集成测试等。</li></ul><p>详细的介绍可以查看项目首页的 <a href="https://github.com/crossoverJie/cim">readme</a>，发现有什么需要优化的地方（其实还蛮多 todo 没有做）都欢迎提交 PR。</p><h2 id="PowerJob"><a href="#PowerJob" class="headerlink" title="PowerJob"></a>PowerJob</h2><p>难度：🌟🌟🌟<br>推荐指数：🌟🌟🌟🌟<br><a href="https://github.com/PowerJob/PowerJob">PowerJob</a> 也是一个调度框架，只是他有后发优势，结合了市面上其他调度系统的优点同时也新增了一些功能，以下是他功能的官方对比图：<br><img src="https://s2.loli.net/2024/11/07/Ngab96HlYstJOyT.png"><br>社区相对于 xxl-job 也更加活跃，目前刚发布了 <code>5.1.0</code> 版本，同时社区也整理许多学习的文章和<a href="https://www.yuque.com/powerjob/guidence/wu2e93">资料</a>：</p><p><img src="https://s2.loli.net/2024/11/07/aGUzAwhX5CE2Lbj.png" alt="image.png"></p><p>它使用了 Akka 来实现远程通信，对这部分内容感兴趣的朋友不容错过，可以看到一些最佳实践。<br>其中的代码写的也很规范，一些类的设计很好，可扩展性很高，比如常用的执行器都是通过一个<br><code>MapProcessor</code> 扩展而来的。<br><img src="https://s2.loli.net/2024/11/07/SO2eRbvqrI5EGyU.png" alt="image.png"><br><img src="https://s2.loli.net/2024/11/07/rvabkCdo4g3FTyU.png" alt="image.png"></p><p>推荐大家从任务调度那一块开始看：<code>tech.powerjob.worker.actors.TaskTrackerActor#onReceiveServerScheduleJobReq</code></p><h2 id="Pulsar"><a href="#Pulsar" class="headerlink" title="Pulsar"></a>Pulsar</h2><p>难度：🌟🌟🌟🌟<br>推荐指数：🌟🌟🌟🌟<br><img src="https://s2.loli.net/2024/11/07/2MFiE1vPSfl69ty.png" alt="image.png"><br>Pulsar 是目前主流的云原生消息队列中间件，现在使用的公司也非常多，通过他你可以学习到：</p><ul><li>API 设计：Pulsar 的 client 是直接面向开发者的，在易用性的前提下每次迭代升级还要考虑到兼容性。</li><li>异步调用：Pulsar 里几乎所有的请求都是异步的，所以大量使用了异步➕回调（虽然也有一些坑），可以学到一些高性能代码的编写方式。</li><li>Netty 的最佳用法：消息收发的底层网络框架也是 Netty 支撑的，Pulsar 对它做了封装。</li><li>基于 protocol 的多语言客户端。<ul><li>因为 Pulsar 的通信编解码使用的是 protocol，本身是可以基于它生成各种语言的 API，所以在此基础上编写其他语言的客户端就非常方便。</li></ul></li></ul><p>不过由于 Pulsar 本身的复杂性，上手起来门槛还是不低，推荐先从客户端的代码（Java 和  Go 的都可以）上手。</p><h2 id="StarRocks"><a href="#StarRocks" class="headerlink" title="StarRocks"></a>StarRocks</h2><p>难度：🌟🌟🌟🌟🌟<br>推荐指数：🌟🌟🌟🌟<br><img src="https://s2.loli.net/2024/11/08/zZ8jD9JU1tSkm6A.png" alt="image.png"></p><p>StarRocks 也是我最近才接触到的 OLAP 数据库项目，以前对这个领域的积累几乎为零，所以也是从头学习。</p><p>好在这段时间因为有需求也给它提交了几个 PR，逐渐熟悉起来了。<br><img src="https://s2.loli.net/2024/11/08/gVb15UWrwXHq8YI.png" alt="image.png"></p><p>我接触下来这些开源项目，发现 StarRocks 这类数据库项目是最有前（钱）景的，毕竟和数据打交道的产品公司的付费意愿会更高一些。</p><p>不过该项目确实对新手不太友好，最好是已经接触过大数据领域再学习会更合适一些，但也不要怕，我就是一个纯小白，没基础就跟着代码 debug，反正都是 Java 写的总能看懂。</p><p>这里推荐先看看我之前写的<a href="https://crossoverjie.top/2024/10/09/ob/StarRocks-dev-env-build/">本地搭建开发环境</a>，这样就可以在 idea 里 debug 了。</p><h2 id="OpenTelemetry"><a href="#OpenTelemetry" class="headerlink" title="OpenTelemetry"></a>OpenTelemetry</h2><p>难度：🌟🌟🌟🌟<br>推荐指数：🌟🌟🌟🌟🌟<br><img src="https://s2.loli.net/2024/08/08/p5WkVbSarUdIQwT.png"><br>OpenTelemetry 现在作为云原生可观测性的事实标准，现在已经逐步成为各大公司必备的技术栈了。</p><p>通过一个 <code>javaagent</code> 就可以自动采集应用的 trace、metrics、logs 等数据，这里先推荐 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/">opentelemetry-java-instrumentation</a>，因为我们日常使用最多的就是基于这个项目打包出来的 <code>javaagent</code>，通过它可以学习到：</p><ul><li>如何编写任意函数的拦截器</li><li>trace 信息是如何在线程和进程之间传递的</li><li>一些常用框架是如何运行的<ul><li>比如你需要了解 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/instrumentation/grpc-1.6">gRPC</a> 的原理，就可以查看 OpenTelemetry 是如何对他埋点的，从而知晓他的核心原理。</li></ul></li><li>优雅的 API 设计</li></ul><p><img src="https://s2.loli.net/2024/11/08/1yenwuxJ9C6tOSb.png" alt="image.png"><br>同时 OpenTelemetry 算是我看过最优雅的代码之一了，非常建议大家都看看。</p><p>如果对 OpenTelemetry 还不太熟悉，可以先看看我<a href="https://crossoverjie.top/tags/OpenTelemetry/">之前写过的文章</a>。</p><h1 id="Go（云原生项目）"><a href="#Go（云原生项目）" class="headerlink" title="Go（云原生项目）"></a>Go（云原生项目）</h1><h2 id="cprobe"><a href="#cprobe" class="headerlink" title="cprobe"></a>cprobe</h2><p>难度：🌟🌟🌟<br>推荐指数：🌟🌟🌟</p><p><a href="https://github.com/cprobe/cprobe">cprobe</a> 属于可观测性项目，他的目的是可以把各种 exporter 都整合在一起，比如 <code>kafka_exporter</code>, <code>nginx_exporter</code>, <code>mysql_exporter</code> 等。</p><p>同时还做了上层抽象，可以统一管理各种监控对象的配置，这样就可以部署一个进程监控所有的应用了。</p><p>通过这个项目可以学到：</p><ul><li>监控体系的基础知识，比如 Prometheus 和 metrics 等</li><li>Go 语言的基本用法</li></ul><p>我之前写过一篇 <a href="https://crossoverjie.top/2024/01/25/ob/create-a-plugin-for-cprobe/">手把手教你为开源项目贡献代码</a>就是以 cprobe 为例来介绍的。</p><h2 id="VictoriaLogs"><a href="#VictoriaLogs" class="headerlink" title="VictoriaLogs"></a>VictoriaLogs</h2><p>难度：🌟🌟🌟🌟<br>推荐指数：🌟🌟🌟🌟</p><p>这是一个属于 <a href="https://github.com/VictoriaMetrics/VictoriaMetrics/tree/master/app/victoria-logs">VictoriaMetrics</a> 的一个子项目，通过这个名字应该会知道他主要用于处理日志，可以把他理解为 ElasticSearch 的简易版，虽然功能简单了但资源消耗也会比 ES 低很多，具体可以看下面的压测图：</p><p><img src="https://s2.loli.net/2023/08/23/3Epxdzie8q5tVmY.png" alt="image.png"></p><p>通过这个项目可以学到：</p><ul><li>数据在磁盘中是如何存储和查询的</li><li>Go 语言中关于 <code>goroutine</code> 和 <code>channel</code> 的一些最佳实践<br>目前的版本还比较早，所以代码都不太复杂，建议大家可以从查询的入口开始<a href="https://github.com/VictoriaMetrics/VictoriaMetrics/blob/master/lib/logstorage/storage_search.go">看起</a>。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上都是我正经接触过的项目，如果是想长期耕耘同时搞钱的话，推荐 <code>StarRocks</code>，目前也很火。</p><p>如果只是想提升在 Java 领域的水平，那推荐 Pulsar 和 OpenTelemetry，都有很多代码最佳实践。</p><p>如果想要入坑云原生和 Go 项目，那 cprobe 是比较合适的。</p><p>当然不管是哪个项目最主要的还是坚持，很多项目如果只是偶尔看一下很容易忘记，起码要做到真正运行起来然后 debug 过代码。</p><p>参考链接：</p><ul><li><a href="https://www.yuque.com/powerjob/guidence/wu2e93">https://www.yuque.com/powerjob/guidence/wu2e93</a></li><li><a href="https://github.com/VictoriaMetrics/VictoriaMetrics/blob/master/lib/logstorage/storage_search.go">https://github.com/VictoriaMetrics/VictoriaMetrics/blob/master/lib/logstorage/storage_search.go</a></li><li><a href="https://crossoverjie.top/tags/OpenTelemetry/">https://crossoverjie.top/tags/OpenTelemetry/</a></li><li><a href="https://crossoverjie.top/2024/10/09/ob/StarRocks-dev-env-build/">https://crossoverjie.top/2024/10/09/ob/StarRocks-dev-env-build/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/11/06/YtoOV3dMNEsqw4u.png&quot; alt=&quot;image.png&quot;&gt;&lt;br&gt;今天收到球友的问题，让推荐一些值得看的开源项目，觉得 netty 这些太复杂了不太好上手。&lt;/p&gt;
&lt;p&gt;确实如此，我们日常常用的 Spring、Netty 确实由于发展了多年，看起来比较头大。&lt;/p&gt;
&lt;p&gt;下面我来推荐一些我看过同时觉得不错的项目(几乎都是我参与过的），由易到难，其中也会包含 Java 和 Go 的项目，包含主流的中间件和云原生项目。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenSource" scheme="http://crossoverjie.top/categories/OpenSource/"/>
    
    
    <category term="OpenSource" scheme="http://crossoverjie.top/tags/OpenSource/"/>
    
  </entry>
  
  <entry>
    <title>StarRocks 物化视图刷新流程和原理</title>
    <link href="http://crossoverjie.top/2024/11/18/ob/StarRocks-MV-refresh-Principle/"/>
    <id>http://crossoverjie.top/2024/11/18/ob/StarRocks-MV-refresh-Principle/</id>
    <published>2024-11-18T14:35:25.000Z</published>
    <updated>2024-11-18T10:46:12.231Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间给 StarRocks 的物化视图新增了一个<a href="https://github.com/StarRocks/starrocks/pull/50926">特性</a>，那也是我第一次接触 StarRocks，因为完全不熟悉这个数据库，所以很多东西都是从头开始了解概念。</p><p>为了能顺利的新增这个特性（具体内容可以见后文），我需要把整个物化视图的流程串联一遍，于是便有了这篇文章。</p><p>在开始之前简单了解下物化视图的基本概念：</p><p><img src="https://s2.loli.net/2024/11/13/TMAjuUsEZGJiFDS.png" alt="image.png"></p><p>简单来说，视图和 MySQL 这类传统数据库的概念类似，也是用于解决大量消耗性能的 SQL 的，可以提前将这些数据查询好然后放在一张单独的表中，这样再查询的时候性能消耗就比较低了。</p><span id="more"></span><h1 id="刷新条件"><a href="#刷新条件" class="headerlink" title="刷新条件"></a>刷新条件</h1><p>为了保证视图数据的实时性，还需要在数据发生变化的时候能够及时刷新视图里的数据，目前有这几个地方会触发视图刷新：<br><img src="https://s2.loli.net/2024/11/13/vJFQBAyfus5ZwIT.png" alt="image.png"></p><ul><li>手动刷新视图，使用 <code>REFRESH MATERIALIZED VIEW order_mv;</code> 语句</li><li>将视图设置为 active 状态：<code>ALTER MATERIALIZED VIEW order_mv ACTIVE;</code></li><li>基表数据发生变化时触发刷新。<ul><li><img src="https://s2.loli.net/2024/11/13/6QCojHZEJcUL4t2.png" alt="image.png"></li></ul></li><li>truncate 基表时触发刷新：<code>truncate table trunc_db.t1;</code> </li><li>drop partition 时触发：<code>ALTER TABLE &lt;tbl_name&gt; DROP PARTITION(S) p0, p1 [, ...];</code></li></ul><p>这里的 truncate table  和 drop partition 目前的版本还存在 bug：当基表和物化视图不在一个数据库时不会触发自动刷新，目前已经修复了。</p><p><img src="https://s2.loli.net/2024/11/13/2wtZfnFTUbsHaY4.png" alt="image.png"></p><ul><li><a href="https://github.com/StarRocks/starrocks/pull/52618">https://github.com/StarRocks/starrocks/pull/52618</a></li><li><a href="https://github.com/StarRocks/starrocks/pull/52295">https://github.com/StarRocks/starrocks/pull/52295</a></li></ul><h1 id="刷新流程"><a href="#刷新流程" class="headerlink" title="刷新流程"></a>刷新流程</h1><p><img src="https://s2.loli.net/2024/11/14/QljDLmRrx97EIK6.png" alt="image.png"></p><p>如图所示，当触发一次刷新之后主要就是需要计算出需要刷新的分区。</p><p>第一次触发刷新的时候是不会带上周期（比如时间范围），然后根据过滤计算出来的周期，默认情况下只会使用第一个周期（我们可以通过 <code>partition_refresh_number</code> 参数来调整单次刷新的分区数量）。</p><p><img src="https://s2.loli.net/2024/11/14/3QFtkXRfvhCdNrS.png"></p><p>然后如果还有其余的周期，会将这些周期重新触发一次刷新任务（会带上刚才剩余的周期数据），这样进行递归执行。</p><p><img src="https://s2.loli.net/2024/11/15/OqjuMl1LNkWh39g.png"></p><p>通过日志会看到返回的分区数据。</p><h1 id="新增优化参数"><a href="#新增优化参数" class="headerlink" title="新增优化参数"></a>新增优化参数</h1><p>我们在使用物化视图的时候，碰到一个场景：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> test.par_tbl1</span><br><span class="line">(</span><br><span class="line">    datekey DATETIME,</span><br><span class="line">    k1      <span class="type">INT</span>,</span><br><span class="line">    item_id STRING,</span><br><span class="line">    v2      <span class="type">INT</span></span><br><span class="line">)<span class="keyword">PRIMARY</span> KEY (`datekey`,`k1`)</span><br><span class="line"> <span class="keyword">PARTITION</span> <span class="keyword">BY</span> date_trunc(<span class="string">&#x27;day&#x27;</span>, `datekey`);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> test.par_tbl2</span><br><span class="line">(</span><br><span class="line">    datekey DATETIME,</span><br><span class="line">    k1      <span class="type">INT</span>,</span><br><span class="line">    item_id STRING,</span><br><span class="line">    v2      <span class="type">INT</span></span><br><span class="line">)<span class="keyword">PRIMARY</span> KEY (`datekey`,`k1`)</span><br><span class="line"> <span class="keyword">PARTITION</span> <span class="keyword">BY</span> date_trunc(<span class="string">&#x27;day&#x27;</span>, `datekey`);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> test.par_tbl3</span><br><span class="line">(</span><br><span class="line">    datekey DATETIME,</span><br><span class="line">    k1      <span class="type">INT</span>,</span><br><span class="line">    item_id STRING,</span><br><span class="line">    v2      <span class="type">INT</span></span><br><span class="line">)</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`datekey`,`k1`);</span><br></pre></td></tr></table></figure><p>但我们有三张基表，其中 1 和 2 都是分区表，但是 3 是非分区表。</p><p>此时基于他们新建了一个物化视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span></span><br><span class="line">MATERIALIZED <span class="keyword">VIEW</span> test.mv_test</span><br><span class="line">REFRESH ASYNC</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> a_time</span><br><span class="line">PROPERTIES (</span><br><span class="line">&quot;excluded_trigger_tables&quot; <span class="operator">=</span> &quot;par_tbl3&quot;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">select</span> date_trunc(&quot;day&quot;, a.datekey) <span class="keyword">as</span> a_time, date_trunc(&quot;day&quot;, b.datekey) <span class="keyword">as</span> b_time,date_trunc(&quot;day&quot;, c.datekey) <span class="keyword">as</span> c_time</span><br><span class="line"><span class="keyword">from</span> test.par_tbl1 a</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> test.par_tbl2 b <span class="keyword">on</span> a.datekey <span class="operator">=</span> b.datekey <span class="keyword">and</span> a.k1 <span class="operator">=</span> b.k1</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> test.par_tbl3 c <span class="keyword">on</span> a.k1 <span class="operator">=</span> c.k1;</span><br></pre></td></tr></table></figure><p>当我同时更新了分区表和非分区表的数据时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `par_tbl1` <span class="keyword">SET</span> `v2` <span class="operator">=</span> <span class="number">2</span> <span class="keyword">WHERE</span> `datekey` <span class="operator">=</span> <span class="string">&#x27;2024-08-05 01:00:00&#x27;</span> <span class="keyword">AND</span> `k1` <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> `par_tbl3` <span class="keyword">SET</span> `item_id` <span class="operator">=</span> <span class="string">&#x27;3&#x27;</span> <span class="keyword">WHERE</span> `datekey` <span class="operator">=</span> <span class="string">&#x27;2024-10-01 01:00:00&#x27;</span> <span class="keyword">AND</span> `k1` <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>预期的结果是只有 <code>par_tbl1</code> 表里修改的数据会被同步到视图（<code>&quot;excluded_trigger_tables&quot; = &quot;par_tbl3&quot;</code>已经被设置为不会触发视图刷新），但实际情况是 <code>par_tbl1</code> 和 <code>par_tbl2</code> 表里所有的数据都会被刷新到物化视图中。</p><p>我们可以使用这个 SQL 查询无刷视图任务的运行状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.task_runs <span class="keyword">order</span> <span class="keyword">by</span> create_time <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>这样就会造成资源损耗，如果这两张基表的数据非常大，本次刷新会非常耗时。</p><p>所以我们的需求是在这样的场景下也只刷新修改的数据。</p><p>因此我们在新建物化视图的时候新增了一个参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span></span><br><span class="line">MATERIALIZED <span class="keyword">VIEW</span> test.mv_test</span><br><span class="line">REFRESH ASYNC</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> a_time</span><br><span class="line">PROPERTIES (</span><br><span class="line">&quot;excluded_trigger_tables&quot; <span class="operator">=</span> &quot;par_tbl3&quot;,</span><br><span class="line">&quot;excluded_refresh_tables&quot;<span class="operator">=</span>&quot;par_tbl3&quot;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">select</span> date_trunc(&quot;day&quot;, a.datekey) <span class="keyword">as</span> a_time, date_trunc(&quot;day&quot;, b.datekey) <span class="keyword">as</span> b_time,date_trunc(&quot;day&quot;, c.datekey) <span class="keyword">as</span> c_time</span><br><span class="line"><span class="keyword">from</span> test.par_tbl1 a</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> test.par_tbl2 b <span class="keyword">on</span> a.datekey <span class="operator">=</span> b.datekey <span class="keyword">and</span> a.k1 <span class="operator">=</span> b.k1</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> test.par_tbl3 c <span class="keyword">on</span> a.k1 <span class="operator">=</span> c.k1;</span><br></pre></td></tr></table></figure><p>这样当在刷新数据的时候，会判断 <code>excluded_refresh_tables</code> 配置的表是否有发生数据变化，如果有的话则不能将当前计算出来的分区（1,2 两张表的全量数据）全部刷新，而是继续求一个交集，只计算基表发生变化的数据。</p><p>这样就可以避免 par_tbl1、par_tbl2 的数据全量刷新，而只刷新修改的数据。</p><p>这样的场景通常是在关联的基表中有一张字典表，通常数据量不大，所以也不需要分区的场景。</p><p>这样在创建物化视图的时候就可以使用这两个参数 <code>excluded_trigger_tables，excluded_refresh_tables</code> 将它排除掉了。</p><p><img src="https://s2.loli.net/2024/11/15/lrGJEnRgyQDd2Pc.png"></p><p>整体的刷新逻辑并不复杂，主要就是几个不同的刷新入口以及刷新过程中计算分区的逻辑。</p><p>参考链接：</p><ul><li><a href="https://docs.starrocks.io/zh/docs/using_starrocks/async_mv/Materialized_view/#%E7%90%86%E8%A7%A3-starrocks-%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE">https://docs.starrocks.io/zh/docs/using_starrocks/async_mv/Materialized_view/#%E7%90%86%E8%A7%A3-starrocks-%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE</a></li><li><a href="https://docs.starrocks.io/zh/docs/using_starrocks/async_mv/use_cases/data_modeling_with_materialized_views/#%E5%88%86%E5%8C%BA%E5%BB%BA%E6%A8%A1">https://docs.starrocks.io/zh/docs/using_starrocks/async_mv/use_cases/data_modeling_with_materialized_views/#%E5%88%86%E5%8C%BA%E5%BB%BA%E6%A8%A1</a></li><li><a href="https://github.com/StarRocks/starrocks/pull/52295">https://github.com/StarRocks/starrocks/pull/52295</a></li><li><a href="https://github.com/StarRocks/starrocks/pull/52618">https://github.com/StarRocks/starrocks/pull/52618</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间给 StarRocks 的物化视图新增了一个&lt;a href=&quot;https://github.com/StarRocks/starrocks/pull/50926&quot;&gt;特性&lt;/a&gt;，那也是我第一次接触 StarRocks，因为完全不熟悉这个数据库，所以很多东西都是从头开始了解概念。&lt;/p&gt;
&lt;p&gt;为了能顺利的新增这个特性（具体内容可以见后文），我需要把整个物化视图的流程串联一遍，于是便有了这篇文章。&lt;/p&gt;
&lt;p&gt;在开始之前简单了解下物化视图的基本概念：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/11/13/TMAjuUsEZGJiFDS.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单来说，视图和 MySQL 这类传统数据库的概念类似，也是用于解决大量消耗性能的 SQL 的，可以提前将这些数据查询好然后放在一张单独的表中，这样再查询的时候性能消耗就比较低了。&lt;/p&gt;</summary>
    
    
    
    <category term="StarRocks" scheme="http://crossoverjie.top/categories/StarRocks/"/>
    
    
    <category term="StarRocks" scheme="http://crossoverjie.top/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 StarRocks 的元数据管理</title>
    <link href="http://crossoverjie.top/2024/11/11/ob/StarRocks-meta/"/>
    <id>http://crossoverjie.top/2024/11/11/ob/StarRocks-meta/</id>
    <published>2024-11-11T10:44:37.000Z</published>
    <updated>2024-11-11T13:54:42.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在排查 <code>starrocks</code> 线上的一个告警日志：</p><p><img src="https://s2.loli.net/2024/09/26/QtMIBdmL7OciVJa.png"></p><p>每隔一段时间都会打印 <code>base-table</code> 也就是物化视图的基表被删除了，但其实表还在，也没人去删除；我们就怀疑是否真的表被删除了（可能是 bug）。</p><p>与此同时还有物化视图 inactive 的日志，也怀疑如果视图是 inactive 之后会导致业务使用有问题。</p><p>为了确认这个日志是否对使用影响，就得需要搞清楚它出现的原因；于是我就着手从日志打印的地方开始排查。</p><span id="more"></span><h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p><img src="https://s2.loli.net/2024/09/26/2T4sGfw1YC63EuP.png"><br>从这个代码可以看出，是在查询表的信息的时候没有查到，从而导致日志打印 base-table 被 dropped 了。</p><p>而我查询了几天的 <code>drop table</code> 的日志，依然没有找到可能是程序 bug 导致被删除的痕迹。</p><blockquote><p>好在 starrocks 的日志打印非常详细，包含了线程名称、类+方法名称，还有具体的代码函数，很容易就定位日志输出的地方。</p></blockquote><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>只是为何会调用到这里还需要阅读源码从而找到原因，在开始之前需要先了解一下 starrocks 元数据的一些基本概念。</p><blockquote><p>其实在这篇文章：<a href="https://xie.infoq.cn/article/6f2f9f56916f0eb2fdb6b001a">StarRocks 元数据管理及 FE 高可用机制</a>中已经有全面的介绍，只是这篇文章有点早了，和现在最新的代码不太匹配。</p></blockquote><p>在 StarRocks 元数据中会保存 Database、Table 等信息。</p><p>这些数据定期保存在 <code>fe/meta</code> 目录中。<br><img src="https://s2.loli.net/2024/09/27/3C4GaXM5BlWmNIw.png"></p><p>StarRocks 对元数据的每一次操作（增删改查数据库、表、物化视图）都会生成 editLog 的操作日志。</p><p><img src="https://s2.loli.net/2024/09/27/5hbDBHGwtarE8fj.png" alt="image.png"></p><blockquote><p>新建数据库、修改表名称等</p></blockquote><p>当 StarRocks 的 FE 集群部署时，会由 leader 的 FE 启动一个 checkpoint 线程，定时扫描当前的元数据是否需要生成一个 <code>image.$&#123;JournalId&#125;</code> 的文件。</p><p><img src="https://s2.loli.net/2024/09/20/lQCkBnNWIZ4GwuV.png"></p><blockquote><p>其实就是判断当前日志数量是否达到上限（默认是 5w）生成一次。</p></blockquote><p>具体的流程如下：<br><img src="https://s2.loli.net/2024/09/27/zgy6ZaQ7b1ceWkm.png"></p><ul><li>判断当前是否需要将日志生成 image</li><li>加载当前 image 里的元数据到内存</li><li>从 bdb 中读取最新的 Journal，然后进行重放（replay）：其实就是更新刚才加载到内存中的元数据。</li><li>基于内存中的元数据重新生成一份 image 文件</li><li>删除历史的 image 文件</li><li>将生成的 image 文件名称通知 FE 的 follower 节点，让他们下载到本地，从而可以实现 image 同步。</li></ul><p><img src="https://s2.loli.net/2024/09/27/Hd1NRzgfSy2xECW.png"><br><img src="https://s2.loli.net/2024/09/27/QiTHLpOfJ19oAam.png"></p><blockquote><p>通知 follower 下载 image。</p></blockquote><h2 id="元数据同步流程"><a href="#元数据同步流程" class="headerlink" title="元数据同步流程"></a>元数据同步流程</h2><p>完整的流程图如下图：<br><img src="https://i.imgur.com/txqTt0U.png"></p><p>在这个流程图有一个关键 <code>loadImage</code> 流程：<br><img src="https://s2.loli.net/2024/09/27/MoWjm8SKsgx2GXh.png"></p><p>他会读取 image 这个文件里的数据，然后反序列化后加载到内存里，主要就是恢复数据库和表。</p><p>还会对每个表调用一次 <code>onReload()</code> 函数，而这个函数会只 MV(<code>MATERIALIZED VIEWS</code>) 生效。</p><p>这个函数正好就是在文初提到的这个函数 <code>com.starrocks.catalog.MaterializedView#onReloadImpl</code>：<br><img src="https://s2.loli.net/2024/09/26/2T4sGfw1YC63EuP.png"></p><p>从他的实现来看就是判断视图所依赖的基表是否存在，如果有一个不存在就会将当前基表置为 inactive。</p><p>如果碰到视图的基表也是视图，那就递归再 reload 一次。</p><h2 id="复现问题"><a href="#复现问题" class="headerlink" title="复现问题"></a>复现问题</h2><p>既然知晓了这个加载流程，再结合源码应该不难看出这里的问题所在了。</p><p><img src="https://s2.loli.net/2024/09/27/MoWjm8SKsgx2GXh.png"><br>从这里的加载数据库可以看出端倪，如果我的视图和基表不在同一个数据库里，此时先加载视图是不是就会出现问题？</p><p>加载视图的时候会判断基表是否存在，而此时基表所在的数据库还没加载到内存里，自然就会查询不到从而出现那个日志。</p><p>我之前一直在本地模拟，因为都是在同一个数据库里的基表和视图，所以一直不能复现。</p><p>只要将基表和视图分开在不同的数据库中，让视图先于数据库前加载就会触发这个日志。</p><h1 id="修复问题"><a href="#修复问题" class="headerlink" title="修复问题"></a>修复问题</h1><p>要修复这个问题也很简单，只要等到所有的数据库都表都加载完毕后再去 reload 物化视图就可以了。</p><p>当我回到 main 分支准备着手修改时，发现这个问题已经被修复了：<br><a href="https://github.com/StarRocks/starrocks/pull/51002">https://github.com/StarRocks/starrocks/pull/51002</a></p><p><img src="https://s2.loli.net/2024/09/27/pzWPnoF2MIji9Kw.png"></p><p>修复过程也很简单，就是 reload 时跳过了 MV，等到所有的数据都加载完之后会在 <code>com.starrocks.server.GlobalStateMgr#postLoadImage</code> 手动加载 <code>MV</code>。</p><p><img src="https://s2.loli.net/2024/09/27/7JCLyU6umlRnqvE.png"></p><p>这个 PR 修复的问题也是我一开始提到的，会打印许多令人误解的日志。</p><p>到这里就可以解释文章开头的那个问题了：打印的这个 base-table 被删除的日志对业务来说没有影响，只是一个 bug 导致出现了这个日志。</p><p>额外提一句，这个日志也比较迷，没有打印数据库名称，如果有数据库名称的话可能会更快定位到这个问题。</p><p>参考文章：</p><ul><li><a href="https://xie.infoq.cn/article/6f2f9f56916f0eb2fdb6b001a">https://xie.infoq.cn/article/6f2f9f56916f0eb2fdb6b001a</a></li><li><a href="https://github.com/StarRocks/starrocks/pull/51002">https://github.com/StarRocks/starrocks/pull/51002</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近在排查 &lt;code&gt;starrocks&lt;/code&gt; 线上的一个告警日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/09/26/QtMIBdmL7OciVJa.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;每隔一段时间都会打印 &lt;code&gt;base-table&lt;/code&gt; 也就是物化视图的基表被删除了，但其实表还在，也没人去删除；我们就怀疑是否真的表被删除了（可能是 bug）。&lt;/p&gt;
&lt;p&gt;与此同时还有物化视图 inactive 的日志，也怀疑如果视图是 inactive 之后会导致业务使用有问题。&lt;/p&gt;
&lt;p&gt;为了确认这个日志是否对使用影响，就得需要搞清楚它出现的原因；于是我就着手从日志打印的地方开始排查。&lt;/p&gt;</summary>
    
    
    
    <category term="StarRocks" scheme="http://crossoverjie.top/categories/StarRocks/"/>
    
    
    <category term="StarRocks" scheme="http://crossoverjie.top/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>时隔五年 9K star 的 IM 项目发布 v2.0.0 了</title>
    <link href="http://crossoverjie.top/2024/11/04/ob/cim-2.0.0/"/>
    <id>http://crossoverjie.top/2024/11/04/ob/cim-2.0.0/</id>
    <published>2024-11-04T03:11:48.000Z</published>
    <updated>2024-11-04T10:28:18.438Z</updated>
    
    <content type="html"><![CDATA[<p>最近业余时间花了小三个月重构了 <a href="https://github.com/crossoverJie/cim">cim</a>，也将版本和升级到了 <a href="https://github.com/crossoverJie/cim/releases/tag/v2.0.0">v2.0.0</a>，合并了十几个 PR 同时也新增了几位开发者。</p><p><img src="https://s2.loli.net/2024/10/12/yKzedUZ8DQlVwTC.png" alt="image.png"></p><blockquote><p>其中有两位也是咱们星球里的小伙伴🎉</p></blockquote><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>上次发版还是在五年前了：<br><img src="https://s2.loli.net/2024/10/12/WCP1Vn62SeBNAmZ.png"></p><p>因为确实已经很久没有更新了，在开始之前还是先介绍 <a href="https://github.com/crossoverJie/cim/">cim</a> 是什么。</p><p>这里有一张简单的使用图片：<br><img src="https://s2.loli.net/2024/10/14/pBvDML4HVgyYZxS.gif" alt="Oct-14-2024 11-09-54-min.gif"><br>同时以前也有录过相关的视频：</p><p>通过 <a href="https://github.com/crossoverJie/cim">cim</a> 这个名字和视频可以看出，它具备 IM 即时通讯的基本功能，同时基于它可以实现：</p><ul><li>即时通讯</li><li>消息推送</li><li>IOT 消息平台</li></ul><p>现在要在本地运行简单许多了，前提是有 docker 就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> --name zookeeper -d -p 2181:2181 zookeeper:3.9.2</span><br><span class="line">docker run --<span class="built_in">rm</span> --name redis -d -p 6379:6379 redis:7.4.0</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/crossoverJie/cim.git</span><br><span class="line"><span class="built_in">cd</span> cim</span><br><span class="line">mvn clean package -DskipTests=<span class="literal">true</span></span><br><span class="line"><span class="built_in">cd</span> cim-server &amp;&amp; cim-client &amp;&amp; cim-forward-route</span><br><span class="line">mvn clean package spring-boot:repackage -DskipTests=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><a href="https://github.com/crossoverJie/cim">cim</a> 的架构图如下：<br><img src="https://s2.loli.net/2024/10/13/O7wVi8QYr3lMFJo.png"><br>主要分为三个部分：</p><ul><li>Client 基本交互功能<ul><li>消息收发</li><li>消息查询</li><li>延迟消息</li></ul></li><li>Route 提供了消息路由以及相关的管理功能<ul><li>API 转发</li><li>消息推送</li><li>会话管理</li><li>可观测性</li></ul></li><li>Server 主要就提供长链接能力，以及真正的消息推送</li></ul><p>同时还有元数据中心（支持扩展实现）、消息存储等组件；</p><p>不管是客户端、route、server 都是支持集群：</p><ul><li>route 由于是无状态，可以任意扩展</li><li>server 通过注册中心也支持集群部署，当发生宕机或者是扩容时，客户端会通过心跳和重连机制保证可用性。</li></ul><p>所以整个架构不存在<strong>单点</strong>，同时比较简单清晰的，大部分组件都支持可扩展。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="https://s2.loli.net/2024/10/13/8teMn7BSa5VWuvi.png"></p><p>为了更方便理解，花了一个流程图。</p><ul><li>server 在启动之后会先在元数据中心注册</li><li>同时 route 会订阅元数据中的 server 信息</li><li>客户端登陆时会调用 route 获取一个 server 的节点信息</li><li>然后发起登陆请求。<ul><li>成功之后会保持长链接。</li></ul></li><li>客户端向发送消息时会调用 route 接口来发起消息<ul><li>route 根据长链接关系选择 server 进行消息推送</li></ul></li></ul><h2 id="v2-0-0"><a href="#v2-0-0" class="headerlink" title="v2.0.0"></a>v2.0.0</h2><p>接下来介绍下本次 <a href="https://github.com/crossoverJie/cim/releases/tag/v2.0.0">v2.0.0</a> 有哪些重大变更，毕竟是修改了大的版本号。</p><p>这里列举一些重大的改动：<br><img src="https://s2.loli.net/2024/10/12/mRGDV6hBCTAblcI.png" alt="image.png"></p><ul><li>首先是支持了元数据中心，解耦了 zookeeper，也支持自定义实现。</li><li>支持了集成测试，可以保证提交的 PR 对现有功能的影响降到最低，代码质量有一定保证；review 代码时更加放心。</li><li>单独抽离了 <code>client-sdk</code>，代码耦合性更好且更易维护。</li><li>服务之间调用的 RPC 完成了重构<ul><li>支持了动态 URL</li><li>泛型数据解析</li></ul></li><li>还有社区小伙伴贡献的一些 bug 修复、<code>RpcProxyManager</code> 的 IOC 支持等特性。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>更多的部署和使用可以参考项目首页的 README，有详细的介绍。</p><p><a href="https://github.com/crossoverJie/cim">cim</a> 目前还需要优化的地方非常多；接下来的重点是实现 ACK，同时会完善一下通讯协议。<br><img src="https://s2.loli.net/2024/10/14/l7RIZfYOsmM1N3P.png" alt="image.png"></p><p>todo 列表我也添加了很多，所以非常推荐感兴趣的朋友可以先看看 todo 列表，说不定就有你感兴趣的可以参与一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近业余时间花了小三个月重构了 &lt;a href=&quot;https://github.com/crossoverJie/cim&quot;&gt;cim&lt;/a&gt;，也将版本和升级到了 &lt;a href=&quot;https://github.com/crossoverJie/cim/releases/tag/v2.0.0&quot;&gt;v2.0.0&lt;/a&gt;，合并了十几个 PR 同时也新增了几位开发者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/10/12/yKzedUZ8DQlVwTC.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其中有两位也是咱们星球里的小伙伴🎉&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="IM" scheme="http://crossoverjie.top/categories/IM/"/>
    
    
    <category term="IM" scheme="http://crossoverjie.top/tags/IM/"/>
    
  </entry>
  
  <entry>
    <title>💢线上高延迟请求排查</title>
    <link href="http://crossoverjie.top/2024/10/29/ob/%F0%9F%92%A2%E7%BA%BF%E4%B8%8A%E9%AB%98%E5%BB%B6%E8%BF%9F%E8%AF%B7%E6%B1%82%E6%8E%92%E6%9F%A5/"/>
    <id>http://crossoverjie.top/2024/10/29/ob/%F0%9F%92%A2%E7%BA%BF%E4%B8%8A%E9%AB%98%E5%BB%B6%E8%BF%9F%E8%AF%B7%E6%B1%82%E6%8E%92%E6%9F%A5/</id>
    <published>2024-10-29T10:21:42.000Z</published>
    <updated>2024-10-28T10:29:17.642Z</updated>
    
    <content type="html"><![CDATA[<p>前几天排查了一个业务接口执行高延迟的问题，也挺有参考意义的，分享一下排查过程。</p><p>现象是业务反馈有一个接口业务逻辑其实很简单，但是调用一次耗时，如下图所示：<br><img src="https://s2.loli.net/2024/10/16/Am9VkNZ5Ep4Uj6G.png"></p><span id="more"></span><h1 id="排查应用运行状态"><a href="#排查应用运行状态" class="headerlink" title="排查应用运行状态"></a>排查应用运行状态</h1><p>首先第一步需要查看当时的应用运行状态，包含当时的日志、JVM 的各种监控等。</p><p>因为我们接入了 <code>OpenTelemetry</code>，所以 <code>trace</code> 和日志是可以关联起来的。</p><blockquote><p>点击链路系统旁边的日志按钮可以直接跳转。</p></blockquote><p>可以通过 <code>trace_id</code> 查询到相关日志：<br><img src="https://s2.loli.net/2024/10/16/W5ow6KpdCaOk2f7.png"></p><p>通过日志可以看出耗时大约在 4s 多一点，然后结合代码发现这两段日志分别是在进入一个核心业务方法之前和方法内打印的。</p><p><img src="https://s2.loli.net/2024/10/16/XeqoaGPx8kEmSrD.png"></p><p>而第一行日志是在一个自定义限流器中打印的，这个限流器是使用 <code>Guava</code> 的 <code>RateLimiter</code>实现的。</p><p>我的第一反应是不是这个限流器当时限流了，从而导致阻塞了；但查看了当时的 QPS 发现完全低于限流器的配置，所以基本可以排除它的嫌疑了。</p><h2 id="JVM-监控"><a href="#JVM-监控" class="headerlink" title="JVM 监控"></a>JVM 监控</h2><p><img src="https://s2.loli.net/2024/10/16/f3H6VBFRpCN7Yza.png"></p><p><img src="https://s2.loli.net/2024/10/16/zvKPyXuScQwmiYN.png"></p><p>之后我们查询当时的 JVM 监控发现当时的 GC  频繁，而堆内存也正好发生了一次回收，初步判断是 GC 导致的本次问题。</p><p>但为啥会导致频繁的 GC 呢，还需要继续排查。</p><h2 id="内存排查"><a href="#内存排查" class="headerlink" title="内存排查"></a>内存排查</h2><p>我们在应用诊断中集成了 <a href="https://github.com/grafana/pyroscope">Pyroscope</a>的持续剖析，可以实时查看内存的占用情况。<br><img src="https://s2.loli.net/2024/10/16/Ow5WksxJan9G8py.png"></p><p><img src="https://s2.loli.net/2024/10/16/CbPhVJ4mDyFxicX.png" alt="image.png"></p><p>通过内存分析发现有大量的 JSON 序列化占用了大量的内存，同时还发现 Pod 已经被重启好几次了：<br><img src="https://s2.loli.net/2024/10/16/iKHCFodeVPM9A68.png" alt="image.png"></p><p><img src="https://s2.loli.net/2024/10/16/31aTS7yqNCKlFJQ.png" alt="image.png"></p><p>查看原因发现是 Pod OOM 导致的。</p><p>因此非常有可能是 GC 导致的，恰好那段时间发生了 GC 内存也有明显变化。</p><p><img src="https://s2.loli.net/2024/10/16/f3H6VBFRpCN7Yza.png"></p><p><img src="https://s2.loli.net/2024/10/16/zvKPyXuScQwmiYN.png"></p><p><img src="https://s2.loli.net/2024/10/16/hsXUAZCIGY12gFk.png"></p><p>最后再通过 arthas 确认了 GC 非常频繁，可以确认目前的资源是是非常紧张的，咨询业务之后得知该应用本身占用的资源就比较大，没有太多优化空间，所以最终决定还是加配置。<br><img src="https://s2.loli.net/2024/10/16/VGyrCAZgjx64wHP.png"><br><img src="https://s2.loli.net/2024/10/17/zIEjeMxvkgLomZ4.png" alt="image.png"><br>还是提高硬件效率最高，目前运行半个月之后 Pod 内存表现稳定，没有出现一次 OOM 的异常。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然最后的处理的方式是简单粗暴的，但其中的过程还是有意义的，遇到不同的情况也有不同的处理方式。</p><p>比如在排查过程中发现内存消耗异常，通过内存分析发现代码可以优化，那就优化代码逻辑。</p><p>如果是堆内存占用不大，但是 Pod 还是 OOM 导致重启，那就要看看 JVM 的内存分配是否合理，应该多预留一些内存给堆外使用。</p><p>但这个过程需要有<strong>完善的可观测系统的</strong>支撑，比如日志、监控等，如果没有这些数据，再回头排查问题就会比较困难。</p><p>总之这个排查过程才是最主要的，大家还有什么排查问题的小 tips 也欢迎在评论区分享。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前几天排查了一个业务接口执行高延迟的问题，也挺有参考意义的，分享一下排查过程。&lt;/p&gt;
&lt;p&gt;现象是业务反馈有一个接口业务逻辑其实很简单，但是调用一次耗时，如下图所示：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/10/16/Am9VkNZ5Ep4Uj6G.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="问题排查" scheme="http://crossoverjie.top/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    
    <category term="Java" scheme="http://crossoverjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>IM系统重构到 SDK 设计的最佳实践</title>
    <link href="http://crossoverjie.top/2024/10/13/ob/cim-client-sdk/"/>
    <id>http://crossoverjie.top/2024/10/13/ob/cim-client-sdk/</id>
    <published>2024-10-13T14:04:45.000Z</published>
    <updated>2024-10-13T06:00:43.572Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/10/13/PW1J2bXx39cfpnC.png"></p><h1 id="SDK-设计"><a href="#SDK-设计" class="headerlink" title="SDK 设计"></a>SDK 设计</h1><p><img src="https://s2.loli.net/2024/09/17/Ck6AfdGOPISDrVN.png"></p><p>在之前提到了 <a href="https://github.com/crossoverJie/cim">cim</a> 在做集成测试的时候遇到的问题，需要提供一个 SDK 来解决，于是我花了一些时间编写了 SDK，同时也将 cim-client 重构了。</p><span id="more"></span><p>重构后的代码长这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Client <span class="title function_">buildClient</span><span class="params">(<span class="meta">@Qualifier(&quot;callBackThreadPool&quot;)</span> ThreadPoolExecutor callbackThreadPool,</span></span><br><span class="line"><span class="params">                          Event event)</span> &#123;</span><br><span class="line">    <span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().connectTimeout(<span class="number">3</span>, TimeUnit.SECONDS)</span><br><span class="line">            .readTimeout(<span class="number">3</span>, TimeUnit.SECONDS)</span><br><span class="line">            .writeTimeout(<span class="number">3</span>, TimeUnit.SECONDS)</span><br><span class="line">            .retryOnConnectionFailure(<span class="literal">true</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Client.builder()</span><br><span class="line">            .auth(ClientConfigurationData.Auth.builder()</span><br><span class="line">                    .userName(appConfiguration.getUserName())</span><br><span class="line">                    .userId(appConfiguration.getUserId())</span><br><span class="line">                    .build())</span><br><span class="line">            .routeUrl(appConfiguration.getRouteUrl())</span><br><span class="line">            .loginRetryCount(appConfiguration.getReconnectCount())</span><br><span class="line">            .event(event)</span><br><span class="line">            .reconnectCheck(client -&gt; !shutDownSign.checkStatus())</span><br><span class="line">            .okHttpClient(okHttpClient)</span><br><span class="line">            .messageListener(<span class="keyword">new</span> <span class="title class_">MsgCallBackListener</span>(msgLogger))</span><br><span class="line">            .callbackThreadPool(callbackThreadPool)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合 <code>springboot</code> 使用时只需要创建一个 <code>Client</code> 即可，这个 <code>Client</code> 里维护了核心的：</p><ul><li>长链接创建、状态维护</li><li>心跳检测</li><li>超时、网络异常重连等</li></ul><p>同时也提供了简易的 API 可以直接收发消息：<br><img src="https://s2.loli.net/2024/09/17/2tCXEo9nLvIrNTf.png"></p><p>这样在集成到业务代码中时会更方便。</p><p>以前的代码耦合度非常高，同时因为基础代码是 18 年写的，现在真的没有眼看了；</p><p>重构的过程中使用一些 Java8+ 的一些语法糖精简了许多代码，各个模块间的组织关系也重新梳理，现在会更易维护了。</p><p>比如由于创建客户端需要许多可选参数，于是就提供了 Builder 模式的创建选项：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClientBuilder</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    Client <span class="title function_">build</span><span class="params">()</span>;  </span><br><span class="line">    ClientBuilder <span class="title function_">auth</span><span class="params">(ClientConfigurationData.Auth auth)</span>;  </span><br><span class="line">    ClientBuilder <span class="title function_">routeUrl</span><span class="params">(String routeUrl)</span>;  </span><br><span class="line">    ClientBuilder <span class="title function_">loginRetryCount</span><span class="params">(<span class="type">int</span> loginRetryCount)</span>;  </span><br><span class="line">    ClientBuilder <span class="title function_">event</span><span class="params">(Event event)</span>;  </span><br><span class="line">    ClientBuilder <span class="title function_">reconnectCheck</span><span class="params">(ReconnectCheck reconnectCheck)</span>;  </span><br><span class="line">    ClientBuilder <span class="title function_">okHttpClient</span><span class="params">(OkHttpClient okHttpClient)</span>;  </span><br><span class="line">    ClientBuilder <span class="title function_">messageListener</span><span class="params">(MessageListener messageListener)</span>;  </span><br><span class="line">    ClientBuilder <span class="title function_">callbackThreadPool</span><span class="params">(ThreadPoolExecutor callbackThreadPool)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上部分 API 的设计借鉴了 Pulsar。</p></blockquote><h1 id="Proxy-优化"><a href="#Proxy-优化" class="headerlink" title="Proxy 优化"></a>Proxy 优化</h1><p>除此之外还优化了请求代理，这个 Proxy 主要是用于方便在各个服务中发起 rest 调用，我这里为了轻量也没有使用 Dubbo、SpringCloud 这类服务框架。</p><p>但如果都硬编码 http client 去请求时会有许多重复冗余的代码，比如创建连接、请求参数、响应解析、异常处理等。</p><p>于是在之前的版本中就提供了一个 <code>ProxyManager</code> 的基本实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> List&lt;OnlineUsersResVO.DataBodyBean&gt; onlineUsers() <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">    <span class="type">RouteApi</span> <span class="variable">routeApi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyManager</span>&lt;&gt;(RouteApi.class, routeUrl, okHttpClient).getInstance();  </span><br><span class="line">  </span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="type">OnlineUsersResVO</span> <span class="variable">onlineUsersResVO</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        response = (Response) routeApi.onlineUser();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> response.body().string() ;  </span><br><span class="line">        onlineUsersResVO = JSON.parseObject(json, OnlineUsersResVO.class);  </span><br><span class="line">  </span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">        log.error(<span class="string">&quot;exception&quot;</span>,e);  </span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;  </span><br><span class="line">        response.body().close();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> onlineUsersResVO.getDataBody();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然提供了一些连接管理和参数封装等基础功能，但只实现了一半。</p><p>从上面的代码也可以看出序列化都得自己实现，这些代码完全是冗余的。</p><p>经过重构后以上的代码可以精简到如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明接口</span></span><br><span class="line"><span class="meta">@Request(method = Request.GET)</span>  </span><br><span class="line">BaseResponse&lt;Set&lt;CIMUserInfo&gt;&gt; <span class="title function_">onlineUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">routeApi = RpcProxyManager.create(RouteApi.class, routeUrl, okHttpClient);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Set&lt;CIMUserInfo&gt; <span class="title function_">onlineUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    BaseResponse&lt;Set&lt;CIMUserInfo&gt;&gt; onlineUsersResVO = routeApi.onlineUser();  </span><br><span class="line">    <span class="keyword">return</span> onlineUsersResVO.getDataBody();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个调整之后就非常类似于 Dubbo gRPC 这类 RPC 框架的使用，只需要把接口定义好，就和调用本地函数一样的简单。</p><p>为了方便后续可能调用一些外部系统，在此基础上还支持了指定多种请求 method、指定 URL 、返回结果嵌套泛型等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Request(url = &quot;sample-request?author=beeceptor&quot;)</span>  </span><br><span class="line">EchoGeneric&lt;EchoResponse.HeadersDTO&gt; echoGeneric(EchoRequest message);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGeneric</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://echo.free.beeceptor.com&quot;</span>;  </span><br><span class="line">    <span class="type">Echo</span> <span class="variable">echo</span> <span class="operator">=</span> RpcProxyManager.create(Echo.class, url, client);  </span><br><span class="line">    <span class="type">EchoRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EchoRequest</span>();  </span><br><span class="line">    request.setName(<span class="string">&quot;crossoverJie&quot;</span>);  </span><br><span class="line">    request.setAge(<span class="number">18</span>);  </span><br><span class="line">    request.setCity(<span class="string">&quot;shenzhen&quot;</span>);  </span><br><span class="line">    <span class="comment">// 支持泛型解析</span></span><br><span class="line">    EchoGeneric&lt;EchoResponse.HeadersDTO&gt; response = echo.echoGeneric(request);  </span><br><span class="line">    Assertions.assertEquals(response.getHeaders().getHost(), <span class="string">&quot;echo.free.beeceptor.com&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支持动态-URL-调用"><a href="#支持动态-URL-调用" class="headerlink" title="支持动态 URL 调用"></a>支持动态 URL 调用</h2><p><img src="https://s2.loli.net/2024/09/19/v8NgprfJ5PWAsER.png"></p><p>还有一个 todo：希望可以将 <code>ProxyManager</code> 交给 <code>Spring</code> 去管理，之前是在每次调用的地方都会创建一个 Proxy 对象，完全没有必要，代码也很冗余。</p><p>但有网友在实现过程中发现，有个场景的请求地址是动态的，如果是交给 Spring 管理为单例后是没法修改 URL 地址的，因为这个地址是在创建对象的时候初始化的。</p><p>所以我就在这里新增了一个动态 URL 的特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EchoResponse <span class="title function_">echoTarget</span><span class="params">(EchoRequest message, <span class="meta">@DynamicUrl(useMethodEndpoint = false)</span> String url)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Echo</span> <span class="variable">echo</span> <span class="operator">=</span> RpcProxyManager.create(Echo.class, client);</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://echo.free.beeceptor.com/sample-request?author=beeceptor&quot;</span>;</span><br><span class="line"><span class="type">EchoResponse</span> <span class="variable">response</span> <span class="operator">=</span> echo.echoTarget(request, url);</span><br></pre></td></tr></table></figure><p>在声明接口的时候使用 <code>@DynamicUrl</code> 的方法参数注解，告诉代理这个参数是 URL。<br>这样就可以允许在创建  <code>Proxy</code> 对象的时候不指定 URL，而是在实际调用时候再传入具体的 URL，更方便创建单例了。</p><h1 id="集成测试优化"><a href="#集成测试优化" class="headerlink" title="集成测试优化"></a>集成测试优化</h1><p>同时还优化了集成测试，支持了 server 的集群版测试。</p><p><a href="https://github.com/crossoverJie/cim/blob/4c149f8bda78718e3ecae2c5759aa9732eff9132/cim-client-sdk/src/test/java/com/crossoverjie/cim/client/sdk/ClientTest.java#L210">https://github.com/crossoverJie/cim/blob/4c149f8bda78718e3ecae2c5759aa9732eff9132/cim-client-sdk/src/test/java/com/crossoverjie/cim/client/sdk/ClientTest.java#L210</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReconnect</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="built_in">super</span>.startTwoServer();  </span><br><span class="line">    <span class="built_in">super</span>.startRoute();  </span><br><span class="line">  </span><br><span class="line">    <span class="type">String</span> <span class="variable">routeUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8083&quot;</span>;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">cj</span> <span class="operator">=</span> <span class="string">&quot;cj&quot;</span>;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">zs</span> <span class="operator">=</span> <span class="string">&quot;zs&quot;</span>;  </span><br><span class="line">    <span class="type">Long</span> <span class="variable">cjId</span> <span class="operator">=</span> <span class="built_in">super</span>.registerAccount(cj);  </span><br><span class="line">    <span class="type">Long</span> <span class="variable">zsId</span> <span class="operator">=</span> <span class="built_in">super</span>.registerAccount(zs);  </span><br><span class="line">    <span class="type">var</span> <span class="variable">auth1</span> <span class="operator">=</span> ClientConfigurationData.Auth.builder()  </span><br><span class="line">            .userName(cj)  </span><br><span class="line">            .userId(cjId)  </span><br><span class="line">            .build();  </span><br><span class="line">    <span class="type">var</span> <span class="variable">auth2</span> <span class="operator">=</span> ClientConfigurationData.Auth.builder()  </span><br><span class="line">            .userName(zs)  </span><br><span class="line">            .userId(zsId)  </span><br><span class="line">            .build();  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Cleanup</span>  </span><br><span class="line">    <span class="type">Client</span> <span class="variable">client1</span> <span class="operator">=</span> Client.builder()  </span><br><span class="line">            .auth(auth1)  </span><br><span class="line">            .routeUrl(routeUrl)  </span><br><span class="line">            .build();  </span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);  </span><br><span class="line">    ClientState.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> client1.getState();  </span><br><span class="line">    Awaitility.await().atMost(<span class="number">10</span>, TimeUnit.SECONDS)  </span><br><span class="line">            .untilAsserted(() -&gt; Assertions.assertEquals(ClientState.State.Ready, state));  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    AtomicReference&lt;String&gt; client2Receive = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();  </span><br><span class="line">    <span class="meta">@Cleanup</span>  </span><br><span class="line">    <span class="type">Client</span> <span class="variable">client2</span> <span class="operator">=</span> Client.builder()  </span><br><span class="line">            .auth(auth2)  </span><br><span class="line">            .routeUrl(routeUrl)  </span><br><span class="line">            .messageListener((client, message) -&gt; client2Receive.set(message))  </span><br><span class="line">            .build();  </span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);  </span><br><span class="line">    ClientState.<span class="type">State</span> <span class="variable">state2</span> <span class="operator">=</span> client2.getState();  </span><br><span class="line">    Awaitility.await().atMost(<span class="number">10</span>, TimeUnit.SECONDS)  </span><br><span class="line">            .untilAsserted(() -&gt; Assertions.assertEquals(ClientState.State.Ready, state2));  </span><br><span class="line">  </span><br><span class="line">    Optional&lt;CIMServerResVO&gt; serverInfo2 = client2.getServerInfo();  </span><br><span class="line">    Assertions.assertTrue(serverInfo2.isPresent());  </span><br><span class="line">    System.out.println(<span class="string">&quot;client2 serverInfo = &quot;</span> + serverInfo2.get());  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// send msg  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line">    client1.sendGroup(msg);  </span><br><span class="line">    Awaitility.await()  </span><br><span class="line">            .untilAsserted(() -&gt; Assertions.assertEquals(String.format(<span class="string">&quot;cj:%s&quot;</span>, msg), client2Receive.get()));  </span><br><span class="line">    client2Receive.set(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    System.out.println(<span class="string">&quot;ready to restart server&quot;</span>);  </span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);  </span><br><span class="line">    Optional&lt;CIMServerResVO&gt; serverInfo = client1.getServerInfo();  </span><br><span class="line">    Assertions.assertTrue(serverInfo.isPresent());  </span><br><span class="line">    System.out.println(<span class="string">&quot;server info = &quot;</span> + serverInfo.get());  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">super</span>.stopServer(serverInfo.get().getCimServerPort());  </span><br><span class="line">    System.out.println(<span class="string">&quot;stop server success! &quot;</span> + serverInfo.get());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Waiting server stopped, and client reconnect.  </span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">30</span>);  </span><br><span class="line">    System.out.println(<span class="string">&quot;reconnect state: &quot;</span> + client1.getState());  </span><br><span class="line">    Awaitility.await().atMost(<span class="number">15</span>, TimeUnit.SECONDS)  </span><br><span class="line">            .untilAsserted(() -&gt; Assertions.assertEquals(ClientState.State.Ready, state));  </span><br><span class="line">    serverInfo = client1.getServerInfo();  </span><br><span class="line">    Assertions.assertTrue(serverInfo.isPresent());  </span><br><span class="line">    System.out.println(<span class="string">&quot;client1 reconnect server info = &quot;</span> + serverInfo.get());  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Send message again.  </span></span><br><span class="line">    log.info(<span class="string">&quot;send message again, client2Receive = &#123;&#125;&quot;</span>, client2Receive.get());  </span><br><span class="line">    client1.sendGroup(msg);  </span><br><span class="line">    Awaitility.await()  </span><br><span class="line">            .untilAsserted(() -&gt; Assertions.assertEquals(String.format(<span class="string">&quot;cj:%s&quot;</span>, msg), client2Receive.get()));  </span><br><span class="line">    <span class="built_in">super</span>.stopTwoServer();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如在这里编写了一个客户端重连的单测，代码有点长，但它的主要流程如下：</p><ul><li>启动两个 Server：Server1，Server2</li><li>启动 Route</li><li>在启动两个 Client 发送消息<ul><li>校验消息发送是否成功</li></ul></li><li><strong>停止 Client1 连接的 Server</strong></li><li><strong>等待 Client 自动重连到另一个 Server</strong></li><li>再次发送消息<ul><li>校验消息发送是否成功</li></ul></li></ul><p>这样就可以验证在服务端 Server 宕机后整个服务是否可用，消息收发是否正常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startTwoServer</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!zooKeeperContainer.isRunning())&#123;  </span><br><span class="line">        zooKeeperContainer.start();  </span><br><span class="line">    &#125;    zookeeperAddr = String.format(<span class="string">&quot;%s:%d&quot;</span>, zooKeeperContainer.getHost(), zooKeeperContainer.getMappedPort(ZooKeeperContainer.DEFAULT_CLIENT_PORT));  </span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(CIMServerApplication.class);  </span><br><span class="line">    String[] args1 = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;  </span><br><span class="line">            <span class="string">&quot;--cim.server.port=11211&quot;</span>,  </span><br><span class="line">            <span class="string">&quot;--server.port=8081&quot;</span>,  </span><br><span class="line">            <span class="string">&quot;--app.zk.addr=&quot;</span> + zookeeperAddr,  </span><br><span class="line">    &#125;;    <span class="type">ConfigurableApplicationContext</span> <span class="variable">run1</span> <span class="operator">=</span> server.run(args1);  </span><br><span class="line">    runMap.put(Integer.parseInt(<span class="string">&quot;11211&quot;</span>), run1);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">server2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(CIMServerApplication.class);  </span><br><span class="line">    String[] args2 = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;  </span><br><span class="line">            <span class="string">&quot;--cim.server.port=11212&quot;</span>,  </span><br><span class="line">            <span class="string">&quot;--server.port=8082&quot;</span>,  </span><br><span class="line">            <span class="string">&quot;--app.zk.addr=&quot;</span> + zookeeperAddr,  </span><br><span class="line">    &#125;;    <span class="type">ConfigurableApplicationContext</span> <span class="variable">run2</span> <span class="operator">=</span> server2.run(args2);  </span><br><span class="line">    runMap.put(Integer.parseInt(<span class="string">&quot;11212&quot;</span>), run2);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopServer</span><span class="params">(Integer port)</span> &#123;  </span><br><span class="line">    runMap.get(port).close();  </span><br><span class="line">    runMap.remove(port);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的启动两个 Server 就是创建了两个 Server 应用，然后保存好端口和应用之间的映射关系。</p><p>这样就可以根据客户端连接的 Server 信息指定停止哪一个 Server，更方便做测试。</p><p>这次重启 <a href="https://github.com/crossoverJie/cim">cim</a> 的维护后会尽量维护下去，即便更新时间慢一点。</p><p>后续还会加上消息 ack、离线消息等之前呼声很高的功能，感兴趣的完全可以一起参与。</p><p>源码地址：<br><a href="https://github.com/crossoverJie/cim">https://github.com/crossoverJie/cim</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/10/13/PW1J2bXx39cfpnC.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;SDK-设计&quot;&gt;&lt;a href=&quot;#SDK-设计&quot; class=&quot;headerlink&quot; title=&quot;SDK 设计&quot;&gt;&lt;/a&gt;SDK 设计&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/09/17/Ck6AfdGOPISDrVN.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在之前提到了 &lt;a href=&quot;https://github.com/crossoverJie/cim&quot;&gt;cim&lt;/a&gt; 在做集成测试的时候遇到的问题，需要提供一个 SDK 来解决，于是我花了一些时间编写了 SDK，同时也将 cim-client 重构了。&lt;/p&gt;</summary>
    
    
    
    <category term="cim" scheme="http://crossoverjie.top/categories/cim/"/>
    
    
    <category term="cim" scheme="http://crossoverjie.top/tags/cim/"/>
    
  </entry>
  
  <entry>
    <title>StarRocks 开发环境搭建踩坑指北</title>
    <link href="http://crossoverjie.top/2024/10/09/ob/StarRocks-dev-env-build/"/>
    <id>http://crossoverjie.top/2024/10/09/ob/StarRocks-dev-env-build/</id>
    <published>2024-10-09T09:20:19.000Z</published>
    <updated>2024-10-08T14:21:33.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近这段时间在处理一个 <code>StarRocks</code> 的关于物化视图优化的一个问题，在此之前其实我也没有接触过 <code>StarRocks</code> 这类主要处理数据分析的数据库，就更别提在这上面做优化了。</p><p>在解决问题之前我先花了一两天时间熟悉了一下 <code>StarRocks</code> 的一些概念和使用方法，然后又花了一些时间搭建环境然后复现了该问题。</p><p>之后便开始阅读源码，大概知道了相关代码的执行流程，但即便是反复阅读了多次代码也没有找到具体出现问题的地方。</p><p>所以便考虑在本地 Debug 源码，最终调试半天之后知道了问题所以，也做了相关修改，给社区提交了 PR，目前还在推进过程中。</p><span id="more"></span><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>这里比较麻烦的是如何在本地 debug 代码。<br><img src="https://s2.loli.net/2024/09/16/uqKGRIJXZB3pbMy.png"><br>根据官方的架构图会发现 <code>StarRocks</code> 主要分为两个部分：</p><ul><li>FE：也就是常说的前端部分，主要负责元数据管理和构建执行计划。</li><li>BE：后端存储部分，执行查询计划并存储数据。</li></ul><p>其中 FE 是 Java 写的，而存储的 BE 则是 C++ 写的，我这次需要修改的是 FE 前端的部分，所以本篇文章主要讨论的是 FE 相关的内容。</p><p>好在社区已经有关于如何编译和构建源码的教程，这里我列举一些重点，FE 首先需要安装以下一些工具：</p><ul><li>Thrift</li><li>Protobuf</li><li>Python3</li><li>JDK8+</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install alberttwong/thrift/thrift@0.13</span><br><span class="line">$ thrift -version  </span><br><span class="line">Thrift version 0.13.0</span><br><span class="line"></span><br><span class="line">brew install protobuf</span><br></pre></td></tr></table></figure><p>以上默认是在  Mac 平台上安装的流程，所以全程使用 <code>brew</code> 最方便了，如果是其他平台也是同理，只要安装好这些工具即可。</p><p>紧接着便是编译 FE，我们需要先下载源码，然后进入 FE 的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/StarRocks/starrocks.git</span><br><span class="line"><span class="built_in">cd</span> fe</span><br><span class="line">mvn install -DskipTests</span><br></pre></td></tr></table></figure><p>然后直接使用 <code>maven</code> 编译安装即可。</p><p>这里需要注意⚠️，因为编译过程中需要使用 <code>Python3</code> 来执行一些构建任务，新版本的 Mac 都是内置 <code>Python3</code> 的，但如果是老版本的 <code>Mac</code> 内置的则是 Python2。</p><p>这时就需要我们将 Python3 的命令手动在构建任务里指定一下：</p><p><img src="https://s2.loli.net/2024/09/16/ouLglsXJEm1TpSh.png"></p><p>比如我这里的 Python3  命令为 <code>python3</code></p><p>我们需要在 <code>fe/fe-core/pom.xml</code> 目录里修改下 Python 的命令名称：<br><img src="https://s2.loli.net/2024/09/16/tcfwoilyDdTQpxX.png"></p><p>修改之后再 <code>mvn install</code> 编译一次，如果一切顺利的话便会编译成功。</p><h2 id="搭建本地集群"><a href="#搭建本地集群" class="headerlink" title="搭建本地集群"></a>搭建本地集群</h2><h3 id="启动-FE"><a href="#启动-FE" class="headerlink" title="启动 FE"></a>启动 FE</h3><p>我的最终目的是可以在本地 IDEA 中启动 FE 然后再配合启动一个 BE，这样就可以在 IDEA 中调试 FE 的源码了。</p><p>在启动 FE 之前还需要创建一些目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r conf fe/conf</span><br><span class="line"><span class="built_in">cp</span> -r bin fe/bin</span><br><span class="line"><span class="built_in">cp</span> -r webroot fe/webroot</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> fe  </span><br><span class="line"><span class="built_in">mkdir</span> <span class="built_in">log</span>  </span><br><span class="line"><span class="built_in">mkdir</span> meta</span><br></pre></td></tr></table></figure><p>主要就是要在 FE 的目录下创建配置文件、执行脚本、日志、元数据等目录。</p><p>接着便可以打开 <code>com.starrocks.StarRocksFE</code> 类在 IDEA 中运行了，在启动之前还需要配置一下环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改为自己的目录</span></span><br><span class="line"><span class="built_in">export</span> PID_DIR=/Users/smith/Code/starrocks/fe/bin</span><br><span class="line"><span class="built_in">export</span> STARROCKS_HOME=/Users/smith/Code/starrocks/fe</span><br><span class="line"><span class="built_in">export</span> LOG_DIR=/Users/smith/Code/starrocks/fe/log</span><br></pre></td></tr></table></figure><p>同时需要配置下 <code>fe.conf</code> 中的 <code>priority_networks</code> 网络配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_networks = 10.10.10.0/24</span><br></pre></td></tr></table></figure><p>这个 IP 得是<strong>宿主机的 IP</strong>，后续我们使用 docker 启动 BE 的时候也需要用到。</p><p><img src="https://s2.loli.net/2024/09/16/Lgrl4YSaD1GdzIZ.png"></p><p>如果启动失败，可以在日志目录下查看日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024-09-16 21:21:59.942+08:00 ERROR (main|1) [NodeMgr.getCheckedSelfHostPort():642] edit_log_port 9010 is already in use. will exit.</span><br></pre></td></tr></table></figure><p>碰到这个异常：提示端口被占用，那可以尝试关闭代理之后再试试。</p><p>启动成功后我们便可以使用 <code>MySQL</code> 兼容的客户端进行连接了，这里我使用的是 <code>tableplus</code>:<br><img src="https://s2.loli.net/2024/09/16/8XMI1DdjGkOKVPy.png"></p><p>然后我们使用以下 sql  可以查询 fe 的节点状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROC <span class="string">&#x27;/frontends&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/16/Jg5TIMtpKoknq4Z.png"></p><p>看到类似的输出则代表启动成功了。</p><h3 id="启动-BE"><a href="#启动-BE" class="headerlink" title="启动 BE"></a>启动 BE</h3><p>之后我们便可以使用 Docker 来启动 BE 了，之所以用 docker 启动，是因为 BE 是 C++ 编写的，想要在 Mac 上运行比较麻烦，最好是得有一台 <code>Ubuntu22</code> 的虚拟机。</p><p>如果我们不需要调试 BE 的话，只使用 docker 启动是再合适不过了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9060:9060 -p 8040:8040 -p 9050:9050 -p 8060:8060 -p 9070:9070 -itd --<span class="built_in">rm</span> --name be -e <span class="string">&quot;TZ=Asia/Shanghai&quot;</span> starrocks/be-ubuntu</span><br></pre></td></tr></table></figure><p>我们需要将 FE 需要连接 BE 的端口暴露出来，启动成功后该镜像并不会直接启动 BE，我们需要进入容器手动启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it be bash</span><br></pre></td></tr></table></figure><p>在启动之前我们依然需要修改下 be.conf 中的 <code>priority_networks</code> 配置：</p><p><img src="https://s2.loli.net/2024/09/16/mcFCo24Kyxui8gt.png"><br>修改为和 fe.conf 中相同的配置。</p><p>之后使用以下命令启动 be:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/start_be.sh --daemon</span><br></pre></td></tr></table></figure><p>启动日志我们可以在 logs 目录中查看。</p><h3 id="绑定-FE-和-BE"><a href="#绑定-FE-和-BE" class="headerlink" title="绑定 FE 和 BE"></a>绑定 FE 和 BE</h3><p>接下来还有最后一步就是将 FE 和 BE 绑定在一起。</p><p>我们在 fe 中执行以下 sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">ADD</span> BACKEND &quot;127.0.0.1:9050&quot;;</span><br></pre></td></tr></table></figure><p>手动添加一个节点，之后再使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROC <span class="string">&#x27;/backends&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以查询到 BE 的节点状态：</p><p><img src="https://s2.loli.net/2024/09/16/YMCXQDoch3NlA1L.png"></p><p>如果出现以下结果代表连接成功，这样我们就可以创建数据库和表了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这部分内容（本地 FE 联结 docker 里的 FE）官方文档并没有提及，也是我踩了不少坑、同时还咨询了一些大佬才全部调试成功。</p><p>还有一点需要注意的事：如果我们网络环境发生了变化，比如从家里的 Wi-Fi 切换到了公司的，需要手动删除下 <code>FE/meta</code> 下的所有文件再次启动，BE 则是需要重启一下容器。</p><p>参考链接：</p><ul><li><a href="https://docs.starrocks.io/zh/docs/developers/development-environment/IDEA/">https://docs.starrocks.io/zh/docs/developers/development-environment/IDEA/</a></li><li><a href="https://docs.starrocks.io/zh/docs/deployment/deploy_manually/#%E7%AC%AC%E5%9B%9B%E6%AD%A5%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4">https://docs.starrocks.io/zh/docs/deployment/deploy_manually/#%E7%AC%AC%E5%9B%9B%E6%AD%A5%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近这段时间在处理一个 &lt;code&gt;StarRocks&lt;/code&gt; 的关于物化视图优化的一个问题，在此之前其实我也没有接触过 &lt;code&gt;StarRocks&lt;/code&gt; 这类主要处理数据分析的数据库，就更别提在这上面做优化了。&lt;/p&gt;
&lt;p&gt;在解决问题之前我先花了一两天时间熟悉了一下 &lt;code&gt;StarRocks&lt;/code&gt; 的一些概念和使用方法，然后又花了一些时间搭建环境然后复现了该问题。&lt;/p&gt;
&lt;p&gt;之后便开始阅读源码，大概知道了相关代码的执行流程，但即便是反复阅读了多次代码也没有找到具体出现问题的地方。&lt;/p&gt;
&lt;p&gt;所以便考虑在本地 Debug 源码，最终调试半天之后知道了问题所以，也做了相关修改，给社区提交了 PR，目前还在推进过程中。&lt;/p&gt;</summary>
    
    
    
    <category term="StarRocks" scheme="http://crossoverjie.top/categories/StarRocks/"/>
    
    
    <category term="StarRocks" scheme="http://crossoverjie.top/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>🤳如何为复杂的 Java 应用编写集成测试</title>
    <link href="http://crossoverjie.top/2024/09/29/ob/%F0%9F%A4%B3cim-support-integration-test/"/>
    <id>http://crossoverjie.top/2024/09/29/ob/%F0%9F%A4%B3cim-support-integration-test/</id>
    <published>2024-09-29T11:16:06.000Z</published>
    <updated>2024-09-29T01:37:17.532Z</updated>
    
    <content type="html"><![CDATA[<p>最近有时间又把以前开源的 <a href="https://github.com/crossoverJie/cim">IM 消息系统</a>捡起来继续开发了（确实这些年经常有朋友催更）。</p><blockquote><p>没错，确实是这些年，因为上次发版还是再 2019 年的八月份。</p></blockquote><p>这段时间比较重大的更新就是把<a href="https://github.com/crossoverJie/cim/pull/140">元数据中心</a>抽离出来了，以前是和 zookeeper 的代码强耦合在一起的，重构之后可以有多种实现了。</p><span id="more"></span><p>今后甚至可以提供一个 jar 包就可以把后端服务全部启动起来用于体验，此时就可以使用一个简单的基于内存的注册中心。</p><p>除此之外做的更多的就是新增了一个集成测试的模块，没有完善的集成测试功能在合并代码的时候都要小心翼翼，基本的功能需求都没法保证。</p><p>加上这几年我也接触了不少优秀的开源项目（比如 Pulsar、OpenTelemetry、HertzBeat 等），他们都有完整的代码合并流程；首先第一点就得把测试流水线跑通过。</p><p>这一点在 OpenTelemetry 社区更为严格：</p><p><img src="https://s2.loli.net/2024/09/04/wlaPtbJNux5vc9n.png"></p><blockquote><p>他们的构建测试流程非常多，包括单元测试、集成测试、代码风格、多版本兼容等。</p></blockquote><p>所以在结合了这些优秀项目的经验后我也为 cim 项目新增相关的模块 <a href="https://github.com/crossoverJie/cim/pull/144">cim-integration-test</a>，同时也在 github 上配置了相关的 action，最终的效果如下：</p><p><img src="https://s2.loli.net/2024/09/04/p9tLcvPTlMBIVq4.png"><br><img src="https://s2.loli.net/2024/09/04/Rxw5F8kNWT1pDO7.png"></p><p>在 <code>“Build with Maven”</code> 阶段触发单元测试和集成测试，最终会把测试结果上传到 Codecov，然后会在 PR 的评论区输出测试报告。<br><img src="https://s2.loli.net/2024/09/04/zmPHB16ryCtGoEM.png"></p><p>相关的 action 配置如下：</p><p><img src="https://s2.loli.net/2024/09/05/mteK1Yj43Z7gIrR.png"></p><p>就是配置了几个 Job，重点是这里的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -B package --file pom.xml</span><br></pre></td></tr></table></figure><p>它会编译并运行项目下面的所有 test 代码。</p><h1 id="cim-integration-test-模块"><a href="#cim-integration-test-模块" class="headerlink" title="cim-integration-test 模块"></a>cim-integration-test 模块</h1><p>为了方便进行集成测试，我新增了 <code>cim-integration-test</code> 这个模块，这里面没有任何源码，只有测试相关的代码。</p><p><img src="https://s2.loli.net/2024/09/05/RfK8FVrL916D7cI.png"></p><p>类的继承关系图如下：</p><p><img src="https://s2.loli.net/2024/09/05/75U9vbkPZOgqrRx.png"></p><p>因为我们做集成测试需要把 cim 所依赖的服务都启动起来，目前主要由以下几个服务：</p><ul><li>cim-server: cim 的服务端</li><li>cim-route: 路由服务</li><li>cim-client: 客户端</li></ul><p>而 route 服务是依赖于 server 服务，所以 route 继承了 server，client 则是需要 route 和 server 都启动，所以它需要继承 route。</p><h2 id="集成-test-container"><a href="#集成-test-container" class="headerlink" title="集成 test container"></a>集成 test container</h2><p>先来看看 server 的测试实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractServerBaseTest</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DockerImageName</span> <span class="variable">DEFAULT_IMAGE_NAME</span> <span class="operator">=</span> DockerImageName  </span><br><span class="line">            .parse(<span class="string">&quot;zookeeper&quot;</span>)  </span><br><span class="line">            .withTag(<span class="string">&quot;3.9.2&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Duration</span> <span class="variable">DEFAULT_STARTUP_TIMEOUT</span> <span class="operator">=</span> Duration.ofSeconds(<span class="number">60</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Container</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">ZooKeeperContainer</span>  </span><br><span class="line">            <span class="variable">zooKeeperContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZooKeeperContainer</span>(DEFAULT_IMAGE_NAME, DEFAULT_STARTUP_TIMEOUT);  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Getter</span>  </span><br><span class="line">    <span class="keyword">private</span> String zookeeperAddr;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> &#123;  </span><br><span class="line">        zooKeeperContainer.start();  </span><br><span class="line">        zookeeperAddr = String.format(<span class="string">&quot;%s:%d&quot;</span>, zooKeeperContainer.getHost(), zooKeeperContainer.getMappedPort(ZooKeeperContainer.DEFAULT_CLIENT_PORT));  </span><br><span class="line">        <span class="type">SpringApplication</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(CIMServerApplication.class);  </span><br><span class="line">        server.run(<span class="string">&quot;--app.zk.addr=&quot;</span> + zookeeperAddr);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>server</code> 是需要依赖 <code>zookeeper</code> 作为元数据中心，所以在启动之前需要先把 zookeeper 启动起来。</p><p>此时就需要使用 <a href="https://testcontainers.com/">testcontainer</a> 来做支持了，使用它可以在单测的过程中使用 docker 启动任意一个服务，这样在 CI 中做集成测试就很简单了。</p><p><img src="https://s2.loli.net/2024/09/06/X3vzp5qd7tbAIHB.png"></p><p>我们日常使用的大部分中间件都是支持的，使用起来也很简单。</p><p>先添加相关的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.postgresql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>42.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在选择我们需要依赖的服务，比如是 <code>PostgreSQL</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.testcontainers<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在测试代码中启动相关的服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomerServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> PostgreSQLContainer&lt;?&gt; postgres = <span class="keyword">new</span> <span class="title class_">PostgreSQLContainer</span>&lt;&gt;(</span><br><span class="line">    <span class="string">&quot;postgres:16-alpine&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  CustomerService customerService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@BeforeAll</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beforeAll</span><span class="params">()</span> &#123;</span><br><span class="line">    postgres.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AfterAll</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">afterAll</span><span class="params">()</span> &#123;</span><br><span class="line">    postgres.stop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@BeforeEach</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DBConnectionProvider</span> <span class="variable">connectionProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DBConnectionProvider</span>(</span><br><span class="line">      postgres.getJdbcUrl(),</span><br><span class="line">      postgres.getUsername(),</span><br><span class="line">      postgres.getPassword()</span><br><span class="line">    );</span><br><span class="line">    customerService = <span class="keyword">new</span> <span class="title class_">CustomerService</span>(connectionProvider);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通常情况下我们都是需要获取这些中间件的链接，比如 IP 端口啥的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.testcontainers.containers.ContainerState#getHost</span><br><span class="line">org.testcontainers.containers.ContainerState#getMappedPort</span><br></pre></td></tr></table></figure><p>通常是通过这两个函数来获取对应的 IP 和端口。</p><h1 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Container</span>  </span><br><span class="line"><span class="type">RedisContainer</span> <span class="variable">redis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisContainer</span>(DockerImageName.parse(<span class="string">&quot;redis:7.4.0&quot;</span>));  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startRoute</span><span class="params">()</span> &#123;  </span><br><span class="line">    redis.start();  </span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">route</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(RouteApplication.class);  </span><br><span class="line">    String[] args = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;  </span><br><span class="line">            <span class="string">&quot;--spring.data.redis.host=&quot;</span> + redis.getHost(),  </span><br><span class="line">            <span class="string">&quot;--spring.data.redis.port=&quot;</span> + redis.getMappedPort(<span class="number">6379</span>),  </span><br><span class="line">            <span class="string">&quot;--app.zk.addr=&quot;</span> + <span class="built_in">super</span>.getZookeeperAddr(),  </span><br><span class="line">    &#125;;    </span><br><span class="line">    route.setAdditionalProfiles(<span class="string">&quot;route&quot;</span>);  </span><br><span class="line">    route.run(args);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 route 来说不但需要 <code>zookeeper</code> 还需要 <code>Redis</code> 来存放用户的路由关系，此时就还需要运行一个 Redis 的容器，使用方法同理。</p><p>最后就需要以 <code>springboot</code> 的方式将这两个应用启动起来，我们直接创建一个 <code>SpringApplication</code> 对象，然后将需要修改的参数通过 <code>--varname=value</code> 的形式将数据传递进去。</p><p>还可以通过 <code>setAdditionalProfiles()</code> 函数指定当前应用运行的 profile，这样我们就可以在测试目录使用对应的配置文件了。</p><p><img src="https://s2.loli.net/2024/09/06/ySK2akYOIAPJqUH.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route.setAdditionalProfiles(<span class="string">&quot;route&quot;</span>);  </span><br></pre></td></tr></table></figure><p>比如我们这里设置为 route 就可以使用 <code>application-route.yaml</code> 作为 route 的配置文件启动，就不用每个参数都通过 <code>--</code> 传递了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String userName, <span class="type">int</span> port)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="built_in">super</span>.registerAccount(userName);  </span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(CIMClientApplication.class);  </span><br><span class="line">    client.setAdditionalProfiles(<span class="string">&quot;client&quot;</span>);  </span><br><span class="line">    String[] args = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;  </span><br><span class="line">            <span class="string">&quot;--server.port=&quot;</span> + port,  </span><br><span class="line">            <span class="string">&quot;--cim.user.id=&quot;</span> + userId,  </span><br><span class="line">            <span class="string">&quot;--cim.user.userName=&quot;</span> + userName  </span><br><span class="line">    &#125;;  </span><br><span class="line">    client.run(args);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">olu</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="built_in">super</span>.startServer();  </span><br><span class="line">    <span class="built_in">super</span>.startRoute();  </span><br><span class="line">    <span class="built_in">this</span>.login(<span class="string">&quot;crossoverJie&quot;</span>, <span class="number">8082</span>);  </span><br><span class="line">    <span class="built_in">this</span>.login(<span class="string">&quot;cj&quot;</span>, <span class="number">8182</span>);  </span><br><span class="line">    <span class="type">MsgHandle</span> <span class="variable">msgHandle</span> <span class="operator">=</span> SpringBeanFactory.getBean(MsgHandle.class);  </span><br><span class="line">    msgHandle.innerCommand(<span class="string">&quot;:olu&quot;</span>);  </span><br><span class="line">    msgHandle.sendMsg(<span class="string">&quot;hello&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们真正要测试的其实是客户端的功能，只要客户端功能正常，说明 server 和 route 也是正常的。</p><p>比如这里的 <code>olu(oline user)</code> 的测试流程是：</p><ul><li>启动 server 和 route</li><li>登录注册两个账号</li><li>查询出所有用户</li><li>发送消息</li></ul><p>最终的测试结果如下，符合预期。</p><p><img src="https://s2.loli.net/2024/09/06/uX7BrNwC8iOHqSQ.png" alt="image.png"></p><h1 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h1><h2 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h2><p>不知道大家注意到刚才测试代码存在的问题没有，主要就是没法断言。</p><p>因为客户端、route、server 都是以一个应用的维度去运行的，没法获取到一些关键指标。</p><p>比如输出在线用户，当客户端作为一个应用时，在线用户就是直接打印在了终端，而没有直接暴露一个接口返回在线数据；收发消息也是同理。</p><p>其实在应用内部这些都是有接口的，但是作为一个整体的 <code>springboot</code> 应用就没有提供这些能力了。</p><p>本质上的问题就是这里应该有一个 client-sdk 的模块，client 也是基于这个 sdk 实现的，这样就可以更好的测试相关的功能了。</p><p>之后就准备把 sdk 单独抽离一个模块，这样可以方便基于这个 sdk 实现不同的交互，甚至做一个 UI 界面都是可以的。</p><h2 id="编译失败"><a href="#编译失败" class="headerlink" title="编译失败"></a>编译失败</h2><p>还有一个问题就是我是直接将 <code>client/route/server</code> 的依赖集成到 <code>integration-test</code> 模块中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crossoverjie.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cim-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crossoverjie.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cim-forward-route<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crossoverjie.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cim-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 IDEA 里直接点击测试按钮是可以直接运行这里的测试用例的，但是想通过 <code>mvn test</code> 时就遇到了问题。</p><p><img src="https://s2.loli.net/2024/09/06/DFy6otpPvjar4JM.png" alt="image.png"></p><p>会在编译期间就是失败了，我排查了很久最终发现是因为这三个模块应用使用了springboot 的构建插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这几个模块最终会被打包成一个 springboot 的 jar 包，从而导致 integration-test 在编译时无法加载进来从而使用里面的类。</p><p>暂时没有找到好的解决办法，我就只有把这几个插件先去掉，需要打包时再手动指定插件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package spring-boot:repackage -DskipTests=true</span><br></pre></td></tr></table></figure><p>其实这里的本质问题也是没有分层的结果，最好还是依赖 <code>route</code> 和 <code>server</code> 的 SDK 进行测试。</p><p>现在因为有了测试的 CI 也欢迎大家来做贡献，可以看看这里的 <code>help want</code>，有一些简单易上手可以先搞起来。</p><p><img src="https://s2.loli.net/2024/09/06/kmgfrIxdhGXib9L.png"></p><p><a href="https://github.com/crossoverJie/cim/issues/135">https://github.com/crossoverJie/cim/issues/135</a></p><p>参考链接：</p><ul><li><a href="https://github.com/crossoverJie/cim/pull/140">https://github.com/crossoverJie/cim/pull/140</a></li><li><a href="https://github.com/crossoverJie/cim/pull/144">https://github.com/crossoverJie/cim/pull/144</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近有时间又把以前开源的 &lt;a href=&quot;https://github.com/crossoverJie/cim&quot;&gt;IM 消息系统&lt;/a&gt;捡起来继续开发了（确实这些年经常有朋友催更）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;没错，确实是这些年，因为上次发版还是再 2019 年的八月份。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这段时间比较重大的更新就是把&lt;a href=&quot;https://github.com/crossoverJie/cim/pull/140&quot;&gt;元数据中心&lt;/a&gt;抽离出来了，以前是和 zookeeper 的代码强耦合在一起的，重构之后可以有多种实现了。&lt;/p&gt;</summary>
    
    
    
    <category term="cim" scheme="http://crossoverjie.top/categories/cim/"/>
    
    <category term="test" scheme="http://crossoverjie.top/categories/cim/test/"/>
    
    
    <category term="cim" scheme="http://crossoverjie.top/tags/cim/"/>
    
  </entry>
  
  <entry>
    <title>OpenTelemetry 实战：从 0 到 1 编写一个 Instrumentation</title>
    <link href="http://crossoverjie.top/2024/09/26/ob/OpenTelemetry-create-instrumentation/"/>
    <id>http://crossoverjie.top/2024/09/26/ob/OpenTelemetry-create-instrumentation/</id>
    <published>2024-09-26T05:14:01.000Z</published>
    <updated>2024-09-26T13:39:32.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>因为公司内部在使用 <a href="https://github.com/PowerJob/PowerJob">PowerJob</a> 作为我们的分布式调度系统，同时又是使用 OpenTelemetry 作为可观测的底座，但目前 OpenTelemetry 还没有对 PowerJob 提供支持，目前社区只对同类型的 XXL-JOB 有支持。<br><img src="https://s2.loli.net/2024/08/26/qfdloarJ7iNzPXy.png"></p><p>恰好公司内部也有一些开发同学有类似的需求：<br><img src="https://s2.loli.net/2024/08/26/6aIFxlEyKt7OfsC.png"></p><p>于是在这个背景下我便开始着手开发 PowerJob 的 instrumentation，最终的效果如下：<br><img src="https://s2.loli.net/2024/08/26/r7xgSHKCftqvuXw.png"><br><img src="https://s2.loli.net/2024/08/26/KNnWPzm5rU9By3c.png"></p><span id="more"></span><p>从这个链路图中可以看到 grpc-consumer 提供了调度的入口函数，然后在内部发送了 Pulsar 消息，最终又调用了 grpc-provider 的 <code>gRPC</code> 接口。</p><p>这样就可以把整个链路串起来，同时还能查看 <code>PowerJob</code> 调度的 JobId、以及调用参数等数据，这样排查问题时也更加直观。</p><h1 id="开发-Instrumentation-的前置知识"><a href="#开发-Instrumentation-的前置知识" class="headerlink" title="开发 Instrumentation 的前置知识"></a>开发 Instrumentation 的前置知识</h1><p>在正式开发 Instrumentation 之前还需要了解一些前置知识点。</p><p><img src="https://s2.loli.net/2024/08/26/K43Ix8LCkQWAao5.png"><br><img src="https://s2.loli.net/2024/08/26/29DQxfMgFViuHYa.png"></p><p>这里我们以现有的  <code>gRPC</code> 和我编写的 PowerJob instrumentation 为例，可以看到 <code>gRPC</code> 的 instrumentation 中多了一个 library 的模块。</p><p>这里就引申出了两种埋点方式：</p><ul><li><strong>Library instrumentation</strong></li><li><strong>Java agent instrumentation</strong></li></ul><p>通常我们对一个框架或者一个库进行埋点时，首先需要找到它的埋点入口。</p><p>以 <em><code>grpc</code></em> 为例，我们首先需要看他是否有提供扩展的 API 可以供我们埋点，恰好 grpc 是有提供客户端和服务端的拦截器的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io.grpc.ClientInterceptor</span><br><span class="line">io.grpc.ServerInterceptor</span><br></pre></td></tr></table></figure><p>我们便可以在这些拦截中加入埋点逻辑，比如客户端的埋点代码如下 <code>io.opentelemetry.instrumentation.grpc.v1_6.TracingClientInterceptor</code> ：</p><p><img src="https://s2.loli.net/2024/08/26/FJgRjf1ACVlmG3D.png"></p><p>这部分代码便是写在 <code>grpc-1.6/library</code> 模块下的。</p><p>这样做有一个好处是：当我们的业务代码不想使用 <code>javaagent</code> 时还可以手动引入 <code>grpc-1.6/library</code> 包，然后使用 <code>TracingClientInterceptor</code> 拦截器也可以实现 trace 埋点的功能。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(project(<span class="string">&quot;:instrumentation:grpc-1.6:library&quot;</span>))</span><br></pre></td></tr></table></figure><p>之后 <code>javaagent</code> 这个模块也会引入 <code>library</code> ，然后直接使用它提供的 API 实现 agent 级别的埋点。</p><p>而如果一些库或者中间件并没有提供这种扩展 API 时，我们就只能使用 agent 的方式在字节码层面上进行埋点，这样就不会限制框架了，理论上任何 Java 代码都可以埋点。</p><p>所以总的来说一个库可能会没有 library instrumentation，但一定会有 agent instrumentation，我们可以根据当前框架的代码进行选择。</p><blockquote><p>而这里的 PowerJob 因为并没有提供扩展接口，所有只有 agent 的 instrumentation。</p></blockquote><h1 id="找到埋点入口"><a href="#找到埋点入口" class="headerlink" title="找到埋点入口"></a>找到埋点入口</h1><p>在开始编码之前我们需要对要埋点的库或者框架有一个清晰的理解，至少得知道它的核心逻辑在哪里。</p><p>以 PowerJob 的调度执行逻辑为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBasicProcessor</span> <span class="keyword">implements</span> <span class="title class_">BasicProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">process</span><span class="params">(TaskContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;======== BasicProcessor#process ========&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;TaskContext: &quot;</span> + JsonUtils.toJSONString(context) + <span class="string">&quot;;time = &quot;</span> + System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>, System.currentTimeMillis() + <span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这是一个最简单的调度执行器的实现逻辑。</p></blockquote><p>从这里看出：如果我们想要在执行器中埋点，那最核心的就是这里的 process 函数。</p><p>需要在 process 的执行前后拿到 context 数据，写入到 OpenTelemetry 中的 span 即可。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCustomizedHandler</span> <span class="keyword">extends</span> <span class="title class_">IJobHandler</span> &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">execute</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;&gt;(<span class="string">&quot;Hello World&quot;</span>);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 xxl-job 中，它的核心逻辑就是这里的 <code>execute</code> 函数。</p><h1 id="选择合适的版本"><a href="#选择合适的版本" class="headerlink" title="选择合适的版本"></a>选择合适的版本</h1><p>找到核心的埋点逻辑后还有一个很重要的工作要做：那就是<strong>选择你需要支持的版本</strong>。</p><p>选择版本的原因是有可能框架或库在版本迭代过程中核心 API 发生了变化，比如：</p><ul><li>函数签名发生了改变</li><li>包名也发生了改变</li></ul><p>以 xxl-job 为例，它在迭代过程中就发生了几次函数签名的修改，所以我们需要针对不同的版本做兼容处理：</p><p><img src="https://s2.loli.net/2024/08/26/yLhmXBKDzVaYjJ5.png"></p><p>而我这里选择支持 <code>PowerJob:4.0+</code> 的版本，因为社区在 4.0 之后做了大量重构，导致修改了包名，同时核心逻辑的函数签名也没发生过变化。</p><p><img src="https://s2.loli.net/2024/08/26/MuRmI9e28pghzNH.png"></p><blockquote><p>4.0 之前的版本我就没做兼容了，感兴趣的朋友可以自行实现。</p></blockquote><h1 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h1><p>首先第一步需要创建一个 <code>InstrumentationModule</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService(InstrumentationModule.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerJobInstrumentationModule</span> <span class="keyword">extends</span> <span class="title class_">InstrumentationModule</span> &#123;  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PowerJobInstrumentationModule</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;powerjob&quot;</span>, <span class="string">&quot;powerjob-4.0&quot;</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">public</span> List&lt;TypeInstrumentation&gt; <span class="title function_">typeInstrumentations</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> asList(<span class="keyword">new</span> <span class="title class_">BasicProcessorInstrumentation</span>());  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/26/AxGWtdflEI5NmKn.png"></p><blockquote><p>这里的 @AutoService 注解，会在代码编译之后生成一份 SPI 文件。</p></blockquote><p>之后便是实现这里最核心的 <code>BasicProcessorInstrumentation</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicProcessorInstrumentation</span> <span class="keyword">implements</span> <span class="title class_">TypeInstrumentation</span> &#123;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">public</span> ElementMatcher&lt;TypeDescription&gt; <span class="title function_">typeMatcher</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> implementsInterface(named(<span class="string">&quot;tech.powerjob.worker.core.processor.sdk.BasicProcessor&quot;</span>));  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(TypeTransformer transformer)</span> &#123;  </span><br><span class="line">    transformer.applyAdviceToMethod(  </span><br><span class="line">        named(<span class="string">&quot;process&quot;</span>).and(isPublic()).and(takesArguments(<span class="number">1</span>)),  </span><br><span class="line">        BasicProcessorInstrumentation.class.getName() + <span class="string">&quot;$ProcessAdvice&quot;</span>);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>从它的代码也可以看出，这里主要是指定我们需要对哪个方法的哪个函数进行埋点，然后埋点之后的处理逻辑是在哪个类(<code>ProcessAdvice</code>)中实现的。</p><p>之后便是 <code>ProcessAdvice</code> 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ProcessAdvice</span> &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span>  </span><br><span class="line">  <span class="meta">@Advice</span>.OnMethodEnter(suppress = Throwable.class)  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">onSchedule</span><span class="params">(  </span></span><br><span class="line"><span class="params">      <span class="meta">@Advice</span>.This BasicProcessor handler,  </span></span><br><span class="line"><span class="params">      <span class="meta">@Advice</span>.Argument(<span class="number">0</span>)</span> TaskContext taskContext,  </span><br><span class="line">      <span class="meta">@Advice</span>.Local(<span class="string">&quot;otelRequest&quot;</span>) PowerJobProcessRequest request,  </span><br><span class="line">      <span class="meta">@Advice</span>.Local(<span class="string">&quot;otelContext&quot;</span>) Context context,  </span><br><span class="line">      <span class="meta">@Advice</span>.Local(<span class="string">&quot;otelScope&quot;</span>) Scope scope) &#123;  </span><br><span class="line">    <span class="type">Context</span> <span class="variable">parentContext</span> <span class="operator">=</span> currentContext();  </span><br><span class="line">    request = PowerJobProcessRequest.createRequest(taskContext.getJobId(), handler, <span class="string">&quot;process&quot;</span>);  </span><br><span class="line">    request.setInstanceParams(taskContext.getInstanceParams());  </span><br><span class="line">    request.setJobParams(taskContext.getJobParams());  </span><br><span class="line">    context = helper().startSpan(parentContext, request);  </span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span>;  </span><br><span class="line">    &#125;    scope = context.makeCurrent();  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span>  </span><br><span class="line">  <span class="meta">@Advice</span>.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">stopSpan</span><span class="params">(  </span></span><br><span class="line"><span class="params">      <span class="meta">@Advice</span>.Return ProcessResult result,  </span></span><br><span class="line"><span class="params">      <span class="meta">@Advice</span>.Thrown Throwable throwable,  </span></span><br><span class="line"><span class="params">      <span class="meta">@Advice</span>.Local(<span class="string">&quot;otelRequest&quot;</span>)</span> PowerJobProcessRequest request,  </span><br><span class="line">      <span class="meta">@Advice</span>.Local(<span class="string">&quot;otelContext&quot;</span>) Context context,  </span><br><span class="line">      <span class="meta">@Advice</span>.Local(<span class="string">&quot;otelScope&quot;</span>) Scope scope) &#123;  </span><br><span class="line">    helper().stopSpan(result, request, throwable, scope, context);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最主要的就是使用 <code>OpenTelemetry</code> 提供 SDK 在入口处调用 <code>startSpan</code> 开始一个 span，然后在函数退出时调用 <code>stopSpan</code> 函数。</p><p>同时在执行前将一些请求信息存起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request = PowerJobProcessRequest.createRequest(taskContext.getJobId(), handler, <span class="string">&quot;process&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样可以根据这些请求信息生成 span 的 attribute，也就是 jobId, jobParam 等数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PowerJobExperimentalAttributeExtractor</span>  </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">AttributesExtractor</span>&lt;PowerJobProcessRequest, Void&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(  </span></span><br><span class="line"><span class="params">      AttributesBuilder attributes,  </span></span><br><span class="line"><span class="params">      Context parentContext,  </span></span><br><span class="line"><span class="params">      PowerJobProcessRequest powerJobProcessRequest)</span> &#123;  </span><br><span class="line">    attributes.put(POWERJOB_JOB_ID, powerJobProcessRequest.getJobId());  </span><br><span class="line">    attributes.put(POWERJOB_JOB_PARAM, powerJobProcessRequest.getJobParams());  </span><br><span class="line">    attributes.put(POWERJOB_JOB_INSTANCE_PARAM, powerJobProcessRequest.getInstanceParams());  </span><br><span class="line">    attributes.put(POWERJOB_JOB_INSTANCE_TRPE, powerJobProcessRequest.getJobType());  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>比如这里的 jobId&#x2F; jobParams 数据都是从刚才写入的 <code>PowerJobProcessRequest</code> 中获取的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CAPTURE_EXPERIMENTAL_SPAN_ATTRIBUTES) &#123;  </span><br><span class="line">  builder.addAttributesExtractor(  </span><br><span class="line">      AttributesExtractor.constant(AttributeKey.stringKey(<span class="string">&quot;job.system&quot;</span>), <span class="string">&quot;powerjob&quot;</span>));  </span><br><span class="line">  builder.addAttributesExtractor(<span class="keyword">new</span> <span class="title class_">PowerJobExperimentalAttributeExtractor</span>());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时只需要将刚才的 <code>PowerJobExperimentalAttributeExtractor</code> 在初始化 Instrumenter 时进行配置，这样 <code>OpenTelemetry</code> 的 SDK 就会自动回调这个接口，从而获取到 Span 的 attribute。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.bytebuddy.matcher.ElementMatchers.isPublic;  </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.bytebuddy.matcher.ElementMatchers.named;  </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.bytebuddy.matcher.ElementMatchers.takesArguments;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.asm.Advice;</span><br></pre></td></tr></table></figure><blockquote><p>其实这里大部分的 API 都是 bytebuddy 提供的。</p></blockquote><p>不知道大家是否觉得眼熟，Instrumentation 的写法其实和 spring 的拦截器有异曲同工之妙：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AroundExample</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around(&quot;execution(* com.xyz..service.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doBasicProfiling</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">// start stopwatch</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line"><span class="comment">// stop stopwatch</span></span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>毕竟 Spring 的拦截器也是使用 <code>bytebuddy</code> 实现的。</p></blockquote><h1 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h1><p>其实整个埋点过程非常简单，我们可以参考一些现有的 instrumentation 就可以很快实现逻辑；真正麻烦的时候在提交 PR 时需要通过 CI 校验。</p><p><img src="https://s2.loli.net/2024/08/26/ynupP2g5UMWGD3Z.png"></p><blockquote><p>我这里大概提交了 8次才把  CI 全部跑通过。</p></blockquote><p>这里面有各种小坑，只有自己提交过才能感受得到，下面我就一一列举一些大家可能会碰到的问题。</p><h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><p>首先第一个是创建模块的时候记得使用 kotlin 作为 gradle 的 DSL。</p><p><img src="https://s2.loli.net/2024/08/26/ku9e3vhG5mSYPc4.png"></p><p>IDEA 这里默认选择的是 Groovy 作为 DSL；我当时没有注意，后面在项目构建过程中一直在报错，仔细核对后发现是 DSL 的问题，修改之后就能编译通过了。</p><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><p>第二个是 module 的命名规则。</p><p><img src="https://s2.loli.net/2024/08/26/NZgl4GUR327IXW5.png"></p><p>我们需要遵守 v4_0_0 的规则，同时还得与 <code>PowerJobInstrumentationModule</code> 中定义的名称相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PowerJobInstrumentationModule</span><span class="params">()</span> &#123;  </span><br><span class="line">  <span class="built_in">super</span>(<span class="string">&quot;powerjob&quot;</span>, <span class="string">&quot;powerjob-4.0&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如如果我们的包名称是 <code>powerjob.v1.1.0</code> ，那这里的名称也得是 <code>&quot;powerjob-1.1.0&quot;</code></p><h1 id="Muzzle"><a href="#Muzzle" class="headerlink" title="Muzzle"></a>Muzzle</h1><p>第三个是 <code>Muzzle</code> 校验，<code>Muzzle</code> 是为了保证 <code>javaagent</code> 在业务代码中使用时和运行时的依赖不发生冲突而定义的一个校验规则。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">muzzle &#123;  </span><br><span class="line">  pass &#123;  </span><br><span class="line">    group.<span class="keyword">set</span>(<span class="string">&quot;tech.powerjob&quot;</span>)  </span><br><span class="line">    module.<span class="keyword">set</span>(<span class="string">&quot;powerjob-worker&quot;</span>)  </span><br><span class="line">    versions.<span class="keyword">set</span>(<span class="string">&quot;[4.0.0,)&quot;</span>)  </span><br><span class="line">    assertInverse.<span class="keyword">set</span>(<span class="literal">true</span>)  </span><br><span class="line">    extraDependency(<span class="string">&quot;tech.powerjob:powerjob-official-processors:1.1.0&quot;</span>)  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以我这个为例，它的含义是兼容 <code>tech.powerjob:powerjob-worker:4.0.0+</code>以上的版本。</p><p><code>assertInverse.set(true)</code>: 的作用是与之相反的版本，也就是 4.0.0 以下的版本都不做支持，如果在这些版本中运行 javaagent 是不会生效的。</p><blockquote><p>因为这些低版本的 powerjob 不兼容我们的埋点代码。</p></blockquote><p><code>extraDependency</code>：的作用是额外需要依赖的包，我这里额外使用了这个包里的一些类，如果不加上的话在做 <code>Muzzle</code> 校验时也会失败。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>最后便是单元测试了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBasicProcessor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">jobId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">jobParam</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  <span class="type">TaskContext</span> <span class="variable">taskContext</span> <span class="operator">=</span> genTaskContext(jobId, jobParam);</span><br><span class="line">  <span class="type">BasicProcessor</span> <span class="variable">testBasicProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestBasicProcessor</span>();</span><br><span class="line">  testBasicProcessor.process(taskContext);</span><br><span class="line">  testing.waitAndAssertTraces(</span><br><span class="line">      trace -&gt; &#123;</span><br><span class="line">        trace.hasSpansSatisfyingExactly(</span><br><span class="line">            span -&gt; &#123;</span><br><span class="line">              span.hasName(String.format(<span class="string">&quot;%s.process&quot;</span>, TestBasicProcessor.class.getSimpleName()));</span><br><span class="line">              span.hasKind(SpanKind.INTERNAL);</span><br><span class="line">              span.hasStatus(StatusData.unset());</span><br><span class="line">              span.hasAttributesSatisfying(</span><br><span class="line">                  attributeAssertions(</span><br><span class="line">                      TestBasicProcessor.class.getName(), jobId, jobParam, BASIC_PROCESSOR));</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;AttributeAssertion&gt; <span class="title function_">attributeAssertions</span><span class="params">(</span></span><br><span class="line"><span class="params">    String codeNamespace, <span class="type">long</span> jobId, String jobParam, String jobType)</span> &#123;</span><br><span class="line">  List&lt;AttributeAssertion&gt; attributeAssertions =</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">          asList(</span><br><span class="line">              equalTo(AttributeKey.stringKey(<span class="string">&quot;code.namespace&quot;</span>), codeNamespace),</span><br><span class="line">              equalTo(AttributeKey.stringKey(<span class="string">&quot;code.function&quot;</span>), <span class="string">&quot;process&quot;</span>),</span><br><span class="line">              equalTo(AttributeKey.stringKey(<span class="string">&quot;job.system&quot;</span>), <span class="string">&quot;powerjob&quot;</span>),</span><br><span class="line">              equalTo(AttributeKey.longKey(<span class="string">&quot;scheduling.powerjob.job.id&quot;</span>), jobId),</span><br><span class="line">              equalTo(AttributeKey.stringKey(<span class="string">&quot;scheduling.powerjob.job.type&quot;</span>), jobType)));</span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isNullOrEmpty(jobParam)) &#123;</span><br><span class="line">    attributeAssertions.add(</span><br><span class="line">        equalTo(AttributeKey.stringKey(<span class="string">&quot;scheduling.powerjob.job.param&quot;</span>), jobParam));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> attributeAssertions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的逻辑很简单，就是模拟一下核心逻辑的调用，然后断言是否存在我们预期的 Span，同时还得校验它的 attribute 是否符合我们的预期。</p><p>这个单测当时也调了许久，因为 <code>versions.set(&quot;[4.0.0,)&quot;)</code> 这个配置，有一个 CI workflow 会校验最新版本的 powerjob 是否也能正常运行。</p><p><img src="https://s2.loli.net/2024/08/26/vDSXq9tpGW7LAdb.png"></p><p>比如它会拉取目前最新的依赖进行测试：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(<span class="string">&quot;tech.powerjob:powerjob-worker:5.1.0&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果我们在单测中依赖了某些版本不存在的类，或者是函数签名发生过变化的函数用于测试，那这个 CI 就会执行失败。</p><p><img src="https://s2.loli.net/2024/08/26/HjIi5dBKlw9FxQy.png"></p><p>因为这里的构建日志非常多，同时还是并发测试的，如果我们想直接查看日志来定位问题会非常麻烦。</p><p>当然社区也考虑到了，可以在 <code>“Build scan”</code> 这个步骤中查看 <code>gradle</code> 的构建日志。</p><p><img src="https://s2.loli.net/2024/08/26/4xmRqFZi6NpkPML.png"></p><p><a href="https://scans.gradle.com/s/meywfxnvhhqtc/console-log/task/:instrumentation:powerjob-4.0:javaagent:compileTestJava?anchor=37&page=1">这里</a>会直接输出具体是哪里构建出了问题，通过它我们就能很快定位到原因。</p><p>我这里也是因为使用的某些帮助函数在最新的版本中发生了变化，为了测试通过，就不得不调整测试代码了。</p><p>如果你发现必须得依赖这些类或者函数来配合测试，那就只有考虑分为多个不同的版本进行测试，类似于 xxl-job：</p><p><img src="https://s2.loli.net/2024/08/26/yLhmXBKDzVaYjJ5.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是整个 instrumentation 的编写过程，其中核心的埋点过程并不复杂，只要我们对需要埋点的库或框架比较熟悉，都可以实现埋点。</p><p>真正麻烦的是需要通过社区复杂且严谨的 CI 流程，好在不管是哪一步的 CI 失败都可以查到具体的原因，有点类似于升级打怪，跟着错误信息走，最终都能验证通过。</p><p>参考链接：</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/CONTRIBUTING.md">https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/CONTRIBUTING.md</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/contributing/writing-instrumentation.md">https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/contributing/writing-instrumentation.md</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;因为公司内部在使用 &lt;a href=&quot;https://github.com/PowerJob/PowerJob&quot;&gt;PowerJob&lt;/a&gt; 作为我们的分布式调度系统，同时又是使用 OpenTelemetry 作为可观测的底座，但目前 OpenTelemetry 还没有对 PowerJob 提供支持，目前社区只对同类型的 XXL-JOB 有支持。&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/26/qfdloarJ7iNzPXy.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;恰好公司内部也有一些开发同学有类似的需求：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/26/6aIFxlEyKt7OfsC.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;于是在这个背景下我便开始着手开发 PowerJob 的 instrumentation，最终的效果如下：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/26/r7xgSHKCftqvuXw.png&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/26/KNnWPzm5rU9By3c.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>我用我的270篇文章做了一个数字 AI 替身</title>
    <link href="http://crossoverjie.top/2024/09/23/ob/Build-ower-AI-robot/"/>
    <id>http://crossoverjie.top/2024/09/23/ob/Build-ower-AI-robot/</id>
    <published>2024-09-23T13:54:01.000Z</published>
    <updated>2024-09-23T14:55:08.624Z</updated>
    
    <content type="html"><![CDATA[<p>23 年在 ChatGPT 刚出来的时候就在 <a href="https://www.v2ex.com/t/931521">V 站</a>上看到有一个看到有大佬用自己的微信聊天记录和博客文章生成了一个 AI 替身：</p><span id="more"></span><p><img src="https://s2.loli.net/2024/09/23/7xPdy54cIEm6pnR.png" alt="image.png"></p><p>当时就想着自己做一个，不过当时实现起来还比较复杂，直到如今 AI 已经越来越普及，想做一个自己的 AI 替身成本也非常低了。</p><p>于是就有了下图里的效果：<br><img src="https://s2.loli.net/2024/09/23/vmJhURZKsg96yaY.png"><br><img src="https://s2.loli.net/2024/09/23/tOzlgqvEMdm6LFo.png"></p><p>和自己的内容这么对话还挺有意思的，现在大家就可以直接在我公众号回复消息和”他“聊天。<br><img src="https://s2.loli.net/2024/09/23/7CiykumvIdALDZe.jpg"></p><blockquote><p>也可以通过小程序来使用：<br><img src="https://s2.loli.net/2024/09/23/9bdLkeP6XGorKAJ.png"></p></blockquote><h2 id="如何搭建"><a href="#如何搭建" class="headerlink" title="如何搭建"></a>如何搭建</h2><p>这里使用的数据源全都是我发布在公众号里的 260 篇文章。<br><img src="https://s2.loli.net/2024/09/23/NWae9gRJbPHO6M8.png"></p><p>能够直接获取到微信公众号的数据一定是腾讯自己的产品，其实这个产品叫做：<a href="https://yuanqi.tencent.com/">腾讯元器</a>，是腾讯大模型团队基于混元大模型推出的智能创作工具。</p><p>我们可以自定义 prompt、数据源、插件来实现自己的 AI 机器人，或者类似的交互产品。</p><p>直接创建一个智能体，然后编写对应的提示词即可，使用起来非常简单，官方也提供了一些 <code>prompt</code> 的示例：<br><img src="https://s2.loli.net/2024/09/23/sOhwLG28i9qTcBz.png" alt="image.png"></p><p>根据自己的需求来填写就可以了。</p><p>最主要的还是创建一个知识库，也就是你的数据源，好在这里直接整合了公众号的数据；<br><img src="https://s2.loli.net/2024/09/23/sXALurKi5BRET23.png"></p><p>直接授权就可以使用，同时还可以每天定时更新，非常方便。</p><p><img src="https://s2.loli.net/2024/09/23/TEJZ56MNCBV3aLh.png"></p><p>它会根据你的问题来判断是否用知识库的内容来回答，所以即便是问一些知识库不存在的内容也能拿到结果。</p><hr><p><img src="https://s2.loli.net/2024/09/23/AJbU4s1FXq7rSxO.png"><br>除此之外还可以上传你本地的文件，所以即便是你没有写公众号也可以上传自己整理的内容。</p><p>有兴趣的朋友可以试试尝尝鲜，后续我可以持续完善这个知识库，比如输入一些代码，之后再有向我咨询问题的朋友就可以先去问问”他“，</p><p>大家可以直接在公众号里和”对话“，说不定还有意外收获🐶。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;23 年在 ChatGPT 刚出来的时候就在 &lt;a href=&quot;https://www.v2ex.com/t/931521&quot;&gt;V 站&lt;/a&gt;上看到有一个看到有大佬用自己的微信聊天记录和博客文章生成了一个 AI 替身：&lt;/p&gt;</summary>
    
    
    
    <category term="AI" scheme="http://crossoverjie.top/categories/AI/"/>
    
    
    <category term="AI" scheme="http://crossoverjie.top/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>OpenTelemetry在企业内部应用所需要的技术栈</title>
    <link href="http://crossoverjie.top/2024/09/15/ob/OpenTelemetry-enterprise/"/>
    <id>http://crossoverjie.top/2024/09/15/ob/OpenTelemetry-enterprise/</id>
    <published>2024-09-15T07:54:11.000Z</published>
    <updated>2024-09-17T11:50:48.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可观测性概念"><a href="#可观测性概念" class="headerlink" title="可观测性概念"></a>可观测性概念</h1><p><img src="https://s2.loli.net/2024/08/08/Sdot1TJUfWgNZyu.png"><br>当一个软件或系统出于运行状态时，如果我们不对他加以观测，那它的运行状态对我们来说就是一个黑盒。</p><blockquote><p>如上图所示。</p></blockquote><p>我们只能通过业务的表象来判断它是否正常运行，无法在故障发生前进行预判，从而只能被动解决问题。</p><span id="more"></span><p>这类问题在微服务时代体现的更加明显，即便是业务已经出现问题，在没有可观测性系统的前提下想要定位问题更是难上加难。</p><p><img src="https://s2.loli.net/2024/08/08/eUFuwnPxf3cVrCL.png"><br>好在可观测性这个概念由来已久，已经由一些业界大佬抽象出几个基本概念：</p><ul><li>Logs：离散的日志信息</li><li>Metrics：聚合的指标</li><li>Trace：请求基本的链路追踪</li></ul><p>结合这三个指标，我们排查问题的流程一般如下：<br><img src="https://s2.loli.net/2024/08/08/Ixqt2WnBaz9jAQ4.png"></p><p>首先根据 metrics 来判断是否有异常，这点可以通过在 Prometheus 的 AlertManager 配置一些核心的告警指标。</p><p>比如当 CPU、内存使用率超过 80% 或者某个应用 Down 机后就发出告警。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">AllInstances</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">InstanceDown</span></span><br><span class="line">    <span class="comment"># Condition for alerting</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">up</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">1m</span></span><br><span class="line">    <span class="comment"># Annotation - additional informational labels to store more information</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">&#x27;Instance <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> down&#x27;</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">&#x27;<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> of job <span class="template-variable">&#123;&#123; $labels.job &#125;&#125;</span> has been down for more than 1 minute.&#x27;</span></span><br><span class="line">    <span class="comment"># Labels - additional labels to be attached to the alert</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">severity:</span> <span class="string">&#x27;critical&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/15/vh4t8nLk2NaXKu9.png"></p><p>这可以让我们尽早发现故障。</p><p>之后我们可以通过链路信息找到发生故障的节点。<br><img src="https://s2.loli.net/2024/08/15/A4C8xQour2WqpLO.png"></p><p>然后通过这里的 trace_id 在应用中找到具体的日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdc.trace_id:4a686dedcdf4e95b1a83b36e62563a96</span><br></pre></td></tr></table></figure><p>再根据日志中的上下文确定具体的异常原因。</p><p>这就是一个完整的排查问题的流程。</p><h1 id="OpenTelemetry-发展历史"><a href="#OpenTelemetry-发展历史" class="headerlink" title="OpenTelemetry 发展历史"></a>OpenTelemetry 发展历史</h1><p><img src="https://s2.loli.net/2024/08/08/p5WkVbSarUdIQwT.png" alt="image.png"><br><img src="https://s2.loli.net/2024/08/08/pvMEBObGgHcdRom.png"><br>在 OpenTelemetry 开始之前还是先回顾下可观测性的发展历史，其中有几个重要时间点：</p><ul><li>2010 年 Google 发布了 Dapper 论文，给业界带来了实现分布式追踪的理论支持，之后的许多分布式链路追踪实现都有它的影子</li><li>kubernetes 的发布奠定了后续云原生社区的基础</li><li>Jaeger 发布后成为了主流的链路存储系统</li><li>2019 年 OpenTracing 和 OpenCensus 合并为 OpenTelemetry</li><li>2021 年底 OpenTelemetry 发布第一个 GA release 版本</li></ul><h2 id="OpenTelemetry-是什么？"><a href="#OpenTelemetry-是什么？" class="headerlink" title="OpenTelemetry 是什么？"></a>OpenTelemetry 是什么？</h2><p><img src="https://s2.loli.net/2024/08/08/FDzVTSqruLxY8EX.png"></p><p>以前我们所接触到的类似于阿里的ARMS、美团的 CAT、Pinpoint 这类系统大多都有一个公司在背后进行驱动，与厂商绑定的非常紧密。</p><p>而 OpenTelemetry 则相反，它主要由社区驱动，参与的公司众多；同时它定义和提供了一套可观测性的标准（包括 API、SDK、规范等数据）。</p><p>使用它你可以灵活的选择和搭配任意的开源或商业产品来组成你的可观测性技术栈。</p><p><img src="https://s2.loli.net/2024/08/08/8RJ6H75hsICWgcD.png"></p><p>因为社区非常活跃，所以当前也几乎支持主流的开发语言。</p><h2 id="OpenTelemetry-的架构"><a href="#OpenTelemetry-的架构" class="headerlink" title="OpenTelemetry 的架构"></a>OpenTelemetry 的架构</h2><p><img src="https://s2.loli.net/2024/08/08/DMd1JfcCrO7Pm52.png"><br>OpenTelemetry 的架构主要分为三个部分：</p><ul><li>左侧的客户端 Agent，用于采集客户端的数据，通常就是我们的应用。</li><li>中间的是 Collector-Service，用于接受客户端的数据、内部处理、导出数据到各种存储</li><li>右侧的则是各种存储层，用于存储 Metrics、Logs、Traces 这些数据。</li></ul><p>我们基于官方推荐的技术架构选型了我们的技术栈：<br><img src="https://s2.loli.net/2024/08/09/XTzCOPBI6HYNta1.png" alt="image.png"><br>主要的区别就是使用 VictoriaMetrics 存储指标、StackRocks 存储 Trace，ElasticSearch 存储日志。</p><blockquote><p>只是目前我们的日志链路还没有完全切换到 OpenTelemetry 的链路，依然是在 Pod 中挂载了一个 sidecar，在这个 sidecar 中通过 filebeat 采集日志输出到 elasticsearch，后续也会逐步迁移。</p></blockquote><h2 id="核心项目"><a href="#核心项目" class="headerlink" title="核心项目"></a>核心项目</h2><h3 id="Collecotor"><a href="#Collecotor" class="headerlink" title="Collecotor"></a>Collecotor</h3><p>OpenTelemetry 社区的项目众多，其中大部分都是各种语言的 SDK 和 API，其中最为关键的应该就是 <a href="https://github.com/open-telemetry?q=opentelemetry-collector&type=all&language=&sort=">opentelemetry-collector</a></p><p>也就是刚才架构图中的中间部分，我们可以把它理解为类似 APIGateway 的角色，所有上报的 OTel 数据都得经过它的处理。</p><p><img src="https://s2.loli.net/2024/08/16/UfuI2wHtojqNS96.png"></p><p>主要由以下三部分组成：</p><ul><li>Receiver：用于接受客户端上报的数据</li><li>Process：内部的数据处理器</li><li>Exporter：将数据导出到不同的存储</li></ul><p>由于 OpenTelemetry 社区非常的活跃，所以这里支持的 <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver">Receiver</a>、<a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor">Processor</a> 和 <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter">Exporter</a> 类型非常多。</p><p><img src="https://s2.loli.net/2024/08/16/hTeuXskGMitYFCr.png"><br><img src="https://s2.loli.net/2024/08/16/EqPcjxK3Myr2LUC.png"><br><img src="https://s2.loli.net/2024/08/16/btqTu9gAl7heJra.png"></p><h3 id="其他核心项目"><a href="#其他核心项目" class="headerlink" title="其他核心项目"></a>其他核心项目</h3><p>我们以 Java 为例，对业务开发最重要的库就是 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/">opentelemetry-java-instrumentation</a></p><p>它可以打包一个 javaagent 给我们使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Java example</span></span><br><span class="line">java -javaagent:path/to/opentelemetry-javaagent.jar \  </span><br><span class="line">     -jar myapp.jar</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/16/YjzfWKFxPOqH5N6.png"></p><p>同时也支持了我们日常开发的绝大多数框架和中间件。</p><blockquote><p>支持的<a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md">库与框架</a>列表</p></blockquote><p>如果我们需要在应用中自定义打桩一些 Span、Metrics ，就还需要 <a href="https://github.com/open-telemetry/opentelemetry-java">opentelemetry-java</a> 这个项目。</p><p>它提供了具体的 SDK 可以方便的创建 Span 和 Metrics。</p><h1 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h1><p>之后来看看 <code>OpenTelemetry</code> 中具体的三个维度的概念和应用，首先是 Trace。</p><p><img src="https://s2.loli.net/2024/08/16/DAB7J5Rpx8OFs6L.png"></p><p>Trace 这个概念首先是 <a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf">Google Dapper</a> 论文中提到。</p><p>如上图所示：一次用户请求经历了 4 次 PRC 调用，分别也属于不同的系统。</p><p>每一次 RPC 调用就会产生一个 Span，将这些 span 串联起来就能形成一个调用链路。</p><p>这个 Span 主要包含以下信息：</p><ul><li>SpanName</li><li>ParentID</li><li>SpanID</li></ul><p>当我们将一个 Span 放大后会看到更加具体的信息：</p><ul><li>TraceId</li><li>SpanName</li><li>ParentID</li><li>SpanID</li><li>开始时间</li><li>结束时间<br>在 Dapper 论文中使用 Annotations 来存放 span 的属性，当然也可以自定义存放一些数据，比如图中的 <code>&quot;foo&quot;</code>。</li></ul><blockquote><p>在 OpenTelemetry 的 SDK 中称为  attribute，而在 Jaeger 的 UI 中又称为 tag，虽然叫法不同，但本质上是一个东西。</p></blockquote><p>最终就会形成上图中的树状结构的调用关系。</p><h2 id="Span-Kind"><a href="#Span-Kind" class="headerlink" title="Span Kind"></a>Span Kind</h2><p><img src="https://s2.loli.net/2024/08/16/XSAGlCY7F4f1pu5.png"><br>Span 中还有一个非常重要的概念，就是 Span Kind，也就是 Span 的类型，这个类型可以在排查问题时很容易得知该服务的类型。</p><p><img src="https://s2.loli.net/2024/08/16/cqezfgKSylJipRB.png"><br>按照官方的定义，Span 的类型分为：</p><ul><li>Client</li><li>Server</li><li>Internal</li><li>Producer</li><li>Consumer</li></ul><p>对于 RPC 的客户端和服务端自然就对应 Client 和 Server，而使用了消息队列的生产者消费者对应的就是 Produce 和 Consumer。</p><p>除此之外发生在应用内部的一些关键 Span 的类型就是 Internal，比如我们需要对业务的某些关键函数生成 Span 时，此时的 Span 类型通常也都是 Internal。</p><h2 id="上下文传递"><a href="#上下文传递" class="headerlink" title="上下文传递"></a>上下文传递</h2><p><img src="https://s2.loli.net/2024/08/09/v1mwnLEGNlKMbsq.png" alt="image.png"></p><p>在 Trace 中有一个关键技术问题需要被解决，也就是 Context 的上下文传递。</p><p>这个特别是在分布式系统中必须要解决，我们可以简单把它理解为如何把上游生成的 trace_id 传递到下游，这样才能在追踪的链路追踪系统中串联起来。</p><p>这个关键的技术名词在 OpenTelemetry 中称为：<a href="https://opentelemetry.io/docs/concepts/context-propagation/">Context Propagation</a>.</p><p>在分布式系统中，数据都是通过网络传递的，所以这里的本质问题依然是如何将上下文数据序列化之后，在下游可以反序列化到 <code>Context</code> 中。</p><p>聪明的小伙伴应该已经想到，我们可以将 trace_id 写入到跨进程调用的元数据中：</p><ul><li>http 可以存放在 http header 中</li><li>gRPC 可以存放在 meta 中</li><li>Pulsar 可以存放在消息的 properties 中</li><li>其余的中间件和框架也是同理</li></ul><p>然后在远程调用之前使用 <code>Inject</code> 将数据注入到这些元数据里，下游在接收到请求后再通过一个<code>Extract</code> 函数将元数据解析到 <code>Context</code> 中，这样 <code>trace_id</code> 就可以串联起来了。</p><p><img src="https://s2.loli.net/2024/08/08/wfKZNacuBJeMDO1.png" alt="image.png"></p><p><img src="https://s2.loli.net/2024/08/08/NHOYS9R1EIZrBhd.png" alt="image.png"></p><p>上图就是 Pulsar 和 gRPC 传递 trace_id 的过程，数据都是存放在元数据中的，这里的 <code>traceparent</code> 的值本质上就是 trace_id.</p><blockquote><p>具体的代码细节我会在下一篇继续分析。</p></blockquote><h1 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h1><p><img src="https://s2.loli.net/2024/08/09/HfFnubtAKvJ8hVy.png"></p><p>Metrics 相对于 Trace 来说则是要简单许多，OpenTelemetry 定义了许多命名规范和标准，这样大家在复用社区的一些监控模板时就要更加容易一些。</p><h2 id="Metrics-Exemplars"><a href="#Metrics-Exemplars" class="headerlink" title="Metrics Exemplars"></a>Metrics Exemplars</h2><p><img src="https://s2.loli.net/2024/08/09/tOlkQFZBH421wri.png"></p><p>Metrics 还提供了一个 Exemplar 的功能，它的主要作用是可以将 Metrics 和 Trace 关联在一起，这样在通过 Metrics 发现问题时，就可以直接跳转到链路系统。</p><p>因为 trace_id 可以通过 MDC 和日志关联，所以我们可以直接通过 Metrics 定位具体应用的日志，这样排查问题的效率将会非常高。</p><h1 id="扩展信息"><a href="#扩展信息" class="headerlink" title="扩展信息"></a>扩展信息</h1><p>以上就是关于 OpenTelemetry 的整体架构，下面来扩展一些内容。</p><h2 id="eBPF"><a href="#eBPF" class="headerlink" title="eBPF"></a>eBPF</h2><p><img src="https://s2.loli.net/2024/08/16/KPxF6kvcBCX4JER.png"><br>eBPF 是一个运行在 Linux 内核中的虚拟机，它提供一套特殊的指令集并允许我们在不重新编译内核、也不需要重启应用的情况下加载自定义的逻辑。</p><p>eBPF 技术具有三大特点：</p><ul><li>第一是<strong>无侵入</strong>，动态挂载，目标进程无需重启，而且因为是 Linux 内核提供功能，所以与语言无关，任何语言都可以支持。</li><li>第二是<strong>高性能</strong>，eBPF 字节码会被 JIT 成机器码后执行，效率非常高；</li><li>第三是更加<strong>安全</strong>，它会运行在自己的沙箱环境中，不会导致目标进程崩溃。</li></ul><p>eBPF 虽然有很多优点，同时也有一些局限性，比如我想监控业务代码中的某个具体指标（订单创建数量），此时它就难以实现了，所以还得看我们的应用场景。<br>更适合一些云平台，或者更偏向底层的应用。</p><p>目前 eBPF 的应用场景还不够广泛，但假以时日一定会成为可观测领域的未来之星。</p><h2 id="SigNoz"><a href="#SigNoz" class="headerlink" title="SigNoz"></a><a href="https://signoz.io/">SigNoz</a></h2><p>不知道大家发现没有，如果我们直接 OpenTelemetry 技术栈会需要为 Trace、Metrics、Logs 选择不同的存储，而且他们的查询界面也分散在不同的地方。</p><p>那有没有一个统一的平台可以给我们提供完整的可观测体验呢？</p><p>有这样的需求那就有对应的厂商实现了：<br><img src="https://s2.loli.net/2024/08/09/YZbT3CrlGwoceDE.png"></p><p><a href="https://signoz.io/">SigNoz</a> 就是这样的平台，它将 OpenTelemetry-collector 和数据存储全部整合在了一起，同时全面兼容  OpenTelemetry；可以说它就是基于 OpenTelemetry 构建的一个可观测产品。</p><p>对于一些中小厂商，不想单独维护这些组件时是非常有用的。</p><h2 id="OpenObserve"><a href="#OpenObserve" class="headerlink" title="OpenObserve"></a><a href="https://openobserve.ai/">OpenObserve</a></h2><p><img src="https://s2.loli.net/2024/08/16/CuzXT7ts6vWQAEO.png" alt="image.png"></p><p><a href="https://openobserve.ai/">OpenObserve</a>在 SigNoz 的基础上做的更加极致一些，它提供了一个统一的存储可以存放日志、Trace、Metrics 等数据。</p><p>这样我们就可以只使用一个数据库存放所有的数据，同时它也提供了完整的 UI，并且也全面兼容 OpenTelemetry。</p><p>这样对于运维来说会更加简单，只是可能带来的副作用就是需要与它完全绑定。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是 OpenTelemetry 在企业的应用，大家可以根据自己的情况选择自建 OTel 的技术栈，还是选择 SigNoz 和 OpenObserve 这类的标准化产品。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;可观测性概念&quot;&gt;&lt;a href=&quot;#可观测性概念&quot; class=&quot;headerlink&quot; title=&quot;可观测性概念&quot;&gt;&lt;/a&gt;可观测性概念&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/08/Sdot1TJUfWgNZyu.png&quot;&gt;&lt;br&gt;当一个软件或系统出于运行状态时，如果我们不对他加以观测，那它的运行状态对我们来说就是一个黑盒。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如上图所示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们只能通过业务的表象来判断它是否正常运行，无法在故障发生前进行预判，从而只能被动解决问题。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>日志与追踪的完美融合：OpenTelemetry MDC 实践指南</title>
    <link href="http://crossoverjie.top/2024/09/05/ob/OpenTelemetry-client-log-mdc/"/>
    <id>http://crossoverjie.top/2024/09/05/ob/OpenTelemetry-client-log-mdc/</id>
    <published>2024-09-05T06:50:33.000Z</published>
    <updated>2024-09-10T13:41:32.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前面两篇实战文章中：</p><ul><li><a href="https://juejin.cn/post/7391744486979076146">OpenTelemetry 实战：从零实现分布式链路追踪</a></li><li><a href="https://juejin.cn/post/7394395254566846475">OpenTelemetry 实战：从零实现应用指标监控</a></li></ul><p>覆盖了可观测中的指标追踪和 <code>metrics</code> 监控，下面理应开始第三部分：<strong>日志</strong>。</p><p>但在开始日志之前还是要先将链路追踪和日志结合起来看看应用实际使用的实践。</p><p>通常我们排查问题的方式是先查询异常日志，判断是否是当前系统的问题。</p><p>如果不是，则在日志中捞出 <code>trace_id</code> 再到链路查询系统中查询链路，看看具体是哪个系统的问题，然后再做具体的排查。</p><p>类似于这样：<br><img src="https://s2.loli.net/2024/08/05/mP97tShHKrGXge2.png"><br>日志中会打印 <code>trace_id</code> 和 <code>span_id</code>。</p><blockquote><p>如果日志系统做的比较完善的话，还可以直接点击 <code>trace_id</code> 跳转到链路系统里直接查询链路信息。</p></blockquote><span id="more"></span><h1 id="MDC"><a href="#MDC" class="headerlink" title="MDC"></a>MDC</h1><p>这里的日志里关联 trace 信息的做法有个专有名词：MDC:(Mapped Diagnostic Context)。</p><p>简单来说就是用于排查问题的上下文信息，通常是由键值对组成，类似于这样的数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2024-08-05 17:27:31.097&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;level&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;INFO&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;thread&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;http-nio-9191-exec-1&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;mdc&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span>  </span><br><span class="line">    <span class="attr">&quot;trace_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;26242f945af80b044a60226af00211fb&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="attr">&quot;trace_flags&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="attr">&quot;span_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;3a7842b3e28ed5c8&quot;</span>  </span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;logger&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;com.example.demo.DemoApplication&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;message&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;request: name: \&quot;1232\&quot;\n&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;context&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;default&quot;</span>  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在 Java 中的 Log4j 和 Logback 都有提供对应的实现。</p><p>如果我们使用了 OpenTelemetry 提供的 <code>javaagent</code> 再配合 <code>logback</code> 或者 <code>Log4j</code> 时就会自动具备打印 <code>MDC</code> 的能力：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:/Users/chenjie/Downloads/blog-img/demo/opentelemetry-javaagent-2.4.0-SNAPSHOT.jar xx.jar</span><br></pre></td></tr></table></figure><p>比如我们只需要这样配置这样一个JSON 输出的 logback 即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;PROJECT_LOG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;PATH&#125;/demo.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;PATH&#125;/demo_%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.contrib.json.classic.JsonLayout&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">jsonFormatter</span>  </span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.contrib.jackson.JacksonJsonFormatter&quot;</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">prettyPrint</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prettyPrint</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">jsonFormatter</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">timestampFormat</span>&gt;</span>yyyy-MM-dd&#x27; &#x27;HH:mm:ss.SSS<span class="tag">&lt;/<span class="name">timestampFormat</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">layout</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;PROJECT_LOG&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/05/ba195iyS2hgnOVx.png"></p><p>就会在日志文件中输出 <code>JSON</code> 格式的日志，并且带上 <code>MDC</code> 的信息。</p><h1 id="自动-MDC-的原理"><a href="#自动-MDC-的原理" class="headerlink" title="自动 MDC 的原理"></a>自动 MDC 的原理</h1><p>我也比较好奇 OpenTelemetry 是如何自动写入 MDC 信息的，这里以 <code>logback</code> 为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> ElementMatcher&lt;TypeDescription&gt; <span class="title function_">typeMatcher</span><span class="params">()</span> &#123;  </span><br><span class="line">  <span class="keyword">return</span> implementsInterface(named(<span class="string">&quot;ch.qos.logback.classic.spi.ILoggingEvent&quot;</span>));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(TypeTransformer transformer)</span> &#123;  </span><br><span class="line">  transformer.applyAdviceToMethod(  </span><br><span class="line">      isMethod()  </span><br><span class="line">          .and(isPublic())  </span><br><span class="line">          .and(namedOneOf(<span class="string">&quot;getMDCPropertyMap&quot;</span>, <span class="string">&quot;getMdc&quot;</span>))  </span><br><span class="line">          .and(takesArguments(<span class="number">0</span>)),  </span><br><span class="line">      LoggingEventInstrumentation.class.getName() + <span class="string">&quot;$GetMdcAdvice&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会在调用 <code>ch.qos.logback.classic.spi.ILoggingEvent.getMDCPropertyMap()/getMdc()</code> 这两个函数中进行埋点。</p><blockquote><p>这些逻辑都是写在 javaagent 中的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">getMDCPropertyMap</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="comment">// populate mdcPropertyMap if null  </span></span><br><span class="line">    <span class="keyword">if</span> (mdcPropertyMap == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="type">MDCAdapter</span> <span class="variable">mdc</span> <span class="operator">=</span> MDC.getMDCAdapter();  </span><br><span class="line">        <span class="keyword">if</span> (mdc <span class="keyword">instanceof</span> LogbackMDCAdapter)  </span><br><span class="line">            mdcPropertyMap = ((LogbackMDCAdapter) mdc).getPropertyMap();  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            mdcPropertyMap = mdc.getCopyOfContextMap();  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// mdcPropertyMap still null, use emptyMap()  </span></span><br><span class="line">    <span class="keyword">if</span> (mdcPropertyMap == <span class="literal">null</span>)  </span><br><span class="line">        mdcPropertyMap = Collections.emptyMap();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> mdcPropertyMap;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数其实默认情况下会返回一个 logback 内置 MDC 的 map 数据（这里的数据我们可以自定义配置）。</p><p>而这里要做的就是将 trace 的上下文信息写入这个 mdcPropertyMap 中。</p><p>以下是 OpenTelemetry agent 中的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; spanContextData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line"><span class="type">SpanContext</span> <span class="variable">spanContext</span> <span class="operator">=</span> Java8BytecodeBridge.spanFromContext(context).getSpanContext();  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (spanContext.isValid()) &#123;  </span><br><span class="line">  spanContextData.put(traceIdKey(), spanContext.getTraceId());  </span><br><span class="line">  spanContextData.put(spanIdKey(), spanContext.getSpanId());  </span><br><span class="line">  spanContextData.put(traceFlagsKey(), spanContext.getTraceFlags().asHex());  </span><br><span class="line">&#125;  </span><br><span class="line">spanContextData.putAll(ConfiguredResourceAttributesHolder.getResourceAttributes());  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (LogbackSingletons.addBaggage()) &#123;  </span><br><span class="line">  <span class="type">Baggage</span> <span class="variable">baggage</span> <span class="operator">=</span> Java8BytecodeBridge.baggageFromContext(context);  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// using a lambda here does not play nicely with instrumentation bytecode process  </span></span><br><span class="line">  <span class="comment">// (Java 6 related errors are observed) so relying on for loop instead  for (Map.Entry&lt;String, BaggageEntry&gt; entry : baggage.asMap().entrySet()) &#123;  </span></span><br><span class="line">    spanContextData.put(  </span><br><span class="line">        <span class="comment">// prefix all baggage values to avoid clashes with existing context  </span></span><br><span class="line">        <span class="string">&quot;baggage.&quot;</span> + entry.getKey(), entry.getValue().getValue());  </span><br><span class="line">  &#125;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (contextData == <span class="literal">null</span>) &#123;  </span><br><span class="line">  contextData = spanContextData;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">  contextData = <span class="keyword">new</span> <span class="title class_">UnionMap</span>&lt;&gt;(contextData, spanContextData);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是核心的写入逻辑，从这个代码中也可以看出直接从上线文中获取的 span 的 context，而我们所需要的 <code>trace_id/span_id</code>  都是存放在 context 中的，只需要 get 出来然后写入进 map 中即可。</p><p>从源码里还得知，只要我们开启 <code>-Dotel.instrumentation.logback-mdc.add-baggage=true</code> 配置还可以将 baggage 中的数据也写入到 MDC 中。</p><p>而得易于 OpenTelemetry 中的 trace 是可以跨线程传输的，所以即便是我们在多线程里打印日志时 MDC 数据依然可以准确无误的传递。</p><h2 id="MDC-的原理"><a href="#MDC-的原理" class="headerlink" title="MDC 的原理"></a>MDC 的原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MDC_ATTR_NAME</span> <span class="operator">=</span> <span class="string">&quot;mdc&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/05/e7PIASyowDGO1sQ.png"></p><p>在 <code>logback</code> 的实现中是会调用刚才的 <code>getMDCPropertyMap()</code> 然后写入到一个 key 为 <code>mdc</code> 的 <code>map</code> 里，最终可以写入到文件或者控制台。</p><p>这样整个原理就可以串起来了。</p><h2 id="自定义日志-数据"><a href="#自定义日志-数据" class="headerlink" title="自定义日志 数据"></a>自定义日志 数据</h2><p>提到可以自定义 MDC 数据其实也是有使用场景的，比如我们的业务系统经常有类似的需求，需要在日志中打印一些常用业务数据：</p><ul><li>userId、userName</li><li>客户端 IP等信息时</li></ul><p>此时我们就可以创建一个 <code>Layout</code> 类来继承 <code>ch.qos.logback.contrib.json.classic.JsonLayout</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomJsonLayout</span> <span class="keyword">extends</span> <span class="title class_">JsonLayout</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomJsonLayout</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addCustomDataToJsonMap</span><span class="params">(Map&lt;String, Object&gt; map, ILoggingEvent event)</span> &#123;</span><br><span class="line">        map.put(<span class="string">&quot;user_name&quot;</span>, context.getProperty(<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">        map.put(<span class="string">&quot;user_id&quot;</span>, context.getProperty(<span class="string">&quot;userId&quot;</span>));</span><br><span class="line">        map.put(<span class="string">&quot;trace_id&quot;</span>, TraceContext.traceId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomJsonLayoutEncoder</span> <span class="keyword">extends</span> <span class="title class_">LayoutWrappingEncoder</span>&lt;ILoggingEvent&gt; &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomJsonLayoutEncoder</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">CustomJsonLayout</span> <span class="variable">jsonLayout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomJsonLayout</span>();  </span><br><span class="line">        jsonLayout.setContext(<span class="built_in">this</span>.context);  </span><br><span class="line">        jsonLayout.setIncludeContextName(<span class="literal">false</span>);  </span><br><span class="line">        jsonLayout.setAppendLineSeparator(<span class="literal">true</span>);  </span><br><span class="line">        jsonLayout.setJsonFormatter(<span class="keyword">new</span> <span class="title class_">JacksonJsonFormatter</span>());  </span><br><span class="line">        jsonLayout.start();  </span><br><span class="line">        <span class="built_in">super</span>.setCharset(StandardCharsets.UTF_8);  </span><br><span class="line">        <span class="built_in">super</span>.setLayout(jsonLayout);  </span><br><span class="line">        <span class="built_in">super</span>.start();  </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的 trace_id 是之前使用 skywalking 的时候由 skywalking 提供的函数：org.apache.skywalking.apm.toolkit.trace.TraceContext#traceId</p></blockquote><p>接着只需要在 <code>logback.xml</code> 中配置这个 <code>CustomJsonLayoutEncoder</code> 就可以按照我们自定义的数据输出日志了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;PROJECT_LOG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;PATH&#125;/app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;PATH&#125;/app_%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;xx.CustomJsonLayoutEncoder&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;PROJECT_LOG&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然这个功能也可以使用日志切面来打印，但还是没有直接在日志中输出更加方便，它可以直接和我们的日志关联在一起，只是多加了这几个字段而已。</p><h2 id="Spring-Boot-使用"><a href="#Spring-Boot-使用" class="headerlink" title="Spring Boot 使用"></a>Spring Boot 使用</h2><p><code>OpenTelemetry</code> 有给 springboot 应用提供一个 <code>spring-boot-starter</code> 包，用于在不使用  <code>javaagent</code> 的情况下也可以自动埋点。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.opentelemetry.instrumentation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opentelemetry-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>OPENTELEMETRY_VERSION<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但在早<a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/discussions/7653">期的版本</a>中还不支持直接打印 MDC 日志：<br><img src="https://s2.loli.net/2024/08/05/aunR8ApiMEoeJ1O.png" alt="image.png"></p><blockquote><p>最新的版本已经支持</p></blockquote><p>即便已经支持默认输出 MDC 后，我们依然可以自定义的内容，比如我们想修改一下 key 的名称，由 <code>trace_id</code> 修改为 <code>otel_trace_id</code> 等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;OTEL&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.opentelemetry.instrumentation.logback.mdc.v1_0.OpenTelemetryAppender&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">traceIdKey</span>&gt;</span>otel_trace_id<span class="tag">&lt;/<span class="name">traceIdKey</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spanIdKey</span>&gt;</span>otel_span_id<span class="tag">&lt;/<span class="name">spanIdKey</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">traceFlagsKey</span>&gt;</span>otel_trace_flags<span class="tag">&lt;/<span class="name">traceFlagsKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还是和之前类似，修改下 logback.xml 即可。</p><p><img src="https://s2.loli.net/2024/08/05/Y3zvfm6rUbxwtOK.png" alt="image.png"><br>他的实现逻辑其实和之前的 auto instrument 中的类似，只不过使用的 API 不同而已。</p><p>auto instrument 是直接拦截代码逻辑修改 map 的返回值，而 <code>OpenTelemetryAppender</code> 是继承了 <code>ch.qos.logback.core.UnsynchronizedAppenderBase</code> 接口，从而获得了重写 <code>MDC</code> 的能力，但本质上都是一样的，没有太大区别。</p><p>不过使用它的前提是我们需要引入以下一个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.opentelemetry.instrumentation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opentelemetry-logback-mdc-1.0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>OPENTELEMETRY_VERSION<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果不想修改 logback.yaml ，对于 <code>springboot</code> 来说还有更简单的方案，我们只需要使用以下配置即可自定义 MDC 数据：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.pattern.level</span> = <span class="string">trace_id=%mdc&#123;trace_id&#125; span_id=%mdc&#123;span_id&#125; trace_flags=%mdc&#123;trace_flags&#125; %5p</span></span><br></pre></td></tr></table></figure><p>这里的 key 也可以自定义，只要占位符没有取错即可。</p><blockquote><p>使用这个的前提是需要加载  javaagent，因为这里的数据是 javaagent 里写进去的。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于 <code>MDC</code> 在 <code>OpenTelemetry</code> 中的使用，从使用和源码逻辑上都分析了一遍，希望对 <code>MDC</code> 和 <code>OpenTelemetry</code> 的理解更加深刻一些。</p><p>关于 MDC 相关的概念与使用还是很有用的，是日常排查问题必不可少的一个工具。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在前面两篇实战文章中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7391744486979076146&quot;&gt;OpenTelemetry 实战：从零实现分布式链路追踪&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7394395254566846475&quot;&gt;OpenTelemetry 实战：从零实现应用指标监控&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;覆盖了可观测中的指标追踪和 &lt;code&gt;metrics&lt;/code&gt; 监控，下面理应开始第三部分：&lt;strong&gt;日志&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但在开始日志之前还是要先将链路追踪和日志结合起来看看应用实际使用的实践。&lt;/p&gt;
&lt;p&gt;通常我们排查问题的方式是先查询异常日志，判断是否是当前系统的问题。&lt;/p&gt;
&lt;p&gt;如果不是，则在日志中捞出 &lt;code&gt;trace_id&lt;/code&gt; 再到链路查询系统中查询链路，看看具体是哪个系统的问题，然后再做具体的排查。&lt;/p&gt;
&lt;p&gt;类似于这样：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/05/mP97tShHKrGXge2.png&quot;&gt;&lt;br&gt;日志中会打印 &lt;code&gt;trace_id&lt;/code&gt; 和 &lt;code&gt;span_id&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果日志系统做的比较完善的话，还可以直接点击 &lt;code&gt;trace_id&lt;/code&gt; 跳转到链路系统里直接查询链路信息。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>OpenTelemetry 实战：gRPC 监控的实现原理</title>
    <link href="http://crossoverjie.top/2024/08/29/ob/OpenTelemetry-grpc-principle/"/>
    <id>http://crossoverjie.top/2024/08/29/ob/OpenTelemetry-grpc-principle/</id>
    <published>2024-08-29T06:50:33.000Z</published>
    <updated>2024-09-03T15:08:51.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://s2.loli.net/2024/07/29/uUTYr8lziEABk4d.png"></p><p>最近在给 <code>opentelemetry-java-instrumentation</code> 提交了一个 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/11833">PR</a>，是关于给 gRPC 新增四个 metrics：</p><ul><li><code>rpc.client.request.size</code>: 客户端请求包大小</li><li><code>rpc.client.response.size</code>：客户端收到的响应包大小</li><li><code>rpc.server.request.size</code>：服务端收到的请求包大小</li><li><code>rpc.server.response.size</code>：服务端响应的请求包大小</li></ul><p>这个 PR 的主要目的就是能够在指标监控中拿到 <code>RPC</code> 请求的包大小，而这里的关键就是如何才能拿到这些包的大小。</p><span id="more"></span><p>首先支持的是 <code>gRPC</code>（目前在云原生领域使用的最多），其余的 RPC 理论上也是可以支持的：<br><img src="https://s2.loli.net/2024/07/29/efGYRktoK8IESzP.png"></p><p>在实现的过程中我也比较好奇 <code>OpenTelemetry</code> 框架是如何给 <code>gRPC</code> 请求创建 <code>span</code> 调用链的，如下图所示：<br><img src="https://s2.loli.net/2024/07/15/skNmSDJaPfHh3GB.png" alt="image.png"><br><img src="https://s2.loli.net/2024/07/15/xoG2finOmFlDReE.png" alt="image.png"></p><blockquote><p>这是一个 gRPC 远程调用，java-demo 是 gRPC 的客户端，k8s-combat 是 gRPC 的服务端</p></blockquote><p>在开始之前我们可以根据 <code>OpenTelemetry</code> 的运行原理大概猜测下它的实现过程。</p><p>首先我们应用可以创建这些链路信息的前提是：使用了 <code>OpenTelemetry</code> 提供的 <code>javaagent</code>，这个 agent 的原理是在运行时使用了 <a href="https://github.com/raphw/byte-buddy">byte-buddy</a> 增强了我们应用的字节码，在这些字节码中代理业务逻辑，从而可以在不影响业务的前提下增强我们的代码（只要就是创建 span、metrics 等数据）</p><blockquote><p>Spring 的一些代理逻辑也是这样实现的</p></blockquote><h1 id="gRPC-增强原理"><a href="#gRPC-增强原理" class="headerlink" title="gRPC 增强原理"></a>gRPC 增强原理</h1><p>而在工程实现上，我们最好是不能对业务代码进行增强，而是要找到这些框架提供的扩展接口。</p><p>拿 <code>gRPC</code> 来说，我们可以使用它所提供的 <code>io.grpc.ClientInterceptor</code> 和 <code>io.grpc.ServerInterceptor</code> 接口来增强代码。</p><p>打开 <code>io.opentelemetry.instrumentation.grpc.v1_6.TracingClientInterceptor</code> 类我们可以看到它就是实现了 <code>io.grpc.ClientInterceptor</code>：<br><img src="https://s2.loli.net/2024/07/29/dVaESmoXIwJC6Li.png"></p><p>而其中最关键的就是要实现 <code>io.grpc.ClientInterceptor#interceptCall</code> 函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> &lt;REQUEST, RESPONSE&gt; ClientCall&lt;REQUEST, RESPONSE&gt; <span class="title function_">interceptCall</span><span class="params">(  </span></span><br><span class="line"><span class="params">    MethodDescriptor&lt;REQUEST, RESPONSE&gt; method, CallOptions callOptions, Channel next)</span> &#123;  </span><br><span class="line">  <span class="type">GrpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GrpcRequest</span>(method, <span class="literal">null</span>, <span class="literal">null</span>, next.authority());  </span><br><span class="line">  <span class="type">Context</span> <span class="variable">parentContext</span> <span class="operator">=</span> Context.current();  </span><br><span class="line">  <span class="keyword">if</span> (!instrumenter.shouldStart(parentContext, request)) &#123;  </span><br><span class="line">    <span class="keyword">return</span> next.newCall(method, callOptions);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> instrumenter.start(parentContext, request);  </span><br><span class="line">  ClientCall&lt;REQUEST, RESPONSE&gt; result;  </span><br><span class="line">  <span class="keyword">try</span> (<span class="type">Scope</span> <span class="variable">ignored</span> <span class="operator">=</span> context.makeCurrent()) &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">      <span class="comment">// call other interceptors  </span></span><br><span class="line">      result = next.newCall(method, callOptions);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;  </span><br><span class="line">      instrumenter.end(context, request, Status.UNKNOWN, e);  </span><br><span class="line">      <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125;  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TracingClientCall</span>&lt;&gt;(result, parentContext, context, request);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口是 <code>gRPC</code> 提供的拦截器接口，对于 <code>gRPC</code> 客户端来说就是在发起真正的网络调用前后会执行的方法。</p><p>所以在这个接口中我们就可以实现创建 span 获取包大小等逻辑。</p><h2 id="使用-byte-buddy-增强代码"><a href="#使用-byte-buddy-增强代码" class="headerlink" title="使用 byte-buddy 增强代码"></a>使用 byte-buddy 增强代码</h2><p>不过有一个问题是我们实现的 <code>io.grpc.ClientInterceptor</code> 类需要加入到拦截器中才可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">managedChannel</span> <span class="operator">=</span> ManagedChannelBuilder.forAddress(host, port) .intercept(<span class="keyword">new</span> <span class="title class_">TracingClientInterceptor</span>()) <span class="comment">// 加入拦截器</span></span><br><span class="line">.usePlaintext()</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure><p>但在 <code>javaagent</code> 中是没法给业务代码中加上这样的代码的。</p><p>此时就需要 <a href="https://bytebuddy.net/#/">byte-buddy</a> 登场了，它可以动态修改字节码从而实现类似于修改源码的效果。</p><p>在 <code>io.opentelemetry.javaagent.instrumentation.grpc.v1_6.GrpcClientBuilderBuildInstr umentation</code>  类里可以看到 <code>OpenTelemetry</code> 是如何使用 <code>byte-buddy</code> 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ElementMatcher&lt;TypeDescription&gt; <span class="title function_">typeMatcher</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> extendsClass(named(<span class="string">&quot;io.grpc.ManagedChannelBuilder&quot;</span>))</span><br><span class="line">      .and(declaresField(named(<span class="string">&quot;interceptors&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(TypeTransformer transformer)</span> &#123;</span><br><span class="line">  transformer.applyAdviceToMethod(</span><br><span class="line">      isMethod().and(named(<span class="string">&quot;build&quot;</span>)),</span><br><span class="line">      GrpcClientBuilderBuildInstrumentation.class.getName() + <span class="string">&quot;$AddInterceptorAdvice&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AddInterceptorAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Advice</span>.OnMethodEnter(suppress = Throwable.class)</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addInterceptor</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="meta">@Advice</span>.This ManagedChannelBuilder&lt;?&gt; builder,</span></span><br><span class="line"><span class="params">      <span class="meta">@Advice</span>.FieldValue(<span class="string">&quot;interceptors&quot;</span>)</span> List&lt;ClientInterceptor&gt; interceptors) &#123;</span><br><span class="line">    VirtualField&lt;ManagedChannelBuilder&lt;?&gt;, Boolean&gt; instrumented =</span><br><span class="line">        VirtualField.find(ManagedChannelBuilder.class, Boolean.class);</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.TRUE.equals(instrumented.get(builder))) &#123;</span><br><span class="line">      interceptors.add(<span class="number">0</span>, GrpcSingletons.CLIENT_INTERCEPTOR);</span><br><span class="line">      instrumented.set(builder, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里的源码可以看出，使用了 <code>byte-buddy</code> 拦截了 <code>io.grpc.ManagedChannelBuilder#intercept(java.util.List&lt;io.grpc.ClientInterceptor&gt;)</code> 函数。</p><blockquote><p>io.opentelemetry.javaagent.extension.matcher.AgentElementMatchers#extendsClass&#x2F; isMethod 等函数都是 byte-buddy 库提供的函数。</p></blockquote><p>而这个函数正好就是我们需要在业务代码里加入拦截器的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interceptors.add(<span class="number">0</span>, GrpcSingletons.CLIENT_INTERCEPTOR);</span><br><span class="line">GrpcSingletons.CLIENT_INTERCEPTOR = <span class="keyword">new</span> <span class="title class_">TracingClientInterceptor</span>(clientInstrumenter, propagators);</span><br></pre></td></tr></table></figure><p>通过这行代码可以手动将 <code>OpenTelemetry</code> 里的 <code>TracingClientInterceptor</code> 加入到拦截器列表中，并且作为第一个拦截器。</p><p>而这里的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extendsClass(named(<span class="string">&quot;io.grpc.ManagedChannelBuilder&quot;</span>))</span><br><span class="line">        .and(declaresField(named(<span class="string">&quot;interceptors&quot;</span>)))</span><br></pre></td></tr></table></figure><p>通过函数的名称也可以看出是为了找到 继承了<code>io.grpc.ManagedChannelBuilder</code> 类中存在成员变量 <code>interceptors</code> 的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transformer.applyAdviceToMethod(  </span><br><span class="line">    isMethod().and(named(<span class="string">&quot;build&quot;</span>)),  </span><br><span class="line">    GrpcClientBuilderBuildInstrumentation.class.getName() + <span class="string">&quot;$AddInterceptorAdvice&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后在调用 <code>build</code> 函数后就会进入自定义的 <code>AddInterceptorAdvice</code> 类，从而就可以拦截到添加拦截器的逻辑，然后把自定义的拦截器加入其中。</p><h1 id="获取-span-的-attribute"><a href="#获取-span-的-attribute" class="headerlink" title="获取 span 的 attribute"></a>获取 span 的 attribute</h1><p><img src="https://s2.loli.net/2024/07/29/dawSY4uQGmJo6qi.png"></p><p>我们在 gRPC 的链路中还可以看到这个请求的具体属性，比如：</p><ul><li>gRPC 服务提供的 IP 端口。</li><li>请求的响应码</li><li>请求的 service 和 method</li><li>线程等信息。<blockquote><p>这些信息在问题排查过程中都是至关重要的。</p></blockquote></li></ul><p>可以看到这里新的 <code>attribute</code> 主要是分为了三类：</p><ul><li><code>net.*</code> 是网络相关的属性</li><li><code>rpc.*</code> 是和 grpc 相关的属性</li><li><code>thread.*</code> 是线程相关的属性</li></ul><p>所以理论上我们在设计 API 时最好可以将这些不同分组的属性解耦开，如果是 MQ 相关的可能还有一些 topic 等数据，所以各个属性之间是互不影响的。</p><p>带着这个思路我们来看看 gRPC 这里是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clientInstrumenterBuilder</span><br><span class="line">.setSpanStatusExtractor(GrpcSpanStatusExtractor.CLIENT)</span><br><span class="line">.addAttributesExtractors(additionalExtractors)</span><br><span class="line">        .addAttributesExtractor(RpcClientAttributesExtractor.create(rpcAttributesGetter))</span><br><span class="line">        .addAttributesExtractor(ServerAttributesExtractor.create(netClientAttributesGetter))</span><br><span class="line">        .addAttributesExtractor(NetworkAttributesExtractor.create(netClientAttributesGetter))</span><br></pre></td></tr></table></figure><p><code>OpenTelemetry</code> 会提供一个 <code>io.opentelemetry.instrumentation.api.instrumenter.InstrumenterBuilder#addAttributesExtractor</code>构建器函数，用于存放自定义的属性解析器。</p><p>从这里的源码可以看出分别传入了网络相关、RPC 相关的解析器；正好也就对应了图中的那些属性，也满足了我们刚才提到的解耦特性。</p><p>而每一个自定义属性解析器都需要实现接口 <code>io.opentelemetry.instrumentation.api.instrumenter.AttributesExtractor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AttributesExtractor</span>&lt;REQUEST, RESPONSE&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们以 <code>GrpcRpcAttributesGetter</code> 为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">GrpcRpcAttributesGetter</span> <span class="keyword">implements</span> <span class="title class_">RpcAttributesGetter</span>&lt;GrpcRequest&gt; &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getSystem</span><span class="params">(GrpcRequest request)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;grpc&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getService</span><span class="params">(GrpcRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fullMethodName</span> <span class="operator">=</span> request.getMethod().getFullMethodName();</span><br><span class="line">    <span class="type">int</span> <span class="variable">slashIndex</span> <span class="operator">=</span> fullMethodName.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (slashIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullMethodName.substring(<span class="number">0</span>, slashIndex);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到 system 是写死的 <code>grpc</code>，也就是对于到页面上的 <code>rpc.system</code> 属性。</p><p>而这里的 <code>getService</code> 函数则是拿来获取 <code>rpc.service</code> 属性的，可以看到它是通过 <code>gRPC</code> <code>的method</code> 信息来获取 <code>service</code> 的。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RpcAttributesGetter</span>&lt;REQUEST&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Nullable</span>  </span><br><span class="line">  String <span class="title function_">getService</span><span class="params">(REQUEST request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这里 <code>REQUEST</code> 其实是一个泛型，在 gRPC 里是 <code>GrpcRequest</code>，在其他 RPC 里这是对应的 RPC 的数据。</p><p>这个 <code>GrpcRequest</code> 是在我们自定义的拦截器中创建并传递的。<br><img src="https://s2.loli.net/2024/07/29/46mOv7XMoT81Bxl.png"></p><p>而我这里需要的请求包大小也是在拦截中获取到数据然后写入进 GrpcRequest。</p><p><img src="https://s2.loli.net/2024/07/29/A1zk79tVOr3DxnQ.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Long <span class="title function_">getBodySize</span><span class="params">(T message)</span> &#123;  </span><br><span class="line">  <span class="keyword">if</span> (message <span class="keyword">instanceof</span> MessageLite) &#123;  </span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>) ((MessageLite) message).getSerializedSize();  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// Message is not a protobuf message  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><p>这样就可以实现不同的 RPC 中获取自己的 <code>attribute</code>，同时每一组 <code>attribute</code> 也都是隔离的，互相解耦。</p><h1 id="自定义-metrics"><a href="#自定义-metrics" class="headerlink" title="自定义 metrics"></a>自定义 metrics</h1><p>每个插件自定义 Metrics 的逻辑也是类似的，需要由框架层面提供 API 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InstrumenterBuilder&lt;REQUEST, RESPONSE&gt; <span class="title function_">addOperationMetrics</span><span class="params">(OperationMetrics factory)</span> &#123;  </span><br><span class="line">  operationMetrics.add(requireNonNull(factory, <span class="string">&quot;operationMetrics&quot;</span>));  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端的 metrics</span></span><br><span class="line">.addOperationMetrics(RpcClientMetrics.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端的 metrics</span></span><br><span class="line">.addOperationMetrics(RpcServerMetrics.get());</span><br></pre></td></tr></table></figure><p>之后也会在框架层面回调这些自定义的 <code>OperationMetrics</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (operationListeners.length != <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// operation listeners run after span start, so that they have access to the current span</span></span><br><span class="line">     <span class="comment">// for capturing exemplars</span></span><br><span class="line">     <span class="type">long</span> <span class="variable">startNanos</span> <span class="operator">=</span> getNanos(startTime);</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; operationListeners.length; i++) &#123;</span><br><span class="line">       context = operationListeners[i].onStart(context, attributes, startNanos);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (operationListeners.length != <span class="number">0</span>) &#123;  </span><br><span class="line">  <span class="type">long</span> <span class="variable">endNanos</span> <span class="operator">=</span> getNanos(endTime);  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> operationListeners.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">    operationListeners[i].onEnd(context, attributes, endNanos);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中最关键的就是两个函数 onStart 和 onEnd，分别会在当前这个 span 的开始和结束时进行回调。</p><p>所以通常的做法是在 <code>onStart</code> 函数中初始化数据，然后在 <code>onEnd</code> 结束时统计结果，最终可以拿到 metrics 所需要的数据。</p><p>以这个 <code>rpc.client.duration</code> 客户端的请求耗时指标为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Context <span class="title function_">onStart</span><span class="params">(Context context, Attributes startAttributes, <span class="type">long</span> startNanos)</span> &#123;  </span><br><span class="line">  <span class="keyword">return</span> context.with(  </span><br><span class="line">      RPC_CLIENT_REQUEST_METRICS_STATE,  </span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">AutoValue_RpcClientMetrics_State</span>(startAttributes, startNanos));  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEnd</span><span class="params">(Context context, Attributes endAttributes, <span class="type">long</span> endNanos)</span> &#123;  </span><br><span class="line">  <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> context.get(RPC_CLIENT_REQUEST_METRICS_STATE);</span><br><span class="line"><span class="type">Attributes</span> <span class="variable">attributes</span> <span class="operator">=</span> state.startAttributes().toBuilder().putAll(endAttributes).build();  </span><br><span class="line">clientDurationHistogram.record(  </span><br><span class="line">    (endNanos - state.startTimeNanos()) / NANOS_PER_MS, attributes, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开始时记录下当前的时间，结束时获取当前时间和结束时间的差值正好就是这个 span 的执行时间，也就是 rpc client 的处理时间。</p><p>在 <code>OpenTelemetry</code> 中绝大多数的请求时间都是这么记录的。</p><h1 id="Golang-增强"><a href="#Golang-增强" class="headerlink" title="Golang 增强"></a>Golang 增强</h1><p>而在 <code>Golang</code> 中因为没有 <a href="https://bytebuddy.net/#/">byte-buddy</a> 这种魔法库的存在，不可以直接修改源码，所以通常的做法还是得硬编码才行。</p><p>还是以 <code>gRPC</code> 为例，我们在创建 gRPC server 时就得指定一个 <code>OpenTelemetry</code> 提供的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := grpc.NewServer(  </span><br><span class="line">    grpc.StatsHandler(otelgrpc.NewServerHandler()),  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/29/RP9LWQVKSOF1d4Z.png"></p><p> 在这个 SDK 中也会实现刚才在 Java 里类似的逻辑，限于篇幅具体逻辑就不细讲了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是 <code>gRPC</code> 在 <code>OpenTelemetry</code> 中的具体实现，主要就是在找到需要增强框架是否有提供扩展的接口，如果有就直接使用该接口进行埋点。</p><p>如果没有那就需要查看源码，找到核心逻辑，再使用 <code>byte-buddy</code> 进行埋点。</p><p><img src="https://s2.loli.net/2024/07/30/h1uvr3EjA9fGmzR.png"></p><p>比如 Pulsar 并没有在客户端提供一些扩展接口，只能找到它的核心函数进行埋点。</p><p>而在具体埋点过程中 <code>OpenTelemetry</code> 提供了许多解耦的 API，方便我们实现埋点所需要的业务逻辑，也会在后续的文章继续分析 <code>OpenTelemetry</code> 的一些设计原理和核心 API 的使用。</p><p>这部分 API 的设计我觉得是 <code>OpenTelemetry</code> 中最值得学习的地方。</p><p>参考链接：</p><ul><li><a href="https://bytebuddy.net/#/">https://bytebuddy.net/#/</a></li><li><a href="https://opentelemetry.io/docs/specs/semconv/rpc/rpc-metrics/#metric-rpcserverrequestsize">https://opentelemetry.io/docs/specs/semconv/rpc/rpc-metrics/#metric-rpcserverrequestsize</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/07/29/uUTYr8lziEABk4d.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在给 &lt;code&gt;opentelemetry-java-instrumentation&lt;/code&gt; 提交了一个 &lt;a href=&quot;https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/11833&quot;&gt;PR&lt;/a&gt;，是关于给 gRPC 新增四个 metrics：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rpc.client.request.size&lt;/code&gt;: 客户端请求包大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rpc.client.response.size&lt;/code&gt;：客户端收到的响应包大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rpc.server.request.size&lt;/code&gt;：服务端收到的请求包大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rpc.server.response.size&lt;/code&gt;：服务端响应的请求包大小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个 PR 的主要目的就是能够在指标监控中拿到 &lt;code&gt;RPC&lt;/code&gt; 请求的包大小，而这里的关键就是如何才能拿到这些包的大小。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>OpenTelemetry 实战：从零实现应用指标监控</title>
    <link href="http://crossoverjie.top/2024/08/27/ob/OpenTelemetry-02-metrics/"/>
    <id>http://crossoverjie.top/2024/08/27/ob/OpenTelemetry-02-metrics/</id>
    <published>2024-08-27T06:53:35.000Z</published>
    <updated>2024-08-27T14:42:10.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇文章：<a href="https://juejin.cn/post/7391744486979076146">OpenTelemetry 实战：从零实现分布式链路追踪</a>讲解了链路相关的实战，本次我们继续跟进如何使用 OpenTelemetry 集成 metrics 监控。</p><blockquote><p>建议对指标监控不太熟的朋友可以先查看这篇前菜文章：<a href="https://crossoverjie.top/2024/06/13/ob/OpenTelemetry-metrics-concept/">从 Prometheus 到 OpenTelemetry：指标监控的演进与实践</a></p></blockquote><span id="more"></span><table><thead><tr><th>名称</th><th>作用</th><th>语言</th><th>版本</th></tr></thead><tbody><tr><td>java-demo</td><td>发送 gRPC 请求的客户端</td><td>Java</td><td>opentelemetry-agent: 2.4.0&#x2F;SpringBoot: 2.7.14</td></tr><tr><td><a href="https://github.com/crossoverJie/k8s-combat">k8s-combat</a></td><td>提供 gRPC 服务的服务端</td><td>Golang</td><td>go.opentelemetry.io&#x2F;otel: 1.28&#x2F; Go: 1.22</td></tr><tr><td><a href="https://www.jaegertracing.io/">Jaeger</a></td><td>trace 存储的服务端以及 TraceUI 展示</td><td>Golang</td><td>jaegertracing&#x2F;all-in-one:1.56</td></tr><tr><td><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib">opentelemetry-collector-contrib</a></td><td>OpenTelemetry 的 collector 服务端，用于收集 trace&#x2F;metrics&#x2F;logs 然后写入到远端存储</td><td>Golang</td><td>otel&#x2F;opentelemetry-collector-contrib:0.98.0</td></tr><tr><td><a href="https://prometheus.io/">Prometheus</a></td><td>作为 metrics 的存储和展示组件，也可以用 <a href="https://github.com/VictoriaMetrics/VictoriaMetrics">VictoriaMetrics</a> 等兼容 Prometheus 的存储替代。</td><td>Golang</td><td>quay.io&#x2F;prometheus&#x2F;prometheus:v2.49.1</td></tr></tbody></table><p><img src="https://s2.loli.net/2024/07/22/oUPjd4KlX7niBaI.png" alt="image.png"></p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>以上是加入 metrics 之后的流程图，在原有的基础上会新增一个 <code>Prometheus</code> 组件，collector 会将 metrics 指标数据通过远程的 remote write 的方式写入到 Prometheus 中。</p><p>Prometheus 为了能兼容 OpenTelemetry 写入过来的数据，需要开启相关<a href="https://prometheus.io/docs/prometheus/latest/feature_flags/#otlp-receiver">特性</a>才可以。</p><p>如果是 docker 启动的话需要传入相关参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run  -d -p 9292:9090 --name prometheus \</span><br><span class="line">-v /prometheus/prometheus.yml:/etc/prometheus/prometheus.yml \</span><br><span class="line">quay.io/prometheus/prometheus:v2.49.1 \</span><br><span class="line">--config.file=/etc/prometheus/prometheus.yml \</span><br><span class="line">--storage.tsdb.path=/prometheus \</span><br><span class="line">--web.console.libraries=/etc/prometheus/console_libraries \</span><br><span class="line">--web.console.templates=/etc/prometheus/consoles \</span><br><span class="line">--enable-feature=exemplar-storage \</span><br><span class="line">--enable-feature=otlp-write-receiver</span><br></pre></td></tr></table></figure><p><code>--enable-feature=otlp-write-receiver</code> 最主要的就是这个参数，用于开启接收 OTLP 格式的数据。</p><p>但使用这个 Push 特性就会丧失掉 Prometheus 的许多 Pull 特性，比如服务发现，定时抓取等，不过也还好，Push 和 Pull 可以同时使用，原本使用 Pull 抓取的组件依然不受影响。</p><h2 id="修改-OpenTelemetry-Collector"><a href="#修改-OpenTelemetry-Collector" class="headerlink" title="修改 OpenTelemetry-Collector"></a>修改 OpenTelemetry-Collector</h2><p>接着我们需要修改下 Collector 的配置:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">exporters:</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">&quot;jaeger:4317&quot;</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">otlphttp/prometheus:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">http://prometheus:9292/api/v1/otlp</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">insecure:</span> <span class="literal">true</span>      </span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="attr">batch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">pipelines:</span></span><br><span class="line">    <span class="attr">traces:</span></span><br><span class="line">      <span class="attr">receivers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlp</span></span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">debug</span>        </span><br><span class="line">    <span class="attr">metrics:</span></span><br><span class="line">      <span class="attr">exporters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlphttp/prometheus</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">debug</span></span><br><span class="line">      <span class="attr">processors:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">batch</span></span><br><span class="line">      <span class="attr">receivers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">otlp</span></span><br></pre></td></tr></table></figure><p>这里我们在 <code>exporter</code> 中新增了一个 <code>otlphttp/prometheus</code> 的节点，用于指定导出 <code>prometheus</code> 的 <code>endpoint</code> 地址。</p><p>同时我们还需要在 <code>server.metrics.exporters</code> 中配置相同的 key: <code>otlphttp/prometheus</code>。</p><p>需要注意的是这里我们一定得是配置在 <code>metrics.exporters</code> 这个节点下，如果配置在 <code>traces.exporters</code> 下时，相当于是告诉 collector 讲 trace 的数据导出到 <code>otlphttp/prometheus.endpoint</code> 这个 endpoint 里了。</p><blockquote><p>所以重点是需要理解这里的配对关系。</p></blockquote><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p>这样我们只需要将应用启动之后就可以在 Prometheus 中查询到应用上报的指标了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.traces.exporter=otlp \</span><br><span class="line">-Dotel.metrics.exporter=otlp \</span><br><span class="line">-Dotel.logs.exporter=none \</span><br><span class="line">-Dotel.service.name=java-demo \</span><br><span class="line">-Dotel.exporter.otlp.protocol=grpc \</span><br><span class="line">-Dotel.propagators=tracecontext,baggage \</span><br><span class="line">-Dotel.exporter.otlp.endpoint=http://127.0.0.1:5317 -jar target/demo-0.0.1-SNAPSHOT.jar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run go app</span></span><br><span class="line">export OTEL_EXPORTER_OTLP_ENDPOINT=http://127.0.0.1:5317 OTEL_RESOURCE_ATTRIBUTES=service.name=k8s-combat</span><br><span class="line">./k8s-combat</span><br></pre></td></tr></table></figure><p>因为我们在 collector 中开启了 Debug 的 exporter，所以可以看到以下日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024-07-22T06:34:08.060ZinfoMetricsExporter&#123;&quot;kind&quot;: &quot;exporter&quot;, &quot;data_type&quot;: &quot;metrics&quot;, &quot;name&quot;: &quot;debug&quot;, &quot;resource metrics&quot;: 1, &quot;metrics&quot;: 18, &quot;data points&quot;: 44&#125;</span><br></pre></td></tr></table></figure><p>此时是可以说明指标上传成功的。</p><p>然后我们打开 <code>Prometheus</code> 的地址：<a href="http://127.0.0.1:9292/graph">http://127.0.0.1:9292/graph</a><br>便可以查询到 Java 应用和 Go 应用上报的指标。<br><img src="https://s2.loli.net/2024/07/22/O4TuE5WlFJ8Gyk1.png"></p><blockquote><p>OpenTelemetry 的 javaagent 会自动上报 JVM 相关的指标。</p></blockquote><hr><p>而在 Go 程序中我们还是需要显式的配置一些埋点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMeterProvider</span><span class="params">()</span></span> *sdkmetric.MeterProvider &#123;  </span><br><span class="line">    ctx := context.Background()  </span><br><span class="line">  </span><br><span class="line">    exporter, err := otlpmetricgrpc.New(ctx)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Printf(<span class="string">&quot;new otlp metric grpc exporter failed: %v&quot;</span>, err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    mp := sdkmetric.NewMeterProvider(  </span><br><span class="line">       sdkmetric.WithReader(sdkmetric.NewPeriodicReader(exporter)),  </span><br><span class="line">       sdkmetric.WithResource(initResource()),  </span><br><span class="line">    )    otel.SetMeterProvider(mp)  </span><br><span class="line">    <span class="keyword">return</span> mp  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mp := initMeterProvider()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := mp.Shutdown(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error shutting down meter provider: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>和 Tracer 类似，我们首先也得在 main 函数中调用 <code>initMeterProvider()</code> 函数来初始化 Meter，此时它会返回一个 <code>sdkmetric.MeterProvider</code> 对象。</p><p>OpenTelemetry Go 的 SDK 中已经提供了对 go runtime 的自动埋点，我们只需要调用相关函数即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := runtime.Start(runtime.WithMinimumReadMemStatsInterval(time.Second))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们启动应用，在 Prometheus 中就可以看到  Go  应用上报的相关指标了。<br><img src="https://s2.loli.net/2024/07/21/FAHrsZ5ap6SWNU7.png" alt="image.png"><br><img src="https://s2.loli.net/2024/07/22/pxWu4UREZ5PXng1.png"></p><blockquote><p>runtime_uptime_milliseconds_total  Go 的运行时指标</p></blockquote><p><code>Prometheus</code> 中展示指标的 UI 能力有限，通常我们都是配合 <code>grafana</code> 进行展示的。<br><img src="https://s2.loli.net/2024/07/22/A7HNl1zbfeI4JuR.png" alt="image.png"></p><h2 id="手动上报指标"><a href="#手动上报指标" class="headerlink" title="手动上报指标"></a>手动上报指标</h2><p>当然除了 SDK 自动上报的指标之外，我们也可以类似于 trace 那样手动上报一些指标；</p><p>比如我就想记录某个函数调用的次数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> meter =  otel.Meter(<span class="string">&quot;test.io/k8s/combat&quot;</span>)  </span><br><span class="line">apiCounter, err = meter.Int64Counter(  </span><br><span class="line">    <span class="string">&quot;api.counter&quot;</span>,  </span><br><span class="line">    metric.WithDescription(<span class="string">&quot;Number of API calls.&quot;</span>),  </span><br><span class="line">    metric.WithUnit(<span class="string">&quot;&#123;call&#125;&quot;</span>),  </span><br><span class="line">)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    log.Err(err)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, <span class="type">error</span>) &#123;  </span><br><span class="line">    <span class="keyword">defer</span> apiCounter.Add(ctx, <span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: fmt.Sprintf(<span class="string">&quot;hostname:%s, in:%s, md:%v&quot;</span>, name, in.Name, md)&#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要创建一个 <code>Int64Counter</code> 类型的指标，然后在需要埋点处调用它的函数 <code>apiCounter.Add(ctx, 1)</code> 即可。</p><p><img src="https://s2.loli.net/2024/07/21/cSwCa4U7WuoJ82n.png" alt="image.png"><br>之后便可以在 <code>Prometheus</code> 中查到这个指标了。</p><p>除此之外 OpenTelemetry 中的 metrics 定义和 Prometheus 也是类似的，还有以下几种类型：</p><ul><li><strong>Counter</strong>：单调递增计数器，比如可以用来记录订单数、总的请求数。</li><li><strong>UpDownCounter</strong>：与 Counter 类似，只不过它可以递减。</li><li><strong>Gauge</strong>：用于记录随时在变化的值，比如内存使用量、CPU 使用量等。</li><li><strong>Histogram</strong>：通常用于记录请求延迟、响应时间等。</li></ul><p>在 Java 中也提供有类似的 API 可以完成自定义指标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">messageInCounter = meter    </span><br><span class="line">        .counterBuilder(MESSAGE_IN_COUNTER)    </span><br><span class="line">        .setUnit(<span class="string">&quot;&#123;message&#125;&quot;</span>)    </span><br><span class="line">        .setDescription(<span class="string">&quot;The total number of messages received for this topic.&quot;</span>)    </span><br><span class="line">        .buildObserver();</span><br></pre></td></tr></table></figure><p>对于 Gauge 类型的数据用法如下，使用 <code>buildWithCallback</code> 回调函数上报数据，<code>OpenTelemetry</code> 会在框架层面每 30s 回调一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerObservers</span><span class="params">()</span> &#123;      </span><br><span class="line">    <span class="type">Meter</span> <span class="variable">meter</span> <span class="operator">=</span> MetricsRegistration.getMeter();      </span><br><span class="line">      </span><br><span class="line">    meter.gaugeBuilder(<span class="string">&quot;pulsar_producer_num_msg_send&quot;</span>)      </span><br><span class="line">            .setDescription(<span class="string">&quot;The number of messages published in the last interval&quot;</span>)      </span><br><span class="line">            .ofLongs()      </span><br><span class="line">            .buildWithCallback(      </span><br><span class="line">                    r -&gt; recordProducerMetrics(r, ProducerStats::getNumMsgsSent));  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recordProducerMetrics</span><span class="params">(ObservableLongMeasurement observableLongMeasurement, Function&lt;ProducerStats, Long&gt; getter)</span> &#123;      </span><br><span class="line">    <span class="keyword">for</span> (Producer producer : CollectionHelper.PRODUCER_COLLECTION.list()) &#123;      </span><br><span class="line">        <span class="type">ProducerStats</span> <span class="variable">stats</span> <span class="operator">=</span> producer.getStats();      </span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> producer.getTopic();      </span><br><span class="line">        <span class="keyword">if</span> (topic.endsWith(RetryMessageUtil.RETRY_GROUP_TOPIC_SUFFIX)) &#123;      </span><br><span class="line">            <span class="keyword">continue</span>;      </span><br><span class="line">        &#125;        observableLongMeasurement.record(getter.apply(stats),      </span><br><span class="line">                Attributes.of(PRODUCER_NAME, producer.getProducerName(), TOPIC, topic));      </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>更多具体用法可以参考官方文档链接：<br><a href="https://opentelemetry.io/docs/languages/java/instrumentation/#metrics">https://opentelemetry.io/docs/languages/java/instrumentation/#metrics</a></p><p>如果我们不想将数据通过 collector 而是直接上报到 Prometheus 中，使用 OpenTelemetry 框架也是可以实现的。</p><p>我们只需要配置下环境变量:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export OTEL_METRICS_EXPORTER=prometheus</span><br></pre></td></tr></table></figure><p>这样我们就可以访问 <a href="http://127.0.0.1:9464/metrics">http://127.0.0.1:9464/metrics</a> 获取到当前应用暴露出来的指标，此时就可以在 <code>Prometheus</code> 里配置好采集 job 来获取数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&quot;k8s-combat&quot;</span></span><br><span class="line">    <span class="comment"># metrics_path defaults to &#x27;/metrics&#x27;</span></span><br><span class="line">    <span class="comment"># scheme defaults to &#x27;http&#x27;.</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&quot;k8s-combat:9464&quot;</span>]   </span><br></pre></td></tr></table></figure><p>这就是典型的 Pull 模型，而 OpenTelemetry 推荐使用的是 Push 模型，数据由 OpenTelemetry 进行采集然后推送到 Prometheus。</p><p>这两种模式各有好处：</p><table><thead><tr><th></th><th>Pull模型</th><th>Push 模型</th></tr></thead><tbody><tr><td>优点</td><td>可以在一个集中的配置里管理所有的抓取端点，也可以为每一个应用单独配置抓取频次等数据。</td><td>在 OpenTelemetry 的 collector中可以集中对指标做预处理之后再将过滤后的数据写入 Prometheus，更加的灵活。</td></tr><tr><td>缺点</td><td>1. 预处理指标比较麻烦，所有的数据是到了 Prometheus 后再经过relabel处理后再写入存储。<br>2. 需要配置服务发现</td><td>1. 额外需要维护一个类似于 collector 这样的指标网关的组件</td></tr></tbody></table><p>比如我们是用和 Prometheus 兼容的 VictoriaMetrics 采集了 istio 的相关指标，但里面的指标太多了，我们需要删除掉一部分。</p><p>就需要在采集任务里编写规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">operator.victoriametrics.com/v1beta1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">VMPodScrape</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">isito-pod-scrape</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">podMetricsEndpoints:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">scheme:</span> <span class="string">http</span>  </span><br><span class="line">      <span class="attr">scrape_interval:</span> <span class="string">&quot;30s&quot;</span>  </span><br><span class="line">      <span class="attr">scrapeTimeout:</span> <span class="string">&quot;30s&quot;</span>  </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/stats/prometheus</span>  </span><br><span class="line">      <span class="attr">metricRelabelConfigs:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">regex:</span> <span class="string">^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum|istio_request_bytes_count|istio_response_bytes_sum|istio_request_bytes_sum|istio_request_duration_milliseconds_sum|istio_response_bytes_count|istio_request_duration_milliseconds_count|^ostrich_apigateway.*|istio_request_messages_total|istio_response_messages_total</span>  </span><br><span class="line">          <span class="attr">action:</span> <span class="string">drop_metrics</span>  </span><br><span class="line">  <span class="attr">namespaceSelector:</span>  </span><br><span class="line">    <span class="attr">any:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>换成在 collector 中处理后，这些逻辑都可以全部移动到 collector 中集中处理。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>metrics 的使用相对于 trace 更简单一些，不需要理解复杂的 context、span 等概念，只需要搞清楚有哪几种 metrics 类型，分别应用在哪些不同的场景即可。</p><p>参考链接：</p><ul><li><a href="https://prometheus.io/docs/prometheus/latest/feature_flags/#otlp-receiver">https://prometheus.io/docs/prometheus/latest/feature_flags/#otlp-receiver</a></li><li><a href="https://opentelemetry.io/docs/languages/java/instrumentation/#metrics">https://opentelemetry.io/docs/languages/java/instrumentation/#metrics</a></li><li><a href="https://opentelemetry.io/docs/languages/go/instrumentation/#metrics">https://opentelemetry.io/docs/languages/go/instrumentation/#metrics</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇文章：&lt;a href=&quot;https://juejin.cn/post/7391744486979076146&quot;&gt;OpenTelemetry 实战：从零实现分布式链路追踪&lt;/a&gt;讲解了链路相关的实战，本次我们继续跟进如何使用 OpenTelemetry 集成 metrics 监控。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;建议对指标监控不太熟的朋友可以先查看这篇前菜文章：&lt;a href=&quot;https://crossoverjie.top/2024/06/13/ob/OpenTelemetry-metrics-concept/&quot;&gt;从 Prometheus 到 OpenTelemetry：指标监控的演进与实践&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>OpenTelemetry 实战：从零实现分布式链路追踪</title>
    <link href="http://crossoverjie.top/2024/08/20/ob/OpenTelemetry-01-trace/"/>
    <id>http://crossoverjie.top/2024/08/20/ob/OpenTelemetry-01-trace/</id>
    <published>2024-08-20T06:53:35.000Z</published>
    <updated>2024-08-20T06:35:59.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前写过一篇 <a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅</a>的文章，主要是从概念上讲解了 Trace 在 OpenTelemetry 的中的场景和使用。</p><p>也写过一篇 <a href="https://crossoverjie.top/2024/05/26/ob/OTel-demo/">实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术</a>：如何从一个 demo 开始集成 OpenTelemetry。</p><p>但还是有不少小伙伴反馈说无法快速上手（可能也是这个 demo 的项目比较多），于是我准备从 0 开始从真实的代码一步步带大家集成 <code>OpenTelemetry</code>，因为 OpenTelemetry 本身是跨多种语言的，所以也会以两种语言为（Java、Golang）主进行讲解。</p><blockquote><p>使用这两种语言主要是因为 Java 几乎全是自动埋点，而 Golang 因为语言特性，大部分都得硬编码埋点；覆盖到这两种场景后其他语言也是类似的，顶多只是 API 名称有些许区别。</p></blockquote><p>在这个过程中也会穿插一些 OpenTelemetry 的原理，希望整个过程下来大家可以在项目中实际运用起来，同时也能知其所以然。</p><span id="more"></span><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>在这个过程中会涉及到以下项目：</p><table><thead><tr><th>名称</th><th>作用</th><th>语言</th><th>版本</th></tr></thead><tbody><tr><td>java-demo</td><td>发送 gRPC 请求的客户端</td><td>Java</td><td>opentelemetry-agent: 2.4.0&#x2F;SpringBoot: 2.7.14</td></tr><tr><td>k8s-combat</td><td>提供 gRPC 服务的服务端</td><td>Golang</td><td>go.opentelemetry.io&#x2F;otel: 1.28&#x2F; Go: 1.22</td></tr><tr><td>Jaeger</td><td>trace 存储的服务端以及 TraceUI 展示</td><td>Golang</td><td>jaegertracing&#x2F;all-in-one:1.56</td></tr><tr><td>opentelemetry-collector-contrib</td><td>OpenTelemetry 的 collector 服务端，用于收集 trace&#x2F;metrics&#x2F;logs 然后写入到远端存储</td><td>Golang</td><td>otel&#x2F;opentelemetry-collector-contrib:0.98.0</td></tr></tbody></table><p><img src="https://s2.loli.net/2024/07/15/u4BYXOkztqyUoEK.png" alt="image.png"></p><p>在开始之前我们先看看实际的效果，我们需要先把 collector 和 Jaeger 部署好：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -d --name jaeger \</span><br><span class="line">  -e COLLECTOR_ZIPKIN_HOST_PORT=:9411 \</span><br><span class="line">  -p 6831:6831/udp \</span><br><span class="line">  -p 6832:6832/udp \</span><br><span class="line">  -p 5778:5778 \</span><br><span class="line">  -p 16686:16686 \</span><br><span class="line">  -p 4317:4317 \</span><br><span class="line">  -p 4318:4318 \</span><br><span class="line">  -p 14250:14250 \</span><br><span class="line">  -p 14268:14268 \</span><br><span class="line">  -p 14269:14269 \</span><br><span class="line">  -p 9411:9411 \</span><br><span class="line">  jaegertracing/all-in-one:1.56</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run --rm -d -v $(pwd)/coll-config.yaml:/etc/otelcol-contrib/config.yaml --name coll \</span><br><span class="line">-p 5318:4318 \</span><br><span class="line">-p 5317:4317 \</span><br><span class="line">otel/opentelemetry-collector-contrib:0.98.0</span><br></pre></td></tr></table></figure><p>这里有一个 <code>coll-config</code> 的配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">receivers:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">protocols:</span></span><br><span class="line">      <span class="attr">grpc:</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line"><span class="attr">exporters:</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">&quot;127.0.0.1:4317&quot;</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="attr">batch:</span></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">pipelines:</span></span><br><span class="line">    <span class="attr">traces:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">otlp</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">otlp</span>, <span class="string">debug</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重点是这里的 <code>endpoint: &quot;127.0.0.1:4317&quot;</code> 我们需要配置位 Jaeger 的 IP 和端口。</p><blockquote><p>更多关于这里的配置会在后续单独的 collector 章节中讲解。</p></blockquote><p>这两个服务都启动成功后再启动我们的 Java 客户端和  Go  服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.traces.exporter=otlp \</span><br><span class="line">-Dotel.metrics.exporter=otlp \</span><br><span class="line">-Dotel.logs.exporter=none \</span><br><span class="line">-Dotel.service.name=demo \</span><br><span class="line">-Dotel.exporter.otlp.protocol=grpc \</span><br><span class="line">-Dotel.propagators=tracecontext,baggage \</span><br><span class="line">-Dotel.exporter.otlp.endpoint=http://127.0.0.1:5317 \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Golang</span></span><br><span class="line">export OTEL_EXPORTER_OTLP_ENDPOINT=http://127.0.0.1:5317</span><br><span class="line">export OTEL_RESOURCE_ATTRIBUTES=service.name=k8s-combat</span><br><span class="line">./k8s-combat</span><br></pre></td></tr></table></figure><p>可以看到不管是 Java 还是 Golang 应用都是需要配置 <code>OTEL_EXPORTER_OTLP_ENDPOINT</code> 参数，也就是 <code>opentelemetry-collector-contrib</code> 的地址。</p><blockquote><p>其余的一些配置在后面会讲到。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:9191/request\?name\=1232</span><br></pre></td></tr></table></figure><p>然后我们触发一下 Java 客户端的入口，就可以在 JaegerUI 中查询到刚才的链路了。<br><code>http://localhost:16686/search</code></p><p><img src="https://s2.loli.net/2024/07/15/skNmSDJaPfHh3GB.png" alt="image.png"><br><img src="https://s2.loli.net/2024/07/15/xoG2finOmFlDReE.png" alt="image.png"><br>这样整个 <code>trace</code> 链路就串起来了。</p><h1 id="Java-应用"><a href="#Java-应用" class="headerlink" title="Java 应用"></a>Java 应用</h1><p>下面来看看具体的应用代码里是如何编写的。</p><blockquote><p>Java 是基于 springboot 编写的，具体 springboot 的使用就不再赘述了。</p></blockquote><p>因为我们应用是使用 gRPC 通信的，所以需要提供一个 <code>helloworld.proto</code> 的 pb 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;  </span><br><span class="line">  </span><br><span class="line">option go_package = &quot;google.golang.org/grpc/examples/helloworld/helloworld&quot;;  </span><br><span class="line">option java_multiple_files = true;  </span><br><span class="line">option java_package = &quot;io.grpc.examples.helloworld&quot;;  </span><br><span class="line">option java_outer_classname = &quot;HelloWorldProto&quot;;  </span><br><span class="line">  </span><br><span class="line">package helloworld;  </span><br><span class="line">  </span><br><span class="line">// The greeting service definition.  </span><br><span class="line">service Greeter &#123;  </span><br><span class="line">  // Sends a greeting  </span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// The request message containing the user&#x27;s name.  </span><br><span class="line">message HelloRequest &#123;  </span><br><span class="line">  string name = 1;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// The response message containing the greetings  </span><br><span class="line">message HelloReply &#123;  </span><br><span class="line">  string message = 1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件也没啥好说的，就定义了一个简单的 <code>SayHello</code> 接口。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.devh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-stub<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-protobuf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Java 中使用了 <code>grpc-spring-boot-starter</code> 这个库来处理 gRPC 的客户端和服务端请求。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">grpc:</span>  </span><br><span class="line">  <span class="attr">server:</span>  </span><br><span class="line">    <span class="attr">port:</span> <span class="number">9192</span>  </span><br><span class="line">  <span class="attr">client:</span>  </span><br><span class="line">    <span class="attr">greeter:</span>  </span><br><span class="line">      <span class="attr">address:</span> <span class="string">&#x27;static://127.0.0.1:50051&#x27;</span>  </span><br><span class="line">      <span class="attr">enableKeepAlive:</span> <span class="literal">true</span>  </span><br><span class="line">      <span class="attr">keepAliveWithoutCalls:</span> <span class="literal">true</span>  </span><br><span class="line">      <span class="attr">negotiationType:</span> <span class="string">plaintext</span></span><br></pre></td></tr></table></figure><p>然后我们定义了一个接口用于接收请求触发 <code>gRPC</code> 的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/request&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;  </span><br><span class="line">   log.info(<span class="string">&quot;request: &#123;&#125;&quot;</span>, request);    </span><br><span class="line">   <span class="type">HelloReply</span> <span class="variable">abc</span> <span class="operator">=</span> greeterStub.sayHello(io.grpc.examples.helloworld.HelloRequest.newBuilder().setName(request.getName()).build());   </span><br><span class="line">   <span class="keyword">return</span> abc.getMessage();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 应用的实现非常简单，和我们日常日常开发没有任何区别；唯一的区别就是在启动时需要加入一个 <code>javaagent</code>以及一些启动参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar \</span><br><span class="line">-Dotel.traces.exporter=otlp \</span><br><span class="line">-Dotel.metrics.exporter=otlp \</span><br><span class="line">-Dotel.logs.exporter=none \</span><br><span class="line">-Dotel.service.name=demo \</span><br><span class="line">-Dotel.exporter.otlp.protocol=grpc \</span><br><span class="line">-Dotel.propagators=tracecontext,baggage \</span><br><span class="line">-Dotel.exporter.otlp.endpoint=http://127.0.0.1:5317 \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>下面来仔细看看这些参数</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>javaagent:opentelemetry-javaagent-2.4.0-SNAPSHOT.jar</td><td>这个没啥好说的，指定一个 javaagent</td></tr><tr><td>otel.traces.exporter</td><td>指定 trace 以什么格式传输（默认是这里的 <code>otlp</code>)；当然还有其他的值：<code>logging/jaeger/zipkin</code> 等，我们这里使用 otlp 会将数据传输到 collector 中。</td></tr><tr><td>otel.metrics.exporter</td><td>同上，只是指定的是 metrics 的传输方式，我们在之后讲解指标的时候会用到。</td></tr><tr><td>otel.service.name</td><td>定义在 trace 中的应用名称，springboot 会默认使用 <code>spring.application.name</code> 这个变量。</td></tr><tr><td>otel.exporter.otlp.protocol</td><td>指定传输协议；除了 grpc 之外还有 <code>http/protobuf</code>，当然我们也可以根据 trace 和 metrics 分开指定：<code>otel.exporter.otlp.traces.protocol/otel.exporter.otlp.metrics.protocol</code></td></tr><tr><td>otel.propagators</td><td>指定我们跨服务传播上下文的时候使用哪种格式，默认是 <a href="https://www.w3.org/TR/trace-context/">W3C Trace Context</a>,<a href="https://www.w3.org/TR/baggage/">baggage</a>，当然也有其他的- <code>&quot;b3&quot;</code>: <a href="https://github.com/openzipkin/b3-propagation#single-header">B3 Single</a>，- <code>&quot;xray&quot;</code>: <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader">AWS X-Ray</a>，<code>&quot;jaeger&quot;</code>: <a href="https://www.jaegertracing.io/docs/1.21/client-libraries/#propagation-format">Jaeger</a>等</td></tr><tr><td>otel.exporter.otlp.endpoint</td><td>指定 collector 的 endpoint</td></tr><tr><td>更多细节的参数大家可以在这里找到：</td><td></td></tr><tr><td><a href="https://opentelemetry.io/docs/languages/java/configuration/">https://opentelemetry.io/docs/languages/java/configuration/</a></td><td></td></tr></tbody></table><h1 id="Golang-应用"><a href="#Golang-应用" class="headerlink" title="Golang 应用"></a>Golang 应用</h1><p>接着我们来看看 Go 是如何集成 <code>OpenTelemetry</code> 的。</p><p>在创建好项目之后我们需要添加 <code>OpenTelemetry</code> 所提供的包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go get &quot;go.opentelemetry.io/otel&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/propagation&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/sdk/metric&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/sdk/resource&quot; \</span><br><span class="line">  &quot;go.opentelemetry.io/otel/sdk/trace&quot; \       &quot;go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc&quot;\</span><br></pre></td></tr></table></figure><p>然后我们需要创建一个初始化 <code>tracer</code> 的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initTracerProvider</span><span class="params">()</span></span> *sdktrace.TracerProvider &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">exporter, err := otlptracegrpc.New(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;new otlp trace grpc exporter failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">tp := sdktrace.NewTracerProvider(</span><br><span class="line">sdktrace.WithBatcher(exporter),</span><br><span class="line">sdktrace.WithResource(initResource()),</span><br><span class="line">)</span><br><span class="line">otel.SetTracerProvider(tp)</span><br><span class="line">otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext&#123;&#125;, propagation.Baggage&#123;&#125;))</span><br><span class="line"><span class="keyword">return</span> tp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们使用的是 <code>grpc</code> 协议上报 <code>otlp</code> 数据，所以这里使用的是 <code>exporter, err := otlptracegrpc.New(ctx)</code>  创建了一个 <code>exporter</code>。</p><p><code>otel.SetTextMapPropagator()</code> 这个函数里配置数据和刚才 Java 里配置的 <code>-Dotel.propagators=tracecontext,baggage</code> 是一样的效果。</p><p>与此同时我们还需要提供一个 <code>initResource()</code> 的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initResource</span><span class="params">()</span></span> *sdkresource.Resource &#123;</span><br><span class="line">initResourcesOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">extraResources, _ := sdkresource.New(</span><br><span class="line">context.Background(),</span><br><span class="line">sdkresource.WithOS(),</span><br><span class="line">sdkresource.WithProcess(),</span><br><span class="line">sdkresource.WithContainer(),</span><br><span class="line">sdkresource.WithHost(),</span><br><span class="line">)</span><br><span class="line">resource, _ = sdkresource.Merge(</span><br><span class="line">sdkresource.Default(),</span><br><span class="line">extraResources,</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数用来告诉 trace 需要暴露那些 resource，也就是我们在这里看到进程相关的属性：<br><img src="https://s2.loli.net/2024/07/15/Gveu4hNjWdYLiBo.png" alt="image.png"><br>比如这里的 <code>sdkresource.WithOS(),</code> 就会显示 OS 的类型和描述。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithOS</span><span class="params">()</span></span> Option &#123;  </span><br><span class="line">    <span class="keyword">return</span> WithDetectors(  </span><br><span class="line">       osTypeDetector&#123;&#125;,  </span><br><span class="line">       osDescriptionDetector&#123;&#125;,  </span><br><span class="line">    )&#125;</span><br></pre></td></tr></table></figure><p>而 <code>sdkresource.WithProcess(),</code> 显示的数据就更多了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithProcess</span><span class="params">()</span></span> Option &#123;  </span><br><span class="line">    <span class="keyword">return</span> WithDetectors(  </span><br><span class="line">       processPIDDetector&#123;&#125;,  </span><br><span class="line">       processExecutableNameDetector&#123;&#125;,  </span><br><span class="line">       processExecutablePathDetector&#123;&#125;,  </span><br><span class="line">       processCommandArgsDetector&#123;&#125;,  </span><br><span class="line">       processOwnerDetector&#123;&#125;,  </span><br><span class="line">       processRuntimeNameDetector&#123;&#125;,  </span><br><span class="line">       processRuntimeVersionDetector&#123;&#125;,  </span><br><span class="line">       processRuntimeDescriptionDetector&#123;&#125;,  </span><br><span class="line">    )&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上这些代码在 Java 中都是由 agent 指定创建的。</p></blockquote><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init OpenTelemetry start  </span></span><br><span class="line">tp := initTracerProvider()  </span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> err := tp.Shutdown(context.Background()); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Printf(<span class="string">&quot;Error shutting down tracer provider: %v&quot;</span>, err)  </span><br><span class="line">    &#125;&#125;()  </span><br><span class="line">   </span><br><span class="line">err := runtime.Start(runtime.WithMinimumReadMemStatsInterval(time.Second))  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    log.Err(err)  </span><br><span class="line">&#125;</span><br><span class="line">tracer = tp.Tracer(<span class="string">&quot;k8s-combat&quot;</span>)</span><br><span class="line"><span class="comment">// Init OpenTelemetry end</span></span><br></pre></td></tr></table></figure><p>之后我们需要在 main 函数一开始就初始化 <code>traceProvider</code>。</p><p>对于 <code>grpc</code> 来说，<code>OpenTelemetry</code> 的 Go-SDK 提供了自动埋点，但我们也得手动配置一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := grpc.NewServer(  </span><br><span class="line">    grpc.StatsHandler(otelgrpc.NewServerHandler()),  </span><br><span class="line">)  </span><br><span class="line">pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br></pre></td></tr></table></figure><p>使用 <code>grpc.StatsHandler(otelgrpc.NewServerHandler()),</code>  将 <code>OTel</code> 的 <code>serverHandle</code> 加入进去，这个 handle 会自动创建 <code>grpc</code> 服务端的 <code>span</code>。</p><blockquote><p>对 trace&#x2F;span 概念还有不了解的朋友可以查看这篇<a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">文章</a>。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> port = <span class="string">&quot;:50051&quot;</span>  </span><br><span class="line">lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    log.Fatal().Msgf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)  </span><br><span class="line">&#125;  </span><br><span class="line">s := grpc.NewServer(  </span><br><span class="line">    grpc.StatsHandler(otelgrpc.NewServerHandler()),  </span><br><span class="line">)  </span><br><span class="line">pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)  </span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    log.Fatal().Msgf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    log.Printf(<span class="string">&quot;served on %s \n&quot;</span>, port)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们只需要启动这个 grpc 服务即可，就算完成了 Go 服务的集成。</p><p>从这里可以看出 Java 相对于 Go 来说会简单许多，只需要配置一个 agent 就可以不该一行代码支持目前市面上流行的绝大多数框架。<br><img src="https://s2.loli.net/2024/04/17/kMDcrPwxJy4oZYe.png"></p><h1 id="自定义-span-的-attribute"><a href="#自定义-span-的-attribute" class="headerlink" title="自定义  span 的 attribute"></a>自定义  span 的 attribute</h1><p>我们在看链路信息的时候其实看的最多的是某个 <code>span</code> 里的 <code>attribute</code> 数据（有些地方又称为 <code>tag</code>)<br>如下图所示：<br><img src="https://s2.loli.net/2024/07/15/jrdkNCAZhi6UIvP.png"></p><p>这里会展示当前 <code>span</code> 的各种信息，但如果我们想要额外加一些自己关心的数据应该如何添加呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message HelloRequest &#123;  </span><br><span class="line">  string name = 1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们想知道这个 grpc 接口里的 name 参数，如上图所示那样展示在 span 中。</p><p>好在 <code>OpenTelemetry</code> 已经考虑到类似的需求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">span := trace.SpanFromContext(ctx)  </span><br><span class="line">span.SetAttributes(attribute.String(<span class="string">&quot;request.name&quot;</span>, in.Name))</span><br></pre></td></tr></table></figure><p>我们使用 <code>span := trace.SpanFromContext(ctx)</code>  获取到当前的 span，然后调用 <code>SetAttributes</code> 就可以添加自定义的数据了。</p><blockquote><p>对应的 Java 也有类似的函数。</p></blockquote><p>除了新增 <code>attribute</code> 之外还可以新增 Event，Link 等数据，使用方式也是类似的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddEvent adds an event with the provided name and options.  </span></span><br><span class="line">AddEvent(name <span class="type">string</span>, options ...EventOption)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// AddLink adds a link.  </span></span><br><span class="line"><span class="comment">// Adding links at span creation using WithLinks is preferred to calling AddLink  </span></span><br><span class="line"><span class="comment">// later, for contexts that are available during span creation, because head  </span></span><br><span class="line"><span class="comment">// sampling decisions can only consider information present during span creation.  </span></span><br><span class="line">AddLink(link Link)</span><br></pre></td></tr></table></figure><h1 id="自定义新增-span"><a href="#自定义新增-span" class="headerlink" title="自定义新增 span"></a>自定义新增 span</h1><p>同理我们可能不局限于为某个 span 新增 attribute，也有可能想要新增一个新的 span 来记录关键的调用信息。</p><blockquote><p>默认情况下只有 OpenTelemetry 实现过的组件的核心函数才会有 span，自己代码里的函数调用是不会创建span 的。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> span(ctx context.Context) &#123;  </span><br><span class="line">    ctx, span := tracer.Start(ctx, <span class="string">&quot;hello-span&quot;</span>)  </span><br><span class="line">    <span class="keyword">defer</span> span.End()  </span><br><span class="line">    <span class="comment">// do some work  </span></span><br><span class="line">    log.Printf(<span class="string">&quot;create span&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在  Go 中只需要手动 Start 一个 span 即可。</p><p>对应到 <code>Java</code> 稍微简单一些，只需要为函数添加一个注解即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WithSpan(&quot;span&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">span</span><span class="params">(<span class="meta">@SpanAttribute(&quot;request.name&quot;)</span> String name)</span> &#123;  </span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);  </span><br><span class="line">    log.info(<span class="string">&quot;span:&#123;&#125;&quot;</span>, name);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过得单独引入一个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.opentelemetry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opentelemetry-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.opentelemetry.instrumentation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opentelemetry-instrumentation-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终我们在 Jaeger UI 上看到的效果如下：</p><p><img src="https://s2.loli.net/2024/07/15/1tLlYezQwInZWDX.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://s2.loli.net/2024/07/15/WXPp1MUkdHo4zam.png"></p><p>最后总结一下，OpenTelemetry 支持许多流行的语言，主要分为两类：是否支持自动埋点。</p><p><img src="https://s2.loli.net/2024/07/15/fvu67rdoxtZkq5m.png"></p><blockquote><p>这里 Go 也可以零代码埋点，是使用了 eBPF，本文暂不做介绍。</p></blockquote><p>对于支持自动埋点的语言就很简单，只需要配置下 agent 即可；而原生的 Go 语言不支持自动埋点就得手动使用 OpenTelemetry 提供的 SDK 处理一些关键步骤；总体来说也不算复杂。</p><p>下一期会重点讲解如何使用 Metrics。</p><p>感兴趣的朋友可以在这里查看 Go 相关的源码：</p><ul><li><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></li></ul><p>参考链接：</p><ul><li><a href="https://opentelemetry.io/docs/languages/java/configuration/">https://opentelemetry.io/docs/languages/java/configuration/</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md">https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md</a></li><li><a href="https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/">https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前写过一篇 &lt;a href=&quot;https://crossoverjie.top/2024/06/06/ob/OpenTelemetry-trace-concept/&quot;&gt;从 Dapper 到 OpenTelemetry：分布式追踪的演进之旅&lt;/a&gt;的文章，主要是从概念上讲解了 Trace 在 OpenTelemetry 的中的场景和使用。&lt;/p&gt;
&lt;p&gt;也写过一篇 &lt;a href=&quot;https://crossoverjie.top/2024/05/26/ob/OTel-demo/&quot;&gt;实操 OpenTelemetry：通过 Demo 掌握微服务监控的艺术&lt;/a&gt;：如何从一个 demo 开始集成 OpenTelemetry。&lt;/p&gt;
&lt;p&gt;但还是有不少小伙伴反馈说无法快速上手（可能也是这个 demo 的项目比较多），于是我准备从 0 开始从真实的代码一步步带大家集成 &lt;code&gt;OpenTelemetry&lt;/code&gt;，因为 OpenTelemetry 本身是跨多种语言的，所以也会以两种语言为（Java、Golang）主进行讲解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用这两种语言主要是因为 Java 几乎全是自动埋点，而 Golang 因为语言特性，大部分都得硬编码埋点；覆盖到这两种场景后其他语言也是类似的，顶多只是 API 名称有些许区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这个过程中也会穿插一些 OpenTelemetry 的原理，希望整个过程下来大家可以在项目中实际运用起来，同时也能知其所以然。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/categories/OB/OpenTelemetry/"/>
    
    
    <category term="OpenTelemetry" scheme="http://crossoverjie.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>深入理解单元测试：技巧与最佳实践</title>
    <link href="http://crossoverjie.top/2024/08/15/ob/unit-test/"/>
    <id>http://crossoverjie.top/2024/08/15/ob/unit-test/</id>
    <published>2024-08-15T02:43:09.000Z</published>
    <updated>2024-08-14T13:55:07.855Z</updated>
    
    <content type="html"><![CDATA[<p>之前分享过如何快速上手开源项目以及如何在开源项目里做集成测试，但还没有讲过具体的实操。</p><p>今天来详细讲讲如何写单元测试。</p><h1 id="🤔什么情况下需要单元测试"><a href="#🤔什么情况下需要单元测试" class="headerlink" title="🤔什么情况下需要单元测试"></a>🤔什么情况下需要单元测试</h1><p>这个大家应该是有共识的，对于一些功能单一、核心逻辑、同时变化不频繁的公开函数才有必要做单元测试。</p><p>对于业务复杂、链路繁琐但也是核心流程的功能通常建议做 e2e 测试，这样可以保证最终测试结果的一致性。</p><span id="more"></span><h1 id="💀具体案例"><a href="#💀具体案例" class="headerlink" title="💀具体案例"></a>💀具体案例</h1><p>我们都知道单测的主要目的是模拟执行你写过的每一行代码，目的就是要覆盖到主要分支，做到自己的每一行代码都心中有数。</p><p>下面以 <code>Apache HertzBeat</code> 的一些单测为例，讲解如何编写一个单元测试。</p><p><img src="https://s2.loli.net/2024/07/02/SbqCvHVZk6f5tB1.png"><br>先以一个最简单的 <code>org.apache.hertzbeat.collector.collect.udp.UdpCollectImpl#preCheck</code> 函数测试为例。<br>这里的 <code>preCheck</code> 函数就是简单的检测做参数校验。<br>测试时只要我们手动将 <code>metrics</code> 设置为 <code>null</code> 就可以进入这个 if 条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UdpCollectImplTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> UdpCollectImpl udpCollect;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testPreCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; aliasField = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        aliasField.add(<span class="string">&quot;responseTime&quot;</span>);</span><br><span class="line">        <span class="type">Metrics</span> <span class="variable">metrics</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Metrics</span>();</span><br><span class="line">        metrics.setAliasFields(aliasField);</span><br><span class="line">        assertThrows(IllegalArgumentException.class, () -&gt; udpCollect.preCheck(metrics));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>来看具体的单测代码，我们一行行的来看：</p><p><code>@ExtendWith(MockitoExtension.class)</code> 是 <code>Junit5</code> 提供的一个注解，里面传入的 <code>MockitoExtension.class</code> 是我们单测 mock 常用的框架。</p><p>简单来说就是告诉 <code>Junit5</code> ，当前的测试类会使用 mockito 作为扩展运行，从而可以 <code>mock</code> 我们运行时的一些对象。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InjectMocks</span>  </span><br><span class="line"><span class="keyword">private</span> UdpCollectImpl udpCollect;</span><br></pre></td></tr></table></figure><p><code>@InjectMocks</code> 也是 <code>mockito</code> 这个库提供的注解，通常用于声明需要测试的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InjectMocks</span>  </span><br><span class="line"><span class="keyword">private</span> AbstractCollect udpCollect;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/02/zSocET9f5y6lqC3.png"></p><p>需要注意的是这个注解必须是一个具体的类，不可以是一个抽象类或者是接口。</p><p>其实当我们了解了他的原理就能知道具体的原因：<br><img src="https://s2.loli.net/2024/07/02/5DwRyVsBHd1EmpA.png"></p><p>当我们 debug 运行时会发现 <code>udpCollect</code> 对象是有值的，而如果我们去掉这个注解 <code>@InjectMocks</code> 再运行就会抛空指针异常。</p><blockquote><p>因为并没有初始化 udpCollect</p></blockquote><p>而使用 <code>@InjectMocks</code>注解后，<code>mockito</code> 框架会自动给 <code>udpCollect</code> 注入一个代理对象；而如果是一个接口或者是抽象类，mockito 框架是无法知道创建具体哪个对象。</p><p>当然在这个简单场景下，我们直接 <code>udpCollect = new UdpCollectImpl()</code> 进行测试也是可以的。</p><h1 id="🔥配合-jacoco-输出单测覆盖率"><a href="#🔥配合-jacoco-输出单测覆盖率" class="headerlink" title="🔥配合 jacoco 输出单测覆盖率"></a>🔥配合 jacoco 输出单测覆盖率</h1><p><img src="https://s2.loli.net/2024/07/02/fgv3O4RbnHsQTWV.png"><br><img src="https://s2.loli.net/2024/07/02/coXOGkjyE2zKsYa.png"></p><p>在 IDEA 中我们可以以 <code>Coverage</code> 的方式运行，<code>IDEA</code> 就将我们的单测覆盖情况显示在源代码中，绿色的部分就代表在实际在运行时执行到的地方。</p><p>我们也可以在 <code>maven</code> 项目中集成 <code>jacoco</code>，只需要添加一个根目录的 <code>pom.xml</code> 中添加一个 <code>plugin</code> 就可以了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jacoco<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jacoco-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jacoco-maven-plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>prepare-agent<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>report<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>test<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>report<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后运行 <code>mvn test</code> 就会在 target 目录下生成测试报告了。</p><p><img src="https://s2.loli.net/2024/07/02/GiBrPjtLcXhgDbp.png"></p><p>我们还可以在 GitHub 的 CI 中集成 <code>Codecov</code>，他会直接读取 jacoco 的测试数据，并且在 PR 的评论区加上测试报告。<br><img src="https://s2.loli.net/2024/07/02/ujdGke4gf5mAW3x.png"></p><p><img src="https://s2.loli.net/2024/07/02/nFt5SukAjMPZ96W.png"></p><p><img src="https://s2.loli.net/2024/07/02/KcXJUs3mehxFAYz.png"></p><p>需要从 <code>Codecov</code> 里将你项目的 token 添加到 repo 的 环境变量中即可。</p><p>具体可以参考这个 PR：<a href="https://github.com/apache/hertzbeat/pull/1985">https://github.com/apache/hertzbeat/pull/1985</a></p><h1 id="☀️复杂一点的单测"><a href="#☀️复杂一点的单测" class="headerlink" title="☀️复杂一点的单测"></a>☀️复杂一点的单测</h1><p>刚才展示的是一个非常简单的场景，下面来看看稍微复杂的。</p><p>我们以这个单测为例：<br><code>org.apache.hertzbeat.collector.collect.redis.RedisClusterCollectImplTest</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClusterCollectImplTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> RedisCommonCollectImpl redisClusterCollect;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> StatefulRedisClusterConnection&lt;String, String&gt; connection;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> RedisAdvancedClusterCommands&lt;String, String&gt; cmd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> RedisClusterClient client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个单测在刚才的基础上多了一个 <code>@Mock</code> 的注解。</p><p>这是因为我们需要测试的 <code>RedisCommonCollectImpl</code> 类中需要依赖 <code>StatefulRedisClusterConnection/RedisAdvancedClusterCommands/RedisClusterClient</code> 这几个类所提供的服务。</p><p>单测的时候需要使用 <code>mockito</code> 创建一个他们的对象，并且注入到需要被测试的 <code>RedisCommonCollectImpl</code>类中。</p><blockquote><p>不然我们就需要准备单测所需要的资源，比如可以使用的 Redis、MySQL 等。</p></blockquote><h2 id="🚤模拟行为"><a href="#🚤模拟行为" class="headerlink" title="🚤模拟行为"></a>🚤模拟行为</h2><p>只是注入进去还不够，我们还需要模拟它的行为：</p><ul><li>比如调用某个函数可以模拟返回数据</li><li>模拟函数调用抛出异常</li><li>模拟函数调用耗时</li></ul><p>这里以最常见的模拟函数返回为例：</p><p><img src="https://s2.loli.net/2024/07/02/3lnFxsQmcWqao5u.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">clusterNodes</span> <span class="operator">=</span> connection.sync().clusterInfo();</span><br></pre></td></tr></table></figure><p>在源码里看到会使用 connection 的 <code>clusterInfo()</code> 函数返回集群信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">clusterKnownNodes</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">clusterInfoTemp</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        cluster_slots_fail:0</span></span><br><span class="line"><span class="string">        cluster_known_nodes:%s</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">clusterInfo</span> <span class="operator">=</span> String.format(clusterInfoTemp, clusterKnownNodes);</span><br><span class="line">Mockito.when(cmd.clusterInfo()).thenReturn(clusterInfo);        </span><br></pre></td></tr></table></figure><p>此时我们就可以使用 <code>Mockito.when().thenReturn()</code> 来模拟这个函数的返回数据。</p><p>而其中的 <code>cmd</code> 自然也是需要模拟返回的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Mockito.mockStatic(RedisClusterClient.class).when(()-&gt;RedisClusterClient.create(Mockito.any(ClientResources.class),</span><br><span class="line">        Mockito.any(RedisURI.class))).thenReturn(client);</span><br><span class="line">Mockito.when(client.connect()).thenReturn(connection);</span><br><span class="line"></span><br><span class="line">Mockito.when(connection.sync()).thenReturn(cmd);</span><br><span class="line">Mockito.when(cmd.info(metrics.getName())).thenReturn(info);</span><br><span class="line">Mockito.when(cmd.clusterInfo()).thenReturn(clusterInfo);</span><br></pre></td></tr></table></figure><p><code>cmd</code> 是通过 <code>Mockito.when(connection.sync()).thenReturn(cmd);</code>返回的，而 <code>connection</code> 又是从 <code>client.connect()</code> 返回的。</p><p>最终就像是套娃一样，<code>client</code> 在源码中是通过一个静态函数创建的。</p><h3 id="⚡模拟静态函数"><a href="#⚡模拟静态函数" class="headerlink" title="⚡模拟静态函数"></a>⚡模拟静态函数</h3><p>我依稀记得在我刚接触 <code>mockito</code> 的 16～17 年那段时间还不支持模拟调用静态函数，不过如今已经支持了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mock</span>  </span><br><span class="line"><span class="keyword">private</span> RedisClusterClient client;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mockito.mockStatic(RedisClusterClient.class).when(()-&gt;RedisClusterClient.create(Mockito.any(ClientResources.class),  </span><br><span class="line">        Mockito.any(RedisURI.class))).thenReturn(client);</span><br></pre></td></tr></table></figure><p>这样就可以模拟静态函数的返回值了，但前提是返回的 <code>client</code> 需要使用 <code>@Mock</code> 注解。</p><h3 id="💥模拟构造函数"><a href="#💥模拟构造函数" class="headerlink" title="💥模拟构造函数"></a>💥模拟构造函数</h3><p><img src="https://s2.loli.net/2024/07/02/aFiCLRyYh4IU83o.png"><br>有时候我们也需要模拟构造函数，从而可以模拟后续这个对象的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MockedConstruction&lt;FTPClient&gt; mocked = Mockito.mockConstruction(FTPClient.class,</span><br><span class="line">        (ftpClient, context) -&gt; &#123;</span><br><span class="line">            Mockito.doNothing().when(ftpClient).connect(ftpProtocol.getHost(),</span><br><span class="line">                    Integer.parseInt(ftpProtocol.getPort()));</span><br><span class="line"></span><br><span class="line">            Mockito.doAnswer(invocationOnMock -&gt; <span class="literal">true</span>).when(ftpClient)</span><br><span class="line">                    .login(ftpProtocol.getUsername(), ftpProtocol.getPassword());</span><br><span class="line">            Mockito.when(ftpClient.changeWorkingDirectory(ftpProtocol.getDirection())).thenReturn(isActive);</span><br><span class="line">            Mockito.doNothing().when(ftpClient).disconnect();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>可以使用 <code>Mockito.mockConstruction</code> 来进行模拟，该对象的一些行为就直接写在这个模拟函数内。</p><p>需要注意的是返回的 <code>mocked</code> 对象需要记得关闭。</p><h3 id="不需要-Mock"><a href="#不需要-Mock" class="headerlink" title="不需要 Mock"></a>不需要 Mock</h3><p>当然也不是所有的场景都需要 <code>mock</code>。</p><p>比如刚才第一个场景，没有依赖任何外部服务时就不需要 <code>mock</code>。</p><p><img src="https://s2.loli.net/2024/07/02/mW3gxERBc4qoz2L.png"></p><p>类似于这个 <a href="https://github.com/apache/hertzbeat/pull/2021">PR</a> 里的测试，只是依赖一个基础的内存缓存组件，就没必要 mock，但如果依赖的是 <code>Redis</code> 缓存组件还是需要 mock 的。<br><a href="https://github.com/apache/hertzbeat/pull/2021">https://github.com/apache/hertzbeat/pull/2021</a></p><h3 id="⚙️修改源码"><a href="#⚙️修改源码" class="headerlink" title="⚙️修改源码"></a>⚙️修改源码</h3><p>如果有些测试场景下需要获取内部变量方便后续的测试，但是该测试类也没有提供获取变量的函数，我们就只有修改源码来配合测试了。</p><p>比如这个 <a href="https://github.com/apache/hertzbeat/pull/">PR</a>：<br><img src="https://s2.loli.net/2024/07/02/bxfQgsymWVcnawE.png"></p><p>当然如果只是给测试环境下使用的函数或变量，我们可以加上 <code>@VisibleForTesting</code>注解标明一下，这个注解没有其他作用，可以让后续的维护者更清楚的知道这是做什么用的。</p><h1 id="📈集成测试"><a href="#📈集成测试" class="headerlink" title="📈集成测试"></a>📈集成测试</h1><p>单元测试只能测试一些功能单一的函数，要保证整个软件的质量仅依赖单测是不够的，我们还需要集成测试。</p><p>通常是需要对外提供服务的开源项目都需要集成测试：</p><ul><li>Pulsar</li><li>Kafka</li><li>Dubbo 等</li></ul><p>以我接触到的服务型应用主要分为两类：一个是 Java 应用一个是 Golang 应用。</p><h1 id="🐳Golang"><a href="#🐳Golang" class="headerlink" title="🐳Golang"></a>🐳Golang</h1><p><img src="https://s2.loli.net/2024/07/11/vZISu9Qg3foKhsU.png"></p><p><code>Golang</code> 因为工具链没有 Java 那么强大，所以大部分的集成测试的功能都是通过编写 Makefile 和 shell 脚本实现的。</p><p>还是以我熟悉的 Pulsar 的 <code>go-client</code> 为例，它在 GitHub 的集成测试是通过 GitHub action 触发的，定义如下：<br><img src="https://s2.loli.net/2024/05/20/f2196pujo8m7KRe.png"><br>最终调用的是 Makefile 中的 test 命令，并且把需要测试的 Golang 版本传入进去。</p><p><img src="https://s2.loli.net/2024/05/20/YpwtSHnLXqU1xQj.png"></p><p><code>Dockerfile</code>：<br><img src="https://s2.loli.net/2024/05/20/1ySGWF46U7EC2rk.png"></p><p>这个镜像简单来说就是将 Pulsar 的镜像作为基础运行镜像（这里面包含了 Pulsar 的服务端），然后将这个 pulsar-client-go 的代码复制进去编译。</p><p>接着运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /pulsar/pulsar-client-go &amp;&amp; ./scripts/run-ci.sh</span><br></pre></td></tr></table></figure><p>也就是测试脚本。</p><p><img src="https://s2.loli.net/2024/05/20/2Afmdu8ozRvH9FC.png"></p><p>测试脚本的逻辑也很简单：</p><ul><li>启动 pulsar 服务端</li><li>运行测试代码<br>因为所有的测试代码里连接服务端的地址都是 <code>localhost</code>，所以可以直接连接。<br><img src="https://s2.loli.net/2024/05/20/C1RHxTkuz25Mlj8.png"></li></ul><p>通过这里的 <a href="https://github.com/apache/pulsar-client-go/actions/runs/9014510238/job/24768797555">action</a> 日志可以跟踪所有的运行情况。</p><h1 id="☕Java"><a href="#☕Java" class="headerlink" title="☕Java"></a>☕Java</h1><p><img src="https://s2.loli.net/2024/07/11/KlqzSwJ6f895A4n.png"></p><p>Java 因为工具链强大，所以集成测试几乎不需要用 Makefile 和脚本配合执行。</p><p>还是以 Pulsar 为例，它的集成测试是需要模拟在本地启动一个服务端（因为 Pulsar 的服务端源码和测试代码都是 Java 写的，更方便做测试），然后再运行测试代码。</p><blockquote><p>这个的好处是任何一个单测都可以在本地直接运行，而  Go 的代码还需要先在本地启动一个服务端，测试起来比较麻烦。</p></blockquote><p>来看看它是如何实现的，我以其中一个 <a href="https://github.com/apache/pulsar/blob/631b13ad23d7e48c6e82d38f97c23d129062cb7c/pulsar-broker/src/test/java/org/apache/pulsar/client/impl/BrokerClientIntegrationTest.java#L117">BrokerClientIntegrationTest</a>为例：<br><img src="https://s2.loli.net/2024/05/20/9PbioA3RQLMBy6J.png"><br><img src="https://s2.loli.net/2024/05/20/blKePdxTUIkgRD3.png"><br>会在单测启动的时候先启动服务端。</p><p><img src="https://s2.loli.net/2024/05/20/gzY3lyTGuEDUwZF.png"></p><p>最终会调用 <code>PulsarTestContext</code> 的 <code>build</code> 函数启动 <code>broker</code>（服务端），而执行单测也只需要使用 <code>mvn test</code> 就可以自动触发这些单元测试。<br><img src="https://s2.loli.net/2024/05/20/N15amZihWI73Qyw.png"><br>只是每一个单测都需要启停服务端，所以要把 Pulsar 的所有单测跑完通常需要 1～2 个小时。</p><p>以上就是日常编写单测可能会碰到的场景，希望对大家有所帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前分享过如何快速上手开源项目以及如何在开源项目里做集成测试，但还没有讲过具体的实操。&lt;/p&gt;
&lt;p&gt;今天来详细讲讲如何写单元测试。&lt;/p&gt;
&lt;h1 id=&quot;🤔什么情况下需要单元测试&quot;&gt;&lt;a href=&quot;#🤔什么情况下需要单元测试&quot; class=&quot;headerlink&quot; title=&quot;🤔什么情况下需要单元测试&quot;&gt;&lt;/a&gt;🤔什么情况下需要单元测试&lt;/h1&gt;&lt;p&gt;这个大家应该是有共识的，对于一些功能单一、核心逻辑、同时变化不频繁的公开函数才有必要做单元测试。&lt;/p&gt;
&lt;p&gt;对于业务复杂、链路繁琐但也是核心流程的功能通常建议做 e2e 测试，这样可以保证最终测试结果的一致性。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="单测" scheme="http://crossoverjie.top/tags/%E5%8D%95%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>Pulsar升级自动化：一键搞定集群升级与测试</title>
    <link href="http://crossoverjie.top/2024/08/06/ob/Pulsar%20test%20framework/"/>
    <id>http://crossoverjie.top/2024/08/06/ob/Pulsar%20test%20framework/</id>
    <published>2024-08-06T03:15:50.000Z</published>
    <updated>2024-08-06T02:22:27.446Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/07/01/xZSMlpJPWTRGkge.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于我在公司内部负责维护 <code>Pulsar</code>，需要时不时的升级 <code>Pulsar</code> 版本从而和社区保持一致。</p><p>而每次升级过程都需要做相同的步骤：</p><ul><li>安装一个新版本的集群</li><li>触发功能性测试</li><li>触发性能测试</li><li>查看监控是否正常<ul><li>应用有无异常日志</li><li>流量是否正常</li><li>各个组件的内存占用是否正常</li><li>写入延迟是否正常</li></ul></li></ul><span id="more"></span><h1 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><p>以上的流程步骤最好是全部一键完成，我们只需要人工检测下监控是否正常即可。</p><p>于是我便写了一个命令行工具，执行流程如下：<br><img src="https://s2.loli.net/2024/07/01/cmXCqk6nyj2DpZA.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pulsar-upgrade-cli -h                                                                                                  ok | at 10:33:18 </span><br><span class="line">A cli app for upgrading Pulsar</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  pulsar-upgrade-cli [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  completion  Generate the autocompletion script for the specified shell</span><br><span class="line">  help        Help about any command</span><br><span class="line">  install     install a target version</span><br><span class="line">  scale       scale statefulSet of the cluster</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">      --burst-limit int                 client-side default throttling limit (default 100)</span><br><span class="line">      --debug                           enable verbose output</span><br><span class="line">  -h, --help                            help for pulsar-upgrade-cli</span><br><span class="line">      --kube-apiserver string           the address and the port for the Kubernetes API server</span><br><span class="line">      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.</span><br><span class="line">      --kube-as-user string             username to impersonate for the operation</span><br></pre></td></tr></table></figure><p>真实使用的 <code>example</code> 如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pulsar-upgrade-cli install \                                                   </span><br><span class="line">        --values ./charts/pulsar/values.yaml \</span><br><span class="line">        --set namespace=pulsar-test \</span><br><span class="line">        --set initialize=true \</span><br><span class="line">        --debug \</span><br><span class="line">        --test-case-schema=http \</span><br><span class="line">        --test-case-host=127.0.0.1 \</span><br><span class="line">        --test-case-port=9999 \</span><br><span class="line">    pulsar-test ./charts/pulsar -n pulsar-test</span><br></pre></td></tr></table></figure><p>它的安装命令非常类似于 <code>helm</code>，也是直接使用 helm 的 <code>value.yaml</code> 进行安装；只是在安装成功后（等待所有的 Pod 都处于 Running 状态）会再触发 test-case 测试，也就是请求一个 endpoint。</p><blockquote><p>这个 endpoint 会在内部处理所有的功能测试和性能测试，具体细节就在后文分析。</p></blockquote><p>同时还提供了一个 scale（扩、缩容） 命令，可以用修改集群规模：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缩容集群规模为0</span></span><br><span class="line">./pulsar-upgrade-cli scale --replicase 0 -n pulsar-test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缩容为最小集群</span></span><br><span class="line">./pulsar-upgrade-cli scale --replicase 1 -n pulsar-test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复为最满集群</span></span><br><span class="line">./pulsar-upgrade-cli scale --replicase 2 -n pulsar-test</span><br></pre></td></tr></table></figure><p>这个需求是因为我们的 <code>Pulsar</code> 测试集群部署在了一个 <code>servless</code> 的 <code>kubernetes</code> 集群里，它是按照使用量收费的，所以在我不需要的使用的时候可以通过这个命令将所有的副本数量修改为 0，从而减少使用成本。</p><p>当只需要做简单的功能测试时便回将集群修改为最小集群，将副本数修改为只可以提供服务即可。</p><p>而当需要做性能测试时就需要将集群修改为最高配置。</p><p>这样可以避免每次都安装新集群，同时也可以有效的减少测试成本。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">require (  </span><br><span class="line">    github.com/spf13/cobra v1<span class="number">.6</span><span class="number">.1</span>  </span><br><span class="line">    github.com/spf13/pflag v1<span class="number">.0</span><span class="number">.5</span>   </span><br><span class="line">    helm.sh/helm/v3 v3<span class="number">.10</span><span class="number">.2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个命令行工具本质上是参考了 helm 的命令行实现的，所有主要也是依赖了 <code>helm</code> 和 <code>cobra</code>。</p><p><img src="https://s2.loli.net/2024/07/01/rouTSUBDIWciElx.png"><br>下面以最主要的安装命令为例，核心的是以下的步骤：</p><ul><li>执行 <code>helm</code> 安装（这里是直接使用的 helm 的源码逻辑进行安装）</li><li>等待所有的 <code>Pod</code> 成功运行</li><li>触发 <code>test-case</code> 执行</li><li>等待测试用例执行完毕</li><li>检测是否需要卸载安装的集群</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *installEvent)</span></span> FinishInstall(cfg *action.Configuration, name <span class="type">string</span>) <span class="type">error</span> &#123;  </span><br><span class="line">    bar.Increment()  </span><br><span class="line">    bar.Finish()  </span><br><span class="line">  </span><br><span class="line">    clientSet, err := cfg.KubernetesClientSet()  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> err  </span><br><span class="line">    &#125;  </span><br><span class="line">    ctx := context.Background()  </span><br><span class="line">    ip, err := GetServiceExternalIp(ctx, clientSet, settings.Namespace(), fmt.Sprintf(<span class="string">&quot;%s-proxy&quot;</span>, name))  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> err  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    token, err := GetPulsarProxyToken(ctx, clientSet, settings.Namespace(), fmt.Sprintf(<span class="string">&quot;%s-token-proxy-admin&quot;</span>, name))  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> err  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// trigger testcase  </span></span><br><span class="line">    err = e.client.Trigger(context.Background(), ip, token)  </span><br><span class="line">    <span class="keyword">return</span> err  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>FinishInstall</code> 需要获取到新安装的 Pulsar 集群的 proxy IP 地址和鉴权所使用的 <code>token</code>(<code>GetServiceExternalIp()</code>&#x2F;<code>GetPulsarProxyToken()</code>)。</p><p>将这两个参数传递给 <code>test-case</code> 才可以构建出 <code>pulsar-client</code>.</p><p>这个命令的核心功能就是安装集群和触发测试，以及一些集群的基本运维能力。</p><h1 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h1><p>而关于这里的测试用例也有一些小伙伴咨询过，如何对 Pulsar 进行功能测试。</p><p>其实 Pulsar 源码中已经包含了几乎所有我们会使用到的测试代码，理论上只要新版本的官方镜像已经推送了那就是跑了所有的单测，质量是可以保证的。</p><p>那为什么还需要做功能测试呢？</p><p>其实很很简单，<code>Pulsar</code> 这类基础组件官方都有提供基准测试，但我们想要用于生产环境依然需要自己做压测得出一份属于自己环境下的性能测试报告；</p><p>根本目的是要看在自己的业务场景下是否可以满足（包括公司的软硬件，不同的业务代码）。</p><p>所以这里的功能测试代码有一个很重要的前提就是：<strong>需要使用真实的业务代码进行测试</strong>。</p><p>也就是业务在线上使用与 Pulsar 相关的代码需要参考功能测试里的代码实现，不然有些问题就无法在测试环节覆盖到。</p><blockquote><p>这里我就踩过坑，因为在功能测试里用的是官方的 example 代码进行测试的，自然是没有问题；但业务在实际使用时，使用到了一个 Schema 的场景，并没有在功能测试里覆盖到（官方的测试用例里也没有😂），就导致升级到某个版本后业务功能无法正常使用（虽然用法确实是有问题），但应该在我测试阶段就暴露出来。</p></blockquote><h2 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h2><p><img src="https://s2.loli.net/2024/07/01/3vZiGABjkYh5LUJ.png"><br>以上是一个集群的功能测试报告，这里我只有 8 个测试场景（结合实际业务使用），考虑到未来可能会有新的测试用例，所以在设计这个测试框架时就得考虑到扩展性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job5</span> <span class="operator">=</span>  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FailoverConsumerTest</span>(event, <span class="string">&quot;故障转移消费测试&quot;</span>, pulsarClient, <span class="number">20</span>, admin);  </span><br><span class="line">CompletableFuture&lt;Void&gt; c5 = CompletableFuture.runAsync(job5::start, EXECUTOR);  </span><br><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchemaTest</span>(event,<span class="string">&quot;schema测试&quot;</span>,pulsarClient,<span class="number">20</span>,prestoService);  </span><br><span class="line">CompletableFuture&lt;Void&gt; c6 = CompletableFuture.runAsync(job6::start, EXECUTOR);  </span><br><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VlogsTest</span>(event,<span class="string">&quot;vlogs test&quot;</span>,pulsarClient,<span class="number">20</span>, vlogsUrl);  </span><br><span class="line">CompletableFuture&lt;Void&gt; c7 = CompletableFuture.runAsync(job7::start, EXECUTOR);  </span><br><span class="line">  </span><br><span class="line">CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(c1, c2, c3, c4, c5, c6, c7);  </span><br><span class="line">all.whenComplete((___, __) -&gt; &#123;  </span><br><span class="line">    event.finishAll();  </span><br><span class="line">    pulsarClient.closeAsync();  </span><br><span class="line">    admin.close();  </span><br><span class="line">&#125;).get();</span><br></pre></td></tr></table></figure><p>对外提供的 trigger 接口就不贴代码了，重点就是在这里构建测试任务，然后等待他们全部执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractJobDefine</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Event event;</span><br><span class="line">    <span class="keyword">private</span> String jobName;</span><br><span class="line">    <span class="keyword">private</span> PulsarClient pulsarClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PulsarAdmin admin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractJobDefine</span><span class="params">(Event event, String jobName, PulsarClient pulsarClient, <span class="type">int</span> timeout, PulsarAdmin admin)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.event = event;</span><br><span class="line">        <span class="built_in">this</span>.jobName = jobName;</span><br><span class="line">        <span class="built_in">this</span>.pulsarClient = pulsarClient;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.admin = admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        event.addJob();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">                <span class="type">StopWatch</span> <span class="variable">watch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    watch.start(jobName);</span><br><span class="line">                    run(pulsarClient, admin);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    event.oneException(<span class="built_in">this</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    watch.stop();</span><br><span class="line">                    event.finishOne(jobName, StrUtil.format(<span class="string">&quot;cost: &#123;&#125;s&quot;</span>, watch.getTotalTimeSeconds()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, TestCase.EXECUTOR).get(timeout, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            event.oneException(<span class="built_in">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** run busy code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pulsarClient pulsar client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> admin pulsar admin client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(PulsarClient pulsarClient, PulsarAdmin admin)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码就是这个抽象的任务定义类，其中的 start 函数用于定义任务执行的模版：</p><ul><li>添加任务：具体实现是任务计数器+1</li><li>开始计时</li><li>执行抽血的 run 函数，具体实现交给子类</li><li>异常时记录事件</li><li>正常执行完毕后也记录事件</li></ul><p>下面来看一个普通用例的实现情况：<br><img src="https://s2.loli.net/2024/07/01/rdU5mPbfOJxv4TL.png"></p><p>就是重写了 <code>run()</code> 函数，然后在其中实现具体的测试用例，断言测试结果。</p><p>这样当我们需要再添加用例的时候只需要再新增一个子类实现即可。</p><p>同时还需要定义一个事件接口，用于处理一些关键的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Event</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 新增一个任务  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addJob</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 获取运行中的任务数量  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取运行中的任务数量  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    TestCaseRuntimeResponse <span class="title function_">getRuntime</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 单个任务执行完毕  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobName    任务名称  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> finishCost 任务完成耗时  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">finishOne</span><span class="params">(String jobName, String finishCost)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**单个任务执行异常  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobDefine 任务  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 异常  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">oneException</span><span class="params">(AbstractJobDefine jobDefine, Exception e)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 所有任务执行完毕  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">finishAll</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>getRuntime</code> 接口是用于在 cli 那边查询任务是否执行完毕的接口，只有任务执行完毕之后才能退出 <code>cli</code>。</p><h1 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h1><p>当这些任务运行完毕后我们需要重点查看应用客户端和 Pulsar broker 端是否有异常日志。</p><p>同时还需要观察一些关键的监控面板：</p><p><img src="https://s2.loli.net/2024/07/01/sGxOjRWnScPl5oZ.png"><br><img src="https://s2.loli.net/2024/07/01/E6hcSxHrRmNVFoi.png"><br><img src="https://s2.loli.net/2024/07/01/UeFZ73yRbpkAsEH.png"></p><p>包含但不限于：</p><ul><li>消息吞吐量</li><li><code>broker</code> 写入延迟</li><li><code>Bookkeeper</code> 的写入、读取成功率，以及延迟。</li></ul><p>当然还有 <code>zookeeper</code> 的运行情况也需要监控，限于篇幅就不一一粘贴了。</p><p>以上就是测试整个 Pulsar 集群的流程，当然还有一些需要优化的地方。</p><p>比如使用命令行还是有些不便，后续可能会切换到网页上就可以操作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/07/01/xZSMlpJPWTRGkge.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;由于我在公司内部负责维护 &lt;code&gt;Pulsar&lt;/code&gt;，需要时不时的升级 &lt;code&gt;Pulsar&lt;/code&gt; 版本从而和社区保持一致。&lt;/p&gt;
&lt;p&gt;而每次升级过程都需要做相同的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装一个新版本的集群&lt;/li&gt;
&lt;li&gt;触发功能性测试&lt;/li&gt;
&lt;li&gt;触发性能测试&lt;/li&gt;
&lt;li&gt;查看监控是否正常&lt;ul&gt;
&lt;li&gt;应用有无异常日志&lt;/li&gt;
&lt;li&gt;流量是否正常&lt;/li&gt;
&lt;li&gt;各个组件的内存占用是否正常&lt;/li&gt;
&lt;li&gt;写入延迟是否正常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>Pulsar客户端消费模式揭秘：Go 语言实现 ZeroQueueConsumer</title>
    <link href="http://crossoverjie.top/2024/07/29/ob/pulsar-client-zero-consumer/"/>
    <id>http://crossoverjie.top/2024/07/29/ob/pulsar-client-zero-consumer/</id>
    <published>2024-07-29T14:31:57.000Z</published>
    <updated>2024-07-29T03:08:42.394Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在 <a href="https://github.com/apache/pulsar-client-go">pulsar-client-go</a> 社区里看到这么一个 <a href="https://github.com/apache/pulsar-client-go/issues/1223">issue</a>：<br><img src="https://s2.loli.net/2024/06/24/KNsvV7jeZYSaiPq.png"></p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/apache/pulsar-client-go/pulsar&quot;</span></span><br><span class="line"></span><br><span class="line">client, err := pulsar.NewClient(pulsar.ClientOptions&#123;</span><br><span class="line">    URL: <span class="string">&quot;pulsar://localhost:6650&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">consumer, err := client.Subscribe(pulsar.ConsumerOptions&#123;</span><br><span class="line">    Topic:             <span class="string">&quot;persistent://public/default/mq-topic-1&quot;</span>,</span><br><span class="line">    SubscriptionName:  <span class="string">&quot;sub-1&quot;</span>,</span><br><span class="line">    Type:              pulsar.Shared,</span><br><span class="line">    ReceiverQueueSize: <span class="number">0</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小于等于 0 时会设置为 1000</span></span><br><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">    defaultReceiverQueueSize = <span class="number">1000</span>  </span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> options.ReceiverQueueSize &lt;= <span class="number">0</span> &#123;  </span><br><span class="line">    options.ReceiverQueueSize = defaultReceiverQueueSize  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他发现手动将 pulsar-client-go 客户端的 <code>ReceiverQueueSize</code> 设置为 0 的时候，客户端在初始化时会再将其调整为 1000.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> options.ReceiverQueueSize &lt; <span class="number">0</span> &#123;  </span><br><span class="line">    options.ReceiverQueueSize = defaultReceiverQueueSize  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果手动将源码修改为可以设置为 0 时，却不能正常消费，消费者会一直处于 waiting 状态，获取不到任何数据。</p><p>经过我的排查发现是 Pulsar 的  Go  客户端缺少了一个 <a href="https://github.com/apache/pulsar/blob/83b86abcb74595d7e8aa31b238a7dbb19a04dde2/pulsar-client/src/main/java/org/apache/pulsar/client/impl/ConsumerImpl.java#L268-L272">ZeroQueueConsumerImpl</a>的实现类，这个类主要用于可以精细控制消费逻辑。</p><blockquote><p>If you’d like to have tight control over message dispatching across consumers, set the <strong>consumers’ receiver queue size very low (potentially even to 0 if necessary)</strong>. Each consumer has a receiver queue that determines how many messages the consumer attempts to fetch at a time. For example, a receiver queue of 1000 (the default) means that the consumer attempts to process 1000 messages from the topic’s backlog upon connection. Setting the receiver queue to 0 essentially means ensuring that each consumer is only doing one thing at a time.</p></blockquote><p><a href="https://pulsar.apache.org/docs/next/cookbooks-message-queue/#client-configuration-changes">https://pulsar.apache.org/docs/next/cookbooks-message-queue/#client-configuration-changes</a></p><p>正如官方文档里提到的那样，可以将 ReceiverQueueSize 设置为 0；这样消费者就可以一条条的消费数据，而不会将消息堆积在客户端队列里。</p><h1 id="客户端消费逻辑"><a href="#客户端消费逻辑" class="headerlink" title="客户端消费逻辑"></a>客户端消费逻辑</h1><p>借此机会需要再回顾下 pulsar 客户端的消费逻辑，这样才能理解 <code>ReceiverQueueSize</code> 的作用以及如何在 pulsar-client-go 如何实现这个 <code>ZeroQueueConsumerImpl</code>。</p><p>Pulsar 客户端的消费模式是基于推拉结合的：</p><p><img src="https://s2.loli.net/2024/06/24/bTP1WGVJUR9wzYe.png"><br>如这张图所描述的流程，消费者在启动的时候会主动向服务端发送一个 Flow 的命令，告诉服务端需要下发多少条消息给客户端。</p><p>同时会使用刚才的那个 <code>ReceiverQueueSize</code>参数作为内部队列的大小，将客户端下发的消息存储在内部队列里。</p><p>然后在调用 <code>receive</code> 函数的时候会直接从这个队列里获取数据。</p><p><img src="https://s2.loli.net/2024/06/24/e3AabLk4FqB8VTo.png"><br><img src="https://s2.loli.net/2024/06/24/ZGHiaXBJfEyxh5d.png"></p><p>每次消费成功后都会将内部的一个 <code>AvailablePermit+1</code>，直到大于 <code>MaxReceiveQueueSize / 2</code> 就会再次向 broker 发送 flow 命令，告诉 broker 再次下发消息。</p><p>所以这里有一个很关键的事件：就是向 broker 发送 <code>flow</code> 命令，这样才会有新的消息下发给客户端。</p><p>之前经常都会有研发同学让我排查无法消费的问题，最终定位到的原因几乎都是消费缓慢，导致这里的 <code>AvailablePermit</code> 没有增长，从而也就不会触发 broker 给客户端推送新的消息。</p><p>看到的现象就是消费非常缓慢。</p><h1 id="ZeroQueueConsumerImpl-原理"><a href="#ZeroQueueConsumerImpl-原理" class="headerlink" title="ZeroQueueConsumerImpl 原理"></a>ZeroQueueConsumerImpl 原理</h1><p>下面来看看 <code>ZeroQueueConsumerImpl</code> 是如何实现队列大小为 0 依然是可以消费的。</p><p><img src="https://s2.loli.net/2024/06/24/Vmk9l2nucP31bNX.png"><br>在构建 consumer 的时候，就会根据队列大小从而来创建普通消费者还是 <code>ZeroQueueConsumerImpl</code> 消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">protected</span> CompletableFuture&lt;Message&lt;T&gt;&gt; <span class="title function_">internalReceiveAsync</span><span class="params">()</span> &#123;  </span><br><span class="line">    CompletableFuture&lt;Message&lt;T&gt;&gt; future = <span class="built_in">super</span>.internalReceiveAsync();  </span><br><span class="line">    <span class="keyword">if</span> (!future.isDone()) &#123;  </span><br><span class="line">        <span class="comment">// We expect the message to be not in the queue yet  </span></span><br><span class="line">        increaseAvailablePermits(cnx());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> future;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 <code>ZeroQueueConsumerImpl</code> 重写的一个消费函数，其中关键的就是 <code>increaseAvailablePermits(cnx());</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">increaseAvailablePermits</span><span class="params">(ClientCnx currentCnx)</span> &#123;</span><br><span class="line">    increaseAvailablePermits(currentCnx, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">increaseAvailablePermits</span><span class="params">(ClientCnx currentCnx, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> AVAILABLE_PERMITS_UPDATER.addAndGet(<span class="built_in">this</span>, delta);</span><br><span class="line">    <span class="keyword">while</span> (available &gt;= getCurrentReceiverQueueSize() / <span class="number">2</span> &amp;&amp; !paused) &#123;</span><br><span class="line">        <span class="keyword">if</span> (AVAILABLE_PERMITS_UPDATER.compareAndSet(<span class="built_in">this</span>, available, <span class="number">0</span>)) &#123;</span><br><span class="line">            sendFlowPermitsToBroker(currentCnx, available);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            available = AVAILABLE_PERMITS_UPDATER.get(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码里可以得知这里的逻辑就是将 AvailablePermit 自增，达到阈值后请求 broker 下发消息。</p><p>因为在 <code>ZeroQueueConsumerImpl</code> 中队列大小为 0，所以 <code>available &gt;= getCurrentReceiverQueueSize() / 2</code>永远都会为 true。</p><p>也就是说每消费一条消息都会请求 broker 让它再下发一条消息，这样就达到了每一条消息都精确控制的效果。</p><h1 id="pulsar-client-go-中的实现"><a href="#pulsar-client-go-中的实现" class="headerlink" title="pulsar-client-go 中的实现"></a>pulsar-client-go 中的实现</h1><p>为了在 pulsar-client-go 实现这个需求，我提交了一个 <a href="https://github.com/apache/pulsar-client-go/pull/1225">PR</a> 来解决这个问题。</p><p>其实从上面的分析已经得知为啥手动将 <code>ReceiverQueueSize</code> 设置为 0 无法消费消息了。</p><p>根本原因还是在初始化的时候优于队列为 0，导致不会给 broker 发送 flow 命令，这样就不会有消息推送到客户端，也就无法消费到数据了。</p><p>所以我们依然得参考 Java 的 <code>ZeroQueueConsumerImpl</code> 在每次消费的时候都手动增加  <code>availablePermits</code>。</p><p>为此我也新增了一个消费者 <code>zeroQueueConsumer</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EnableZeroQueueConsumer, if enabled, the ReceiverQueueSize will be 0.  </span></span><br><span class="line"><span class="comment">// Notice: only non-partitioned topic is supported.  </span></span><br><span class="line"><span class="comment">// Default is false.  </span></span><br><span class="line">EnableZeroQueueConsumer <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">consumer, err := client.Subscribe(ConsumerOptions&#123;  </span><br><span class="line">    Topic:                   topicName,  </span><br><span class="line">    SubscriptionName:        <span class="string">&quot;sub-1&quot;</span>,  </span><br><span class="line">    Type:                    Shared,  </span><br><span class="line">    NackRedeliveryDelay:     <span class="number">1</span> * time.Second,  </span><br><span class="line">    EnableZeroQueueConsumer: <span class="literal">true</span>,  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> options.EnableZeroQueueConsumer &#123;  </span><br><span class="line">    options.ReceiverQueueSize = <span class="number">0</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建消费者的时候需要指定是否开启 <code>ZeroQueueConsumer</code>，当开启后会手动将 ReceiverQueueSize 设置为 0.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以设置默认值。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">receiverQueueSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在 Go 中无法像 Java 那样在结构体初始化化的时候就指定默认值，再加上 Go 的 int 类型具备零值（也就是0），所以无法区分出 ReceiverQueueSize&#x3D;0 是用户主动设置的，还是没有传入这个参数使用的零值。</p></blockquote><p>所以才需要新增一个参数来手动区分是否使用 <code>ZeroQueueConsumer</code>。</p><p><img src="https://s2.loli.net/2024/06/24/TK2fJVEFlnL4dIy.png"><br>之后在创建 <code>consumer</code> 的时候进行判断，只有使用的是单分区的 <code>topic</code> 并且开启了 <code>EnableZeroQueueConsumer</code> 才能创建  <code>zeroQueueConsumer</code>。</p><hr><p><img src="https://s2.loli.net/2024/06/24/Aq5onPKOjIgserx.png"></p><blockquote><p>使用 PARTITIONED_METADATA 命令可以让 broker 返回分区数量。</p></blockquote><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *zeroQueueConsumer)</span></span> Receive(ctx context.Context) (Message, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> state := z.pc.getConsumerState(); state == consumerClosed || state == consumerClosing &#123;</span><br><span class="line">z.log.WithField(<span class="string">&quot;state&quot;</span>, state).Error(<span class="string">&quot;Failed to ack by closing or closed consumer&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;consumer state is closed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">z.Lock()</span><br><span class="line"><span class="keyword">defer</span> z.Unlock()</span><br><span class="line">z.pc.availablePermits.inc()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-z.closeCh:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, newError(ConsumerClosed, <span class="string">&quot;consumer closed&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> cm, ok := &lt;-z.messageCh:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, newError(ConsumerClosed, <span class="string">&quot;consumer closed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cm.Message, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的关键代码：<code>z.pc.availablePermits.inc()</code></p><p>消费时的逻辑其实和 Java 的 <code>ZeroQueueConsumerImpl</code> 逻辑保持了一致，也是每消费一条数据之前就增加一次 <code>availablePermits</code>。</p><p>pulsar-client-go 的运行原理与 Java 客户端的类似，也是将消息存放在了一个内部队列里，所以每次消费消息只需要从这个队列 <code>messageCh</code> 里获取即可。</p><p>值得注意的是， pulsar-client-go 版本的 <code>zeroQueueConsumer</code> 就不支持直接读取内部的队列了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *zeroQueueConsumer)</span></span> Chan() &lt;-<span class="keyword">chan</span> ConsumerMessage &#123;  </span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;zeroQueueConsumer cannot support Chan method&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会直接 panic，因为直接消费 channel 在客户端层面就没法帮用户主动发送 flow 命令了，所以这个功能就只能屏蔽掉了，只可以主动的 <code>receive</code> 消息。</p><p><img src="https://s2.loli.net/2024/06/24/dDlr3RWM6iYHFbc.png"></p><p>许久之前我也画过一个关于 pulsar client 的消费流程图，后续考虑会再写一篇关于 pulsar client 的原理分析文章。</p><p>参考链接：</p><ul><li><a href="https://github.com/apache/pulsar-client-go/issues/1223">https://github.com/apache/pulsar-client-go/issues/1223</a></li><li><a href="https://cloud.tencent.com/developer/article/2307608">https://cloud.tencent.com/developer/article/2307608</a></li><li><a href="https://pulsar.apache.org/docs/next/cookbooks-message-queue/#client-configuration-changes">https://pulsar.apache.org/docs/next/cookbooks-message-queue/#client-configuration-changes</a></li><li><a href="https://github.com/apache/pulsar-client-go/pull/1225">https://github.com/apache/pulsar-client-go/pull/1225</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间在 &lt;a href=&quot;https://github.com/apache/pulsar-client-go&quot;&gt;pulsar-client-go&lt;/a&gt; 社区里看到这么一个 &lt;a href=&quot;https://github.com/apache/pulsar-client-go/issues/1223&quot;&gt;issue&lt;/a&gt;：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2024/06/24/KNsvV7jeZYSaiPq.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/OB/Pulsar/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>如何监控 Nginx</title>
    <link href="http://crossoverjie.top/2024/07/23/ob/how-to-monitoring-nginx/"/>
    <id>http://crossoverjie.top/2024/07/23/ob/how-to-monitoring-nginx/</id>
    <published>2024-07-23T02:46:30.000Z</published>
    <updated>2024-07-23T03:18:06.688Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间接到一个需求，希望可以监控 Nginx 的运行状态。</p><p>我们都知道 Nginx 作为一个流行的 Web 服务器提供了多种能力，包括反向代理、负载均衡；也支持了许多协议，包括：</p><ul><li>gRPC</li><li>http</li><li>WebSocket 等<br>作为一个流量入口的中间件，对其的监控就显得至关重要了。</li></ul><span id="more"></span><p>市面上也有一些现成的产品可以监控 Nginx，比如知名的监控服务商 <code>datadog</code> 也提供了 Nginx 的监控。</p><p><img src="https://s2.loli.net/2024/06/21/BEjyS4ZQHKCrPqx.png"></p><p>但是我这是一个内网服务，并不能使用这些外部的云厂商，所有就只能在内部搭建 Nginx 的监控服务了。</p><p>不过 Nginx 默认情况下并没有提供 <code>/metrics</code> 的 endpoint，但好在它提供了一个额外的模块：<code>stub_status</code> 可以用于获取监控数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server</span> &#123;</span><br><span class="line">  <span class="string">listen</span> <span class="number">80</span><span class="string">;</span></span><br><span class="line">  <span class="string">server_name</span> <span class="string">_;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">location</span> <span class="string">/status</span> &#123;</span><br><span class="line">    <span class="string">stub_status</span> <span class="string">on;</span></span><br><span class="line">    <span class="string">access_log</span> <span class="string">off;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">      <span class="string">root</span> <span class="string">/usr/share/nginx/html;</span></span><br><span class="line">      <span class="string">index</span> <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/06/21/ZRIPyN2UxXuiCdE.png"><br>这样访问 <code>http://127.0.0.1:80/status</code> 就可以拿到一些基本的运行数据。</p><p>但这个格式明显不是 Prometheus 所支持的 metrics 格式，无法直接将数据采集到 Prometheus 中然后通过 Grafana 进行查看。</p><p>所以还得需要一个中间层来将这些数据转换为 Prometheus 可以接收的 metrics 数据。</p><h1 id="nginx-prometheus-exporter"><a href="#nginx-prometheus-exporter" class="headerlink" title="nginx-prometheus-exporter"></a>nginx-prometheus-exporter</h1><p>好在社区已经提供了类似的工具：<a href="https://github.com/nginxinc/nginx-prometheus-exporter">nginx-prometheus-exporter</a> 它读取刚才 status endpoint 所暴露的数据，然后转换为 Prometheus 格式，并对外提供了一个 <code>/metrics</code> 的 endpoint 供 Prometheus 来采集。</p><h2 id="转换数据"><a href="#转换数据" class="headerlink" title="转换数据"></a>转换数据</h2><p>我们在启动这个 <code>nginx-exporter</code> 时需要传入刚才 <code>Nginx</code> 暴露的 <code>/status</code> endpoint。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9113:9113 nginx/nginx-prometheus-exporter:1.1.0 --nginx.scrape-uri=http://&lt;nginx&gt;:8080/stub_status</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> templateMetrics <span class="type">string</span> = <span class="string">`Active connections: %d</span></span><br><span class="line"><span class="string">server accepts handled requests</span></span><br><span class="line"><span class="string">%d %d %d</span></span><br><span class="line"><span class="string">Reading: %d Writing: %d Waiting: %d</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 Nginx status 数据</span></span><br><span class="line">body, err := io.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to read the response body: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r := bytes.NewReader(body)</span><br><span class="line">stats, err := parseStubStats(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to parse response body %q: %w&quot;</span>, <span class="type">string</span>(body), err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 Nginx status 数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseStubStats</span><span class="params">(r io.Reader)</span></span> (*StubStats, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> s StubStats</span><br><span class="line"><span class="keyword">if</span> _, err := fmt.Fscanf(r, templateMetrics,</span><br><span class="line">&amp;s.Connections.Active,</span><br><span class="line">&amp;s.Connections.Accepted,</span><br><span class="line">&amp;s.Connections.Handled,</span><br><span class="line">&amp;s.Requests,</span><br><span class="line">&amp;s.Connections.Reading,</span><br><span class="line">&amp;s.Connections.Writing,</span><br><span class="line">&amp;s.Connections.Waiting); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to scan template metrics: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后会把刚才解析到的数据生成 metrics：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_active&quot;</span>],  </span><br><span class="line">    prometheus.GaugeValue, <span class="type">float64</span>(stats.Connections.Active))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_accepted&quot;</span>],  </span><br><span class="line">    prometheus.CounterValue, <span class="type">float64</span>(stats.Connections.Accepted))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_handled&quot;</span>],  </span><br><span class="line">    prometheus.CounterValue, <span class="type">float64</span>(stats.Connections.Handled))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_reading&quot;</span>],  </span><br><span class="line">    prometheus.GaugeValue, <span class="type">float64</span>(stats.Connections.Reading))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_writing&quot;</span>],  </span><br><span class="line">    prometheus.GaugeValue, <span class="type">float64</span>(stats.Connections.Writing))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;connections_waiting&quot;</span>],  </span><br><span class="line">    prometheus.GaugeValue, <span class="type">float64</span>(stats.Connections.Waiting))  </span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(c.metrics[<span class="string">&quot;http_requests_total&quot;</span>],  </span><br><span class="line">    prometheus.CounterValue, <span class="type">float64</span>(stats.Requests))</span><br></pre></td></tr></table></figure><p>这些 metrics 是一开始就定义好的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewNginxCollector creates an NginxCollector.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNginxCollector</span><span class="params">(nginxClient *client.NginxClient, namespace <span class="type">string</span>, constLabels <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, logger log.Logger)</span></span> *NginxCollector &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;NginxCollector&#123;</span><br><span class="line">nginxClient: nginxClient,</span><br><span class="line">logger:      logger,</span><br><span class="line">metrics: <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc&#123;</span><br><span class="line"><span class="string">&quot;connections_active&quot;</span>:   newGlobalMetric(namespace, <span class="string">&quot;connections_active&quot;</span>, <span class="string">&quot;Active client connections&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;connections_accepted&quot;</span>: newGlobalMetric(namespace, <span class="string">&quot;connections_accepted&quot;</span>, <span class="string">&quot;Accepted client connections&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;connections_handled&quot;</span>:  newGlobalMetric(namespace, <span class="string">&quot;connections_handled&quot;</span>, <span class="string">&quot;Handled client connections&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;connections_reading&quot;</span>:  newGlobalMetric(namespace, <span class="string">&quot;connections_reading&quot;</span>, <span class="string">&quot;Connections where NGINX is reading the request header&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;connections_writing&quot;</span>:  newGlobalMetric(namespace, <span class="string">&quot;connections_writing&quot;</span>, <span class="string">&quot;Connections where NGINX is writing the response back to the client&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;connections_waiting&quot;</span>:  newGlobalMetric(namespace, <span class="string">&quot;connections_waiting&quot;</span>, <span class="string">&quot;Idle client connections&quot;</span>, constLabels),</span><br><span class="line"><span class="string">&quot;http_requests_total&quot;</span>:  newGlobalMetric(namespace, <span class="string">&quot;http_requests_total&quot;</span>, <span class="string">&quot;Total http requests&quot;</span>, constLabels),</span><br><span class="line">&#125;,</span><br><span class="line">upMetric: newUpMetric(namespace, constLabels),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个函数是在 exporter 启动时候会调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;github.com/prometheus/client_golang/prometheus&quot;</span></span><br><span class="line"></span><br><span class="line">prometheus.MustRegister(collector.NewNginxCollector(ossClient, <span class="string">&quot;nginx&quot;</span>, labels, logger))</span><br></pre></td></tr></table></figure><p>使用的是 <code>prometheus</code> 包提供的注册函数，将我们刚才自定义的获取 <code>metrics</code> 的逻辑注册进去，这样当我们在 Prometheus 中配置好采集任务之后就可以定期扫描 <code>/status</code> 的数据然后转换为 Prometheus 指标返回。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">10s</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">nginx-exportor</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;127.0.0.1:9113&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这样就可以将 nginx status 的数据定期采集到 Prometheus 中了，最后使用社区提供的 grafana 面板便可以可视化的查看这些监控数据：<br><img src="https://s2.loli.net/2024/06/21/NvlwuAdDZHUznrC.png"></p><h2 id="Nginx-Plus"><a href="#Nginx-Plus" class="headerlink" title="Nginx Plus"></a>Nginx Plus</h2><p>同时这个 nginx-exporter 还支持 <code>Nginx Plus</code>(这是 Nginx 的商用增强版)，它的实现原理类似，只是它支持的指标更多一些而已。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NginxPlusCollector <span class="keyword">struct</span> &#123;  </span><br><span class="line">    upMetric                       prometheus.Gauge  </span><br><span class="line">    logger                         log.Logger  </span><br><span class="line">    cacheZoneMetrics               <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    workerMetrics                  <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    nginxClient                    *plusclient.NginxClient  </span><br><span class="line">    streamServerZoneMetrics        <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    streamZoneSyncMetrics          <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    streamUpstreamMetrics          <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    streamUpstreamServerMetrics    <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    locationZoneMetrics            <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    resolverMetrics                <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    limitRequestMetrics            <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    limitConnectionMetrics         <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    streamLimitConnectionMetrics   <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    upstreamServerMetrics          <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    upstreamMetrics                <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    streamUpstreamServerPeerLabels <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    serverZoneMetrics              <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    upstreamServerLabels           <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    streamUpstreamServerLabels     <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    serverZoneLabels               <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    streamServerZoneLabels         <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    upstreamServerPeerLabels       <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    workerLabels                   <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    cacheZoneLabels                <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>  </span><br><span class="line">    totalMetrics                   <span class="keyword">map</span>[<span class="type">string</span>]*prometheus.Desc  </span><br><span class="line">    variableLabelNames             VariableLabelNames  </span><br><span class="line">    variableLabelsMutex            sync.RWMutex  </span><br><span class="line">    mutex                          sync.Mutex  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://prometheus.io/docs/instrumenting/exporters/">Prometheus</a> 社区中提供不少这类 <code>exporter</code>：<br><img src="https://s2.loli.net/2024/06/21/ztuCr8FgJvcSbis.png"></p><p>这些 <code>exporter</code> 要解决的问题都是类似的，对于一些没有暴露 <code>/metrics</code> 的中间件通过他们提供的客户端直连，然后将获取到的数据转换为 Prometheus 所支持的格式。</p><blockquote><p>需要单独的 exporter 支持的中间件大部分都是一些老牌产品，在设计之初就没有考虑可观测性的需求，现在一些新的中间件几乎都原生支持 metrics，这种产品只需要在 Prometheus 中配置采集任务即可。</p></blockquote><h1 id="Cprobe"><a href="#Cprobe" class="headerlink" title="Cprobe"></a>Cprobe</h1><p>不知道大家发现没有，社区中提供的 <code>exporter</code> 还是挺多的，但如果我们都需要在自己的生产环境将这些 exporter 部署起来多少会有些繁琐：</p><ul><li>不同的 exporter 需要的参数可能不同</li><li>暴露的端口可能不同</li><li>配置文件难以统一管理</li></ul><p>在这个背景下社区有大佬发起了一个 <a href="https://github.com/cprobe/cprobe">cprobe</a> 项目，这是一个大而全的项目，可以将散落在各处的 <code>exporter</code> 都整合在一起。</p><p>并且统一抽象了接入方式，使得所有的插件都可以用类似的配置书写方式来维护这些插件。</p><p>目前已经支持以下一些常用的中间件：</p><p><img src="https://s2.loli.net/2024/06/21/eC75lpg2fBmstjS.png"></p><p>这里的 Nginx 就是本次监控的需求贡献的，因为还需要监控这里支持的一些其他中间件，所以最终也是使用 cprobe 来部署监控。</p><h2 id="整合-Nginx-exporter-到-Cprobe-中"><a href="#整合-Nginx-exporter-到-Cprobe-中" class="headerlink" title="整合 Nginx exporter 到 Cprobe 中"></a>整合 Nginx exporter 到 Cprobe 中</h2><p>下面来看看如何将社区中已经存在的 Nginx exporter 整合到  cprobe 中：</p><p>在开始之前我们先要抽象出这个插件需要哪些配置？</p><p>这个其实很好解决，我们直接看看需要实现的 exporter 中提供了哪些参数，这里以 Nginx 的为例：<br><img src="https://s2.loli.net/2024/06/21/zsY2F563pPglNcS.png"></p><p>排除掉一些我们不需要的，比如端口、日志级别、endpoint等配置之外，就只需要一些关于 SSL 的配置，所以最终我们需要的配置文件如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nginx_plus</span> = <span class="literal">false</span>  </span><br><span class="line"><span class="comment"># Path to the PEM encoded CA certificate file used to validate the servers SSL certificate.  </span></span><br><span class="line"><span class="attr">ssl_ca_cert</span> = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line"><span class="comment"># Path to the PEM encoded client certificate file to use when connecting to the server.  </span></span><br><span class="line"><span class="attr">ssl_client_cert</span> = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line"><span class="comment"># Path to the PEM encoded client certificate key file to use when connecting to the server.  </span></span><br><span class="line"><span class="attr">ssl_client_key</span> = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line"><span class="comment"># Perform SSL certificate verification.  </span></span><br><span class="line"><span class="attr">ssl_verify</span> = <span class="literal">false</span>  </span><br><span class="line"><span class="attr">timeout</span> = <span class="string">&#x27;5s&#x27;</span></span><br></pre></td></tr></table></figure><p>然后将这个 toml 里的配置转换为一个 struct。</p><p>在 cprobe 中有一个核心的接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// ParseConfig is used to parse config</span></span><br><span class="line">ParseConfig(baseDir <span class="type">string</span>, bs []<span class="type">byte</span>) (any, <span class="type">error</span>)</span><br><span class="line"><span class="comment">// Scrape is used to scrape metrics, cfg need to be cast specific cfg</span></span><br><span class="line">Scrape(ctx context.Context, target <span class="type">string</span>, cfg any, ss *types.Samples) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ParseConfig</code> 用于将刚才的配置文件流格式化为插件所需要的配置。</p><p><code>Scrape</code> 函数则是由 cprobe 定时调用的函数，会传入抓取的目标地址，每个插件将抓到的数据写入 <code>*types.Samples</code> 中即可。</p><p><code>cprobe</code> 会将 <code>*types.Samples</code> 的数据发送到 remote 的 Prometheus 中。</p><p>接下来看看 Nginx 插件的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">NginxPlus     <span class="type">bool</span>          <span class="string">`toml:&quot;nginx_plus&quot;`</span></span><br><span class="line">SSLCACert     <span class="type">string</span>        <span class="string">`toml:&quot;ssl_ca_cert&quot;`</span></span><br><span class="line">SSLClientCert <span class="type">string</span>        <span class="string">`toml:&quot;ssl_client_cert&quot;`</span></span><br><span class="line">SSLClientKey  <span class="type">string</span>        <span class="string">`toml:&quot;ssl_client_key&quot;`</span></span><br><span class="line">SSLVerify     <span class="type">bool</span>          <span class="string">`toml:&quot;ssl_verify&quot;`</span></span><br><span class="line">Timeout       time.Duration <span class="string">`toml:&quot;timeout&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Nginx)</span></span> ParseConfig(baseDir <span class="type">string</span>, bs []<span class="type">byte</span>) (any, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> c Config</span><br><span class="line">err := toml.Unmarshal(bs, &amp;c)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.Timeout == <span class="number">0</span> &#123;</span><br><span class="line">c.Timeout = time.Millisecond * <span class="number">500</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ParseConfig</code> 很简单，就是将配置文件转换为 struct。</p><p>抓取函数 <code>Scrape</code> 也很简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">collect, err := registerCollector(transport, target, <span class="literal">nil</span>, conf)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> err  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> prometheus.Metric)  </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    collect.Collect(ch)  </span><br><span class="line">    <span class="built_in">close</span>(ch)  </span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>就是构建之前在 <code>nginx exporter</code> 中的 <code>prometheus.Collector</code>，其实代码大部分也是从那边复制过来的。<br><img src="https://s2.loli.net/2024/06/21/4yHQgL1EAiZXwju.png"><br><img src="https://s2.loli.net/2024/06/21/1OloLxpEnbqiaXA.png"><br>所以其实迁移一个 exporter 到 cprobe 中非常简单，只需要：</p><ul><li>定义好需要的配置。</li><li>去掉不需要的代码，比如日志、端口之类的。</li><li>适配好刚才那两个核心函数 <code>ParseConfig/Scrape</code> 即可。</li></ul><p>但这样也有些小问题，现有的一些 exporter 还在迭代，那边更新的版本需要有人及时同步过来。</p><p>除非有一天 cprobe 可以作为一个标准，版本更新都在 cprobe 这边完成，这样就真的是做大做强了。</p><p>不过这些依旧是适配老一代的中间件产品，逐步都会适配现代的可观测体系，这些 exporter 也会逐渐走下历史舞台。</p><p>参考链接：</p><ul><li><a href="https://prometheus.io/docs/instrumenting/exporters/">https://prometheus.io/docs/instrumenting/exporters/</a></li><li><a href="https://github.com/nginxinc/nginx-prometheus-exporter">https://github.com/nginxinc/nginx-prometheus-exporter</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间接到一个需求，希望可以监控 Nginx 的运行状态。&lt;/p&gt;
&lt;p&gt;我们都知道 Nginx 作为一个流行的 Web 服务器提供了多种能力，包括反向代理、负载均衡；也支持了许多协议，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gRPC&lt;/li&gt;
&lt;li&gt;http&lt;/li&gt;
&lt;li&gt;WebSocket 等&lt;br&gt;作为一个流量入口的中间件，对其的监控就显得至关重要了。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    
    <category term="Nginx" scheme="http://crossoverjie.top/tags/Nginx/"/>
    
    <category term="Monitor" scheme="http://crossoverjie.top/tags/Monitor/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统如何做负载均衡</title>
    <link href="http://crossoverjie.top/2024/07/15/ob/Pulsar-loadbalance/"/>
    <id>http://crossoverjie.top/2024/07/15/ob/Pulsar-loadbalance/</id>
    <published>2024-07-15T02:22:14.000Z</published>
    <updated>2024-07-15T14:03:51.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Pulsar 有提供一个查询 Broker 负载的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get load for this broker.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> PulsarAdminException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">LoadManagerReport <span class="title function_">getLoadReport</span><span class="params">()</span> <span class="keyword">throws</span> PulsarAdminException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadManagerReport</span> <span class="keyword">extends</span> <span class="title class_">ServiceLookupData</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getCpu</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getMemory</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getDirectMemory</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getBandwidthIn</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    ResourceUsage <span class="title function_">getBandwidthOut</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以返回一些 broker 的负载数据，比如 CPU、内存、流量之类的数据。</p><span id="more"></span><blockquote><p>我目前碰到的问题是目前会遇到部分节点的负债不平衡，导致资源占用不均衡，所以想要手动查询所有节点的负载数据，然后人工进行负载。</p></blockquote><p>理论上这些数据是在运行时实时计算的数据，如果对于单机的倒还好说，每次请求这个接口直接实时计算一次就可以了。</p><p>但对于集群的服务来说会有多个节点，目前 Pulsar 提供的这个接口只能查询指定节点的负载数据，也就是说每次得传入目标节点的 IP 和端口。</p><p><img src="https://s2.loli.net/2024/06/07/ephIgndx54sFlLa.png"></p><p>所以我的预期是可以提供一个查询所有节点负载的接口，已经提了 <code>issue</code>，最近准备写 Purpose 把这个需求解决了。</p><p>实现这个需求的方案有两种：</p><ol><li>拿到所有 broker 也就是服务节点信息，依次遍历调用接口，然后自己组装信息。</li><li>从 zookeeper 中获取负载信息。</li></ol><p>理论上第二种更好，第一种实现虽然更简单，但每次都发起一次 http 请求，多少有些浪费。</p><p>第二种方案直接从源头获取负载信息，只需要请求一次就可以了。</p><p>而正好社区提供了一个命令行工具可以直接打印所有的 <code>broker</code> 负载数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pulsar-perf monitor-brokers --connect-string &lt;zookeeper host:port&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/06/07/UN8gpW915RfcODb.png"></p><h1 id="分布式系统常用组件"><a href="#分布式系统常用组件" class="headerlink" title="分布式系统常用组件"></a>分布式系统常用组件</h1><p>提供的命令行工具其实就是直接从 zookeeper 中查询的数据。</p><p>在分布式系统中需要一个集中的组件来管理各种数据，比如：</p><ol><li>可以利用该组件来选举 leader 节点</li><li>使用该组件来做分布式锁</li><li>为分布式系统同步数据</li><li>统一的存放和读取某些数据</li></ol><p>可以提供该功能的组件其实也不少：</p><ul><li><a href="https://zookeeper.apache.org/">zookeeper</a></li><li><a href="https://etcd.io/">etcd</a></li><li><a href="https://github.com/streamnative/oxia">oxia</a></li></ul><p>Zookeeper 是老牌的分布式协调组件，可以做 leader 选举、配置中心、分布式锁、服务注册与发现等功能。</p><p>在许多中间件和系统中都有应用，比如：</p><ul><li><a href="https://github.com/apache/pulsar">Apache Pulsar</a> 中作为协调中心</li><li><a href="https://github.com/apache/kafka">Kafka</a> 中也有类似的作用。</li><li>在 <a href="https://github.com/apache/dubbo">Dubbo</a> 中作为服务注册发现组件。</li></ul><hr><p>etcd 的功能与 zookeeper 类似，可以用作服务注册发现，也可以作为 Key Value 键值对存储系统；在 kubernetes 中扮演了巨大作用，经历了各种考验，稳定性已经非常可靠了。</p><hr><p><a href="https://github.com/streamnative/oxia">Oxia</a> 则是 StreamNative 开发的一个用于替换 Zookeeper 的中间件，功能也与 Zookeeper 类似；目前已经可以在 Pulsar 中替换 Zookeeper，只是还没有大规模的使用。</p><h1 id="Pulsar-中的应用"><a href="#Pulsar-中的应用" class="headerlink" title="Pulsar 中的应用"></a>Pulsar 中的应用</h1><p>下面以 Pulsar 为例（使用 zookeeper），看看在这类大型分布式系统中是如何处理负载均衡的。</p><p>再开始之前先明确下负载均衡大体上会做哪些事情。</p><ol><li>首先上报自己节点的负载数据</li><li>Leader 节点需要定时收集所有节点的负载数据。<ol><li>这些负载数据中包括：<ol><li><code>CPU</code>、堆内存、堆外内存等通用数据的使用量</li><li>流出、流入流量</li><li>一些系统特有的数据，比如在 <code>Pulsar</code> 中就是：<ol><li>每个 <code>broker</code> 中的 <code>topic</code>、<code>consumer</code>、<code>producer</code>、<code>bundle</code> 等数据。</li></ol></li></ol></li></ol></li><li>再由 leader 节点读取到这些数据后选择负载较高的节点，将数据迁移到负载较低的节点。</li></ol><p>以上就是一个完整的负载均衡的流程，下面我们依次看看在 <code>Pulsar</code> 中是如何实现这些逻辑的。</p><p>在 Pulsar 中提供了多种负载均衡策略，以下是加载负载均衡器的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> LoadManager <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> PulsarService pulsar)</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServiceConfiguration</span> <span class="variable">conf</span> <span class="operator">=</span> pulsar.getConfiguration();  </span><br><span class="line">        <span class="comment">// Assume there is a constructor with one argument of PulsarService.  </span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">loadManagerInstance</span> <span class="operator">=</span> Reflections.createInstance(conf.getLoadManagerClassName(),  </span><br><span class="line">                Thread.currentThread().getContextClassLoader());  </span><br><span class="line">        <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> LoadManager) &#123;  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> (LoadManager) loadManagerInstance;  </span><br><span class="line">            casted.initialize(pulsar);  </span><br><span class="line">            <span class="keyword">return</span> casted;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> ModularLoadManager) &#123;  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModularLoadManagerWrapper</span>((ModularLoadManager) loadManagerInstance);  </span><br><span class="line">            casted.initialize(pulsar);  </span><br><span class="line">            <span class="keyword">return</span> casted;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        LOG.warn(<span class="string">&quot;Error when trying to create load manager: &quot;</span>, e);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// If we failed to create a load manager, default to SimpleLoadManagerImpl.  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleLoadManagerImpl</span>(pulsar);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认使用的是 <code>ModularLoadManagerImpl</code>， 如果出现异常那就会使用 <code>SimpleLoadManagerImpl</code> 作为兜底。</p><p>他们两个的区别是 <code>ModularLoadManagerImpl</code> 的功能更全，可以做更为细致的负载策略。</p><p>接下来以默认的 <code>ModularLoadManagerImpl</code> 为例讲解上述的流程。</p><h2 id="上报负载数据"><a href="#上报负载数据" class="headerlink" title="上报负载数据"></a>上报负载数据</h2><p>在负载均衡器启动的时候就会收集节点数据然后进行上报：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> PulsarServerException &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="type">String</span> <span class="variable">brokerId</span> <span class="operator">=</span> pulsar.getBrokerId();</span><br><span class="line">         brokerZnodePath = LoadManager.LOADBALANCE_BROKERS_ROOT + <span class="string">&quot;/&quot;</span> + brokerId;</span><br><span class="line">         <span class="comment">// 收集本地负载数据</span></span><br><span class="line">         updateLocalBrokerData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上报 zookeeper</span></span><br><span class="line">         brokerDataLock = brokersData.acquireLock(brokerZnodePath, localData).join();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         log.error(<span class="string">&quot;Unable to acquire lock for broker: [&#123;&#125;]&quot;</span>, brokerZnodePath, e);</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PulsarServerException</span>(e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先获取到当前 broker 的 Id 然后拼接一个 zookeeper 节点的路径，将生成的 localData 上传到 zookeeper 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 存放 broker 的节点信息</span><br><span class="line">ls /loadbalance/brokers</span><br><span class="line"></span><br><span class="line">[broker-1:8080, broker-2:8080]</span><br><span class="line"></span><br><span class="line">// 根据节点信息查询负载数据</span><br><span class="line">get /loadbalance/brokers/broker-1:8080</span><br></pre></td></tr></table></figure><p>上报的数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;webServiceUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://broker-1:8080&quot;</span><span class="punctuation">,</span><span class="attr">&quot;pulsarServiceUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;pulsar://broker-1:6650&quot;</span><span class="punctuation">,</span><span class="attr">&quot;persistentTopicsEnabled&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="attr">&quot;nonPersistentTopicsEnabled&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">7.311714728372232</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">800.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;memory&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">124.0</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">2096.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;directMemory&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">36.0</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">256.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;bandwidthIn&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">0.8324254085661579</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">1.0E7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;bandwidthOut&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span><span class="number">0.7155446715644209</span><span class="punctuation">,</span><span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span><span class="number">1.0E7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgRateIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgRateOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;lastUpdate&quot;</span><span class="punctuation">:</span><span class="number">1690979816792</span><span class="punctuation">,</span><span class="attr">&quot;lastStats&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;my-tenant/my-namespace/0x4ccccccb_0x66666664&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;msgRateIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputIn&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgRateOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;msgThroughputOut&quot;</span><span class="punctuation">:</span><span class="number">0.0</span><span class="punctuation">,</span><span class="attr">&quot;consumerCount&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;producerCount&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;topics&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;cacheSize&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;numTopics&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;numBundles&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;numConsumers&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;numProducers&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;bundles&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;my-tenant/my-namespace/0x4ccccccb_0x66666664&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;lastBundleGains&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;lastBundleLosses&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;brokerVersionString&quot;</span><span class="punctuation">:</span><span class="string">&quot;3.1.0-SNAPSHOT&quot;</span><span class="punctuation">,</span><span class="attr">&quot;protocols&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;advertisedListeners&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;internal&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;brokerServiceUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;pulsar://broker-1:6650&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;loadManagerClassName&quot;</span><span class="punctuation">:</span><span class="string">&quot;org.apache.pulsar.broker.loadbalance.impl.ModularLoadManagerImpl&quot;</span><span class="punctuation">,</span><span class="attr">&quot;startTimestamp&quot;</span><span class="punctuation">:</span><span class="number">1690940955211</span><span class="punctuation">,</span><span class="attr">&quot;maxResourceUsage&quot;</span><span class="punctuation">:</span><span class="number">0.140625</span><span class="punctuation">,</span><span class="attr">&quot;loadReportType&quot;</span><span class="punctuation">:</span><span class="string">&quot;LocalBrokerData&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="采集数据"><a href="#采集数据" class="headerlink" title="采集数据"></a>采集数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SystemResourceUsage <span class="title function_">getSystemResourceUsage</span><span class="params">(<span class="keyword">final</span> BrokerHostUsage brokerHostUsage)</span> &#123;  </span><br><span class="line">    <span class="type">SystemResourceUsage</span> <span class="variable">systemResourceUsage</span> <span class="operator">=</span> brokerHostUsage.getBrokerHostUsage();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Override System memory usage and limit with JVM heap usage and limit  </span></span><br><span class="line">    <span class="type">double</span> <span class="variable">maxHeapMemoryInBytes</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory();  </span><br><span class="line">    <span class="type">double</span> <span class="variable">memoryUsageInBytes</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();  </span><br><span class="line">    <span class="type">double</span> <span class="variable">memoryUsage</span> <span class="operator">=</span> memoryUsageInBytes / MIBI;  </span><br><span class="line">    <span class="type">double</span> <span class="variable">memoryLimit</span> <span class="operator">=</span> maxHeapMemoryInBytes / MIBI;  </span><br><span class="line">    systemResourceUsage.setMemory(<span class="keyword">new</span> <span class="title class_">ResourceUsage</span>(memoryUsage, memoryLimit));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Collect JVM direct memory  </span></span><br><span class="line">    systemResourceUsage.setDirectMemory(<span class="keyword">new</span> <span class="title class_">ResourceUsage</span>((<span class="type">double</span>) (getJvmDirectMemoryUsed() / MIBI),  </span><br><span class="line">            (<span class="type">double</span>) (DirectMemoryUtils.jvmMaxDirectMemory() / MIBI)));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> systemResourceUsage;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会在运行时获取一些 JVM 和 堆外内存的数据。</p><h2 id="收集所有节点数据"><a href="#收集所有节点数据" class="headerlink" title="收集所有节点数据"></a>收集所有节点数据</h2><p>作为 <code>leader</code> 节点还需要收集所有节点的负载数据，然后根据一些规则选择将负载较高的节点移动到负债较低的节点中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateAllBrokerData</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 从 zookeeper 中获取所有节点</span></span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; activeBrokers = getAvailableBrokers();</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, BrokerData&gt; brokerDataMap = loadData.getBrokerData();</span><br><span class="line">    <span class="keyword">for</span> (String broker : activeBrokers) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s/%s&quot;</span>, LoadManager.LOADBALANCE_BROKERS_ROOT, broker);</span><br><span class="line">            <span class="comment">// 依次读取各个节点的负载数据</span></span><br><span class="line">            Optional&lt;LocalBrokerData&gt; localData = brokersData.readLock(key).get();</span><br><span class="line">            <span class="keyword">if</span> (!localData.isPresent()) &#123;</span><br><span class="line">                brokerDataMap.remove(broker);</span><br><span class="line">                log.info(<span class="string">&quot;[&#123;&#125;] Broker load report is not present&quot;</span>, broker);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brokerDataMap.containsKey(broker)) &#123;</span><br><span class="line">                <span class="comment">// Replace previous local broker data.</span></span><br><span class="line">                brokerDataMap.get(broker).setLocalData(localData.get());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Initialize BrokerData object for previously unseen</span></span><br><span class="line">                <span class="comment">// brokers.</span></span><br><span class="line">                <span class="comment">// 将数据写入到本地缓存</span></span><br><span class="line">                brokerDataMap.put(broker, <span class="keyword">new</span> <span class="title class_">BrokerData</span>(localData.get()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Error reading broker data from cache for broker - [&#123;&#125;], [&#123;&#125;]&quot;</span>, broker, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove obsolete brokers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> String broker : brokerDataMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!activeBrokers.contains(broker)) &#123;</span><br><span class="line">            brokerDataMap.remove(broker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会从 zookeeper 的节点中获取到所有的 broker 列表（broker 会在启动时将自身的信息注册到 zookeeper 中。）</p><p>然后依次读取各自节点的负载数据，也就是在负载均衡器启动的时候上报的数据。</p><h2 id="筛选出所有-broker-中需要-unload-的-bundle"><a href="#筛选出所有-broker-中需要-unload-的-bundle" class="headerlink" title="筛选出所有 broker 中需要 unload 的 bundle"></a>筛选出所有 broker 中需要 unload 的 bundle</h2><p>在 Pulsar 中 topic 是最核心的概念，而为了方便管理大量 topic，提出了一个 Bundle 的概念； Bundle 是一批 topic 的集合，管理 Bundle 自然会比 topic 更佳容易。</p><p>所以在 Pulsar 中做负载均衡最主要的就是将负载较高节点中的 bundle 转移到低负载的 broker 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateAllBrokerData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; activeBrokers = getAvailableBrokers();</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, BrokerData&gt; brokerDataMap = loadData.getBrokerData();</span><br><span class="line">    <span class="keyword">for</span> (String broker : activeBrokers) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s/%s&quot;</span>, LoadManager.LOADBALANCE_BROKERS_ROOT, broker);</span><br><span class="line">            Optional&lt;LocalBrokerData&gt; localData = brokersData.readLock(key).get();</span><br><span class="line">            <span class="keyword">if</span> (!localData.isPresent()) &#123;</span><br><span class="line">                brokerDataMap.remove(broker);</span><br><span class="line">                log.info(<span class="string">&quot;[&#123;&#125;] Broker load report is not present&quot;</span>, broker);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brokerDataMap.containsKey(broker)) &#123;</span><br><span class="line">                <span class="comment">// Replace previous local broker data.</span></span><br><span class="line">                brokerDataMap.get(broker).setLocalData(localData.get());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Initialize BrokerData object for previously unseen</span></span><br><span class="line">                <span class="comment">// brokers.</span></span><br><span class="line">                brokerDataMap.put(broker, <span class="keyword">new</span> <span class="title class_">BrokerData</span>(localData.get()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Error reading broker data from cache for broker - [&#123;&#125;], [&#123;&#125;]&quot;</span>, broker, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove obsolete brokers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> String broker : brokerDataMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!activeBrokers.contains(broker)) &#123;</span><br><span class="line">            brokerDataMap.remove(broker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负载均衡器在启动的时候就会查询所有节点的数据，然后写入到 <code>brokerDataMap</code> 中。</p><p><img src="https://s2.loli.net/2024/06/12/ASoLedKVlgRbCFO.png"><br>同时也会注册相关的 zookeeper 事件，当注册的节点发生变化时（一般是新增或者删减了 broker 节点）就会更新内存中缓存的负载数据。</p><p>之后 leader 节点会定期调用 <code>org.apache.pulsar.broker.loadbalance.impl.ModularLoadManagerImpl#doLoadShedding</code> 函数查询哪些数据需要卸载，然后进行重新负载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Multimap&lt;String, String&gt; bundlesToUnload = loadSheddingStrategy.findBundlesForUnloading(loadData, conf);</span><br></pre></td></tr></table></figure><p>最核心的就是调用这个 <code>findBundlesForUnloading</code> 函数，会返回需要卸载 bundle 集合，最终会遍历这个集合调用 admin API 进行卸载和重平衡。</p><p>而这个函数会有多种实现，本质上就是根据传入的各个节点的负载数据，然后根据自定义的规则返回一批需要卸载的数据。</p><p>以默认的 <code>org.apache.pulsar.broker.loadbalance.impl.ThresholdShedder</code> 规则为例：</p><p><img src="https://s2.loli.net/2024/06/12/hg751LtwZMrUyFb.png"><br>它是根据带宽、内存、流量等各个指标的权重算出每个节点的负载值，之后为整个集群计算出一个平均负载值。</p><p>以上图为例：超过 <code>ShedBundles</code> 的数据就需要被卸载掉，然后转移到低负载的节点中。</p><p>所以最左边节点和超出的 bundle 部分就需要被返回。</p><p>具体的计算逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">filterAndSelectBundle</span><span class="params">(LoadData loadData, Map&lt;String, Long&gt; recentlyUnloadedBundles, String broker,</span></span><br><span class="line"><span class="params">                                   LocalBrokerData localData, <span class="type">double</span> minimumThroughputToOffload)</span> &#123;</span><br><span class="line">    <span class="type">MutableDouble</span> <span class="variable">trafficMarkedToOffload</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutableDouble</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">MutableBoolean</span> <span class="variable">atLeastOneBundleSelected</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutableBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">    loadData.getBundleDataForLoadShedding().entrySet().stream()</span><br><span class="line">            .map((e) -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">bundle</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">BundleData</span> <span class="variable">bundleData</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="type">TimeAverageMessageData</span> <span class="variable">shortTermData</span> <span class="operator">=</span> bundleData.getShortTermData();</span><br><span class="line">                <span class="type">double</span> <span class="variable">throughput</span> <span class="operator">=</span> shortTermData.getMsgThroughputIn() + shortTermData.getMsgThroughputOut();</span><br><span class="line">                <span class="keyword">return</span> Pair.of(bundle, throughput);</span><br><span class="line">            &#125;).filter(e -&gt;</span><br><span class="line">                    !recentlyUnloadedBundles.containsKey(e.getLeft())</span><br><span class="line">            ).filter(e -&gt;</span><br><span class="line">                    localData.getBundles().contains(e.getLeft())</span><br><span class="line">            ).sorted((e1, e2) -&gt;</span><br><span class="line">                    Double.compare(e2.getRight(), e1.getRight())</span><br><span class="line">            ).forEach(e -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (trafficMarkedToOffload.doubleValue() &lt; minimumThroughputToOffload</span><br><span class="line">                        || atLeastOneBundleSelected.isFalse()) &#123;</span><br><span class="line">                    selectedBundlesCache.put(broker, e.getLeft());</span><br><span class="line">                    trafficMarkedToOffload.add(e.getRight());</span><br><span class="line">                    atLeastOneBundleSelected.setTrue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码里看的出来就是在一个备选集合中根据各种阈值和判断条件筛选出需要卸载的 bundle。</p><hr><p>而 <code>SimpleLoadManagerImpl</code> 的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (currentLoadReports) &#123;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;ResourceUnit, LoadReport&gt; entry : currentLoadReports.entrySet()) &#123;</span><br><span class="line"><span class="type">ResourceUnit</span> <span class="variable">overloadedRU</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"><span class="type">LoadReport</span> <span class="variable">lr</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"><span class="comment">// 所有数据做一个简单的筛选，超过阈值的数据需要被 unload</span></span><br><span class="line"><span class="keyword">if</span> (isAboveLoadLevel(lr.getSystemResourceUsage(), overloadThreshold)) &#123;</span><br><span class="line"><span class="type">ResourceType</span> <span class="variable">bottleneckResourceType</span> <span class="operator">=</span> lr.getBottleneckResourceType();</span><br><span class="line">Map&lt;String, NamespaceBundleStats&gt; bundleStats = lr.getSortedBundleStats(bottleneckResourceType);</span><br><span class="line"><span class="keyword">if</span> (bundleStats == <span class="literal">null</span>) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;Null bundle stats for bundle &#123;&#125;&quot;</span>, lr.getName());</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是很简单的通过将判断节点的负载是否超过了阈值 <code>isAboveLoadLevel</code>，然后做一个简单的排序就返回了。</p><p>从这里也看得出来 <code>SimpleLoadManagerImpl</code> 和 <code>ModularLoadManager</code> 的区别，<code>SimpleLoadManagerImpl</code> 更简单，并没有提供多个 <code>doLoadShedding</code> 的筛选实现。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说对于无状态的服务来说，理论上我们只需要做好负载算法即可（轮训、一致性哈希、低负载优先等）就可以很好的平衡各个节点之间的负载。</p><p>而对于有状态的服务来说，负载均衡就是将负载较高节点中的数据转移到负载低的节点中。</p><p>其中的关键就是需要存储各个节点的负载数据（业界常用的是存储到 zookeeper 中），然后再由一个 leader 节点从这些节点中根据某种负载算法选择出负载较高的节点以及负载较低的节点，最终把数据迁移过去即可。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Pulsar 有提供一个查询 Broker 负载的接口：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * Get load for this broker.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; PulsarAdminException&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LoadManagerReport &lt;span class=&quot;title function_&quot;&gt;getLoadReport&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; PulsarAdminException;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;LoadManagerReport&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ServiceLookupData&lt;/span&gt; &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getCpu&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getMemory&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getDirectMemory&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getBandwidthIn&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResourceUsage &lt;span class=&quot;title function_&quot;&gt;getBandwidthOut&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以返回一些 broker 的负载数据，比如 CPU、内存、流量之类的数据。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/OB/Pulsar/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
</feed>
