<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverJie&#39;s Blog</title>
  
  <subtitle>baller</subtitle>
  <link href="http://crossoverjie.top/atom.xml" rel="self"/>
  
  <link href="http://crossoverjie.top/"/>
  <updated>2022-10-15T08:43:50.137Z</updated>
  <id>http://crossoverjie.top/</id>
  
  <author>
    <name>crossoverJie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何为 GScript 编写标准库</title>
    <link href="http://crossoverjie.top/2022/10/15/gscript/gscript10-write-native-lib/"/>
    <id>http://crossoverjie.top/2022/10/15/gscript/gscript10-write-native-lib/</id>
    <published>2022-10-15T00:08:09.000Z</published>
    <updated>2022-10-15T08:43:50.137Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h75zxqn8bej30gq074aa9.jpg"></p><h1 id="版本更新"><a href="#版本更新" class="headerlink" title="版本更新"></a>版本更新</h1><p>最近 <code>GScript</code> 更新了 <code>v0.0.11</code> 版本，重点更新了：</p><ul><li><code>Docker</code> 运行环境</li><li>新增了 byte 原始类型</li><li>新增了一些字符串标准库 <code>Strings/StringBuilder</code></li><li>数组切片语法：<code>int[] b = a[1: len(a)];</code></li></ul><blockquote><p>具体更新内容请看下文。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间发布了 <code>GScript</code> 的在线 <code>playground</code>，<br><img src="http://tva1.sinaimg.cn/large/72fbb941ly1h760l8xfm0g20go0dfnen.gif" alt="playground-min.gif"></p><p>这是一个可以在线运行 <code>GScript</code> 脚本的网站，其本质原理是接收用户的输入源码从而在服务器上运行的服务；这简直就是后门大开的 <code>XSS</code> 攻击，为保住服务器我设置了运行 <code>API</code> 的后端服务的用户权限，这样可以避免执行一些恶意的请求。</p><p>但也避免不了一些用户执行了一些耗时操作，比如一个死循环、或者是我提供 <code>demo</code> 里的打印杨辉三角。<br><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h760uozudlj30u014bdi9.jpg"></p><span id="more"></span><p>这本质上是一个递归函数，当打印的三角层数过高时便会非常耗时，同时也非常消耗 CPU。</p><p>有几次我去检查服务器时发现了几个 CPU 过高的进程，基本上都是这样的耗时操作，不可避免的会影响到服务器的性能。</p><h1 id="使用-Docker"><a href="#使用-Docker" class="headerlink" title="使用 Docker"></a>使用 Docker</h1><p>为了解决这类问题，很自然的就能想到可以使用 <code>Docker</code>，所有的资源都和宿主机是隔离开的，无论怎么瞎折腾也不会影响到宿主机。</p><p>说干就干，最后修改了 API 执行脚本的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> <span class="variable">fileName</span> <span class="operator">=</span> d.unix(<span class="string">&quot;Asia/Shanghai&quot;</span>) + <span class="string">&quot;temp.gs&quot;</span> ;</span><br><span class="line">s.writeFile(fileName, body, <span class="number">438</span>);</span><br><span class="line"><span class="type">string</span> <span class="variable">pwd</span> <span class="operator">=</span> s.getwd();</span><br><span class="line"><span class="comment">// string res = s.command(&quot;gscript&quot;, fileName);</span></span><br><span class="line"><span class="type">string</span> <span class="variable">res</span> <span class="operator">=</span> s.command(<span class="string">&quot;docker&quot;</span>,<span class="string">&quot;run&quot;</span>,<span class="string">&quot;--rm&quot;</span>,<span class="string">&quot;-v&quot;</span>, pwd+<span class="string">&quot;:/usr/src/gscript&quot;</span>,<span class="string">&quot;-w&quot;</span>,<span class="string">&quot;/usr/src/gscript&quot;</span>, <span class="string">&quot;crossoverjie/gscript&quot;</span>,<span class="string">&quot;gscript&quot;</span>, fileName);</span><br><span class="line">s.remove(fileName);</span><br><span class="line">r.body = res;</span><br><span class="line">r.ast = dumpAST(body);</span><br><span class="line">r.symbol=dumpSymbol(body);</span><br><span class="line">ctx.JSON(<span class="number">200</span>, r);</span><br></pre></td></tr></table></figure><p>主要修改的就是将直接执行的 <code>GScript</code> 命令修改为了调用 <code>docker</code> 执行。</p><blockquote><p>但其实也还有改进空间，后续新增协程之后可以便可监控运行时间，超时后便会自动 kill 进程。</p></blockquote><p>我也将该 <code>Docker</code> 上传到了 <code>DockerHub</code>，现在大家想在本地体验 <code>GScript</code> 的 <code>REPL</code> 时也只需要运行<code>Docker</code> 就能使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull crossoverjie/gscript</span><br><span class="line">docker run --rm -it  crossoverjie/gscript:latest gscript</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h76148st1pj31ik0laq5r.jpg"></p><p>当然也可以执行用 <code>Docker</code> 执行 <code>GScript</code> 脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -v $PWD:/usr/src/gscript -w /usr/src/gscript crossoverjie/gscript gscript &#123;yourpath&#125;/temp.gs</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h76194c45pj320g0ee41b.jpg"></p><h1 id="编写-GScript-标准库"><a href="#编写-GScript-标准库" class="headerlink" title="编写 GScript 标准库"></a>编写 GScript 标准库</h1><p>接下来重点聊聊 <code>GScript</code> 标准库的事情，其实编写标准库是一个费时费力的事情。<br><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h761e5h3p3j31cw0tgwis.jpg"><br>现在编译器已经提供了一些可用的内置函数，借由这些内置函数写一些常见的工具类是完全没有问题的。</p><p>对写 <code>GScript</code> 标准库感谢的朋友可以当做一个参考，这里我打了一个样，先看下运行效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串工具类</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">b</span> <span class="operator">=</span> StringBuilder();</span><br><span class="line">b.writeString(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">b.writeString(<span class="string">&quot;20&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> b.writeString(<span class="string">&quot;30&quot;</span>);</span><br><span class="line"><span class="type">string</span> <span class="variable">s</span> <span class="operator">=</span> b.String();</span><br><span class="line">printf(<span class="string">&quot;s:%s, len=%d &quot;</span>,s,l);</span><br><span class="line">assertEqual(s,<span class="string">&quot;102030&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] b2 = toByteArray(<span class="string">&quot;40&quot;</span>);</span><br><span class="line">b.WriteBytes(b2);</span><br><span class="line">s = b.String();</span><br><span class="line">assertEqual(s,<span class="string">&quot;10203040&quot;</span>);</span><br><span class="line">println(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Strings 工具类</span></span><br><span class="line"><span class="type">Strings</span> <span class="variable">s</span> <span class="operator">=</span> Strings();</span><br><span class="line">string[] elems = &#123;<span class="string">&quot;name=xxx&quot;</span>,<span class="string">&quot;age=xx&quot;</span>&#125;;</span><br><span class="line"><span class="type">string</span> <span class="variable">ret</span> <span class="operator">=</span> s.join(elems, <span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">println(ret);</span><br><span class="line">assertEqual(ret, <span class="string">&quot;name=xxx&amp;age=xx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="variable">b</span> <span class="operator">=</span> s.hasPrefix(<span class="string">&quot;http://www.xx.com&quot;</span>, <span class="string">&quot;http&quot;</span>);</span><br><span class="line">println(b);</span><br><span class="line">assertEqual(b,<span class="literal">true</span>);</span><br><span class="line">b = s.hasPrefix(<span class="string">&quot;http://www.xx.com&quot;</span>, <span class="string">&quot;https&quot;</span>);</span><br><span class="line">println(b);</span><br><span class="line">assertEqual(b,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>其中的实现源码基本上是借鉴了 Go 的标准库，先来看看 <code>StringBuilder</code> 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringBuilder</span>&#123;</span><br><span class="line">    <span class="type">byte</span>[] buf = [<span class="number">0</span>]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// append contents to buf, it returns the length of s</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">writeString</span><span class="params">(string s)</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] temp = toByteArray(s);</span><br><span class="line">        append(buf, temp);</span><br><span class="line">        <span class="keyword">return</span> len(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// append b to buf, it returns the length of b.</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">WriteBytes</span><span class="params">(<span class="type">byte</span>[] b)</span>&#123;</span><br><span class="line">        append(buf, b);</span><br><span class="line">        <span class="keyword">return</span> len(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copies the buffer to a new.</span></span><br><span class="line">    grow(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// when there is not enough space left.</span></span><br><span class="line">            <span class="keyword">if</span> (cap(buf) - len(buf) &lt; n) &#123;</span><br><span class="line">                <span class="type">byte</span>[] newBuf = [len(buf), <span class="number">2</span>*cap(buf)+n]&#123;&#125;;</span><br><span class="line">                copy(newBuf, buf);</span><br><span class="line">                buf = newBuf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string <span class="title function_">String</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是借助了原始的数组类型以及 <code>toByteArray/toString</code> 字节数组和字符串的转换函数实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Strings</span>&#123;</span><br><span class="line">    <span class="comment">// concatenates the elements of its first argument to create a single string. The separator</span></span><br><span class="line">    <span class="comment">// string sep is placed between elements in the resulting string.</span></span><br><span class="line">    string <span class="title function_">join</span><span class="params">(string[] elems, string sep)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len(elems) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len(elems) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> elems[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">byte</span>[] bs = toByteArray(sep);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> len(bs) * (len(elems) -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; len(elems); i++) &#123;</span><br><span class="line">            <span class="type">string</span> <span class="variable">s</span> <span class="operator">=</span> elems[i];</span><br><span class="line">            <span class="type">byte</span>[] bs = toByteArray(s);</span><br><span class="line">            n = n + len(bs);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> StringBuilder();</span><br><span class="line">        sb.grow(n);</span><br><span class="line">        <span class="type">string</span> <span class="variable">first</span> <span class="operator">=</span> elems[<span class="number">0</span>];</span><br><span class="line">        sb.writeString(first);</span><br><span class="line"></span><br><span class="line">        string[] remain = elems[<span class="number">1</span>:len(elems)];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; len(remain); i++)&#123;</span><br><span class="line">            sb.writeString(sep);</span><br><span class="line">            <span class="type">string</span> <span class="variable">r</span> <span class="operator">=</span> remain[i];</span><br><span class="line">            sb.writeString(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.String();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// tests whether the string s begins with prefix.</span></span><br><span class="line">    bool <span class="title function_">hasPrefix</span><span class="params">(string s, string prefix)</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toByteArray(s);</span><br><span class="line">        <span class="type">byte</span>[] bp = toByteArray(prefix);    </span><br><span class="line">        <span class="keyword">return</span> len(bs) &gt;= len(bp) &amp;&amp; toString(bs[<span class="number">0</span>:len(bp)]) == prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Strings</code> 工具类也是类似的，都是一些内置函数的组合运用；</p><p>在写标准库的过程中还会有额外收获，可以再次阅读一遍 Go 标准库的实现流程，换了一种语法实现出来，会加深对 Go 标准库的理解。</p><p>所以欢迎感兴趣的朋友向 <code>GScript</code> 贡献标准库，由于我个人精力有限，实现过程中可能会发现缺少某些内置函数或数据结构，这也没关系，反馈 <code>issue</code> 后我会尽快处理。</p><blockquote><p>由于目前 <code>GScript</code> 还不支持包管理，所以新增的函数可以创建 <code>Class</code> 来实现，后续支持包或者是 <code>namespace</code> 之后直接将该 <code>Class</code> 迁移过去即可。</p></blockquote><hr><p>本文相关资源链接</p><ul><li>GScript 源码：<a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></li><li>Playground 源码：<a href="https://github.com/crossoverJie/gscript-homepage">https://github.com/crossoverJie/gscript-homepage</a></li><li>GScript Docker地址：<a href="https://hub.docker.com/r/crossoverjie/gscript">https://hub.docker.com/r/crossoverjie/gscript</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h75zxqn8bej30gq074aa9.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;版本更新&quot;&gt;&lt;a href=&quot;#版本更新&quot; class=&quot;headerlink&quot; title=&quot;版本更新&quot;&gt;&lt;/a&gt;版本更新&lt;/h1&gt;&lt;p&gt;最近 &lt;code&gt;GScript&lt;/code&gt; 更新了 &lt;code&gt;v0.0.11&lt;/code&gt; 版本，重点更新了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Docker&lt;/code&gt; 运行环境&lt;/li&gt;
&lt;li&gt;新增了 byte 原始类型&lt;/li&gt;
&lt;li&gt;新增了一些字符串标准库 &lt;code&gt;Strings/StringBuilder&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数组切片语法：&lt;code&gt;int[] b = a[1: len(a)];&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;具体更新内容请看下文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间发布了 &lt;code&gt;GScript&lt;/code&gt; 的在线 &lt;code&gt;playground&lt;/code&gt;，&lt;br&gt;&lt;img src=&quot;http://tva1.sinaimg.cn/large/72fbb941ly1h760l8xfm0g20go0dfnen.gif&quot; alt=&quot;playground-min.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是一个可以在线运行 &lt;code&gt;GScript&lt;/code&gt; 脚本的网站，其本质原理是接收用户的输入源码从而在服务器上运行的服务；这简直就是后门大开的 &lt;code&gt;XSS&lt;/code&gt; 攻击，为保住服务器我设置了运行 &lt;code&gt;API&lt;/code&gt; 的后端服务的用户权限，这样可以避免执行一些恶意的请求。&lt;/p&gt;
&lt;p&gt;但也避免不了一些用户执行了一些耗时操作，比如一个死循环、或者是我提供 &lt;code&gt;demo&lt;/code&gt; 里的打印杨辉三角。&lt;br&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h760uozudlj30u014bdi9.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>用自己的编程语言实现了一个网站（增强版）</title>
    <link href="http://crossoverjie.top/2022/10/08/gscript/gscript08-write-site-enhance/"/>
    <id>http://crossoverjie.top/2022/10/08/gscript/gscript08-write-site-enhance/</id>
    <published>2022-10-08T00:08:09.000Z</published>
    <updated>2022-10-08T16:28:35.327Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://tva1.sinaimg.cn/large/72fbb941ly1h6wtyytk80j20zk0hsq3d.jpg" alt="gscript08-min.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间在<a href="https://crossoverjie.top/2022/09/14/gscript/gscript05-write-site/">《用自己的编程语言实现了一个网站》</a>用介绍了用 <code>GScript</code> 写的一个简单“网站”，虽然是打上引号的；页面长这样：</p><p><img src="http://tva1.sinaimg.cn/large/72fbb941ly1h6wu59169mj21000cymyg.jpg" alt="GScript-index.jpg"></p><p>看起来确实非常的挫，其实之前一直也想做一个 <code>GScript</code> 的在线 <code>playground</code> ，于是国庆期间学了一点  皮毛 <code>Vue</code> 加上老弟的帮忙（他是前端开发），最终完成了下面这个网站：</p><p><a href="https://gscript.crossoverjie.top/">https://gscript.crossoverjie.top/</a></p><p><img src="http://tva1.sinaimg.cn/large/72fbb941ly1h6wubsl36rj21b60sun5a.jpg" alt="image.png"></p><blockquote><p>❤打印源码参考了：<a href="https://wa-lang.org/playground/">https://wa-lang.org/playground/</a></p></blockquote><span id="more"></span><p>在这里可以在线运行 <code>GScript</code> 代码，借助于前端的代码编辑器插件甚至还能有一些语法提示。</p><blockquote><p>不过有些提示与 GScript 的语法不兼容，毕竟编辑器的提示是基于 JavaScript 的语法。</p></blockquote><p><img src="http://tva1.sinaimg.cn/large/72fbb941ly1h6wuejlgbfj21a60t8qbt.jpg" alt="image.png"></p><p>内置了几个 demo，可以选择运行试试。</p><p>同时也支持查看 <code>AST</code> 树和 <code>symbol</code> 符号表。</p><blockquote><p>虽然显示上还有待优化。</p></blockquote><p><img src="http://tva1.sinaimg.cn/large/72fbb941ly1h6wugjwr3yj21sm0pmn0r.jpg" alt="image.png"><br><img src="http://tva1.sinaimg.cn/large/72fbb941ly1h6wuhp7847j21ss0jk0yr.jpg" alt="image.png"></p><p>整个后端接口全都是用 <code>GScript</code> 原生代码编写的，所以这也算是 <code>GScript</code> 的一个实际应用案例。</p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="title class_">HttpContext</span>) <span class="title function_">run</span>(<span class="params">HttpContext ctx</span>) &#123;</span><br><span class="line">    string body = ctx.<span class="title function_">postFormValue</span>(<span class="string">&quot;body&quot;</span>);</span><br><span class="line">    string local = d.<span class="title function_">getCurrentTime</span>(<span class="string">&quot;Asia/Shanghai&quot;</span>,<span class="string">&quot;2006-01-02 15:04:05&quot;</span>);</span><br><span class="line">    <span class="title function_">println</span>(<span class="string">&quot;===&quot;</span> + local);</span><br><span class="line">    <span class="title function_">println</span>(body);</span><br><span class="line">    <span class="title function_">println</span>(<span class="string">&quot;===&quot;</span>);</span><br><span class="line">    <span class="title class_">RunResponse</span> r = <span class="title class_">RunResponse</span>();</span><br><span class="line">    <span class="keyword">if</span> (body == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        r.<span class="property">body</span> = <span class="string">&quot;empty code&quot;</span>;</span><br><span class="line">        ctx.<span class="title class_">JSON</span>(<span class="number">200</span>, r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string fileName = d.<span class="title function_">unix</span>(<span class="string">&quot;Asia/Shanghai&quot;</span>) + <span class="string">&quot;temp.gs&quot;</span> ;</span><br><span class="line">    s.<span class="title function_">writeFile</span>(fileName, body, <span class="number">438</span>);</span><br><span class="line">    string pwd = s.<span class="title function_">getwd</span>();</span><br><span class="line">    <span class="comment">// string res = s.command(&quot;gscript&quot;, fileName);</span></span><br><span class="line">    string res = s.<span class="title function_">command</span>(<span class="string">&quot;docker&quot;</span>,<span class="string">&quot;run&quot;</span>,<span class="string">&quot;--rm&quot;</span>,<span class="string">&quot;-v&quot;</span>, pwd+<span class="string">&quot;:/usr/src/gscript&quot;</span>,<span class="string">&quot;-w&quot;</span>,<span class="string">&quot;/usr/src/gscript&quot;</span>, <span class="string">&quot;crossoverjie/gscript&quot;</span>,<span class="string">&quot;gscript&quot;</span>, fileName);</span><br><span class="line">    s.<span class="title function_">remove</span>(fileName);</span><br><span class="line">    r.<span class="property">body</span> = res;</span><br><span class="line">    r.<span class="property">ast</span> = <span class="title function_">dumpAST</span>(body);</span><br><span class="line">    r.<span class="property">symbol</span>=<span class="title function_">dumpSymbol</span>(body);</span><br><span class="line">    ctx.<span class="title class_">JSON</span>(<span class="number">200</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">httpHandle</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/index&quot;</span>, index);</span><br><span class="line"><span class="title function_">httpHandle</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/run&quot;</span>, run);</span><br><span class="line">string[] args = s.<span class="title function_">getOSArgs</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">len</span>(args) ==<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="title function_">httpRun</span>(<span class="string">&quot;:&quot;</span> + args[<span class="number">2</span>]);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">httpRun</span>(<span class="string">&quot;:8000&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际代码量也并不多，将前端输入的代码写入到一个临时文件，再调用 OS 的 <code>command api</code> 在本地执行执行 docker，最后将标准输出和错误返回即可。</p><h1 id="版本更新"><a href="#版本更新" class="headerlink" title="版本更新"></a>版本更新</h1><p>为了能实现上述的需求，所以本次也更新了 <code>GScript</code> 的版本，新增了一些内置 <code>API</code>。</p><p><img src="http://tva1.sinaimg.cn/large/72fbb941ly1h6wv0m6aj4j20z40qwqc2.jpg" alt="image.png"></p><p>主要是新增了 <code>playground</code> 需要的一些 <code>OS api</code>、文件写入、执行系统命令、日期相关等。</p><p>同时将同一类的 <code>API</code> 合并到一个 <code>class</code> 中，方便后期维护与调用。</p><h2 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h2><p>除此之外也新增了一些易用功能，比如现在提供了更友好的编译错误信息：<br><img src="http://tva1.sinaimg.cn/large/72fbb941ly1h6wv67teksj21ru09qq6a.jpg" alt="image.png"></p><h2 id="运行时错误"><a href="#运行时错误" class="headerlink" title="运行时错误"></a>运行时错误</h2><p>运行时的异常现在也有对应提示：<br><img src="http://tva1.sinaimg.cn/large/72fbb941ly1h6wv8wbft3j21yc0d0wjj.jpg" alt="image.png"></p><p>只不过目前的显示还不太友好，打印的堆栈还是 <code>Go</code> 的，之后会优化为只显示 <code>GScript</code> 的堆栈。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有了在线的 <a href="https://gscript.crossoverjie.top/">playground</a> 后使得对 <code>GScript</code> 感兴趣的门槛更低了一些，欢迎大家试用。</p><hr><p>经过最近几个版本的迭代，<code>GScript</code> 也逐步完善了，基本完成了第一版本的需求。</p><p>后续会继续完善第二阶段的，比如：</p><ul><li>namespace</li><li>包管理</li><li>并发</li></ul><p>等内容，每一项看起来都不是那么容易啊。</p><p>之前有不少人问我 <code>GScript</code> 是拿来解决什么问题的？当时我确实没仔细想过；不过现在经过几个版本的开发有了一点想法：</p><p>是否可以将 <code>GScript</code> 作为一个脚本化的 Go 语言，毕竟 Go 是编译类型的，每次修改发布都需要经过编译才能运行，但如果可以像脚本语言，比如 <code>Python、Bash</code> 修改后就可以直接运行，这在写一些不是那么重的业务时非常有用。</p><p>同时借助于语法糖甚至可以优化掉 Go 本身被人“吐槽”的地方，比如异常、append 函数、没有运算符重载、三目运算符等。</p><blockquote><p>部分吐槽 <code>GScript</code> 已经支持。</p></blockquote><p>同时因为得益于本身也是 Go 编写的，所以 Go 的一些优点也能继承过来，比如轻量级的协程等。</p><p>Go 本身也有大量的第三方库，后续甚至也能直接使用这些现成的库。</p><p>以上只是一些美好的畅想，就像老板画的大饼一样，具体在实现过程中可能又有不一样的想法，欢迎提供建议。</p><p><code>playground</code> 地址：<br><a href="https://gscript.crossoverjie.top/">https://gscript.crossoverjie.top/</a></p><p>源码地址：<br><a href="https://github.com/crossoverjie/gscript">https://github.com/crossoverjie/gscript</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://tva1.sinaimg.cn/large/72fbb941ly1h6wtyytk80j20zk0hsq3d.jpg&quot; alt=&quot;gscript08-min.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间在&lt;a href=&quot;https://crossoverjie.top/2022/09/14/gscript/gscript05-write-site/&quot;&gt;《用自己的编程语言实现了一个网站》&lt;/a&gt;用介绍了用 &lt;code&gt;GScript&lt;/code&gt; 写的一个简单“网站”，虽然是打上引号的；页面长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tva1.sinaimg.cn/large/72fbb941ly1h6wu59169mj21000cymyg.jpg&quot; alt=&quot;GScript-index.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;看起来确实非常的挫，其实之前一直也想做一个 &lt;code&gt;GScript&lt;/code&gt; 的在线 &lt;code&gt;playground&lt;/code&gt; ，于是国庆期间学了一点  皮毛 &lt;code&gt;Vue&lt;/code&gt; 加上老弟的帮忙（他是前端开发），最终完成了下面这个网站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gscript.crossoverjie.top/&quot;&gt;https://gscript.crossoverjie.top/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tva1.sinaimg.cn/large/72fbb941ly1h6wubsl36rj21b60sun5a.jpg&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;❤打印源码参考了：&lt;a href=&quot;https://wa-lang.org/playground/&quot;&gt;https://wa-lang.org/playground/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>手写编程语言-递归函数是如何实现的？</title>
    <link href="http://crossoverjie.top/2022/09/27/gscript/gscript07-return/"/>
    <id>http://crossoverjie.top/2022/09/27/gscript/gscript07-return/</id>
    <published>2022-09-27T00:08:08.000Z</published>
    <updated>2022-09-26T17:02:46.600Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6k7cg9ushj20ic05kdge.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章主要是记录一下在 <a href="https://github.com/crossoverJie/gscript">GScript</a> 中实现递归调用时所遇到的坑，类似的问题在中文互联网上我几乎没有找到相关的内容，所以还是很有必要记录一下。</p><p>在开始之前还是简单介绍下本次更新的 <code>GScript</code> v0.0.9 所包含的内容：</p><ul><li>支持可变参数</li><li>优化 <code>append</code> 函数语义</li><li>优化编译错误信息</li><li>最后一个就是支持递归调用</li></ul><span id="more"></span><hr><p>先看第一个可变参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//formats according to a format specifier and writes to standard output.</span></span><br><span class="line">printf(string format, any ...a)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//formats according to a format specifier and returns the resulting string.</span></span><br><span class="line">string <span class="title function_">sprintf</span><span class="params">(string format, any ...a)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>以上是随着本次更新新增的两个标准函数，均支持可变参数，其中使用 <code>...</code> 表示可变参数，调用时如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">printf</span>(<span class="string">&quot;hello %s &quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="title function_">printf</span>(<span class="string">&quot;hello-%s-%s &quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="title function_">printf</span>(<span class="string">&quot;hello-%s-%d &quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="number">123</span>);</span><br><span class="line">string format = <span class="string">&quot;this is %s &quot;</span>;</span><br><span class="line"><span class="title function_">printf</span>(format, <span class="string">&quot;gscript&quot;</span>);</span><br><span class="line"></span><br><span class="line">string s = <span class="title function_">sprintf</span>(<span class="string">&quot;nice to meet %s&quot;</span>, <span class="string">&quot;you&quot;</span>);</span><br><span class="line"><span class="title function_">assertEqual</span>(s,<span class="string">&quot;nice to meet you&quot;</span>);</span><br></pre></td></tr></table></figure><p>与大部分语言类似，可变参数本质上就是一个数组，所以可以拿来循环遍历：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">add</span>(<span class="params">string s, int ...num</span>)&#123;</span><br><span class="line"><span class="title function_">println</span>(s);</span><br><span class="line">int sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="title function_">len</span>(num);i++)&#123;</span><br><span class="line">int v = num[i];</span><br><span class="line">sum = sum+v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">int x = <span class="title function_">add</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="title function_">println</span>(x);</span><br><span class="line"><span class="title function_">assertEqual</span>(x, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// appends &quot;v&quot; to the end of a array &quot;a&quot;</span></span><br><span class="line"><span class="title function_">append</span>(<span class="params">any[] a, any v</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>之后是优化了内置函数 <code>append()</code> 的语义，本次优化来自于 issue12 的建议：<br><a href="https://github.com/crossoverJie/gscript/issues/12">https://github.com/crossoverJie/gscript/issues/12</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line">int[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="title function_">println</span>(a);</span><br><span class="line"><span class="title function_">println</span>();</span><br><span class="line">a = <span class="title function_">append</span>(a,<span class="number">4</span>);</span><br><span class="line"><span class="title function_">println</span>(a);</span><br><span class="line"><span class="comment">// Output: [1 2 3 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Now</span></span><br><span class="line">int[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="title function_">println</span>(a);</span><br><span class="line"><span class="title function_">println</span>();</span><br><span class="line"><span class="title function_">append</span>(a,<span class="number">4</span>);</span><br><span class="line">int b = a[<span class="number">3</span>];</span><br><span class="line"><span class="title function_">assertEqual</span>(<span class="number">4</span>, b);</span><br><span class="line"><span class="title function_">println</span>(a);</span><br><span class="line"><span class="comment">// Output: [1 2 3 4]</span></span><br></pre></td></tr></table></figure><p>现在 <code>append</code> 之后不需要再重新赋值，也会追加数据，优化后这里看起来是一个值&#x2F;引用传递的问题，但其实底层也是值传递，只是在语法上增加了这样的语法糖，帮使用者重新做了一次赋值。</p><hr><p>之后是新增了编译错误信息提示，比如下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a+<span class="number">2</span>;</span><br><span class="line">b+c;</span><br></pre></td></tr></table></figure><p>使用没有声明的变量，现在会直接编译失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1:0: undefined: a</span><br><span class="line">2:0: undefined: b</span><br><span class="line">2:2: undefined: c</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">2</span>:<span class="number">0</span>: <span class="keyword">class</span> <span class="title class_">T</span> redeclared <span class="keyword">in</span> <span class="variable language_">this</span> block</span><br></pre></td></tr></table></figure><p>重复声明之类的语法错误也有相关提示。</p><hr><p>最后一个才是本次讨论的重点，也就是递归函数的支持。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">num</span>(<span class="params">int x,int y</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (y==<span class="number">1</span> || y ==x) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">int v1 = <span class="title function_">num</span>(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再上一个版本中 <code>int v1 = num(x - 1, y - 1);</code> 这行代码是不会执行的，具体原因后文会分析。</p><p>现在利用递归便可以实现类似于<code>打印杨辉三角</code>之类的程序了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">num</span>(<span class="params">int x,int y</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (y==<span class="number">1</span> || y ==x) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    int v1 = <span class="title function_">num</span>(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">    int v2 = <span class="title function_">num</span>(x - <span class="number">1</span>, y);</span><br><span class="line">int c = v1+v2;</span><br><span class="line">    <span class="comment">// int c = num(x - 1, y - 1)+num(x - 1, y);</span></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printTriangle</span>(<span class="params">int row</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= row - i; j++) &#123;</span><br><span class="line">           <span class="title function_">print</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="title function_">print</span>(<span class="title function_">num</span>(i, j) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printTriangle</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">      <span class="number">1</span> </span><br><span class="line">     <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">    <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line">   <span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> </span><br><span class="line">  <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">4</span> <span class="number">1</span> </span><br><span class="line"> <span class="number">1</span> <span class="number">5</span> <span class="number">10</span> <span class="number">10</span> <span class="number">5</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">15</span> <span class="number">20</span> <span class="number">15</span> <span class="number">6</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><h1 id="函数中的-return"><a href="#函数中的-return" class="headerlink" title="函数中的 return"></a>函数中的 return</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">num</span>(<span class="params">int x,int y</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (y==<span class="number">1</span> || y ==x) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">int v1 = <span class="title function_">num</span>(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来看看这样的代码为什么执行完 <code>return 1</code> 之后就不会执行后边的语句了。</p><p>其实在此之前我首先解决的时候函数 <code>return</code> 后不能执行后续 <code>statement</code> 的需求，其实正好就是上文提到的逻辑，只是这里是递归而已。</p><p>先把代码简化一下方便分析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">f1</span>(<span class="params">int a</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (a==<span class="number">10</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">println</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当参数 a 等于 10 的时候确实不能执行后续的打印语句了，那么如何实现该需求呢？</p><p>以正常人类的思考方式：当我们执行完 <code>return</code> 语句的时候，就应该标记该语句所属的函数直接返回，不能在执行后续的 <code>statement</code>。</p><p>可是这应该如何实操呢？</p><p>其实看看 <code>AST</code> 就能明白了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6kgqzbu9xj21ss0u0wiy.jpg"></p><p>当碰到 <code>return</code> 语句的时，会递归向上遍历语法树，标记上所有 <code>block</code> 节点表明这个 <code>block</code> 后续的语句不再执行了，同时还得把返回值记录下来。</p><p>这样当执行到下一个 <code>statement</code> 时，也就是 <code>println(&quot;abc&quot;);</code> 则会判断他所属的 <code>block</code> 是否有被标记，如果有则直接返回，这样便实现了 <code>return</code> 语句不执行后续代码。</p><p>部分实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 return 的时候递归向上扫描所有的 Block，并打上标记，用于后面执行 return 的时候直接返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Visitor)</span></span> scanBlockStatementCtx(tree antlr.ParseTree, value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">context, ok := tree.(*parser.BlockContext)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">if</span> v.blockCtx2Mark == <span class="literal">nil</span> &#123;</span><br><span class="line">v.blockCtx2Mark = <span class="built_in">make</span>(<span class="keyword">map</span>[*parser.BlockContext]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">v.blockCtx2Mark[context] = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> tree.GetParent() != <span class="literal">nil</span> &#123;</span><br><span class="line">v.scanBlockStatementCtx(tree.GetParent().(antlr.ParseTree), value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6kh2esn6jj214m0u0tec.jpg"></p><p>源码地址：<br><a href="https://github.com/crossoverJie/gscript/blob/793d196244416574bd6be641534742e57c54db7a/visitor.go#L182">https://github.com/crossoverJie/gscript/blob/793d196244416574bd6be641534742e57c54db7a/visitor.go#L182</a></p><h1 id="递归的问题"><a href="#递归的问题" class="headerlink" title="递归的问题"></a>递归的问题</h1><p>但同时问题也来了，就是递归的时候也不会执行后续的递归代码了。</p><p>其实解决问题的方法也很简单，就是在判断是否需要直接返回那里新增一个条件，这个 <code>block</code> 中不存在递归调用。</p><p>所以我们就得先知道这个 <code>block</code> 中是否存在递归调用。</p><p>整个过程有以下几步：</p><ul><li>编译期：在函数声明处记录下函数与当前 <code>context</code> 的映射关系。</li><li>编译期：扫描 <code>statement</code> 时，取出该 <code>statement</code> 的 <code>context</code> 所对应的函数。</li><li>编译期：扫描到的 <code>statement</code> 如果是一个函数调用，则判断该函数是否为该 <code>block</code> 中的函数，也就是第二步取出的函数。</li><li>编译期：如果两个函数相等，则将当前 <code>block</code> 标记为递归调用。</li><li>运行期：在刚才判断 <code>return</code> 语句处，额外多出判断当前 <code>block</code> 是否为递归调用，如果是则不能返回。</li></ul><p>部分代码如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6khkphcxtj21660u043f.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6khle6mnvj219a0g2tbj.jpg"></p><p><a href="https://github.com/crossoverJie/gscript/blob/3e179f27cb30ca5c3af57b3fbf2e46075baa266b/resolver/ref_resolver.go#L70">https://github.com/crossoverJie/gscript/blob/3e179f27cb30ca5c3af57b3fbf2e46075baa266b/resolver/ref_resolver.go#L70</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里的递归调用其实卡了我挺长时间的，思路是有的，但是写出来的代码总是和预期不符，当天晚上坐在电脑面前到凌晨两三点，百思不得其解。</p><p>最后受不了上床休息的时候，突然一个灵光乍现让我想到了解决方案，于是第二天起了个早床赶忙实践，还真给解决了。</p><p>所以有些时候碰到棘手问题时给自己放松一下，往往会有出其不意的效果。</p><p>最后是目前的递归在某些情况下性能还有些问题，后续会尽量将这些标记过程都放在编译期，编译慢点没事，但运行时慢那就有问题了。</p><p>之后还会继续优化运行时的异常，目前是直接 <code>panic</code>，堆栈也没有，体感非常不好；欢迎感兴趣的朋友试用反馈bug。</p><p>源码地址：</p><p><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h6k7cg9ushj20ic05kdge.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章主要是记录一下在 &lt;a href=&quot;https://github.com/crossoverJie/gscript&quot;&gt;GScript&lt;/a&gt; 中实现递归调用时所遇到的坑，类似的问题在中文互联网上我几乎没有找到相关的内容，所以还是很有必要记录一下。&lt;/p&gt;
&lt;p&gt;在开始之前还是简单介绍下本次更新的 &lt;code&gt;GScript&lt;/code&gt; v0.0.9 所包含的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持可变参数&lt;/li&gt;
&lt;li&gt;优化 &lt;code&gt;append&lt;/code&gt; 函数语义&lt;/li&gt;
&lt;li&gt;优化编译错误信息&lt;/li&gt;
&lt;li&gt;最后一个就是支持递归调用&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="递归" scheme="http://crossoverjie.top/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="antlr" scheme="http://crossoverjie.top/tags/antlr/"/>
    
  </entry>
  
  <entry>
    <title>手写编程语言-实现运算符重载</title>
    <link href="http://crossoverjie.top/2022/09/18/gscript/gscript06-operator-overloading/"/>
    <id>http://crossoverjie.top/2022/09/18/gscript/gscript06-operator-overloading/</id>
    <published>2022-09-18T00:08:08.000Z</published>
    <updated>2022-09-18T14:04:58.770Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6at95ynkaj21900u07aw.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先带来日常的 <a href="https://github.com/crossoverJie/gscript">GScript</a> 更新：新增了可变参数的特性，语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">add</span>(<span class="params">string s, int ...num</span>)&#123;</span><br><span class="line"><span class="title function_">println</span>(s);</span><br><span class="line">int sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="title function_">len</span>(num);i++)&#123;</span><br><span class="line">int v = num[i];</span><br><span class="line">sum = sum+v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">int x = <span class="title function_">add</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="title function_">println</span>(x);</span><br><span class="line"><span class="title function_">assertEqual</span>(x, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><span id="more"></span><p>得益于可变参数，所以新增了格式化字符串的内置函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//formats according to a format specifier and writes to standard output.</span></span><br><span class="line"><span class="title function_">printf</span>(<span class="params">string format, any ...a</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//formats according to a format specifier and returns the resulting string.</span></span><br><span class="line">string <span class="title function_">sprintf</span>(<span class="params">string format, any ...a</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>下面重点看看 <a href="https://github.com/crossoverJie/gscript#operator-overloading">GScript</a> 所支持的运算符重载是如何实现的。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>运算符重载其实也是多态的一种表现形式，我们可以重写运算符的重载函数，从而改变他们的计算规则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="number">100</span>+<span class="number">2</span>*<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>以这段代码的运算符为例，输出的结果自然是：104.</p><p>但如果我们是对两个对象进行计算呢，举个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">Person(<span class="type">int</span> a)&#123;</span><br><span class="line">age = a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> Person(<span class="number">10</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> Person(<span class="number">20</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> p1+p2;</span><br></pre></td></tr></table></figure><p>这样的写法在 <code>Java/Go</code> 中都会报编译错误，这是因为他们两者都不支持运算符重载；</p><p>但 <code>Python/C#</code> 是支持的，相比之下我觉得 <code>C#</code> 的实现方式更符合 <code>GScript</code> 语法，所以参考 C# 实现了以下的语法规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span> operator + (<span class="title class_">Person</span> p1, <span class="title class_">Person</span> p2)&#123;</span><br><span class="line"><span class="title class_">Person</span> pp = <span class="title class_">Person</span>(p1.<span class="property">age</span>+p2.<span class="property">age</span>);</span><br><span class="line"><span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> p3 = p1+p2;</span><br><span class="line"><span class="title function_">println</span>(<span class="string">&quot;p3.age=&quot;</span>+p3.<span class="property">age</span>);</span><br><span class="line"><span class="title function_">assertEqual</span>(p3.<span class="property">age</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>有几个硬性条件：</p><ul><li>函数名必须是 <code>operator</code> </li><li>名称后跟上运算符即可。</li></ul><blockquote><p>目前支持的运算符有：+-*&#x2F;   &#x3D;&#x3D; !&#x3D; &lt; &lt;&#x3D; &gt; &gt;&#x3D;</p></blockquote><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>以前在使用 <code>Python</code> 运算符重载时就有想过它是如何实现的？但没有深究，这次借着自己实现相关功能从而需要深入理解。</p><p>其中重点就为两步：</p><ol><li>编译期间：记录所有的重载函数和运算符的关系。</li><li>运行期：根据当前的运算找到声明的函数，直接运行即可。</li></ol><p>第一步的重点是扫描所有的重载函数，将重载函数与运算符存放起来，需要关注的是函数的返回值与运算符类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpOverload 重载符</span></span><br><span class="line"><span class="keyword">type</span> OpOverload <span class="keyword">struct</span> &#123;</span><br><span class="line">function  *Func</span><br><span class="line">tokenType <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符重载自定义函数</span></span><br><span class="line">opOverloads []*symbol.OpOverload</span><br></pre></td></tr></table></figure><p>在编译器中使用一个切片存放。</p><p>而在运行期中当两个入参类型相同时，则需要查找重载函数。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6b310mefaj21ky05u3zz.jpg"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetOpFunction 获取运算符重载函数</span></span><br><span class="line"><span class="comment">// 通过返回值以及运算符号(+-*/) 匹配重载函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AnnotatedTree)</span></span> GetOpFunction(returnType symbol.Type, tokenType <span class="type">int</span>) *symbol.Func &#123;</span><br><span class="line"><span class="keyword">for</span> _, overload := <span class="keyword">range</span> a.opOverloads &#123;</span><br><span class="line">isType := overload.GetFunc().GetReturnType().IsType(returnType)</span><br><span class="line"><span class="keyword">if</span> isType &amp;&amp; overload.GetTokenType() == tokenType &#123;</span><br><span class="line"><span class="keyword">return</span> overload.GetFunc()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找方式就是通过编译期存放的数据进行匹配，拿到重载函数后自动调用便实现了重载。</p><p>感兴趣的朋友可以查看相关代码：</p><ul><li><p>编译期：<a href="https://github.com/crossoverJie/gscript/blob/ae729ce7d4cf39fe115121993fcd2222716755e5/resolver/type_scope_resolver.go#L127">https://github.com/crossoverJie/gscript/blob/ae729ce7d4cf39fe115121993fcd2222716755e5/resolver/type_scope_resolver.go#L127</a></p></li><li><p>运行期：<a href="https://github.com/crossoverJie/gscript/blob/499236af549be47ff827c6d55de1fc8e5600b9b3/visitor.go#L387">https://github.com/crossoverJie/gscript/blob/499236af549be47ff827c6d55de1fc8e5600b9b3/visitor.go#L387</a></p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>运算符重载其实并不是一个常用的功能；因为会改变运算符的语义，比如明明是加法却在重载函数中写为减法。</p><p>这会使得代码阅读起来困难，但在某些情况下我们又非常希望语言本身能支持运算符重载。</p><p>比如在 Go 中常用的一个第三方精度库<code>decimal.Decimal</code>，进行运算时只能使用 <code>d1.Add(d2)</code> 这样的函数，当运算复杂时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a5 = (a1.Add(a2).Add(a3)).Mul(a4);</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a5 = (a1+a2+a3)*a4;</span><br></pre></td></tr></table></figure><p>就不如下面这种直观，所以有利有弊吧，多一个选项总不是坏事。</p><p>GScript 源码：<br><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h6at95ynkaj21900u07aw.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;先带来日常的 &lt;a href=&quot;https://github.com/crossoverJie/gscript&quot;&gt;GScript&lt;/a&gt; 更新：新增了可变参数的特性，语法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int &lt;span class=&quot;title function_&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;string s, int ...num&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;title function_&quot;&gt;println&lt;/span&gt;(s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int sum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(int i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;title function_&quot;&gt;len&lt;/span&gt;(num);i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		int v = num[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		sum = sum+v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int x = &lt;span class=&quot;title function_&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title function_&quot;&gt;println&lt;/span&gt;(x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title function_&quot;&gt;assertEqual&lt;/span&gt;(x, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="antlr" scheme="http://crossoverjie.top/tags/antlr/"/>
    
    <category term="运算符重载" scheme="http://crossoverjie.top/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>用自己的编程语言实现了一个网站</title>
    <link href="http://crossoverjie.top/2022/09/14/gscript/gscript05-write-site/"/>
    <id>http://crossoverjie.top/2022/09/14/gscript/gscript05-write-site/</id>
    <published>2022-09-14T00:08:08.000Z</published>
    <updated>2022-09-13T17:38:42.968Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h65ahhmp7uj20h80beweu.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇<a href="https://crossoverjie.top/2022/09/07/gscript/gscript04-preview/">《终于实现了一门属于自己的编程语言》</a> 介绍了自己写的编程语言 <a href="https://github.com/crossoverJie/gscript">GScript</a> ，在文中提到希望最终可以使用 <code>GScript</code> 开发一个网站。</p><p>到目前为止确实是做到了，首页地址：</p><p><a href="https://gscript.crossoverjie.top/index">https://gscript.crossoverjie.top/index</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h65g2ios46j20zk0iyabv.jpg"></p><p>要称为一个网站确实有点勉强，不过也是一个动态网页，因为返回的是 <code>HTML</code>，所以在当前阶段只要不嫌麻烦其实也能写一个“合格”的网站，有点像以前我们学习 <code>Java</code> 时的 <code>servlet</code>。</p><span id="more"></span><p>该页面的源码地址在这里：<br><a href="https://github.com/crossoverjie/gscript-homepage">https://github.com/crossoverjie/gscript-homepage</a></p><p>其实总共也就40来行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GScript</span>&#123;</span><br><span class="line">    string author;</span><br><span class="line">    string[] features;</span><br><span class="line">    string since;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">GScript</span>(string a, string[] f, string s)&#123;</span><br><span class="line">        author = a;</span><br><span class="line">        features = f;</span><br><span class="line">        since = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="title class_">HttpContext</span>) <span class="title function_">index</span>(<span class="params">HttpContext ctx</span>)&#123;</span><br><span class="line">    string[] features = &#123;<span class="string">&quot;statically&quot;</span>, <span class="string">&quot;strongly&quot;</span>&#125;;</span><br><span class="line">    <span class="title class_">GScript</span> gs = <span class="title class_">GScript</span>(<span class="string">&quot;crossoverJie&quot;</span>,features, <span class="string">&quot;2022&quot;</span>);</span><br><span class="line">    string j = <span class="title class_">JSON</span>(gs);</span><br><span class="line">    <span class="title function_">println</span>(j);</span><br><span class="line">    string local = <span class="title function_">getCurrentTime</span>(<span class="string">&quot;Asia/Shanghai&quot;</span>,<span class="string">&quot;2006-01-02 15:04:05&quot;</span>);</span><br><span class="line">    <span class="title function_">println</span>(<span class="string">&quot;local=&quot;</span> + local);</span><br><span class="line">    string html = ^</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>GScript<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                 _     _   </span></span><br><span class="line"><span class="language-xml"> ___ ___ ___ ___|_|___| |_ </span></span><br><span class="line"><span class="language-xml">| . |_ -|  _|  _| | . |  _|</span></span><br><span class="line"><span class="language-xml">|_  |___|___|_| |_|  _|_|  </span></span><br><span class="line"><span class="language-xml">|___|             |_|   v0.0.7   </span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">^+ j +^</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>current ^+ local +^<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com/crossoverjie/gscript-homepage&quot;</span>&gt;</span>GScript-homepace source code<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line">    ^;</span><br><span class="line">    ctx.<span class="title function_">HTML</span>(<span class="number">200</span>, html);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">httpHandle</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/index&quot;</span>, index);</span><br><span class="line">string[] args = <span class="title function_">getOSArgs</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">len</span>(args) ==<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="title function_">httpRun</span>(<span class="string">&quot;:&quot;</span> + args[<span class="number">2</span>]);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">httpRun</span>(<span class="string">&quot;:8000&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全是利用 <code>GScript</code> 所提供的标准库实现的，后文会详细聊聊内置 HTTP 包。</p><h1 id="更新内容"><a href="#更新内容" class="headerlink" title="更新内容"></a>更新内容</h1><p>下面重点来看看 <code>v0.0.8</code> 这个版本相较于上一个更新了哪些地方。</p><p>因为我是把自己当做一个开发者的角度去实现了一个 http 服务，同时还用 <code>GScript</code> 刷了两道简单的 LeetCode；为了让这个过程更流畅，更符合一个现代语言的使用方式，所以本次真的更新不少东西。</p><blockquote><p>刷题源码：<a href="https://github.com/crossoverJie/gscript/tree/main/example/leetcode">https://github.com/crossoverJie/gscript/tree/main/example/leetcode</a></p></blockquote><p>大概如下：</p><ul><li><code>any</code> 类型的支持，简化标准库的实现。</li><li>可以用 <code>^^</code> 来声明多行字符串，方便声明复杂字符串。</li><li>更完善的类型推导，修复了上个版本中某些情况推导不出类型的bug。</li><li>支持运算符重载。</li><li>基本的 http 包，可以开发出 http 服务，目前能响应 <code>JSON</code> 以及 <code>HTML</code>。</li><li>新增内置函数：根据时区获取当前时间、获取应用启动参数等。</li><li><code>JSON</code> 的序列表以及查询，语法级适配了 <a href="https://github.com/crossoverJie/xjson">XJSON</a>。</li><li>修复了在多个 <code>block</code> 嵌套情况下不能正确 <code>return</code> 的 bug。</li></ul><p>其实从这些更新中也能看出，上个版本只是一个简单能用的状态，而现在这个版本已经可以拿来写复杂逻辑了，当然目前还缺乏一些更友好的编译提示以及运行时错误。</p><p>下面仔细聊聊一些更新内容。</p><h2 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h2><p>首先是 <code>any</code> 通用类型，这个类似于 Java 中的 <code>Object</code> 和 Go 中的 <code>interface&#123;&#125;</code>,极大的方便了我们编写一些标准库。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h65gmnjk39j22u20jyjum.jpg"></p><p>以之前内置的 hash 和 len 函数为例，需要对每种类型都实现一遍，非常麻烦而且毫无必要；现在只需要定义一次即可，代码量直接省几倍。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h65go7c0lrj22ui0hqaem.jpg"><br>同理，之前实现的 Map 只支持存放 string 类型，现在便能存放任何类型的数据。</p><blockquote><p>对 any 的实现过程感兴趣的朋友，今后可以单独分享一下。</p></blockquote><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>写 go 或者是 Java 的朋友应该知道，这两门语言都无法对两个对象进行运算，编译器会直接报错。</p><p>但在一些特殊场景下还是蛮好用的，于是我参考了 <code>C#</code> 的语法在 <code>GScript</code> 中也实现了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">int age;</span><br><span class="line"><span class="title class_">Person</span>(int a)&#123;</span><br><span class="line">age = a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> operator + (<span class="title class_">Person</span> p1, <span class="title class_">Person</span> p2)&#123;</span><br><span class="line"><span class="title class_">Person</span> pp = <span class="title class_">Person</span>(p1.<span class="property">age</span>+p2.<span class="property">age</span>);</span><br><span class="line"><span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> operator - (<span class="title class_">Person</span> p1, <span class="title class_">Person</span> p2)&#123;</span><br><span class="line"><span class="title class_">Person</span> pp = <span class="title class_">Person</span>(p1.<span class="property">age</span>-p2.<span class="property">age</span>);</span><br><span class="line"><span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> p1 = <span class="title class_">Person</span>(<span class="number">10</span>);</span><br><span class="line"><span class="title class_">Person</span> p2 = <span class="title class_">Person</span>(<span class="number">20</span>);</span><br><span class="line"><span class="title class_">Person</span> p3 = p1+p2;</span><br><span class="line"><span class="title function_">println</span>(<span class="string">&quot;p3.age=&quot;</span>+p3.<span class="property">age</span>);</span><br><span class="line"><span class="title function_">assertEqual</span>(p3.<span class="property">age</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>声明的函数名称必须为 <code>operator</code>，之后跟上运算符便实现了重载。</p><p>支持的运算符有：<code>+-*/ &lt; &gt;= &lt;= &gt; ==</code>。</p><h2 id="JSON支持"><a href="#JSON支持" class="headerlink" title="JSON支持"></a>JSON支持</h2><p>当前版本中支持将对象、基本类型进行序列化，暂不支持反序列化为对象，但可以根据 <code>JSON</code> 字符串通过一定的语法查询数据。</p><p>内置了两个 JSON 相关函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return JSON string</span></span><br><span class="line">string <span class="title class_">JSON</span>(any a)&#123;&#125;</span><br><span class="line"><span class="comment">// JSON query with path</span></span><br><span class="line">any <span class="title class_">JSON</span>Get(string json, string path)&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">int age;</span><br><span class="line">string name;</span><br><span class="line">float weight;</span><br><span class="line">bool man;</span><br><span class="line"><span class="title class_">Person</span>(string n, int a, float w, bool m)&#123;</span><br><span class="line">name = n;</span><br><span class="line">age = a;</span><br><span class="line">weight = w;</span><br><span class="line">man =m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> p1 = <span class="title class_">Person</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">10</span>,<span class="number">99.99</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="title class_">Person</span> p2 = <span class="title class_">Person</span>(<span class="string">&quot;a&quot;</span>,<span class="number">11</span>,<span class="number">999.99</span>,<span class="literal">false</span>);</span><br><span class="line">string json = <span class="title class_">JSON</span>(p1);</span><br><span class="line"><span class="title function_">println</span>(json);</span><br><span class="line"><span class="comment">// output:&#123;&quot;age&quot;:10,&quot;man&quot;:true,&quot;name&quot;:&quot;abc&quot;,&quot;weight&quot;:99.99&#125;</span></span><br></pre></td></tr></table></figure><p>以这段代码为例，调用 <code>JSON</code> 函数可以将对象序列化为 <code>JSON</code> 字符串。</p><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">int age;</span><br><span class="line">string name;</span><br><span class="line">float weight;</span><br><span class="line">bool man;</span><br><span class="line"><span class="title class_">Person</span>(string n, int a, float w, bool m)&#123;</span><br><span class="line">name = n;</span><br><span class="line">age = a;</span><br><span class="line">weight = w;</span><br><span class="line">man =m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> p1 = <span class="title class_">Person</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">10</span>,<span class="number">99.99</span>,<span class="literal">true</span>);</span><br><span class="line">string json = <span class="title class_">JSON</span>(p1);</span><br><span class="line"><span class="title function_">println</span>(json);</span><br><span class="line"></span><br><span class="line">int age = <span class="title class_">JSON</span>Get(json, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="title function_">println</span>(age);</span><br><span class="line"><span class="title function_">assertEqual</span>(age,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>JSONGet</code> 函数可以在一个 JSON 字符串中查询任意的数据，这个功能是通过适配 <a href="https://github.com/crossoverJie/xjson">XJSON</a> 实现的，所以 <code>XJSON</code> 支持的查询语法都能实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">string j=^&#123;<span class="string">&quot;age&quot;</span>:<span class="number">10</span>, <span class="string">&quot;abc&quot;</span>:&#123;<span class="string">&quot;def&quot;</span>:<span class="string">&quot;def&quot;</span>&#125;,<span class="string">&quot;list&quot;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;^;</span><br><span class="line"><span class="title class_">String</span> def = <span class="title class_">JSON</span>Get(j, <span class="string">&quot;abc.def&quot;</span>);</span><br><span class="line"><span class="title function_">println</span>(def);</span><br><span class="line"><span class="title function_">assertEqual</span>(def,<span class="string">&quot;def&quot;</span>);</span><br><span class="line">int l1 = <span class="title class_">JSON</span>Get(j, <span class="string">&quot;list[0]&quot;</span>);</span><br><span class="line"><span class="title function_">println</span>(l1);</span><br><span class="line"><span class="title function_">assertEqual</span>(l1,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">string str=^</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bob&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&quot;skill&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;lang&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;go&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;feature&quot;</span>: [</span><br><span class="line">                        <span class="string">&quot;goroutine&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;channel&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;simple&quot;</span>,</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">^;</span><br><span class="line"><span class="title class_">String</span> g = <span class="title class_">JSON</span>Get(str, <span class="string">&quot;skill.lang[0].go.feature[0]&quot;</span>);</span><br><span class="line"><span class="title function_">println</span>(g);</span><br><span class="line"><span class="title function_">assertEqual</span>(g,<span class="string">&quot;goroutine&quot;</span>);</span><br></pre></td></tr></table></figure><p>比如这样复杂的嵌套 <code>JSON</code>，也能通过查询语法获取数据。</p><h2 id="HTTP-包"><a href="#HTTP-包" class="headerlink" title="HTTP 包"></a>HTTP 包</h2><p>HTTP 包是本次升级的重点，标准库中提供了以下函数和类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http lib</span></span><br><span class="line"><span class="comment">// Response json</span></span><br><span class="line"><span class="title class_">FprintfJSON</span>(int code, string path, string json)&#123;&#125;</span><br><span class="line"><span class="comment">// Resonse html</span></span><br><span class="line"><span class="title class_">FprintfHTML</span>(int code, string path, string html)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// path (relative paths may omit leading slash)</span></span><br><span class="line">string <span class="title class_">QueryPath</span>(string path)&#123;&#125;</span><br><span class="line"></span><br><span class="line">string <span class="title class_">FormValue</span>(string path, string key)&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpContext</span>&#123;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="title class_">JSON</span>(int code, any v)&#123;</span><br><span class="line">        string json = <span class="title class_">JSON</span>(v);</span><br><span class="line">        <span class="title class_">FprintfJSON</span>(code, path, json);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">HTML</span>(<span class="params">int code, any v</span>) &#123;</span><br><span class="line">        string html = v;</span><br><span class="line">        <span class="title class_">FprintfHTML</span>(code, path, html);</span><br><span class="line">    &#125;</span><br><span class="line">    string <span class="title function_">queryPath</span>(<span class="params"></span>) &#123;</span><br><span class="line">        string p = <span class="title class_">QueryPath</span>(path);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string <span class="title function_">formValue</span>(<span class="params">string key</span>)&#123;</span><br><span class="line">        string v = <span class="title class_">FormValue</span>(path, key);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bind route</span></span><br><span class="line"><span class="title function_">httpHandle</span>(<span class="params">string method, string path, func (HttpContext) handle</span>)&#123;</span><br><span class="line">    <span class="comment">// println(&quot;path=&quot;+path);</span></span><br><span class="line">    <span class="title class_">HttpContext</span> ctx = <span class="title class_">HttpContext</span>();</span><br><span class="line">    <span class="title function_">handle</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Run http server.</span></span><br><span class="line"><span class="title function_">httpRun</span>(<span class="params">string addr</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>具体的使用流程：</p><ol><li>通过定义一个函数变量实现自己的业务逻辑。</li><li>注册路由。</li><li>启动 HTTP 服务。</li></ol><p>在自己的 <code>handle</code> 中可以通过 <code>HttpContext</code> 对象拿到请求上下文，可以获取请求参数以及响应数据。<br>具体使用示例可以参考这份代码。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h65ha9w1q4j20u00w841m.jpg"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次更新比我预期的要顺利一些，因为语法树和编译器已经基本实现完毕，不会怎么改了，现在新增的特性无非就是运行时实现一些语法糖，大部分都是体力劳动；可能是新鲜感带来的兴奋剂效果，大部分时间都是痛并快乐着。</p><p>比如这两天主要就是在修复多层 <code>block</code> 嵌套时遇到 <code>return</code> 语句无法正确返回的 bug，死活折腾了两夜；终于在无数次分析 AST 找到了解决方案，现在想想确实还是相关经验太少。</p><blockquote><p>对这个 Bug 感兴趣的朋友可以点个赞，后面可以分享一下。</p></blockquote><p>下一阶段重点就是将编译信息好好整理，让开发体验更好。之后抽空再把 <code>SQL</code> 标准库实现了，这样就能愉快的 <code>CURD</code>了。</p><p>最后希望对该项目或者是编译原理感兴趣的朋友可以下载使用，提出宝贵意见，欢迎加我微信交流。</p><p>v0.0.8 下载地址：<br><a href="https://github.com/crossoverJie/gscript/releases/tag/v0.0.8">https://github.com/crossoverJie/gscript/releases/tag/v0.0.8</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h65ahhmp7uj20h80beweu.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇&lt;a href=&quot;https://crossoverjie.top/2022/09/07/gscript/gscript04-preview/&quot;&gt;《终于实现了一门属于自己的编程语言》&lt;/a&gt; 介绍了自己写的编程语言 &lt;a href=&quot;https://github.com/crossoverJie/gscript&quot;&gt;GScript&lt;/a&gt; ，在文中提到希望最终可以使用 &lt;code&gt;GScript&lt;/code&gt; 开发一个网站。&lt;/p&gt;
&lt;p&gt;到目前为止确实是做到了，首页地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gscript.crossoverjie.top/index&quot;&gt;https://gscript.crossoverjie.top/index&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h65g2ios46j20zk0iyabv.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;要称为一个网站确实有点勉强，不过也是一个动态网页，因为返回的是 &lt;code&gt;HTML&lt;/code&gt;，所以在当前阶段只要不嫌麻烦其实也能写一个“合格”的网站，有点像以前我们学习 &lt;code&gt;Java&lt;/code&gt; 时的 &lt;code&gt;servlet&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="antlr" scheme="http://crossoverjie.top/tags/antlr/"/>
    
  </entry>
  
  <entry>
    <title>终于实现了一门属于自己的编程语言</title>
    <link href="http://crossoverjie.top/2022/09/07/gscript/gscript04-preview/"/>
    <id>http://crossoverjie.top/2022/09/07/gscript/gscript04-preview/</id>
    <published>2022-09-07T00:08:08.000Z</published>
    <updated>2022-09-07T09:27:02.794Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5x5v62lgsj21o00u00u2.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>都说程序员的三大浪漫是：操作系统、编译原理、图形学；最后的图形学确实是特定的专业领域，我们几乎接触不到，所以对我来说换成网络更合适一些，最后再加上一个数据库。</p><p>这四项技术如果都能掌握的话那岂不是在 IT 行业横着走了，加上这几年互联网行业越来越不景气，越底层的技术就越不可能被替代；所以为了给自己的 30+ 危机留点出路，从今年上半年开始我就逐渐开始从头学习编译原理。</p><p>功夫不负有心人，经过近一个月的挑灯夜战，每晚都在老婆的催促下才休息，克服了中途好几次想放弃的冲动，终于现在完成了 <a href="https://github.com/crossoverJie/gscript">GScript</a> 一个预览版。</p><blockquote><p>预览版的意思是语法结构与整体设计基本完成，后续更新也不太会改动这部分内容、但还缺少一些易用功能。</p></blockquote><span id="more"></span><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>首先来看看保留环节， <a href="https://github.com/crossoverJie/gscript">GScript</a> 是如何编写 <code>hello world</code> 的。</p><p>hello_world.gs:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ gscript hello_world.gs</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>废话说完了接下来重点聊聊 <code>GScript</code> 所支持的特性了。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5x9767yayj20mi0h6myk.jpg"><br>后文会重点说明每一个特性。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>除了刚才提到的 hello world，再来看一个也是示例代码经常演示的<code>打印斐波那契数列</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">int</span><span class="params">()</span> fib()&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = a+c;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="title function_">int</span><span class="params">()</span> f = fib();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    println(f());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>整体写法与 Go 官方推荐的类似：<a href="https://go.dev/play/p/NeGuDahW2yP">https://go.dev/play/p/NeGuDahW2yP</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib returns a function that returns</span></span><br><span class="line"><span class="comment">// successive Fibonacci numbers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">a, b = b, a+b</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := fib()</span><br><span class="line"><span class="comment">// Function calls are evaluated left-to-right.</span></span><br><span class="line">fmt.Println(f(), f(), f(), f(), f())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都是通过闭包变量实现的，同时也展示了 <code>GScript</code> 对闭包、函数的使用，后文详细介绍闭包的用法。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>GScript</code> 的语法与常见的 <code>Java/Go</code> 类似，所以上手非常简单。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>先来看看基本类型，目前支持 <code>int/string/float/bool</code> 四种基本类型以及 <code>nil</code> 特殊类型。</p><p>变量声明语法和 <code>Java</code> 类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">string b,c;</span><br><span class="line"><span class="type">float</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">10.1</span>;</span><br><span class="line"><span class="type">bool</span> <span class="variable">f</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>个人觉得将类型放在前面，代码阅读起来会更清晰一些，当然这也是个人喜好。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明并初始化</span></span><br><span class="line"><span class="type">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">println(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个空数组并指定大小</span></span><br><span class="line"><span class="type">int</span>[] table = [<span class="number">4</span>]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">println();</span><br><span class="line"><span class="comment">// 向数组 append 数据</span></span><br><span class="line">a = append(a,<span class="number">4</span>);</span><br><span class="line">println(a);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len(a);i++)&#123;</span><br><span class="line">println(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过下标获取数组数据</span></span><br><span class="line"><span class="type">int</span> b=a[<span class="number">2</span>];</span><br><span class="line">println(b);</span><br></pre></td></tr></table></figure><p>其实严格来讲这并不算是数组，因为它的底层是用 <code>Go</code> 切片实现的，所以可以动态扩容。</p><p>以这段代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a=[<span class="number">2</span>]&#123;&#125;;</span><br><span class="line">println(<span class="string">&quot;数组大小:&quot;</span>+len(a));</span><br><span class="line">a = append(a,<span class="number">1</span>);</span><br><span class="line">println(<span class="string">&quot;数组大小:&quot;</span>+len(a));</span><br><span class="line">println(a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">100</span>;</span><br><span class="line">println(a);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组大小:2</span><br><span class="line">数组大小:3</span><br><span class="line">[&lt;nil&gt; &lt;nil&gt; 1]</span><br><span class="line">[100 &lt;nil&gt; 1]</span><br></pre></td></tr></table></figure><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>类的支持非常重要，是实现面向对象的基础，目前还未完全实现面向对象，只实现了数据与函数的封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> v, ListNode n)&#123;</span><br><span class="line">        value =v;</span><br><span class="line">        next = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用构造函数时不需要使用 new 关键字。</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> ListNode(<span class="number">1</span>, nil);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 . 调用对象属性或函数。</span></span><br><span class="line">println(l1.value);</span><br></pre></td></tr></table></figure><p>缺省情况下 <code>class</code> 具有无参构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">int</span> age=<span class="number">10</span>;</span><br><span class="line">string name=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>+age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造函数</span></span><br><span class="line">Person xx= Person();</span><br><span class="line">println(xx.age);</span><br><span class="line">assertEqual(xx.age, <span class="number">10</span>);</span><br><span class="line">println(xx.getAge());</span><br><span class="line">assertEqual(xx.getAge(), <span class="number">110</span>);</span><br></pre></td></tr></table></figure><p>得益于 <code>class</code> 的实现，结合刚才的数组也可以定义出自定义类型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小为 16 的 Person 数组</span></span><br><span class="line">Person[] personList = [<span class="number">16</span>]&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数其实分为两类：</p><ul><li>普通的全局函数。</li><li>类的函数。</li></ul><p>本质上没有任何区别，只是所属范围不同而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断链表是否有环</span></span><br><span class="line">bool <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == nil)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.next == nil)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">bool</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (fast.next != nil)&#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.next == nil)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast.next.next == nil)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slow.next == nil)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow)&#123;</span><br><span class="line">            ret = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> ListNode(<span class="number">1</span>, nil);</span><br><span class="line"><span class="type">bool</span> <span class="variable">b1</span> <span class="operator">=</span>hasCycle(l1);</span><br><span class="line">println(b1);</span><br><span class="line">assertEqual(b1, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">l4</span> <span class="operator">=</span> ListNode(<span class="number">4</span>, nil);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">l3</span> <span class="operator">=</span> ListNode(<span class="number">3</span>, l4);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> ListNode(<span class="number">2</span>, l3);</span><br><span class="line"><span class="type">bool</span> <span class="variable">b2</span> <span class="operator">=</span> hasCycle(l2);</span><br><span class="line">println(b2);</span><br><span class="line">assertEqual(b2, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">l4.next = l2;</span><br><span class="line"><span class="type">bool</span> <span class="variable">b3</span> <span class="operator">=</span> hasCycle(l2);</span><br><span class="line">println(b3);</span><br><span class="line">assertEqual(b3, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>这里演示了链表是否有环的一个函数，只要有其他语言的使用基础，相信阅读起来没有任何问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="type">int</span> a)&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当函数没有返回值时，可以声明为 void 或直接忽略返回类型。</p></blockquote><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包我认为是非常有意思的一个特性，可以实现很灵活的设计，也是函数式编程的基础。</p><p>所以在 <code>GScript</code> 中函数是作为一等公民存在；因此 <code>GScript</code> 也支持函数类型的变量。</p><p>函数变量声明语法如下：<code>func typeTypeOrVoid &#39;(&#39; typeList? &#39;)&#39;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部变量，全局共享。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">varExternal</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f1()&#123;</span><br><span class="line"><span class="comment">// 闭包变量对每个闭包单独可见</span></span><br><span class="line"><span class="type">int</span> <span class="variable">varInner</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">innerFun</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">println(a);</span><br><span class="line"><span class="type">int</span> c=<span class="number">100</span>;</span><br><span class="line">varExternal++;</span><br><span class="line">varInner++;</span><br><span class="line"><span class="keyword">return</span> varInner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回函数</span></span><br><span class="line"><span class="keyword">return</span> innerFun;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f2 作为一个函数类型，接收的是一个返回值和参数都是 int 的函数。</span></span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f2 = f1();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">println(<span class="string">&quot;varInner=&quot;</span> + f2(i) + <span class="string">&quot;, varExternal=&quot;</span> + varExternal);</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;=======&quot;</span>);</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f3 = f1();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">println(<span class="string">&quot;varInner=&quot;</span> + f3(i) + <span class="string">&quot;, varExternal=&quot;</span> + varExternal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">varInner=21, varExternal=11</span><br><span class="line">1</span><br><span class="line">varInner=22, varExternal=12</span><br><span class="line">=======</span><br><span class="line">0</span><br><span class="line">varInner=21, varExternal=13</span><br><span class="line">1</span><br><span class="line">varInner=22, varExternal=14</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f2 = f1();</span><br></pre></td></tr></table></figure><p>以这段代码为例：f2 是一个返回值，入参都为 int 的函数类型；所以后续可以直接当做函数调用 <code>f2(i)</code>.</p><p>例子中将闭包分别赋值给 f2 和 f3 变量，这两个变量中的闭包数据也是互相隔离、互不影响的，所有基于这个特性甚至还是实现面向对象。</p><blockquote><p>关于闭包的实现，后续会单独更新一篇。</p></blockquote><p>更多样例请参考：<a href="https://github.com/crossoverJie/gscript/tree/main/example">https://github.com/crossoverJie/gscript/tree/main/example</a></p><h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><p>标准库源码：<a href="https://github.com/crossoverJie/gscript/tree/main/internal">https://github.com/crossoverJie/gscript/tree/main/internal</a></p><p>目前实现的标准库并不多，这完全是一个体力活；基于现有的语法和基础数据类型，几乎可以实现大部分的数据结构了，所以感兴趣的朋友也欢迎来贡献标准库代码；比如 <code>Stack</code>、<code>Set</code> 之类的数据结构。</p><h2 id="MapString"><a href="#MapString" class="headerlink" title="MapString"></a>MapString</h2><p>以这个 <code>MapString</code> 为例：键值对都为 <code>string</code> 的 <code>HashMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">100</span>;</span><br><span class="line"><span class="type">MapString</span> <span class="variable">m1</span> <span class="operator">=</span> MapString();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line"><span class="type">string</span> <span class="variable">key</span> <span class="operator">=</span> i+<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">string</span> <span class="variable">value</span> <span class="operator">=</span> key;</span><br><span class="line">m1.put(key,value);</span><br><span class="line">&#125;</span><br><span class="line">println(m1.getSize());</span><br><span class="line">assertEqual(m1.getSize(),count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line"><span class="type">string</span> <span class="variable">key</span> <span class="operator">=</span> i+<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">string</span> <span class="variable">value</span> <span class="operator">=</span> m1.get(key);</span><br><span class="line">println(<span class="string">&quot;key=&quot;</span>+key+ <span class="string">&quot;:&quot;</span>+ value);</span><br><span class="line">assertEqual(key,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用起来和 <code>Java</code> 的 <code>HashMap</code> 类似，当然他的实现源码也是参考的 jdk1.7 的 <code>HashMap</code>。</p><blockquote><p>由于目前并有一个类似于 Java 的 <code>object</code> 或者是 go 中的 <code>interface&#123;&#125;</code>, 所以如果需要存放 int，那还得实现一个 MapInt，不过这个通用类型很快会实现。</p></blockquote><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// len 返回数组大小</span></span><br><span class="line">println(len(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组追加数据</span></span><br><span class="line">a = append(a,<span class="number">4</span>);</span><br><span class="line">println(a);</span><br><span class="line"><span class="comment">// output: [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言函数，不相等时会抛出运行时异常，并中断程序。</span></span><br><span class="line">assertEqual(len(a),<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 hashcode</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hashcode</span> <span class="operator">=</span> hash(key);</span><br></pre></td></tr></table></figure><p>也内置了一些基本函数，当然也这不是由 <code>GScript</code> 源码实现的，而是编译器实现的，所以新增起来要稍微麻烦一些；后续会逐步完善，比如和 IO 相关的内置函数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>现阶段的 <code>GScript</code> 还有许多功能没有完善，比如 JSON、网络库、更完善的语法检查、编译报错信息等；现在拿来刷刷 <code>LeetCode</code> 还是没有问题的。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5xaige47gj216o0lkq78.jpg"></p><p>从这 65 个 todo 就能看出还有很长的路要走，我对它的终极目标就是可以编写一个网站那就算是一个成熟的语言了。</p><p>目前还有一个问题是没有集成开发环境，现在的开发体验和白板上写代码相差无异，所以后续有时间的话尝试写一个 VS Code 的插件，至少能有语法高亮与提示。</p><p>最后对 <code>GScript</code> 或者是编译原理感兴趣的小伙伴可以加我微信一起交流。</p><p>项目源码：<a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a><br>下载地址：<a href="https://github.com/crossoverJie/gscript/releases/tag/v0.0.6">https://github.com/crossoverJie/gscript/releases/tag/v0.0.6</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h5x5v62lgsj21o00u00u2.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;都说程序员的三大浪漫是：操作系统、编译原理、图形学；最后的图形学确实是特定的专业领域，我们几乎接触不到，所以对我来说换成网络更合适一些，最后再加上一个数据库。&lt;/p&gt;
&lt;p&gt;这四项技术如果都能掌握的话那岂不是在 IT 行业横着走了，加上这几年互联网行业越来越不景气，越底层的技术就越不可能被替代；所以为了给自己的 30+ 危机留点出路，从今年上半年开始我就逐渐开始从头学习编译原理。&lt;/p&gt;
&lt;p&gt;功夫不负有心人，经过近一个月的挑灯夜战，每晚都在老婆的催促下才休息，克服了中途好几次想放弃的冲动，终于现在完成了 &lt;a href=&quot;https://github.com/crossoverJie/gscript&quot;&gt;GScript&lt;/a&gt; 一个预览版。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;预览版的意思是语法结构与整体设计基本完成，后续更新也不太会改动这部分内容、但还缺少一些易用功能。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="antlr" scheme="http://crossoverjie.top/tags/antlr/"/>
    
  </entry>
  
  <entry>
    <title>自己动手写脚本解释器--实现作用域与函数调用</title>
    <link href="http://crossoverjie.top/2022/08/17/gscript/gscript03-scope-func/"/>
    <id>http://crossoverjie.top/2022/08/17/gscript/gscript03-scope-func/</id>
    <published>2022-08-17T00:08:08.000Z</published>
    <updated>2022-08-16T17:38:48.849Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h594ovvpt6j20k00k0jse.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次利用 Antlr 重构一版 <a href="https://crossoverjie.top/2022/08/08/gscript/gscript02-antlr-statement/">用 Antlr 重构脚本解释器</a> 之后便着手新增其他功能，也就是现在看到的支持了作用域以及函数调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b= <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">age++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b+age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> foo(<span class="number">10</span>);</span><br><span class="line">e = e+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> a+b+<span class="number">3</span>+e;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">// Output:65</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>整个语法规则大部分参考了 Java，现阶段支持了：</p><ul><li>函数声明与调用。</li><li>函数调用的入栈和出栈，保证了函数局部变量在函数退出时销毁。</li><li>作用域支持，内部作用域可以访问外部作用域的变量。</li><li>基本的表达式语句，如 <code>i++, !=,==</code></li></ul><p>这次实现的重点与难点则是作用域与函数调用，实现之后也算是满足了我的好奇心，不过在讲作用域与函数调用之前先来看看一个简单的变量声明与访问语句是如何实现的，这样后续的理解会更加容易。</p><h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">a;</span><br></pre></td></tr></table></figure><blockquote><p>由于还没有实现内置函数，比如控制台输出函数 print()，所以这里就直接访问变量也能拿到数据</p></blockquote><p>运行后结果如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5904p530kj20nc0ewdgo.jpg"></p><p>首先看看变量声明语句的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">variableDeclarators</span><br><span class="line">    : typeType variableDeclarator (&#x27;,&#x27; variableDeclarator)*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">variableDeclarator</span><br><span class="line">    : variableDeclaratorId (&#x27;=&#x27; variableInitializer)?</span><br><span class="line">    ;</span><br><span class="line">typeList</span><br><span class="line">    : typeType (&#x27;,&#x27; typeType)*</span><br><span class="line">    ;</span><br><span class="line">typeType</span><br><span class="line">    : (functionType | primitiveType) (&#x27;[&#x27; &#x27;]&#x27;)*</span><br><span class="line">    ;</span><br><span class="line">primitiveType</span><br><span class="line">    : INT</span><br><span class="line">    | STRING</span><br><span class="line">    | FLOAT</span><br><span class="line">    | BOOLEAN</span><br><span class="line">    ;        </span><br></pre></td></tr></table></figure><p> 只看语法不太直观，直接看下生成的 AST 树就明白了：<br> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5907v0pzmj20w80gkmy9.jpg"><br> 编译期<br> 左边这棵 <code>BlockVardeclar</code> 树对应的就是  <code>int a=10;</code>，右边的 <code>blockStm</code> 对应的就是变量访问 <code>a</code>。</p><p> 整个程序的运行过程分为编译期和运行期，对应的流程：</p><ul><li>遍历 AST 树，做语义分析，生成对应的符号表、类型表、引用消解、还有一些语法校验，比如变量名、函数名是否重复、是否能访问私有变量等。</li><li>运行期：从编译期中生成的符号表、类型表中获取数据，执行具体的代码逻辑。</li></ul><h2 id="访问-AST"><a href="#访问-AST" class="headerlink" title="访问 AST"></a>访问 AST</h2><p>对于刚才提到的编译期和运行期其实分别对应两种访问 <code>AST</code> 的方式，这也是 <code>Antlr</code> 所提供两种方式。</p><h3 id="Listener-模式"><a href="#Listener-模式" class="headerlink" title="Listener 模式"></a>Listener 模式</h3><p>第一种是 <code>Listener</code> 模式，就这名字也能猜到是如何运行的；我们需要实现 Antlr 所提供的接口，这些接口分别对应 AST 树中的不同节点。</p><p>接着 Antlr 会自动遍历这棵树，当访问和退出某个节点时变会回调我们自定义的方法，这些接口都是没有返回值的，所以我们需要将遍历过程中的数据自行存放起来。</p><p>这点非常适合上文提到的编译期，遍历过程中产生的数据自然就会存放到符号表、类型表这些容器中。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h591ozeop0j20u00uote1.jpg"><br>以这段代码为例，我们实现了程序根节点、for循环节点的进入和退出 Listener，当 Antlr 运行到这些节点时便会执行其中的逻辑。</p><p><a href="https://github.com/crossoverJie/gscript/blob/main/resolver/type_scope_resolver.go">https://github.com/crossoverJie/gscript/blob/main/resolver/type_scope_resolver.go</a></p><h3 id="Visitor-模式"><a href="#Visitor-模式" class="headerlink" title="Visitor 模式"></a>Visitor 模式</h3><p><code>Visitor</code> 模式正好和 <code>Listener</code> 相反，这是由我们自行控制需要访问哪个 AST 节点，同时需要在每次访问之后返回数据，这点非常适合来做程序运行期。</p><p>配合在编译期中存放的数据，便可以实现各种特性了。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5922ws8o0j21n00tcgsc.jpg"></p><p>以上图为例，在访问 Prog 节点时便可以从编译期中拿到当前节点所对应的作用域 <code>scope</code>，同时我们可以自行控制访问下一个节点 <code>VisitBlockStms</code>，访问其他节点当然也是可以的，不过通常我们还是按照语法中定义的结构进行访问。</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>即便是同一个语法生成的 AST 是相同的，但我们在遍历 AST 时实现不同也就会导致不同的语义，这就是各个语言语义分析的不同之处。</p><blockquote><p>比如 Java 不允许在子作用域中声明和父作用域中相同的变量，但 JavaScript 却是可以的。</p></blockquote><p>有了上面的基础下面我们来看看作用域是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">a;</span><br></pre></td></tr></table></figure><p>还是以这段代码为例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59355xwevj21bw0rsq9k.jpg"></p><p>这里我简单画了下流程：</p><p>在编译期间会会为当前节点写入一个 <code>scope</code>，以及在 <code>scope</code> 中写入变量 <code>“a”</code>。</p><blockquote><p>这里的写入 scope 和写入变量是分为两次 Listener 进行的，具体代码实现在下面查看源码。</p></blockquote><p>第一次：<br><a href="https://github.com/crossoverJie/gscript/blob/main/resolver/type_scope_resolver.go#L21">https://github.com/crossoverJie/gscript/blob/main/resolver/type_scope_resolver.go#L21</a></p><p>第二次：<br><a href="https://github.com/crossoverJie/gscript/blob/main/resolver/type_resolver.go#L59">https://github.com/crossoverJie/gscript/blob/main/resolver/type_resolver.go#L59</a></p><p>接着是运行期，从编译期中生成的数据拿到 <code>scope</code> 以及其中的变量，获取变量时有一个细节：<br>当前 scope 中如果获取不到需要尝试从父级 <code>scope</code> 中获取，比如如下情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b= <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 b 在当前函数作用域中是获取不到的，只能在父级 <code>scope</code> 中获取。</p><blockquote><p>父级 scope 的关系是在创建 scope 的时候维护进去的，默认当前 scope 就是写入时 scope 的父级。</p></blockquote><p>关键代码试下如下图：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h593bq2mrgj211e0lwtby.jpg"></p><p>第四步获取变量的值也是需要访问到 AST 中的字面量节点获取值即可，核心代码如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h593fchoccj20wa0ia3zy.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h593fwqkgmj217p0u078h.jpg"></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数的调用最核心的就是在运行时需要把当前函数中的所有数据入栈，访问完毕后出栈，这样才能实现函数退出后自动释放函数体类的数据。</p><p>核心代码如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h593mb2qrqj216y0u0n37.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b= <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> foo();</span><br><span class="line"><span class="keyword">return</span> a+b+<span class="number">3</span>+e;</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">2</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>即便是有上面这类函数类调其他函数情况也不必担心，无非就是在执行函数体的时候再往栈中写入数据而已，函数退出后会依次退出栈帧。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h593r5bgs5j20rs11bq4b.jpg"></p><p>有点类似于匹配括号的算法 <code>&#123;[()]&#125;</code>，本质上就是递归调用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>限于篇幅其中的许多细节没有仔细讨论，感兴趣的朋友可以直接跑跑单测，debug 试试。</p><p><a href="https://github.com/crossoverJie/gscript/blob/main/compiler_test.go">https://github.com/crossoverJie/gscript/blob/main/compiler_test.go</a></p><p>目前的版本还比较初级，比如基本类型还只有 int，也没有一些常用的内置函数。</p><p>后续会逐步完善，比如新增：</p><ul><li>函数多返回值。</li><li>自定义类型</li><li>闭包</li></ul><p>等特性，这个坑会一直填下去，希望在年底可以用 <code>gscript</code> 写一个 <code>web</code> 服务端那就算是里程碑完成了。</p><p>现阶段也实现了一个简易的 <code>REPL</code> 工具，大家可以安装试用：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h594523npmj20bc0de74n.jpg"></p><p>源码地址：<br><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h594ovvpt6j20k00k0jse.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上次利用 Antlr 重构一版 &lt;a href=&quot;https://crossoverjie.top/2022/08/08/gscript/gscript02-antlr-statement/&quot;&gt;用 Antlr 重构脚本解释器&lt;/a&gt; 之后便着手新增其他功能，也就是现在看到的支持了作用域以及函数调用。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; b= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; age)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		age++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; b+age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a,&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; foo(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	e = e+&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a+b+&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;+e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;add(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Output:65&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="antlr" scheme="http://crossoverjie.top/tags/antlr/"/>
    
  </entry>
  
  <entry>
    <title>用 Antlr 重构脚本解释器</title>
    <link href="http://crossoverjie.top/2022/08/08/gscript/gscript02-antlr-statement/"/>
    <id>http://crossoverjie.top/2022/08/08/gscript/gscript02-antlr-statement/</id>
    <published>2022-08-08T00:08:08.000Z</published>
    <updated>2022-08-07T11:08:02.871Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4y7c4s1gbj20z20kd0we.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一个版本实现的脚本解释器 <a href="https://github.com/crossoverJie/gscript">GScript</a> 中实现了基本的四则运算以及 <code>AST</code> 的生成。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4ybcb7x07j20im0hcgne.jpg"></p><p>当我准备再新增一个 <code>%</code> 取模的运算符时，会发现工作很繁琐而且几乎都是重复的；主要是两步：</p><ol><li>需要在词法解析器中新增对 <code>%</code> 符号的支持。</li><li>在语法解析器遍历 AST 时对 <code>%</code> token 实现具体逻辑。</li></ol><p>其中的词法解析和遍历 AST 完全是重复工作，所以我们可否能够简化这两步呢？</p><span id="more"></span><h1 id="Antlr"><a href="#Antlr" class="headerlink" title="Antlr"></a>Antlr</h1><p><code>Antlr</code> 就是做帮我们解决这些问题的常用工具，利用它我们只需要编写词法文件，然后就可以自动生成词法、语法解析器，并且可以生成不同语言的代码。</p><p>下面以 <code>GScript</code> 的示例来看看 antlr 是如何帮我们生成词法分析器的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGScriptVisitor_Visit_Lexer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">expression := <span class="string">&quot;(2+3) * 2&quot;</span></span><br><span class="line">input := antlr.NewInputStream(expression)</span><br><span class="line">lexer := parser.NewGScriptLexer(input)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">t := lexer.NextToken()</span><br><span class="line"><span class="keyword">if</span> t.GetTokenType() == antlr.TokenEOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s (%q) %d\n&quot;</span>,</span><br><span class="line">lexer.SymbolicNames[t.GetTokenType()], t.GetText(),t.GetColumn())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//output:</span><br><span class="line"> (&quot;(&quot;) 0</span><br><span class="line">DECIMAL_LITERAL (&quot;2&quot;) 1</span><br><span class="line">PLUS (&quot;+&quot;) 2</span><br><span class="line">DECIMAL_LITERAL (&quot;3&quot;) 3</span><br><span class="line"> (&quot;)&quot;) 4</span><br><span class="line">MULT (&quot;*&quot;) 6</span><br><span class="line">DECIMAL_LITERAL (&quot;2&quot;) 8</span><br></pre></td></tr></table></figure><p><code>Antlr </code> 会自动将我们的表达式解析为 <code>token</code>，遍历 <code>token</code> 时还能拿到该 <code>token</code> 所在的代码行数、位置等信息，在编译期间做语法检查非常有用。</p><p>要实现这些我们只需要编写词法、语法规则文件即可。</p><p>刚才的示例所对应的词法、语法规则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">expr</span><br><span class="line">    : &#x27;(&#x27; expr &#x27;)&#x27;                        #NestedExpr</span><br><span class="line">    | liter=literal #Liter</span><br><span class="line">    | lhs=expr bop=( MULT | DIV ) rhs=expr #MultDivExpr</span><br><span class="line">    | lhs=expr bop=MOD rhs=expr            #ModExpr</span><br><span class="line">    | lhs=expr bop=( PLUS | SUB ) rhs=expr #PlusSubExpr</span><br><span class="line">    | expr bop=(LE | GE | GT | LT ) expr # GLe</span><br><span class="line">    | expr bop=(EQUAL | NOTEQUAL) expr # EqualOrNot</span><br><span class="line">    ;</span><br><span class="line">DECIMAL_LITERAL:    (&#x27;0&#x27; | [1-9] (Digits? | &#x27;_&#x27;+ Digits)) [lL]?;    </span><br></pre></td></tr></table></figure><blockquote><p>完整规则：<a href="https://github.com/crossoverJie/gscript/blob/main/GScript.g4">https://github.com/crossoverJie/gscript/blob/main/GScript.g4</a></p></blockquote><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antlr -Dlanguage=Go -o parser -visitor -no-listener GScript.g4</span><br></pre></td></tr></table></figure><p>就可以帮我们生成 <code>Go</code> 的代码（默认是 <code>Java</code>），关于 <code>Antlr</code> 的词法、文法规则以及安装步骤请参考<a href="https://www.antlr.org/">官网</a>。</p><p>而我们要实现具体的语法逻辑时只需要实现相关的接口，<code>Antlr</code> 会自动遍历 <code>AST</code>（当然也可以手动控制），同时在访问不同的 <code>AST</code> 节点时会回调我们自己实现的接口，这样我们就能编写自己的语法规则了。</p><p>以这里的新增的取模运算为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *GScriptVisitor)</span></span> VisitModExpr(ctx *parser.ModExprContext) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">lhs := v.Visit(ctx.GetLhs())</span><br><span class="line">rhs := v.Visit(ctx.GetRhs())</span><br><span class="line"><span class="keyword">return</span> lhs.(<span class="type">int</span>) % rhs.(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>Antlr</code> 回调 <code>VisitModExpr</code> 方法时，便能获取到 % 符号左右两侧的数据，这时只需要做相关运算即可。</p><p>基于这个模式这次新增了一个 <code>statement</code>，具体语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGScriptVisitor_VisitIfElse8</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">expression := <span class="string">`</span></span><br><span class="line"><span class="string">if(3!=(1+2))&#123;</span></span><br><span class="line"><span class="string">return 1+3</span></span><br><span class="line"><span class="string">&#125; else &#123;</span></span><br><span class="line"><span class="string">return false</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">input := antlr.NewInputStream(expression)</span><br><span class="line">lexer := parser.NewGScriptLexer(input)</span><br><span class="line">stream := antlr.NewCommonTokenStream(lexer, <span class="number">0</span>)</span><br><span class="line">parser := parser.NewGScriptParser(stream)</span><br><span class="line">parser.BuildParseTrees = <span class="literal">true</span></span><br><span class="line">tree := parser.Prog()</span><br><span class="line">visitor := GScriptVisitor&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> result = visitor.Visit(tree)</span><br><span class="line">fmt.Println(expression, <span class="string">&quot; result:&quot;</span>, result)</span><br><span class="line">assert.Equal(t, result, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Antlr 还有其他各种优势，比如可以解决：</p><ul><li>左递归。</li><li>二义性。</li><li>优先级。</li></ul><p>等问题。</p><p>这里也推荐在 IDE 中安装 Antlr 的插件，这样就可以直观的查看  AST 语法树，可以帮我们更好的调试代码。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4ydh1xkenj22gk0qm43a.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4ydhe0vnpj217s0r277g.jpg"></p><h1 id="升级-xjson"><a href="#升级-xjson" class="headerlink" title="升级 xjson"></a>升级 xjson</h1><p>借助 <code>GScript</code> 提供的 <code>statement</code>，<code>xjson</code> 也提供了有些有意思的写法：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4yekrs5r5j219w0fu0v9.jpg"></p><p>因为 <code>xjson</code> 的四则运算语法没有使用 <code>Antlr</code> 生成，所以为了能支持 <code>GScript</code> 提供的 <code>statement</code> 需要手写许多词法代码。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4ye5optx1j21ji0u0wir.jpg"></p><p>这也体现了 <code>Antlr</code> 这类前端工具的重要性，效率提升是非常明显的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>借助于 <code>Antlr</code> 后续 <code>GScript</code> 会继续支持函数调用、更完善的类型系统、面向对象等特性；感兴趣的朋友请持续关注。</p><p>源码地址：<br><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a><br><a href="https://github.com/crossoverJie/xjson">https://github.com/crossoverJie/xjson</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h4y7c4s1gbj20z20kd0we.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一个版本实现的脚本解释器 &lt;a href=&quot;https://github.com/crossoverJie/gscript&quot;&gt;GScript&lt;/a&gt; 中实现了基本的四则运算以及 &lt;code&gt;AST&lt;/code&gt; 的生成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h4ybcb7x07j20im0hcgne.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;当我准备再新增一个 &lt;code&gt;%&lt;/code&gt; 取模的运算符时，会发现工作很繁琐而且几乎都是重复的；主要是两步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要在词法解析器中新增对 &lt;code&gt;%&lt;/code&gt; 符号的支持。&lt;/li&gt;
&lt;li&gt;在语法解析器遍历 AST 时对 &lt;code&gt;%&lt;/code&gt; token 实现具体逻辑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中的词法解析和遍历 AST 完全是重复工作，所以我们可否能够简化这两步呢？&lt;/p&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="antlr" scheme="http://crossoverjie.top/tags/antlr/"/>
    
  </entry>
  
  <entry>
    <title>用位运算为你的程序加速</title>
    <link href="http://crossoverjie.top/2022/08/01/gjson/xjson04-bitwisee-operation/"/>
    <id>http://crossoverjie.top/2022/08/01/gjson/xjson04-bitwisee-operation/</id>
    <published>2022-08-01T00:14:36.000Z</published>
    <updated>2022-07-31T07:12:35.226Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4p37zeb9aj20xc0go0tv.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在持续优化之前编写的 <code>JSON</code> 解析库 <a href="https://github.com/crossoverJie/xjson">xjson</a>，主要是两个方面的优化。</p><p>第一个是支持将一个 <code>JSONObject</code> 对象输出为 <code>JSON</code> 字符串。</p><p>这点在上个版本中只是利用自带的 <code>Print</code> 函数打印数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJson4</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">str := <span class="string">`&#123;&quot;people&quot;:&#123;&quot;name&quot;:&#123;&quot;first&quot;:&quot;bob&quot;&#125;&#125;&#125;`</span></span><br><span class="line">first := xjson.Get(str, <span class="string">&quot;people.name.first&quot;</span>)</span><br><span class="line">assert.Equal(t, first.String(), <span class="string">&quot;bob&quot;</span>)</span><br><span class="line">get := xjson.Get(str, <span class="string">&quot;people&quot;</span>)</span><br><span class="line">fmt.Println(get.String())</span><br><span class="line"><span class="comment">//assert.Equal(t, get.String(),`&#123;&quot;name&quot;:&#123;&quot;first&quot;:&quot;bob&quot;&#125;&#125;`)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[name:map[first:bob]]</span><br></pre></td></tr></table></figure><span id="more"></span><p>本次优化之后便能直接输出 JSON 字符串了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4p3ihijjgj20ne05s0sw.jpg"></p><p>实现过程也很简单，只需要递归遍历 object 中的数据，然后拼接字符串即可，核心代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> r.Token &#123;</span><br><span class="line"><span class="keyword">case</span> String:</span><br><span class="line"><span class="keyword">return</span> fmt.Sprint(r.object)</span><br><span class="line"><span class="keyword">case</span> Bool:</span><br><span class="line"><span class="keyword">return</span> fmt.Sprint(r.object)</span><br><span class="line"><span class="keyword">case</span> Number:</span><br><span class="line">i, _ := strconv.Atoi(fmt.Sprint(r.object))</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, i)</span><br><span class="line"><span class="keyword">case</span> Float:</span><br><span class="line">i, _ := strconv.ParseFloat(fmt.Sprint(r.object), <span class="number">64</span>)</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, i)</span><br><span class="line"><span class="keyword">case</span> JSONObject:</span><br><span class="line"><span class="keyword">return</span> object2JSONString(r.object)</span><br><span class="line"><span class="keyword">case</span> ArrayObject:</span><br><span class="line"><span class="keyword">return</span> object2JSONString(r.Array())</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4q0yqg8u1j20u00zl0vy.jpg"></p><h1 id="用位运算优化"><a href="#用位运算优化" class="headerlink" title="用位运算优化"></a>用位运算优化</h1><p>第二个优化主要是提高了性能，查询一个复杂 JSON 数据的时候性能提高了大约 ⏫16%.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">优化前</span></span><br><span class="line">BenchmarkDecode-12         90013             66905 ns/op           42512 B/op       1446 allocs/op</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">优化后</span></span><br><span class="line">BenchmarkDecode-12        104746             59766 ns/op           37749 B/op       1141 allocs/op</span><br></pre></td></tr></table></figure><p>这里截取了一些重点改动的部分：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4q29pojhdj223g0u0gsv.jpg"></p><p>在 JSON 解析过程中会有一个有限状态机状态迁移的过程，而迁移的时候可能会出现多个状态。</p><p>比如当前解析到的 token 值为 <code>&#123;</code>，那它接下来的 token 可能会为 <code>ObjectKey:&quot;name&quot;</code>,也可能会是 <code>BeginObject:&#123;</code>,当然也可能会是 <code>EndObject:&#125;</code>，<br>所以在优化之前我是将状态全部存放在一个集合中的，在解析过程中如果发现状态不满足预期的列表时则会抛出语法异常的错误。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4q2ysk89kj22s409omyd.jpg"></p><p>所以优化之前是遍历这个集合来进行判断的，这样的时间复杂度为 <code>O(N)</code>,但当我们换成位运算就不一样了，时间复杂度直接就变为<code>O(1)</code>了，同时还节省了一个切片的存储空间。</p><p>我们简单来分析下这个位运算为什么会达到判断一个数据是否在一个集合中同样的效果。</p><p>首先以这两个状态为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StatusObjectKey   status = <span class="number">0x0002</span></span><br><span class="line">StatusColon       status = <span class="number">0x0004</span></span><br></pre></td></tr></table></figure><p>他们分别对应的二进制数据为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StatusObjectKey   status = <span class="number">0x0002</span> <span class="comment">//0010</span></span><br><span class="line">StatusColon       status = <span class="number">0x0004</span> <span class="comment">//0100</span></span><br></pre></td></tr></table></figure><p>当我们对这两个数据求 <code>|</code> 运算得到的数据是 <code>0110</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A:<span class="number">0010</span></span><br><span class="line">B:<span class="number">0100</span></span><br><span class="line"></span><br><span class="line">C:<span class="number">0110</span></span><br></pre></td></tr></table></figure><p>这时候如何我们如果用这两个原始数据与 <code>C:0110</code> 做 <code>&amp;</code> 运算时就会还原为刚才的两个数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input:</span></span><br><span class="line">A:<span class="number">0010</span></span><br><span class="line">C:<span class="number">0110</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">A:<span class="number">0010</span></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"><span class="comment">// input:</span></span><br><span class="line">B:<span class="number">0100</span></span><br><span class="line">C:<span class="number">0110</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">B:<span class="number">0100</span></span><br></pre></td></tr></table></figure><p>但我们换一个 D 与 C 求 <code>&amp;</code> 时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D: <span class="number">1000</span> <span class="comment">// 0x0008 对应的二进制为 1000</span></span><br><span class="line">C: <span class="number">0110</span></span><br><span class="line">D<span class="string">&#x27;:0000</span></span><br></pre></td></tr></table></figure><p>将会得到一个 0 值，只要得出的数据大于 0 我们就能判断一个数据是否在给定的集合中了。</p><blockquote><p>当然这里有一个前提条件就是，我们输入的数据高位永远都是是 1 才行，也就是2的幂。</p></blockquote><p>同样的优化在解析查询语法时也有使用：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4q45v8q2dj22va0msaf2.jpg"></p><h1 id="其他奇淫巧技"><a href="#其他奇淫巧技" class="headerlink" title="其他奇淫巧技"></a>其他奇淫巧技</h1><p>当然位运算还有一些其他技巧，比如判断奇偶数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偶数</span></span><br><span class="line">a &amp; <span class="number">1</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 奇数</span></span><br><span class="line">a &amp; <span class="number">1</span> == <span class="number">1</span></span><br></pre></td></tr></table></figure><p>乘法和除法，右移1一位是除以2，左移一位是乘以2.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">2</span></span><br><span class="line">fmt.Println(x&gt;&gt;<span class="number">1</span>) <span class="comment">//1</span></span><br><span class="line">fmt.Println(x&lt;&lt;<span class="number">1</span>) <span class="comment">//4</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>位运算在带来程序性能提升的同时也降低代码可读性，所以我们得按需选择是否使用；</p><p>再一些底层库、框架代码对性能有极致追求的场景推荐使用，但在业务代码中对数据做加减乘除就没必要用位运算了，只会让后续的维护者一脸懵逼。</p><p>相关代码：<a href="https://github.com/crossoverJie/xjson">https://github.com/crossoverJie/xjson</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h4p37zeb9aj20xc0go0tv.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在持续优化之前编写的 &lt;code&gt;JSON&lt;/code&gt; 解析库 &lt;a href=&quot;https://github.com/crossoverJie/xjson&quot;&gt;xjson&lt;/a&gt;，主要是两个方面的优化。&lt;/p&gt;
&lt;p&gt;第一个是支持将一个 &lt;code&gt;JSONObject&lt;/code&gt; 对象输出为 &lt;code&gt;JSON&lt;/code&gt; 字符串。&lt;/p&gt;
&lt;p&gt;这点在上个版本中只是利用自带的 &lt;code&gt;Print&lt;/code&gt; 函数打印数据：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestJson4&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	str := &lt;span class=&quot;string&quot;&gt;`&amp;#123;&amp;quot;people&amp;quot;:&amp;#123;&amp;quot;name&amp;quot;:&amp;#123;&amp;quot;first&amp;quot;:&amp;quot;bob&amp;quot;&amp;#125;&amp;#125;&amp;#125;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	first := xjson.Get(str, &lt;span class=&quot;string&quot;&gt;&amp;quot;people.name.first&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	assert.Equal(t, first.String(), &lt;span class=&quot;string&quot;&gt;&amp;quot;bob&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	get := xjson.Get(str, &lt;span class=&quot;string&quot;&gt;&amp;quot;people&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fmt.Println(get.String())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//assert.Equal(t, get.String(),`&amp;#123;&amp;quot;name&amp;quot;:&amp;#123;&amp;quot;first&amp;quot;:&amp;quot;bob&amp;quot;&amp;#125;&amp;#125;`)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Output:&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;map[name:map[first:bob]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="xjson" scheme="http://crossoverjie.top/categories/xjson/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/xjson/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="Bitwise operation" scheme="http://crossoverjie.top/tags/Bitwise-operation/"/>
    
  </entry>
  
  <entry>
    <title>【译】Goland 中的隐藏宝石</title>
    <link href="http://crossoverjie.top/2022/07/28/translation/hidden-gems-goland/"/>
    <id>http://crossoverjie.top/2022/07/28/translation/hidden-gems-goland/</id>
    <published>2022-07-28T00:03:13.000Z</published>
    <updated>2022-07-27T16:49:13.445Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://blog.jetbrains.com/go/2022/07/21/hidden-gems-in-goland/">原文链接</a></strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4lrsooqqjj212w0k6t9k.jpg"></p><p>在日常使用 <code>Goland</code> 时，团队收集了一些可以帮助我们专注于创造的同时减少重复工作的小技巧。<br>如果你是在 <code>IDEA</code> 中使用的 <code>Go</code> 插件，或者其他 <code>IntelliJ</code> 的产品，同样也有这些特性。</p><span id="more"></span><h1 id="行排序"><a href="#行排序" class="headerlink" title="行排序"></a>行排序</h1><p>当你在查看文本文件时，行排序非常有用；按照字母排序后能够帮我们更好的阅读，同时也容易找到重复的行。</p><p>在菜单栏中使用 <code>Edit | Sort Lines or Edit | Reverse Lines</code>可以帮我们快速的对选中的代码或者是整个文件进行排序；或者也可以使用快速命令执行这个操作。</p><p><img src="https://lh4.googleusercontent.com/G6g_eIinHwfZchGFPW9cBWYqYzrLuDTQYFafJZ0U0XlibbgANGVZwfgu7UM7bdN1Kr5tiPxk1ELV5F6sgQILyJKyDiziwUGqBOZxUWugfxNvZ9kw4KQBbl9zv-Z4oj8Uxru3Y12glEkhvWAqXxy0R-Q"></p><h1 id="打开对比窗口"><a href="#打开对比窗口" class="headerlink" title="打开对比窗口"></a>打开对比窗口</h1><p>打开一个对比窗口可以帮助我们对比任何文件、文件夹、文本；举个例子，将复制的内容粘贴到对比窗口中，IDE 会类似于版本控制系统那样展示两者的差异。</p><p>当然也可以用快速指令打开对比窗口（double shift)。</p><p><img src="https://lh4.googleusercontent.com/2GtGBX33TZw7WEyVgSYwYcRozVp4AYp8xNYUp4fXtjWXiwolR5ikJdf-AoROpJw1A2HKyolrLR5HAdYUYWbIgJydX01FBOlUQ54BMHh7KS9Jda1Slc0QQp_N-uGwYsBBKAr-yhtsiVWTNrSB6PpYeIA"></p><p>此外你也可以在 IDE 编辑器的任何地方右键鼠标选择与当前粘贴板数据进行对比。</p><blockquote><p>这个功能很棒，可以替换掉以前大部分用 BeyondCompare 的场景了。</p></blockquote><h1 id="暂存文件"><a href="#暂存文件" class="headerlink" title="暂存文件"></a>暂存文件</h1><p>有时候你需要一个随意的地方来编写一段文本，与当前工作相关的一些记录，也或是与当前项目上下文无关的草稿代码；这时候就需要用到暂存文件了。</p><p>暂存文件可不只是简单的笔记，它支持语法高亮、代码提示以及所有和这个文件类型相关的特性。</p><p>暂存文件与当前项目无关，你可以在任意项目中访问到这些文件，这样你就不需要离开 IDE 到其他地方来保存这些文件了。</p><p>可以在菜单栏中新建暂存文件<code>File | New | Scratch File or</code>，也可以使用快捷键 <code>⇧ ⌘ N</code>.</p><p><img src="https://lh4.googleusercontent.com/d-HxnmVYaZOJq8mqJzCMagroGVpg6i7E2VF2j44MhGsqluWKRXENxgZI4sy8pLNaYex6hxSD9Yg0hNM06PgKvKjifGNYYfbA21C4mCiQAN0GctH2SK2fW9DFg1boZ3G2gZyradsaGVH08clG96s1KnY"></p><blockquote><p>通常使用这个功能来存放和运行一些测试或者是实例代码。</p></blockquote><h1 id="多行光标"><a href="#多行光标" class="headerlink" title="多行光标"></a>多行光标</h1><p>多行光标可以让你快速在多个地方同时修改代码，同时它也支持代码提示以及实时模板。</p><p>开启多行光标可以双击 <code>⌥/Ctrl</code> 后不要释放，然后点击上下箭头键。使用 <code>Escape</code> 键可以退出多行光标。</p><p><img src="https://lh3.googleusercontent.com/Zb_1_CiZAP0_6rvAKurH-LsP3OOXqUufkLeeOTWtsCj2EtHAgPZ7sJq3_39oLwwT8bL8gH1eLynMLCQoBI73pUi5STUozXcCOBFry4lGLI-XVEAQYSrQ-opyFv1S_HKt56jYwDAimcFWskDbPpp85nQ"></p><blockquote><p>这个在批量修改代码时非常有用。</p></blockquote><h1 id="批量折叠和展开"><a href="#批量折叠和展开" class="headerlink" title="批量折叠和展开"></a>批量折叠和展开</h1><p>在阅读复杂长篇代码的过程中有时候很难弄懂代码结构，即便是代码是我们自己写的。</p><p>这也容易解决，批量折叠和展开可以快速帮我们浏览代码，快捷键是：macOS:<code>⇧⌘- /⇧⌘+</code>,Windows&#x2F;Linux: <code>Ctrl+Shift+NumPad + / Ctrl+Shift+NumPad</code>。</p><p>IDE 可以帮我们折叠&#x2F;展开选中的代码，如果没有选中则是处理整个文件。</p><p>也可以使用 macOS:<code> ⌥⌘- / ⌥⌘+</code>, Windows&#x2F;Linux:<code>Ctrl+Alt+NumPad + / Ctrl+Alt+NumPad</code> 来递归的处理代码，IDE 将会折叠&#x2F;展开当前代码片段或者是他们包含的片段。</p><p><img src="https://lh5.googleusercontent.com/cYtEgj2G98zshGwM-1a91f6_kqP1ZjLdWA_yQOCsXOo_0KQC4O9HL1Lphs-vdN71kiD_XjZ_Rh5oDo8zhuh9u7KuSacMFqfv6U1F0kXd8zJT3uF3f0GkZgu1P-OgAPGrG77ByWn5UmcK-uIdZ0Iahqo"></p><h1 id="最近文件"><a href="#最近文件" class="headerlink" title="最近文件"></a>最近文件</h1><p>最近文件可以帮助我们快速跳转到最近经常打开的文件，当我们使用 macOS:<code>⌘+E</code> Windows&#x2F;Linux:<code>Ctrl + E</code> 打开最近文件对话框的时，再使用<code>⌘+E</code>可以再次过滤只显示已经修改过的文件，这样可以帮我们更精准的查找。</p><p><img src="https://lh5.googleusercontent.com/dfCbbr1RJYJGM12VmuNf7ebgvi01W3yseLvHLELhaMSyTy_MK2N3VmgXxJqcgJ3NVlYzsX9PV3_qiUA9cy_T8_Z5HGY9FDYyn6AwT9Xk6wTieDHl89hKf0JsCeV3XNZEgPcB9TgjbM8CH4o12RyRhfQ"></p><p>这些特性可能有些并不常用，一旦用上一次解决问题后会发现 <code>IntelliJ</code> 的 <code>IDE</code> 功能非常强大，如果你还发现了一些其他有用的特性请在留言区分享。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://blog.jetbrains.com/go/2022/07/21/hidden-gems-in-goland/&quot;&gt;原文链接&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h4lrsooqqjj212w0k6t9k.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在日常使用 &lt;code&gt;Goland&lt;/code&gt; 时，团队收集了一些可以帮助我们专注于创造的同时减少重复工作的小技巧。&lt;br&gt;如果你是在 &lt;code&gt;IDEA&lt;/code&gt; 中使用的 &lt;code&gt;Go&lt;/code&gt; 插件，或者其他 &lt;code&gt;IntelliJ&lt;/code&gt; 的产品，同样也有这些特性。&lt;/p&gt;</summary>
    
    
    
    <category term="翻译" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="IDE" scheme="http://crossoverjie.top/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>XJSON 是如何实现四则运算的？</title>
    <link href="http://crossoverjie.top/2022/07/12/gjson/xjson03/"/>
    <id>http://crossoverjie.top/2022/07/12/gjson/xjson03/</id>
    <published>2022-07-12T00:12:36.000Z</published>
    <updated>2022-07-11T16:59:34.673Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h42y3ylnbuj20wi0lomz7.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<a href="https://crossoverjie.top/2022/07/04/gjson/gjson02/">上一篇</a>中介绍了 <code>xjson</code> 的功能特性以及使用查询语法快速方便的获取 <code>JSON</code> 中的值。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h42btsa4cgj21cs0mmjuh.jpg"></p><p>同时这次也更新了一个版本，主要是两个升级：</p><ol><li>对转义字符的支持。</li><li>性能优化，大约提升了30%⬆️。</li></ol><span id="more"></span><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>先说第一个转义字符，不管是原始 <code>JSON</code> 字符串中存在转义字符，还是查询语法中存在转义字符都已经支持，具体用法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">`&#123;&quot;1a.b.[]&quot;:&quot;b&quot;&#125;`</span></span><br><span class="line">get = Get(str, <span class="string">&quot;1a\\.b\\.\\[\\]&quot;</span>)</span><br><span class="line">assert.Equal(t, get.String(), <span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line">str = <span class="string">`&#123;&quot;.&quot;:&quot;b&quot;&#125;`</span></span><br><span class="line">get = Get(str, <span class="string">&quot;\\.&quot;</span>)</span><br><span class="line">assert.Equal(t, get.String(), <span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line">str = <span class="string">`&#123;&quot;a&quot;:&quot;&#123;\&quot;a\&quot;:\&quot;123\&quot;&#125;&quot;&#125;`</span></span><br><span class="line">get = Get(str, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">fmt.Println(get)</span><br><span class="line">assert.Equal(t, get.String(), <span class="string">&quot;&#123;\&quot;a\&quot;:\&quot;123\&quot;&#125;&quot;</span>)</span><br><span class="line">assert.Equal(t, Get(get.String(), <span class="string">&quot;a&quot;</span>).String(), <span class="string">&quot;123&quot;</span>)</span><br><span class="line"></span><br><span class="line">str = <span class="string">`&#123;&quot;a&quot;:&quot;&#123;\&quot;a\&quot;:[1,2]&#125;&quot;&#125;`</span></span><br><span class="line">get = Get(str, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">fmt.Println(get)</span><br><span class="line">assert.Equal(t, get.String(), <span class="string">&quot;&#123;\&quot;a\&quot;:[1,2]&#125;&quot;</span>)</span><br><span class="line">assert.Equal(t, Get(get.String(), <span class="string">&quot;a[0]&quot;</span>).Int(), <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>性能也有部分优化，大约比上一版本提升了 30%。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pkg: github.com/crossoverJie/xjson/benckmark</span><br><span class="line">cpu: Intel(R) Core(TM) i7<span class="number">-9750</span>H CPU @ <span class="number">2.60</span>GHz</span><br><span class="line">BenchmarkDecode<span class="number">-12</span>           <span class="number">14968</span>     <span class="number">77130</span> ns/op   <span class="number">44959</span> B/op    <span class="number">1546</span> allocs/op</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line">pkg: github.com/crossoverJie/xjson/benckmark</span><br><span class="line">cpu: Intel(R) Core(TM) i7<span class="number">-9750</span>H CPU @ <span class="number">2.60</span>GHz</span><br><span class="line">BenchmarkDecode<span class="number">-12</span>           <span class="number">19136</span>     <span class="number">62960</span> ns/op   <span class="number">41593</span> B/op    <span class="number">1407</span> allocs/op</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>但总体来说还有不少优化空间，主要是上限毕竟低，和官方库比还是有不小的差距。</p><h1 id="实现四则运算"><a href="#实现四则运算" class="headerlink" title="实现四则运算"></a>实现四则运算</h1><p>接下来聊聊四则运算是如何实现的，这本身算是一个比较有意思的 <code>feature</code>，虽然用的场景不多🙂。</p><p>先来看看是如何使用的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">json :=<span class="string">`&#123;&quot;alice&quot;:&#123;&quot;age&quot;:10&#125;,&quot;bob&quot;:&#123;&quot;age&quot;:20&#125;,&quot;tom&quot;:&#123;&quot;age&quot;:20&#125;&#125;`</span></span><br><span class="line">query := <span class="string">&quot;(alice.age+bob.age) * tom.age&quot;</span></span><br><span class="line">arithmetic := GetWithArithmetic(json, query)</span><br><span class="line">assert.Equal(t, arithmetic.Int(), <span class="number">600</span>)</span><br></pre></td></tr></table></figure><p>输入一个 <code>JSON</code> 字符串以及计算公式然后得到计算结果。</p><p>其实实现原理也比较简单，总共分为是三步:</p><ol><li>对 <code>json</code> 进行词法分析，得到一个四则运算的第一步 <code>token</code>。</li><li>基于该 <code>token</code> 流，生产出最终的四则运算表达式，比如 <code>(3+2)*5</code></li><li>调用四则运算处理器，拿到最终结果。</li></ol><hr><p>先看第一步，根据 <code>(alice.age+bob.age) * tom.age</code> 解析出 <code>token</code>：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h43ekglsqej21g6078jsl.jpg"></p><p>第二步，解析该 token，碰到 <code>Identifier</code> 类型时，将其解析为具体的数据。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h43em2y8q3j21ha0l2tcj.jpg"><br>而其他类型的 token 直接拼接字符串即可，最终生成表达式：<code>(10+20)*20</code></p><blockquote><p>这一步的核心功能是由 <code>xjson.Get(json, query)</code> 函数提供的。</p></blockquote><p>关键代码如下图所示：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h43epvk5t8j20u00v20ws.jpg"></p><p>最终的目的就是能够生成一个表达式，只要拿到这个四则运算表达式便能得到最终计算结果。</p><p>而最终的计算逻辑其实也挺简单，构建一个 AST 树，然后深度遍历递归求解即可，如下图所示：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h43eugwrduj20n80n4mxz.jpg"></p><blockquote><p>这一步的核心功能是有之前实现的脚本解释器 <a href="https://github.com/crossoverJie/gscript/blob/4897b0dd0e4110820c1e69f7a692d90640325cbd/syntax/parse.go#L10">gscipt</a> 提供的。</p></blockquote><p>感兴趣的朋友可以查看源码。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个 <code>JSON</code> 库的功能其实并不多，欢迎大家分享平时用 <code>JSON</code> 库的常用功能；也欢迎大家体验下这个库。</p><p>源码地址：<br><a href="https://github.com/crossoverJie/xjson">https://github.com/crossoverJie/xjson</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h42y3ylnbuj20wi0lomz7.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;https://crossoverjie.top/2022/07/04/gjson/gjson02/&quot;&gt;上一篇&lt;/a&gt;中介绍了 &lt;code&gt;xjson&lt;/code&gt; 的功能特性以及使用查询语法快速方便的获取 &lt;code&gt;JSON&lt;/code&gt; 中的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h42btsa4cgj21cs0mmjuh.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;同时这次也更新了一个版本，主要是两个升级：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对转义字符的支持。&lt;/li&gt;
&lt;li&gt;性能优化，大约提升了30%⬆️。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="xjson" scheme="http://crossoverjie.top/categories/xjson/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/xjson/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>用面向对象的方式操作 JSON 甚至还能做四则运算 JSON 库</title>
    <link href="http://crossoverjie.top/2022/07/04/gjson/gjson02/"/>
    <id>http://crossoverjie.top/2022/07/04/gjson/gjson02/</id>
    <published>2022-07-04T00:13:36.000Z</published>
    <updated>2022-07-05T02:35:05.552Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3vuj0uxlcj208u07tmxb.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在之前实现的 <a href="https://crossoverjie.top/2022/06/28/xjson/xjson01/"><code>JSON</code> 解析器</a>中当时只实现了将一个 JSON 字符串转换为一个 <code>JSONObject</code>，并没有将其映射为一个具体的 <code>struct</code>；如果想要获取值就需要先做断言将其转换为 <code>map</code> 或者是切片再来获，会比较麻烦。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">decode, err := xjson.Decode(<span class="string">`&#123;&quot;glossary&quot;:&#123;&quot;title&quot;:&quot;example glossary&quot;,&quot;age&quot;:1&#125;&#125;`</span>)</span><br><span class="line">assert.Nil(t, err)</span><br><span class="line">glossary := v[<span class="string">&quot;glossary&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">assert.Equal(t, glossary[<span class="string">&quot;title&quot;</span>], <span class="string">&quot;example glossary&quot;</span>)</span><br><span class="line">assert.Equal(t, glossary[<span class="string">&quot;age&quot;</span>], <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>但其实转念一想，部分场景我们甚至我们只需要拿到 <code>JSON</code> 中的某个字段的值，这样还需要先声明一个 <code>struct</code> 会略显麻烦。</p><p>经过查询发现已经有了一个类似的库来解决该问题，<a href="https://github.com/tidwall/xjson">https://github.com/tidwall/xjson</a> 并且 star 数还很多（甚至名字都是一样的😂），说明这样的需求大家还是很强烈的。</p><p>于是我也打算增加类似的功能，使用方式如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3t43ocuudj20zn0u0wha.jpg"></p><span id="more"></span><blockquote><p>最后还加上了一个四则运算的功能。</p></blockquote><h1 id="面向对象的方式操作-JSON"><a href="#面向对象的方式操作-JSON" class="headerlink" title="面向对象的方式操作 JSON"></a>面向对象的方式操作 JSON</h1><p>因为功能类似，所以我参考了 <code>tidwall</code> 的 <code>API</code> 但去掉一些我觉得暂时用不上的特性，并调整了一点语法。</p><p>当前这个版本只能通过确定的 <code>key</code> 加上 <code>.</code> 点符号访问数据，如果是数组则用 <code>[index]</code> 的方式访问下标。<br><code>[]</code> 符号访问数组我觉得要更符合直觉一些。</p><p>以下是一个包含多重嵌套 <code>JSON</code> 的访问示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">`</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;bob&quot;,</span></span><br><span class="line"><span class="string">&quot;age&quot;: 20,</span></span><br><span class="line"><span class="string">&quot;skill&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;lang&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;go&quot;: &#123;</span></span><br><span class="line"><span class="string">                &quot;feature&quot;: [</span></span><br><span class="line"><span class="string">                    &quot;goroutine&quot;,</span></span><br><span class="line"><span class="string">                    &quot;channel&quot;,</span></span><br><span class="line"><span class="string">                    &quot;simple&quot;,</span></span><br><span class="line"><span class="string">                    true</span></span><br><span class="line"><span class="string">                ]</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line"></span><br><span class="line">name := xjson.Get(str, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">assert.Equal(t, name.String(), <span class="string">&quot;bob&quot;</span>)</span><br><span class="line"></span><br><span class="line">age := xjson.Get(str, <span class="string">&quot;age&quot;</span>)</span><br><span class="line">assert.Equal(t, age.Int(), <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">assert.Equal(t, xjson.Get(str,<span class="string">&quot;skill.lang[0].go.feature[0]&quot;</span>).String(), <span class="string">&quot;goroutine&quot;</span>)</span><br><span class="line">assert.Equal(t, xjson.Get(str,<span class="string">&quot;skill.lang[0].go.feature[1]&quot;</span>).String(), <span class="string">&quot;channel&quot;</span>)</span><br><span class="line">assert.Equal(t, xjson.Get(str,<span class="string">&quot;skill.lang[0].go.feature[2]&quot;</span>).String(), <span class="string">&quot;simple&quot;</span>)</span><br><span class="line">assert.Equal(t, xjson.Get(str,<span class="string">&quot;skill.lang[0].go.feature[3]&quot;</span>).Bool(), <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>这样的语法使用个人觉得还是满符合直觉的，相信对使用者来说也比较简单。</p><p>返回值参考了 <code>tidwall</code> 使用了一个 <code>Result</code> 对象，它提供了多种方法可以方便的获取各种类型的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> String() <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> Bool() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> Int() <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> Float() <span class="type">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> Map() <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> Array() *[]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> Exists() <span class="type">bool</span></span><br></pre></td></tr></table></figure><p>比如使用 <code>Map()/Array()</code> 这两个函数可以将 <code>JSON</code> 数据映射到 <code>map</code> 和切片中，当然前提是传入的语法返回的是一个合法 <code>JSONObject</code> 或数组。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在实现之前需要先定义一个基本语法，主要支持以下四种用法：</p><ul><li>单个 <code>key</code> 的查询：<code>Get(json,&quot;name&quot;)</code></li><li>嵌套查询： <code>Get(json,&quot;obj1.obj2.obj3.name&quot;)</code></li><li>数组查询：<code>Get(json,&quot;obj.array[0]&quot;)</code></li><li>数组嵌套查询：<code>Get(json,&quot;obj.array[0].obj2.obj3[1].name&quot;)</code></li></ul><p>语法很简单，符合我们日常接触到语法规则，这样便可以访问到 <code>JSON</code> 数据中的任何一个值。</p><p>其实实现过程也不复杂，我们已经在上一文中实现将 <code>JSON</code> 字符串转换为一个 <code>JSONObject</code> 了。</p><p>这次只是额外再解析刚才定义的语法为 <code>token</code>，然后解析该 <code>token</code> 的同时再从生成好的 <code>JSONObject</code> 中获取数据。</p><p>最后在解析完 <code>token</code> 时拿到的 <code>JSONObject</code> 数据返回即可。</p><hr><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3u0oie3saj213r0u0n0h.jpg"></p><p>我们以这段查询代码为例：</p><p>首先第一步是对查询语法做词法分析，最终得到下图的 <code>token</code>。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3u0ruv7upj218605uaap.jpg"></p><p>在词法分析过程中也可以做简单的语法校验；比如如果包含数组查询，并不是以 <code>]</code> 符号结尾时就抛出语法错误。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3u0r6v29nj219e0nojuq.jpg"></p><p>接着我们遍历语法的 token。如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3u0w0sb8xj217h0u042u.jpg"></p><p>每当遍历到 <code>token</code> 类型为 <code>Key</code> 时便从当前的 JSONObject 对象中获取数据，<strong>并用获取到的值替覆盖为当前的 JSONObject。</strong></p><p>其中每当遇到 <code>.</code> <code>[</code> <code>]</code> 这样的 token 时便消耗掉，直到我们将 token 遍历完毕，这时将当前 <code>JSONObject</code> 返回即可。</p><p>在遍历过程中当遇到非法格式时，比如 <code>obj_list[1.]</code> 便会返回一个空的 <code>JSONObject</code>。</p><p>语法校验这点其实也很容易办到，因为根据我们的语法规则，<code>Array</code> 中的 <code>index</code> 后一定紧接的是一个 <code>EndArray</code>，只要不是一个 <code>EndArray</code> 便能知道语法不合法了。</p><p>有兴趣的可以看下解析过程的源码：</p><p><a href="https://github.com/crossoverJie/xjson/blob/cfbca51cc9bc0c77e6cb9c9ad3f964b2054b3826/json.go#L46">https://github.com/crossoverJie/xjson/blob/cfbca51cc9bc0c77e6cb9c9ad3f964b2054b3826/json.go#L46</a></p><h1 id="对-JSON-做四则运算"><a href="#对-JSON-做四则运算" class="headerlink" title="对 JSON 做四则运算"></a>对 JSON 做四则运算</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">str := `&#123;&quot;name&quot;:&quot;bob&quot;, &quot;age&quot;:10,&quot;magic&quot;:10.1, &quot;score&quot;:&#123;&quot;math&quot;:[1,2]&#125;&#125;`</span><br><span class="line">result := GetWithArithmetic(str, &quot;(age+age)*age+magic&quot;)</span><br><span class="line">assert.Equal(t, result.Float(), 210.1)</span><br><span class="line">result = GetWithArithmetic(str, &quot;(age+age)*age&quot;)</span><br><span class="line">assert.Equal(t, result.Int(), 200)</span><br><span class="line"></span><br><span class="line">result = GetWithArithmetic(str, &quot;(age+age) * age + score.math[0]&quot;)</span><br><span class="line">assert.Equal(t, result.Int(), 201)</span><br><span class="line"></span><br><span class="line">result = GetWithArithmetic(str, &quot;(age+age) * age - score.math[0]&quot;)</span><br><span class="line">assert.Equal(t, result.Int(), 199)</span><br><span class="line"></span><br><span class="line">result = GetWithArithmetic(str, &quot;score.math[1] / score.math[0]&quot;)</span><br><span class="line">assert.Equal(t, result.Int(), 2)</span><br></pre></td></tr></table></figure><p>最后我还扩展了一下语法，可以支持对 <code>JSON</code> 数据中的整形<code>（int、float）</code>做四则运算，虽然这是一个小众需求，但做完我觉得还挺有意思的，目前在市面上我还没发现有类似功能的库，可能和小众需求有关🤣。</p><p>其中核心的四则运算逻辑是由之前写的脚本解释器提供的:</p><p><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3u84i945oj218c0iwgpw.jpg"><br>单独提供了一个函数，传入一个四则运算表达式返回计算结果。</p><blockquote><p>由于上一版本还不支持 float，所以这次专门适配了一下。</p></blockquote><p>限于篇幅，更多关于这个四则运算的实现逻辑会在后面继续分享。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此算是我第一次利用编译原理的知识解决了一点特定领域问题，在大学以及工作这些年一直觉得编译原理比较高深，所以内心一直是抗拒的，但经过这段时间的学习和实践慢慢的也掌握到了一点门道。</p><p>不过目前也只是冰山一角，后面的编译原理后端更是要涉及到计算机底层知识，所以依然任重而道远。</p><p>已上都是题外话，针对于这个库我也会长期维护；为了能达到生产的使用要求，尽量提高了单测覆盖率，目前是98%。</p><p>也欢迎大家使用，提 bug🐛。</p><p>后面会继续优化，比如支持转义字符、提高性能等。</p><p>感兴趣的朋友请持续关注：<br><a href="https://github.com/crossoverJie/xjson">https://github.com/crossoverJie/xjson</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h3vuj0uxlcj208u07tmxb.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在之前实现的 &lt;a href=&quot;https://crossoverjie.top/2022/06/28/xjson/xjson01/&quot;&gt;&lt;code&gt;JSON&lt;/code&gt; 解析器&lt;/a&gt;中当时只实现了将一个 JSON 字符串转换为一个 &lt;code&gt;JSONObject&lt;/code&gt;，并没有将其映射为一个具体的 &lt;code&gt;struct&lt;/code&gt;；如果想要获取值就需要先做断言将其转换为 &lt;code&gt;map&lt;/code&gt; 或者是切片再来获，会比较麻烦。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;decode, err := xjson.Decode(&lt;span class=&quot;string&quot;&gt;`&amp;#123;&amp;quot;glossary&amp;quot;:&amp;#123;&amp;quot;title&amp;quot;:&amp;quot;example glossary&amp;quot;,&amp;quot;age&amp;quot;:1&amp;#125;&amp;#125;`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;assert.Nil(t, err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;glossary := v[&lt;span class=&quot;string&quot;&gt;&amp;quot;glossary&amp;quot;&lt;/span&gt;].(&lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;string&lt;/span&gt;]&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt;&amp;#123;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;assert.Equal(t, glossary[&lt;span class=&quot;string&quot;&gt;&amp;quot;title&amp;quot;&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;&amp;quot;example glossary&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;assert.Equal(t, glossary[&lt;span class=&quot;string&quot;&gt;&amp;quot;age&amp;quot;&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;但其实转念一想，部分场景我们甚至我们只需要拿到 &lt;code&gt;JSON&lt;/code&gt; 中的某个字段的值，这样还需要先声明一个 &lt;code&gt;struct&lt;/code&gt; 会略显麻烦。&lt;/p&gt;
&lt;p&gt;经过查询发现已经有了一个类似的库来解决该问题，&lt;a href=&quot;https://github.com/tidwall/xjson&quot;&gt;https://github.com/tidwall/xjson&lt;/a&gt; 并且 star 数还很多（甚至名字都是一样的😂），说明这样的需求大家还是很强烈的。&lt;/p&gt;
&lt;p&gt;于是我也打算增加类似的功能，使用方式如下：&lt;br&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h3t43ocuudj20zn0u0wha.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="xjson" scheme="http://crossoverjie.top/categories/xjson/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/xjson/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>几百行代码实现一个 JSON 解析器</title>
    <link href="http://crossoverjie.top/2022/06/28/gjson/gjson01/"/>
    <id>http://crossoverjie.top/2022/06/28/gjson/gjson01/</id>
    <published>2022-06-28T00:13:36.000Z</published>
    <updated>2022-07-04T08:56:40.229Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3m5tef1rzj218a0u07ju.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在写 <a href="https://crossoverjie.top/2022/05/30/gscript/gscript01/">gscript</a>时我就在想有没有利用编译原理实现一个更实际工具？毕竟真写一个语言的难度不低，并且也很难真的应用起来。</p><p>一次无意间看到有人提起 <code>JSON</code> 解析器，这类工具充斥着我们的日常开发，运用非常广泛。</p><p>以前我也有思考过它是如何实现的，过程中一旦和编译原理扯上关系就不由自主的劝退了；但经过这段时间的实践我发现实现一个 <code>JSON</code> 解析器似乎也不困难，只是运用到了编译原理前端的部分知识就完全足够了。</p><p>得益于 <code>JSON</code> 的轻量级，同时语法也很简单，所以核心代码大概只用了 800 行便实现了一个语法完善的 <code>JSON</code> 解析器。</p><span id="more"></span><p>首先还是来看看效果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/crossoverJie/xjson&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJson</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">str := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">   &quot;glossary&quot;: &#123;</span></span><br><span class="line"><span class="string">       &quot;title&quot;: &quot;example glossary&quot;,</span></span><br><span class="line"><span class="string">&quot;age&quot;:1,</span></span><br><span class="line"><span class="string">&quot;long&quot;:99.99,</span></span><br><span class="line"><span class="string">&quot;GlossDiv&quot;: &#123;</span></span><br><span class="line"><span class="string">           &quot;title&quot;: &quot;S&quot;,</span></span><br><span class="line"><span class="string">&quot;GlossList&quot;: &#123;</span></span><br><span class="line"><span class="string">               &quot;GlossEntry&quot;: &#123;</span></span><br><span class="line"><span class="string">                   &quot;ID&quot;: &quot;SGML&quot;,</span></span><br><span class="line"><span class="string">&quot;SortAs&quot;: &quot;SGML&quot;,</span></span><br><span class="line"><span class="string">&quot;GlossTerm&quot;: &quot;Standard Generalized Markup Language&quot;,</span></span><br><span class="line"><span class="string">&quot;Acronym&quot;: &quot;SGML&quot;,</span></span><br><span class="line"><span class="string">&quot;Abbrev&quot;: &quot;ISO 8879:1986&quot;,</span></span><br><span class="line"><span class="string">&quot;GlossDef&quot;: &#123;</span></span><br><span class="line"><span class="string">                       &quot;para&quot;: &quot;A meta-markup language, used to create markup languages such as DocBook.&quot;,</span></span><br><span class="line"><span class="string">&quot;GlossSeeAlso&quot;: [&quot;GML&quot;, &quot;XML&quot;, true, null]</span></span><br><span class="line"><span class="string">                   &#125;,</span></span><br><span class="line"><span class="string">&quot;GlossSee&quot;: &quot;markup&quot;</span></span><br><span class="line"><span class="string">               &#125;</span></span><br><span class="line"><span class="string">           &#125;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">decode, err := xjson.Decode(str)</span><br><span class="line">assert.Nil(t, err)</span><br><span class="line">fmt.Println(decode)</span><br><span class="line">v := decode.(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">glossary := v[<span class="string">&quot;glossary&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">assert.Equal(t, glossary[<span class="string">&quot;title&quot;</span>], <span class="string">&quot;example glossary&quot;</span>)</span><br><span class="line">assert.Equal(t, glossary[<span class="string">&quot;age&quot;</span>], <span class="number">1</span>)</span><br><span class="line">assert.Equal(t, glossary[<span class="string">&quot;long&quot;</span>], <span class="number">99.99</span>)</span><br><span class="line">glossDiv := glossary[<span class="string">&quot;GlossDiv&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">assert.Equal(t, glossDiv[<span class="string">&quot;title&quot;</span>], <span class="string">&quot;S&quot;</span>)</span><br><span class="line">glossList := glossDiv[<span class="string">&quot;GlossList&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">glossEntry := glossList[<span class="string">&quot;GlossEntry&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">assert.Equal(t, glossEntry[<span class="string">&quot;ID&quot;</span>], <span class="string">&quot;SGML&quot;</span>)</span><br><span class="line">assert.Equal(t, glossEntry[<span class="string">&quot;SortAs&quot;</span>], <span class="string">&quot;SGML&quot;</span>)</span><br><span class="line">assert.Equal(t, glossEntry[<span class="string">&quot;GlossTerm&quot;</span>], <span class="string">&quot;Standard Generalized Markup Language&quot;</span>)</span><br><span class="line">assert.Equal(t, glossEntry[<span class="string">&quot;Acronym&quot;</span>], <span class="string">&quot;SGML&quot;</span>)</span><br><span class="line">assert.Equal(t, glossEntry[<span class="string">&quot;Abbrev&quot;</span>], <span class="string">&quot;ISO 8879:1986&quot;</span>)</span><br><span class="line">glossDef := glossEntry[<span class="string">&quot;GlossDef&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">assert.Equal(t, glossDef[<span class="string">&quot;para&quot;</span>], <span class="string">&quot;A meta-markup language, used to create markup languages such as DocBook.&quot;</span>)</span><br><span class="line">glossSeeAlso := glossDef[<span class="string">&quot;GlossSeeAlso&quot;</span>].(*[]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">assert.Equal(t, (*glossSeeAlso)[<span class="number">0</span>], <span class="string">&quot;GML&quot;</span>)</span><br><span class="line">assert.Equal(t, (*glossSeeAlso)[<span class="number">1</span>], <span class="string">&quot;XML&quot;</span>)</span><br><span class="line">assert.Equal(t, (*glossSeeAlso)[<span class="number">2</span>], <span class="literal">true</span>)</span><br><span class="line">assert.Equal(t, (*glossSeeAlso)[<span class="number">3</span>], <span class="string">&quot;&quot;</span>)</span><br><span class="line">assert.Equal(t, glossEntry[<span class="string">&quot;GlossSee&quot;</span>], <span class="string">&quot;markup&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个用例中可以看到支持字符串、布尔值、浮点、整形、数组以及各种嵌套关系。                                                                                      </p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3mz1xo687j20iw0evt9f.jpg"></p><p>这里简要说明一下实现原理，本质上就是两步：</p><ol><li><strong>词法解析</strong>：根据原始输入的 <code>JSON</code> 字符串解析出 token，也就是类似于 <code>&quot;&#123;&quot; &quot;obj&quot; &quot;age&quot; &quot;1&quot; &quot;[&quot; &quot;]&quot;</code> 这样的标识符，只是要给这类标识符分类。</li><li>根据生成的一组 <code>token</code> 集合，以流的方式进行读取，最终可以生成图中的树状结构，也就是一个 <code>JSONObject</code> 。</li></ol><p>下面来重点看看这两个步骤具体做了哪些事情。</p><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BeginObject  &#123;</span><br><span class="line">String  &quot;name&quot;</span><br><span class="line">SepColon  :</span><br><span class="line">String  &quot;cj&quot;</span><br><span class="line">SepComma  ,</span><br><span class="line">String  &quot;object&quot;</span><br><span class="line">SepColon  :</span><br><span class="line">BeginObject  &#123;</span><br><span class="line">String  &quot;age&quot;</span><br><span class="line">SepColon  :</span><br><span class="line">Number  10</span><br><span class="line">SepComma  ,</span><br><span class="line">String  &quot;sex&quot;</span><br><span class="line">SepColon  :</span><br><span class="line">String  &quot;girl&quot;</span><br><span class="line">EndObject  &#125;</span><br><span class="line">SepComma  ,</span><br><span class="line">String  &quot;list&quot;</span><br><span class="line">SepColon  :</span><br><span class="line">BeginArray  [</span><br></pre></td></tr></table></figure><p>其实词法解析就是构建一个有限自动机的过程（<code>DFA</code>)，目的是可以生成这样的集合（token）,只是我们需要将这些 token进行分类以便后续做语法分析的时候进行处理。</p><p>比如 <code>&quot;&#123;&quot;</code> 这样的左花括号就是一个 <code>BeginObject</code> 代表一个对象声明的开始，而 <code>&quot;&#125;&quot;</code> 则是 <code>EndObject</code> 代表一个对象的结束。</p><p>其中 <code>&quot;name&quot;</code> 这样的就被认为是 <code>String</code> 字符串，以此类推 <code>&quot;[&quot;</code> 代表 <code>BeginArray</code></p><p>这里我一共定义以下几种 token 类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Token <span class="type">string</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Init        Token = <span class="string">&quot;Init&quot;</span></span><br><span class="line">BeginObject       = <span class="string">&quot;BeginObject&quot;</span></span><br><span class="line">EndObject         = <span class="string">&quot;EndObject&quot;</span></span><br><span class="line">BeginArray        = <span class="string">&quot;BeginArray&quot;</span></span><br><span class="line">EndArray          = <span class="string">&quot;EndArray&quot;</span></span><br><span class="line">Null              = <span class="string">&quot;Null&quot;</span></span><br><span class="line">Null1             = <span class="string">&quot;Null1&quot;</span></span><br><span class="line">Null2             = <span class="string">&quot;Null2&quot;</span></span><br><span class="line">Null3             = <span class="string">&quot;Null3&quot;</span></span><br><span class="line">Number            = <span class="string">&quot;Number&quot;</span></span><br><span class="line">Float             = <span class="string">&quot;Float&quot;</span></span><br><span class="line">BeginString       = <span class="string">&quot;BeginString&quot;</span></span><br><span class="line">EndString         = <span class="string">&quot;EndString&quot;</span></span><br><span class="line">String            = <span class="string">&quot;String&quot;</span></span><br><span class="line">True              = <span class="string">&quot;True&quot;</span></span><br><span class="line">True1             = <span class="string">&quot;True1&quot;</span></span><br><span class="line">True2             = <span class="string">&quot;True2&quot;</span></span><br><span class="line">True3             = <span class="string">&quot;True3&quot;</span></span><br><span class="line">False             = <span class="string">&quot;False&quot;</span></span><br><span class="line">False1            = <span class="string">&quot;False1&quot;</span></span><br><span class="line">False2            = <span class="string">&quot;False2&quot;</span></span><br><span class="line">False3            = <span class="string">&quot;False3&quot;</span></span><br><span class="line">False4            = <span class="string">&quot;False4&quot;</span></span><br><span class="line"><span class="comment">// SepColon :</span></span><br><span class="line">SepColon = <span class="string">&quot;SepColon&quot;</span></span><br><span class="line"><span class="comment">// SepComma ,</span></span><br><span class="line">SepComma = <span class="string">&quot;SepComma&quot;</span></span><br><span class="line">EndJson  = <span class="string">&quot;EndJson&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>其中可以看到  true&#x2F;false&#x2F;null 会有多个类型，这点先忽略，后续会解释。</p></blockquote><p>以这段 <code>JSON</code> 为例：<code>&#123;&quot;age&quot;:1&#125;</code>，它的状态扭转如下图：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n83xkv82j21360i0t9r.jpg"></p><p>总的来说就是依次遍历字符串，然后更新一个全局状态，根据该状态的值进行不同的操作。</p><p>部分代码如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n866cfqfj20u01jyjxt.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n86kgy9qj20u012kadx.jpg"></p><p>感兴趣的朋友可以跑跑单例 debug 一下就很容易理解：</p><p><a href="https://github.com/crossoverJie/xjson/blob/main/token_test.go">https://github.com/crossoverJie/xjson/blob/main/token_test.go</a></p><p>以这段 JSON 为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestInitStatus</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">str := <span class="string">`&#123;&quot;name&quot;:&quot;cj&quot;, &quot;age&quot;:10&#125;`</span></span><br><span class="line">tokenize, err := Tokenize(str)</span><br><span class="line">assert.Nil(t, err)</span><br><span class="line"><span class="keyword">for</span> _, tokenType := <span class="keyword">range</span> tokenize &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s  %s\n&quot;</span>, tokenType.T, tokenType.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终生成的 <code>token</code> 集合如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BeginObject  &#123;</span><br><span class="line">String  &quot;name&quot;</span><br><span class="line">SepColon  :</span><br><span class="line">String  &quot;cj&quot;</span><br><span class="line">SepComma  ,</span><br><span class="line">String  &quot;age&quot;</span><br><span class="line">SepColon  :</span><br><span class="line">Number  10</span><br><span class="line">EndObject  &#125;</span><br></pre></td></tr></table></figure><h3 id="提前检查"><a href="#提前检查" class="headerlink" title="提前检查"></a>提前检查</h3><p>由于 <code>JSON</code> 的语法简单，一些规则甚至在词法规则中就能校验。</p><p>举个例子：<br><code>JSON</code> 中允许 <code>null</code> 值，当我们字符串中存在 <code>nu  nul</code> 这类不匹配 <code>null</code> 的值时，就可以提前抛出异常。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n8dt7d1aj211w0tigpa.jpg"><br>比如当检测到第一个字符串为 n 时，那后续的必须为 <code>u-&gt;l-&gt;l</code> 不然就抛出异常。</p><p>浮点数同理，当一个数值中存在多个 . 点时，依然需要抛出异常。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n8fk2xsbj20u010hgp2.jpg"></p><p>这也是前文提到 <code>true/false/null</code> 这些类型需要有多个中间状态的原因。</p><h2 id="生成-JSONObject-树"><a href="#生成-JSONObject-树" class="headerlink" title="生成 JSONObject 树"></a>生成 JSONObject 树</h2><p>在讨论生成 <code>JSONObject</code> 树之前我们先来看这么一个问题，给定一个括号集合，判断是否合法。</p><ul><li><code>[&lt;()&gt;]</code> 这样是合法的。</li><li><code>[&lt;()&gt;)</code> 而这样是不合法的。</li></ul><p>如何实现呢？其实也很简单，只需要利用栈就能完成，如下图所示：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n8u1brbbj216u0rsgp1.jpg"><br>利用栈的特性，依次遍历数据，遇到是左边的符号就入栈，当遇到是右符号时就与栈顶数据匹配，能匹配上就出栈。</p><p>当匹配不上时则说明格式错误，数据遍历完毕后如果栈为空时说明数据合法。</p><p>其实仔细观察 <code>JSON</code> 的语法也是类似的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;cj&quot;,</span><br><span class="line">    &quot;object&quot;: &#123;</span><br><span class="line">        &quot;age&quot;: 10,</span><br><span class="line">        &quot;sex&quot;: &quot;girl&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;1&quot;: &quot;a&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;2&quot;: &quot;b&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BeginObject:&#123;</code> 与 <code>EndObject:&#125;</code> 一定是成对出现的，中间如论怎么嵌套也是成对的。<br>而对于 <code>&quot;age&quot;:10</code> 这样的数据，: 冒号后也得有数据进行匹配，不然就是非法格式。</p><p>所以基于刚才的括号匹配原理，我们也能用类似的方法来解析 <code>token</code> 集合。</p><p>我们也需要创建一个栈，当遇到 <code>BeginObject</code> 时就入栈一个 Map，当遇到一个 <code>String</code> 键时也将该值入栈。</p><p>当遇到 <code>value</code> 时，就将出栈一个 <code>key</code>,同时将数据写入当前栈顶的 <code>map</code> 中。</p><p>当然在遍历 <code>token</code> 的过程中也需要一个全局状态，所以这里也是一个<strong>有限状态机</strong>。</p><hr><p>举个例子：当我们遍历到 <code>Token</code> 类型为 <code>String</code>，值为 <code>&quot;name&quot;</code> 时，预期下一个 <code>token</code> 应当是 :冒号；</p><p>所以我们得将当前的 status 记录为 <code>StatusColon</code>，一旦后续解析到 token 为 <code>SepColon</code> 时，就需要判断当前的 status 是否为 <code>StatusColon</code> ，如果不是则说明语法错误，就可以抛出异常。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n9ilzooqj20u00u442z.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n9j1iex0j21bc09q0uj.jpg"></p><p>同时值得注意的是这里的 <code>status</code> 其实是一个<code>集合</code>，因为下一个状态可能是多种情况。</p><p><code>&#123;&quot;e&quot;:[1,[2,3],&#123;&quot;d&quot;:&#123;&quot;f&quot;:&quot;f&quot;&#125;&#125;]&#125;</code><br>比如当我们解析到一个 <code>SepColon</code> 冒号时，后续的状态可能是 <code>value</code> 或 <code>BeginObject &#123;</code> 或 <code>BeginArray [</code></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n9pwpspuj21hg09q76e.jpg"><br>因此这里就得把这三种情况都考虑到，其他的以此类推。</p><p>具体解析过程可以参考源码：<br><a href="https://github.com/crossoverJie/xjson/blob/main/parse.go">https://github.com/crossoverJie/xjson/blob/main/parse.go</a></p><hr><p>虽然是借助一个栈结构就能将 <code>JSON</code> 解析完毕，不知道大家发现一个问题没有：<br>这样非常容易遗漏规则，比如刚才提到的一个冒号后面就有三种情况，而一个 <code>BeginArray</code> 后甚至有四种情况（<code>StatusArrayValue, StatusBeginArray, StatusBeginObject, StatusEndArray</code>）</p><p>这样的代码读起来也不是很直观，同时容易遗漏语法，只能出现问题再进行修复。</p><p>既然提到了问题那自然也有相应的解决方案，其实就是语法分析中常见的递归下降算法。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3n9vzwepij20u01ecwgy.jpg"><br>我们只需要根据 <code>JSON</code> 的文法定义，递归的写出算法即可，这样代码阅读起来非常清晰，同时也不会遗漏规则。</p><p>完整的 <code>JSON</code> 语法查看这里：<br><a href="https://github.com/antlr/grammars-v4/blob/master/json/JSON.g4">https://github.com/antlr/grammars-v4/blob/master/json/JSON.g4</a></p><p>我也预计将下个版本改为递归下降算法来实现。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当目前为止其实只是实现了一个非常基础的 <code>JSON</code> 解析，也没有做性能优化，和官方的 <code>JSON</code> 包对比性能差的不是一星半点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz</span><br><span class="line">BenchmarkJsonDecode-12            372298             15506 ns/op             512 B/op         12 allocs/op</span><br><span class="line">BenchmarkDecode-12                141482             43516 ns/op           30589 B/op        962 allocs/op</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>同时还有一些基础功能没有实现，比如将解析后的 <code>JSONObject</code> 可以反射生成自定义的 <code>Struct</code>，以及我最终想实现的支持 <code>JSON</code> 的四则运算：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xjson.Get(<span class="string">&quot;glossary.age+long*(a.b+a.c)&quot;</span>)</span><br></pre></td></tr></table></figure><p>目前我貌似没有发现有类似的库实现了这个功能，后面真的完成后应该会很有意思，感兴趣的朋友请持续关注。</p><p>源码：<br><a href="https://github.com/crossoverJie/xjson">https://github.com/crossoverJie/xjson</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h3m5tef1rzj218a0u07ju.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前在写 &lt;a href=&quot;https://crossoverjie.top/2022/05/30/gscript/gscript01/&quot;&gt;gscript&lt;/a&gt;时我就在想有没有利用编译原理实现一个更实际工具？毕竟真写一个语言的难度不低，并且也很难真的应用起来。&lt;/p&gt;
&lt;p&gt;一次无意间看到有人提起 &lt;code&gt;JSON&lt;/code&gt; 解析器，这类工具充斥着我们的日常开发，运用非常广泛。&lt;/p&gt;
&lt;p&gt;以前我也有思考过它是如何实现的，过程中一旦和编译原理扯上关系就不由自主的劝退了；但经过这段时间的实践我发现实现一个 &lt;code&gt;JSON&lt;/code&gt; 解析器似乎也不困难，只是运用到了编译原理前端的部分知识就完全足够了。&lt;/p&gt;
&lt;p&gt;得益于 &lt;code&gt;JSON&lt;/code&gt; 的轻量级，同时语法也很简单，所以核心代码大概只用了 800 行便实现了一个语法完善的 &lt;code&gt;JSON&lt;/code&gt; 解析器。&lt;/p&gt;</summary>
    
    
    
    <category term="xjson" scheme="http://crossoverjie.top/categories/xjson/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/xjson/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>几百行代码实现一个脚本解释器</title>
    <link href="http://crossoverjie.top/2022/05/30/gscript/gscript01/"/>
    <id>http://crossoverjie.top/2022/05/30/gscript/gscript01/</id>
    <published>2022-05-30T00:14:36.000Z</published>
    <updated>2022-05-29T16:21:28.903Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2pp039p8mj20rs0rsmy0.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近又在重新学习编译原理了，其实两年前也复习过，当初是为了能实现通过 <code>MySQL</code> 的 <code>DDL</code> 生成 <code>Python</code> 中 <code>sqlalchemy</code> 的 <code>model</code>。</p><p><img src="https://i.loli.net/2020/03/23/dLpAoxf4BwEj81S.gif"><br>相关文章在这里：<a href="https://crossoverjie.top/2020/03/23/compilation/Lexer/">手写一个词法分析器</a></p><span id="more"></span><p>虽然完成了相关功能，但现在看来其实实现的比较糙的，而且也只运用到了词法分析；所以这次我的目的是可以通过词法分析-&gt;语法分析-&gt;语义分析 最终能实现一个功能完善的脚本”语言”。</p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>现在也有了一些阶段性的成果，如下图所示：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2pp97cs39j20hi0cwgmo.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2pp9ez7ibj20im0hcgnd.jpg"></p><p>目前具备以下基本功能：</p><ul><li>变量声明与赋值（只支持 int)</li><li>二次运算（优先级支持）</li><li>语法检查</li><li>debug 模式，可以打印 AST</li></ul><p>感兴趣的朋友可以在这里查看源码：<br><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p><p>本地有 go 环境的话也可以安装运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/crossoverJie/gscript</span><br><span class="line">gscript -h</span><br></pre></td></tr></table></figure><p>或者直接下载二进制文件运行：<a href="https://github.com/crossoverJie/gscript/releases">https://github.com/crossoverJie/gscript/releases</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>当前版本是使用 go 编写的，确实也如标题所说，核心代码还不到 1k 行代码，当然这也和目前功能简陋有关。</p><p>不过麻雀虽小五脏俱全，从当前版本还是运用到了编译原理中的部分知识：词法、语法分析。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2pq6r1ilkj210k0ngq4l.jpg"></p><p>基本实现流程如上图：</p><ul><li>通过词法分析器将源码中解析出 token</li><li>再通过对 token  推导生成出抽象语法树（AST）<ul><li>如果语法语法出现错误，这一步骤便会抛出编译失败，比如 <code>2*(1+</code> 少了一个括号。</li></ul></li></ul><p>因为没有使用类似于 <code>ANTLR</code> 这样工具来辅助生成代码（不然功能也不会只有这么点），所以其中的词法、语法分析都是手写的，代码量并不大，对于想要调试的朋友可以直接查看源码。</p><p>词法分析器：<code>token/token.go:39</code><br>语法分析器：<code>syntax/syntax.go</code></p><p>其中会涉及到一些概念，比如有限状态机、递归下降算法等知识点就没在本文讨论了，后续这个项目功能更加完善后也会重头整理。</p><h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><p>最后是画饼阶段了，不出意外后续会继续新增如下功能：</p><ul><li>更多的基础类型，string&#x2F;long 之类的。</li><li>变量作用域、函数。</li><li>甚至是闭包。</li><li>OOP 肯定也少不了。</li></ul><p>这些特性都实现后那也算是一个”现代”的脚本语言了，后续我也会继续更新学习和实现过程中的有趣内容。</p><p>源码地址：<br><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h2pp039p8mj20rs0rsmy0.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近又在重新学习编译原理了，其实两年前也复习过，当初是为了能实现通过 &lt;code&gt;MySQL&lt;/code&gt; 的 &lt;code&gt;DDL&lt;/code&gt; 生成 &lt;code&gt;Python&lt;/code&gt; 中 &lt;code&gt;sqlalchemy&lt;/code&gt; 的 &lt;code&gt;model&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/23/dLpAoxf4BwEj81S.gif&quot;&gt;&lt;br&gt;相关文章在这里：&lt;a href=&quot;https://crossoverjie.top/2020/03/23/compilation/Lexer/&quot;&gt;手写一个词法分析器&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud Feign 实现动态 URL</title>
    <link href="http://crossoverjie.top/2022/05/23/troubleshoot/SpringCloud-Feign-dynamic-url/"/>
    <id>http://crossoverjie.top/2022/05/23/troubleshoot/SpringCloud-Feign-dynamic-url/</id>
    <published>2022-05-23T00:15:36.000Z</published>
    <updated>2022-05-22T17:25:18.950Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hksgjbitj21hc0u0ajs.jpg"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间同事碰到一个问题，需要在 <code>SpringCloud</code> 的 Feign 调用中使用自定义的 URL；通常情况下是没有这个需求的；毕竟都用了 <code>SpringCloud</code> 的了，那服务之间的调用都是走注册中心的，不会需要自定义 URL 的情况。</p><span id="more"></span><p>但也有特殊的，比如我们这里碰到 <code>ToB</code> 场景，需要对每个商户自定义的 <code>URL</code> 进行调用。</p><p>虽说也可以使用原生的 <code>Feign</code> 甚至是自定义一个 <code>OKHTTP Client</code> 实现，但这些方案都得换一种写法；</p><p>打算利用现有的 <code>SpringCloud</code> <code>OpenFeign</code> 来实现，毕竟原生的 Feign 其实是支持该功能的，而 <code>SpringCloud OpenFeign</code> 也只是在这基础上封装了一层。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hmgcpmg5j21aa0bsjtl.jpg"></p><p>只需要在接口声明处加上一个 <code>URI</code> 参数即可，这样就可以在每次调用时传递不同的 <code>URI</code> 来实现动态 <code>URL</code> 的目的。</p><hr><p>想法很简单，但实践起来却不是那么回事了。<br>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;dynamic&quot;)</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DynamicClient</span> &#123;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">String <span class="title function_">get</span><span class="params">(URI uri)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dynamicClient.get(URI.create(<span class="string">&quot;https://github.com&quot;</span>));</span><br></pre></td></tr></table></figure><p>执行后会抛出负载均衡的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: com.netflix.client.ClientException:</span><br><span class="line">Load balancer does not have available server <span class="keyword">for</span> client: github.com</span><br></pre></td></tr></table></figure><p>这个异常也能理解，就是找不到 github 这个服务；找不到也是合理的，毕竟也不是一个内部注册的服务。</p><p>但按照 <code>Feign</code> 的官方介绍，只要接口中声明了 <code>URI</code> 这个参数就能自定义，同时我自己也用原生的 Feign 测试过确实没什么问题。</p><h1 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h1><p>那问题只能出在 <code>SpringCloud OpenFeign</code> 的封装上了；经过同事的搜索在网上找到一篇博客解决了这个问题。</p><p><a href="https://www.cnblogs.com/syui-terra/p/14386188.html">https://www.cnblogs.com/syui-terra/p/14386188.html</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hmzxmu68j20xg0u0n16.jpg"></p><p>按照文中的说法，确实只需要加上 URL 参数同时有值就可以了，但原因不明。</p><p>本着打破砂锅问到底的精神，我个人也想知道 <code>OpenFeign</code> 是如何处理的，只要 url 有值就可以，这完全是个黑盒，而且在官方的注释中并没有对这种情况有特殊说明。</p><p>所以我准备从源码中找到答案。</p><p>既然是 url 有值就能正常运行，那一定是在运行过程中获取了这个值；</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hn5b81vtj211o0ds763.jpg"><br>但我在源码中查看 url 所使用的地方，并没有在单测之外找到哪里有所应用，说明源码中并没有直接调用 <code>url()</code> 这个函数来获取值。</p><p>但 <code>org.springframework.cloud.openfeign.FeignClient</code> 这个注解总会使用吧，于是我又查询这个注解的使用情况。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hnamym3tj22sh0u0tl4.jpg"><br>最终在这里查到了使用的痕迹。</p><blockquote><p>这里查阅源码时也有一些小技巧，比如如果我们直接查询时，IDEA 默认的查询范围是整个项目和所有依赖库，会有许多干扰信息。</p></blockquote><p>比如我这里就需要只看项目源码，单测这些都不用看；所以在查询的时候可以过滤一下，这样干扰信息就会少很多。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hndgadtzj22mo0u0wou.jpg"></p><p>左边的工具栏还有许多过滤条件，大家可以自行研究一下。</p><hr><p>接着从源码中进行阅读，会发现是将 <code>@FeignClient</code> 中的所有数据都写到一个 <code>Map</code> 里进行使用的。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hnfkwg9dj21920u0jyh.jpg"><br>最终会发现这个 url 被写入到了 <code>FeignClientFactoryBean</code> 中的 url 成员变量中了。</p><p>查看哪里在使用这个 url 就知道背后的原理了。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hnkav8hgj21l20rsdlb.jpg"></p><p>在这里打个断点会发现：当 url 为空时会返回一个 <code>LoadBalance</code> 的 <code>client</code>，也就是会从注册中心获取 <code>url</code> 的客户端，而 <code>url</code> 有值时则会获取一个默认的客户端，这样就不会走负载均衡了。</p><blockquote><p>所以我们如果想在 OpenFeign 中使用动态 url 时就得让 @Feign 的 url 有值才行，无论是什么都可以。</p></blockquote><h2 id="Feign-的实现"><a href="#Feign-的实现" class="headerlink" title="Feign 的实现"></a>Feign 的实现</h2><p>既然已经看到这一步了，我也比较好奇 Feign 是如何做到只要有 URI 参数就使用指定的 URL 呢？</p><blockquote><p>这里也分享一个读源码的小技巧，如果我们跟着程序执行的思路去一步步 <code>debug</code> 的话会非常消耗时间，毕竟这类成熟库的代码量也不小。</p></blockquote><p>这里我们从官方文档中可以得知只要在接口参数中使用了 <code>java.net.URI</code> 便会走自定义的 url，所以我们反过来只要在源码中找到哪里在使用 <code>java.net.URI</code> 便能知道关键源码。</p><p>毕竟使用 <code>java.net.URI</code> 的场景也不会太多。</p><hr><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hnw6rwq1j225408idia.jpg"><br>所以只需要在这个依赖的地方 <code>cmd+shift+f</code> 全局搜索 <code>java.net.URI</code> 就能查到结果，果然不多，只有两处使用。</p><hr><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2hnzg6tcvj21r60sgjxn.jpg"><br>再结合使用场景猜测大概率是判断参数中是否是有 <code>URL.class</code> 这样的条件，或者是 url 对象；总之我们先用<br><code>URL</code> 这样关键字在这两个文件中搜索一下，记得勾选匹配大小写；最后会发现的确是判断了参数中是否有 <code>URL</code> 这个类，同时将这个索引位置记录了下来。</p><p>想必后续会通过这个索引位置读取最终的 <code>url</code> 信息。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ho2auls1j21v20daq7r.jpg"></p><p>最终通过这个索引的使用地方查询到了核心源码，如果有值时就取这个 URI 中所指定的地址作为 <code>target</code>。</p><p>到此为止这个问题的背后原理都已经分析完毕了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实本文重点是分析了一些 <code>debug</code> 和阅读源码的一些小技巧，特别是在读关于 <code>Spring</code> 相关的代码时一定不能 debug 跟踪到细节中，因为调用链通常是很长的，稍不留神就把自己都绕晕了，只需要知道核心、关键源码是如何处理的即可。</p><p>最后对于 OpenFeign 处理动态 url 的方案确实也有些疑惑，是一个典型的<code>约定大于配置</code>的场景，但问题就在于我们并不知道这个约定是 <code>@Feign</code>  的 url 得有值。</p><p>所以我也提了一个 <code>PR</code> 给 <code>OpenFeign</code>，感兴趣的朋友也可以查看一下：</p><p><a href="https://github.com/spring-cloud/spring-cloud-openfeign/pull/713">https://github.com/spring-cloud/spring-cloud-openfeign/pull/713</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h2hksgjbitj21hc0u0ajs.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间同事碰到一个问题，需要在 &lt;code&gt;SpringCloud&lt;/code&gt; 的 Feign 调用中使用自定义的 URL；通常情况下是没有这个需求的；毕竟都用了 &lt;code&gt;SpringCloud&lt;/code&gt; 的了，那服务之间的调用都是走注册中心的，不会需要自定义 URL 的情况。&lt;/p&gt;</summary>
    
    
    
    <category term="问题排查" scheme="http://crossoverjie.top/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="Java 进阶" scheme="http://crossoverjie.top/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/Java-%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="SpringCloud" scheme="http://crossoverjie.top/tags/SpringCloud/"/>
    
    <category term="Feign" scheme="http://crossoverjie.top/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>撸了一个 Feign 增强包 V2.0 升级版</title>
    <link href="http://crossoverjie.top/2022/05/06/wheel/feign-plus2/"/>
    <id>http://crossoverjie.top/2022/05/06/wheel/feign-plus2/</id>
    <published>2022-05-06T00:10:36.000Z</published>
    <updated>2022-05-05T16:28:58.895Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1wsydvy1mj20rs0rsmy3.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大概在两年前我写过一篇 <a href="https://crossoverjie.top/2020/07/28/wheel/feign-plus/">撸了一个 Feign 增强包</a>，当时准备是利用 <code>SpringBoot + K8s</code> 构建应用，这个库可以类似于 <code>SpringCloud</code> 那样结合 <code>SpringBoot</code> 使用声明式接口来达到服务间通讯的目的。</p><span id="more"></span><p>但后期由于技术栈发生变化（改为 Go），导致该项目只实现了基本需求后就搁置了。</p><p>巧合的时最近内部有部分项目又计划采用 <code>SpringBoot + K8s</code> 开发，于是便着手继续维护；现已经内部迭代了几个版本比较稳定了，也增加了一些实用功能，在此分享给大家。</p><p><a href="https://github.com/crossoverJie/feign-plus">https://github.com/crossoverJie/feign-plus</a></p><p>首先是新增了一些 <code>features</code>:</p><ul><li>更加统一的 API。</li><li>统一的请求、响应、异常日志记录。</li><li>自定义拦截器。</li><li>Metric 支持。</li><li>异常传递。</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>结合上面提到的一些特性做一些简单介绍，统一的 API 主要是在使用层面：</p><p>在上一个版本中声明接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignPlusClient(name = &quot;github&quot;, url = &quot;$&#123;github.url&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Github</span> &#123;</span><br><span class="line">    <span class="meta">@RequestLine(&quot;GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span></span><br><span class="line">    List&lt;GitHubRes&gt; <span class="title function_">contributors</span><span class="params">(<span class="meta">@Param(&quot;owner&quot;)</span> String owner, <span class="meta">@Param(&quot;repo&quot;)</span> String repo)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>@RequestLine</code> 等注解都是使用 feign 包所提供的。</p><p>这次更新后改为如下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/v1/demo&quot;)</span></span><br><span class="line"><span class="meta">@FeignPlusClient(name = &quot;demo&quot;, url = &quot;$&#123;feign.demo.url&#125;&quot;, port = &quot;$&#123;feign.demo.port&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DemoApi</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/id&quot;)</span></span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">(<span class="meta">@RequestParam(value = &quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/id/&#123;id&#125;&quot;)</span></span><br><span class="line">    String <span class="title function_">id</span><span class="params">(<span class="meta">@PathVariable(value = &quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/create&quot;)</span></span><br><span class="line">    Order <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span> OrderCreateReq req)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line">    Order <span class="title function_">query</span><span class="params">(<span class="meta">@SpringQueryMap</span> OrderQueryDTO dto)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟悉的味道，基本都是 <code>Spring</code> 自带的注解，这样在使用上学习成本更低，同时与项目中原本的接口写法保持一致。</p><blockquote><p>@SpringQueryMap(top.crossoverjie.feign.plus.contract.SpringQueryMap) 是由 feign-plus 提供，其实就是从 SpringCloud 中 copy 过来的。</p></blockquote><p>我这里写了两个 demo 来模拟调用：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1xw1ko6ivj21480iwgmj.jpg"></p><p><code>provider</code>： 作为服务提供者提供了一系列接口供消费方调用，并对外提供了一个 api 模块。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1xw51ht2hj21dl0u0grh.jpg"></p><hr><p><code>demo</code>：作为服务消费者依赖 <code>provider-api</code> 模块，根据其中声明的接口进行远程调用。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1xwj1f191j21mv0u0k0a.jpg"><br>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8181</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">demo:</span></span><br><span class="line">    <span class="attr">url :</span> <span class="string">http://127.0.0.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">top:</span></span><br><span class="line">      <span class="attr">crossoverjie:</span> <span class="string">debug</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">base-path:</span> <span class="string">/actuator</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">distribution:</span></span><br><span class="line">      <span class="attr">percentiles:</span></span><br><span class="line">        <span class="attr">all:</span> <span class="number">0.5</span><span class="string">,0.75,0.95,0.99</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">prometheus:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">step:</span> <span class="string">1m</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo</span></span><br></pre></td></tr></table></figure><p>当我们访问 <code>http://127.0.0.1:8181/hello/2</code> 接口时从控制台可以看到调用结果：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1xwo7u0m3j22xu0pswt2.jpg"></p><h1 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h1><p>从上图中可以看出 <code>feign-plus</code> 会用 debug 记录请求&#x2F;响应结果，如果需要打印出来时需要将该包下的日志级别调整为 debug：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">top:</span></span><br><span class="line">      <span class="attr">crossoverjie:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>由于内置了拦截器，也可以自己继承 <code>top.crossoverjie.feign.plus.log.DefaultLogInterceptor</code> 来实现自己的日志拦截记录，或者其他业务逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomFeignInterceptor</span> <span class="keyword">extends</span> <span class="title class_">DefaultLogInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">(String target, String url, String body)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.request(target, url, body);</span><br><span class="line">        log.info(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exception</span><span class="params">(String target, String url, FeignException feignException)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.exception(target, url, feignException);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">response</span><span class="params">(String target, String url, Object response)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.response(target, url, response);</span><br><span class="line">        log.info(<span class="string">&quot;response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="监控-metric"><a href="#监控-metric" class="headerlink" title="监控 metric"></a>监控 metric</h1><p><code>feign-plus</code> 会自行记录每个接口之间的调用耗时、异常等情况。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1xx0z05kej21sk0pgnfy.jpg"><br>访问 <code>http://127.0.0.1:8181/actuator/prometheus</code> 会看到相关埋点信息，通过 <code>feign_call*</code> 的 key 可以自行在 <code>Grafana</code> 配置相关面板，类似于下图：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1wsgw07sdj21hg0u0wka.jpg"></p><h1 id="异常传递"><a href="#异常传递" class="headerlink" title="异常传递"></a>异常传递</h1><p><code>rpc</code>（远程调用）要使用起来真的类似于本地调用，异常传递必不可少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// provider</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">query</span><span class="params">(OrderQueryDTO dto)</span> &#123;</span><br><span class="line">log.info(<span class="string">&quot;dto = &#123;&#125;&quot;</span>, dto);</span><br><span class="line"><span class="keyword">if</span> (dto.getId().equals(<span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DemoException</span>(<span class="string">&quot;provider test exception&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Order</span>(dto.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// consumer</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            demoApi.query(<span class="keyword">new</span> <span class="title class_">OrderQueryDTO</span>(id, <span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DemoException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;feignCall:&#123;&#125;, sourceApp:[&#123;&#125;], sourceStackTrace:&#123;&#125;&quot;</span>, e.getMessage(), e.getAppName(), e.getDebugStackTrace(), e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>比如 <code>provider</code> 中抛出了一个自定义的异常，在 <code>consumer</code> 中可以通过 <code>try/catch</code> 捕获到该异常。</p><p>为了在 feign-plus 中实现该功能需要几个步骤：</p><ol><li>自定义一个通用异常。</li><li>服务提供方需要实现一个全局拦截器，当发生异常时统一对外响应数据。</li><li>服务消费方需要自定义一个异常解码器的 bean。</li></ol><p>这里我在 <code>provider</code> 中自定义了一个 <code>DemoException</code>：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1xxixi872j214o0sedjz.jpg"></p><blockquote><p>通常这个类应该定义在公司内部的通用包中，这里为了演示方便。</p></blockquote><p>接着定义了一个 <code>HttpStatus</code> 的类用于统一对外响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpStatus</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> String debugStackTrace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个也应该放在通用包中。</p></blockquote><p>然后在 <code>provider</code> 中定义全局异常处理：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1xxm6hlj0j21q80sqwla.jpg"></p><p>当出现异常时便会返回一个 http_code&#x3D;500 的数据：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1xxqfm85wj22as0k41ax.jpg"></p><p>到这一步又会出现一个引战话题：HTTP 接口返回到底是全部返回 200 然后通过 code 来来判断，还是参考 http_code 进行返回?</p><p>这里不做过多讨论，具体可以参考耗子叔的文章：<br><a href="https://coolshell.cn/articles/22173.html">“一把梭：REST API 全用 POST”</a></p><p><code>feign-plus</code> 默认采用的 http_code !&#x3D;200 才会认为发生了异常。</p><p>而这里的 http_status 也是参考了 Google 的 api 设计：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1xxwgc5jej20u00zt0y6.jpg"><br>具体可以参考这个链接：<br><a href="https://cloud.google.com/apis/design/errors#propagating_errors">https://cloud.google.com/apis/design/errors#propagating_errors</a></p><p>然后定义一个异常解析器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignExceptionConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FeignErrorDecoder <span class="title function_">feignExceptionDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (methodName, response, e) -&gt; &#123;</span><br><span class="line">            <span class="type">HttpStatus</span> <span class="variable">status</span> <span class="operator">=</span> JSONUtil.toBean(response, HttpStatus.class);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DemoException</span>(status.getAppName(), status.getCode(), status.getMessage(), status.getDebugStackTrace());</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通常这块代码也是放在基础包中。</p></blockquote><hr><p>这样当服务提供方抛出异常时，消费者便能成功拿到该异常：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1xxyhn8gjj23fs0to19d.jpg"></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>实现原理其实也比较简单，了解 <code>rpc</code> 原理的话应该会知道，服务提供者返回的异常调用方是不可能接收到的，这和是否由一种语言实现也没关系。</p><p>毕竟两个进程之间的栈是完全不同的，不在一台服务器上，甚至都不在一个地区。</p><p>所以 <code>provider</code> 抛出异常后，消费者只能拿到一串报文，我们只能根据这段报文解析出其中的异常信息，然后再重新创建一个内部自定义的异常（比如这里的 <code>DemoException</code>），也就是我们自定义异常解析器所干的事情。</p><p>下图就是这个异常传递的大致流程：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1xzssxw0nj21460h0gmn.jpg"></p><h2 id="code-message-模式"><a href="#code-message-模式" class="headerlink" title="code message 模式"></a>code message 模式</h2><p>由于 feign-plus 默认是采用 <code>http_code != 200</code> 的方式来抛出异常的，所以采用 <code>http_code=200, code message</code> 的方式响应数据将不会传递异常，依然会任务是一次正常调用。</p><p>不过基于该模式传递异常也是可以实现的，但没法做到统一，比如有些团队习惯 <code>code !=0</code> 表示异常，甚至字段都不是 code；再或者异常信息有些是放在 message 或 msg 字段中。</p><p>每个团队、个人习惯都不相同，所以没法抽象出一个标准，因此也就没做相关适配。</p><blockquote><p>这也印证了使用国际标准所带来的好处。</p></blockquote><p>限于篇幅，如果有相关需求的朋友也可以在评论区沟通，实现上会比现在稍微复杂一点点🤏🏻。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>项目源码：<br><a href="https://github.com/crossoverJie/feign-plus">https://github.com/crossoverJie/feign-plus</a></p><p>基于2022年云原生这个背景，当然更推荐大家使用 <code>gRPC</code> 来做服务间通信，这样也不需要维护类似于这样的库了。</p><p>不过在一些调用第三方接口而对方也没有提供 SDK 时，这个库也有一定用武之地，虽然使用原生 feign 也能达到相同目的，但使用该库可以使得与 <code>Spring</code> 开发体验一致，同时内置了日志、<code>metric</code> 等功能，避免了重复开发。</p><p><strong>你的点赞与分享是对我最大的支持</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h1wsydvy1mj20rs0rsmy3.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;大概在两年前我写过一篇 &lt;a href=&quot;https://crossoverjie.top/2020/07/28/wheel/feign-plus/&quot;&gt;撸了一个 Feign 增强包&lt;/a&gt;，当时准备是利用 &lt;code&gt;SpringBoot + K8s&lt;/code&gt; 构建应用，这个库可以类似于 &lt;code&gt;SpringCloud&lt;/code&gt; 那样结合 &lt;code&gt;SpringBoot&lt;/code&gt; 使用声明式接口来达到服务间通讯的目的。&lt;/p&gt;</summary>
    
    
    
    <category term="轮子" scheme="http://crossoverjie.top/categories/%E8%BD%AE%E5%AD%90/"/>
    
    
    <category term="Java" scheme="http://crossoverjie.top/tags/Java/"/>
    
    <category term="SpringBoot" scheme="http://crossoverjie.top/tags/SpringBoot/"/>
    
    <category term="Feign" scheme="http://crossoverjie.top/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>Pulsar 重复消费?</title>
    <link href="http://crossoverjie.top/2022/03/18/troubleshoot/pulsar-repeat-consume/"/>
    <id>http://crossoverjie.top/2022/03/18/troubleshoot/pulsar-repeat-consume/</id>
    <published>2022-03-18T00:15:36.000Z</published>
    <updated>2022-03-17T16:44:56.303Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h09wy1o5v8j20rs0rs408.jpg"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>许久没有分享 Java 相关的问题排查了，最近帮同事一起排查了一个问题：</p><blockquote><p>在使用 <code>Pulsar</code> 消费时，发生了同一条消息反复消费的情况。</p></blockquote><span id="more"></span><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>当他告诉我这个现象的时候我就持怀疑态度，根据之前使用的经验 Pulsar 在官方文档以及 API 中都解释过：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0c6a9vzvuj216y05gdhd.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0c6apssrmj21t00o8afc.jpg"><br>只有当设置了消费的 <code>ackTimeout</code> 并超时消费时才会重复投递消息，默认情况下是关闭的，查看代码也确实没有开启。</p><p>那会不会是调用了 <code>negativeAcknowledge()</code> 方法呢（调用该方法也会触发重新投递），因为我们使了一个第三方库 <a href="https://github.com/majusko/pulsar-java-spring-boot-starter">https://github.com/majusko/pulsar-java-spring-boot-starter</a> 只有当抛出异常时才会调用该方法。</p><p>查阅代码之后也没有地方抛出异常，甚至整个过程中都没看到异常产生；这就有点诡异了。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>为了捋清楚整个事情的来龙去脉，详细了解了他的使用流程；</p><p>其实也就是业务出现了 <code>bug</code>，他在消息消费时 <code>debug</code> 然后进行单步调试，当走完一次调试后，没多久马上又收到了同样的消息。</p><p>但奇怪的是也不是每次 <code>debug</code> 后都能重复消费，我们都说如果一个 <code>bug</code> 能 100% 完全复现，那基本上就解决一大半了。</p><p>所以我们排查的第一步就是完全复现这个问题。</p><hr><p>为了排除掉是 IDEA 的问题（虽然极大概率不太可能）既然是 <code>debug</code> 的时候产生的问题，那其实转换到代码也就是 <code>sleep</code> 嘛，所以我们打算在消费逻辑里直接 <code>sleep</code> 一段时间看能否复现。</p><p>经过测试，<code>sleep</code> 几秒到几十秒都无法复现，最后索性 <code>sleep</code> 一分钟，神奇的事情发生了，每次都成功复现！</p><p>既然能成功复现那就好说了，因为我自己的业务代码也有使用到 <code>Pulsar</code> 的地方，为了方便调试就准备在自己的项目里再复现一次。</p><p>结果诡异的事情再次发生，我这里又不能复现了。</p><blockquote><p>虽然这才是符合预期的，但这就没法调了呀。</p></blockquote><p>本着相信现代科学的前提，我们俩唯一的区别就是项目不一样了，为此我对比了两边的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PulsarConsumer(</span></span><br><span class="line"><span class="meta">        topic = xx,</span></span><br><span class="line"><span class="meta">        clazz = Xx.class,</span></span><br><span class="line"><span class="meta">        subscriptionType = SubscriptionType.Shared</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(Data msg)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;consume msg:&#123;&#125;&quot;</span>, msg.getOrderId());</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> redisLockRegistry.obtain(msg.getOrderId());</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            orderService.<span class="keyword">do</span>(msg.getOrderId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;consumer msg:&#123;&#125; err:&quot;</span>, msg.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果不出所料，同事那边的代码加了锁；一个基于 Redis 的分布式锁，这时我一拍大腿不会是解锁的时候超时了导致抛了异常吧。</p><p>为了验证这个问题，在能复现的基础上我在框架的 <code>Pulsar</code> 消费处打了断点：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0c4tmq9dhj22zg0hon4e.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0c5xve3qaj21ss070q4u.jpg"><br>果然破案了，异常提示已经非常清楚了：加锁已经过了超时时间。</p><p>进入异常后直接 <code>negative</code> 消息，同时异常也被吃掉了，所以之前没有发现。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0dckg14crj21l60maq88.jpg"><br>查阅了 <code>RedisLockRegistry</code> 的源码，默认超时时间正好是一分钟，所以之前我们 <code>sleep</code> 几十秒也无法复现这个问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>事后我向同事了解了下为啥这里要加锁，因为我看下来完全没有加锁的必要；结果他是因为从别人那里复制的代码才加上的，压根没想那么多。</p><p>所以这事也能得出一些教训：</p><ul><li>ctrl C&#x2F;V 虽然方便，但也得充分考虑自己的业务场景。</li><li>使用一些第三方 API 时，需要充分了解其作用、参数。</li></ul><p><strong>你的点赞与分享是对我最大的支持</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h09wy1o5v8j20rs0rs408.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;许久没有分享 Java 相关的问题排查了，最近帮同事一起排查了一个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在使用 &lt;code&gt;Pulsar&lt;/code&gt; 消费时，发生了同一条消息反复消费的情况。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="问题排查" scheme="http://crossoverjie.top/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="Java 进阶" scheme="http://crossoverjie.top/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/Java-%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
    <category term="Consumer" scheme="http://crossoverjie.top/tags/Consumer/"/>
    
  </entry>
  
  <entry>
    <title>5分钟学会 gRPC</title>
    <link href="http://crossoverjie.top/2022/03/08/framework-design/grpc/"/>
    <id>http://crossoverjie.top/2022/03/08/framework-design/grpc/</id>
    <published>2022-03-08T00:12:16.000Z</published>
    <updated>2022-03-13T10:44:15.907Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/03/13/EvoDe9JNqPLHwdF.jpg"></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>我猜测大部分长期使用 <code>Java</code> 的开发者应该较少会接触 <code>gRPC</code>，毕竟在 <code>Java</code> 圈子里大部分使用的还是 <code>Dubbo/SpringClound</code> 这两类服务框架。</p><p>我也是近段时间有机会从零开始重构业务才接触到 <code>gRPC</code> 的，当时选择 <code>gRPC</code> 时也有几个原因：</p><p><img src="https://s2.loli.net/2022/03/13/XCYkMxjpUgvZE5L.jpg"></p><ul><li>基于云原生的思路开发部署项目，而在云原生中 <code>gRPC</code> 几乎已经是标准的通讯协议了。</li><li>开发语言选择了 Go，在 Go 圈子中 <code>gRPC</code> 显然是更好的选择。</li><li>公司内部有部分业务使用的是 <code>Python</code> 开发，在多语言兼容性上 <code>gRPC</code> 支持的非常好。</li></ul><span id="more"></span><p>经过线上一年多的平稳运行，可以看出 <code>gRPC</code> 还是非常稳定高效的；rpc 框架中最核心的几个要点：</p><ul><li>序列化</li><li>通信协议</li><li>IDL（接口描述语言）</li></ul><p>这些在 <code>gRPC</code> 中分别对应的是：</p><ul><li>基于 <code>Protocol Buffer</code> 序列化协议，性能高效。</li><li>基于 <code>HTTP/2</code> 标准协议开发，自带 <code>stream</code>、多路复用等特性；同时由于是标准协议，第三方工具的兼容性会更好（比如负载均衡、监控等）</li><li>编写一份 <code>.proto</code> 接口文件，便可生成常用语言代码。</li></ul><h1 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h1><p>学习 <code>gRPC</code> 之前首先得知道它是通过什么协议通信的，我们日常不管是开发还是应用基本上接触到最多的还是 <code>HTTP/1.1</code> 协议。</p><p><img src="https://s2.loli.net/2022/03/13/r6w2Yvi9dkPqKEW.jpg"></p><p>由于 <code>HTTP/1.1</code> 是一个文本协议，对人类非常友好，相反的对机器性能就比较低。</p><p>需要反复对文本进行解析，效率自然就低了；要对机器更友好就得采用二进制，<code>HTTP/2</code> 自然做到了。</p><p>除此之外还有其他优点：</p><ul><li>多路复用：可以并行的收发消息，互不影响</li><li><code>HPACK</code> 节省 <code>header</code> 空间，避免 <code>HTTP1.1</code> 对相同的 <code>header</code> 反复发送。</li></ul><h1 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h1><p><code>gRPC</code> 采用的是 <code>Protocol</code> 序列化，发布时间比 <code>gRPC</code> 早一些，所以也不仅只用于 <code>gRPC</code>，任何需要序列化 IO 操作的场景都可以使用它。</p><p>它会更加的省空间、高性能；之前在开发 <a href="https://github.com/crossoverJie/cim/blob/master/protocol/BaseRequestProto.proto">https://github.com/crossoverJie/cim</a> 时就使用它来做数据交互。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package order.v1;</span><br><span class="line"></span><br><span class="line">service OrderService&#123;</span><br><span class="line"></span><br><span class="line">  rpc Create(OrderApiCreate) returns (Order) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  rpc Close(CloseApiCreate) returns (Order) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // 服务端推送</span><br><span class="line">  rpc ServerStream(OrderApiCreate) returns (stream Order) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // 客户端推送</span><br><span class="line">  rpc ClientStream(stream OrderApiCreate) returns (Order) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  // 双向推送</span><br><span class="line">  rpc BdStream(stream OrderApiCreate) returns (stream Order) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message OrderApiCreate&#123;</span><br><span class="line">  int64 order_id = 1;</span><br><span class="line">  repeated int64 user_id = 2;</span><br><span class="line">  string remark = 3;</span><br><span class="line">  repeated int32 reason_id = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用起来也是非常简单的，只需要定义自己的 <code>.proto</code> 文件，便可用命令行工具生成对应语言的 SDK。</p><p>具体可以参考官方文档：<br><a href="https://grpc.io/docs/languages/go/generated-code/">https://grpc.io/docs/languages/go/generated-code/</a></p><h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative \</span><br><span class="line">   --go-grpc_out=. --go-grpc_opt=paths=source_relative \</span><br><span class="line">   test.proto</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/13/vAahTlgs54Pem7c.jpg"><br>生成代码之后编写服务端就非常简单了，只需要实现生成的接口即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order)</span></span> Create(ctx context.Context, in *v1.OrderApiCreate) (*v1.Order, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// 获取 metadata</span></span><br><span class="line">md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.DataLoss, <span class="string">&quot;failed to get metadata&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(md)</span><br><span class="line">fmt.Println(in.OrderId)</span><br><span class="line"><span class="keyword">return</span> &amp;v1.Order&#123;</span><br><span class="line">OrderId: in.OrderId,</span><br><span class="line">Reason:  <span class="literal">nil</span>,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/13/wWJQ7Rv5BnqPrjo.jpg"></p><p>客户端也非常简单，只需要依赖服务端代码，创建一个 <code>connection</code> 然后就和调用本地方法一样了。</p><p>这是经典的 <code>unary</code>(一元)调用，类似于 http 的请求响应模式，一个请求对应一次响应。</p><p><img src="https://s2.loli.net/2022/03/13/cxF2Xlj4BuWOEbz.jpg"></p><h2 id="Server-stream"><a href="#Server-stream" class="headerlink" title="Server stream"></a>Server stream</h2><p><code>gRPC</code> 除了常规的 <code>unary</code> 调用之外还支持服务端推送，在一些特定场景下还是很有用的。</p><p><img src="https://s2.loli.net/2022/03/13/jz2CwFvfR6iuTMt.jpg"> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order)</span></span> ServerStream(in *v1.OrderApiCreate, rs v1.OrderService_ServerStreamServer) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">rs.Send(&amp;v1.Order&#123;</span><br><span class="line">OrderId: in.OrderId,</span><br><span class="line">Reason:  <span class="literal">nil</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端的推送如上所示，调用 <code>Send</code> 函数便可向客户端推送。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msg, err := rpc.RecvMsg()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">marshalIndent, _ := json.MarshalIndent(msgs, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端则通过一个循环判断当前接收到的数据包是否已经截止来获取服务端消息。</p><p>为了能更直观的展示这个过程，优化了之前开发的一个 <code>gRPC</code> <a href="https://github.com/crossoverJie/ptg">客户端</a>，可以直观的调试 <code>stream</code> 调用。</p><p><img src="https://s2.loli.net/2022/03/13/zqTm3bgysJcMEeZ.gif"></p><blockquote><p>上图便是一个服务端推送示例。</p></blockquote><h2 id="Client-Stream"><a href="#Client-Stream" class="headerlink" title="Client Stream"></a>Client Stream</h2><p><img src="https://s2.loli.net/2022/03/13/rkSeCNVEzJ26sMd.jpg"></p><p>除了支持服务端推送之外，客户端也支持。</p><blockquote><p>客户端在同一个连接中一直向服务端发送数据，服务端可以并行处理消息。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 服务端代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order)</span></span> ClientStream(rs v1.OrderService_ClientStreamServer) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">var</span> value []<span class="type">int64</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">recv, err := rs.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">rs.SendAndClose(&amp;v1.Order&#123;</span><br><span class="line">OrderId: <span class="number">100</span>,</span><br><span class="line">Reason:  <span class="literal">nil</span>,</span><br><span class="line">&#125;)</span><br><span class="line">log.Println(value)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">value = <span class="built_in">append</span>(value, recv.OrderId)</span><br><span class="line">log.Printf(<span class="string">&quot;ClientStream receiv msg %v&quot;</span>, recv.OrderId)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;ClientStream finish&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">messages, _ := GetMsg(data)</span><br><span class="line">rpc.SendMsg(messages[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line">receive, err := rpc.CloseAndReceive()</span><br></pre></td></tr></table></figure><p>代码与服务端推送类似，只是角色互换了。</p><p><img src="https://s2.loli.net/2022/03/13/lZzfH8yq3MGwKa9.gif"></p><h2 id="Bidirectional-Stream"><a href="#Bidirectional-Stream" class="headerlink" title="Bidirectional Stream"></a>Bidirectional Stream</h2><p><img src="https://s2.loli.net/2022/03/13/Le2OdbBN1DGScg6.jpg"></p><p>同理，当客户端、服务端同时都在发送消息也是支持的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order)</span></span> BdStream(rs v1.OrderService_BdStreamServer) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">var</span> value []<span class="type">int64</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">recv, err := rs.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">log.Println(value)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">value = <span class="built_in">append</span>(value, recv.OrderId)</span><br><span class="line">log.Printf(<span class="string">&quot;BdStream receiv msg %v&quot;</span>, recv.OrderId)</span><br><span class="line">rs.SendMsg(&amp;v1.Order&#123;</span><br><span class="line">OrderId: recv.OrderId,</span><br><span class="line">Reason:  <span class="literal">nil</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">messages, _ := GetMsg(data)</span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">rpc.SendMsg(messages[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 接收消息</span></span><br><span class="line">receive, _ := rpc.RecvMsg()</span><br><span class="line">marshalIndent, _ := json.MarshalIndent(receive, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">fmt.Println(<span class="type">string</span>(marshalIndent))</span><br><span class="line">&#125;</span><br><span class="line">rpc.CloseSend()</span><br></pre></td></tr></table></figure><p>其实就是将上诉两则合二为一。</p><p><img src="https://s2.loli.net/2022/03/13/Lxy7dhbD8ewlpUf.gif"></p><p>通过调用示例很容易理解。</p><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p><code>gRPC</code> 也支持元数据传输，类似于 <code>HTTP</code> 中的 <code>header</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端写入</span></span><br><span class="line">metaStr := <span class="string">`&#123;&quot;lang&quot;:&quot;zh&quot;&#125;`</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">err := json.Unmarshal([]<span class="type">byte</span>(metaStr), &amp;m)</span><br><span class="line">md := metadata.New(m)</span><br><span class="line"><span class="comment">// 调用时将 ctx 传入即可</span></span><br><span class="line">ctx := metadata.NewOutgoingContext(context.Background(), md)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端接收</span></span><br><span class="line">md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.DataLoss, <span class="string">&quot;failed to get metadata&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(md)</span><br></pre></td></tr></table></figure><h2 id="gRPC-gateway"><a href="#gRPC-gateway" class="headerlink" title="gRPC gateway"></a>gRPC gateway</h2><p><code>gRPC</code> 虽然功能强大使用也很简单，但对于浏览器、APP的支持还是不如 REST 应用广泛（浏览器也支持，但应用非常少）。</p><p>为此社区便创建了 <a href="https://github.com/grpc-ecosystem/grpc-gateway">https://github.com/grpc-ecosystem/grpc-gateway</a> 项目，可以将 gRPC 服务暴露为 RESTFUL API。</p><p><img src="https://s2.loli.net/2022/03/13/Gt2sRplIADyvTHg.jpg"></p><blockquote><p>为了让测试可以习惯用 postman 进行接口测试，我们也将 gRPC 服务代理出去，更方便的进行测试。</p></blockquote><h2 id="反射调用"><a href="#反射调用" class="headerlink" title="反射调用"></a>反射调用</h2><p>作为一个 rpc 框架，泛化调用也是必须支持的，可以方便开发配套工具；gRPC 是通过反射支持的，通过拿到服务名称、pb 文件进行反射调用。</p><p><a href="https://github.com/jhump/protoreflect">https://github.com/jhump/protoreflect</a> 这个库封装了常见的反射操作。</p><p>上图中看到的可视化 <code>stream</code> 调用也是通过这个库实现的。</p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>由于 <code>gRPC</code> 是基于 <code>HTTP/2</code> 实现的，客户端和服务端会保持长连接；这时做负载均衡就不像是 <code>HTTP</code> 那样简单了。</p><p>而我们使用 <code>gRPC</code> 想达到效果和 HTTP 是一样的，需要对请求进行负载均衡而不是连接。</p><p>通常有两种做法：</p><ul><li>客户端负载均衡</li><li>服务端负载均衡</li></ul><p>客户端负载均衡在 <code>rpc</code> 调用中应用广泛，比如 <code>Dubbo</code> 就是使用的客户端负载均衡。</p><p><code>gRPC</code> 中也提供有相关接口，具体可以参考官方demo。</p><p><a href="https://github.com/grpc/grpc-go/blob/87eb5b7502/examples/features/load_balancing/README.md">https://github.com/grpc/grpc-go/blob/87eb5b7502/examples/features/load_balancing&#x2F;README.md</a></p><p>客户端负载均衡相对来说对开发者更灵活（可以自定义适合自己的策略），但相对的也需要自己维护这块逻辑，如果有多种语言那就得维护多份。</p><p>所以在云原生这个大基调下，更推荐使用服务端负载均衡。</p><p>可选方案有：</p><ul><li>istio</li><li>envoy</li><li>apix</li></ul><p>这块我们也在研究，大概率会使用 <code>envoy/istio</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>gRPC</code> 内容还是非常多的，本文只是作为一份入门资料希望能让不了解 <code>gRPC</code> 的能有一个基本认识；这在云原生时代确实是一门必备技能。</p><blockquote><p>对文中的 gRPC 客户端感兴趣的朋友，可以参考这里的源码：<br><a href="https://github.com/crossoverJie/ptg">https://github.com/crossoverJie/ptg</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/03/13/EvoDe9JNqPLHwdF.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;我猜测大部分长期使用 &lt;code&gt;Java&lt;/code&gt; 的开发者应该较少会接触 &lt;code&gt;gRPC&lt;/code&gt;，毕竟在 &lt;code&gt;Java&lt;/code&gt; 圈子里大部分使用的还是 &lt;code&gt;Dubbo/SpringClound&lt;/code&gt; 这两类服务框架。&lt;/p&gt;
&lt;p&gt;我也是近段时间有机会从零开始重构业务才接触到 &lt;code&gt;gRPC&lt;/code&gt; 的，当时选择 &lt;code&gt;gRPC&lt;/code&gt; 时也有几个原因：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/03/13/XCYkMxjpUgvZE5L.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于云原生的思路开发部署项目，而在云原生中 &lt;code&gt;gRPC&lt;/code&gt; 几乎已经是标准的通讯协议了。&lt;/li&gt;
&lt;li&gt;开发语言选择了 Go，在 Go 圈子中 &lt;code&gt;gRPC&lt;/code&gt; 显然是更好的选择。&lt;/li&gt;
&lt;li&gt;公司内部有部分业务使用的是 &lt;code&gt;Python&lt;/code&gt; 开发，在多语言兼容性上 &lt;code&gt;gRPC&lt;/code&gt; 支持的非常好。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="framework" scheme="http://crossoverjie.top/categories/framework/"/>
    
    
    <category term="Go" scheme="http://crossoverjie.top/tags/Go/"/>
    
    <category term="gRPC" scheme="http://crossoverjie.top/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>【译】Java8 之后对新开发者非常友好的特性盘点</title>
    <link href="http://crossoverjie.top/2022/02/07/translation/new-developer-friendly-features-after-java-8/"/>
    <id>http://crossoverjie.top/2022/02/07/translation/new-developer-friendly-features-after-java-8/</id>
    <published>2022-02-07T00:03:13.000Z</published>
    <updated>2022-02-06T14:22:10.479Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://piotrminkowski.com/2021/02/01/new-developer-friendly-features-after-java-8/">原文链接</a></strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz3vzlzrs6j30qo0f0dhz.jpg"></p><p>在这篇文章中，我将描述自 Java8 依赖对开发者来说最重要也最友好的特性，之所以选择 Java8 ，那是因为它依然是目前使用最多的版本。</p><p>具体可见这个调查报告：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz3w509h16j30sg0ao74v.jpg"></p><span id="more"></span><h1 id="Switch-表达式-JDK-12"><a href="#Switch-表达式-JDK-12" class="headerlink" title="Switch 表达式 (JDK 12)"></a>Switch 表达式 (JDK 12)</h1><p>使用 switch 表达式，你可以定义多个 case 条件，并使用箭头 <code>-&gt;</code> 符号返回值，这个特性在 JDK12 之后启用，它使得 switch 表达式更容易理解了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">newMultiSwitch</span><span class="params">(<span class="type">int</span> day)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> -&gt; <span class="string">&quot;workday&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span> -&gt; <span class="string">&quot;weekend&quot;</span>;</span><br><span class="line">      <span class="keyword">default</span> -&gt; <span class="string">&quot;invalid&quot;</span>;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JDK12 之前，同样的例子要复杂的多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">oldMultiSwitch</span><span class="params">(<span class="type">int</span> day)</span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;workday&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;weekend&quot;</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;invalid&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文本块-JDK-13"><a href="#文本块-JDK-13" class="headerlink" title="文本块 (JDK 13)"></a>文本块 (JDK 13)</h1><p>文本块是一个多行字符串，可以避免使用转移字符；从 Java13 之后它成为了预览特性，使用 <code>&quot;&quot;&quot;</code> 符号定义。接下来看看使用它声明一个 JSON 字符串有多简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getNewPrettyPrintJson</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">          &#123;</span></span><br><span class="line"><span class="string">             &quot;firstName&quot;: &quot;Piotr&quot;,</span></span><br><span class="line"><span class="string">             &quot;lastName&quot;: &quot;Mińkowski&quot;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">          &quot;&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java13 之前的版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getOldPrettyPrintJson</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">          <span class="string">&quot;     \&quot;firstName\&quot;: \&quot;Piotr\&quot;,\n&quot;</span> +</span><br><span class="line">          <span class="string">&quot;     \&quot;lastName\&quot;: \&quot;Mińkowski\&quot;\n&quot;</span> +</span><br><span class="line">          <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="新的-Optional-Methods-JDK-9-x2F-JDK-10"><a href="#新的-Optional-Methods-JDK-9-x2F-JDK-10" class="headerlink" title="新的 Optional Methods (JDK 9&#x2F; JDK 10)"></a>新的 Optional Methods (JDK 9&#x2F; JDK 10)</h1><p>Java 9&#x2F;10 版本之后新增了几种可选方法，有意思的是这两个：</p><ul><li><code>orElseThrow</code></li><li><code>ifPresentOrElse</code></li></ul><p>使用 <code>orElseThrow</code> 当数据不存在时你能抛出 <code>NoSuchElementException</code> 异常，相反会返回数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Person <span class="title function_">getPersonById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">   Optional&lt;Person&gt; personOpt = repository.findById(id);</span><br><span class="line">   <span class="keyword">return</span> personOpt.orElseThrow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正因为如此，可以避免在 isPresent 中使用 if 条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Person <span class="title function_">getPersonByIdOldWay</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">   Optional&lt;Person&gt; personOpt = repository.findById(id);</span><br><span class="line">   <span class="keyword">if</span> (personOpt.isPresent())</span><br><span class="line">      <span class="keyword">return</span> personOpt.get();</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个有趣的方法是 <code>ifPresentOrElse</code> ,当数据存在时，会执行带数据参数的函数，相反会执行参数为空的函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printPersonById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">   Optional&lt;Person&gt; personOpt = repository.findById(id);</span><br><span class="line">   personOpt.ifPresentOrElse(</span><br><span class="line">      System.out::println,</span><br><span class="line">      () -&gt; System.out.println(<span class="string">&quot;Person not found&quot;</span>)</span><br><span class="line">   );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java8 中，你需要在 isPresent 方法中使用 if else 语句。</p><h1 id="集合工厂方法-JDK-9"><a href="#集合工厂方法-JDK-9" class="headerlink" title="集合工厂方法(JDK 9)"></a>集合工厂方法(JDK 9)</h1><p>使用 Java9 中的集合工厂方法可以简单的使用预定义数据创建不可变集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; fruits = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>);</span><br><span class="line">Map&lt;Integer, String&gt; numbers = Map.of(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>, <span class="number">2</span>,<span class="string">&quot;two&quot;</span>, <span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br></pre></td></tr></table></figure><p>在 Java9 之前，你可以使用 Collections ，但肯定是更复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">fruits</span><span class="params">()</span> &#123;</span><br><span class="line">   List&lt;String&gt; fruitsTmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   fruitsTmp.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">   fruitsTmp.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">   fruitsTmp.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> Collections.unmodifiableList(fruitsTmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Map&lt;Integer, String&gt; <span class="title function_">numbers</span><span class="params">()</span> &#123;</span><br><span class="line">   Map&lt;Integer, String&gt; numbersTmp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   numbersTmp.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">   numbersTmp.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">   numbersTmp.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> Collections.unmodifiableMap(numbersTmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Records-JDK-14"><a href="#Records-JDK-14" class="headerlink" title="Records (JDK 14)"></a>Records (JDK 14)</h1><p>使用 <code>Records</code> 你可以定义一个不可变、只能访问数据（只有 getter 方法) 的类，它可以自动创建 <code>toString，equals，hashcode</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>以下效果与  <code>Records</code>  类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonOld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonOld</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">PersonOld</span> <span class="variable">personOld</span> <span class="operator">=</span> (PersonOld) o;</span><br><span class="line">        <span class="keyword">return</span> age == personOld.age &amp;&amp; name.equals(personOld.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PersonOld&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口中的私有方法-JDK-9"><a href="#接口中的私有方法-JDK-9" class="headerlink" title="接口中的私有方法 (JDK 9)"></a>接口中的私有方法 (JDK 9)</h1><p>从 Java8 之后你就可以为接口创建默认方法，但从 Java9 的私有方法你就能充分使用该特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExampleInterface</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printMsg</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Calling interface&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Interface method: &quot;</span> + methodName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">      printMsg(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">      printMsg(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="局部变量类型推导-JDK-10-x2F-JDK-11"><a href="#局部变量类型推导-JDK-10-x2F-JDK-11" class="headerlink" title="局部变量类型推导 (JDK 10 &#x2F; JDK 11)"></a>局部变量类型推导 (JDK 10 &#x2F; JDK 11)</h1><p>从 Java10 之后你就能使用局部变量类型推导了，只需要使用 var 关键字来代替具体类型；在 Java11 之后你就能在 lambda 表达式中使用类型推导了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">sumOfString</span><span class="params">()</span> &#123;</span><br><span class="line">   BiFunction&lt;String, String, String&gt; func = (<span class="keyword">var</span> x, <span class="keyword">var</span> y) -&gt; x + y;</span><br><span class="line">   <span class="keyword">return</span> func.apply(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;efg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://piotrminkowski.com/2021/02/01/new-developer-friendly-features-after-java-8/&quot;&gt;原文链接&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008i3skNly1gz3vzlzrs6j30qo0f0dhz.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章中，我将描述自 Java8 依赖对开发者来说最重要也最友好的特性，之所以选择 Java8 ，那是因为它依然是目前使用最多的版本。&lt;/p&gt;
&lt;p&gt;具体可见这个调查报告：&lt;br&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008i3skNly1gz3w509h16j30sg0ao74v.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="翻译" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="Java" scheme="http://crossoverjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>2021 年度报告</title>
    <link href="http://crossoverjie.top/2022/01/27/annual-summary/2021/"/>
    <id>http://crossoverjie.top/2022/01/27/annual-summary/2021/</id>
    <published>2022-01-27T00:13:26.000Z</published>
    <updated>2022-03-13T10:39:09.674Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/03/13/3KxYVB5liTZvHzJ.jpg"></p><p>不知不觉年终总结就像每个人的 KPI 一样，年底不总结一下感觉今年就白过了似的。</p><p>今年时间真的感觉过的特别快，经常感觉工资刚发不久结果没几天又到了发薪日；再也没有小时候一个暑假都能过一年的感觉。</p><span id="more"></span><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>生活上来说最大的变化也许就是年龄+1了，今年也是我们结婚两年恋爱十年的时间；十年这样的跨度现在想想还是觉得不可思议。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyp6g0rml3j30w20u0tct.jpg"></p><p>好在目前为止我们双方父母都没有催生，一切都顺其自然吧。</p><hr><p>虽然每天都是公司、家里两点一线的生活，但没想到的是今年居然喜欢上和我毫无关系的一项运动：足球。</p><p>原本是公司每周组织的足球活动 14 缺 1，没事就去踢了一次，结果发现还挺好玩；</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyp6qpormfj30rh1c3gpf.jpg"><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyp6y37k62j30rm1jzgp2.jpg"><br>虽然每次报名的都是原有的篮球队员，此消彼长自然篮球就没啥人报名了😂。</p><p>贴几段足球小视频：</p><iframe src="//player.bilibili.com/player.html?aid=676954694&bvid=BV1xU4y1T7xT&cid=450061966&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><iframe src="//player.bilibili.com/player.html?aid=975700568&bvid=BV1t44y147oD&cid=414155189&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><iframe src="//player.bilibili.com/player.html?aid=720492584&bvid=BV1LQ4y1r7rT&cid=405983161&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytw2pp3zmj30xi0k80yd.jpg"></p><blockquote><p>今年最后一场</p></blockquote><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>总的来说今年工作上的变化是最大的，其实简单来说就是我们被收购了；之前总是在网上看别人公司的小道消息吃瓜，没想到这次吃到自己头上来了。</p><p>幸运的是我个人受到的影响不大，毕竟也不是公司领导层，我们只需要做好自己的事情就行了。</p><p>当然落实到我们日常工作最明显的变化可能就是开发流程的变化了，这点在后文会具体说明。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyp7e4ycvcj30ry17gteg.jpg"><br>今年因为主导了几个系统的重构以及部门内部技术的推动，相对去年来说成绩上还是有所提升的，所以年底也评了优，算是对我工作的肯定吧。</p><p>但其实我个人不是特别满意，几个项目推动了一半，最终也没达到预期目标，只能寄托于来年了。</p><h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><p>由于公司的调整自然也带来了我们技术栈的变化；简单来说经历了几个阶段：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytwmggtycj31zs0aw3zv.jpg"></p><p>其实每个阶段都和公司业务+组织架构+业务现状有着千丝万缕的关系；个人的喜好很难起决定性作用。</p><p>所以绕来绕去，今年我又得开始写 <code>Java</code> 了；最近这三年时间从 <code>Java</code> 转到 <code>Python</code>，体验到了各种便捷的语法糖，又写了将近两年 <code>Go</code> 之后体验到了大道至简的优雅。</p><p>三种语言都各有优势，但从内心深处来讲我还是更愿意写 Go；可能是不想再去卷很难用到的八股文、配置繁琐的 <code>maven</code> 等。</p><p>由于团队内部有些同事没有接触过 <code>Java</code> ，所以让我以新手角度带大家一起学习；新版本的 JDK 语法糖+ <code>lombok</code> + <code>mapstruct</code> 这类工具，配合上最新的 IDEA 开发起来也是非常舒服的。</p><p>用单纯的 <code>SpringBoot</code> 结合 <code>k8s</code> 后，之前的 <a href="https://github.com/crossoverJie/feign-plus">https://github.com/crossoverJie/feign-plus</a> 就有用武之处了。</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytvfwavtlj30s80r2dhm.jpg"><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytvggk9fhj30p00tuwgf.jpg"></p><p>今年的技术原创博客产量也不高，满打满算将近 20 篇；其中大部分都与 Go 有关，近期确实大部分时间都是在写 Go，但也只是用了点皮毛；不出意外的话来年会 Java 和 Go 的内容都会写一点。</p><h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>今年的开源项目上我最喜欢的应该就是 <a href="https://github.com/crossoverJie/ptg">https://github.com/crossoverJie/ptg</a></p><blockquote><p>这是命令行的接口压测工具，同时也是一个 <code>gRPC</code> 的客户端 app。</p></blockquote><p><img src="https://i.loli.net/2021/11/29/GnPF5UESwNrojOl.gif"></p><p>UI 确实是我的极限了，我自己还有部分小伙伴使用了一段时间还是挺好用的。</p><blockquote><p>最近正在加 stream 调用相关的功能。</p></blockquote><hr><p>其实在公司内部也有用过 Go 重构过调度中心，就是大家用的挺多的 <code>xxl-job</code>。</p><p>由于我们的项目都是 <code>gRPC</code> 协议，同时运维体系之类的原因就用 Go 重写了一版。</p><p><img src="https://s2.loli.net/2022/03/13/jMAx3uBJqiTFo8t.jpg"></p><p>最终在每日百万次数的调度下成功率<code>≈99.9%</code>，已经可以满足业务使用了；</p><p>但后期如果业务上不再使用 <code>Go</code> 的话难免会有些可惜，所以我也在想和公司沟通下，可以把这个调度中心开源出来，同时以前也说过我们内部也做了一个 Go 的业务框架，现有的调度业务代码接入调度中心也是通过该业务框架实现的。</p><p>所以也准备都开源出来，但时间上还不好说，总之希望来年还能有机会多写写  Go，能参与开源是最好的。</p><hr><p>最后希望来年疫情能彻底结束了，至少能不限制的跨省旅旅游；也希望有机会能把前年办的健身卡利用起来，根据前几年的经验来看 flag 还是要少立。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/03/13/3KxYVB5liTZvHzJ.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;不知不觉年终总结就像每个人的 KPI 一样，年底不总结一下感觉今年就白过了似的。&lt;/p&gt;
&lt;p&gt;今年时间真的感觉过的特别快，经常感觉工资刚发不久结果没几天又到了发薪日；再也没有小时候一个暑假都能过一年的感觉。&lt;/p&gt;</summary>
    
    
    
    <category term="annual-summary" scheme="http://crossoverjie.top/categories/annual-summary/"/>
    
    
  </entry>
  
</feed>
