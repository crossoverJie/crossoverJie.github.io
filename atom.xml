<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverJie&#39;s Blog</title>
  
  <subtitle>baller</subtitle>
  <link href="http://crossoverjie.top/atom.xml" rel="self"/>
  
  <link href="http://crossoverjie.top/"/>
  <updated>2023-10-19T10:34:44.918Z</updated>
  <id>http://crossoverjie.top/</id>
  
  <author>
    <name>crossoverJie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何优雅重启 kubernetes 的 Pod</title>
    <link href="http://crossoverjie.top/2023/10/19/ob/k8s-restart-pod/"/>
    <id>http://crossoverjie.top/2023/10/19/ob/k8s-restart-pod/</id>
    <published>2023-10-19T02:58:44.000Z</published>
    <updated>2023-10-19T10:34:44.918Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/19/IW8kEDatFlMhz1O.png" alt="restart pod.png"></p><p>最近在升级服务网格 Istio，升级后有个必要的流程就是需要重启数据面的所有的 Pod，也就是业务的 Pod，这样才能将这些 Pod 的 sidecar 更新为新版本。</p><span id="more"></span><h1 id="方案-1"><a href="#方案-1" class="headerlink" title="方案 1"></a>方案 1</h1><p>因为我们不同环境的 Pod 数不少，不可能手动一个个重启；之前也做过类似的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete --all pods --namespace=dev</span><br></pre></td></tr></table></figure><p>这样可以一键将 dev 这个命名空间下的 Pod 删掉，kubernetes 之后会自动将这些 Pod 重启，保证和应用的可用性。</p><p>但这有个大问题是对 <code>kubernetes</code> 的调度压力较大，一般一个 <code>namespace</code> 下少说也是几百个 Pod，全部需要重新调度启动对 <code>kubernetes</code> 的负载会很高，稍有不慎就会有严重的后果。</p><p>所以当时我的第一版方案是遍历所有的  deployment，删除一个 Pod 后休眠 5 分钟再删下一个，伪代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">deployments, err := clientSet.AppsV1().Deployments(ns).List(ctx, metav1.ListOptions&#123;&#125;)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> err  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, deployment := <span class="keyword">range</span> deployments.Items &#123;</span><br><span class="line">podList, err := clientSet.CoreV1().Pods(ns).List(ctx, metav1.ListOptions&#123;  </span><br><span class="line">    LabelSelector: fmt.Sprintf(<span class="string">&quot;app=%s&quot;</span>, deployment.Name),  </span><br><span class="line">&#125;)</span><br><span class="line">err = clientSet.CoreV1().Pods(pod.Namespace).Delete(ctx, pod.Name, metav1.DeleteOptions&#123;&#125;)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> err  </span><br><span class="line">&#125;  </span><br><span class="line">log.Printf(<span class="string">&quot;    Pod %s rebuild success.\n&quot;</span>, pod.Name)</span><br><span class="line">time.Sleep(time.Minute * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>这个方案确实是简单粗暴，但在测试的时候就发现了问题。</p><p>当某些业务只有一个 Pod 的时候，直接删掉之后这个业务就挂了，没有多余的副本可以提供服务了。</p><p><strong>这肯定是不能接受的。</strong></p><p>甚至还有删除之后没有重启成功的：</p><ul><li>长期没有重启导致镜像缓存没有了，甚至镜像已经被删除了，这种根本就没法启动成功。</li><li>也有一些 Pod 有 <code>Init-Container</code> 会在启动的时候做一些事情，如果失败了也是没法启动成功的。<br>总之就是有多种情况导致一个 Pod 无法正常启动，这在线上就会直接导致生产问题，所以方案一肯定是不能用的。</li></ul><h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>为此我就准备了方案二：</p><p><img src="https://s2.loli.net/2023/10/19/reKiba4XtWSnP6z.png" alt="image.png"></p><ul><li>先将副本数+1，这是会新增一个 Pod，也会使用最新的 sidecar 镜像。</li><li>等待新建的 Pod 重启成功。</li><li>重启成功后删除原有的 Pod。</li><li>再将副本数还原为之前的数量。</li></ul><p>这样可以将原有的 Pod 平滑的重启，同时如果新的 Pod 启动失败也不会继续重启其他 <code>Deployment</code> 的 Pod，老的 Pod 也是一直保留的，对服务本身没有任何影响。</p><h2 id="存在的问题-1"><a href="#存在的问题-1" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>看起来是没有什么问题的，就是实现起来比较麻烦，流程很繁琐，这里我贴了部分核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RebuildDeploymentV2</span><span class="params">(ctx context.Context, clientSet kubernetes.Interface, ns <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">deployments, err := clientSet.AppsV1().Deployments(ns).List(ctx, metav1.ListOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, deployment := <span class="keyword">range</span> deployments.Items &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print each Deployment</span></span><br><span class="line">log.Printf(<span class="string">&quot;Ready deployment: %s\n&quot;</span>, deployment.Name)</span><br><span class="line"></span><br><span class="line">originPodList, err := clientSet.CoreV1().Pods(ns).List(ctx, metav1.ListOptions&#123;</span><br><span class="line">LabelSelector: fmt.Sprintf(<span class="string">&quot;app=%s&quot;</span>, deployment.Name),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if there are any Pods</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(originPodList.Items) == <span class="number">0</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;No pod in %s\n&quot;</span>, deployment.Name)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Skip Pods that have already been upgraded</span></span><br><span class="line">updateSkip := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, container := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line"><span class="keyword">if</span> container.Name == <span class="string">&quot;istio-proxy&quot;</span> &amp;&amp; container.Image == <span class="string">&quot;proxyv2:1.x.x&quot;</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;  Pod: %s Container: %s has already upgrade, skip\n&quot;</span>, pod.Name, container.Name)</span><br><span class="line">updateSkip = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> updateSkip &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scale the Deployment, create a new pod.</span></span><br><span class="line">scale, err := clientSet.AppsV1().Deployments(ns).GetScale(ctx, deployment.Name, metav1.GetOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">scale.Spec.Replicas = scale.Spec.Replicas + <span class="number">1</span></span><br><span class="line">_, err = clientSet.AppsV1().Deployments(ns).UpdateScale(ctx, deployment.Name, scale, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for pods to be scaled</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">podList, err := clientSet.CoreV1().Pods(ns).List(ctx, metav1.ListOptions&#123;</span><br><span class="line">LabelSelector: fmt.Sprintf(<span class="string">&quot;app=%s&quot;</span>, deployment.Name),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(podList.Items) != <span class="type">int</span>(scale.Spec.Replicas) &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for pods to be running</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">podList, err := clientSet.CoreV1().Pods(ns).List(ctx, metav1.ListOptions&#123;</span><br><span class="line">LabelSelector: fmt.Sprintf(<span class="string">&quot;app=%s&quot;</span>, deployment.Name),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">isPending := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> podList.Items &#123;</span><br><span class="line"><span class="keyword">if</span> item.Status.Phase != v1.PodRunning &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Deployment: %s Pod: %s Not Running Status: %s\n&quot;</span>, deployment.Name, item.Name, item.Status.Phase)</span><br><span class="line">isPending = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> isPending == <span class="literal">true</span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove origin pod</span></span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> originPodList.Items &#123;</span><br><span class="line">err = clientSet.CoreV1().Pods(ns).Delete(context.Background(), pod.Name, metav1.DeleteOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Remove origin %s success.\n&quot;</span>, pod.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recover scale</span></span><br><span class="line">newScale, err := clientSet.AppsV1().Deployments(ns).GetScale(ctx, deployment.Name, metav1.GetOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">newScale.Spec.Replicas = newScale.Spec.Replicas - <span class="number">1</span></span><br><span class="line">newScale.ResourceVersion = <span class="string">&quot;&quot;</span></span><br><span class="line">newScale.UID = <span class="string">&quot;&quot;</span></span><br><span class="line">_, err = clientSet.AppsV1().Deployments(ns).UpdateScale(ctx, deployment.Name, newScale, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Depoloyment %s rebuild success.\n&quot;</span>, deployment.Name)</span><br><span class="line">log.Println()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看的出来代码是比较多的。</p><h1 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h1><p>有没有更简单的方法呢，当我把上述的方案和领导沟通后他人都傻了，这也太复杂了：<code>kubectl</code> 不是有一个直接滚动重启的命令吗。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">❯ k rollout -h</span><br><span class="line">Manage the rollout of one or many resources.</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  <span class="built_in">history</span>       View rollout <span class="built_in">history</span></span><br><span class="line">  pause         Mark the provided resource as paused</span><br><span class="line">  restart       Restart a resource</span><br><span class="line">  resume        Resume a paused resource</span><br><span class="line">  status        Show the status of the rollout</span><br><span class="line">  undo          Undo a previous rollout</span><br></pre></td></tr></table></figure><p><code>kubectl rollout restart deployment/abc</code><br>使用这个命令可以将 <code>abc</code> 这个 <code>deployment</code> 进行滚动更新，这个更新操作发生在  kubernetes 的服务端，执行的步骤和方案二差不多，只是 kubernetes 实现的比我的更加严谨。</p><p>后来我在查看 <code>Istio</code> 的官方升级指南中也是提到了这个命令：<br><img src="https://s2.loli.net/2023/10/19/IjckD8GK2pzXfyn.png" alt="image.png"></p><blockquote><p>所以还是得好好看官方文档</p></blockquote><h2 id="整合-kubectl"><a href="#整合-kubectl" class="headerlink" title="整合 kubectl"></a>整合 kubectl</h2><p>既然有现成的了，那就将这个命令整合到我的脚本里即可，再遍历 namespace 下的 deployment 的时候循环调用就可以了。</p><p>但这个 <code>rollout</code> 命令在 <code>kubernetes</code> 的 <code>client-go</code> 的 <code>SDK</code> 中是没有这个 API 的。</p><p>所以我只有参考 kubectl 的源码，将这部分功能复制过来；不过好在可以直接依赖 kubect 到我的项目里。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">require (  </span><br><span class="line">    k8s.io/api v0<span class="number">.28</span><span class="number">.2</span>  </span><br><span class="line">    k8s.io/apimachinery v0<span class="number">.28</span><span class="number">.2</span>  </span><br><span class="line">    k8s.io/cli-runtime v0<span class="number">.28</span><span class="number">.2</span>  </span><br><span class="line">    k8s.io/client-<span class="keyword">go</span> v0<span class="number">.28</span><span class="number">.2</span>  </span><br><span class="line">    k8s.io/klog/v2 v2<span class="number">.100</span><span class="number">.1</span>  </span><br><span class="line">    k8s.io/kubectl v0<span class="number">.28</span><span class="number">.2</span>  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/10/19/7beuKWadX8M9y5c.png" alt="image.png"></p><p>源码里使用到的 <code>RestartOptions</code> 结构体是公共访问的，所以我就参考它源码魔改了一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRollOutRestart</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">    kubeConfigFlags := defaultConfigFlags()  </span><br><span class="line">    streams, _, _, _ := genericiooptions.NewTestIOStreams()  </span><br><span class="line">    ns := <span class="string">&quot;dev&quot;</span>  </span><br><span class="line">    kubeConfigFlags.Namespace = &amp;ns  </span><br><span class="line">    matchVersionKubeConfigFlags := cmdutil.NewMatchVersionFlags(kubeConfigFlags)  </span><br><span class="line">    f := cmdutil.NewFactory(matchVersionKubeConfigFlags)  </span><br><span class="line">    deploymentName := <span class="string">&quot;deployment/abc&quot;</span>  </span><br><span class="line">    r := &amp;rollout.RestartOptions&#123;  </span><br><span class="line">       PrintFlags: genericclioptions.NewPrintFlags(<span class="string">&quot;restarted&quot;</span>).WithTypeSetter(scheme.Scheme),  </span><br><span class="line">       Resources:  []<span class="type">string</span>&#123;deploymentName&#125;,  </span><br><span class="line">       IOStreams:  streams,  </span><br><span class="line">    &#125;  </span><br><span class="line">    err := r.Complete(f, <span class="literal">nil</span>, []<span class="type">string</span>&#123;deploymentName&#125;)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Fatal(err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    err = r.RunRestart()  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Fatal(err)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终在几次 debug 后终于可以运行了，只需要将这部分逻辑移动到循环里，加上 <code>sleep</code> 便可以有规律的重启 Pod 了。</p><p>参考链接：</p><ul><li><a href="https://istio.io/latest/docs/setup/upgrade/canary/#data-plane">https://istio.io/latest/docs/setup/upgrade/canary/#data-plane</a></li><li><a href="https://github.com/kubernetes/kubectl/blob/master/pkg/cmd/rollout/rollout_restart.go">https://github.com/kubernetes/kubectl/blob/master/pkg/cmd/rollout/rollout_restart.go</a></li></ul><p>#Blog #K8s </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/19/IW8kEDatFlMhz1O.png&quot; alt=&quot;restart pod.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在升级服务网格 Istio，升级后有个必要的流程就是需要重启数据面的所有的 Pod，也就是业务的 Pod，这样才能将这些 Pod 的 sidecar 更新为新版本。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/OB/k8s/"/>
    
    
    <category term="client-go" scheme="http://crossoverjie.top/tags/client-go/"/>
    
  </entry>
  
  <entry>
    <title>在 kubernetes 环境中实现 gRPC 负载均衡</title>
    <link href="http://crossoverjie.top/2023/10/16/ob/k8s-grpc-lb/"/>
    <id>http://crossoverjie.top/2023/10/16/ob/k8s-grpc-lb/</id>
    <published>2023-10-16T07:55:50.000Z</published>
    <updated>2023-10-17T06:01:48.484Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/16/wJiKvMAaWUyOCpX.png" alt="Istio-grpc-lb.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间写过一篇 <code>gRPC</code> 的入门文章，在最后还留了一个坑没有填：<br><img src="https://s2.loli.net/2023/10/16/41I2RZXeQanFgdB.png" alt="image.png"><br>也就是 <code>gRPC</code> 的负载均衡问题，因为当时的业务请求量不算大，再加上公司没有对 Istio 这类服务网格比较熟悉的大牛，所以我们也就一直拖着没有解决，依然只是使用了 kubernetes 的 service 进行负载，好在也没有出什么问题。</p><span id="more"></span><p>由于现在换了公司后也需要维护公司的服务网格服务，结合公司内部对 Istio 的使用现在终于不再停留在理论阶段了。</p><p>所以也终有机会将这个坑填了。</p><h1 id="gRPC-负载均衡"><a href="#gRPC-负载均衡" class="headerlink" title="gRPC 负载均衡"></a>gRPC 负载均衡</h1><h2 id="负载不均衡"><a href="#负载不均衡" class="headerlink" title="负载不均衡"></a>负载不均衡</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>先来回顾下背景，为什么会有 <code>gRPC</code> 负载不均衡的问题。<br>由于 <code>gRPC</code> 是基于 HTTP&#x2F;2 协议的，所以客户端和服务端会保持长链接，一旦链接建立成功后就会一直使用这个连接处理后续的请求。</p><p><img src="https://s2.loli.net/2023/10/16/NxJqPM49vAgEBtX.png" alt="image.png"></p><p>除非我们每次请求之后都新建一个连接，这显然是不合理的。</p><p>所以要解决 <code>gRPC</code> 的负载均衡通常有两种方案：</p><ul><li>服务端负载均衡</li><li>客户端负载均衡<br>在 <code>gRPC</code> 这个场景服务端负载均衡不是很合适，所有的请求都需要经过一个负载均衡器，这样它就成为整个系统的瓶颈，所以更推荐使用客户端负载均衡。</li></ul><p>客户端负载均衡目前也有两种方案，最常见也是传统方案。<br><img src="https://s2.loli.net/2023/10/16/x31gJLImRlfXa9i.png" alt="image.png"><br>这里以 Dubbo 的调用过程为例，调用的时候需要从服务注册中心获取到提供者的节点信息，然后在客户端本地根据一定的负载均衡算法得出一个节点然后发起请求。</p><p>换成 <code>gRPC</code> 也是类似的，这里以 <code>go-zero</code> 负载均衡的原理为例：<br><img src="https://s2.loli.net/2023/10/16/PLnyAKsmDZQRoeh.png" alt="image.png"></p><p>gRPC 官方库也提供了对应的负载均衡接口，但我们依然需要自己维护服务列表然后在客户端编写负载均衡算法，这里有个官方 demo:</p><p><a href="https://github.com/grpc/grpc-go/blob/87eb5b7502493f758e76c4d09430c0049a81a557/examples/features/load_balancing/client/main.go">https://github.com/grpc/grpc-go/blob/87eb5b7502493f758e76c4d09430c0049a81a557/examples/features/load_balancing&#x2F;client&#x2F;main.go</a></p><p>但切换到 kubernetes 环境中时再使用以上的方式就不够优雅了，因为我们使用 kubernetes 的目的就是不想再额外的维护这个客户端包，这部分能力最好是由 kubernetes 自己就能提供。</p><p>但遗憾的是 kubernetes 提供的 service 只是基于 L4 的负载，所以我们每次请求的时候都只能将请求发往同一个 Provider 节点。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这里我写了一个小程序来验证负载不均衡的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create gRPC server</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   <span class="keyword">var</span> port = <span class="string">&quot;:50051&quot;</span>  </span><br><span class="line">   lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)  </span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">      log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)  </span><br><span class="line">   &#125;  </span><br><span class="line">   s := grpc.NewServer()  </span><br><span class="line">   pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)  </span><br><span class="line">   <span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">      log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)  </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      log.Printf(<span class="string">&quot;served on %s \n&quot;</span>, port)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.  </span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;  </span><br><span class="line">   pb.UnimplementedGreeterServer  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// SayHello implements helloworld.GreeterServer  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, <span class="type">error</span>) &#123;  </span><br><span class="line">   log.Printf(<span class="string">&quot;Received: %v&quot;</span>, in.GetName())  </span><br><span class="line">   name, _ := os.Hostname()  </span><br><span class="line">   <span class="comment">// Return hostname of Server</span></span><br><span class="line">   <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: fmt.Sprintf(<span class="string">&quot;hostname:%s, in:%s&quot;</span>, name, in.Name)&#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用同一个 gRPC 连接发起一次 gRPC 请求，服务端会返回它的 <code>hostname</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (  </span><br><span class="line">   once sync.Once  </span><br><span class="line">   c    pb.GreeterClient  </span><br><span class="line">)  </span><br><span class="line">http.HandleFunc(<span class="string">&quot;/grpc_client&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">   once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">      service := r.URL.Query().Get(<span class="string">&quot;name&quot;</span>)  </span><br><span class="line">      conn, err := grpc.Dial(fmt.Sprintf(<span class="string">&quot;%s:50051&quot;</span>, service), grpc.WithInsecure(), grpc.WithBlock())  </span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)  </span><br><span class="line">      &#125;  </span><br><span class="line">      c = pb.NewGreeterClient(conn)  </span><br><span class="line">   &#125;)  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// Contact the server and print out its response.  </span></span><br><span class="line">   name := <span class="string">&quot;world&quot;</span>  </span><br><span class="line">   ctx, cancel := context.WithTimeout(context.Background(), time.Second)  </span><br><span class="line">   <span class="keyword">defer</span> cancel()  </span><br><span class="line">   g, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: name&#125;)  </span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">      log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)  </span><br><span class="line">   &#125;  </span><br><span class="line">   fmt.Fprint(w, fmt.Sprintf(<span class="string">&quot;Greeting: %s&quot;</span>, g.GetMessage()))  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>创建一个 service 用于给 <code>gRPC</code> 提供域名：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">native-tools-2</span></span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">native-tools-2</span></span><br><span class="line">  <span class="attr">ports:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span>  </span><br><span class="line">      <span class="attr">port:</span> <span class="number">8081</span>  </span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8081</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grpc</span>  </span><br><span class="line">      <span class="attr">port:</span> <span class="number">50051</span>  </span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">50051</span></span><br></pre></td></tr></table></figure><p>同时将我们的 gRPC server 部署三个节点，再部署了一个客户端节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ k get pod</span><br><span class="line">NAME                                READY   STATUS    RESTARTS</span><br><span class="line">native-tools-2-d6c454689-52wgd      1/1     Running   0              </span><br><span class="line">native-tools-2-d6c454689-67rx4      1/1     Running   0              </span><br><span class="line">native-tools-2-d6c454689-zpwxt      1/1     Running   0              </span><br><span class="line">native-tools-65c5bd87fc-2fsmc       2/2     Running   0             </span><br></pre></td></tr></table></figure><p>我们进入客户端节点执行多次 grpc 请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">k <span class="built_in">exec</span> -it native-tools-65c5bd87fc-2fsmc bash</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line">Greeting: hostname:native-tools-2-d6c454689-zpwxt, <span class="keyword">in</span>:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br></pre></td></tr></table></figure><p>会发现每次请求的都是同一个节点 <code>native-tools-2-d6c454689-zpwxt</code>，这也就证明了在 kubernetes 中直接使用 gRPC 负载是不均衡的，一旦连接建立后就只能将请求发往那个节点。</p><h2 id="使用-Istio"><a href="#使用-Istio" class="headerlink" title="使用 Istio"></a>使用 Istio</h2><p>Istio 可以拿来解决这个问题，我们换到一个注入了 Istio 的 namespace 下还是同样的 代码，同样的 service 资源进行测试。</p><blockquote><p>关于开启 namespace 的 Istio 注入会在后续更新，现在感兴趣的可以查看下官方文档：<br><a href="https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/">https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-5m7dl, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-xprjz, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-5m7dl, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-5m7dl, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-xprjz, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-xprjz, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-5m7dl, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-5m7dl, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-nz8h5, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br><span class="line"></span><br><span class="line">Greeting: hostname:native-tools-2-5fbf46cf54-nz8h5, in:worldistio-proxy@n:/$ curl http://127.0.0.1:8081/grpc_client?name=native-tools-2</span><br></pre></td></tr></table></figure><p>可以发现同样的请求已经被负载到了多个 server 后端，这样我们就可以不再单独维护一个客户端 SDK 的情况下实现了负载均衡。</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>其实本质上 Istio 也是客户端负载均衡的一种实现。<br><img src="https://s2.loli.net/2023/10/16/XOU1TGtvm7PeJ8o.png" alt="image.png"><br>以 Istio 的架构图为例：</p><ul><li>每一个 Pod 下会新增一个 <code>Proxy</code> 的 <code>container</code>，所有的流量入口和出口都会经过它。</li><li>它会从控制平面 <code>Istiod</code> 中拿到服务的注册信息，也就是 <code>kubernetes</code> 中的 service。</li><li>发生请求时由 proxy 容器中的 <code>Envoy</code> 进行最终的负载请求。</li></ul><p>可以在使用了 Istio 的 Pod 中查看到具体的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ k get pod native-tools-2-5fbf46cf54-5m7dl -n istio-test-2 -o json | jq <span class="string">&#x27;.spec.containers[].name&#x27;</span></span><br><span class="line"><span class="string">&quot;istio-proxy&quot;</span></span><br><span class="line"><span class="string">&quot;native-tools-2&quot;</span></span><br></pre></td></tr></table></figure><p>可以发现这里存在一个 <code>istio-proxy</code> 的容器，也就是我们常说的 <code>sidecar</code>，这样我们就可以把原本的 SDK 里的功能全部交给 Istio 去处理。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当然 Istio 的功能远不止于此，比如：</p><ul><li>统一网关，处理东西、南北向流量。</li><li>灰度发布</li><li>流量控制</li><li>接口粒度的超时配置</li><li>自动重试等</li></ul><p>这次只是一个开胃菜，更多关于 <code>Istio</code> 的内容会在后续更新，比如会从如何在 <code>kubernetes</code> 集群中安装 <code>Istio</code> 讲起，带大家一步步使用好 <code>Istio</code>。</p><p>本文相关源码：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p><p><sub>参考链接：</sub></p><ul><li><a href="https://istio.io/latest/docs/setup/getting-started/">https://istio.io/latest/docs/setup/getting-started/</a></li><li><a href="https://segmentfault.com/a/1190000042295402">https://segmentfault.com/a/1190000042295402</a></li><li><a href="https://go-zero.dev/docs/tutorials/service/governance/lb">https://go-zero.dev/docs/tutorials/service/governance/lb</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/16/wJiKvMAaWUyOCpX.png&quot; alt=&quot;Istio-grpc-lb.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间写过一篇 &lt;code&gt;gRPC&lt;/code&gt; 的入门文章，在最后还留了一个坑没有填：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/16/41I2RZXeQanFgdB.png&quot; alt=&quot;image.png&quot;&gt;&lt;br&gt;也就是 &lt;code&gt;gRPC&lt;/code&gt; 的负载均衡问题，因为当时的业务请求量不算大，再加上公司没有对 Istio 这类服务网格比较熟悉的大牛，所以我们也就一直拖着没有解决，依然只是使用了 kubernetes 的 service 进行负载，好在也没有出什么问题。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/OB/k8s/"/>
    
    
    <category term="gRPC" scheme="http://crossoverjie.top/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读周刊第一期</title>
    <link href="http://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/"/>
    <id>http://crossoverjie.top/2023/10/13/ob/newsletter/Newsletter01-20231013/</id>
    <published>2023-10-13T08:22:13.000Z</published>
    <updated>2023-10-18T02:54:40.821Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/13/qHMR6zDI529ZsEf.png" alt="Newsletter01.png"></p><p>我自己平时有每天阅读文章的习惯，也会将这些文章保存起来并做一些记录，今天在看阮一峰的科技爱好者周刊时突然想到我也可以将这些看过的觉得不错的内容分享出来。<br><img src="https://s2.loli.net/2023/10/13/TaQZ2MyX4xEIedR.png" alt="image.png"></p><p>顺便也可以让大伙参与留下自己觉得不错的内容，互相学习。</p><span id="more"></span><p>以下便是第一期的内容：</p><h1 id="Istio-中的负载均衡详解及多集群路由实践-🌟🌟🌟"><a href="#Istio-中的负载均衡详解及多集群路由实践-🌟🌟🌟" class="headerlink" title="Istio 中的负载均衡详解及多集群路由实践 🌟🌟🌟"></a><a href="https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/">Istio 中的负载均衡详解及多集群路由实践</a> 🌟🌟🌟</h1><p>1. 介绍了客户端负载均衡和服务端负载均衡的特点和应用场景。<br>2. 引申出 Istio 使用 Envoy 做客户端负载均衡的方案。<br>3. 介绍 Istio 支持的一些负载均衡算法。<br>4. 如何为具体的服务配置负载均衡，以及如何编写 <code>DestinationRule</code> <code>和VirtualService</code></p><h1 id="理解-gRPC-协议🌟🌟🌟🌟"><a href="#理解-gRPC-协议🌟🌟🌟🌟" class="headerlink" title="理解 gRPC 协议🌟🌟🌟🌟"></a><a href="https://taoshu.in/grpc.html">理解 gRPC 协议</a>🌟🌟🌟🌟</h1><p>1. 首先是介绍了 JSON 编码的缺点，可读性高，但性能差。<br>2. PB 性能好，但可读性差，同时还需要配套工具，比如 .proto 格式 IDL 文件来做额外的接口描述。<br>3. 接口请求是底层依然是 http 协议，不过是 http&#x2F;2 协议，但是请求的映射是直接使用 .proto 文件的描述。<br>4. 消息格式描述了消息体前有五个字节，第一个字节描述了是否压缩，后续四个字节描述了消息大小。<br>5. 因为是 stream 协议的关系，才加了这五个字节，因为每次请求都是同一个连接，为了要区分不同的请求就需要在这五个字节来区分了。</p><h1 id="Protocol-Buffers-编码🌟🌟🌟🌟"><a href="#Protocol-Buffers-编码🌟🌟🌟🌟" class="headerlink" title="Protocol Buffers 编码🌟🌟🌟🌟"></a><a href="https://taoshu.in/pb-encoding.html">Protocol Buffers 编码</a>🌟🌟🌟🌟</h1><blockquote><p>配合上一篇一起阅读更加</p></blockquote><p>详细讲解了 PB 编码的原理。<br>1. 定长数据都比较简单，主要是解决变长字符串的问题。<br>2. 以 <code>websocket</code> 为例，<code>websocket</code> 的是三挡变速，而 PB 引入了  VarInts 实现了无级变速，<strong>但前提是字段不能太多</strong>。<br>3. 使用了 Tag 代替了字段名，但坏处就是解码必须需要 PB 文件，也就是需要通过 PB 文件生成目标语言。<br>4. 同时 Tag 也不能更改，更改后解码端得同步更新。</p><h1 id="The-top-7-software-engineering-workflow-tips-I-wish-I-knew-earlier-🧰-🌟🌟🌟🌟"><a href="#The-top-7-software-engineering-workflow-tips-I-wish-I-knew-earlier-🧰-🌟🌟🌟🌟" class="headerlink" title="The top 7 software engineering workflow tips I wish I knew earlier 🧰 🌟🌟🌟🌟"></a>The top 7 software engineering workflow tips I wish I knew earlier 🧰 🌟🌟🌟🌟</h1><blockquote><p>作者使用多年的提高工作效率的七个习惯<br>1. Git 相关，别名，我觉得对我来说是自动补全+历史记录更好用<br>2. 编码相关，别直接使用查找，可以多使用 IDE 快捷键+AI 编程<br>3. 记录学到的知识，比如 Notion，现在我使用 Obsidian<br>4. 使用 Todo 记录自己的灵感，脑子不是拿来存储这些东西的，是拿来做创造力相关的事情（这个我也是使用的 Obsidian 插件 Memos）。<br>5. 可视化沟通，比如使用截图 App，写文档等。<br>6. 使用密码 App，比如 1Password<br>7. 使用窗口管理 App</p></blockquote><h1 id="conc：Go-语言的并发工具库🌟🌟🌟🌟"><a href="#conc：Go-语言的并发工具库🌟🌟🌟🌟" class="headerlink" title="conc：Go 语言的并发工具库🌟🌟🌟🌟"></a><a href="https://github.com/sourcegraph/conc">conc</a>：Go 语言的并发工具库🌟🌟🌟🌟</h1><blockquote><p>Better structured concurrency for go</p></blockquote><p>这是项目的介绍，简单来说就是封装了一些使用  goroutine 的常用操作：</p><ul><li>使用 <code>conc.WaitGroup</code> 替代标准的 <code>sync.WaitGroup</code>，并提供了安全运行的特性，不用担心 panic。</li><li>使用 <code>pool.ResultPool</code> 可以拿到执行的结果，<code>Javaer</code> 是不是似曾相识。</li><li><code>iter.Map/iter.ForEach</code> 可以直接并发 Map 或者是迭代 slice。</li></ul><p><img src="https://s2.loli.net/2023/10/13/iwhN8qW5MmpXfQV.png" alt="image.png"><br>这里举了个例子，如果我们想要写出一个安全的 <code>goroutine</code> 程序，大概需要写左边那么多的代码，而使用 <code>conc</code> 会简单很多，也更加易读。</p><p>其实从这里就不难看出，<code>conc</code> 只是将这些代码封装好了，感兴趣的也可以看看源码，代码不多，很快就可以看完。</p><blockquote><p>以上内容和评分纯主观参考，均没有使用类似于 ChatGPT 这类 AI 工具进行总结，绝对是传统人肉阅读归纳，匠心工艺。</p><p>上榜文章都很不错，推荐大家去阅读原文。</p></blockquote><p>文章链接：</p><ul><li><a href="https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/">https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/</a></li><li><a href="https://github.com/sourcegraph/conc">https://github.com/sourcegraph/conc</a></li><li><a href="https://taoshu.in/pb-encoding.html">https://taoshu.in/pb-encoding.html</a></li><li><a href="https://taoshu.in/grpc.html">https://taoshu.in/grpc.html</a></li><li><a href="https://careercutler.substack.com/p/the-top-7-software-engineering-workflow?ref=dailydev">https://careercutler.substack.com/p/the-top-7-software-engineering-workflow?ref=dailydev</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/13/qHMR6zDI529ZsEf.png&quot; alt=&quot;Newsletter01.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;我自己平时有每天阅读文章的习惯，也会将这些文章保存起来并做一些记录，今天在看阮一峰的科技爱好者周刊时突然想到我也可以将这些看过的觉得不错的内容分享出来。&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/13/TaQZ2MyX4xEIedR.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;顺便也可以让大伙参与留下自己觉得不错的内容，互相学习。&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Newsletter" scheme="http://crossoverjie.top/categories/OB/Newsletter/"/>
    
    
    <category term="Tech" scheme="http://crossoverjie.top/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>使用 Helm 管理应用的一些 Tips</title>
    <link href="http://crossoverjie.top/2023/10/07/ob/Helm-tips/"/>
    <id>http://crossoverjie.top/2023/10/07/ob/Helm-tips/</id>
    <published>2023-10-07T12:36:14.000Z</published>
    <updated>2023-10-08T09:49:14.476Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/08/9HKS1lNqyGMson5.png" alt="Helm tips.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><code>Helm</code> 是一个 <strong>Kubernetes</strong> 的包管理工具，有点类似于 <code>Mac</code> 上的 <code>brew</code>，<code>Python</code> 中的 <code>PIP</code>；可以很方便的帮我们直接在 <code>kubernetes</code> 中安装某个应用。</p><p>比如我们可以直接使用以下命令方便的在 k8s 集群安装和卸载 <code>MySQL</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm install my-sql oci://registry-1.docker.io/bitnamicharts/mysql -n mysql</span><br><span class="line"></span><br><span class="line">helm uninstall my-mysql -n mysql</span><br></pre></td></tr></table></figure><span id="more"></span><p>对于一些复杂的应用使用 Helm 一键安装会更简单，以 Pulsar 举例：<br><img src="https://s2.loli.net/2023/10/08/ig4koZIFlUT5Bt1.png" alt="image.png"><br>它有着多个组件，比如 bookkeeper、zookeeper、broker、proxy 等，各个组件还有着依赖关系。</p><p>如果我们手动安装流程会比较繁琐，而使用 Helm 时便非常简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm repo add apache https://pulsar.apache.org/charts</span><br><span class="line"></span><br><span class="line">helm install my-pulsar apache/pulsar --version 3.0.0 -n pulsar</span><br></pre></td></tr></table></figure><blockquote><p>当然他也只是帮我们生成了部署所需要的 yaml 文件，也没有太多黑科技。</p></blockquote><h1 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h1><p>看似简单的工具我在实际线上使用的时候也踩过一个坑，最大的一个问题就是某次升级 Pulsar 的时候生成的 yaml 文件是空的，导致整个集群被删除了😭。</p><p>还好最后使用 <code>helm  rollback version</code> 将集群恢复过来了，我们的持久化数据也还在。</p><p>而出现这个问题的原因是我执行了下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade pulsar ./charts/pulsar --version 2.9.2 -f charts/pulsar/values-2.10.3.yaml -n pulsar</span><br></pre></td></tr></table></figure><p>我们是将 <code>pulsar</code> 的 <code>Helm-Chart</code> 源码下载到本地，然后修改 <code>value.yaml</code> 的方式执行升级的。</p><p>当时执行命令的时候没有注意，在一个没有 <code>values-2.10.3.yaml</code> 文件的目录下执行的，导致生成的 <code>yaml</code> 文件是空的，也就导致 k8s 在 <code>pulsar</code> 这个 <code>namespace</code> 下删除了所有的资源。</p><h2 id="模拟升级"><a href="#模拟升级" class="headerlink" title="模拟升级"></a>模拟升级</h2><p>为了避免今后再次出现类似的问题，需要在升级前先模拟升级：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade pulsar ./charts/pulsar --version 2.9.2 -f charts/pulsar/values-2.10.3.yaml -n pulsar --dry-run --debug &gt; debug.yaml</span><br></pre></td></tr></table></figure><p>其中关键的 <code>dry-run</code> 和 <code>debug</code> 参数可以指定模拟升级和输出详细的内容。</p><p>这样我们就可以在升级前先查看 <code>debug.yaml</code> 里的内容是不是符合我们的预期。</p><h1 id="对比升级"><a href="#对比升级" class="headerlink" title="对比升级"></a>对比升级</h1><p>但这样并不能直观的看出哪些地方是我们修改的，还好社区已经有了相关的插件，可以帮我们高亮显示修改的地方。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm plugin install https://github.com/databus23/helm-diff</span><br></pre></td></tr></table></figure><p>我们先安装好这个 helm 插件。</p><p>然后在升级前先使用该插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm diff upgrade pulsar ./charts/pulsar --version 2.9.2 -f charts/pulsar/values-2.10.3.yaml -n pulsar</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/10/08/V1k5gdhLASfq9JR.png" alt="image.png"></p><p>这样就可以高亮显示出修改的内容。</p><blockquote><p>不用担心这个命令会直接升级，它会自动加上 –dry-run –debug 参数。</p></blockquote><p>更多命令可以参考官方文档：<br><a href="https://github.com/databus23/helm-diff">https://github.com/databus23/helm-diff</a></p><p>Helm 功能很强，在操作生产环境的时候必须得谨慎，都是血淋淋的教训啊。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/08/9HKS1lNqyGMson5.png&quot; alt=&quot;Helm tips.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Helm&lt;/code&gt; 是一个 &lt;strong&gt;Kubernetes&lt;/strong&gt; 的包管理工具，有点类似于 &lt;code&gt;Mac&lt;/code&gt; 上的 &lt;code&gt;brew&lt;/code&gt;，&lt;code&gt;Python&lt;/code&gt; 中的 &lt;code&gt;PIP&lt;/code&gt;；可以很方便的帮我们直接在 &lt;code&gt;kubernetes&lt;/code&gt; 中安装某个应用。&lt;/p&gt;
&lt;p&gt;比如我们可以直接使用以下命令方便的在 k8s 集群安装和卸载 &lt;code&gt;MySQL&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;helm install my-sql oci://registry-1.docker.io/bitnamicharts/mysql -n mysql&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;helm uninstall my-mysql -n mysql&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Helm" scheme="http://crossoverjie.top/categories/Helm/"/>
    
    
    <category term="CloudNative" scheme="http://crossoverjie.top/tags/CloudNative/"/>
    
  </entry>
  
  <entry>
    <title>跟着播客学英语-Why I use vim ? part two.</title>
    <link href="http://crossoverjie.top/2023/10/06/ob/podcasts-english-1-vim/"/>
    <id>http://crossoverjie.top/2023/10/06/ob/podcasts-english-1-vim/</id>
    <published>2023-10-06T12:54:10.000Z</published>
    <updated>2023-10-06T10:04:51.597Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/05/lx4a2h1KcUyIoHd.png"></p><p>在上一期作者讲到了他使用 Vim 的主要原因是提高效率，不需要再去使用鼠标，今天我们继续上次未听完的内容：</p><span id="more"></span><p>if you type Vi, that’s going to be alias to Vim anyway by default there’s, not really a good reason for you to use vi that I can think of. The reason I first started using Vim is kind of a <code>silly</code> one, and that is because my brother used it, uh, my brother, Nick, he climbs mountains for a living. Right now, he lives in Seattle and goes up and down rain near when it gets too cold to climb. Rainer? He goes to the other side of the world and leads, climbs up mountains over there, and then comes back again and starts climb a rain air over and over and over again.</p><p>Before he did that, though, he used to do quite a bit of programming, and I remember when I would watch him program because he started programming before me, he looked like a real hacker. He looked like the hackers you see on TV. He never touched the mouse. There was text flying out all over the screen files, opening, closing splits. It was awesome. It was like I wanted to be that person you. Know and He was using vim. I didn’t know it was Vim, but that’s what he was using. So I opened Vim. I tried to edit some files I was using Eclipse at the time and doing Java.</p><blockquote><p>作者首次使用 Vim 的 原因有点傻，因为他的哥哥 Nick 做了很长时间的编程，一直使用的都是 Vim，看起来就行是电视里真正的黑客那样，他从不使用鼠标，文字也在屏幕里乱飞，看起来非常酷。<br>而那个时候作者还在使用 eclipse 编写 Java</p></blockquote><p>This is like my first year of college, I was taking an introductory to programming class. It’s the first programming I’ve ever done, and I thought Eclipse was great. It compiled my code for me. It had buttons for everything, but I didn’t feel like a real hacker when I looked at nick. I mean, granted, he was writing C, which already looks way cooler. He was using Vim as well, and it just <code>impressed</code> me, so I try to start opening up some of my Java files, and I have no idea how to do it. No idea how to edit a file I have no idea how to save a file I have no idea how to type in the document for crying out loud.</p><p>If I press keys, it does nothing. Sometimes a delete words, sometimes at pacewords, <code>it&#39;s a mess</code>, and this is probably the first experience that everybody has when they start using Vim, because Vim operates completely different than any other text editor I’ve ever used it’s <code>weird</code> them has modes, it has a language, it has objects, subjects, counts, verbs. All that stuff is, like, really weird when you first get started, but once you understand it, it’s a lot of learning upfront everything, just kind of clicks and you’re instantly faster than you’ve ever been before,</p><blockquote><p>eclipse 很好用，但看起来没有 Nick 使用 Vim 那么酷，使得作者印象深刻。</p><p>因此他尝试使用 Vim 来打开 Java 文件，但却不知道如何编辑、删除、保存等基本操作，大部分初次使用 Vim 应该都会碰到这些问题，它和我们使用的其他编辑器完全不同，看起来比较奇怪。</p><p>不过一旦你掌握它，那么使用效率将会飞速提高。</p></blockquote><p>for example, let’s say, we wanted to copy a method from one ruby file and put it in another. If I was using sublime text, I would take my mouse. I would select that method I’d press command c to copy it, and then I’d click over to where I want the method to be, and I’d press command v to paste it. Not very bad that’s pretty fast probably doesn’t take very long, but in Vim, you can do it even faster and without touching your mouse, them has a verb for yanking text it’s not called copying it’s, called yanking.</p><p>It has a movement called inside, so you can yank inside something, and then it has subjects called text blocks, which, in Ruby, those are methods. Vim understands blocks of text if you’re editing a markdown document like, say, a read me, them’ll know where a paragraph starts and where a paragraph ends, if we’re editing a ruby file it’s going to know where a method begins and where a method ends, or where your class begins or where your class ends, so using the Verb Yank, which happens to be the key Y,</p><blockquote><p>如果我们使用 sublime 这样的编辑器复制一个方法时会比较麻烦，首先要用鼠标选中文本，然后复制再粘贴。<br>但使用 Vim 时不需要使用鼠标，而是被称为 Yanking，当编辑  Markdown 时 Vim 会知道段落的开始和结尾，编辑 Ruby 时可以方法的开始和结尾。</p></blockquote><p>and then the movement inside, which happens to be the key I, and then the subject paragraph, which is vim’s word for a block of text, you can yank a method. So if I put my cursor inside a ruby method and I type Y I P. For yank inside paragraph, it’s going to copy that method to the clipboard. So by understanding the verb, yank the movement inside and the subject paragraph, we can perform actions really, really quickly, and then if we want to pace it somewhere else, we press the peaky for paste,</p><p>and it’ll stick that text down, so everything in Vim is based on those concepts of verbs, movements and subjects. You also have one more thing you can play with, and that is counts, so if you want to perform something multiple times, in most cases, you can stick a number in front of it like one, two, three, five, and it’s going to do it that many times, understanding those basic concepts, gets you a really long way, and then it’s just a matter of understanding which keys correspond to which verbs and which movements and which subjects,</p><blockquote><p>在 vim 中只需要将光标移动到方法中，然后使用 YIP 就可以复制整个方法。<br>所以只要理解了这些基本概念就可以快速提高效率。</p></blockquote><p>and that just comes with time, which is the third reason I like to use Vim. Is there so much stuff to learn whenever I get bored? All I got to do is pull up them help, and I could start learning stuff in every little thing, I learn, every little keyboard shortcut, every movement, every subject, gets me a little bit faster, and it doesn’t seem like a lot like the example I gave earlier, of copying and pasting text and sublime with a mouse that doesn’t take very long. But if you add up all those little bits,</p><p>you’re saving a ton of time, a good <code>analogy</code> I like to use is <code>lifting</code> weights if I’m <code>squatting</code> 100 pounds, and I take a little, teeny, tiny two and a half pound plate, and I put it on each side of the barbell I probably won’t, even notice it, I mean, I’ll be squatting 105 pounds now, right, that’s not really that big of a difference, but if I add those two and a half pound plates 60 more times, going in once a day, and doing that, I’m now squatting 400 pounds, which is a pretty big difference, so those little changes don’t seem like a lot,</p><blockquote><p>我喜欢使用 Vim 的一个原因是可以学到许多东西，每学一些都可以让自己的效率提高一点。<br>就像是我们深蹲一样，慢慢的加重量，反复尝试最终就能得到巨大的提升。</p></blockquote><p>but taken as a whole, you’re editing text way faster than people who aren’t using vim. The last reason I like to use Vim is because it runs in the terminal, and this may not seem like a big deal, but it really is <code>cosmetically</code>, it’s nice because you can just pop a terminal open, full screen and have no chrome I use mac os, so I’ve got that big menu bar on top, it’s really nice to just full screen a terminal and not see anything at all, and have your command line tools and your text editor all running in the same window I happen to use tmucks to manage that stuff I won’t talk about Tmux and now,</p><p>but I definitely will talk about it in another episode, but even out of the <code>cosmetic</code> reasons, it’s nice to have a text editor that runs in the terminal because you’re not always using your own machine right as web developers, I’m a web developer, we’re always connecting to remote machines to edit files. Now, why is it that we should be forced to use a different text editor? The nice thing about Vim is it runs in the terminal, so every machine you connect to will likely already have Vim installed, but even if it doesn’t you can install it,</p><p>and you can put your config files over there and you can make it so that no matter where you’re editing text you’re always in the same environment, which is awesome. Before I started using Vim out, connect a remote machines, and, and be forced to use some textset or I’m not familiar with, and it drove me nuts, but now I sometimes forget I’m on a remote machine because it’s exactly the same as the machine I use at home, so if you’ve never tried them, or maybe you tried it in the past, and it was super confusing or really turned you off.</p><blockquote><p>最后一个使用 Vim 的 原因是它可以在终端中运行，不仅可以使用自己的设备，还可以连接到远程设备去编辑文件，还可以使用相同的配置文件，使得所有的环境配置都是相同的</p></blockquote><p>Give it a second shot there’s, a great stack overflow article that just kind of rehashs a lot of the things I said here, but it’s just it’s also just fun to read it talks about the core concepts of vi, the editor that Vim is based on, and I put a link to that in the shownotes there’s, also, them casts by Drew Neil, which is a screencast series that’s totally free, and he covers a lot of advanced concepts he’s got a little bit of beginner stuff in there as well. You can also just open up a terminal and type vim tutor and Vim’s going to give you a little lesson in how to use Vim,</p><p>give it a shot that’s all I’ve got for this week, you can find the shownotes at healthy hacker Dot Com, slash one, if you have any questions or feedback, send me a voicemail healthy hacker, Dot Com Slash Voicemail.</p><blockquote><p>在 stack overflow 中有着各种教程，大家可以尝试一下。</p></blockquote><h1 id="生词"><a href="#生词" class="headerlink" title="生词"></a>生词</h1><p>The reason I first started using Vim is kind of a <code>silly</code> one<br>我第一次使用 Vim 的原因有点傻。</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://s2.loli.net/2023/10/06/WKxpPUNT5wZr983.png" alt="image.png"></h2><p><code>it&#39;s a mess</code><br>搞砸了<br><img src="https://s2.loli.net/2023/10/06/Cl6pKGR7e8A54mk.png" alt="image.png"></p><p>a good <code>analogy</code> I like to use is <code>lifting</code> weights if I’m <code>squatting</code> 100 pounds,<br>but it really is <code>cosmetically</code>,<br><img src="https://s2.loli.net/2023/10/06/8DxnNGwmMiyzCbJ.png"></p><p><img src="https://s2.loli.net/2023/10/06/68yEronuJUpm9wW.png" alt="image.png"><br><img src="https://s2.loli.net/2023/10/06/2O86HijZufx9eVW.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/05/lx4a2h1KcUyIoHd.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上一期作者讲到了他使用 Vim 的主要原因是提高效率，不需要再去使用鼠标，今天我们继续上次未听完的内容：&lt;/p&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Podcasts" scheme="http://crossoverjie.top/categories/OB/Podcasts/"/>
    
    
    <category term="English" scheme="http://crossoverjie.top/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>跟着播客学英语-Why I use vim ? part one.</title>
    <link href="http://crossoverjie.top/2023/10/02/ob/podcasts-english-0-vim/"/>
    <id>http://crossoverjie.top/2023/10/02/ob/podcasts-english-0-vim/</id>
    <published>2023-10-02T12:54:10.000Z</published>
    <updated>2023-10-05T15:25:45.382Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/03/kheL1o68m2IyXbU.png" alt="why-use-vim-01.png"></p><p>最近这段时间在学英语，在网上看到有网友推荐可以听英文播客提高听力水平。</p><p>正好我自己也有听播客的习惯，只不过几乎都是中文，但现在我已经尝试听了一段时间的英文播客，觉得效果还不错。</p><p>大部分都是和 IT 相关的内容，所以一些关键词还能听懂，同时也是自己的感兴趣的内容，如果是一次听不懂我就会反复收听。<br>视频版：</p><iframe src="//player.bilibili.com/player.html?aid=961634958&bvid=BV1TH4y1Z77L&cid=1287992721&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><span id="more"></span><p>今天来听第一期内容，这位作者是一位资深工程师，讲述他为什么使用 Vim 的过程。<br><a href="https://www.healthyhacker.com/2014/07/29/why-i-use-vim/">https://www.healthyhacker.com/2014/07/29/why-i-use-vim/</a></p><p>以下是我通过语音转文字的内容</p><blockquote><p>我会精简翻译比较重要的部分，还是推荐大家去收听原始播客。</p></blockquote><p>Healthy hacker episode one. Welcome to the healthy hacker, where we talk about programming, puzzles, memory, fitness, diet, and everything else that you a healthy hacker , find Interesting. I’m Chris Hunt, and on the very first episode episode one, I’m going to answer a question? I get all the time, every conference I go to, every time I start a new job, every time I pair with somebody new. And that is: Chris, why do you use Vim? At of all the text editor on the planet, why do you choose to use Vim?</p><blockquote><p>作者在各种会议和新同事的接触中都会被问到这个问题：为什么你会使用 vim</p></blockquote><p>It’s so old it looks like <code>crap</code>. Why do you do it? So I’m totally going to tell you I have many various reasons why I love using Vim really excited about it, going to answer that question before we do though, we are going to talk about the workout of the week , all right. The workout of the week is a section that, uh, basically, I’m just going to take a workout I’ve done recently, and tell you about it, and hopefully you find the time this week to try it yourself, because every single one of these workouts you can do, I promise you. </p><blockquote><p>在开始之前先聊聊本周的锻炼</p></blockquote><p>Okay, so this week’s workout is a workout that I’ve been doing for several years. You need <code>barely</code> no equipment. All you need is a floor. I do it at least once, when I travel, sometimes twice, sometimes three times. I think there was a point in my life where I was doing this. Work out, like three or four times a day. This is the only thing I was doing. I don’t recommend that, but you should totally give it a shot at least once this week and let me know how you do, because I’m <code>curious</code>,</p><blockquote><p>这个锻炼已经进行了许多年了，几乎不需要额外的设备，只需要一块地板。旅行的时候也会继续坚持，建议你本周至少得尝试一次。</p></blockquote><p>so let’s get right into it this is  A ten rep pyramid, and I’ll I’ll explain what that means. Basically, you want to do each exercise, one time, then two times, then three times, then four times, all the way up to ten, the top of the pyramid ten times, and then you go back down again to one, so nine, a seven until you finally end with one rep of each exercise, so the two exercises are going to do for this workout is a pushup and a shoulder press with no weight on each of these, you’re just doing body weight.</p><blockquote><p>做一个递增组和递减组，从每组一个动作增加到每组 10 个动作，再由十个动作一组减少到一个动作一组；<br>每组做两个动作，俯卧撑，和坐姿推肩，都不用负重，只需要自重即可。</p></blockquote><p>So I’m sure, everybody knows what a pushup is. If you don’t check out the show notes, or just do a Google image search, shoulder press you may or may not be as familiar with, but it’s just like it sounds. You take your hands, put them by your shoulders, and then press your hands up into the air again, just to Google. Im in search, you’ll totally get what this is. So the workout is one pushup. One shoulder press, then two pushups, two shoulder presses, then three pushups, then three shoulder presses,</p><blockquote><p>应该都知道俯卧撑怎么做，如果推肩不知道怎么做的话可以去 Google，都是比较简单动作；<br>所以这个训练是一次俯卧撑，一次推肩为一个动作；然后增加到两个俯卧撑+推肩+然后是三个俯卧撑+三个推肩。</p></blockquote><p>then four, five, six, seven, eight 910, and then go back down again, nine, eight, seven, six, and you finish with one push up, one shoulder, press. Now. The goal with this is to go as fast as you possibly can, but take breaks as necessary. I <code>definitely</code> can’t do this without stopping, especially on the pushups part. So do as fast as you can. When I did this this morning, I did it in seven minutes and 28 seconds, so let me know how you do. I’m super curious if you’ve never done this before, it’s going to seem crazy hard,</p><blockquote><p>以此类推做到十次，再递减到 1 一次，目标是尽可能的快速完成。<br>休息也是非常有必要的，我无法做到不休息全部完成，特别是在俯卧撑这个部分。<br>非常好奇你做完的感受，如果你从来没做过的话，还是比较困难的。</p></blockquote><p>but I know you can do it. By the time you finished this workout, you will have done 100 pushups and 100 shoulder presses. If it really Really Really is out of your <code>reach</code>, even with breaks, then you can scale this workout, decreasing your pyramid. So instead of doing a ten rep pyramid, do like a six rep pyramid or a Five Rep Pyramid, but with brakes, I know that everybody can do 100 pushups in 100 shoulder presses. It might take you a while, but you can do it, so give it a shot. All right. </p><blockquote><p>但超过你的承受范围时，可以适当减少组数。</p></blockquote><p>So now it’s time to answer that question: why do I use Vim? Well, for starters, if you’re going to learn any editor vim is a pretty good <code>investment</code>. It’s been around for a long time over 20 years. It’s open source, it runs on everything it’s not like there’s, a company vested in its future you know it doesn’t cost you money, it’s for as long as I’m programming, vim is going to be around, so if I’m going to waste time trying to master a text editor, vim is probably a good choice because it’s not going anywhere</p><p>I’m not going to have to forget everything I’ve learned and start learning a different text editor. I can use vim for the rest of my life for all my text editor so it’s a good <code>investment</code> of your time. Now if you do a Google search, you start looking for books for Vim, you might see Vi and Vi is actually an older editor that Vim is based on Vim stands for Vi improved, and most of them’s functionality comes from Vi, so most of us, don’t use Vi, some of the things I really like about vim, that Vi doesn’t have is improved syntax,</p><p>highlighting for the languages I like to use mostly Ruby and Javascript. Nowadays, they’re spell-checking, so when you use it for typing an emails or typing up a poll request that comes in handy, there’s splits, so you can view maybe your test and your code at the same time, without having to go back and forth, you have multiple levels of undo and redo them can do diffs, or, as vi can’t do diff, so you can open up two of the same files that are edited at different points of time, and see that diff in red and green it’s pretty nice,</p><blockquote><p>学习 vim 是一个很好的投资，它是开源的免费的，值得花时间去学习。<br>vi 是 vim 的前身，vim 在此基础上进行了改进，比如语法高亮、输入检测等。<br>vim 还可以分屏，可视化对比等</p></blockquote><p>and then you also have scripting Vim script itself, which is, the native script language for Vim is not pretty, but you can also do scripting with other languages, like Perl, Ruby, python and Vim also has a really awesome help system with which vi does not have there’s also some improvements that Vim ads that I don’t really care about, I mean I took notes, obviously because I don’t have all this stuff memorized, and I’ve titled this section dumb <code>stuff</code>, because it’s kind of du I don’t care linefolding is one editing of compressed files I don’t really care about that.</p><blockquote><p>Vim 还内置了脚本语言 vimscript，很好用的帮助系统，这些 vi 都没有。</p></blockquote><p>You can edit files over network connections like ssh ftp http. I could say how that would be useful, but I’ve never wanted or had to do that, and then them also provides a graphical user interface. Usually you open this up using Gvim for graphical Vim, and that provides mouse integration, again, things I don’t care about. One of the main reasons I use Vim is for speed, and not having to touch the mouse, so it’s kind of silly to for me to get excited about that kind of <code>stuff</code>, okay So so that’s the kind of the differences between Vim and Vi and why everybody uses Vim most computers now.</p><blockquote><p>vim 可以通过网络连接来编辑文件，同时也提供了 GUI 界面，可以使用鼠标来操作。<br>不过我对这个并不感兴趣，使用 vim 的主要原因就是因为速度，不需要在去触摸鼠标了（这确实也是大部分人使用 vim 的原因）</p></blockquote><h1 id="生词"><a href="#生词" class="headerlink" title="生词"></a>生词</h1><p>It’s so old it looks like <code>crap</code>:  它已经很老了，看起来是垃圾。<br><code>crap</code>:<br><img src="https://s2.loli.net/2023/10/03/3RZontYrVcDTFGq.png" alt="image.png"></p><p>if you’re going to learn any editor, vim is a pretty good <code>investment</code>：<br>如果你想学习一个编辑器，Vim 是一个不错的投资。<br><code>investment</code>:<br><img src="https://s2.loli.net/2023/10/03/PjR97l2iYNLtU3g.png" alt="image.png"></p><p>I <code>definitely</code> can’t do this without stopping<br>我绝对不能不停下来<br><code>definitely</code>:<br><img src="https://s2.loli.net/2023/10/03/saTHywQgdti5ePA.png" alt="image.png"></p><p>let me know how you do, because I’m <code>curious</code>:<br>告诉我你是怎么做的，我很好奇。<br><code>curious</code><br><img src="https://s2.loli.net/2023/10/03/vWz9ZR6MdLVSrUu.png" alt="image.png"></p><p>You need <code>barely</code> no equipment.<br>你几乎不需要设备<br><code>barely</code><br><img src="https://s2.loli.net/2023/10/03/9rcKYjITGQgUB4n.png" alt="image.png"></p><p>I don’t have all this <code>stuff</code> memorized:<br>我没有记住所有这些东西<br><code>stuff</code><br><img src="https://s2.loli.net/2023/10/03/nP8SpO2DTdHLj31.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/10/03/kheL1o68m2IyXbU.png&quot; alt=&quot;why-use-vim-01.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近这段时间在学英语，在网上看到有网友推荐可以听英文播客提高听力水平。&lt;/p&gt;
&lt;p&gt;正好我自己也有听播客的习惯，只不过几乎都是中文，但现在我已经尝试听了一段时间的英文播客，觉得效果还不错。&lt;/p&gt;
&lt;p&gt;大部分都是和 IT 相关的内容，所以一些关键词还能听懂，同时也是自己的感兴趣的内容，如果是一次听不懂我就会反复收听。&lt;br&gt;视频版：&lt;/p&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=961634958&amp;bvid=BV1TH4y1Z77L&amp;cid=1287992721&amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;</summary>
    
    
    
    <category term="OB" scheme="http://crossoverjie.top/categories/OB/"/>
    
    <category term="Podcasts" scheme="http://crossoverjie.top/categories/OB/Podcasts/"/>
    
    
    <category term="English" scheme="http://crossoverjie.top/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>k8s入门到实战-应用配置</title>
    <link href="http://crossoverjie.top/2023/09/26/ob/k8s-configmap/"/>
    <id>http://crossoverjie.top/2023/09/26/ob/k8s-configmap/</id>
    <published>2023-09-26T06:20:33.000Z</published>
    <updated>2023-09-26T13:24:40.137Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/26/b9N2AufHMpqWRKs.png" alt="ConfigMap.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在前面<a href="https://crossoverjie.top/categories/k8s/">三节中</a>已经讲到如何将我们的应用部署到 k8s 集群并提供对外访问的能力，x现在可以满足基本的应用开发需求了。</p><p>现在我们需要更进一步，使用 k8s 提供的一些其他对象来标准化我的应用开发。<br>首先就是 <code>ConfigMap</code>，从它的名字也可以看出这是用于管理配置的对象。</p><span id="more"></span><h1 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h1><p>不管我们之前是做 <code>Java</code>、<code>Go</code> 还是 <code>Python</code> 开发都会使用到配置文件，而 <code>ConfigMap</code> 的作用可以将我们原本写在配置文件里的内容转存到 <code>k8s</code> 中，然后和我们的 <code>Container</code> 进行绑定。</p><h2 id="存储到环境变量"><a href="#存储到环境变量" class="headerlink" title="存储到环境变量"></a>存储到环境变量</h2><p>绑定的第一种方式就是将配置直接写入到环境变量，这里我先定义一个 <code>ConfigMap</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-configmap</span>  </span><br><span class="line"><span class="attr">data:</span>  </span><br><span class="line">  <span class="attr">PG_URL:</span> <span class="string">&quot;postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable&quot;</span></span><br></pre></td></tr></table></figure><p>重点是 <code>data</code> 部分，存储的是一个 <code>KV</code> 结构的数据，这里存储的是一个数据库连接。</p><blockquote><p>需要注意，KV 的大小不能超过 1MB</p></blockquote><p>接着可以在容器定义中绑定这个 <code>ConfigMap</code> 的所有 <code>KV</code> 到容器的环境变量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define all the ConfigMap&#x27;s data as container environment variables </span></span><br><span class="line"><span class="attr">envFrom:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">configMapRef:</span>  </span><br><span class="line">      <span class="attr">name:</span> <span class="string">k8s-combat-configmap</span></span><br></pre></td></tr></table></figure><p>我将 <code>ConfigMap</code> 的定义也放在了同一个 <a href="https://github.com/crossoverJie/k8s-combat/blob/main/deployment/deployment.yaml">deployment</a> 中，直接 apply:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ k apply -f deployment/deployment.yaml</span><br><span class="line">deployment.apps/k8s-combat created</span><br><span class="line">configmap/k8s-combat-configmap created</span><br></pre></td></tr></table></figure><p>此时 <code>ConfigMap</code> 也会被创建，我们可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">❯ k get configmap</span><br><span class="line">NAME                   DATA   AGE</span><br><span class="line">k8s-combat-configmap   1      3m17s</span><br><span class="line"></span><br><span class="line">❯ k describe configmap k8s-combat-configmap</span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">PG_URL:</span><br><span class="line">----</span><br><span class="line">postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable</span><br></pre></td></tr></table></figure><p>拿到刚才声明的配置信息。</p><hr><p>同时我在代码中也读取了这个环境变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">   name, _ := os.Hostname()  </span><br><span class="line">   url := os.Getenv(<span class="string">&quot;PG_URL&quot;</span>)   </span><br><span class="line">   fmt.Fprint(w, fmt.Sprintf(<span class="string">&quot;%s-%s&quot;</span>, name, url))  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>访问这个接口便能拿到这个环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-combat-7b987bb496-pqt9s:/# curl http://127.0.0.1:8081</span><br><span class="line">k8s-combat-7b987bb496-pqt9s-postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable</span><br><span class="line"></span><br><span class="line">root@k8s-combat-7b987bb496-pqt9s:/# echo $PG_URL</span><br><span class="line">postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable</span><br></pre></td></tr></table></figure><h2 id="存储到文件"><a href="#存储到文件" class="headerlink" title="存储到文件"></a>存储到文件</h2><p>有些时候我们也需要将这些配置存储到一个文件中，比如在 Java 中可以使用 <code>spring</code> 读取，<code>Go</code> 也可以使用 <code>configor</code> 这些第三方库来读取，所有配置都在一个文件中也更方便维护。</p><p><img src="https://s2.loli.net/2023/09/26/g2IhktH7iwWb8LT.png" alt="image.png"><br>在 <code>ConfigMap</code> 中新增了一个 <code>key:APP</code> 存放了一个 <code>yaml</code> 格式的数据，然后在容器中使用 <code>volumes</code> 和 <code>volumeMounts</code> 将数据挂载到容器中的指定路径<code>/go/bin/app.yaml</code></p><p>apply 之后我们可以在容器中查看这个文件是否存在：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-combat-7b987bb496-pqt9s:/# cat /go/bin/app.yaml</span><br><span class="line">name: k8s-combat</span><br><span class="line">pulsar:</span><br><span class="line">  url: &quot;pulsar://localhost:6650&quot;</span><br><span class="line">  token: &quot;abc&quot;</span><br></pre></td></tr></table></figure><p>配置已经成功挂载到了这个路径，我们便可以在代码中读取这些数据。</p><h1 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h1><p>可以看到 <code>ConfigMap</code> 中是明文存储数据的；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k describe configmap k8s-combat-configmap</span><br></pre></td></tr></table></figure><p>可以直接查看。</p><p>对一些敏感数据就不够用了，这时我们可以使用 <code>Secret</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-secret</span>  </span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span>  </span><br><span class="line"><span class="attr">data:</span>  </span><br><span class="line">  <span class="attr">PWD:</span> <span class="string">YWJjCg==</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">env:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PG_PWD</span>  </span><br><span class="line">    <span class="attr">valueFrom:</span>  </span><br><span class="line">      <span class="attr">secretKeyRef:</span>  </span><br><span class="line">        <span class="attr">name:</span> <span class="string">k8s-combat-secret</span>  </span><br><span class="line">        <span class="attr">key:</span> <span class="string">PWD</span></span><br></pre></td></tr></table></figure><p>这里我新增了一个 <code>Secret</code> 用于存储密码，并在 <code>container</code> 中也将这个 <code>key</code> 写入到环境变量中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ echo &#x27;abc&#x27; | base64</span><br><span class="line">YWJjCg==</span><br></pre></td></tr></table></figure><p><code>Secret</code> 中的数据需要使用 <code>base64</code> 进行编码，所以我这里存储的是 abc.</p><p>apply 之后我们再查看这个 <code>Secret</code> 是不能直接查看原始数据的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ k describe secret k8s-combat-secret</span><br><span class="line">Name:         k8s-combat-secret</span><br><span class="line">Type:  Opaque</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">PWD:  4 bytes</span><br></pre></td></tr></table></figure><p><code>Secret</code> 相比 <code>ConfigMap</code> 多了一个 <code>Type</code> 选项。<br><img src="https://s2.loli.net/2023/09/26/G25TRcSzCbIVDQ3.png"></p><p>我们现阶段在应用中用的最多的就是这里的 <code>Opaque</code>，其他的暂时还用不上。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在实际开发过程中研发人员基本上是不会直接接触 <code>ConfigMap</code>，一般会给开发者在管理台提供维护配置的页面进行 CRUD。</p><p>由于 <code>ConfigMap</code> 依赖于 k8s 与我们应用的语言无关，所以一些高级特性，比如实时更新就无法实现，每次修改后都得重启应用才能生效。</p><p>类似于 Java 中常见的配置中心：<code>Apollo,Nacos</code> 使用上会有不小的区别，但这些是应用语言强绑定的，如果业务对这些配置中心特性有强烈需求的话也是可以使用的。</p><p>但如果团队本身就是多语言研发，想要降低运维复杂度 <code>ConfigMap</code> 还是不二的选择。</p><p>下一章节会更新大家都很感兴趣的服务网格 <code>Istio</code>，感兴趣的朋友多多点赞转发🙏🏻。</p><p>本文的所有源码和资源文件在这里可以访问：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/26/b9N2AufHMpqWRKs.png&quot; alt=&quot;ConfigMap.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在前面&lt;a href=&quot;https://crossoverjie.top/categories/k8s/&quot;&gt;三节中&lt;/a&gt;已经讲到如何将我们的应用部署到 k8s 集群并提供对外访问的能力，x现在可以满足基本的应用开发需求了。&lt;/p&gt;
&lt;p&gt;现在我们需要更进一步，使用 k8s 提供的一些其他对象来标准化我的应用开发。&lt;br&gt;首先就是 &lt;code&gt;ConfigMap&lt;/code&gt;，从它的名字也可以看出这是用于管理配置的对象。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/k8s/"/>
    
    
    <category term="ConfigMap" scheme="http://crossoverjie.top/tags/ConfigMap/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言史诗级更新-循环Bug修复</title>
    <link href="http://crossoverjie.top/2023/09/24/ob/go-loop-fix/"/>
    <id>http://crossoverjie.top/2023/09/24/ob/go-loop-fix/</id>
    <published>2023-09-24T10:05:25.000Z</published>
    <updated>2023-09-24T11:45:54.302Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/24/rU7IujkPWX1TRQM.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前两天 <code>Golang</code> 的官方博客更新了一篇文章：<a href="https://go.dev/blog/loopvar-preview">Fixing For Loops in Go 1.22</a></p><p>看这个标题的就是修复了 Go 循环的 bug，这真的是史诗级的更新；我身边接触到的大部分 Go 开发者都犯过这样的错误，包括我自己，所以前两年我也写过类似的博客：<br><a href="https://crossoverjie.top/2021/12/28/go/for-mistake/">简单的 for 循环也会踩的坑</a></p><span id="more"></span><p>先来简单回顾下使用使用 for 循环会碰到的问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list := []*Demo&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;&#125;  </span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;  </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">fmt.Println(<span class="string">&quot;name=&quot;</span>+v.Name)  </span><br><span class="line">&#125;()  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Demo <span class="keyword">struct</span> &#123;  </span><br><span class="line">Name <span class="type">string</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预期的结果应该是打印 <code>a,b</code>，但实际打印的却是<code>b,b</code>。</p><p><img src="https://s2.loli.net/2023/09/24/I98GMk5efvNUDbT.png" alt="image.png"></p><p><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1619047">Let’s Encrypt: CAA Rechecking bug</a><br>类似的问题连 <code>mozilla</code> 团队也没能幸免，所以也确实是一个非常常见的问题，这样的写法符合大部分的开发者的直觉，毕竟其他语言这么使用也没有问题。</p><p>当然在现阶段要解决也很简单，要么就是在使用之前先复制一次，或者使用闭包传参：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制</span></span><br><span class="line"> list := []*Demo&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;&#125;  </span><br><span class="line"> <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;  </span><br><span class="line">  temp:=v  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   fmt.Println(<span class="string">&quot;name=&quot;</span>+temp.Name)  </span><br><span class="line">  &#125;()  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"> list := []*Demo&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;&#125;  </span><br><span class="line"> <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(temp *Demo)</span></span> &#123;  </span><br><span class="line">   fmt.Println(<span class="string">&quot;name=&quot;</span>+temp.Name)  </span><br><span class="line">  &#125;(v)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>还好官方也意识到了这个问题：<br><img src="https://s2.loli.net/2023/09/24/6NTZSijCofypK54.png" alt="image.png"><br>所以在 1.22 中我们可以不用再写这个 <code>    v:=v</code>这个多余的复制语句了，也不会出现上面的问题。</p><p>我们在 1.21 中可以使用环境变量预览这个特性:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ GOEXPERIMENT=loopvar <span class="keyword">go</span> test</span><br><span class="line">name=b</span><br><span class="line">name=a</span><br></pre></td></tr></table></figure><p>在 1.22 发布后建议大家都可以升级了，将这种恶心的 bug 扼杀在摇篮里。</p><p>1.22 后带来了一个好消息是今后少了一道面试题，坏消息是又新增了一个 1.22 版本带来了哪些变化的面试题😂</p><p>更多详情可以参看官方播客：<a href="https://go.dev/blog/loopvar-preview">https://go.dev/blog/loopvar-preview</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/24/rU7IujkPWX1TRQM.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前两天 &lt;code&gt;Golang&lt;/code&gt; 的官方博客更新了一篇文章：&lt;a href=&quot;https://go.dev/blog/loopvar-preview&quot;&gt;Fixing For Loops in Go 1.22&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看这个标题的就是修复了 Go 循环的 bug，这真的是史诗级的更新；我身边接触到的大部分 Go 开发者都犯过这样的错误，包括我自己，所以前两年我也写过类似的博客：&lt;br&gt;&lt;a href=&quot;https://crossoverjie.top/2021/12/28/go/for-mistake/&quot;&gt;简单的 for 循环也会踩的坑&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="http://crossoverjie.top/categories/Golang/"/>
    
    
    <category term="loop" scheme="http://crossoverjie.top/tags/loop/"/>
    
  </entry>
  
  <entry>
    <title>Github commit 签名+合并 Commit</title>
    <link href="http://crossoverjie.top/2023/09/18/ob/git-tips-rebase/"/>
    <id>http://crossoverjie.top/2023/09/18/ob/git-tips-rebase/</id>
    <published>2023-09-18T09:56:51.000Z</published>
    <updated>2023-09-19T06:36:40.881Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/18/gCjw9hZx4Y6cPSn.png" alt="Github的一个奇技淫巧.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间给 <code>VictoriaLogs</code> 提交了一个 PR：<br><a href="https://github.com/VictoriaMetrics/VictoriaMetrics/pull/4934">https://github.com/VictoriaMetrics/VictoriaMetrics/pull/4934</a></p><p>本来一切都很顺利，只等合并了，但在临门一脚的时候社区维护人员问我可否给 <code>git</code> <code>commit</code> 加上签名。</p><blockquote><p>于是我就默默的调试到了凌晨四点😭</p></blockquote><p><img src="https://s2.loli.net/2023/09/18/VXhjU9ypuKP1ZWg.png" alt="image.png"></p><span id="more"></span><p>以前我也没怎么注意过这个选项，经过 <code>Google</code> 后发现 <code>Idea</code> 在提交的时候可以自行设置。</p><p><img src="https://s2.loli.net/2023/09/18/QdTetRSNG5c3KVr.png" alt="image.png"><br>当我勾选了这个提交新的代码后，依然被告知没有正确的签名，这时我才发现理解错误了。</p><h1 id="为-GitHub-的提交签名"><a href="#为-GitHub-的提交签名" class="headerlink" title="为 GitHub 的提交签名"></a>为 GitHub 的提交签名</h1><p>结合这位社区大佬给的文档，他所需要的是每次提交的代码都是有签名的，类似于这样：<br><img src="https://s2.loli.net/2023/09/18/26vgVMZmNrPCkqo.png" alt="image.png"></p><p>如果我们想要 <code>GitHub</code> 现实 <code>Verified</code> 这个标签，那就需要对 <code>commit</code> 或者是打的 <code>tag</code> 进行签名。</p><p>而签名的方式有三种：<code>GPG</code>, <code>SSH</code>, <code>S/MIME</code>，这里我以 GPG 签名为例，整体流程如下：</p><p><img src="https://s2.loli.net/2023/09/18/HwDIlL94c51Uz3e.png" alt="image.png"></p><p>先在<a href="https://www.gnupg.org/download/">https://www.gnupg.org/download/</a>这里下载安装 GPG 的命令行程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --full-generate-key</span><br></pre></td></tr></table></figure><p>使用这个命令生成 key，之后会根据提示录入一些信息，包含你的 ID 和邮箱，建议都和 GitHub 的 ID 邮箱保持一致即可，然后一路回车完事。</p><p>之后可以使用这个命令查看刚才创建的 Key：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gpg --list-secret-keys --keyid-format=long</span><br><span class="line">------------------------------------</span><br><span class="line">sec   4096R/3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]</span><br><span class="line">uid                          Hubot &lt;hubot@example.com&gt;</span><br><span class="line">ssb   4096R/4BB6D45482678BE3 2016-03-10</span><br></pre></td></tr></table></figure><p>我们需要将 <code>3AA5C34371567BD2</code> 这个 Key 的 ID 字符串复制，之后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --armor --export 3AA5C34371567BD2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Prints the GPG key ID, <span class="keyword">in</span> ASCII armor format</span></span><br></pre></td></tr></table></figure><p>此时会打印出公钥，我们将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PGP PUBLIC KEY BLOCK-----</span><br><span class="line">-----END PGP PUBLIC KEY BLOCK-----</span><br></pre></td></tr></table></figure><p>这些数据复制到 GitHub 的个人设置页面：<br><img src="https://s2.loli.net/2023/09/18/zvMgJcqAnRQjYxG.png" alt="image.png"></p><p>此时还没完，如果我们直接提交代码的也不会有 <code>Verified</code> 的标签。</p><p><img src="https://s2.loli.net/2023/09/18/eST5f1Vad4x8Ou7.png" alt="image.png"></p><p>我们还需要打开 git 的 config 设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config commit.gpgsign true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局打开</span></span><br><span class="line">git config --global commit.gpgsign true</span><br><span class="line">git commit -S -m &quot;YOUR_COMMIT_MESSAGE&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>这样提交的 Commit 就会打上验证的标签了。<br><img src="https://s2.loli.net/2023/09/18/HKcvrfMozC9YEnx.png" alt="image.png"></p><blockquote><p>-S 的效果和在 idea 中选中 Sign-off 的效果一样。</p></blockquote><p>官方文档也有详细的步骤：<br><a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/about-commit-signature-verification">https://docs.github.com/en/authentication/managing-commit-signature-verification/about-commit-signature-verification</a></p><h1 id="Squash-合并提交"><a href="#Squash-合并提交" class="headerlink" title="Squash 合并提交"></a>Squash 合并提交</h1><p>不过在我这个 <code>PR</code> 的背景下还有一个步骤没有完成，就是我之前提交的 <code>Commit</code> 都没要验证，我需要将他们都合并为一个验证的 Commit 然后在强制推送上去，这样整个 <code>git log</code> 看起来才足够简洁。</p><p>最终效果如下，只有一个 Commit 存在。<br><img src="https://s2.loli.net/2023/09/18/1OzjkDwhdWuJS8n.png"></p><p>这时候就得需要 git rebase 出马了。</p><p><img src="https://s2.loli.net/2023/09/18/vaOPw3gQTtVSoxC.png" alt="image.png"><br>以刚才测试的这两个提交为例，我需要将他们合并为一个提交。</p><p>我们先使用这个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~N</span><br><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure><p>N 就是我们需要合并几个提交，在我这里就是 2.</p><p><img src="https://s2.loli.net/2023/09/18/PN6nUE3BVu48TWF.png" alt="image.png"><br>我们需要将除了第一个 commit 之外的都修改为 s，也就是下面注释里的 <code>squash</code> 的简写（压缩的意思）。</p><p>这是一个 vim 的交互编辑模式，编辑完成之后保存退出。</p><blockquote><p>不会还有程序员不知道如何保存 vim 退出吧🐕。</p></blockquote><p>保存后又会弹出一个编辑页面，让我们填写这次压缩之后的提交记录，默认会帮我生成好，当然你也可以全部删掉后重写。</p><p><img src="https://s2.loli.net/2023/09/18/YCx5ablcrBmsdiD.png" alt="image.png"></p><p>我这里就直接使用它生成好的就可以了，依然还是保存退出。</p><p>最后再强行推送到我所在的分支即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin test-rebase -f</span><br></pre></td></tr></table></figure><p>在这个分支的提交页面也只会看到刚才强行推送的记录了，刚才的两个提交已经合并为这一个了。</p><p><img src="https://s2.loli.net/2023/09/18/ULO3kxgSYErPqle.png" alt="image.png"></p><h1 id="将修改提交到其他分支"><a href="#将修改提交到其他分支" class="headerlink" title="将修改提交到其他分支"></a>将修改提交到其他分支</h1><p>有时候线上出现问题需要马上修复的时候，我会不下意识的直接就开始改了，等真的提交代码被拒的时候才发现是在主分支上。</p><p>我觉得有类似需求的场景还不少，这时候就需要将当前分支的修改提交到一个新的分支上，总不能 revert 之后重新再写吧。</p><p>所以通常我的流程是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个分支</span></span><br><span class="line">git branch newbranch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将当前分支的修改临时保存到暂缓区，同时回滚当前分支。</span></span><br><span class="line">git stash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到新的分支</span></span><br><span class="line">git checkout newbranch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从暂缓区中取出刚才的修改</span></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>这样之前分支的修改就会同步到新的分支上了，借着便在新的分支上继续开发了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>借着这个机会也了解了 <code>rebase</code> 的骚操作挺多的，不过我平时用的最多的还是 <code>merge</code>，这个倒没有好坏之分，只要同组的开发者都达成一致即可。</p><p>#Blog #Github #Git</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/18/gCjw9hZx4Y6cPSn.png&quot; alt=&quot;Github的一个奇技淫巧.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间给 &lt;code&gt;VictoriaLogs&lt;/code&gt; 提交了一个 PR：&lt;br&gt;&lt;a href=&quot;https://github.com/VictoriaMetrics/VictoriaMetrics/pull/4934&quot;&gt;https://github.com/VictoriaMetrics/VictoriaMetrics/pull/4934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本来一切都很顺利，只等合并了，但在临门一脚的时候社区维护人员问我可否给 &lt;code&gt;git&lt;/code&gt; &lt;code&gt;commit&lt;/code&gt; 加上签名。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;于是我就默默的调试到了凌晨四点😭&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/18/VXhjU9ypuKP1ZWg.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="http://crossoverjie.top/categories/git/"/>
    
    
    <category term="rebase" scheme="http://crossoverjie.top/tags/rebase/"/>
    
  </entry>
  
  <entry>
    <title>k8s入门到实战-使用Ingress</title>
    <link href="http://crossoverjie.top/2023/09/15/ob/k8s-Ingress/"/>
    <id>http://crossoverjie.top/2023/09/15/ob/k8s-Ingress/</id>
    <published>2023-09-15T09:13:37.000Z</published>
    <updated>2023-09-24T11:31:04.693Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/14/Pe7DWCIS2UMKHQ8.png" alt="ingress.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前两章中我们将应用<a href="https://crossoverjie.top/2023/08/31/ob/k8s-0-start/">部署</a>到了 k8s 中，同时不同的服务之间也可以通过 <a href="https://crossoverjie.top/2023/09/05/ob/k8s-service/">service</a> 进行调用，现在还有一个步骤就是将我们的应用暴露到公网，并提供域名的访问。</p><p>这一步类似于我们以前配置 Nginx 和绑定域名，提供这个能力的服务在 k8s 中成为 Ingress。</p><p>通过这个描述其实也能看出 Ingress 是偏运维的工作，但也不妨碍我们作为研发去了解这部分的内容；了解整个系统是如何运转的也是研发应该掌握的技能。</p><span id="more"></span><h1 id="安装-Ingress-控制器"><a href="#安装-Ingress-控制器" class="headerlink" title="安装 Ingress 控制器"></a>安装 Ingress 控制器</h1><p>在正式使用 Ingress 之前需要给 k8s 安装一个 Ingress 控制器，我们这里安装官方提供的 Ingress-nginx 控制器。</p><p>当然还有社区或者企业提供的各种控制器：<br><img src="https://s2.loli.net/2023/09/14/i1ebXQNUjxPkLEZ.png" alt="image.png"></p><p>有两种安装方式: helm 或者是直接 apply 一个资源文件。</p><p>关于 <code>helm</code> 我们会在后面的章节单独讲解。</p><p>这里就直接使用资源文件安装即可，我已经上传到 GitHub 可以在这里访问：<br><a href="https://github.com/crossoverJie/k8s-combat/blob/main/deployment/ingress-nginx.yaml">https://github.com/crossoverJie/k8s-combat/blob/main/deployment/ingress-nginx.yaml</a></p><p>其实这个文件也是直接从官方提供的复制过来的，也可以直接使用这个路径进行安装：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/cloud/deploy.yaml</span></span><br></pre></td></tr></table></figure><blockquote><p>yaml 文件的内容是一样的。</p></blockquote><p>不过要注意安装之后可能容器状态一直处于 Pending 状态，查看容器的事件时会发现镜像拉取失败。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k describe pod ingress-nginx-controller-7cdfb9988c-lbcst -n ingress-nginx</span><br></pre></td></tr></table></figure><blockquote><p>describe 是一个用于查看 k8s 对象详细信息的命令。</p></blockquote><p>在刚才那份 yaml 文件中可以看到有几个镜像需要拉取，我们可以先在本地手动拉取镜像：<br><img src="https://s2.loli.net/2023/09/14/3IsRe2QWcmjTY41.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.k8s.io/ingress-nginx/controller:v1.8.2</span><br></pre></td></tr></table></figure><p>如果依然无法拉取，可以尝试配置几个国内镜像源镜像拉取：</p><p><img src="https://s2.loli.net/2023/09/14/uTNDACSWdPp7BVt.png" alt="image.png"></p><blockquote><p>我这里使用的 docker-desktop 自带的 k8s，推荐读者朋友也使用这个工具。</p></blockquote><h1 id="创建-Ingress"><a href="#创建-Ingress" class="headerlink" title="创建 Ingress"></a>创建 Ingress</h1><p>使用刚才的 yaml 安装成功之后会在 <code>ingress-nginx</code> 命名空间下创建一个 Pod，通过 get 命令查看状态为 Running 即为安装成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">k get pod -n ingress-nginx</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS      AGE</span><br><span class="line">ingress-nginx-controller-7cdf   1/1     Running   2 (35h ago)   3d</span><br></pre></td></tr></table></figure><blockquote><p>Namespace 也是 k8s 内置的一个对象，可以简单理解为对资源进行分组管理，我们通常可以使用它来区分各个不同的环境，比如 dev&#x2F;test&#x2F;prod 等，不同命名空间下的资源不会互相干扰，且相互独立。</p></blockquote><p>之后便可以创建 Ingress 资源了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-ingress</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span>  </span><br><span class="line">  <span class="attr">rules:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.service1.io</span>  </span><br><span class="line">      <span class="attr">http:</span>  </span><br><span class="line">        <span class="attr">paths:</span>  </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">backend:</span>  </span><br><span class="line">              <span class="attr">service:</span>  </span><br><span class="line">                <span class="attr">name:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line">                <span class="attr">port:</span>  </span><br><span class="line">                  <span class="attr">number:</span> <span class="number">8081</span>  </span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span>  </span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.service2.io</span>  </span><br><span class="line">      <span class="attr">http:</span>  </span><br><span class="line">        <span class="attr">paths:</span>  </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">backend:</span>  </span><br><span class="line">              <span class="attr">service:</span>  </span><br><span class="line">                <span class="attr">name:</span> <span class="string">k8s-combat-service-2</span>  </span><br><span class="line">                <span class="attr">port:</span>  </span><br><span class="line">                  <span class="attr">number:</span> <span class="number">8081</span>  </span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span>  </span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br></pre></td></tr></table></figure><p>看这个内容也很容易理解，创建了一个 <code>Ingress</code> 的对象，其中的重点就是这里的规则是如何定义的。</p><blockquote><p>在 k8s 中今后还会接触到各种不同的 Kind</p></blockquote><p>这里的 <code>ingressClassName: nginx</code>   也是在刚开始安装的控制器里定义的名字，由这个资源定义。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">IngressClass</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app.kubernetes.io/component:</span> <span class="string">controller</span>  </span><br><span class="line">    <span class="attr">app.kubernetes.io/instance:</span> <span class="string">ingress-nginx</span>  </span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span>  </span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span>  </span><br><span class="line">    <span class="attr">app.kubernetes.io/version:</span> <span class="number">1.8</span><span class="number">.2</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>咱们这个规则很简单，就是将两个不同的域名路由到两个不同的 service。</p><blockquote><p>这里为了方便测试又创建了一个 <code>k8s-combat-service-2</code> 的 service，和 <code>k8s-combat-service</code> 是一样的，只是改了个名字而已。</p></blockquote><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>也是为了方便测试，我在应用镜像中新增了一个接口，用于返回当前 Pod 的 hostname。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">   name, _ := os.Hostname()  </span><br><span class="line">   fmt.Fprint(w, name)  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于我实际并没有 <code>www.service1.io/www.service2.io</code> 这两个域名，所以只能在本地配置 host 进行模拟。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.37 www.service1.io</span><br><span class="line">10.0.0.37 www.service2.io</span><br></pre></td></tr></table></figure><blockquote><p>我测试所使用的 k8s 部署在我家里一台限制的 Mac 上，所以这里的 IP 它的地址。</p></blockquote><p>当我们反复请求两次这个接口，会拿到两个不同的 hostname，也就是将我们的请求轮训负载到了这两个 service 所代理的两个 Pod 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">❯ curl http://www.service1.io/</span><br><span class="line"><span class="meta prompt_">k8s-combat-service-79c5579587-b6nlj%</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">❯ curl http://www.service1.io/</span></span><br><span class="line"><span class="meta prompt_">k8s-combat-service-79c5579587-bk7nw%</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">❯ curl http://www.service2.io/</span></span><br><span class="line"><span class="meta prompt_">k8s-combat-service-2-7bbf56b4d9-dkj9b%</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">❯ curl http://www.service2.io/</span></span><br><span class="line">k8s-combat-service-2-7bbf56b4d9-t5l4g</span><br></pre></td></tr></table></figure><p>我们也可以直接使用 describe 查看我们的 ingress 定义以及路由规则：<br><img src="https://s2.loli.net/2023/09/14/pgZzVb1L4aQTMwn.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">k describe ingress k8s-combat-ingress</span></span><br><span class="line">Name:             k8s-combat-ingress</span><br><span class="line">Labels:           &lt;none&gt;</span><br><span class="line">Namespace:        default</span><br><span class="line">Address:          localhost</span><br><span class="line">Ingress Class:    nginx</span><br><span class="line">Default backend:  &lt;default&gt;</span><br><span class="line">Rules:</span><br><span class="line">  Host             Path  Backends</span><br><span class="line">  ----             ----  --------</span><br><span class="line">  www.service1.io</span><br><span class="line">                   /   k8s-combat-service:8081 (10.1.0.65:8081,10.1.0.67:8081)</span><br><span class="line">  www.service2.io</span><br><span class="line">                   /   k8s-combat-service-2:8081 (10.1.0.63:8081,10.1.0.64:8081)</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure><p>如果我们手动新增一个域名解析：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.37 www.service3.io</span><br><span class="line">❯ curl http://www.service3.io/</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>会直接 404，这是因为没有找到这个域名的规则。</p><h1 id="访问原理"><a href="#访问原理" class="headerlink" title="访问原理"></a>访问原理</h1><p><img src="https://s2.loli.net/2023/09/14/9JTfp6GP24VmzAK.png" alt="image.png"><br>整个的请求路径如上图所示，其实我们的 Ingress 本质上也是一个 service（所以它也可以启动多个副本来进行负载），只是他的类型是 <code>LoadBalancer</code>，通常这种类型的 service 会由云厂商绑定一个外部 IP，这样就可以通过这个外部 IP 访问 Ingress 了。</p><blockquote><p>而我们应用的 service 是 ClusterIP，只能在应用内部访问</p></blockquote><p><img src="https://s2.loli.net/2023/09/14/Bu67SlMLak1hirc.png" alt="image.png"></p><p>通过 service 的信息也可以看到，我们 ingress 的 service 绑定的外部 IP 是 <code>localhost</code>（本地的原因）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Ingress 通常是充当网关的作用，后续我们在使用 Istio 时，也可以使用 Istio 所提供的控制器来替换掉 Ingress-nginx，可以更方便的管理内外网流量。</p><p>本文的所有源码在这里可以访问：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/14/Pe7DWCIS2UMKHQ8.png&quot; alt=&quot;ingress.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前两章中我们将应用&lt;a href=&quot;https://crossoverjie.top/2023/08/31/ob/k8s-0-start/&quot;&gt;部署&lt;/a&gt;到了 k8s 中，同时不同的服务之间也可以通过 &lt;a href=&quot;https://crossoverjie.top/2023/09/05/ob/k8s-service/&quot;&gt;service&lt;/a&gt; 进行调用，现在还有一个步骤就是将我们的应用暴露到公网，并提供域名的访问。&lt;/p&gt;
&lt;p&gt;这一步类似于我们以前配置 Nginx 和绑定域名，提供这个能力的服务在 k8s 中成为 Ingress。&lt;/p&gt;
&lt;p&gt;通过这个描述其实也能看出 Ingress 是偏运维的工作，但也不妨碍我们作为研发去了解这部分的内容；了解整个系统是如何运转的也是研发应该掌握的技能。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/k8s/"/>
    
    
    <category term="Ingress" scheme="http://crossoverjie.top/tags/Ingress/"/>
    
  </entry>
  
  <entry>
    <title>Golang 基础面试题 01</title>
    <link href="http://crossoverjie.top/2023/09/12/ob/Golang-interview-01/"/>
    <id>http://crossoverjie.top/2023/09/12/ob/Golang-interview-01/</id>
    <published>2023-09-12T12:58:03.000Z</published>
    <updated>2023-09-15T18:42:21.149Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/12/xJgnyReWs2mp7Pr.png" alt="Golang 面试题合集.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在之前的文章中分享了 <a href="https://crossoverjie.top/2023/08/17/ob/k8s-question-01/">k8s</a> 相关的面试题，本文我们重点来讨论和 k8s 密切相关的 Go 语言面试题。</p><p>这几年随着云原生的兴起，大部分后端开发者，特别是 Java 开发者都或多或少的想学习一些 Go 相关的技能，所以今天分享的内容比较初级，适合 Go 语言初学者。</p><p><img src="https://s2.loli.net/2023/09/12/oheqNwJt3KvsgDM.png" alt="image.png"></p><p>本文内容依然来自于这个仓库<br><a href="https://github.com/bregman-arie/devops-exercises">https://github.com/bregman-arie/devops-exercises</a></p><span id="more"></span><p>以下是具体内容：</p><blockquote><p>（）的内容是我的补充部分。</p></blockquote><h1 id="Go-101"><a href="#Go-101" class="headerlink" title="Go 101"></a>Go 101</h1><h2 id="Go-语言有哪些特点"><a href="#Go-语言有哪些特点" class="headerlink" title="Go 语言有哪些特点"></a>Go 语言有哪些特点</h2><ul><li>Go 是一种强类型静态语言，变量的类型必须在声明的时候指定（但可以使用类型推导），在运行时不能修改变量类型（与 <code>Python</code> 这类动态类型语言不同）。</li><li>足够的简单，通常一个周末就能学会</li><li>编译速度够快</li><li>内置并发（相对于 Java 的并发来说非常简单）</li><li>内置垃圾收集</li><li>多平台支持</li><li>可以打包到一个二进制文件中，所有运行时需要依赖的库都会被打包进这个二进制文件中，非常适合于分发。</li></ul><h2 id="Go-是一种编译型的静态类型语言，正确还是错误"><a href="#Go-是一种编译型的静态类型语言，正确还是错误" class="headerlink" title="Go 是一种编译型的静态类型语言，正确还是错误"></a>Go 是一种编译型的静态类型语言，正确还是错误</h2><p>正确✅</p><h2 id="为什么有些函数是以大写字母开头的"><a href="#为什么有些函数是以大写字母开头的" class="headerlink" title="为什么有些函数是以大写字母开头的"></a>为什么有些函数是以大写字母开头的</h2><p>这是因为 Go 语言中首字母大写的函数和变量是可以导出的，也就是可以被其他包所引用；类似于 Java 中的 <code>public</code> 和 <code>private</code> 关键字。</p><h1 id="变量和数据类型"><a href="#变量和数据类型" class="headerlink" title="变量和数据类型"></a>变量和数据类型</h1><h2 id="简洁和常规声明变量方式"><a href="#简洁和常规声明变量方式" class="headerlink" title="简洁和常规声明变量方式"></a>简洁和常规声明变量方式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x := <span class="number">2</span> <span class="comment">// 只能在函数内使用，自动类型推导</span></span><br><span class="line">  <span class="keyword">var</span> y <span class="type">int</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">&quot;x: %v. y: %v&quot;</span>, x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正确✅还是错误❌"><a href="#正确✅还是错误❌" class="headerlink" title="正确✅还是错误❌"></a>正确✅还是错误❌</h2><ul><li>可以重复声明变量❌（强类型语言的特性）</li><li>变量一旦声明，就必须使用✅（避免声明无效变量，增强代码可读性）</li></ul><h2 id="下面这段代码的结果是什么？"><a href="#下面这段代码的结果是什么？" class="headerlink" title="下面这段代码的结果是什么？"></a>下面这段代码的结果是什么？</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> userName</span><br><span class="line">    userName = <span class="string">&quot;user&quot;</span></span><br><span class="line">    fmt.Println(userName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误，变量 <code>userName</code> 没有声明类型；修改为这样是可以的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> userName <span class="type">string</span></span><br><span class="line">    userName = <span class="string">&quot;user&quot;</span></span><br><span class="line">    fmt.Println(userName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="var-x-int-2-and-x-2-这两种声明变量的区别"><a href="#var-x-int-2-and-x-2-这两种声明变量的区别" class="headerlink" title="var x int = 2 and x := 2 这两种声明变量的区别"></a><code>var x int = 2</code> and <code>x := 2</code> 这两种声明变量的区别</h2><p>结果上来说是相等的，但 <code>x := 2</code>  只能在函数体类声明。</p><h2 id="下面这段代码的结果是声明？"><a href="#下面这段代码的结果是声明？" class="headerlink" title="下面这段代码的结果是声明？"></a>下面这段代码的结果是声明？</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">x := <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x = <span class="number">3</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误，<code>x := 2</code>  不能在函数体外使用， <code>x = 3</code> 没有指定类型，除非使用 <code>x := 3</code> 进行类型推导。</p><h2 id="如何使用变量声明块（至少三个变量）"><a href="#如何使用变量声明块（至少三个变量）" class="headerlink" title="如何使用变量声明块（至少三个变量）"></a>如何使用变量声明块（至少三个变量）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  x <span class="type">bool</span>   = <span class="literal">false</span></span><br><span class="line">  y <span class="type">int</span>    = <span class="number">0</span></span><br><span class="line">  z <span class="type">string</span> = <span class="string">&quot;false&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;The type of x: %T. The value of x: %v\n&quot;</span>, x, x)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;The type of y: %T. The value of y: %v\n&quot;</span>, y, y)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;The type of z: %T. The value of z: %v\n&quot;</span>, y, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量块配合 <code>go fmt</code> 格式化之后的代码对齐的非常工整，强迫症的福音。</p><p>Go 的基础面试题也蛮多的，我们先从基础的开始，今后后继续更新相关面试题，难度也会逐渐提高，感兴趣的朋友请持续关注。<br>#GO #面试 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/12/xJgnyReWs2mp7Pr.png&quot; alt=&quot;Golang 面试题合集.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在之前的文章中分享了 &lt;a href=&quot;https://crossoverjie.top/2023/08/17/ob/k8s-question-01/&quot;&gt;k8s&lt;/a&gt; 相关的面试题，本文我们重点来讨论和 k8s 密切相关的 Go 语言面试题。&lt;/p&gt;
&lt;p&gt;这几年随着云原生的兴起，大部分后端开发者，特别是 Java 开发者都或多或少的想学习一些 Go 相关的技能，所以今天分享的内容比较初级，适合 Go 语言初学者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/12/oheqNwJt3KvsgDM.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文内容依然来自于这个仓库&lt;br&gt;&lt;a href=&quot;https://github.com/bregman-arie/devops-exercises&quot;&gt;https://github.com/bregman-arie/devops-exercises&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="http://crossoverjie.top/categories/Golang/"/>
    
    
    <category term="面试" scheme="http://crossoverjie.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>k8s入门到实战--跨服务调用</title>
    <link href="http://crossoverjie.top/2023/09/05/ob/k8s-service/"/>
    <id>http://crossoverjie.top/2023/09/05/ob/k8s-service/</id>
    <published>2023-09-05T13:13:28.000Z</published>
    <updated>2023-09-15T18:42:21.018Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/05/GbZ1vKQNHY32wzD.png" alt="service.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在做传统业务开发的时候，当我们的服务提供方有多个实例时，往往我们需要将对方的服务列表保存在本地，然后采用一定的算法进行调用；当服务提供方的列表变化时还得及时通知调用方。</p><span id="more"></span><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">student:</span>  </span><br><span class="line">   <span class="attr">url:</span>     </span><br><span class="line">   <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span><span class="string">:8081</span>     </span><br><span class="line">   <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.2</span><span class="string">:8081</span></span><br></pre></td></tr></table></figure><p>这样自然是对双方都带来不少的负担，所以后续推出的服务调用框架都会想办法解决这个问题。</p><p>以 <code>spring cloud</code> 为例：<br><img src="https://s2.loli.net/2023/09/06/IW1jaidQ25Xk9u4.png" alt="image.png"></p><p>服务提供方会向一个服务注册中心注册自己的服务（名称、IP等信息），客户端每次调用的时候会向服务注册中心获取一个节点信息，然后发起调用。</p><p>但当我们切换到 <code>k8s</code> 后，这些基础设施都交给了 <code>k8s</code> 处理了，所以 <code>k8s</code> 自然得有一个组件来解决服务注册和调用的问题。</p><p>也就是我们今天重点介绍的 <code>service</code>。</p><h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p>在介绍 <code>service</code> 之前我先调整了源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   http.HandleFunc(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">      name, _ := os.Hostname()  </span><br><span class="line">      log.Printf(<span class="string">&quot;%s ping&quot;</span>, name)  </span><br><span class="line">      fmt.Fprint(w, <span class="string">&quot;pong&quot;</span>)  </span><br><span class="line">   &#125;)  </span><br><span class="line">   http.HandleFunc(<span class="string">&quot;/service&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">      resp, err := http.Get(<span class="string">&quot;http://k8s-combat-service:8081/ping&quot;</span>)  </span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         log.Println(err)  </span><br><span class="line">         fmt.Fprint(w, err)  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">      fmt.Fprint(w, resp.Status)  </span><br><span class="line">   &#125;)  </span><br><span class="line">  </span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, <span class="literal">nil</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增了一个 <code>/service</code> 的接口，这个接口会通过 service 的方式调用服务提供者的服务，然后重新打包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make docker</span><br></pre></td></tr></table></figure><p>同时也新增了一个 <code>deployment-service.yaml</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat-service</span> <span class="comment"># 通过标签选择关联  </span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line">  <span class="attr">template:</span>  </span><br><span class="line">    <span class="attr">metadata:</span>  </span><br><span class="line">      <span class="attr">labels:</span>  </span><br><span class="line">        <span class="attr">app:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line">    <span class="attr">spec:</span>  </span><br><span class="line">      <span class="attr">containers:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line">          <span class="attr">image:</span> <span class="string">crossoverjie/k8s-combat:v1</span>  </span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span>  </span><br><span class="line">          <span class="attr">resources:</span>  </span><br><span class="line">            <span class="attr">limits:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">100Mi</span>  </span><br><span class="line">            <span class="attr">requests:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;0.1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">10Mi</span>  </span><br><span class="line"><span class="meta">---  </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat-service</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat-service</span> <span class="comment"># 通过标签选择关联  </span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span>  </span><br><span class="line">  <span class="attr">ports:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8081</span>        <span class="comment"># 本 Service 的端口  </span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8081</span>  <span class="comment"># 容器端口  </span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">app</span></span><br></pre></td></tr></table></figure><p>使用相同的镜像部署一个新的 deployment，名称为 <code>k8s-combat-service</code>，重点是新增了一个<code>kind: Service</code> 的对象。</p><p>这个就是用于声明 <code>service</code> 的组件，在这个组件中也是使用 <code>selector</code> 标签和 <code>deployment</code> 进行了关联。</p><p>也就是说这个 <code>service</code> 用于服务于名称等于 <code>k8s-combat-service</code> 的 <code>deployment</code>。</p><p>下面的两个端口也很好理解，一个是代理的端口， 另一个是  service 自身提供出去的端口。</p><p>至于 <code>type: ClusterIP</code> 是用于声明不同类型的 <code>service</code>，除此之外的类型还有：</p><ul><li><a href="https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport"><code>NodePort</code></a></li><li><a href="https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer"><code>LoadBalancer</code></a></li><li><a href="https://kubernetes.io/docs/concepts/services-networking/service/#externalname"><code>ExternalName</code></a><br>等类型，默认是 <code>ClusterIP</code>，现在不用纠结这几种类型的作用，后续我们在讲到 <code>Ingress</code> 的时候会具体介绍。</li></ul><h2 id="负载测试"><a href="#负载测试" class="headerlink" title="负载测试"></a>负载测试</h2><p>我们先分别将这两个 <code>deployment</code> 部署好：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k apply -f deployment/deployment.yaml</span><br><span class="line">k apply -f deployment/deployment-service.yaml</span><br><span class="line"></span><br><span class="line">❯ k get pod</span><br><span class="line">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">k8s-combat-7867bfb596-67p5m           1/1     Running   0          3h22m</span><br><span class="line">k8s-combat-service-5b77f59bf7-zpqwt   1/1     Running   0          3h22m</span><br></pre></td></tr></table></figure><p>由于我新增了一个 <code>/service</code> 的接口，用于在 <code>k8s-combat</code> 中通过 <code>service</code> 调用 <code>k8s-combat-service</code> 的接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://k8s-combat-service:8081/ping&quot;</span>)</span><br></pre></td></tr></table></figure><p>其中 <code>k8s-combat-service</code> 服务的域名就是他的服务名称。</p><blockquote><p>如果是跨 namespace 调用时，需要指定一个完整名称，在后续的章节会演示。</p></blockquote><p>我们整个的调用流程如下：<br><img src="https://s2.loli.net/2023/09/06/i12pR3DjC6wnIXQ.png" alt="image.png"></p><p>相信大家也看得出来相对于 <code>spring cloud</code> 这类微服务框架提供的客户端负载方式，<code>service</code> 是一种服务端负载，有点类似于 <code>Nginx</code> 的反向代理。</p><p>为了更直观的验证这个流程，此时我将 <code>k8s-combat-service</code> 的副本数增加到 2：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>只需要再次执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ k apply -f deployment/deployment-service.yaml</span><br><span class="line">deployment.apps/k8s-combat-service configured</span><br><span class="line">service/k8s-combat-service unchanged</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/09/06/ZC8UrjEz6ia1Qgo.png" alt="image.png"></p><blockquote><p>不管我们对 <code>deployment</code> 的做了什么变更，都只需要 <code>apply</code> 这个 <code>yaml</code>  文件即可， k8s 会自动将当前的 <code>deployment</code> 调整为我们预期的状态（比如这里的副本数量增加为 2）；这也就是 <code>k8s</code> 中常说的<strong>声明式 API</strong>。</p></blockquote><p>可以看到此时 <code>k8s-combat-service</code> 的副本数已经变为两个了。<br>如果我们此时查看这个 <code>service</code> 的描述时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ k describe svc k8s-combat-service |grep Endpoints</span><br><span class="line">Endpoints:         192.168.130.133:8081,192.168.130.29:8081</span><br></pre></td></tr></table></figure><p>会发现它已经代理了这两个 <code>Pod</code> 的 IP。</p><p><img src="https://s2.loli.net/2023/09/06/HbjyEcnaeCK6uMJ.png" alt="image.png"><br>此时我进入了 <code>k8s-combat-7867bfb596-67p5m</code> 的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k exec -it k8s-combat-7867bfb596-67p5m bash</span><br><span class="line">curl http://127.0.0.1:8081/service</span><br></pre></td></tr></table></figure><p>并执行两次 <code>/service</code> 接口，发现请求会轮训进入 <code>k8s-combat-service</code> 的代理的 IP 中。</p><p>由于 <code>k8s service</code> 是基于 <code>TCP/UDP</code> 的四层负载，所以在 <code>http1.1</code>  中是可以做到请求级的负载均衡，但如果是类似于 <code>gRPC</code> 这类长链接就无法做到请求级的负载均衡。</p><p>换句话说 <code>service</code> 只支持连接级别的负载。</p><p>如果要支持 <code>gRPC</code>，就得使用 Istio 这类服务网格，相关内容会在后续章节详解。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说 <code>k8s service</code> 提供了简易的服务注册发现和负载均衡功能，当我们只提供 http 服务时是完全够用的。</p><p>相关的源码和 yaml 资源文件都存在这里：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/05/GbZ1vKQNHY32wzD.png&quot; alt=&quot;service.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在做传统业务开发的时候，当我们的服务提供方有多个实例时，往往我们需要将对方的服务列表保存在本地，然后采用一定的算法进行调用；当服务提供方的列表变化时还得及时通知调用方。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/k8s/"/>
    
    
    <category term="Go" scheme="http://crossoverjie.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>k8s 入门到实战--部署应用到 k8s</title>
    <link href="http://crossoverjie.top/2023/08/31/ob/k8s-0-start/"/>
    <id>http://crossoverjie.top/2023/08/31/ob/k8s-0-start/</id>
    <published>2023-08-31T14:42:32.000Z</published>
    <updated>2023-09-15T18:42:21.018Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/04/ymUpcXZrxfNsT91.png" alt="k8s 入门到实战 01.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近这这段时间更新了一些 k8s 相关的博客和视频，也收到了一些反馈；大概分为这几类：</p><ul><li>公司已经经历过服务化改造了，但还未接触过云原生。</li><li>公司部分应用进行了云原生改造，但大部分工作是由基础架构和运维部门推动的，自己只是作为开发并不了解其中的细节，甚至 k8s 也接触不到。</li><li>还处于比较传统的以虚拟机部署的传统运维为主。</li></ul><p>其中以第二种占大多数，虽然公司进行了云原生改造，但似乎和纯业务研发同学来说没有太大关系，自己工作也没有什么变化。</p><p>恰好我之前正好从业务研发的角度转换到了基础架构部门，两个角色我都接触过，也帮助过一些业务研发了解公司的云原生架构；</p><p>为此所以我想系统性的带大家以<strong>研发</strong>的角度对 k8s 进行实践。</p><p>因为 k8s 部分功能其实是偏运维的，对研发来说优先级并不太高；<br>所以我不太会涉及一些 k8s 运维的知识点，比如安装、组件等模块；主要以我们日常开发会使用到的组件讲起。</p><span id="more"></span><h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul><li>部署应用到 k8s</li><li>跨服务调用</li><li>集群外部访问</li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><ul><li>如何使用配置</li><li>服务网格实战</li></ul><h2 id="运维你的应用"><a href="#运维你的应用" class="headerlink" title="运维你的应用"></a>运维你的应用</h2><ul><li>应用探针</li><li>滚动更新与回滚</li><li>优雅采集日志</li><li>应用可观测性<ul><li>指标可视化</li></ul></li></ul><h2 id="k8s-部署常见中间件"><a href="#k8s-部署常见中间件" class="headerlink" title="k8s 部署常见中间件"></a>k8s 部署常见中间件</h2><ul><li>helm 一键部署</li><li>编写 Operator 自动化应用生命周期</li></ul><p><img src="https://s2.loli.net/2023/09/02/BtYcF6jp8u3nzJs.png" alt="image.png"><br>这里我整理了一下目录，每个章节都有博客+视频配合观看，大家可以按照喜好选择。</p><p>因为还涉及到了视频，所以只能争取一周两更，在两个月内全部更新完毕。</p><p>根据我自己的经验，以上内容都掌握的话对 k8s 的掌握会更进一步。</p><h1 id="部署应用到-k8s"><a href="#部署应用到-k8s" class="headerlink" title="部署应用到 k8s"></a>部署应用到 k8s</h1><p>首先从第一章【部署应用到 k8s】开始，我会用 Go 写一个简单的 Web 应用，然后打包为一个 Docker 镜像，之后部署到 k8s 中，并完成其中的接口调用。</p><h2 id="编写应用"><a href="#编写应用" class="headerlink" title="编写应用"></a>编写应用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   http.HandleFunc(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">      log.Println(<span class="string">&quot;ping&quot;</span>)  </span><br><span class="line">      fmt.Fprint(w, <span class="string">&quot;pong&quot;</span>)  </span><br><span class="line">   &#125;)  </span><br><span class="line">  </span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, <span class="literal">nil</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 应用非常简单就是提供了一个 <code>ping</code>  接口，然后返回了一个 <code>pong</code>.</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一阶段：编译 Go 程序  </span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.19</span> AS dependencies  </span><br><span class="line"><span class="keyword">ENV</span> GOPROXY=https://goproxy.cn,direct  </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/app  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> go.mod .  </span></span><br><span class="line"><span class="comment">#COPY ../../go.sum .  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=ssh go mod download  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 第二阶段：构建可执行文件  </span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.19</span> AS builder  </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/app  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .  </span></span><br><span class="line"><span class="comment">#COPY --from=dependencies /go/pkg /go/pkg  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 第三阶段：部署  </span></span><br><span class="line"><span class="keyword">FROM</span> debian:stable-slim  </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y curl  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /go/src/app/k8s-combat /go/bin/k8s-combat  </span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/go/bin:$&#123;PATH&#125;&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 启动 Go 程序  </span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;k8s-combat&quot;</span>]</span></span><br></pre></td></tr></table></figure><p> 之后编写了一个 <code>dockerfile</code> 用于构建 <code>docker</code> 镜像。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">docker:  </span></span><br><span class="line">   @echo <span class="string">&quot;Docker Build...&quot;</span>  </span><br><span class="line">   docker build . -t crossoverjie/k8s-combat:v1 &amp;&amp; docker image push crossoverjie/k8s-combat:v1</span><br></pre></td></tr></table></figure><p>使用 <code>make docker</code>  会在本地构建镜像并上传到 <code>dockerhub</code></p><h2 id="编写-deployment"><a href="#编写-deployment" class="headerlink" title="编写 deployment"></a>编写 deployment</h2><p>下一步便是整个过程中最重要的环节了，也是唯一和 k8s 打交道的地方，那就是编写 deployment。</p><iframe src="//player.bilibili.com/player.html?aid=702346697&bvid=BV1Cm4y1n7yG&cid=1235124452&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>在之前的视频《一分钟了解 k8s》中讲过常见的组件：<br><img src="https://s2.loli.net/2023/09/04/hrOUSVsmP2KkNlC.png" alt="image.png"></p><p>其中我们最常见的就是 deployment，通常用于部署无状态应用；现在还不太需要了解其他的组件，先看看 deployment 如何编写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-combat</span>  </span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span>  </span><br><span class="line">  <span class="attr">selector:</span>  </span><br><span class="line">    <span class="attr">matchLabels:</span>  </span><br><span class="line">      <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">  <span class="attr">template:</span>  </span><br><span class="line">    <span class="attr">metadata:</span>  </span><br><span class="line">      <span class="attr">labels:</span>  </span><br><span class="line">        <span class="attr">app:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">    <span class="attr">spec:</span>  </span><br><span class="line">      <span class="attr">containers:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">k8s-combat</span>  </span><br><span class="line">          <span class="attr">image:</span> <span class="string">crossoverjie/k8s-combat:v1</span>  </span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span>  </span><br><span class="line">          <span class="attr">resources:</span>  </span><br><span class="line">            <span class="attr">limits:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">300Mi</span>  </span><br><span class="line">            <span class="attr">requests:</span>  </span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;0.1&quot;</span>  </span><br><span class="line">              <span class="attr">memory:</span> <span class="string">30Mi</span></span><br></pre></td></tr></table></figure><p>开头两行的 <code>apiVersion</code>  和 <code>kind</code> 可以暂时不要关注，就理解为 deployment 的固定写法即可。</p><p>metadata：顾名思义就是定义元数据的地方，告诉 <code>Pod</code> 我们这个 <code>deployment</code> 叫什么名字，这里定义为：<code>k8s-combat</code></p><p>中间的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-combat</span></span><br></pre></td></tr></table></figure><p>也很容易理解，就是给这个 <code>deployment</code> 打上标签，通常是将这个标签和其他的组件进行关联使用才有意义，不然就只是一个标签而已。</p><blockquote><p>标签是键值对的格式，key, value 都可以自定义。</p></blockquote><p>而这里的  <code>app: k8s-combat</code> 便是和下面的 spec 下的 selector 选择器匹配，表明都使用  <code>app: k8s-combat</code>  进行关联。</p><p>而 template 中所定义的标签也是为了让选择器和 template 中的定义的 Pod 进行关联。</p><blockquote><p>Pod 是 k8s 中相同功能容器的分组，一个 Pod 可以绑定多个容器，这里就只有我们应用容器一个了；后续在讲到 istio 和日志采集时便可以看到其他的容器。</p></blockquote><p>template 中定义的内容就很容易理解了，指定了我们的容器拉取地址，以及所占用的资源(<code>cpu/ memory</code>)。</p><p><code>replicas: 1</code>：表示只部署一个副本，也就是只有一个节点的意思。</p><h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><p>之后我们使用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f deployment/deployment.yaml</span><br></pre></td></tr></table></figure><blockquote><p>生产环境中往往会使用云厂商所提供的 k8s 环境，我们本地可以使用 <a href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a> minikube 来模拟。</p></blockquote><p>就会应用这个 deployment 同时将容器部署到 k8s 中，之后使用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure><blockquote><p> 在后台 k8s 会根据我们填写的资源选择一个合适的节点，将当前这个 Pod 部署过去。</p></blockquote><p> 就会列出我们刚才部署的 Pod:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ kubectl get pod</span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">k8s-combat-57f794c59b-7k58n         1/1     Running   0          17h</span><br></pre></td></tr></table></figure><p>我们使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it k8s-combat-57f794c59b-7k58n  bash</span><br></pre></td></tr></table></figure><p>就会进入我们的容器，这个和使用 docker 类似。</p><p>之后执行 curl 命令便可以访问我们的接口了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-combat-57f794c59b-7k58n:/# curl http://127.0.0.1:8081/ping</span><br><span class="line">pong</span><br><span class="line">root@k8s-combat-57f794c59b-7k58n:/#</span><br></pre></td></tr></table></figure><p>这时候我们再开一个终端执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ kubectl logs -f k8s-combat-57f794c59b-7k58n</span><br><span class="line">2023/09/03 09:28:07 ping</span><br></pre></td></tr></table></figure><p>便可以打印容器中的日志，当然前提是应用的日志是写入到了标准输出中。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是这一章节的主要内容，重点就是将我们应用程序员打包为 docker 镜像后上传到镜像仓库，再配置好 deployment 由 k8s 进行调度运行。</p><p>下一章主要会涉及服务内部的调用，感兴趣的朋友可以先关注起来。</p><p>相关的源码和 yaml 资源文件都存在这里：<br><a href="https://github.com/crossoverJie/k8s-combat">https://github.com/crossoverJie/k8s-combat</a></p><p>#Blog #K8s </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/09/04/ymUpcXZrxfNsT91.png&quot; alt=&quot;k8s 入门到实战 01.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近这这段时间更新了一些 k8s 相关的博客和视频，也收到了一些反馈；大概分为这几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公司已经经历过服务化改造了，但还未接触过云原生。&lt;/li&gt;
&lt;li&gt;公司部分应用进行了云原生改造，但大部分工作是由基础架构和运维部门推动的，自己只是作为开发并不了解其中的细节，甚至 k8s 也接触不到。&lt;/li&gt;
&lt;li&gt;还处于比较传统的以虚拟机部署的传统运维为主。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中以第二种占大多数，虽然公司进行了云原生改造，但似乎和纯业务研发同学来说没有太大关系，自己工作也没有什么变化。&lt;/p&gt;
&lt;p&gt;恰好我之前正好从业务研发的角度转换到了基础架构部门，两个角色我都接触过，也帮助过一些业务研发了解公司的云原生架构；&lt;/p&gt;
&lt;p&gt;为此所以我想系统性的带大家以&lt;strong&gt;研发&lt;/strong&gt;的角度对 k8s 进行实践。&lt;/p&gt;
&lt;p&gt;因为 k8s 部分功能其实是偏运维的，对研发来说优先级并不太高；&lt;br&gt;所以我不太会涉及一些 k8s 运维的知识点，比如安装、组件等模块；主要以我们日常开发会使用到的组件讲起。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://crossoverjie.top/categories/k8s/"/>
    
    
    <category term="Go" scheme="http://crossoverjie.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>使用 SQL 的方式查询消息队列数据以及踩坑指南</title>
    <link href="http://crossoverjie.top/2023/08/30/ob/Pulsar-SQL/"/>
    <id>http://crossoverjie.top/2023/08/30/ob/Pulsar-SQL/</id>
    <published>2023-08-30T01:31:53.000Z</published>
    <updated>2023-09-15T18:42:21.017Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/30/3iz9yqfuSCn18xk.png" alt="Pulsar-sql.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>为了让业务团队可以更好的跟踪自己消息的生产和消费状态，需要一个类似于表格视图的消息列表，用户可以直观的看到发送的消息；同时点击详情后也能查到消息的整个轨迹。</p><blockquote><p> 消息列表<br><img src="https://s2.loli.net/2023/08/02/l9uvSnqAOxfPer7.png" alt="20230802234405.png"></p></blockquote><span id="more"></span><blockquote><p>点击详情后查看轨迹<br><img src="https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png" alt="20230802234058.png"></p></blockquote><h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p>由于 <code>Pulsar</code> 并没有关系型数据库中表的概念，所有的数据都是存储在 <code>Bookkeeper</code> 中，为了模拟使用 SQL 查询的效果 Pulsar 提供了 <code>Presto</code> (现在已经更名为 <code>Trino</code>)的插件。</p><blockquote><p>Trino 是一个分布式的 SQL 查询引擎，它也提供了插件能力，如果我们想通过 SQL 从自定义数据源查询数据时，基于它的 SPI 编写一个插件是很方便的。</p></blockquote><p>这样便可以类似于查询数据库一样查询 <code>Pulsar</code> 数据：<br><img src="https://s2.loli.net/2023/08/30/1YEtorbwaZAXylL.png" alt="image.png"></p><hr><p><img src="https://s2.loli.net/2023/08/30/u6gc3YxvH94ZDPG.png" alt="image.png"><br>Pulsar 插件的运行流程如上图所示：</p><ul><li>启动的时候通过 <code>Pulsar-Admin</code> 接口获取一些元数据，比如 Scheme，topic 分区信息等。</li><li>然后会创建一个只读的 Bookkeeper 客户端，用于获取数据。</li><li>之后根据 SQL 条件过滤数据即可。</li></ul><p>相关代码：<br><img src="https://s2.loli.net/2023/08/30/vr7ED6BYgOsoqxz.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/30/Np2XD7T9cJAwxQC.png" alt="image.png"></p><h1 id="使用-Pulsar-SQL"><a href="#使用-Pulsar-SQL" class="headerlink" title="使用 Pulsar-SQL"></a>使用 Pulsar-SQL</h1><p><img src="https://s2.loli.net/2023/08/30/UBqocsjFvC2yXEe.png" alt="image.png"></p><p>使用起来也很简单，官方提供了两个命令：</p><ul><li>sql-worker: 会启动一个 trino 服务端同时运行了 Pulsar 插件</li><li>sql: 就是一个 SQL 命令行终端。</li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>自己在本地运行的时候自然是没问题，可是一旦想在生产运行，同时如果你的 <code>Pulsar</code> 集群是运行再 <code>k8s</code> 环境中时就会碰到一些问题。</p><h3 id="无法使用现有-Trino-集群"><a href="#无法使用现有-Trino-集群" class="headerlink" title="无法使用现有 Trino 集群"></a>无法使用现有 Trino 集群</h3><p>首先第一个问题是如果生产环境已经有了一个 <code>Trino</code> 集群想要复用的时候就会碰到问题，常规流程是将 <code>Pulsar</code> 的插件复制到 <code>Trino</code> 的 <code>Plugin</code> 目录，然后重启 <code>Trino</code> 后就能使用该插件。</p><p>当然社区也是支持这么做的：<br><img src="https://s2.loli.net/2023/08/30/RqtIvwy5HNsr27M.png" alt="image.png"><br>但是当我将 Pulsar-plugin 复制到 Trino 中运行的时候却失败了，整体的流程可以参考这个 issue：<br><a href="https://github.com/apache/pulsar/discussions/20941">https://github.com/apache/pulsar/discussions/20941</a></p><p>简单来说 <code>Trino</code> 的官方镜像和 <code>pulsar-plugin</code> 并不能兼容，这个问题直接影响到我们是否可以在生产环境使用它。</p><p>但是手动编译出来的 <code>Trino</code> 服务和插件是兼容的，可以直接运行。</p><p><img src="https://s2.loli.net/2023/08/30/MswBlVXi12DICr9.png" alt="image.png"></p><p>因此我只能在本地编译出 Trino 服务端和 <code>pulsar-plugin</code> 然后打包成一个镜像来运行了，当然这样的坏处就是无法利用到我们现有的 <code>Trino</code> 集群，又得重新部署一个了。</p><p><img src="https://s2.loli.net/2023/08/30/vG83bleTf1EcCPp.png" alt="image.png"></p><p>流程也比较麻烦：</p><ul><li>首先是本地编译 <code>Pulsar-SQL</code> 模块</li><li>将生成物复制到当前目录</li><li>执行 <code>make docker</code> 打出 docker 镜像并上传到私服</li><li>再执行 <code>kubectl</code> 将 trino 部署到 <code>k8s</code> 环境中</li></ul><p>整个流程做下来加上和社区的沟通，更加确定这个功能应该是很少有人在生产环境使用的，毕竟第一个坑就很麻烦，更别提后续的问题了😂。</p><h3 id="Presto-插件不支持-AuthToken"><a href="#Presto-插件不支持-AuthToken" class="headerlink" title="Presto 插件不支持 AuthToken"></a>Presto 插件不支持 AuthToken</h3><p>第二个问题也是个深坑，当我把 Trino 部署好查询数据的时候直接抛了一个调用 <code>pulsar-admin</code>  接口连接超时的异常。</p><p>结果排查了半天发现原来是 <code>pulsar-plugin</code> 里没有提供 <code>JWT</code> 的验证方式，而我们的 Pulsar 集群恰好是打开了 <code>JWT</code> 验证的。</p><p>为此我只能先在本地修复了这个问题，同时也提交了 PR，预计会在下一个大版本合并吧：<br><a href="https://github.com/apache/pulsar/pull/20860">https://github.com/apache/pulsar/pull/20860</a></p><h3 id="新创建的-topic-查询失败"><a href="#新创建的-topic-查询失败" class="headerlink" title="新创建的 topic 查询失败"></a>新创建的 topic 查询失败</h3><p>第二个问题是当查询一个新创建的 topic 时，客户端会直接 block，相关的复现流程在这里：<br><a href="https://github.com/apache/pulsar/issues/20910">https://github.com/apache/pulsar/issues/20910</a></p><p><img src="https://s2.loli.net/2023/08/30/nYestcQqRax1NVv.png" alt="image.png"></p><p>这个问题还好，不是很致命，是我在本地测试的时候无意间发现的。</p><p>本地我已经修复了，后面也提交了一个 PR，目前还在讨论中：<br><a href="https://github.com/apache/pulsar/pull/20911">https://github.com/apache/pulsar/pull/20911</a></p><h3 id="查询消息会丢失最后一条"><a href="#查询消息会丢失最后一条" class="headerlink" title="查询消息会丢失最后一条"></a>查询消息会丢失最后一条</h3><p>这个问题也不是很严重，数据量少的时候会发现，就是在指定了消息发送时间的查询条件时，最后一条消息会被过滤掉，相关 issue 在这里：<br><a href="https://github.com/apache/pulsar/issues/20919">https://github.com/apache/pulsar/issues/20919</a><br><img src="https://s2.loli.net/2023/08/30/MPamvyduxrTZRkY.png" alt="image.png"><br>这个我只是定位到了原因，但不太清楚 为什么要这么做(-1)，影响也不是很大，就放在这里搁置了。</p><h3 id="Schema-不兼容"><a href="#Schema-不兼容" class="headerlink" title="Schema 不兼容"></a>Schema 不兼容</h3><p>最后发现的一个问题是我们线上某些 topic 查询数据的时候会抛出 <code>Not a record: &quot;string&quot;</code>的异常，但只是部分 topic，也排查了很久，整个源码中没有任何一个地方有这个异常。</p><p><a href="!%5B%5D(https://s2.loli.net/2023/08/30/UBl6OPGzASnfqT2.png)">https://github.com/apache/pulsar/issues/20945</a></p><p><img src="https://s2.loli.net/2023/08/30/UBl6OPGzASnfqT2.png" alt="image.png"></p><p>根本原因是生产者生成的 schema 有问题，类型已经是 JSON 了，但是 schema 却是 string，这样导致 <code>pulsar-plugin</code>  在反序列化 schema 的时候抛出了异常，由于是 pb 反序列化抛出的异常，所以源码中都搜索不到。</p><blockquote><p>没有问题的 topic 使用了正确的 schema</p></blockquote><p>后续我也在本地修复了这个问题，当抛出异常后就将 schema 降级为基本类型进行解析。<br><img src="https://s2.loli.net/2023/08/30/XZfWG2EYHpj5QJb.png" alt="image.png"></p><p>不过本质问题还是客户端使用有误，如果对 <code>schema</code> 理解不准确的话还是建议使用 <code>byte[]</code> 吧，这样至少兼容性不会有问题。<br>相关 PR：<br><a href="https://github.com/apache/pulsar/pull/20955">https://github.com/apache/pulsar/pull/20955</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Pulsar-SQL</code> 是一个非常有用的功能，只是我们使用过程中确实发现了一些问题，大部分都已经修复了；<br>希望对后续使用该功能的朋友有所帮助。<br>#Pulsar </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/30/3iz9yqfuSCn18xk.png&quot; alt=&quot;Pulsar-sql.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;为了让业务团队可以更好的跟踪自己消息的生产和消费状态，需要一个类似于表格视图的消息列表，用户可以直观的看到发送的消息；同时点击详情后也能查到消息的整个轨迹。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 消息列表&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/02/l9uvSnqAOxfPer7.png&quot; alt=&quot;20230802234405.png&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="SQL" scheme="http://crossoverjie.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>VictoriaLogs：一款超低占用的 ElasticSearch 替代方案</title>
    <link href="http://crossoverjie.top/2023/08/23/ob/VictoriaLogs-Intro/"/>
    <id>http://crossoverjie.top/2023/08/23/ob/VictoriaLogs-Intro/</id>
    <published>2023-08-23T07:46:25.000Z</published>
    <updated>2023-09-15T18:42:21.017Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/23/t5soejn8vw1aZil.png" alt="image.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间我们想实现 <code>Pulsar</code> 消息的追踪流程，追踪实现的效果图如下：<br><img src="https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png" alt="image.png"></p><p>实现其实比较简单，其中最重要的就是如何存储消息。</p><blockquote><p>消息的读取我们是通过 Pulsar 自带的 BrokerInterceptor 实现的，对这个感兴趣的朋友后面会单独做一个分享。</p></blockquote><span id="more"></span><p>根据这里的显示内容我们大概需要存储这些信息：</p><ul><li>客户端地址</li><li>消息发布时间</li><li>分发消费者、订阅者名称</li><li>ACK 消费者、订阅者名称</li><li>消息 ID<br>最终捋了下：<br><img src="https://s2.loli.net/2023/08/23/MWbVcu6dm1NfaAB.png" alt="image.png"></li></ul><p>都以两个 <code>consumer</code> 计算：<br>一条消息占用内存：<code>140+ 535*2 + 536*2 =2282byte</code><br>存储三天：<code>TPS * 86400 * 3</code>&#x3D;<code>TPS*259200</code> 条<br>总存储：<br><code>2282*TPS*259200≈ 百GB</code></p><p>根据我们的 <code>TPS</code> 计算，三天的大概会使用到 上百 G 的存储，这样首先就排除了 <code>Redis</code> 这种内存型数据库。</p><p>同样的换成 <code>MySQL</code> 存储也不划算，因为其实这些数据并不算那么重要。</p><p>做了几个技术选型都不太满意，不是资源开销太大就是没有相关的运维经验。</p><p>后面在领导的提醒下，我们使用的 <code>VictoriaMetrics</code> 开源了一个 <code>VictoriaLogs</code>，虽然当时的版本还是 <code>0.1.0</code>，使用过他们家 Metrics 的应该都会比较信任他们的技术能力，所以就调研了一下。</p><p>具体的信息可以查看官方文档：<br><a href="https://docs.victoriametrics.com/VictoriaLogs/">https://docs.victoriametrics.com/VictoriaLogs/</a></p><p><img src="https://s2.loli.net/2023/08/23/8LDNOGEC6Aslvzn.png" alt="image.png"></p><p>简单来说就是它也是一个日志存储数据库，并且有着极低的资源占有率，相对于 <code>ElasticSearch</code> 来说内存、磁盘、CPU 都是几十倍的下降率。</p><p><img src="https://s2.loli.net/2023/08/23/U9v1HCgRDtLsdif.png" alt="image.png"></p><p>通过官方的压测对比图会发现确实在各方面对 ES 都是碾压。<br><img src="https://s2.loli.net/2023/08/23/3Epxdzie8q5tVmY.png" alt="image.png"></p><p>官方宣传的第一反应是不能全信，于是我自己压测了一下，果然 CPU 内存 磁盘的占用都是极低的。</p><blockquote><p> 同时也发现运维部署确实简单，直接一个 helm install 就搞定，就是一个二进制文件，不会依赖第二个组件。</p></blockquote><p>按照刚才同样的数据存储三天，只需要不到 6G 的磁盘空间，我们生产环境已经平稳运行一段时间了。<br><img src="https://s2.loli.net/2023/08/23/kzrxA89EeNnQ7Ro.png" alt="image.png"><br>因为我们是批量写入数据的，所以在最高峰 20K 的 <code>TPS</code> 下 <code>CPU</code> 使用不到 0.1 核，内存使用最高 <code>120M</code>，这点确实是对 ES 碾压了。</p><p><img src="https://s2.loli.net/2023/08/23/wn2BduNX63PyYV9.png" alt="image.png"><br>磁盘占用也是非常少。</p><p>这些有点得归功于它有些的压缩、编解码算法，以及 <code>Golang</code>  带来的相对于 <code>Java</code> 的极低资源占用。</p><h1 id="还存在的问题"><a href="#还存在的问题" class="headerlink" title="还存在的问题"></a>还存在的问题</h1><p>如果一切都这么完美的话那 <code>VictoriaLogs</code>  确实也太变态了， 自然他也有一些不太完美的地方。</p><h2 id="分词功能有限"><a href="#分词功能有限" class="headerlink" title="分词功能有限"></a>分词功能有限</h2><p>首先第一个是分词功能有限，只能做简单的搜索，无法做到类似于 ES 的各种分词，插件当然也别想了。</p><h2 id="不支持集群"><a href="#不支持集群" class="headerlink" title="不支持集群"></a>不支持集群</h2><p>当前版本不支持集群部署，也就是无法横向扩展了；不过幸好他的的单机性能已经非常强了。</p><p>这也是目前阶段部署简单的原因。</p><h2 id="过期时间无法混用"><a href="#过期时间无法混用" class="headerlink" title="过期时间无法混用"></a>过期时间无法混用</h2><p><code>VictoriaLogs</code> 支持为数据配置过期时间自动删除，有点类似于 Redis，它会在后台启动一个协程定期判断数据是否过期，但只能对所有数据统一设置。</p><p>比如我想在 <code>VictoriaLogs</code> 中存放两种不同类型的数据，同时他们的过期删除时间也不相同；比如一个是三天删除，一个是三月后删除。</p><p>这样的需求目前是无法实现的，只能部署两个 <code>VictoriaLogs</code>.</p><h2 id="默认无法查询所有字段"><a href="#默认无法查询所有字段" class="headerlink" title="默认无法查询所有字段"></a>默认无法查询所有字段</h2><p><img src="https://s2.loli.net/2023/08/24/2Wk6VUXQoEYvZJ1.png" alt="image.png"></p><p>由于 <code>VictoriaLogs</code>  可以存储非结构化数据，默认情况下只能查询内置的三个字段，我们自定义的字段目前没法自动查询，需要我们手动指定。</p><p>这个倒不是致命问题，只是使用起来稍微麻烦一些；社区也有一些反馈，相信不久就会优化该功能。<br><img src="https://s2.loli.net/2023/08/24/XYxz8tTDmw6arf9.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/24/pgQCPsLvXfMc7nF.png" alt="image.png"></p><ul><li><a href="https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4780">https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4780</a></li><li><a href="https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4513">https://github.com/VictoriaMetrics/VictoriaMetrics/issues/4513</a></li></ul><h2 id="没有官方-SDK"><a href="#没有官方-SDK" class="headerlink" title="没有官方 SDK"></a>没有官方 SDK</h2><p><img src="https://s2.loli.net/2023/08/24/bXPKRIy7Ojf1elE.png" alt="image.png"></p><p>这也是个有了更好的一个功能，目前只能根据 REST API 自己编写。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当前我们只用来存储 <code>Pulsar</code> 链路追踪数据，目前看来非常稳定，各方面资源占用极少；所以后续我们会陆续讲一些日志类型的数据迁移过来，比如审计日志啥的。</p><p>之后再逐步完善功能后，甚至可以将所有应用存放在 <code>ElasticSeach</code> 中的日志也迁移过来，这样确实能省下不少资源。</p><p>总得来说 <code>VictoriaLogs</code>  资源占用极少，如果只是拿来存储日志相关的数据，没有很强的分词需求那它将非常合适。</p><p>截止到目前最新版也才 <code>0.3.0</code> 还有很大的进步空间，有类似需求的可以持续关注。<br>#Blog #Vlogs #CloudNative </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/23/t5soejn8vw1aZil.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间我们想实现 &lt;code&gt;Pulsar&lt;/code&gt; 消息的追踪流程，追踪实现的效果图如下：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;实现其实比较简单，其中最重要的就是如何存储消息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;消息的读取我们是通过 Pulsar 自带的 BrokerInterceptor 实现的，对这个感兴趣的朋友后面会单独做一个分享。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="VictoriaLogs" scheme="http://crossoverjie.top/categories/VictoriaLogs/"/>
    
    
    <category term="CloudNative" scheme="http://crossoverjie.top/tags/CloudNative/"/>
    
  </entry>
  
  <entry>
    <title>k8s 常见面试题 01</title>
    <link href="http://crossoverjie.top/2023/08/17/ob/k8s-question-01/"/>
    <id>http://crossoverjie.top/2023/08/17/ob/k8s-question-01/</id>
    <published>2023-08-17T14:33:43.000Z</published>
    <updated>2023-09-15T18:42:21.018Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/17/hnWciw54ml6oPdg.jpg"></p><p>前段时间在这个视频中分享了 <a href="https://github.com/bregman-arie/devops-exercises">https://github.com/bregman-arie/devops-exercises</a> 这个知识仓库。</p><iframe src="//player.bilibili.com/player.html?aid=532004472&bvid=BV1Wu411n7U7&cid=1227759877&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>这次继续分享里面的内容，本次主要以 k8s 相关的问题为主。</p><span id="more"></span><h2 id="k8s-是什么，为什么企业选择使用它"><a href="#k8s-是什么，为什么企业选择使用它" class="headerlink" title="k8s 是什么，为什么企业选择使用它"></a>k8s 是什么，为什么企业选择使用它</h2><p>k8s 是一个开源应用，给用户提供了管理、部署、扩展容器的能力，以下几个例子更容易理解：</p><ul><li>你可以将容器运行在不同的机器或节点中，并且可以将一些变化同步给这些容器，简单来说我们只需要编写 <code>yaml</code> 文件，告诉 <code>k8s</code> 我的预期是什么，其中同步变化的过程全部都交给 k8s 去完成。<blockquote><p>其实就是我们常说的声明式 API</p></blockquote></li><li>第二个特点刚才已经提到了，它可以帮我们一键管理多个容器，同步所有的变更。</li><li>可以根据当前的负载调整应用的副本数，负载高就新创建几个应用实例，低就降低几个，这个可以手动或自动完成。</li></ul><h2 id="什么时候使用或者不使用-k8s"><a href="#什么时候使用或者不使用-k8s" class="headerlink" title="什么时候使用或者不使用 k8s"></a>什么时候使用或者不使用 k8s</h2><ul><li>如果主要还是使用物理机这种低级别的基础设施的话，不太建议使用 <code>k8s</code>，这种情况通常是比较传统的业务，没有必要使用 <code>k8s</code>。</li><li>第二种情况是如果是小团队，或者容器规模较小时也不建议使用，除非你想使用 k8s 的滚动发布和自扩容能力，<blockquote><p>不过这些功能运维自己写工具也能实现。</p></blockquote></li></ul><h2 id="k8s-有哪些特性"><a href="#k8s-有哪些特性" class="headerlink" title="k8s 有哪些特性"></a>k8s 有哪些特性</h2><ul><li>是自我修复，<code>k8s</code> 对容器有着健康检测，比如使用启动探针、存活探针等，或者是容器 <code>OOM</code> 后也会重启应用尝试修复。</li><li>自带负载均衡，使用 <code>service</code> 可以将流量自动负载到后续 Pod 中，如果 Pod 提供的是 http 服务这个够用了，但如果是 grpc 这样的长链接，就需要使用 istio 这类服务网格，他可以识别出协议类型，从而做到请求级别的负载均衡。</li><li><code>Operator</code> 自动运维能力：k8s 可以根据应用的运行情况自动调整当前集群的 Pod 数量、存储等，拿 <code>Pulsar</code> 举例，当流量激增后自动新增 <code>broker</code>，磁盘不足时自动扩容等。</li><li>滚动更新能力：当我们发版或者是回滚版本的时候，k8s 会等待新的容器启动之后才会将流量切回来，同时逐步停止老的实例。</li><li>水平扩展能力：可以灵活的新增或者是减少副本的数量，当然也可以自动控制。</li><li>数据加密：使用 <code>secret</code> 可以保存一些敏感的配置或者文件。</li></ul><h2 id="k8s-有着哪些对象"><a href="#k8s-有着哪些对象" class="headerlink" title="k8s 有着哪些对象"></a>k8s 有着哪些对象</h2><p>这个就是考察我们对 <code>k8s</code> 是否是熟悉了，常用的有：</p><ul><li>Pod</li><li>Service</li><li>ReplicationController</li><li>DaemonSet</li><li>namespace</li><li>ConfigMap<br>这个其实知道没有太多作用，主要还是得知道在不同场景如何使用不同的组件。</li></ul><h2 id="哪些字段是必须的"><a href="#哪些字段是必须的" class="headerlink" title="哪些字段是必须的"></a>哪些字段是必须的</h2><p>这个问题我也觉得意义不大，只要写过 <code>yaml</code> 就会知道了，<code>metadata, kind, apiVersion</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>  </span><br><span class="line">    <span class="attr">app:</span> <span class="string">app</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app</span></span><br></pre></td></tr></table></figure><h2 id="kubectl-是什么"><a href="#kubectl-是什么" class="headerlink" title="kubectl 是什么"></a>kubectl 是什么</h2><p>其实就是一个 k8s 的 命令行客户端。</p><h2 id="当你部署应用的时候哪些对象用的比较多"><a href="#当你部署应用的时候哪些对象用的比较多" class="headerlink" title="当你部署应用的时候哪些对象用的比较多"></a>当你部署应用的时候哪些对象用的比较多</h2><ul><li>第一个肯定是 <code>deployment</code>，这应该是最常见的部署方式。</li><li><code>service</code>: 可以将流量负载到 Pod 中。</li><li><code>Ingress</code>: 如果需要从集群外访问 Pod 就得需要 <code>Ingress</code> 然后 配合域名访问。</li></ul><h2 id="为什么没有-k-get-containers-这个命令"><a href="#为什么没有-k-get-containers-这个命令" class="headerlink" title="为什么没有 k get containers 这个命令"></a>为什么没有 <code>k get containers</code> 这个命令</h2><p>这个问题主要是看对 <code>Pod</code> 的理解，因为在 <code>k8s</code> 中 <code>Pod</code> 就是最小的单位了，如果想要访问容器可以在 Pod 中访问。</p><p>我们可以加上 <code>-c</code> 参数进入具体的容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it app -c istio-proxy</span><br></pre></td></tr></table></figure><h2 id="你认为使用使用-k8s-的最佳实践是什么"><a href="#你认为使用使用-k8s-的最佳实践是什么" class="headerlink" title="你认为使用使用 k8s 的最佳实践是什么"></a>你认为使用使用 k8s 的最佳实践是什么</h2><p>这个主要是看日常使用时有没有遇到什么坑了：</p><ul><li>第一个就是要验证 <code>yaml</code> 内容是否正确，这个确实很重要，一旦执行错了后果很严重，比如使用 helm 的时候最好岂容 <code>dry-run</code> 和 <code>debug</code>，先看看生成的 <code>yaml</code> 是否是预期想要的。<blockquote><p>helm upgrade app –dry-run –debug</p></blockquote></li><li>第二个限制资源的使用，比如 CPU 和 内存，这个也很重要，如果不设置一旦应用出现 bug 可能导致整个 k8s 集群都受到影响。</li><li>为 Pod，deployment 指定标签，用于分组。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 资源限制</span></span><br><span class="line"><span class="attr">resources:</span>  </span><br><span class="line">  <span class="attr">limits:</span>  </span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">200m</span>  </span><br><span class="line">    <span class="attr">memory:</span> <span class="string">200Mi</span>  </span><br><span class="line">  <span class="attr">requests:</span>  </span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">100m</span>  </span><br><span class="line">    <span class="attr">memory:</span> <span class="string">100Mi</span></span><br></pre></td></tr></table></figure><blockquote><p>参考来源：<a href="https://github.com/bregman-arie/devops-exercises/blob/master/topics/kubernetes/README.md#kubernetes-101">https://github.com/bregman-arie/devops-exercises/blob/master/topics/kubernetes/README.md#kubernetes-101</a></p></blockquote><p>后续部分内容也有出视频版，强烈建议大家关注我的 B 站或者是视频号：<br><img src="https://s2.loli.net/2023/08/17/joO3wpCAEMtY2yW.jpg" alt="image.png"><br><img src="https://s2.loli.net/2023/08/17/2gcNDC4M3x91Sbh.jpg" alt="image.png"></p><p>#Blog #K8s </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/17/hnWciw54ml6oPdg.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;前段时间在这个视频中分享了 &lt;a href=&quot;https://github.com/bregman-arie/devops-exercises&quot;&gt;https://github.com/bregman-arie/devops-exercises&lt;/a&gt; 这个知识仓库。&lt;/p&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=532004472&amp;bvid=BV1Wu411n7U7&amp;cid=1227759877&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;

&lt;p&gt;这次继续分享里面的内容，本次主要以 k8s 相关的问题为主。&lt;/p&gt;</summary>
    
    
    
    <category term="Interview" scheme="http://crossoverjie.top/categories/Interview/"/>
    
    
    <category term="k8s" scheme="http://crossoverjie.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>新手如何快速参与开源项目</title>
    <link href="http://crossoverjie.top/2023/08/05/ob/novice-contribute-open-source/"/>
    <id>http://crossoverjie.top/2023/08/05/ob/novice-contribute-open-source/</id>
    <published>2023-08-05T05:37:58.000Z</published>
    <updated>2023-09-15T18:42:21.019Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/05/5mXrStCDVHNxF7f.png" alt="image.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开源这件事情在软件开发领域一直是一个高频话题，我们工作中不管是使用到的工具还是第三方库都离不开开源的支持。</p><p>近期由于工作的原因，我需要经常和 <code>Apache Pulsar</code> 社区沟通，同时也会将日常碰到的问题反馈给社区，包括一些 <code>bug</code> ，一些我能修的也是顺带就提了一些 <code>PR</code>。</p><span id="more"></span><p>之前或多或少我也参与过其他的开源社区，但和现在的还是有些许的不同：</p><ul><li>以前我更多的是个人开源项目，偶尔也会有其他开发者向我的仓库贡献代码。</li><li>也参与过其他个人作者或者是社区性质的项目，但流程上没有那么正规或者是<code>标准</code>。</li></ul><p>简单来说就是以前就是小打小闹，<code>Pulsar</code> 毕竟是 <code>Apache</code> 社区的顶级项目，参与的整个流程要求也会比较复杂，当然学到的知识也会更多。</p><p><img src="https://s2.loli.net/2023/08/05/uSRKlvh8q4sTpWj.png" alt="image.png"></p><p><img src="https://s2.loli.net/2023/08/05/DJm145yigIhEvwe.png" alt="image.png"><br>这半年时间大大小小提了十几个 PR ，也逐渐捋清楚了一些上手的方法和套路，所以如果你也想参与开源，但苦于不知道如何入门，看完后希望对你有所帮助。</p><h1 id="为什么参与开源"><a href="#为什么参与开源" class="headerlink" title="为什么参与开源"></a>为什么参与开源</h1><p>首先还是来聊聊参与开源的好处，了解之后也许会让你有路转粉。</p><p>首先最明显的一点就是让你对贡献的这个项目更加深入的了解，我们常常都在面试的时候被问到对 XX 框架的熟悉程度，哪怕你在简历里写的天花乱坠也没有是这个项目  <code>Contributor</code> 更具有说服力。</p><p>其次是沟通交流能力也会得到锻炼，开源社区往往都是以 <code>github issue/PR</code>，或者是 <code>Mailing List</code> 的方式沟通交流，这样的沟通方式和我们常用的微信、QQ 这类及时通讯工具有着本质的区别。</p><p>往往需要我们有了冷静的思考加上清晰的描述才会将自己的观点发布出去，这样不自觉的就会养成自己的总结能力，这个能力对于<code>内容创意内容工作者</code>来说非常重要。</p><p>还有一个更明显的好处就是对个人的能力背书，大家常说的 <code>show me the code</code>，而 <code>GitHub</code> 就是最好的方式。</p><p>当你是某个知名开源项目的 <code>Contributor</code> 甚至是 <code>Committer/PMC</code> 就已经足够证明自己的能力了。</p><h1 id="如何参与"><a href="#如何参与" class="headerlink" title="如何参与"></a>如何参与</h1><p>如何参与呢，其实也很简单，不外乎有以下几种方式（由易到难）：</p><ul><li>一些 <code>typo</code> 类的修复。</li><li>回答社区中用户的问题。</li><li>使用过程中遇到 <code>bug</code>，直接反馈，有兴趣的话最好是自己能修复。</li><li>修复现有 <code>issue</code> 列表中未解决的 <code>bug</code>。</li><li>软件不具备自己需要的功能时提交 <code>feature</code> 提案并实现。</li></ul><p>不管是哪种方式我的建议是在准备贡献之前都应该先看看官方提供的贡献指南，通常在官网就能查看。</p><blockquote><p>即便是最简单的修复 typo，因为越是专业的项目每个 PR 的合并都是严谨的，提前了解后可以避免犯一些基本错误从而影响积极性。</p></blockquote><p>这里我以 <code>Pulsar</code> 为例：<br><img src="https://s2.loli.net/2023/08/05/8TGyjSXChsaoPc6.png" alt="image.png"><br>官网有着详细的贡献指南，包括环境搭建、代码约定、<code>PR/git commit</code> 语义等各种规范。</p><p>这里我重点强调 PR 的语义，一个好的 PR 规范更容易引起社区成员的注意，毕竟我们每一次提交都需要 <code>Committer</code> 的同意才能合并。</p><p><img src="https://s2.loli.net/2023/08/05/gfbEBjc4dXVLPtw.png" alt="image.png"><br>还是以 <code>Pulsar</code> 为例，在提交 PR 前一定得先看看这里的规范要求，不然很可能第一步就会吃瘪。</p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><p>下面讲讲贡献过程中可能会碰到的问题。</p><p>在上面讲到的难度排序中将修复个人 issue 排在了其他 issue 之前了，这是因为往往对自己提交的 bug 更熟悉，而社区其他人反馈的问题大概率会被老手认领。</p><p>加上自己也不熟悉，可能在自己研究复现的过程中就把自己劝退了。</p><h3 id="认领-issue"><a href="#认领-issue" class="headerlink" title="认领 issue"></a>认领 issue</h3><p>这里还有个小技巧，当我们准备修复一个不是自己提交的 issue 时，最好是在评论区让 <code>Committer</code> 将这个任务分配给你，这样社区成员就不会做重复工作了。</p><p><img src="https://s2.loli.net/2023/08/05/KBh1HRd8EyziuQP.png" alt="image.png"><br>类似于这样。</p><p>同时我们在查找可以修复的 <code>issue</code> 时也要注意这个 issue 有没有被认领以及是否有 PR 关联。</p><p><img src="https://s2.loli.net/2023/08/05/pOPybK7lmX1v8oU.png" alt="image.png"></p><p>有时候 <code>issue</code> 并没有被指定但也有相关 <code>PR</code> 在处理该问题了，这时我们就可以过滤掉这个 <code>issue</code>。</p><h3 id="help-want"><a href="#help-want" class="headerlink" title="help want"></a>help want</h3><p><img src="https://s2.loli.net/2023/08/05/QMwDlTWd3iFPU7c.png" alt="image.png"><br>也可以找找带有  <code>help want</code> 标签的 <code>issue</code>，这类问题往往会相对简单，修复起来也更容易。</p><h3 id="社区反馈较慢"><a href="#社区反馈较慢" class="headerlink" title="社区反馈较慢"></a>社区反馈较慢</h3><p>还有一个比较常见的问题是自己提交的 issue 或者是 PR 迟迟没有人处理。</p><p>我们可以先看看这个 issue 对应的代码最近主要是哪些人在维护，这个在 IDE 中配合 <code>GitToolBox</code> 插件就很容易看出来。</p><p><img src="https://s2.loli.net/2023/08/05/ojErZnigXbqFvam.png" alt="image.png"><br>后面的 ID 往往是 <code>PR</code> 号，我们可以通过这个 <code>PR</code> 找到对应的作者，然后尝试在 <code>issue</code> 评论区艾特对方。</p><p>如果依然没有回复，那我们也可以给开发组发送邮件。<br><img src="https://s2.loli.net/2023/08/05/SuT5Fb4wG2BnrV1.png" alt="image.png"><br>如果还是没有回复，比如我这个😂</p><p>那也还有一个办法，就是尝试在社交媒体（GitHub 首页、技术群）上找到 Committer 的微信，直接私聊的方式让对方帮忙推进。<br><img src="https://s2.loli.net/2023/08/05/J8r6lBbhMgziFGv.png" alt="image.png"></p><p>当然也有一些项目长期没有维护了，这种 PR 要做好心里准备，很有可能对方不会理你；这点在国内某个企业的开源项目中比较常见。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说想要做好开源得有耐心和长期坚持，同时给自己带来的好处也是物超所值的，<code>Apache</code> 这类专业的社区我也才参与了半年，后续也会长期坚持下去，也希望哪天可以积累到成为 <code>Committer</code> 后再和大家分享。</p><p>#Pulsar #OpenSource</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/05/5mXrStCDVHNxF7f.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;开源这件事情在软件开发领域一直是一个高频话题，我们工作中不管是使用到的工具还是第三方库都离不开开源的支持。&lt;/p&gt;
&lt;p&gt;近期由于工作的原因，我需要经常和 &lt;code&gt;Apache Pulsar&lt;/code&gt; 社区沟通，同时也会将日常碰到的问题反馈给社区，包括一些 &lt;code&gt;bug&lt;/code&gt; ，一些我能修的也是顺带就提了一些 &lt;code&gt;PR&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenSource" scheme="http://crossoverjie.top/categories/OpenSource/"/>
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>从 Pulsar Client 的原理到它的监控面板</title>
    <link href="http://crossoverjie.top/2023/08/03/ob/Pulsar-Client/"/>
    <id>http://crossoverjie.top/2023/08/03/ob/Pulsar-Client/</id>
    <published>2023-08-03T03:47:52.000Z</published>
    <updated>2023-09-15T18:42:21.017Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/02/GipDPSlbycQxqFd.png" alt="image.png"></p><p>#Blog #Pulsar </p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间业务团队偶尔会碰到一些 Pulsar 使用的问题，比如消息阻塞不消费了、生产者消息发送缓慢等各种问题。</p><p>虽然我们有个监控页面可以根据 topic 维度查看他的发送状态，比如速率、流量、消费状态等信息。</p><span id="more"></span><p><img src="https://s2.loli.net/2023/08/02/UNZVawH4QYSu3Ko.png" alt="image.png"></p><p>但也有几个问题：</p><ul><li>无法在应用维度查看他所依赖的所有  topic 的各种状态。</li><li>监控的信息还不够，比如发送&#x2F;消费延迟、发送&#x2F;消费失败等数据。</li></ul><p>总之就是缺少一个全局的监控视角，通过这些指标可以很方便的分析出当时的运行情况。</p><p>基于这个需求经过一段时间的折腾，现在已经上线使用几个月，目前比较稳定，效果图如下：<br><img src="https://s2.loli.net/2023/08/02/byv4RDZnruSjo9h.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/TtufOpwHB86PFhK.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/d21IaNzbFQpnrkA.png" alt="image.png"></p><p>现在就可以在每个应用的监控面板里看到自己使用了哪些 topic，分别的生产消费情况如何。</p><h1 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h1><p>要实现这些功能就得在应用的 <code>metrics</code> 中加入相关的监控信息，但官方的 Java client 是没有暴露出这些指标的。</p><p><img src="https://s2.loli.net/2023/08/02/DlfkQo1Lmt8J7Iq.png" alt="image.png"></p><blockquote><p>但 pulsar-client-go 是自带了这些指标的</p></blockquote><p>由于 <code>SDK</code> 不支持所以只能自己想办法实现了，为此其实有两种实现方案：</p><ul><li>魔改 <code>Java client</code>，在需要监控的地方手动埋点指标。</li><li>由于我们使用了 <code>SkyWalking</code>，所以可以编写插件，以 <code>agent</code> 的方式获取数据、埋点指标。</li></ul><p>不过第一种方案有以下一些问题：</p><ul><li>需要自己维护一个代码分支，还需要定期和官方保持一致，难免会出现代码冲突。</li><li>需要推动业务方进行依赖升级，线上有着几百个应用，推动起来时间太慢。</li></ul><p>第二种方案的好处就不言而喻了：</p><ul><li>升级无感知，只需要在我们的基础镜像中加上插件即可。</li><li>Java client 的版本也更容易统一。</li></ul><h2 id="Client-原理"><a href="#Client-原理" class="headerlink" title="Client 原理"></a>Client 原理</h2><p>但其实不管是哪种方案我们都得熟悉 Java Client 的实现原理，才能知道哪些数据是我们需要重点关注的，可以帮助我们更好的定位问题。</p><p><img src="https://s2.loli.net/2023/08/02/vweWVR8fkJgrSMI.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/S2DNUb768rJRMLm.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/8Byvq4LXtACoIg5.png" alt="image.png"></p><blockquote><p>本文重点不在于此，具体代码就不仔细分析了。</p></blockquote><p>从上图可以看出，如果我们想要监控消费是否存在阻塞的情况，这几个内部队列是需要重点监控的，一旦他们出现堆积，那就会出现消费阻塞。</p><p>其实这些数据都可以通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.apache.pulsar.client.api.ProducerStats</span><br><span class="line">org.apache.pulsar.client.api.ConsumerStats</span><br></pre></td></tr></table></figure><p>这两个接口获取到生产者和消费者的大部分指标，只是这里还有一个小插曲。</p><p>那就是在获取消费者队列大小的时候，获取到的数据一直为空。</p><p>最终经过源码排查，原来是我们大量使用的 <code>messageListener</code> 在获取队列大小时有 bug，导致获取到的数据一直都为 0.</p><p>相关的 issue 和 PR 可以在这两个链接查看，问题原因和修复过程都有具体描述：<br><a href="https://github.com/apache/pulsar/issues/20076">https://github.com/apache/pulsar/issues/20076</a><br><a href="https://github.com/apache/pulsar/pull/20245">https://github.com/apache/pulsar/pull/20245</a></p><blockquote><p>但这个修复得在新版本才能使用，就导致我们现在的监控页面一直显示为空。</p></blockquote><h1 id="开发-SkyWalking-插件"><a href="#开发-SkyWalking-插件" class="headerlink" title="开发 SkyWalking 插件"></a>开发 SkyWalking 插件</h1><p>然后就是开发一个 <code>SkyWalking</code> 的插件了，其实直接使用 SW 开发插件是上手 <code>Java-Agent</code> 比较快的方式。</p><p><code>SW</code> 的 SDK 封装了许多 <code>agent</code> 原生接口，使得开发起来非常容易；当然缺点也有，就是得集成整个 <code>SW</code> 的 <code>agent</code>。</p><p>这里我简单介绍下这个插件的运行流程：<br><img src="https://s2.loli.net/2023/08/02/tW8QSqdU1yZf25A.png" alt="image.png"></p><ul><li>在创建和删除 consumer 的时候维护 consumerPool</li><li>启动一个定时任务，定期从这些 consumer 中获取指标数据。<br><img src="https://s2.loli.net/2023/08/02/ndhi3yH7CzS9FLA.png" alt="image.png"><br><img src="https://s2.loli.net/2023/08/02/WtZNTClh8Y3wj1F.png" alt="image.png"></li></ul><blockquote><p>当消费多分区 topic 时，为了能唯一标志一个 consumer，所以给每个消费者都加了一个 hashcode 的 label。</p></blockquote><p>因为我们所有的 Java 技术栈都是使用的 <code>Prometheus</code> 的包来生成 <code>metrics</code> ，所以该插件也是使用该包生成的数据。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了兼容一些特殊 Java 应用没有该包时会启动报错，所以在初始化插件的时候需要检测当前 <code>classpath</code> 下是否存在该依赖。</p><p><img src="https://s2.loli.net/2023/08/02/IBwdhH9b1tc8aoE.png" alt="image.png"></p><p>这些功能 SW 已经封装好了，对我们来说也是开箱即用。</p><blockquote><p>其实 SW 插件自己也是支持 metrics 的，由于我们只是使用了它的 trace 功能，所以这里就没有使用它的 API。</p></blockquote><p>关于开发一个 SW 插件的流程也比较简单，可以参考官方文档或者是一些现成的插件源码。<br><a href="https://skywalking.apache.org/docs/skywalking-java/next/en/setup/service-agent/java-agent/java-plugin-development-guide/">https://skywalking.apache.org/docs/skywalking-java/next/en/setup/service-agent/java-agent/java-plugin-development-guide/</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有了这个监控面板后，对于 Pulsar 客户端内部的一些运行情况就不再是黑盒了，还可以基于此做一些报警，比如消费堆积、发送延迟过大等。</p><p>当然仅仅只有这个面板依然是不够的，后续我们又开发了可以通过 <code>messageId</code> 查询它的整个生命周期，包括：</p><ul><li>生产者、消费者信息</li><li>消息生产时间</li><li>推送时间</li><li>ack 时间等</li></ul><p><img src="https://s2.loli.net/2023/08/02/H7pjinzQ5EWR2tF.png" alt="image.png"></p><p>同时借助与 Pulsar-SQL 的能力，还能以列表的形式展示当前 topic 的消息列表。<br><img src="https://s2.loli.net/2023/08/02/l9uvSnqAOxfPer7.png" alt="image.png"><br>当然在实现这两个功能的同时也踩了不少坑，提了几个 PR ，后面在抽时间做具体的分享。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/02/GipDPSlbycQxqFd.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;#Blog #Pulsar &lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间业务团队偶尔会碰到一些 Pulsar 使用的问题，比如消息阻塞不消费了、生产者消息发送缓慢等各种问题。&lt;/p&gt;
&lt;p&gt;虽然我们有个监控页面可以根据 topic 维度查看他的发送状态，比如速率、流量、消费状态等信息。&lt;/p&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="Metrics" scheme="http://crossoverjie.top/tags/Metrics/"/>
    
  </entry>
  
  <entry>
    <title>使用 ChatGPT 碰到的坑</title>
    <link href="http://crossoverjie.top/2023/07/18/ob/ChatGPT-hole/"/>
    <id>http://crossoverjie.top/2023/07/18/ob/ChatGPT-hole/</id>
    <published>2023-07-18T03:47:52.000Z</published>
    <updated>2023-09-15T18:42:21.016Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/07/14/YtqXVJmfNokCwyE.png"></p><p>最近在使用 ChatGPT 的时候碰到一个小坑，因为某些特殊情况我需要使用 <code>syslog</code> 向 <code>logbeat</code> 中发送日志。</p><p>由于这是一个比较古老的协议，确实也没接触过，所以就想着让 ChatGPT 帮我生成个例子。</p><span id="more"></span><p>原本我已经在  Go  中将这个流程跑通，所以其实只需要将代码转换为 Java 就可以了，这个我还是很信任 <code>ChatGPT</code> 的；</p><blockquote><p>现在我挺多结构化数据的转换都交给了 ChatGPT，省去了不少小工具。</p></blockquote><p>于是便有了这段对话：<br><img src="https://s2.loli.net/2023/07/17/6MHlRKOtZ2rJocd.png" alt="image.png"><br><img src="https://s2.loli.net/2023/07/17/SzCGBuiN6AvR7Zo.png" alt="image.png"><br>看起来挺正常的，我那过来改改确实也能用。</p><hr><p>直到快上线的时候，我发现一些元信息丢失了，比如日志生产者的 <code>hostname, PID</code> 等，然而这个信息在 Go 却没有丢失。</p><p>于是我反复调试了之前生成的代码，依然没有找到问题。</p><p>没办法，就只有去翻翻 Go 源码，想看看最终发出去的数据长什么样子，最后看到这样几行代码：<br><img src="https://s2.loli.net/2023/07/17/kJnoR4stKwYvCg8.png"><br><img src="https://s2.loli.net/2023/07/17/tOHvgx2ZzyrAEh9.png" alt="image.png"></p><p>这样一看就很清晰了，只是按照 <code>&lt;%d&gt;%s %s %s[%d]: %s%s</code> 的格式将生成的字符串通过网络发送出去。</p><p>既然这样 Java 代码也很好写了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(hostname,port);</span><br><span class="line">socket.setKeepAlive(<span class="literal">true</span>);</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(os, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> String.format(<span class="string">&quot;&lt;%d&gt;%s %s %s[%d]: %s%s&quot;</span>, <span class="number">6</span> , rfc3164DateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()), <span class="string">&quot;test&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="number">0</span>, message, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">pw.println(format);</span><br></pre></td></tr></table></figure><p>经过测试数据终于对了。</p><p>之后我就在想这么简单的一个问题 Google 上不可能没有吧，于是直接搜索了 <code>Java syslog</code> 关键字，结果直接就有一个现成的库。<br><img src="https://s2.loli.net/2023/07/17/Fm6XBnOdxQ9PAKY.png"></p><p><img src="https://s2.loli.net/2023/07/17/c7PCjmZnboReQtp.png"></p><p>而且实现也是类似的。</p><p>我相信应该有不少朋友也有被 ChatGPT 一本正经的胡说八道误导过，至少在当前的环境下一些简单的东西我还是决定优先 <code>Google</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/07/14/YtqXVJmfNokCwyE.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在使用 ChatGPT 的时候碰到一个小坑，因为某些特殊情况我需要使用 &lt;code&gt;syslog&lt;/code&gt; 向 &lt;code&gt;logbeat&lt;/code&gt; 中发送日志。&lt;/p&gt;
&lt;p&gt;由于这是一个比较古老的协议，确实也没接触过，所以就想着让 ChatGPT 帮我生成个例子。&lt;/p&gt;</summary>
    
    
    
    <category term="ChatGPT" scheme="http://crossoverjie.top/categories/ChatGPT/"/>
    
    
    <category term="Go" scheme="http://crossoverjie.top/tags/Go/"/>
    
    <category term="Syslog" scheme="http://crossoverjie.top/tags/Syslog/"/>
    
  </entry>
  
  <entry>
    <title>Grafana 变量转义处理</title>
    <link href="http://crossoverjie.top/2023/06/26/k8s/grafana-variable/"/>
    <id>http://crossoverjie.top/2023/06/26/k8s/grafana-variable/</id>
    <published>2023-06-26T00:08:08.000Z</published>
    <updated>2023-09-15T18:42:21.015Z</updated>
    
    <content type="html"><![CDATA[<p>Grafana 是一款强大的可视化工具，不止是用于 Prometheus 做数据源，还可以集成数据库、日志等作为数据源整体使用。</p><p>最近我在配置一个监控面板，其中的数据由 Prometheus 和 MySQL 组成；简单来说就是一个指标的查询条件是从数据库中来的。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pulsar_subscription_back_log_no_delayed&#123;topic=~&quot;$topic&quot;,subscription=~&quot;$subscription&quot;&#125;</span><br></pre></td></tr></table></figure><p>其中的 topic 数据是从  MySQL 中来的，其实就是在 Grafana 声明一个变量，从数据库返回了一个列表。</p><p><img src="https://s2.loli.net/2023/06/25/OE37acurFIQjVNH.png"></p><p>因为我们的查询条件是 <code>topic=~&quot;$topic&quot;</code>是正则匹配，所以理论上应该把所有的 <code>topic</code> 关联的数据都查询出来。</p><p><img src="https://s2.loli.net/2023/06/25/WMetKBAvg24hzZk.png"></p><p>但实际情况是任何数据都查不到。</p><p>查看发出去的原始请求后才发现问题出在哪里：</p><p><img src="https://s2.loli.net/2023/06/25/AUXs9lnHoYMQjhO.png"></p><p>原来是选择所有 topic 后 grafana 会~~~~自动对参数转义，这个我查了好多资料包括咨询 ChatGPT 都没有得到解决。</p><p>经过多次测试，发现只要开启多选 grafana 就会自动转义。<br><img src="https://s2.loli.net/2023/06/25/ao51AysPEeiTQNr.png"></p><p>最后我只能想到一个不需要生成多行记录的办法：将所有数据合并成一条记录。</p><p><img src="https://s2.loli.net/2023/06/25/o7Xaf3NKD1rystn.png"></p><p>这样的话就只会生成一条数据，其中包含了所有的 topic，也就避免了被转义。</p><blockquote><p>SQL 中的 CONCAT 函数其实我也不知道怎么使用，还是 ChatGPT 告诉我的。</p></blockquote><p><img src="https://s2.loli.net/2023/06/25/InPYWyiqAL1xRfK.png"></p><p>最后便能完美的查询出数据了。</p><p>有碰到类似问题的朋友可以尝试这个方法，我估计用到这个场景的并不多，不然 ChatGPT 也不会不知道。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Grafana 是一款强大的可视化工具，不止是用于 Prometheus 做数据源，还可以集成数据库、日志等作为数据源整体使用。&lt;/p&gt;
&lt;p&gt;最近我在配置一个监控面板，其中的数据由 Prometheus 和 MySQL 组成；简单来说就是一个指标的查询条件是从数据库中来的。&lt;/p&gt;</summary>
    
    
    
    <category term="cloudnative" scheme="http://crossoverjie.top/categories/cloudnative/"/>
    
    
    <category term="Grafana" scheme="http://crossoverjie.top/tags/Grafana/"/>
    
  </entry>
  
</feed>
