<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverJie&#39;s Blog</title>
  
  <subtitle>baller</subtitle>
  <link href="http://crossoverjie.top/atom.xml" rel="self"/>
  
  <link href="http://crossoverjie.top/"/>
  <updated>2023-05-20T15:22:55.419Z</updated>
  <id>http://crossoverjie.top/</id>
  
  <author>
    <name>crossoverJie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>云原生背景下如何配置 JVM 内存</title>
    <link href="http://crossoverjie.top/2023/05/15/k8s/cloudnative-java/"/>
    <id>http://crossoverjie.top/2023/05/15/k8s/cloudnative-java/</id>
    <published>2023-05-15T00:08:08.000Z</published>
    <updated>2023-05-20T15:22:55.419Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/05/12/IAxSF3oZ1j8GHbi.png" alt="image.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间业务研发反馈说是他的应用内存使用率很高，导致频繁的重启，让我排查下是怎么回事；</p><p>在这之前我也没怎么在意过这个问题，正好这次排查分析的过程做一个记录。</p><span id="more"></span><p>首先我查看了监控面板里的 Pod 监控：<br><img src="https://s2.loli.net/2023/05/14/wyYu8SI7eGprqmQ.png" alt="WeChatWorkScreenshot_ac6f8d80-bdb4-469e-af1a-b2199c9ee288.png"></p><p>发现确实是快满了，而此时去查看应用的 JVM 占用情况却只有30%左右；说明并不是应用内存满了导致 JVM 的 OOM，而是 Pod 的内存满了，导致 Pod 的内存溢出，从而被 k8s 杀掉了。</p><p>而 <code>k8s</code> 为了维持应用的副本数量就得重启一个 Pod，所以看起来就是应用运行一段时间后就被重启。</p><hr><p><img src="https://s2.loli.net/2023/05/14/Lhkjys1TEQUKV86.png" alt="WeChatWorkScreenshot_6213e2f8-c429-4d33-acdd-e639275dd92b.png"><br>而这个应用配置的是 JVM 8G，容器申请的内存是16G，所以 Pod 的内存占用看起来也就 50% 左右。</p><h1 id="容器的原理"><a href="#容器的原理" class="headerlink" title="容器的原理"></a>容器的原理</h1><p>在解决这个问题之前还是先简单了解下容器的运行原理，因为在 k8s 中所有的应用都是运行在容器中的，而容器本质上也是运行在宿主机上的一个个进程而已。</p><p>但我们使用 Docker 的时候会感觉每个容器启动的应用之间互不干扰，从文件系统、网络、CPU、内存这些都能完全隔离开来，就像两个运行在不同的服务器中的应用。</p><p>其实这一点也不是啥黑科技，Linux 早就支持 2.6.x 的版本就已经支持 <code>namespace</code> 隔离了，使用 <code>namespace</code> 可以将两个进程完全隔离。</p><p>仅仅将资源隔离还不够，还需要限制对资源的使用，比如 CPU、内存、磁盘、带宽这些也得做限制；这点也可以使用 <code>cgroups</code> 进行配置。</p><p>它可以限制某个进程的资源，比如宿主机是 4 核 CPU，8G 内存，为了保护其他容器，必须给这个容器配置使用上限：1核 CPU，2G内存。</p><p><img src="https://s2.loli.net/2023/05/14/dzcHK6G8VZQuFC5.png" alt="image.png"></p><p>这张图就很清晰的表示了 <code>namespace</code>  和 <code>cgroups</code> 在容器技术中的作用，简单来说就是：</p><ul><li>namespace 负责隔离</li><li>cgroups 负责限制</li></ul><p>在 k8s 中也有对应的提现：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="number">0.1</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这个资源清单表示该应用至少需要为一个容器分配一个 0.1 核和 1024M 的资源，CPU 的最高上限为 4 个核心。</p><h1 id="不同的OOM"><a href="#不同的OOM" class="headerlink" title="不同的OOM"></a>不同的OOM</h1><p>回到本次的问题，可以确认是容器发生了 OOM 从而导致被 k8s 重启，这也是我们配置 limits 的作用。</p><blockquote><p>k8s 内存溢出导致容器退出会出现 exit code 137 的一个 event 日志。</p></blockquote><p>因为该应用的 JVM 内存配置和容器的配置大小是一样的，都是8GB，但 Java 应用还有一些非 JVM 管理的内存，比如堆外内存之类的，这样很容易就导致容器内存大小超过了限制的 8G 了，也就导致了容器内存溢出。</p><h1 id="云原生背景的优化"><a href="#云原生背景的优化" class="headerlink" title="云原生背景的优化"></a>云原生背景的优化</h1><p>因为这个应用本身使用的内存不多，所以建议将堆内存限制到 4GB，这样就避免了容器内存超限，从而解决了问题。</p><p>当然之后我们也会在应用配置栏里加上建议：推荐 JVM 的配置小于容器限制的 2&#x2F;3，预留一些内存。</p><p>其实本质上还是开发模式没有转变过来，以传统的 Java 应用开发模式甚至都不会去了解容器的内存大小，因为以前大家的应用都是部署在一个内存较大的虚拟机上，所以感知不到容器内存的限制。</p><p>从而误以为将两者画了等号，这一点可能在 Java 应用中尤为明显，毕竟多了一个 JVM；甚至在老版本的 JDK 中如果没有设置堆内存大小，无法感知到容器的内存限制，从而自动生成的 Xmx 大于了容器的内存大小，以致于 OOM。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/05/12/IAxSF3oZ1j8GHbi.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间业务研发反馈说是他的应用内存使用率很高，导致频繁的重启，让我排查下是怎么回事；&lt;/p&gt;
&lt;p&gt;在这之前我也没怎么在意过这个问题，正好这次排查分析的过程做一个记录。&lt;/p&gt;</summary>
    
    
    
    <category term="cloudnative" scheme="http://crossoverjie.top/categories/cloudnative/"/>
    
    
    <category term="Java" scheme="http://crossoverjie.top/tags/Java/"/>
    
    <category term="JVM" scheme="http://crossoverjie.top/tags/JVM/"/>
    
    <category term="K8s" scheme="http://crossoverjie.top/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>从源码彻底理解 Prometheus/VictoriaMetrics 中的 relabel_configs/metric_relabel_configs 配置</title>
    <link href="http://crossoverjie.top/2023/03/13/metrics/relabel_configs_%20metric_relabel_configs/"/>
    <id>http://crossoverjie.top/2023/03/13/metrics/relabel_configs_%20metric_relabel_configs/</id>
    <published>2023-03-13T00:08:08.000Z</published>
    <updated>2023-03-12T10:44:16.552Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/03/11/Xxp5yNTH1ASBk3Z.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近接手维护了公司的指标监控系统，之后踩到坑就没站起来过。。<br><img src="https://s2.loli.net/2023/03/11/UwBJ28ZafziRsQS.png"></p><span id="more"></span><p>本次问题的起因是我们配置了一些指标的删除策略没有生效：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">action:</span> <span class="string">drop_metrics</span></span><br><span class="line">  <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br></pre></td></tr></table></figure><p>与这两个容易引起误解的配置<code>relabel_configs/metric_relabel_configs</code>有关。</p><p>他们都是对抓取的数据进行重命名、过滤、新增、删除等操作，但应用场景却完全不同。</p><blockquote><p>我们使用了 VictoriaMetrics 替换了 Prometheus，VM 完全兼容 Prometheus ，所以本文也对 Prometheus 同样适用。</p></blockquote><h1 id="理解错误1"><a href="#理解错误1" class="headerlink" title="理解错误1"></a>理解错误1</h1><p><img src="https://s2.loli.net/2023/03/12/9oYRlCGTZaNuc5j.png" alt="image.png"><br>但这里其实是有一个错误理解的，我是通过 VM 的服务发现页面的指标响应页面查询指标的，打开之后确实能搜到需要被删除的相关指标。</p><p>但其实即便是真的删除了数据这个页面也会有数据存在，删除的数据只是不会写入 VM 的时序数据库中。</p><blockquote><p>这一点是在后续查源码时才发现；后面我配置对了依然在这里查看数据，发现还是没有删除，这个错误理解浪费了不少时间😂。</p></blockquote><h1 id="理解错误2"><a href="#理解错误2" class="headerlink" title="理解错误2"></a>理解错误2</h1><p>为了解决问题，通过 <code>drop metrics</code> 这类关键字在 VM 的官方文档中查询，最终找到一篇文章。<br><a href="https://www.robustperception.io/dropping-metrics-at-scrape-time-with-prometheus/">https://www.robustperception.io/dropping-metrics-at-scrape-time-with-prometheus/</a><br><img src="https://s2.loli.net/2023/03/12/oRQKnf7u6j3Ulq5.png"></p><p>按照这里的介绍，将删除的配置加入到 <code>metric_relabel_configs</code> 配置下，经过测试确实有效。</p><p>不过为啥将同样的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">drop_metrics</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br></pre></td></tr></table></figure><p>加入到 <code>relabel_configs</code> 未能生效呢？</p><p>估计确实容易令人误导，在文档中也找到了相关的解释：<br><a href="https://www.robustperception.io/relabel_configs-vs-metric_relabel_configs/">https://www.robustperception.io/relabel_configs-vs-metric_relabel_configs&#x2F;</a><br><img src="https://s2.loli.net/2023/03/12/xyaqKjkf85YZzeA.png"><br>这篇文章主要是表达几个重点：</p><ul><li><code>relabel_configs</code> 用于配置哪个目标需要被抓取，发生在指标抓取之前。</li><li><code>metric_relabel_configs</code> 发生在指标抓取之后，写入存储之前。</li><li>如果其中一个没生效，就换一个（这句话很容易让人犯迷糊）</li></ul><p>但说实话当时我看到这里还是一脸懵，为了彻底了解两则的区别还是看源码来的直接。</p><h2 id="阅读源码理解本质原因"><a href="#阅读源码理解本质原因" class="headerlink" title="阅读源码理解本质原因"></a>阅读源码理解本质原因</h2><h3 id="metric-relabel-configs"><a href="#metric-relabel-configs" class="headerlink" title="metric_relabel_configs"></a>metric_relabel_configs</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metric_relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">drop_metrics</span></span><br><span class="line">      <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br></pre></td></tr></table></figure><p>首先看下<code>metric_relabel_configs</code>配置生效的原因。</p><p><img src="https://s2.loli.net/2023/03/12/dWA4a3kzGPIxFEX.png"></p><p><code>metric_relabel_configs</code> 配置的整体流程如上图：</p><ul><li>启动 VM 时加载配置到内存</li><li>根据配置的抓取间隔时间(<code>scrape_interval</code>)抓取数据，拿到的每一条数据都需要通过 <code>metric_relabel_configs</code> 的应用。</li><li>针对于这里的 <code>drop_metrics</code> 来说，就是判断是否需要删除掉所有的 <code>Label</code>。</li><li>如果可以匹配删除，那就不会写入存储。</li></ul><p>其中的关键代码如下：<br><img src="https://s2.loli.net/2023/03/12/ZlIKFDbhLVpx8Om.png"></p><p>这里还有一个小细节，源码里判断的 <code>action</code> 是 <code>drop</code>，而我们配置的是 <code>drop_metrics</code>，其实 <code>drop_metrics</code> 也是 drop 的一个封装而已。</p><p><img src="https://s2.loli.net/2023/03/12/2kQ9rSBsJ3IuAwm.png"><br>在解析配置的时候会进行转换。</p><p>与这个写法是等价的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">source_labels:</span> [ <span class="string">__name__</span> ]</span><br><span class="line">  <span class="attr">regex:</span> <span class="string">&quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</span></span><br><span class="line">  <span class="attr">action:</span> <span class="string">drop</span></span><br></pre></td></tr></table></figure><h3 id="relabel-configs"><a href="#relabel-configs" class="headerlink" title="relabel_configs"></a>relabel_configs</h3><p>然后来看看 <code>relabel_configs</code> 没有按照预期生效的原因。</p><p><img src="https://s2.loli.net/2023/03/12/itlzeXC8DNhpQf4.png"></p><p>其实核心的应用配置就是同一份代码，只是触发点不一样。</p><p><code>relabel_configs</code> 是在应用启动的时候根据我们配置的抓取目标的数据当做数据源，所以这里的 <code>action: drop</code> 删除的是抓取目标，而不是真正的抓取数据。<br><img src="https://s2.loli.net/2023/03/12/qXbwjh5e3uRds4z.png"></p><p>而且它的目的是在应用启动的时候，用于生成抓取目标的任务，<strong>只会运行一次</strong>。</p><p>假设我这里改写为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">relabel_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [ <span class="string">__address__</span> ]</span><br><span class="line">      <span class="attr">regex:</span> <span class="string">&#x27;192.xx.xx.xx:443&#x27;</span></span><br><span class="line">      <span class="attr">action:</span> <span class="string">drop</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/12/SfJnMP547ltQohW.png"><br>那么我这个抓取任务就会被删除掉，而不是删除这个指标了。</p><p>因此之前我在这里配置的是一些业务指标 <code>regex: &quot;^envoy_.*|^url\_\_\_\_.*|istio_request_bytes_sum&quot;</code>，在所有元数据里自然是没有任何一个可以匹配了，所以也就无事发生。</p><blockquote><p>元数据都是以 <code>__</code> 开头。</p></blockquote><hr><p>其实 VM 也有提供一个 Debug 页面用于调试 <code>relabel_configs</code>，但如果知道怎么用这个调试页面其实也理解了他的运行原理😂<br><img src="https://s2.loli.net/2023/03/12/q8KAwpOsBMIEXT3.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://www.robustperception.io/relabelling-can-discard-targets-timeseries-and-alerts/">https://www.robustperception.io/relabelling-can-discard-targets-timeseries-and-alerts/</a> </p><p><img src="https://s2.loli.net/2023/03/12/lJsntMyoCruRYi7.png"><br>后面我查到这篇文章也有相关解释，理解了两者的区别后再看这里的分析会更加容易理解。</p><p>总的来说：</p><ul><li><code>relabel_configs</code> 用于对抓取目标元数据的增删改；如果删除后连后续的抓取任务也会被取消。</li><li><code>metric_relabel_configs</code> 用于对抓取到的数据增删改，对于不需要的业务指标可以在这里配置。</li></ul><p>也就是前文讲到的 <code>relabel_configs</code> 应用于指标抓取前，<code>metric_relabel_configs</code> 应用于指标抓取后。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/03/11/Xxp5yNTH1ASBk3Z.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近接手维护了公司的指标监控系统，之后踩到坑就没站起来过。。&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/03/11/UwBJ28ZafziRsQS.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="metrics" scheme="http://crossoverjie.top/categories/metrics/"/>
    
    
    <category term="K8s" scheme="http://crossoverjie.top/tags/K8s/"/>
    
    <category term="Prometheus" scheme="http://crossoverjie.top/tags/Prometheus/"/>
    
    <category term="VictoriaMetrics" scheme="http://crossoverjie.top/tags/VictoriaMetrics/"/>
    
  </entry>
  
  <entry>
    <title>通过 Pulsar 源码彻底解决重复消费问题</title>
    <link href="http://crossoverjie.top/2023/02/27/pulsar/pulsar-repeat-consume/"/>
    <id>http://crossoverjie.top/2023/02/27/pulsar/pulsar-repeat-consume/</id>
    <published>2023-02-27T00:08:08.000Z</published>
    <updated>2023-02-26T13:42:52.831Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/02/26/Oz94bQasM2Einok.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近真是和 <code>Pulsar</code> 杠上了，业务团队反馈说是线上有个应用消息重复消费。</p><p><img src="https://s2.loli.net/2023/02/26/c2eZuTPUvrlB1YF.png"></p><p>而且在测试环境是可以稳定复现的，根据经验来看一般能稳定复现的都比较好解决。</p><span id="more"></span><h1 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h1><p>接着便是定位问题了，根据之前的经验让业务按照这几种情况先排查一下：<br><img src="https://s2.loli.net/2023/02/26/IrvxGDQuaSt7AOE.png"></p><p>通过排查：1,2可以排除了。</p><ol><li>没有相关日志</li><li>存在异常，但最外层也捕获了，所以不管有无异常都会 ACK。</li></ol><p>第三个也在消费的入口和提交消息出计算了时间，最终发现都是在2s左右 ACK 的。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> client.newConsumer()</span><br><span class="line">        .subscriptionType(SubscriptionType.Shared)</span><br><span class="line">        .enableRetry(<span class="literal">true</span>)</span><br><span class="line">        .topic(topic)</span><br><span class="line">        .ackTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">        .subscriptionName(<span class="string">&quot;my-sub&quot;</span>)</span><br><span class="line">        .messageListener(<span class="keyword">new</span> <span class="title class_">MessageListener</span>&lt;<span class="type">byte</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@SneakyThrows</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">received</span><span class="params">(Consumer&lt;<span class="type">byte</span>[]&gt; consumer, Message&lt;<span class="type">byte</span>[]&gt; msg)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;msg_id&#123;&#125;&quot;</span>,msg.getMessageId().toString());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                consumer.acknowledge(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure><p>那这就很奇怪了，因为代码里配置的 ackTimeout 是 30s，理论上来说是不会存在超时导致消息重发的。</p><p>为了排除是否是超时引起的，直接将业务代码注释掉了，等于是消息收到后立即就 ACK，经过测试发现这样确实就没有重复消费了。</p><p>为了再次确认是不是和 ackTimeout 有关，直接将 <code>.ackTimeout(30, TimeUnit.SECONDS)</code> 注释掉后测试，发现也没有重复消费了。</p><h1 id="确认原因"><a href="#确认原因" class="headerlink" title="确认原因"></a>确认原因</h1><p>既然如此那一定是和这个配置有关了，但看代码确实没有超时，为了定位具体原因只有去看 client 的源码了。</p><p>这里简单梳理下消息的消费的流程：</p><ol><li>根据 <code>.receiverQueueSize(1000)</code> 的配置，默认情况下 broker 会直接给客户端推送 1000 条消息。</li><li>客户端将这 1000 条消息保存到内部队列中。</li><li>如果使用同步消费 <code>receive()</code> 时，本质上就是去 <code>take</code> 这个内部队列。</li><li>如果是使用的是 <code>messageListener</code> 异步消费并配置 <code>ackTimeout</code>，每当从队列里获得一条消息后便会把这条消息加入 <code>UnAckedMessageTracker</code> 内部的一个时间轮中，定时检测顶部是否存在消息，如果存在则会触发重新投递。<br>4.1 加入时间轮后，<code>异步</code>调用我们自定义的事件，这个异步操作是提交到一个无界队列中由单个线程依次排队执行（这点是这次问题的关键）</li><li>业务 ACK 的时候会从时间轮中删除消息，所以如果消息 ACK 的足够快，在第四步就不会获取到消息进行重新投递。</li></ol><p><img src="https://s2.loli.net/2023/02/26/2PuOadlU6oRqHVN.png"></p><p>整体流程如上图，代码细节如下图：<br><img src="https://s2.loli.net/2023/02/26/jMOqBUe912cdEWg.png"></p><p>所以问题的根本原因就是写入时间轮（<code>UnAckedMessageTracker</code>）开始倒计时的线程和回调业务逻辑的不是同一个线程。</p><p>如果业务执行耗时，等到消息从那个单线程的无界队列中取出来的时候很有可能已经过了 ackTimeou 的时间，从而导致了超时重发。</p><p>也就是用户所理解的 <code>ackTimeout</code> 周期（应该进入回调时候开始计时）和 SDK 实现的不一致造成的。</p><p>之后我再次确认同样的代码换为同步消费是没有问题的，不会导致重复消费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> consumer.receive();</span><br><span class="line">            log.info(</span><br><span class="line">                    <span class="string">&quot;consumer Message received: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(msg.getData()) + msg.getMessageId().toString());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            consumer.acknowledge(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看代码后发现同步代码的获取消息和加入 <code>UnAckedMessageTracker</code> 时间轮是同步的，也就不会出现超时的问题。<br><img src="https://s2.loli.net/2023/02/26/AUiDgXYO7QvINTF.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以其实 是<code>messageListener</code> 异步消费的 ackTimeout 的语义是有问题的，需要将加入 <code>UnAckedMessageTracker</code> 处移动到回调函数中同步调用。</p><p>我查看了最新的 <code>2.11.x</code> 版本的代码依然没有修复，正准备提个 PR 切换到 master 时才发现已经有相关的 PR 了，只是还没有发版。</p><p>修复的背景和思路也是类似的，具体参考：</p><p><a href="https://github.com/apache/pulsar/pull/18911">https://github.com/apache/pulsar/pull/18911</a></p><p>其实业务中并不推荐使用 ackTimeout 这个配置了，不好预估时间从而导致超时，而且我相信大部分业务配置好 <code>ackTImeout</code> 后直到后续出问题的时候才想起来要改。<br>所以干脆一开始就不要使用。</p><p>在 go 版本的 SDK 中直接废弃掉了这个参数，推荐使用 nack API 替换。</p><p><img src="https://s2.loli.net/2023/02/26/kQaZAcJi6WjNDXq.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/26/Oz94bQasM2Einok.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近真是和 &lt;code&gt;Pulsar&lt;/code&gt; 杠上了，业务团队反馈说是线上有个应用消息重复消费。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/26/c2eZuTPUvrlB1YF.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;而且在测试环境是可以稳定复现的，根据经验来看一般能稳定复现的都比较好解决。&lt;/p&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="Consumer" scheme="http://crossoverjie.top/tags/Consumer/"/>
    
  </entry>
  
  <entry>
    <title>一个诡异的 Pulsar InterruptedException 异常</title>
    <link href="http://crossoverjie.top/2023/02/23/pulsar/pulsar-interrupted/"/>
    <id>http://crossoverjie.top/2023/02/23/pulsar/pulsar-interrupted/</id>
    <published>2023-02-23T00:08:08.000Z</published>
    <updated>2023-02-22T17:11:31.775Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/02/22/mQaCJMopS1WAjVN.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><img src="https://s2.loli.net/2023/02/22/Lw3UbtiJ1GKyg6x.png"><br>今天收到业务团队反馈线上有个应用往 Pulsar 中发送消息失败了，经过日志查看得知是发送消息时候抛出了 <code>java.lang.InterruptedException</code> 异常。</p><p>和业务沟通后得知是在一个 <code>gRPC</code> 接口中触发的消息发送，大约持续了半个小时的异常后便恢复正常了，这是整个问题的背景。</p><span id="more"></span><h1 id="前置排查"><a href="#前置排查" class="headerlink" title="前置排查"></a>前置排查</h1><p>拿到该问题后首先排查下是否是共性问题，查看了其他的应用没有发现类似的异常；同时也查看了 Pulsar broker 的监控大盘，在这个时间段依然没有波动和异常；</p><p>这样可以初步排除是 Pulsar 服务端的问题。</p><p>接着便是查看应用那段时间的负载情况，从应用 QPS 到 JVM 的各个内存情况依然没发现有什么明显的变化。</p><h1 id="Pulsar-源码排查"><a href="#Pulsar-源码排查" class="headerlink" title="Pulsar 源码排查"></a>Pulsar 源码排查</h1><p>既然看起来应用本身和 Pulsar broker 都没有问题的话那就只能从异常本身来排查了。</p><p>首先第一步要得知具体使用的是 <code>Pulsar-client</code> 是版本是多少，因为业务使用的是内部基于官方 SDK 封装 <code>springboot starter</code> 所以第一步还得排查这个 <code>starter</code> 是否有影响。</p><p>通过查看源码基本排除了 <code>starter</code> 的嫌疑，里面只是简单的封装了 <code>SDK</code> 的功能而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">org.apache.pulsar.client.api.PulsarClientException: java.util.concurrent.ExecutionException: org.apache.pulsar.client.api.PulsarClientException: java.lang.InterruptedException at org.apache.pulsar.client.api.PulsarClientException.unwrap(PulsarClientException.java:<span class="number">1027</span>) at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.send(TypedMessageBuilderImpl.java:<span class="number">91</span>) at </span><br><span class="line">java.base/java.lang.Thread.run(Thread.java:<span class="number">834</span>) Caused by: java.util.concurrent.ExecutionException: org.apache.pulsar.client.api.PulsarClientException: java.lang.InterruptedException at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:<span class="number">395</span>) </span><br><span class="line">at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:<span class="number">1999</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.send(TypedMessageBuilderImpl.java:<span class="number">89</span>) ... <span class="number">49</span> common frames omitted Caused by: org.apache.pulsar.client.api.PulsarClientException: java.lang.InterruptedException </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.canEnqueueRequest(ProducerImpl.java:<span class="number">775</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.sendAsync$original$BWm7PPlZ(ProducerImpl.java:<span class="number">393</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.sendAsync$original$BWm7PPlZ$accessor$i7NYMN6i(ProducerImpl.java) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl$auxiliary$EfuVvJLT.call(Unknown Source) </span><br><span class="line">at org.apache.skywalking.apm.agent.core.plugin.interceptor.enhance.InstMethodsInter.intercept(InstMethodsInter.java:<span class="number">86</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.sendAsync(ProducerImpl.java) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.internalSendAsync(ProducerImpl.java:<span class="number">292</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.internalSendWithTxnAsync(ProducerImpl.java:<span class="number">363</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.PartitionedProducerImpl.internalSendWithTxnAsync(PartitionedProducerImpl.java:<span class="number">191</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.PartitionedProducerImpl.internalSendAsync(PartitionedProducerImpl.java:<span class="number">167</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.sendAsync(TypedMessageBuilderImpl.java:<span class="number">103</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.TypedMessageBuilderImpl.send(TypedMessageBuilderImpl.java:<span class="number">82</span>) ... <span class="number">49</span> common frames omitted Caused by: java.lang.InterruptedException: <span class="literal">null</span></span><br><span class="line">at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">1343</span>) </span><br><span class="line">at java.base/java.util.concurrent.Semaphore.acquire(Semaphore.java:<span class="number">318</span>) </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.canEnqueueRequest(ProducerImpl.java:<span class="number">758</span>)</span><br></pre></td></tr></table></figure><p>接下来便只能是分析堆栈了，因为 Pulsar-client 的部分实现源码是没有直接打包到依赖中的，反编译的话许多代码行数对不上，所以需要将官方的源码拉到本地，切换到对于的分支进行查看。</p><blockquote><p>这一步稍微有点麻烦，首先是代码库还挺大的，加上之前如果没有准备好 Pulsar 的开发环境的话估计会劝退一部分人；但其实大部分问题都是网络造成的，只要配置一些 Maven 镜像多试几次总会编译成功。</p></blockquote><p>我这里直接将分支切换到 <code>branch-2.8</code>。</p><p>从堆栈的顶部开始排查 <code>TypedMessageBuilderImpl.java:91</code>：<br><img src="https://s2.loli.net/2023/02/23/Q53Vm1Fkau9Yn2c.png"><br>看起来是内部异步发送消息的时候抛了异常。</p><p>接着往下看到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException </span><br><span class="line">at org.apache.pulsar.client.impl.ProducerImpl.canEnqueueRequest(ProducerImpl.java:<span class="number">775</span>) at</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/23/LdJspv5CfaRm3EW.png"><br>看起来是这里没错，但是代码行数明显不对；因为 2.8 这个分支也是修复过几个版本，所以中间有修改导致代码行数与最新代码对不上也正常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphore.get().acquire();</span><br></pre></td></tr></table></figure><p>不过初步来看应该是这行代码抛出的线程终端异常，这里看起来只有他最有可能了。</p><p><img src="https://s2.loli.net/2023/02/23/V3mFAuRKzgWnN5T.png"><br>为了确认是否是真的是这行代码，这个文件再往前翻了几个版本最终确认了就是这行代码没错了。</p><p>我们点开<code>java.util.concurrent.Semaphore#acquire()</code>的源码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;has its interrupted status set on entry to this method; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while waiting</span></span><br><span class="line"><span class="comment"> * for a permit,</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread&#x27;s</span></span><br><span class="line"><span class="comment"> * interrupted status is cleared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted() ||</span><br><span class="line">        (tryAcquireShared(arg) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         acquire(<span class="literal">null</span>, arg, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0L</span>) &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>通过源码会发现 <code>acquire()</code> 函数确实会响应中断，一旦检测到当前线程被中断后便会抛出 <code>InterruptedException</code> 异常。</p><h1 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h1><p>所以问题的原因基本确定了，就是在 Pulsar 的发送消息线程被中断了导致的，但为啥会被中断还需要继续排查。</p><p>我们知道线程中断是需要调用 <code>Thread.currentThread().interrupt();</code> API的，首先猜测是否 Pulsar 客户端内部有个线程中断了这个发送线程。</p><p>于是我在 <code>pulsar-client</code> 这个模块中搜索了相关代码：<br><img src="https://s2.loli.net/2023/02/23/w6USaRvMqAIjCfm.png"><br>排除掉和 producer 不相关的地方，其余所有中断线程的代码都是在有了该异常之后继续传递而已；所以初步来看 pulsar-client 内部没有主动中断的操作。</p><p>既然 Pulsar 自己没有做，那就只可能是业务做的了？</p><p>于是我在业务代码中搜索了一下：<br><img src="https://s2.loli.net/2023/02/23/lVzJPf9ZWBGmuti.png"></p><p>果然在业务代码中搜到了唯一一处中断的地方，而且通过调用关系得知这段代码是在消息发送前执行的，并且和 Pulsar 发送函数处于同一线程。</p><p>大概的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).stream().map(e -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    ).collect(Collectors.toList()).forEach(f -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> f.get();</span><br><span class="line">            log.info(<span class="string">&quot;====&quot;</span> + integer);</span><br><span class="line">            <span class="keyword">if</span> (integer==<span class="number">3</span>)&#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="type">MessageId</span> <span class="variable">send</span> <span class="operator">=</span> producer.newMessage().value(msg.getBytes()).send();</span><br></pre></td></tr></table></figure><p>执行这段代码可以完全复现同样的堆栈。</p><p>幸好中断这里还打得有日志：</p><p><img src="https://s2.loli.net/2023/02/23/nHE4WcfaKD8iqSb.png"><br><img src="https://s2.loli.net/2023/02/23/4df5ehMBwj9DyQV.png"></p><p>通过日志搜索发现异常的时间和这个中断的日志时间点完全重合，这样也就知道根本原因了。</p><p>因为业务线程和消息发送线程是同一个，在某些情况下会执行 <code>Thread.currentThread().interrupt();</code>，其实单纯执行这行函数并不会发生什么，只要没有去响应这个中断，也就是 <code>Semaphore</code> 源码中的判断了线程中断的标记：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted() ||</span><br><span class="line">        (tryAcquireShared(arg) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         acquire(<span class="literal">null</span>, arg, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0L</span>) &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但恰好这里业务中断后自己并没有去判断这个标记，导致 Pulsar 内部去判断了，最终抛出了这个异常。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以归根结底还是这里的代码不合理导致的，首先是自己中断了线程但也没使用，从而导致有被其他基础库使用的可能，所以会造成了一些不可预知的后果。</p><p>再一个是不建议在业务代码中使用 <code>Thread.currentThread().interrupt();</code> 这类代码，第一眼根本不知道是要干啥，也不易维护。</p><p>其实本质上线程中断也是线程间通信的一种手段，有这类需求完全可以换为内置的 <code>BlockQueue</code> 这类函数来实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/22/mQaCJMopS1WAjVN.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/22/Lw3UbtiJ1GKyg6x.png&quot;&gt;&lt;br&gt;今天收到业务团队反馈线上有个应用往 Pulsar 中发送消息失败了，经过日志查看得知是发送消息时候抛出了 &lt;code&gt;java.lang.InterruptedException&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;和业务沟通后得知是在一个 &lt;code&gt;gRPC&lt;/code&gt; 接口中触发的消息发送，大约持续了半个小时的异常后便恢复正常了，这是整个问题的背景。&lt;/p&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="InterruptedException" scheme="http://crossoverjie.top/tags/InterruptedException/"/>
    
  </entry>
  
  <entry>
    <title>Istio 升级后踩的坑</title>
    <link href="http://crossoverjie.top/2023/02/20/istio/istio1.12-upgrade-fix/"/>
    <id>http://crossoverjie.top/2023/02/20/istio/istio1.12-upgrade-fix/</id>
    <published>2023-02-20T00:08:08.000Z</published>
    <updated>2023-02-19T13:42:29.744Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/02/19/FwgABGdDrhR4a3j.png"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间我们将 istio 版本升级到 1.12 后导致现有的应用监控有部分数据丢失（页面上显示不出来）。</p><ul><li>一个是应用基础信息丢失。</li><li>再一个是应用 JVM 数据丢失。</li><li>接口维度的监控数据丢失。</li></ul><span id="more"></span><p><img src="https://s2.loli.net/2023/02/19/6eSAIF1Jcjhrp4x.png"></p><hr><p><img src="https://s2.loli.net/2023/02/19/Lyr4cSxVmutjJU6.png"></p><hr><p><img src="https://s2.loli.net/2023/02/19/aPzD9t7L1mGqiJR.png"></p><hr><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p>首先是第一个基础信息丢失的问题，页面上其实显示的是我们的一个聚合指标<code>istio_requests_total:source:rate1m</code>。</p><blockquote><p>聚合后可以将多个指标合并为一个，减少系统压力</p></blockquote><p>具体可以参考 Istio 的最佳实践 <a href="https://istio.io/latest/docs/ops/best-practices/observability/#workload-level-aggregation-via-recording-rules">Observability Best Practices</a> 有详细说明。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">groups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">istio.service.source.istio_requests_total</span></span><br><span class="line">      <span class="attr">rules:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">expr:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            sum(irate(istio_requests_total&#123;reporter=&quot;source&quot;&#125;[1m]))</span></span><br><span class="line"><span class="string">            by (</span></span><br><span class="line"><span class="string">              destination_app,</span></span><br><span class="line"><span class="string">              source_workload_namespace,</span></span><br><span class="line"><span class="string">              response_code,</span></span><br><span class="line"><span class="string">              source_app</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string"></span>          <span class="attr">record:</span> <span class="string">istio_requests_total:source:rate1m</span></span><br></pre></td></tr></table></figure><p>本质上是通过以上四个维度进行统计 <code>istio_requests_total</code>；但在升级之后查看原始数据发现丢失了 <code>destination_app, source_app</code> 这两个 tag。</p><p>至于为啥丢失，查了许久，最后在升级后的资源文件 <code>stats-filter-1.12.yaml</code> 中找到了答案:<br><img src="https://s2.loli.net/2023/02/19/B7a6sH9CYznVGUI.png"><br>升级后新增了 <code>tags_to_remove</code> 标记，将我们所需要的两个 tag 直接删掉了。</p><p>后续在当前 namespace 下重新建一个 <code>EnvoyFilter</code> 资源覆盖掉默认的便能恢复这两个 tag，修复后监控页面也显示正常了。</p><blockquote><p>EnvoyFilter 是实时生效的，并不需要重建应用 Pod。</p></blockquote><h3 id="JVM-监控"><a href="#JVM-监控" class="headerlink" title="JVM 监控"></a>JVM 监控</h3><p><code>JVM</code> 数据丢失的这个应用，直接进入 <code>Pod</code> 查看暴露出的 <code>metric</code>，发现数据都有，一切正常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;Code Cache&quot;,&#125; 1.32126784E8</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;Metaspace&quot;,&#125; 2.74250552E8</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;Compressed Class Space&quot;,&#125; 3.1766024E7</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;G1 Eden Space&quot;,&#125; 1.409286144E9</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;G1 Survivor Space&quot;,&#125; 2.01326592E8</span><br><span class="line">jvm_memory_pool_bytes_used&#123;pool=&quot;G1 Old Gen&quot;,&#125; 2.583691248E9</span><br></pre></td></tr></table></figure><p>说明不是数据源的问题，那就可能是数据采集节点的问题了。</p><p>进入<code>VictoriaMetrics</code> 的 <code>target</code> 页面发现应用确实已经下线，原来是采集的端口不通导致的。</p><blockquote><p>我们使用 VictoriaMetrics 代替了 Prometheus。</p></blockquote><p><img src="https://s2.loli.net/2023/02/19/Hhj6LutlvUsycES.png"></p><p>而这个端口 15020 之前并未使用，我们使用的是另外一个自定义端口和端点来采集数据。</p><p>经过查阅发现 15020 是 istio 默认的端口：<br><img src="https://s2.loli.net/2023/02/19/LjOewSXl5IVPv6q.png"></p><p>原来在默认情况下 Istio 会为所有的数据面 Pod 加上：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">prometheus.io/path:</span> <span class="string">/stats/prometheus</span></span><br><span class="line">    <span class="attr">prometheus.io/port:</span> <span class="string">&quot;15020&quot;</span></span><br></pre></td></tr></table></figure><p>这个注解用于采集数据，由于我们是自定义的端点，所以需要修改默认行为：<br><img src="https://s2.loli.net/2023/02/19/R7v8rG6f2XixlBU.png"></p><p>在控制面将 <code>--set meshConfig.enablePrometheusMerge=false</code> 设置为 false，其实官方文档已经说明，如果不是使用的标准 <code>prometheus.io</code> 注解，需要将这个设置为 false。</p><blockquote><p>修改后需要重建应用 Pod 方能生效。</p></blockquote><p>有了 url 这个 tag 后，接口监控页也恢复了正常。</p><h3 id="接口维度"><a href="#接口维度" class="headerlink" title="接口维度"></a>接口维度</h3><p>接口维度的数据丢失和基本数据丢失的原因类似，本质上也是原始数据中缺少了 url 这个 tag，因为我们所聚合的指标使用了 url：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio.service.source.url.istio_requests_total</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">expr:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        sum(irate(istio_requests_total&#123;reporter=&quot;source&quot;&#125;[1m]))</span></span><br><span class="line"><span class="string">        by (</span></span><br><span class="line"><span class="string">          destination_app,</span></span><br><span class="line"><span class="string">          source_workload_namespace,</span></span><br><span class="line"><span class="string">          response_code,</span></span><br><span class="line"><span class="string">          source_app,</span></span><br><span class="line"><span class="string">          url</span></span><br><span class="line"><span class="string">        )</span></span><br></pre></td></tr></table></figure><p>最终参考了 <a href="https://istio.io/latest/docs/reference/config/proxy_extensions/stats/#MetricConfig">MetricConfig</a> 自定义了 URL 的tag.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;dimensions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;request.url_path&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/19/tERXzV3TI1oe7bJ.png"><br>但这也有个大前提，当我们 tag 的指标没有在默认 tag 列表中时，需要在 Deployment 或者是 Istio 控制面中全局加入我们自定义的 tag 声明。</p><p>比如这里新增了 url 的 tag，那么就需要在控制面中加入：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">meshConfig:</span></span><br><span class="line">  <span class="attr">defaultConfig:</span></span><br><span class="line">    <span class="attr">extraStatTags:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">url</span></span><br></pre></td></tr></table></figure><blockquote><p>修改了控制面后需要重新构建 Pod 后才会生效。</p></blockquote><h2 id="EnvoyFilter的问题"><a href="#EnvoyFilter的问题" class="headerlink" title="EnvoyFilter的问题"></a>EnvoyFilter的问题</h2><p>查看<a href="https://istio.io/latest/docs/reference/config/proxy_extensions/stats/#MetricConfig">MetricConfig</a>的配置后发现是可以直接去掉指标以及去掉指标中的 tag ，这个很有用，能够大大减低指标采集系统 <code>VictoriaMetrics</code> 的系统负载。</p><p>于是参考了官方的示例，去掉了一些 tag，同时还去掉了指标：<code>istio_request_messages_total</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      <span class="attr">&quot;tags_to_remove&quot;:</span> [</span><br><span class="line">        <span class="string">&quot;source_principal&quot;</span>,</span><br><span class="line">        <span class="string">&quot;source_version&quot;</span>,</span><br><span class="line">        <span class="string">&quot;destination_principal&quot;</span>,</span><br><span class="line">        <span class="string">&quot;destination_version&quot;</span>,</span><br><span class="line">        <span class="string">&quot;source_workload&quot;</span>,</span><br><span class="line">        <span class="string">&quot;source_cluster&quot;</span>,</span><br><span class="line">      ]</span><br><span class="line">&#125;<span class="string">,</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;:</span> <span class="string">&quot;istio_request_messages_total&quot;</span>,</span><br><span class="line"><span class="attr">&quot;drop&quot;:</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但并没有生效，于是换成了在 <code>v1.12</code> 中新增的 <code>Telemetry API</code>。</p><h1 id="使用-Telemetry-API"><a href="#使用-Telemetry-API" class="headerlink" title="使用 Telemetry API"></a>使用 Telemetry API</h1><p><img src="https://s2.loli.net/2023/02/19/bN4LiwQZm7rJHXW.png"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">telemetry.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Telemetry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mesh-istio-test</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># no selector specified, applies to all workloads</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">overrides:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">metric:</span> <span class="string">GRPC_REQUEST_MESSAGES</span></span><br><span class="line">            <span class="attr">mode:</span> <span class="string">CLIENT_AND_SERVER</span></span><br><span class="line">          <span class="attr">disabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>但是参考了官方文档后发现依然不能生效，<code>GRPC_REQUEST_MESSAGES</code> 所对应的 <code>istio_request_messages_total</code> 指标依然存在。</p><p>接着在我领导查看 <code>Istio</code> 源码以及相关 <a href="https://github.com/istio/istio/issues/37645">issue</a> 后发现 <code>Telemetry API</code> 和 <code>EnvoyFilter</code> 是不能同时存在的，也就是说会优先使用 <code>EnvoyFilter</code>；这也就是为什么我之前配置没有生效的原因。<br><img src="https://s2.loli.net/2023/02/19/M3uevVscNk5XOTd.png"></p><blockquote><p>后初始化 EnvoyFilter</p></blockquote><p><img src="https://s2.loli.net/2023/02/19/sbkrBdRwULSo9Yg.png"><br>正如这个 issue 中所说，需要删掉现在所有的 EnvoyFilter；删除后果然就生效了。</p><p>新的 <code>Telemetry API</code> 不但语义更加清晰，功能也一样没少，借助他我们依然可以自定义、删除指标、tag 等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">telemetry.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Telemetry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mesh-istio-telemetry-test</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">overrides:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">metric:</span> <span class="string">GRPC_RESPONSE_MESSAGES</span></span><br><span class="line">            <span class="attr">mode:</span> <span class="string">CLIENT_AND_SERVER</span></span><br><span class="line">          <span class="attr">disabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">tagOverrides:</span></span><br><span class="line">            <span class="attr">url:</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;request.url_path&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">metric:</span> <span class="string">ALL_METRICS</span></span><br><span class="line">          <span class="attr">tagOverrides:</span></span><br><span class="line">            <span class="attr">source_workload:</span></span><br><span class="line">              <span class="attr">operation:</span> <span class="string">REMOVE</span></span><br></pre></td></tr></table></figure><p>比如以上配置便可以删除掉 <code>GRPC_RESPONSE_MESSAGES</code> 指标，新增一个 url 的指标，同时在所有指标中删除了 <code>source_workload</code> 这个 tag。</p><p>借助于这一个声明文件便能满足我们多个需求。</p><h2 id="裁剪指标"><a href="#裁剪指标" class="headerlink" title="裁剪指标"></a>裁剪指标</h2><p>后续根据我们实际需求借助于 <code>Telemetry API</code> 裁剪掉了许多指标和 tag，使得指标系统负载下降了一半左右。<br><img src="https://s2.loli.net/2023/02/19/rLqd3lUTgOK9RbS.png"><br>效果相当明显。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次定位修复 <code>Istio</code> 升级后带来的指标系统问题收获巨大，之前对 Istio 一直只停留在理论阶段，只知道他可以实现传统微服务中对接口粒度的控制，完美弥补了 <code>k8s</code> 只有服务层级的粗粒度控制；</p><p>这两周下来对一个现代云原生监控系统也有了系统的认识，从 <code>App-&gt;Pod-&gt;sidecar-&gt;VictoriaMetrics(Prometheus)-&gt;Grafana</code> 这一套流程中每个环节都可能会出错；</p><p>所以学无止境吧，幸好借助公司业务场景后续还有更多机会参与实践。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/19/FwgABGdDrhR4a3j.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间我们将 istio 版本升级到 1.12 后导致现有的应用监控有部分数据丢失（页面上显示不出来）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个是应用基础信息丢失。&lt;/li&gt;
&lt;li&gt;再一个是应用 JVM 数据丢失。&lt;/li&gt;
&lt;li&gt;接口维度的监控数据丢失。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Istio" scheme="http://crossoverjie.top/categories/Istio/"/>
    
    
    <category term="K8s" scheme="http://crossoverjie.top/tags/K8s/"/>
    
    <category term="云原生" scheme="http://crossoverjie.top/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Pulsar负载均衡原理及优化</title>
    <link href="http://crossoverjie.top/2023/02/07/pulsar/pulsar-load-banance/"/>
    <id>http://crossoverjie.top/2023/02/07/pulsar/pulsar-load-banance/</id>
    <published>2023-02-07T00:12:26.000Z</published>
    <updated>2023-02-07T01:38:09.189Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/02/04/d4NqxaoulEXnr5s.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间我们在升级 Pulsar 版本的时候发现升级后最后一个节点始终没有流量。<br><img src="https://s2.loli.net/2023/02/07/ZwQ7sfVhuzb4tyv.jpg"></p><blockquote><p>虽然对业务使用没有任何影响，但负载不均会导致资源的浪费。</p></blockquote><p>和同事沟通后得知之前的升级也会出现这样的情况，最终还是人工调用 Pulsar 的 <code>admin API</code> 完成的负载均衡。</p><p>这个问题我尝试在 Google 和 Pulsar 社区都没有找到类似的，不知道是大家都没碰到还是很少升级集群。</p><blockquote><p>我之前所在的公司就是一个版本走到黑😂</p></blockquote><span id="more"></span><h1 id="Pulsar-负载均衡原理"><a href="#Pulsar-负载均衡原理" class="headerlink" title="Pulsar 负载均衡原理"></a>Pulsar 负载均衡原理</h1><p>当一个集群可以水平扩展后负载均衡就显得非常重要，根本目的是为了让每个提供服务的节点都能均匀的处理请求，不然扩容就没有意义了。</p><p>在分析这个问题的原因之前我们先看看 Pulsar 负载均衡的实现方案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Enable load balancer</span><br><span class="line">loadBalancerEnabled=true</span><br></pre></td></tr></table></figure><p>我们可以通过这个 broker 的这个配置来控制负载均衡器的开关，默认是打开。</p><p>但具体使用哪个实现类来作为负载均衡器也可以在配置文件中指定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Name of load manager to use</span><br><span class="line">loadManagerClassName=org.apache.pulsar.broker.loadbalance.impl.ModularLoadManagerImpl</span><br></pre></td></tr></table></figure><p>默认使用的是 <code>ModularLoadManagerImpl</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> LoadManager <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> PulsarService pulsar)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServiceConfiguration</span> <span class="variable">conf</span> <span class="operator">=</span> pulsar.getConfiguration();</span><br><span class="line">        <span class="comment">// Assume there is a constructor with one argument of PulsarService.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">loadManagerInstance</span> <span class="operator">=</span> Reflections.createInstance(conf.getLoadManagerClassName(),</span><br><span class="line">                Thread.currentThread().getContextClassLoader());</span><br><span class="line">        <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> LoadManager) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> (LoadManager) loadManagerInstance;</span><br><span class="line">            casted.initialize(pulsar);</span><br><span class="line">            <span class="keyword">return</span> casted;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loadManagerInstance <span class="keyword">instanceof</span> ModularLoadManager) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">LoadManager</span> <span class="variable">casted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModularLoadManagerWrapper</span>((ModularLoadManager) loadManagerInstance);</span><br><span class="line">            casted.initialize(pulsar);</span><br><span class="line">            <span class="keyword">return</span> casted;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Error when trying to create load manager: &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If we failed to create a load manager, default to SimpleLoadManagerImpl.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleLoadManagerImpl</span>(pulsar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>broker</code> 启动时会从配置文件中读取配置进行加载，如果加载失败会使用 <code>SimpleLoadManagerImpl</code> 作为兜底策略。</p><p>当 broker 是一个集群时，只有 leader 节点的 broker 才会执行负载均衡器的逻辑。</p><blockquote><p>Leader 选举是通过 Zookeeper 实现的。</p></blockquote><p>默然情况下成为 Leader 节点的 broker 会每分钟读取各个 broker 的数据来判断是否有节点负载过高需要做重平衡。</p><p>而是否重平衡的判断依据是由 <code>org.apache.pulsar.broker.loadbalance.LoadSheddingStrategy</code> 接口提供的，它其实只有一个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadSheddingStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Recommend that all of the returned bundles be unloaded.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A map from all selected bundles to the brokers on which they reside.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Multimap&lt;String, String&gt; <span class="title function_">findBundlesForUnloading</span><span class="params">(LoadData loadData, ServiceConfiguration conf)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据所有 broker 的负载信息计算出一个需要被 unload 的 broker 以及 bundle。</p><p>这里解释下 unload 和 bundle 的概念：</p><ul><li><code>bundle</code> 是一批 <code>topic</code> 的抽象，将 <code>bundle</code> 和 <code>broker</code> 进行关联后客户端才能知道应当连接哪个 broker；而不是直接将 topic 与 <code>broker</code> 绑定，这样才能实现海量 topic 的管理。</li><li>unload 则是将已经与 broker 绑定的 bundle 手动解绑，从而触发负载均衡器选择一台合适的 broker 重新进行绑定；通常是整个集群负载不均的时候触发。</li></ul><h2 id="ThresholdShedder-原理"><a href="#ThresholdShedder-原理" class="headerlink" title="ThresholdShedder 原理"></a>ThresholdShedder 原理</h2><p><code>LoadSheddingStrategy</code> 接口目前有三个实现，这里以官方默认的 <code>ThresholdShedder</code> 为例：<br><img src="https://s2.loli.net/2023/02/07/9xqNPs31RtHOC2u.jpg"></p><p>它的实现算法是根据带宽、内存、流量等各个指标的权重算出每个节点的负载值，之后为整个集群计算出一个平均负载值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 阈值</span><br><span class="line">loadBalancerBrokerThresholdShedderPercentage=10</span><br></pre></td></tr></table></figure><p>当集群中有某个节点的负载值超过平均负载值达到一定程度（可配置的阈值）时，就会触发 unload，以上图为例就会将最左边节点中红色部分的 bundle 卸载掉，然后再重新计算一个合适的 broker 进行绑定。</p><blockquote><p>阈值存在的目的是为了避免频繁的 unload，从而影响客户端的连接。</p></blockquote><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>当某些 topic 的流量突然爆增的时候这种负载策略确实可以处理的很好，但在我们集群升级的情况就不一定了。</p><p>假设我这里有三个节点：</p><ul><li>broker0</li><li>broker1</li><li>broker2</li></ul><p><img src="https://s2.loli.net/2023/02/07/9fpusPqY8BmkGdl.png"><br>集群升级时会从 <code>broker2-&gt;0</code> 进行镜像替换重启，假设在升级前每个 broker 的负载值都是 10。</p><ul><li>重启 broker2 时，它所绑定的 bundle 被 broker0&#x2F;1 接管。</li><li>升级 broker1 时，它所绑定的 bundle 又被 broker0&#x2F;2 接管。</li><li>最后升级 broker0, 它所绑定的 bundle 会被broker1&#x2F;2 接管。</li></ul><p>只要在这之后没有发生流量激增到触发负载的阈值，那么当前的负载情况就会一直保留下去，也就是 <code>broker0</code> 会一直没有流量。</p><p>经过我反复测试，现象也确实如此。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./pulsar-perf monitor-brokers --connect-string pulsar-test-zookeeper:2181</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/07/nDaOlsMprJ1hCwg.png"><br>通过这个工具也可以查看各个节点的负载情况</p><h1 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h1><p>这种场景是当前 <code>ThresholdShedder</code> 所没有考虑到的，于是我在我们所使用的版本 2.10.3 的基础上做了简单的优化：<br><img src="https://s2.loli.net/2023/02/07/iRkm2FaBz4wtbG6.png"></p><ul><li>当原有逻辑走完之后也没有获取需要需要卸载的 bundle，同时也存在一个负载极低的 broker 时(<code>emptyBundle</code>)，再触发一次 bundle 查询。</li><li>按照 broker 所绑定的数量排序，选择一个数量最多的 broker 的 第一个 bundle 进行卸载。</li></ul><p>修改后打包发布，再走一遍升级流程后整个集群负载就是均衡的了。<br><img src="https://s2.loli.net/2023/02/07/oCYzJBj7xavkLub.jpg"></p><p>但其实这个方案并不严谨，第二步选择的重点是筛选出负载最高的集群中负载最高的 bundle；这里只是简单的根据数量来判断，并不够准确。</p><p>正当我准备持续优化时，鬼使神差的我想看看 master 上有人修复这个问题没，结果一看还真有人修复了；只是还没正式发版。</p><p><a href="https://github.com/apache/pulsar/pull/17456">https://github.com/apache/pulsar/pull/17456</a></p><p><img src="https://s2.loli.net/2023/02/07/7TKxPv8BfblngRc.png"></p><p>整体思路是类似的，只是筛选负载需要卸载 bundle 时是根据 bundle 自身的流量来的，这样会更加精准。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不过看社区的进度等这个优化最终能用还不知道得多久，于是我们就自己参考这个思路在管理台做了类似的功能，当升级后出现负载不均衡时人工触发一个逻辑：</p><ul><li>系统根据各个节点的负载情况计算出一个负载最高的节点和 bundle 在页面上展示。</li><li>人工二次确认是否要卸载，确认无误后进行卸载。</li></ul><p>本质上只是将上述优化的自动负载流程改为人工处理了，经过测试效果是一样的。</p><p>Pulsar 整个项目其实非常庞大，有着几十上百个模块，哪怕每次我只改动一行代码准备发布测试时都得经过漫长的编译+ Docker镜像打包+上传私服这些流程，通常需要1~2个小时；但总的来说收获还是很大的，最近也在提一些 issue 和 PR，希望后面能更深入的参与进社区。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/04/d4NqxaoulEXnr5s.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间我们在升级 Pulsar 版本的时候发现升级后最后一个节点始终没有流量。&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/02/07/ZwQ7sfVhuzb4tyv.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然对业务使用没有任何影响，但负载不均会导致资源的浪费。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和同事沟通后得知之前的升级也会出现这样的情况，最终还是人工调用 Pulsar 的 &lt;code&gt;admin API&lt;/code&gt; 完成的负载均衡。&lt;/p&gt;
&lt;p&gt;这个问题我尝试在 Google 和 Pulsar 社区都没有找到类似的，不知道是大家都没碰到还是很少升级集群。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我之前所在的公司就是一个版本走到黑😂&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="消息队列" scheme="http://crossoverjie.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="负载均衡" scheme="http://crossoverjie.top/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>2022 年度总结</title>
    <link href="http://crossoverjie.top/2023/01/18/annual-summary/2022/"/>
    <id>http://crossoverjie.top/2023/01/18/annual-summary/2022/</id>
    <published>2023-01-18T00:08:08.000Z</published>
    <updated>2023-01-17T13:00:54.832Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/17/C9tczrjDlwfVqvR.png"></p><p>一转眼 2022 年又过去了，不多不少距离上次写年终总结过去了 365 天；今年的艰难情况想必大家都亲身经历过了；如果要举行卖惨大会的话今年也许我能排的上号。</p><span id="more"></span><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>今年对大家影响最大的事应该都是疫情了，在年底的最后几天家里的老人还是没顶住疫情的冲击离开了，原以为成年后我已经看淡了生老病死，直到我现在敲下这几行字时才发现这么难过。</p><p>悲伤的事暂且不提，还是聊聊今年生活上的好事吧。</p><h2 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h2><p>首先是健身这个我念叨了几年的运动今年终于被我提上了议程。</p><blockquote><p>本质原因是请了私教，果然是花自己的钱才会心疼。</p></blockquote><p><img src="https://s2.loli.net/2023/01/17/ojP8sQXracSHM3u.png"><br><img src="https://s2.loli.net/2023/01/17/LWSkPHGEMf1R2UO.png"></p><p>体重也由巅峰的 75kg 降到了66kg 左右。<br><img src="https://s2.loli.net/2023/01/17/R38tM2FOocjHGxI.png"></p><iframe src="//player.bilibili.com/player.html?aid=685069016&bvid=BV1aU4y1X7Ya&cid=749168314&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>一段视频便能看出差距。</p><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>今年不记得被哪个视频安利了微软的 XGP 服务，冲动下单了 xbox，顺道集齐了御三家的全家桶。<br><img src="https://s2.loli.net/2023/01/17/DzUT7yHYm59iZ2R.jpg"></p><p>不得不说 XGP 服务是真的香，游戏也很多，我玩的最多的就是光环、地平线5、奥日这几款游戏；原以为 xbox 后续会成为我的主力机，直到几个月后我在 tb 奸商那儿购买的 XGP 服务被微软退款后我就没怎么碰了。</p><p>后面老头环上线，也是我唯一一款花钱购买的 xbox 游戏，在被老头环揉拧了几周后手残党也被劝退，一直到现在估计三个月没开过机了。</p><p>不过最近倒还喜欢上玩 Steam 上的一些独立小游戏，特别是肉鸽类型的，比如这个“吸血鬼幸存者”玩着真的非常上头。</p><p><img src="https://s2.loli.net/2023/01/17/6Y7lmhtQRMy2TiU.png"></p><p>当然今年最期待依然是那个带我入主机坑的“塞尔达传说”，恨不得现在马上快进到5月12号发售日。</p><h2 id="世界杯"><a href="#世界杯" class="headerlink" title="世界杯"></a>世界杯</h2><p>今年还有件大事那就是世界杯的召开，真没想到我还会对足球这么感兴趣；因为当时是封控在家远程工作，所以我几乎把凌晨三点场的都看完了。</p><p>那段时间因为离职心情还比较 EMO，感谢世界杯带给了我一个月的快乐时间。</p><p>当然不出意外的在世界杯期间发生了意外。</p><p><img src="https://s2.loli.net/2023/01/17/jUMOHidkxapyRbW.jpg"></p><p>大半夜睡得好好的，眼睛被我老婆的手指甲刨到了，连夜赶往医院，最后就成了“带土”的 cos 低配版。</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>经常都有大佬说三年是在一家公司的敏感时间，如果感觉不到提升那就需要适当的跳出舒适圈，其实我压根没这个打算，但生活总在你没准备好的时候推你一把。</p><p><img src="https://s2.loli.net/2023/01/17/3MGYFZ1fCvLsXBz.png"><br><img src="https://s2.loli.net/2023/01/17/qcZoD2Mr7YX1Ble.jpg"></p><p>由于不可抗力因素，我还是离开了这家我有生以来呆的最开心的一家公司；虽然有许多不舍，但江湖总会相见。</p><p><img src="https://s2.loli.net/2023/01/17/ztTP1F9ChJ23AR8.png"><br><strong>这不我微信里最活跃的依然还是那个群。</strong></p><hr><p>后面我花了一个月的时间把重庆大大小小的公司几乎都看了一遍，甚至还差点去成都工作了；最后阴差阳错的来到了现在的公司做我之前非常向往的基础架构+中间件研发，目前也比较满意。</p><blockquote><p>找工作那段时间也碰到许多有意思的和狗血的事情，年后单独分享。</p></blockquote><h1 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h1><h2 id="GScript"><a href="#GScript" class="headerlink" title="GScript"></a><a href="https://github.com/crossoverJie/gscript">GScript</a></h2><p><img src="https://s2.loli.net/2023/01/17/9O4pzlC6T2ISKkA.png"></p><p>今年个人最满意的就是恶补了编译原理的知识，顺带还做了一个<a href="https://gscript.crossoverjie.top/">脚本语言</a>；现在已经可以拿来编写网站了；也算是一个小目标达成吧。</p><p>回想起开发 gscript 的那段时间，真的是没日没夜的干，每完成一个功能就开心的飞起。</p><h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2><p><img src="https://s2.loli.net/2023/01/17/kHa4Demu15OiytE.png"><br>除此之外在来到现在这家公司后接触了大量 k8s 相关的知识点，也算是把之前学到的理论实践上了；这不昨晚上才在生产环境升级了 Pulsar，这个技能树终于点亮了一些叶子节点。</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p><img src="https://s2.loli.net/2023/01/17/q3CLIhWoM8yEtGY.png"><br><img src="https://s2.loli.net/2023/01/17/hSxHZDsEArRFow1.png"></p><p>今年的技术博客产出居然 23 篇，其中大部分都是和编译原理相关的，也是我一步步学习编译原理到实现脚本语言的过程。</p><hr><p><img src="https://s2.loli.net/2023/01/17/mEPTMByJIAKaiwX.png"><br>同时今年也养成了每日看一篇英文博客的习惯，坚持了几个月效果还是很明显的；比如以前我非常排斥看一些英文资料，要么靠一键翻译，要么就直接只看中文内容。</p><p>现在几乎没有这种排斥的感觉了，大部分英文内容也会耐心的阅读完，这点在我订阅了 Pulsar 的开发组邮件后越发明显，明显的能够知道他们在讲些什么，这点与我多年前订阅 Dubbo 社区邮件的感觉完全不同。</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>以上就是整年的流水账式的回顾，又到了经典的保留立 flag 环节。</p><ul><li>首先是健身保持，都说健身是按年算的，希望到今年四月份为期一年的时候能看到健身的痕迹。</li><li>今年好歹的出去玩一玩，比如港澳地区或是日本，念叨几年了。</li><li>工作技术上能够再提交几个 Pulsar 的 PR，最好是能融入社区；混个脸熟。</li><li>云原生和编译原理相关的继续学起来，下半年把 GScript 实现为编写型语言。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/17/C9tczrjDlwfVqvR.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;一转眼 2022 年又过去了，不多不少距离上次写年终总结过去了 365 天；今年的艰难情况想必大家都亲身经历过了；如果要举行卖惨大会的话今年也许我能排的上号。&lt;/p&gt;</summary>
    
    
    
    <category term="annual-summary" scheme="http://crossoverjie.top/categories/annual-summary/"/>
    
    
  </entry>
  
  <entry>
    <title>Pulsar压测及优化</title>
    <link href="http://crossoverjie.top/2023/01/16/pulsar/pulsar-perf-test/"/>
    <id>http://crossoverjie.top/2023/01/16/pulsar/pulsar-perf-test/</id>
    <published>2023-01-16T00:12:26.000Z</published>
    <updated>2023-01-15T09:56:04.199Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/12/tpk3aXFYZ9BPJb8.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这段时间在做 MQ（Pulsar）相关的治理工作，其中一个部分内容关于消息队列的升级，比如：</p><ul><li>一键创建一个测试集群。</li><li>运行一批测试用例，覆盖我们线上使用到的功能，并输出测试报告。</li><li>模拟压测，输出测试结果。</li></ul><p>本质目的就是想直到新版本升级过程中和升级后对现有业务是否存在影响。</p><span id="more"></span><p>一键创建集群和执行测试用例比较简单，利用了 <code>helm</code> 和 <code>k8s client</code> 的 SDK 把整个流程串起来即可。</p><h1 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h1><p>其实稍微麻烦一点的是压测，<code>Pulsar</code> 官方本身是有提供一个压测工具；只是功能相对比较单一，只能对某批 topic 极限压测，最后输出测试报告。<br>最后参考了官方的压测流程，加入了一些实时监控数据，方便分析整个压测过程中性能的变化。</p><h2 id="客户端-timeout"><a href="#客户端-timeout" class="headerlink" title="客户端 timeout"></a>客户端 timeout</h2><p>随着压测过程中的压力增大，比如压测时间和线程数的提高，客户端会抛出发送消息 timeout 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.apache.pulsar.client.api.PulsarClientException$TimeoutException: </span><br><span class="line">The producer pulsar-test-<span class="number">212</span>-<span class="number">20</span> can not send message to the topic persistent:<span class="comment">//my-tenant/my-ns/perf-topic-0 within given timeout : createdAt 82.964 seconds ago, firstSentAt 8.348 seconds ago, lastSentAt 8.348 seconds ago, retryCount 1</span></span><br></pre></td></tr></table></figure><p>而这个异常在生产业务环境的高峰期偶尔也出现过，这会导致业务数据的丢失；所以正好这次被我复现出来后想着分析下产生的原因以及解决办法。</p><h2 id="源码分析客户端"><a href="#源码分析客户端" class="headerlink" title="源码分析客户端"></a>源码分析客户端</h2><p>既然是客户端抛出的异常所以就先看从异常点开始看起，其实整个过程和产生的原因并不复杂，如下图：</p><p><img src="https://s2.loli.net/2023/01/15/UvNGXC3iz9DjT5k.png"></p><p>客户端流程：</p><ol><li>客户端 producer 发送消息时先将消息发往本地的一个 pending 队列。</li><li>待 broker 处理完（写入 bookkeeper) 返回 ACK 时删除该 pending 队列头的消息。</li><li>后台启动一个定时任务，定期扫描队列头（头部的消息是最后写入的）的消息是否已经过期（过期时间可配置，默认30s)。</li><li>如果已经过期（头部消息过期，说明所有消息都已过期）则遍历队列内的消息依次抛出 <code>PulsarClientException$TimeoutException</code> 异常，最后清空该队列。</li></ol><p>服务端 broker 流程：</p><ol><li>收到消息后调用 bookkeeper API 写入消息。</li><li>写入消息时同时写入回调函数。</li><li>写入成功后执行回调函数，这时会记录一条消息的写入延迟，并通知客户端 ACK。</li><li>通过 broker metric 指标 <code>pulsar_broker_publish_latency</code> 可以获取写入延迟。</li></ol><p>从以上流程可以看出，如果客户端不做兜底措施则在第四步会出现消息丢失，这类本质上不算是 broker 丢消息，而是客户端认为当时 broker 的处理能力达到上限，考虑到消息的实时性从而丢弃了还未发送的消息。</p><h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>通过上述分析，特别是 broker 的写入流程得知，整个写入的主要操作便是写入 bookkeeper，所以 bookkeeper 的写入性能便关系到整个集群的写入性能。</p><p>极端情况下，假设不考虑网络的损耗，如果 <code>bookkeeper</code> 的写入延迟是 0ms，那整个集群的写入性能几乎就是无上限；所以我们重点看看在压测过程中 <code>bookkeeper</code> 的各项指标。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>首先是 CPU：<br><img src="https://s2.loli.net/2023/01/15/Et5urHVQ2xhP6Ja.png"></p><p>从图中可以看到压测过程中 CPU 是有明显增高的，所以我们需要找到压测过程中 bookkeeper 的 CPU 大部分损耗在哪里？</p><p>这里不得不吹一波阿里的 arthas 工具，可以非常方便的帮我们生成火焰图。</p><p><img src="https://s2.loli.net/2023/01/15/QCUTiXjcYeHG3LV.png"></p><p>分析火焰图最简单的一个方法便是查看顶部最宽的函数是哪个，它大概率就是性能的瓶颈。</p><p>在这个图中的顶部并没有明显很宽的函数，大家都差不多，所以并没有明显损耗 CPU 的函数。</p><p>此时在借助云厂商的监控得知并没有得到 CPU 的上限（limit 限制为 8核）。<br><img src="https://s2.loli.net/2023/01/15/8HAkq9ijQNdcFJX.png"></p><hr><p>使用 arthas 过程中也有个小坑，在 k8s 环境中有可能应用启动后没有成功在磁盘写入 pid ，导致查询不到 Java 进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar arthas-boot.jar</span><br><span class="line">[INFO] arthas-boot version: <span class="number">3.6</span><span class="number">.7</span></span><br><span class="line">[INFO] Can not find java process. Try to pass &lt;pid&gt; in command line.</span><br><span class="line">Please select an available pid.</span><br></pre></td></tr></table></figure><p>此时可以直接 <code>ps</code> 拿到进程 <code>ID</code>，然后在启动的时候直接传入 <code>pid</code> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar arthas-boot.jar <span class="number">1</span></span><br></pre></td></tr></table></figure><p>通常情况下这个 <code>pid</code> 是 1。</p><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>既然 CPU 没有问题，那就再看看磁盘是不是瓶颈；</p><p><img src="https://s2.loli.net/2023/01/15/PmMFyefXx23gDwC.png"></p><p>可以看到压测时的 IO 等待时间明显是比日常请求高许多，为了最终确认是否是磁盘的问题，再将磁盘类型换为 SSD 进行测试。</p><p><img src="https://s2.loli.net/2023/01/15/pqnFjJH3zbRkxIV.png"><br>果然即便是压测，SSD磁盘的 IO 也比普通硬盘的正常请求期间延迟更低。</p><p>既然磁盘 IO 延迟降低了，根据前文的分析理论上整个集群的性能应该会有明显的上升，因此对比了升级前后的消息 TPS 写入指标：</p><p><img src="https://s2.loli.net/2023/01/15/xofeW98vVnUzskY.png"></p><p>升级后每秒的写入速率由 40k 涨到 80k 左右，几乎是翻了一倍（果然用钱是最快解决问题的方式）；</p><blockquote><p>但即便是这样，极限压测后依然会出现客户端 timeout，这是因为无论怎么提高服务端的处理性能，依然没法做到没有延迟的写入，各个环节都会有损耗。</p></blockquote><h1 id="升级过程中的-timeout"><a href="#升级过程中的-timeout" class="headerlink" title="升级过程中的 timeout"></a>升级过程中的 timeout</h1><p>还有一个关键的步骤必须要覆盖：模拟生产现场有着大量的生产者和消费者接入收发消息时进行集群升级，对客户端业务的影响。</p><p>根据官方推荐的升级步骤，流程如下：</p><ul><li>Upgrade Zookeeper.</li><li>Disable autorecovery.</li><li>Upgrade Bookkeeper.</li><li>Upgrade Broker.</li><li>Upgrade Proxy.</li><li>Enable autorecovery.</li></ul><p>其中最关键的是升级 Broker 和 Proxy，因为这两个是客户端直接交互的组件。</p><p>本质上升级的过程就是优雅停机，然后使用新版本的 docker 启动；所以客户端一定会感知到 Broker 下线后进行重连，如果能快速自动重连那对客户端几乎没有影响。</p><p><img src="https://s2.loli.net/2023/01/15/1WjaiXs24dTwZ3S.png"><br>在我的测试过程中，2000左右的 producer 以 1k 的发送速率进行消息发送，在 30min 内完成所有组件升级，整个过程客户端会自动快速重连，并不会出现异常以及消息丢失。</p><p>而一旦发送频率增加时，在重启 Broker 的过程中便会出现上文提到的 timeout 异常；初步看起来是在默认的 30s 时间内没有重连成功，导致积压的消息已经超时。</p><p>经过分析源码发现关键的步骤如下：<br><img src="https://s2.loli.net/2023/01/15/V3lZeALxF7vhYHf.png"></p><p>客户端在与 Broker 的长连接状态断开后会自动重连，而重连到具体哪台 Broker 节点是由 <code>LookUpService</code> 处理的，它会根据使用的 topic 获取到它的元数据。</p><blockquote><p>理论上这个过程如果足够快，对客户端就会越无感。</p></blockquote><p>在元数据中包含有该 topic 所属的 bundle 所绑定的  Broker 的具体 IP+端口，这样才能重新连接然后发送消息。</p><blockquote><p>bundle 是一批 topic 的抽象，用来将一批 topic 与 Broker 绑定。</p></blockquote><p>而在一个 Broker 停机的时会自动卸载它所有的 bundle，并由负载均衡器自动划分到在线的 Broker 中，交由他们处理。</p><p>这里会有两种情况降低 LookUpSerive 获取元数据的速度：</p><p>因为所有的 Broker 都是 stateful 有状态节点，所以升级时是从新的节点开始升级，假设是<code>broker-5</code>，假设升级的那个节点的 bundle 切好被转移 <code>broker-4</code>中，客户端此时便会自动重连到 4 这个Broker 中。</p><p>此时客户端正在讲堆积的消息进行重发，而下一个升级的节点正好是 4，那客户端又得等待 bundle 成功 unload 到新的节点，如果恰好是 3 的话那又得套娃了，这样整个消息的重发流程就会被拉长，直到超过等待时间便会超时。</p><p>还有一种情况是 bundle 的数量比较多，导致上面讲到的 unload 时更新元数据到 zookeeper 的时间也会增加。</p><blockquote><p>所以我在考虑 Broker 在升级过程中时，是否可以将 unload 的 bundle 优先与 <code>Broker-0</code>进行绑定，最后全部升级成功后再做一次负载均衡，尽量减少客户端重连的机会。</p></blockquote><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>如果我们想要解决这个 timeout 的异常，也有以下几个方案：</p><ol><li>将 bookkeeper 的磁盘换为写入时延更低的 SSD，提高单节点性能。</li><li>增加 bookkeeper 节点，不过由于 bookkeeper 是有状态的，水平扩容起来比较麻烦，而且一旦扩容再想缩容也比较困难。</li><li>增加客户端写入的超时时间，这个可以配置。</li><li>客户端做好兜底措施，捕获异常、记录日志、或者入库都可以，后续进行消息重发。</li><li>为 bookkeeper 的写入延迟增加报警。</li><li>Spring 官方刚出炉的 Pulsar-starter 已经内置了 producer 相关的 metrics，客户端也可以对这个进行监控报警。</li></ol><p>以上最好实现的就是第四步了，效果好成本低，推荐还没有实现的都尽快 <code>try catch</code> 起来。</p><p>整个测试流程耗费了我一两周的时间，也是第一次全方位的对一款中间件进行测试，其中也学到了不少东西；不管是源码还是架构都对 <code>Pulsar</code> 有了更深入的理解。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/12/tpk3aXFYZ9BPJb8.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这段时间在做 MQ（Pulsar）相关的治理工作，其中一个部分内容关于消息队列的升级，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一键创建一个测试集群。&lt;/li&gt;
&lt;li&gt;运行一批测试用例，覆盖我们线上使用到的功能，并输出测试报告。&lt;/li&gt;
&lt;li&gt;模拟压测，输出测试结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本质目的就是想直到新版本升级过程中和升级后对现有业务是否存在影响。&lt;/p&gt;</summary>
    
    
    
    <category term="Pulsar" scheme="http://crossoverjie.top/categories/Pulsar/"/>
    
    
    <category term="消息队列" scheme="http://crossoverjie.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>模板方法实践</title>
    <link href="http://crossoverjie.top/2022/12/27/desigin-patterns/template-method/"/>
    <id>http://crossoverjie.top/2022/12/27/desigin-patterns/template-method/</id>
    <published>2022-12-27T00:08:08.000Z</published>
    <updated>2023-01-12T06:36:40.276Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/12/TG3RQnjKDOc7vaF.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近不出意外的阳了，加上刚入职新公司不久，所以也没怎么更新；这两天好些后分享一篇前段时间的一个案例：</p><p>最近在设计一个对某个中间件的测试方案，这个测试方案需要包含不同的测试逻辑，但相同的是需要对各个环节进行记录；比如统计耗时、调用通知 API 等相同的逻辑。</p><p>如果每个测试都单独写这些逻辑那无疑是做了许多重复工作了。</p><span id="more"></span><p>基于以上的特征很容易能想到<strong>模板方法</strong>这个设计模式。</p><p>这是一种有上层定义框架，下层提供不同实现的设计模式。</p><p>比如装修房子的时候业主可以按照自己的喜好对不同的房间进行装修，但是整体的户型图不能做修改，比如承重墙是肯定不能打的。</p><p>而这些固定好的条条框框就是上层框架给的约束，下层不同的实现就有业主自己决定；所以对于整栋楼来说框架都是固定好的，让业主在有限的范围内自由发挥也方便物业的管理。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>以我这个案例的背景为例，首先需要定义出上层框架：</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><code>Event</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Event</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增一个任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addJob</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个任务执行完毕</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobName    任务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> finishCost 任务完成耗时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">finishOne</span><span class="params">(String jobName, String finishCost)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**单个任务执行异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobDefine 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">oneException</span><span class="params">(AbstractJobDefine jobDefine, Exception e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有任务执行完毕</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">finishAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    event.addJob();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="type">StopWatch</span> <span class="variable">watch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                watch.start(jobName);</span><br><span class="line">                <span class="comment">// 不同的子业务实现</span></span><br><span class="line">                run(client);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                event.oneException(<span class="built_in">this</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                watch.stop();</span><br><span class="line">                event.finishOne(jobName, StrUtil.format(<span class="string">&quot;cost: &#123;&#125;s&quot;</span>, watch.getTotalTimeSeconds()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, TestCase.EXECUTOR).get(timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        event.oneException(<span class="built_in">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Run busy code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception e</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Client client)</span> <span class="keyword">throws</span> Exception;    </span><br></pre></td></tr></table></figure><p>其中最核心的就是 run 函数，它是一个抽象函数，具体实现交由子类完成；这样不同的测试用例之间也互不干扰，同时整体的流程完全相同：</p><ul><li>记录任务数量</li><li>统计耗时</li><li>异常记录</li></ul><p>等流程。</p><hr><p>接下来看看如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test1</span>(event, <span class="string">&quot;测试1&quot;</span>, client, <span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; c1 = CompletableFuture.runAsync(job1::start, EXECUTOR);</span><br><span class="line"></span><br><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test2</span>(event, <span class="string">&quot;测试2&quot;</span>, client, <span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; c2 = CompletableFuture.runAsync(job2::start, EXECUTOR);</span><br><span class="line"></span><br><span class="line"><span class="type">AbstractJobDefine</span> <span class="variable">job3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test3</span>(event, <span class="string">&quot;测试3&quot;</span>, client, <span class="number">20</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; c3 = CompletableFuture.runAsync(job3::start, EXECUTOR);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(c1, c2, c3);</span><br><span class="line">all.whenComplete((___, __) -&gt; &#123;</span><br><span class="line">    event.finishAll();</span><br><span class="line">    client.close();</span><br><span class="line">&#125;).get();</span><br></pre></td></tr></table></figure><p>显而易见 <code>Test1~3</code> 都继承了 <code>AbstractJobDefine</code> 同时实现了其中的 <code>run</code> 函数，使用的时候只需要创建不同的实例等待他们都执行完成即可。</p><p>以前在 Java 中也有不同的应用：<br><img src="https://s2.loli.net/2023/01/12/dRl4DEIXj1BfNZ2.png"></p><p><a href="https://crossoverjie.top/2019/03/01/algorithm/consistent-hash/?highlight=%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95">https://crossoverjie.top/2019/03/01/algorithm/consistent-hash/?highlight=%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95</a></p><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><p>同样的示例用 Go 自然也可以实现：</p><p><img src="https://s2.loli.net/2023/01/12/Eu6OUrb7jGtLozN.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJobDefine_start</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">event := NewEvent()</span><br><span class="line">j1 := &amp;JobDefine&#123;</span><br><span class="line">Event:   event,</span><br><span class="line">Run:     &amp;run1&#123;&#125;,</span><br><span class="line">JobName: <span class="string">&quot;job1&quot;</span>,</span><br><span class="line">Param1:  <span class="string">&quot;p1&quot;</span>,</span><br><span class="line">Param2:  <span class="string">&quot;p2&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">j2 := &amp;JobDefine&#123;</span><br><span class="line">Event:   event,</span><br><span class="line">Run:     &amp;run2&#123;&#125;,</span><br><span class="line">JobName: <span class="string">&quot;job2&quot;</span>,</span><br><span class="line">Param1:  <span class="string">&quot;p11&quot;</span>,</span><br><span class="line">Param2:  <span class="string">&quot;p22&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">j1.Start()</span><br><span class="line">j2.Start()</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> event.GetChan() &#123;</span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;finish all&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *run2)</span></span> Run(param1, param2 <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;run3 param1:%s, param2:%s&quot;</span>, param1, param2)</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;test err&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *run1)</span></span> Run(param1, param2 <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;run1 param1:%s, param2:%s&quot;</span>, param1, param2)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用起来也与 Java 类似，创建不同的实例；最后等待所有的任务执行完毕。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>设计模式往往是对某些共性能力的抽象，但也没有一个设计模式可以适用于所有的场景；需要对不同的需求选择不同的设计模式。</p><p>至于在工作中如何进行正确的选择，那就需要自己日常的积累了；比如多去了解不同的设计模式对于的场景，或者多去阅读优秀的代码，Java 中的 <code>InputStream/Reader/Writer</code> 这类 IO 相关的类都有具体的应用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/12/TG3RQnjKDOc7vaF.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近不出意外的阳了，加上刚入职新公司不久，所以也没怎么更新；这两天好些后分享一篇前段时间的一个案例：&lt;/p&gt;
&lt;p&gt;最近在设计一个对某个中间件的测试方案，这个测试方案需要包含不同的测试逻辑，但相同的是需要对各个环节进行记录；比如统计耗时、调用通知 API 等相同的逻辑。&lt;/p&gt;
&lt;p&gt;如果每个测试都单独写这些逻辑那无疑是做了许多重复工作了。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://crossoverjie.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="http://crossoverjie.top/tags/Java/"/>
    
    <category term="Go" scheme="http://crossoverjie.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>深入理解闭包实现原理</title>
    <link href="http://crossoverjie.top/2022/10/24/gscript/gscript11-closure/"/>
    <id>http://crossoverjie.top/2022/10/24/gscript/gscript11-closure/</id>
    <published>2022-10-24T00:08:09.000Z</published>
    <updated>2023-01-14T10:21:02.877Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/14/QnYTwcpIxEH5WOm.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>闭包对于一个长期写 <code>Java</code> 的开发者来说估计鲜有耳闻，我在写 <code>Python</code> 和 <code>Go</code> 之前也是没怎么了解，光这名字感觉就有点”神秘莫测”，这篇文章的主要目的就是从编译器的角度来分析闭包，彻底搞懂闭包的实现原理。</p><span id="more"></span><h1 id="函数一等公民"><a href="#函数一等公民" class="headerlink" title="函数一等公民"></a>函数一等公民</h1><p>一门语言在实现闭包之前首先要具有的特性就是：<code>First class function</code> 函数是第一公民。</p><p>简单来说就是函数可以像一个普通的值一样在函数中传递，也能对变量赋值。</p><p>先来看看在 Go 里是如何编写的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> varExternal <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">varInner := <span class="number">20</span></span><br><span class="line">innerFun := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">varExternal++</span><br><span class="line">varInner++</span><br><span class="line"><span class="keyword">return</span> varInner</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> innerFun</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">varExternal = <span class="number">10</span></span><br><span class="line">f2 := f1()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;varInner=%d, varExternal=%d \n&quot;</span>, f2(i), varExternal)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;======&quot;</span>)</span><br><span class="line"></span><br><span class="line">f3 := f1()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;varInner=%d, varExternal=%d \n&quot;</span>, f3(i), varExternal)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">varInner=<span class="number">21</span>, varExternal=<span class="number">11</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line">varInner=<span class="number">22</span>, varExternal=<span class="number">12</span> </span><br><span class="line">======</span><br><span class="line"><span class="number">0</span></span><br><span class="line">varInner=<span class="number">21</span>, varExternal=<span class="number">13</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line">varInner=<span class="number">22</span>, varExternal=<span class="number">14</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里体现了闭包的两个重要特性，第一个自然就是函数可以作为值返回，同时也能赋值给变量。</p><p>第二个就是在闭包函数 <code>f1()</code> 对闭包变量 <code>varInner</code> 的访问，每个闭包函数的引用都会在自己的函数内部保存一份闭包变量 <code>varInner</code>，这样在调用过程中就不会互相影响。</p><p>从打印的结果中也能看出这个特性。</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>闭包之所以不太好理解的主要原因是它不太符合自觉。</p><p><img src="https://s2.loli.net/2023/01/14/FwMJpUvdPgyhCNY.png"></p><p>本质上就是作用域的关系，当我们调用 <code>f1()</code> 函数的时候，会在栈中分配变量 <code>varInner</code>，正常情况下调用完毕后 <code>f1</code> 的栈会弹出，里面的变量 <code>varInner</code> 自然也会销毁才对。</p><p>但在后续的 <code>f2()</code> 和 <code>f3()</code> 调用的时，却依然能访问到 <code>varInner</code>，就这点不符合我们对函数调用的直觉。</p><p>但其实换个角度来看，对 <code>innerFun</code> 来说，他能访问到 <code>varExternal</code> 和 <code>varInner</code> 变量，最外层的 <code>varExternal</code> 就不用说了，一定是可以访问的。</p><p>但对于 <code>varInner</code> 来说就不一定了，这里得分为两种情况；重点得看该语言是<strong>静态&#x2F;动态</strong>作用域。</p><p>就静态作用域来说，每个符号在编译器就确定好了树状关系，运行时不会发生变化；也就是说 <code>varInner</code> 对于 <code>innerFun</code> 这个函数来说在编译期已经确定可以访问了，在运行时自然也是可以访问的。</p><p>但对于动态作用域来说，完全是在运行时才确定访问的变量是哪一个。</p><p>恰好 <code>Go</code> 就是一个静态作用域的语言，所以返回的 <code>innerFun</code> 函数可以一直访问到 <code>varInner</code> 变量。</p><h1 id="实现闭包"><a href="#实现闭包" class="headerlink" title="实现闭包"></a>实现闭包</h1><p>但 Go 是如何做到在 <code>f1()</code> 函数退出之后依然能访问到 <code>f1()</code> 中的变量呢？</p><p>这里我们不妨大胆假设一下：</p><p>首先在编译期扫描出哪些是闭包变量，也就是这里的 <code>varInner</code>，需要将他保存到函数 <code>innerFun()</code> 中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f2 := f1()</span><br><span class="line">f2()</span><br></pre></td></tr></table></figure><p>运行时需要判断出 <code>f2</code> 是一个函数，而不是一个变量，同时得知道它所包含的函数体是 <code>innerFun()</code> 所定义的。</p><p>接着便是执行函数体的 <code>statement</code> 即可。</p><p>而当 <code>f3 := f1()</code> 重新赋值给 <code>f3</code> 时，在 <code>f2</code> 中累加的 <code>varInner</code> 变量将不会影响到 <code>f3</code>，这就得需要在给 <code>f3</code> 赋值的重新赋值一份闭包变量到  <code>f3</code> 中，这样便能达到互不影响的效果。</p><h2 id="闭包扫描"><a href="#闭包扫描" class="headerlink" title="闭包扫描"></a>闭包扫描</h2><p><code>GScript</code> 本身也是支持闭包的，所以把 Go 的代码翻译过来便长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">varExternal</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f1()&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">varInner</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">innerFun</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">println(a);</span><br><span class="line"><span class="type">int</span> c=<span class="number">100</span>;</span><br><span class="line">varExternal++;</span><br><span class="line">varInner++;</span><br><span class="line"><span class="keyword">return</span> varInner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> innerFun;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f2 = f1();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">println(<span class="string">&quot;varInner=&quot;</span> + f2(i) + <span class="string">&quot;, varExternal=&quot;</span> + varExternal);</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;=======&quot;</span>);</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f3 = f1();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">println(<span class="string">&quot;varInner=&quot;</span> + f3(i) + <span class="string">&quot;, varExternal=&quot;</span> + varExternal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">varInner=<span class="number">21</span>, varExternal=<span class="number">11</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">varInner=<span class="number">22</span>, varExternal=<span class="number">12</span></span><br><span class="line">=======</span><br><span class="line"><span class="number">0</span></span><br><span class="line">varInner=<span class="number">21</span>, varExternal=<span class="number">13</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">varInner=<span class="number">22</span>, varExternal=<span class="number">14</span></span><br></pre></td></tr></table></figure><p>可以看到运行结果和 Go 的一样，所以我们来看看 <code>GScript</code> 是如何实现的便也能理解 Go 的原理了。</p><hr><p>先来看看第一步扫描闭包变量：<br><img src="https://s2.loli.net/2023/01/14/uMxlDhkrs1g9zoT.png"></p><p><code>allVariable := c.allVariable(function)</code><br>查询所有的变量，包括父 <code>scope</code> 的变量。</p><p><code>scopeVariable := c.currentScopeVariable(function)</code><br>查询当前 <code>scope</code> 包含下级所有 <code>scope</code> 中的变量，这样一减之后就能知道闭包变量了，然后将所有的闭包变量存放进闭包函数中。</p><h2 id="闭包赋值"><a href="#闭包赋值" class="headerlink" title="闭包赋值"></a>闭包赋值</h2><p><img src="https://s2.loli.net/2023/01/14/tLBOHCpdwfYj7DX.png"><br>之后在 <code>return innerFun</code> 处，将闭包变量的数据赋值到变量中。</p><p><img src="https://s2.loli.net/2023/01/14/2jf6kYVHXBvbmNo.png"></p><h2 id="闭包函数调用"><a href="#闭包函数调用" class="headerlink" title="闭包函数调用"></a>闭包函数调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f2 = f1();</span><br><span class="line"></span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f3 = f1();</span><br></pre></td></tr></table></figure><p>在这里每一次赋值时，都会把 <code>f1()</code> 返回函数复制到变量 <code>f2/f3</code> 中，这样两者所包含的闭包变量就不会互相影响。</p><hr><p><img src="https://s2.loli.net/2023/01/14/OmlVzJLASZpEP73.png"><br>在调用函数变量时，判断到该变量是一个函数，则直接返回函数。</p><p>之后直接调用该函数即可。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>接下来便可以利用 <code>First class function</code> 来试试函数式编程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="type">int</span> value=<span class="number">0</span>;</span><br><span class="line">Test(<span class="type">int</span> v)&#123;</span><br><span class="line">value=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">map</span><span class="params">(func <span class="type">int</span>(<span class="type">int</span>)</span> f)&#123;</span><br><span class="line"><span class="keyword">return</span> f(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> v*v; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> v++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add2</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">v=v+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> v; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span>Test(<span class="number">100</span>);</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> s= square;</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> a= add;</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> a2= add2;</span><br><span class="line">println(t.map(s));</span><br><span class="line">assertEqual(t.map(s),<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">println(t.map(a));</span><br><span class="line">assertEqual(t.map(a),<span class="number">101</span>);</span><br><span class="line"></span><br><span class="line">println(t.map(a2));</span><br><span class="line">assertEqual(t.map(a2),<span class="number">102</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个有点类似于 Java 中流的 map 函数，将函数作为值传递进去，后续支持匿名函数后会更像是函数式编程，现在必须得先定义一个函数变量再进行传递。</p><hr><p>除此之外在 <code>GScript</code> 中的 <code>http</code> 标准库也利用了函数是一等公民的特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准库：Bind route</span></span><br><span class="line">httpHandle(string method, string path, func (HttpContext) handle)&#123;</span><br><span class="line">    <span class="type">HttpContext</span> <span class="variable">ctx</span> <span class="operator">=</span> HttpContext();</span><br><span class="line">    handle(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在绑定路由时，<code>handle</code> 便是一个函数，使用的时候直接传递业务逻辑的 <code>handle</code> 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (HttpContext) handle (HttpContext ctx)&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> Person();</span><br><span class="line">    p.name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    println(<span class="string">&quot;p.name=&quot;</span> + p.name);</span><br><span class="line">    println(<span class="string">&quot;ctx=&quot;</span> + ctx);</span><br><span class="line">    ctx.JSON(<span class="number">200</span>, p);</span><br><span class="line">&#125;</span><br><span class="line">httpHandle(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;/p&quot;</span>, handle);</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说闭包具有以下特性：</p><ul><li>函数需要作为一等公民。</li><li>编译期扫描出所有的闭包变量。</li><li>在返回闭包函数时，为闭包变量赋值。</li><li>每次创建新的函数变量时，需要将闭包数据复制进去，这样闭包变量才不会互相影响。</li><li>调用函数变量时，需要判断为函数，而不是变量。</li></ul><p><img src="https://s2.loli.net/2023/01/14/y2zhcrXgWJbODju.png"><br>可以在 <a href="https://gscript.crossoverjie.top/">Playground</a> 中体验闭包函数打印裴波那切数列的运用。</p><p>本文相关资源链接</p><ul><li><p>GScript 源码：<a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p></li><li><p>Playground 源码：<a href="https://github.com/crossoverJie/gscript-homepage">https://github.com/crossoverJie/gscript-homepage</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/14/QnYTwcpIxEH5WOm.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;闭包对于一个长期写 &lt;code&gt;Java&lt;/code&gt; 的开发者来说估计鲜有耳闻，我在写 &lt;code&gt;Python&lt;/code&gt; 和 &lt;code&gt;Go&lt;/code&gt; 之前也是没怎么了解，光这名字感觉就有点”神秘莫测”，这篇文章的主要目的就是从编译器的角度来分析闭包，彻底搞懂闭包的实现原理。&lt;/p&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="闭包" scheme="http://crossoverjie.top/tags/%E9%97%AD%E5%8C%85/"/>
    
    <category term="closure" scheme="http://crossoverjie.top/tags/closure/"/>
    
  </entry>
  
  <entry>
    <title>如何为 GScript 编写标准库</title>
    <link href="http://crossoverjie.top/2022/10/15/gscript/gscript10-write-native-lib/"/>
    <id>http://crossoverjie.top/2022/10/15/gscript/gscript10-write-native-lib/</id>
    <published>2022-10-15T00:08:09.000Z</published>
    <updated>2023-01-17T09:10:55.342Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/17/Ig7svqZCcPB9FuU.png"></p><h1 id="版本更新"><a href="#版本更新" class="headerlink" title="版本更新"></a>版本更新</h1><p>最近 <code>GScript</code> 更新了 <code>v0.0.11</code> 版本，重点更新了：</p><ul><li><code>Docker</code> 运行环境</li><li>新增了 byte 原始类型</li><li>新增了一些字符串标准库 <code>Strings/StringBuilder</code></li><li>数组切片语法：<code>int[] b = a[1: len(a)];</code></li></ul><blockquote><p>具体更新内容请看下文。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间发布了 <code>GScript</code> 的在线 <code>playground</code>，<br><img src="https://s2.loli.net/2023/01/17/RmTtoqbxPipOgKj.gif"></p><span id="more"></span><p>这是一个可以在线运行 <code>GScript</code> 脚本的网站，其本质原理是接收用户的输入源码从而在服务器上运行的服务；这简直就是后门大开的 <code>XSS</code> 攻击，为保住服务器我设置了运行 <code>API</code> 的后端服务的用户权限，这样可以避免执行一些恶意的请求。</p><p>但也避免不了一些用户执行了一些耗时操作，比如一个死循环、或者是我提供 <code>demo</code> 里的打印杨辉三角。<br><img src="https://s2.loli.net/2023/01/17/LR7EAtxQnB42Wf9.png"></p><p>这本质上是一个递归函数，当打印的三角层数过高时便会非常耗时，同时也非常消耗 CPU。</p><p>有几次我去检查服务器时发现了几个 CPU 过高的进程，基本上都是这样的耗时操作，不可避免的会影响到服务器的性能。</p><h1 id="使用-Docker"><a href="#使用-Docker" class="headerlink" title="使用 Docker"></a>使用 Docker</h1><p>为了解决这类问题，很自然的就能想到可以使用 <code>Docker</code>，所有的资源都和宿主机是隔离开的，无论怎么瞎折腾也不会影响到宿主机。</p><p>说干就干，最后修改了 API 执行脚本的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> <span class="variable">fileName</span> <span class="operator">=</span> d.unix(<span class="string">&quot;Asia/Shanghai&quot;</span>) + <span class="string">&quot;temp.gs&quot;</span> ;</span><br><span class="line">s.writeFile(fileName, body, <span class="number">438</span>);</span><br><span class="line"><span class="type">string</span> <span class="variable">pwd</span> <span class="operator">=</span> s.getwd();</span><br><span class="line"><span class="comment">// string res = s.command(&quot;gscript&quot;, fileName);</span></span><br><span class="line"><span class="type">string</span> <span class="variable">res</span> <span class="operator">=</span> s.command(<span class="string">&quot;docker&quot;</span>,<span class="string">&quot;run&quot;</span>,<span class="string">&quot;--rm&quot;</span>,<span class="string">&quot;-v&quot;</span>, pwd+<span class="string">&quot;:/usr/src/gscript&quot;</span>,<span class="string">&quot;-w&quot;</span>,<span class="string">&quot;/usr/src/gscript&quot;</span>, <span class="string">&quot;crossoverjie/gscript&quot;</span>,<span class="string">&quot;gscript&quot;</span>, fileName);</span><br><span class="line">s.remove(fileName);</span><br><span class="line">r.body = res;</span><br><span class="line">r.ast = dumpAST(body);</span><br><span class="line">r.symbol=dumpSymbol(body);</span><br><span class="line">ctx.JSON(<span class="number">200</span>, r);</span><br></pre></td></tr></table></figure><p>主要修改的就是将直接执行的 <code>GScript</code> 命令修改为了调用 <code>docker</code> 执行。</p><blockquote><p>但其实也还有改进空间，后续新增协程之后可以便可监控运行时间，超时后便会自动 kill 进程。</p></blockquote><p>我也将该 <code>Docker</code> 上传到了 <code>DockerHub</code>，现在大家想在本地体验 <code>GScript</code> 的 <code>REPL</code> 时也只需要运行<code>Docker</code> 就能使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull crossoverjie/gscript</span><br><span class="line">docker run --rm -it  crossoverjie/gscript:latest gscript</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/17/sg67rJAc4BafouI.png"></p><p>当然也可以执行用 <code>Docker</code> 执行 <code>GScript</code> 脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -v $PWD:/usr/src/gscript -w /usr/src/gscript crossoverjie/gscript gscript &#123;yourpath&#125;/temp.gs</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h76194c45pj320g0ee41b.jpg"></p><h1 id="编写-GScript-标准库"><a href="#编写-GScript-标准库" class="headerlink" title="编写 GScript 标准库"></a>编写 GScript 标准库</h1><p>接下来重点聊聊 <code>GScript</code> 标准库的事情，其实编写标准库是一个费时费力的事情。<br><img src="https://s2.loli.net/2023/01/17/oKnZq5mDPpkF7Ix.png"><br>现在编译器已经提供了一些可用的内置函数，借由这些内置函数写一些常见的工具类是完全没有问题的。</p><p>对写 <code>GScript</code> 标准库感谢的朋友可以当做一个参考，这里我打了一个样，先看下运行效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串工具类</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">b</span> <span class="operator">=</span> StringBuilder();</span><br><span class="line">b.writeString(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">b.writeString(<span class="string">&quot;20&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> b.writeString(<span class="string">&quot;30&quot;</span>);</span><br><span class="line"><span class="type">string</span> <span class="variable">s</span> <span class="operator">=</span> b.String();</span><br><span class="line">printf(<span class="string">&quot;s:%s, len=%d &quot;</span>,s,l);</span><br><span class="line">assertEqual(s,<span class="string">&quot;102030&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] b2 = toByteArray(<span class="string">&quot;40&quot;</span>);</span><br><span class="line">b.WriteBytes(b2);</span><br><span class="line">s = b.String();</span><br><span class="line">assertEqual(s,<span class="string">&quot;10203040&quot;</span>);</span><br><span class="line">println(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Strings 工具类</span></span><br><span class="line"><span class="type">Strings</span> <span class="variable">s</span> <span class="operator">=</span> Strings();</span><br><span class="line">string[] elems = &#123;<span class="string">&quot;name=xxx&quot;</span>,<span class="string">&quot;age=xx&quot;</span>&#125;;</span><br><span class="line"><span class="type">string</span> <span class="variable">ret</span> <span class="operator">=</span> s.join(elems, <span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">println(ret);</span><br><span class="line">assertEqual(ret, <span class="string">&quot;name=xxx&amp;age=xx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="variable">b</span> <span class="operator">=</span> s.hasPrefix(<span class="string">&quot;http://www.xx.com&quot;</span>, <span class="string">&quot;http&quot;</span>);</span><br><span class="line">println(b);</span><br><span class="line">assertEqual(b,<span class="literal">true</span>);</span><br><span class="line">b = s.hasPrefix(<span class="string">&quot;http://www.xx.com&quot;</span>, <span class="string">&quot;https&quot;</span>);</span><br><span class="line">println(b);</span><br><span class="line">assertEqual(b,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>其中的实现源码基本上是借鉴了 Go 的标准库，先来看看 <code>StringBuilder</code> 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringBuilder</span>&#123;</span><br><span class="line">    <span class="type">byte</span>[] buf = [<span class="number">0</span>]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// append contents to buf, it returns the length of s</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">writeString</span><span class="params">(string s)</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] temp = toByteArray(s);</span><br><span class="line">        append(buf, temp);</span><br><span class="line">        <span class="keyword">return</span> len(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// append b to buf, it returns the length of b.</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">WriteBytes</span><span class="params">(<span class="type">byte</span>[] b)</span>&#123;</span><br><span class="line">        append(buf, b);</span><br><span class="line">        <span class="keyword">return</span> len(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copies the buffer to a new.</span></span><br><span class="line">    grow(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// when there is not enough space left.</span></span><br><span class="line">            <span class="keyword">if</span> (cap(buf) - len(buf) &lt; n) &#123;</span><br><span class="line">                <span class="type">byte</span>[] newBuf = [len(buf), <span class="number">2</span>*cap(buf)+n]&#123;&#125;;</span><br><span class="line">                copy(newBuf, buf);</span><br><span class="line">                buf = newBuf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string <span class="title function_">String</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是借助了原始的数组类型以及 <code>toByteArray/toString</code> 字节数组和字符串的转换函数实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Strings</span>&#123;</span><br><span class="line">    <span class="comment">// concatenates the elements of its first argument to create a single string. The separator</span></span><br><span class="line">    <span class="comment">// string sep is placed between elements in the resulting string.</span></span><br><span class="line">    string <span class="title function_">join</span><span class="params">(string[] elems, string sep)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len(elems) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len(elems) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> elems[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">byte</span>[] bs = toByteArray(sep);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> len(bs) * (len(elems) -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; len(elems); i++) &#123;</span><br><span class="line">            <span class="type">string</span> <span class="variable">s</span> <span class="operator">=</span> elems[i];</span><br><span class="line">            <span class="type">byte</span>[] bs = toByteArray(s);</span><br><span class="line">            n = n + len(bs);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> StringBuilder();</span><br><span class="line">        sb.grow(n);</span><br><span class="line">        <span class="type">string</span> <span class="variable">first</span> <span class="operator">=</span> elems[<span class="number">0</span>];</span><br><span class="line">        sb.writeString(first);</span><br><span class="line"></span><br><span class="line">        string[] remain = elems[<span class="number">1</span>:len(elems)];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; len(remain); i++)&#123;</span><br><span class="line">            sb.writeString(sep);</span><br><span class="line">            <span class="type">string</span> <span class="variable">r</span> <span class="operator">=</span> remain[i];</span><br><span class="line">            sb.writeString(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.String();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// tests whether the string s begins with prefix.</span></span><br><span class="line">    bool <span class="title function_">hasPrefix</span><span class="params">(string s, string prefix)</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toByteArray(s);</span><br><span class="line">        <span class="type">byte</span>[] bp = toByteArray(prefix);    </span><br><span class="line">        <span class="keyword">return</span> len(bs) &gt;= len(bp) &amp;&amp; toString(bs[<span class="number">0</span>:len(bp)]) == prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Strings</code> 工具类也是类似的，都是一些内置函数的组合运用；</p><p>在写标准库的过程中还会有额外收获，可以再次阅读一遍 Go 标准库的实现流程，换了一种语法实现出来，会加深对 Go 标准库的理解。</p><p>所以欢迎感兴趣的朋友向 <code>GScript</code> 贡献标准库，由于我个人精力有限，实现过程中可能会发现缺少某些内置函数或数据结构，这也没关系，反馈 <code>issue</code> 后我会尽快处理。</p><blockquote><p>由于目前 <code>GScript</code> 还不支持包管理，所以新增的函数可以创建 <code>Class</code> 来实现，后续支持包或者是 <code>namespace</code> 之后直接将该 <code>Class</code> 迁移过去即可。</p></blockquote><hr><p>本文相关资源链接</p><ul><li>GScript 源码：<a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></li><li>Playground 源码：<a href="https://github.com/crossoverJie/gscript-homepage">https://github.com/crossoverJie/gscript-homepage</a></li><li>GScript Docker地址：<a href="https://hub.docker.com/r/crossoverjie/gscript">https://hub.docker.com/r/crossoverjie/gscript</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/17/Ig7svqZCcPB9FuU.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;版本更新&quot;&gt;&lt;a href=&quot;#版本更新&quot; class=&quot;headerlink&quot; title=&quot;版本更新&quot;&gt;&lt;/a&gt;版本更新&lt;/h1&gt;&lt;p&gt;最近 &lt;code&gt;GScript&lt;/code&gt; 更新了 &lt;code&gt;v0.0.11&lt;/code&gt; 版本，重点更新了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Docker&lt;/code&gt; 运行环境&lt;/li&gt;
&lt;li&gt;新增了 byte 原始类型&lt;/li&gt;
&lt;li&gt;新增了一些字符串标准库 &lt;code&gt;Strings/StringBuilder&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数组切片语法：&lt;code&gt;int[] b = a[1: len(a)];&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;具体更新内容请看下文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间发布了 &lt;code&gt;GScript&lt;/code&gt; 的在线 &lt;code&gt;playground&lt;/code&gt;，&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/17/RmTtoqbxPipOgKj.gif&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>用自己的编程语言实现了一个网站（增强版）</title>
    <link href="http://crossoverjie.top/2022/10/08/gscript/gscript08-write-site-enhance/"/>
    <id>http://crossoverjie.top/2022/10/08/gscript/gscript08-write-site-enhance/</id>
    <published>2022-10-08T00:08:09.000Z</published>
    <updated>2023-01-29T02:28:07.741Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/29/Tr3H1wBh9NJi5lQ.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间在<a href="https://crossoverjie.top/2022/09/14/gscript/gscript05-write-site/">《用自己的编程语言实现了一个网站》</a>用介绍了用 <code>GScript</code> 写的一个简单“网站”，虽然是打上引号的；页面长这样：</p><p><img src="https://s2.loli.net/2023/01/29/kXMWY2Dy3RwatHb.png"></p><p>看起来确实非常的挫，其实之前一直也想做一个 <code>GScript</code> 的在线 <code>playground</code> ，于是国庆期间学了一点  皮毛 <code>Vue</code> 加上老弟的帮忙（他是前端开发），最终完成了下面这个网站：</p><p><a href="https://gscript.crossoverjie.top/">https://gscript.crossoverjie.top/</a></p><p><img src="https://s2.loli.net/2023/01/29/3iP94haxUzYWbwe.png"></p><blockquote><p>❤打印源码参考了：<a href="https://wa-lang.org/playground/">https://wa-lang.org/playground/</a></p></blockquote><span id="more"></span><p>在这里可以在线运行 <code>GScript</code> 代码，借助于前端的代码编辑器插件甚至还能有一些语法提示。</p><blockquote><p>不过有些提示与 GScript 的语法不兼容，毕竟编辑器的提示是基于 JavaScript 的语法。</p></blockquote><p><img src="https://s2.loli.net/2023/01/29/RTWZxm42MIJQCBE.png"></p><p>内置了几个 demo，可以选择运行试试。</p><p>同时也支持查看 <code>AST</code> 树和 <code>symbol</code> 符号表。</p><blockquote><p>虽然显示上还有待优化。</p></blockquote><p><img src="https://s2.loli.net/2023/01/29/4h1ySCk5QlVMcZG.png"><br><img src="https://s2.loli.net/2023/01/29/gXsqORWBdDaxry2.png"></p><p>整个后端接口全都是用 <code>GScript</code> 原生代码编写的，所以这也算是 <code>GScript</code> 的一个实际应用案例。</p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="title class_">HttpContext</span>) <span class="title function_">run</span>(<span class="params">HttpContext ctx</span>) &#123;</span><br><span class="line">    string body = ctx.<span class="title function_">postFormValue</span>(<span class="string">&quot;body&quot;</span>);</span><br><span class="line">    string local = d.<span class="title function_">getCurrentTime</span>(<span class="string">&quot;Asia/Shanghai&quot;</span>,<span class="string">&quot;2006-01-02 15:04:05&quot;</span>);</span><br><span class="line">    <span class="title function_">println</span>(<span class="string">&quot;===&quot;</span> + local);</span><br><span class="line">    <span class="title function_">println</span>(body);</span><br><span class="line">    <span class="title function_">println</span>(<span class="string">&quot;===&quot;</span>);</span><br><span class="line">    <span class="title class_">RunResponse</span> r = <span class="title class_">RunResponse</span>();</span><br><span class="line">    <span class="keyword">if</span> (body == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        r.<span class="property">body</span> = <span class="string">&quot;empty code&quot;</span>;</span><br><span class="line">        ctx.<span class="title class_">JSON</span>(<span class="number">200</span>, r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string fileName = d.<span class="title function_">unix</span>(<span class="string">&quot;Asia/Shanghai&quot;</span>) + <span class="string">&quot;temp.gs&quot;</span> ;</span><br><span class="line">    s.<span class="title function_">writeFile</span>(fileName, body, <span class="number">438</span>);</span><br><span class="line">    string pwd = s.<span class="title function_">getwd</span>();</span><br><span class="line">    <span class="comment">// string res = s.command(&quot;gscript&quot;, fileName);</span></span><br><span class="line">    string res = s.<span class="title function_">command</span>(<span class="string">&quot;docker&quot;</span>,<span class="string">&quot;run&quot;</span>,<span class="string">&quot;--rm&quot;</span>,<span class="string">&quot;-v&quot;</span>, pwd+<span class="string">&quot;:/usr/src/gscript&quot;</span>,<span class="string">&quot;-w&quot;</span>,<span class="string">&quot;/usr/src/gscript&quot;</span>, <span class="string">&quot;crossoverjie/gscript&quot;</span>,<span class="string">&quot;gscript&quot;</span>, fileName);</span><br><span class="line">    s.<span class="title function_">remove</span>(fileName);</span><br><span class="line">    r.<span class="property">body</span> = res;</span><br><span class="line">    r.<span class="property">ast</span> = <span class="title function_">dumpAST</span>(body);</span><br><span class="line">    r.<span class="property">symbol</span>=<span class="title function_">dumpSymbol</span>(body);</span><br><span class="line">    ctx.<span class="title class_">JSON</span>(<span class="number">200</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">httpHandle</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/index&quot;</span>, index);</span><br><span class="line"><span class="title function_">httpHandle</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/run&quot;</span>, run);</span><br><span class="line">string[] args = s.<span class="title function_">getOSArgs</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">len</span>(args) ==<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="title function_">httpRun</span>(<span class="string">&quot;:&quot;</span> + args[<span class="number">2</span>]);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">httpRun</span>(<span class="string">&quot;:8000&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际代码量也并不多，将前端输入的代码写入到一个临时文件，再调用 OS 的 <code>command api</code> 在本地执行执行 docker，最后将标准输出和错误返回即可。</p><h1 id="版本更新"><a href="#版本更新" class="headerlink" title="版本更新"></a>版本更新</h1><p>为了能实现上述的需求，所以本次也更新了 <code>GScript</code> 的版本，新增了一些内置 <code>API</code>。</p><p><img src="https://s2.loli.net/2023/01/29/cQUbaZI9s8ONvXA.png"></p><p>主要是新增了 <code>playground</code> 需要的一些 <code>OS api</code>、文件写入、执行系统命令、日期相关等。</p><p>同时将同一类的 <code>API</code> 合并到一个 <code>class</code> 中，方便后期维护与调用。</p><h2 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h2><p>除此之外也新增了一些易用功能，比如现在提供了更友好的编译错误信息：<br><img src="https://s2.loli.net/2023/01/29/Du3Xga8czBTiCQh.png"></p><h2 id="运行时错误"><a href="#运行时错误" class="headerlink" title="运行时错误"></a>运行时错误</h2><p>运行时的异常现在也有对应提示：<br><img src="https://s2.loli.net/2023/01/29/COwbQqXtlsaGdK6.png"></p><p>只不过目前的显示还不太友好，打印的堆栈还是 <code>Go</code> 的，之后会优化为只显示 <code>GScript</code> 的堆栈。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有了在线的 <a href="https://gscript.crossoverjie.top/">playground</a> 后使得对 <code>GScript</code> 感兴趣的门槛更低了一些，欢迎大家试用。</p><hr><p>经过最近几个版本的迭代，<code>GScript</code> 也逐步完善了，基本完成了第一版本的需求。</p><p>后续会继续完善第二阶段的，比如：</p><ul><li>namespace</li><li>包管理</li><li>并发</li></ul><p>等内容，每一项看起来都不是那么容易啊。</p><p>之前有不少人问我 <code>GScript</code> 是拿来解决什么问题的？当时我确实没仔细想过；不过现在经过几个版本的开发有了一点想法：</p><p>是否可以将 <code>GScript</code> 作为一个脚本化的 Go 语言，毕竟 Go 是编译类型的，每次修改发布都需要经过编译才能运行，但如果可以像脚本语言，比如 <code>Python、Bash</code> 修改后就可以直接运行，这在写一些不是那么重的业务时非常有用。</p><p>同时借助于语法糖甚至可以优化掉 Go 本身被人“吐槽”的地方，比如异常、append 函数、没有运算符重载、三目运算符等。</p><blockquote><p>部分吐槽 <code>GScript</code> 已经支持。</p></blockquote><p>同时因为得益于本身也是 Go 编写的，所以 Go 的一些优点也能继承过来，比如轻量级的协程等。</p><p>Go 本身也有大量的第三方库，后续甚至也能直接使用这些现成的库。</p><p>以上只是一些美好的畅想，就像老板画的大饼一样，具体在实现过程中可能又有不一样的想法，欢迎提供建议。</p><p><code>playground</code> 地址：<br><a href="https://gscript.crossoverjie.top/">https://gscript.crossoverjie.top/</a></p><p>源码地址：<br><a href="https://github.com/crossoverjie/gscript">https://github.com/crossoverjie/gscript</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/29/Tr3H1wBh9NJi5lQ.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间在&lt;a href=&quot;https://crossoverjie.top/2022/09/14/gscript/gscript05-write-site/&quot;&gt;《用自己的编程语言实现了一个网站》&lt;/a&gt;用介绍了用 &lt;code&gt;GScript&lt;/code&gt; 写的一个简单“网站”，虽然是打上引号的；页面长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/29/kXMWY2Dy3RwatHb.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;看起来确实非常的挫，其实之前一直也想做一个 &lt;code&gt;GScript&lt;/code&gt; 的在线 &lt;code&gt;playground&lt;/code&gt; ，于是国庆期间学了一点  皮毛 &lt;code&gt;Vue&lt;/code&gt; 加上老弟的帮忙（他是前端开发），最终完成了下面这个网站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gscript.crossoverjie.top/&quot;&gt;https://gscript.crossoverjie.top/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/29/3iP94haxUzYWbwe.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;❤打印源码参考了：&lt;a href=&quot;https://wa-lang.org/playground/&quot;&gt;https://wa-lang.org/playground/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>手写编程语言-递归函数是如何实现的？</title>
    <link href="http://crossoverjie.top/2022/09/27/gscript/gscript07-return/"/>
    <id>http://crossoverjie.top/2022/09/27/gscript/gscript07-return/</id>
    <published>2022-09-27T00:08:08.000Z</published>
    <updated>2022-09-26T17:02:46.600Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6k7cg9ushj20ic05kdge.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章主要是记录一下在 <a href="https://github.com/crossoverJie/gscript">GScript</a> 中实现递归调用时所遇到的坑，类似的问题在中文互联网上我几乎没有找到相关的内容，所以还是很有必要记录一下。</p><p>在开始之前还是简单介绍下本次更新的 <code>GScript</code> v0.0.9 所包含的内容：</p><ul><li>支持可变参数</li><li>优化 <code>append</code> 函数语义</li><li>优化编译错误信息</li><li>最后一个就是支持递归调用</li></ul><span id="more"></span><hr><p>先看第一个可变参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//formats according to a format specifier and writes to standard output.</span></span><br><span class="line">printf(string format, any ...a)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//formats according to a format specifier and returns the resulting string.</span></span><br><span class="line">string <span class="title function_">sprintf</span><span class="params">(string format, any ...a)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>以上是随着本次更新新增的两个标准函数，均支持可变参数，其中使用 <code>...</code> 表示可变参数，调用时如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">printf</span>(<span class="string">&quot;hello %s &quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="title function_">printf</span>(<span class="string">&quot;hello-%s-%s &quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="title function_">printf</span>(<span class="string">&quot;hello-%s-%d &quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="number">123</span>);</span><br><span class="line">string format = <span class="string">&quot;this is %s &quot;</span>;</span><br><span class="line"><span class="title function_">printf</span>(format, <span class="string">&quot;gscript&quot;</span>);</span><br><span class="line"></span><br><span class="line">string s = <span class="title function_">sprintf</span>(<span class="string">&quot;nice to meet %s&quot;</span>, <span class="string">&quot;you&quot;</span>);</span><br><span class="line"><span class="title function_">assertEqual</span>(s,<span class="string">&quot;nice to meet you&quot;</span>);</span><br></pre></td></tr></table></figure><p>与大部分语言类似，可变参数本质上就是一个数组，所以可以拿来循环遍历：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">add</span>(<span class="params">string s, int ...num</span>)&#123;</span><br><span class="line"><span class="title function_">println</span>(s);</span><br><span class="line">int sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="title function_">len</span>(num);i++)&#123;</span><br><span class="line">int v = num[i];</span><br><span class="line">sum = sum+v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">int x = <span class="title function_">add</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="title function_">println</span>(x);</span><br><span class="line"><span class="title function_">assertEqual</span>(x, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// appends &quot;v&quot; to the end of a array &quot;a&quot;</span></span><br><span class="line"><span class="title function_">append</span>(<span class="params">any[] a, any v</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>之后是优化了内置函数 <code>append()</code> 的语义，本次优化来自于 issue12 的建议：<br><a href="https://github.com/crossoverJie/gscript/issues/12">https://github.com/crossoverJie/gscript/issues/12</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line">int[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="title function_">println</span>(a);</span><br><span class="line"><span class="title function_">println</span>();</span><br><span class="line">a = <span class="title function_">append</span>(a,<span class="number">4</span>);</span><br><span class="line"><span class="title function_">println</span>(a);</span><br><span class="line"><span class="comment">// Output: [1 2 3 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Now</span></span><br><span class="line">int[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="title function_">println</span>(a);</span><br><span class="line"><span class="title function_">println</span>();</span><br><span class="line"><span class="title function_">append</span>(a,<span class="number">4</span>);</span><br><span class="line">int b = a[<span class="number">3</span>];</span><br><span class="line"><span class="title function_">assertEqual</span>(<span class="number">4</span>, b);</span><br><span class="line"><span class="title function_">println</span>(a);</span><br><span class="line"><span class="comment">// Output: [1 2 3 4]</span></span><br></pre></td></tr></table></figure><p>现在 <code>append</code> 之后不需要再重新赋值，也会追加数据，优化后这里看起来是一个值&#x2F;引用传递的问题，但其实底层也是值传递，只是在语法上增加了这样的语法糖，帮使用者重新做了一次赋值。</p><hr><p>之后是新增了编译错误信息提示，比如下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a+<span class="number">2</span>;</span><br><span class="line">b+c;</span><br></pre></td></tr></table></figure><p>使用没有声明的变量，现在会直接编译失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1:0: undefined: a</span><br><span class="line">2:0: undefined: b</span><br><span class="line">2:2: undefined: c</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">2</span>:<span class="number">0</span>: <span class="keyword">class</span> <span class="title class_">T</span> redeclared <span class="keyword">in</span> <span class="variable language_">this</span> block</span><br></pre></td></tr></table></figure><p>重复声明之类的语法错误也有相关提示。</p><hr><p>最后一个才是本次讨论的重点，也就是递归函数的支持。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">num</span>(<span class="params">int x,int y</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (y==<span class="number">1</span> || y ==x) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">int v1 = <span class="title function_">num</span>(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再上一个版本中 <code>int v1 = num(x - 1, y - 1);</code> 这行代码是不会执行的，具体原因后文会分析。</p><p>现在利用递归便可以实现类似于<code>打印杨辉三角</code>之类的程序了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">num</span>(<span class="params">int x,int y</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (y==<span class="number">1</span> || y ==x) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    int v1 = <span class="title function_">num</span>(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">    int v2 = <span class="title function_">num</span>(x - <span class="number">1</span>, y);</span><br><span class="line">int c = v1+v2;</span><br><span class="line">    <span class="comment">// int c = num(x - 1, y - 1)+num(x - 1, y);</span></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printTriangle</span>(<span class="params">int row</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= row - i; j++) &#123;</span><br><span class="line">           <span class="title function_">print</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="title function_">print</span>(<span class="title function_">num</span>(i, j) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printTriangle</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">      <span class="number">1</span> </span><br><span class="line">     <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">    <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line">   <span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> </span><br><span class="line">  <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">4</span> <span class="number">1</span> </span><br><span class="line"> <span class="number">1</span> <span class="number">5</span> <span class="number">10</span> <span class="number">10</span> <span class="number">5</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">15</span> <span class="number">20</span> <span class="number">15</span> <span class="number">6</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><h1 id="函数中的-return"><a href="#函数中的-return" class="headerlink" title="函数中的 return"></a>函数中的 return</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">num</span>(<span class="params">int x,int y</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (y==<span class="number">1</span> || y ==x) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">int v1 = <span class="title function_">num</span>(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来看看这样的代码为什么执行完 <code>return 1</code> 之后就不会执行后边的语句了。</p><p>其实在此之前我首先解决的时候函数 <code>return</code> 后不能执行后续 <code>statement</code> 的需求，其实正好就是上文提到的逻辑，只是这里是递归而已。</p><p>先把代码简化一下方便分析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">f1</span>(<span class="params">int a</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (a==<span class="number">10</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">println</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当参数 a 等于 10 的时候确实不能执行后续的打印语句了，那么如何实现该需求呢？</p><p>以正常人类的思考方式：当我们执行完 <code>return</code> 语句的时候，就应该标记该语句所属的函数直接返回，不能在执行后续的 <code>statement</code>。</p><p>可是这应该如何实操呢？</p><p>其实看看 <code>AST</code> 就能明白了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6kgqzbu9xj21ss0u0wiy.jpg"></p><p>当碰到 <code>return</code> 语句的时，会递归向上遍历语法树，标记上所有 <code>block</code> 节点表明这个 <code>block</code> 后续的语句不再执行了，同时还得把返回值记录下来。</p><p>这样当执行到下一个 <code>statement</code> 时，也就是 <code>println(&quot;abc&quot;);</code> 则会判断他所属的 <code>block</code> 是否有被标记，如果有则直接返回，这样便实现了 <code>return</code> 语句不执行后续代码。</p><p>部分实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 return 的时候递归向上扫描所有的 Block，并打上标记，用于后面执行 return 的时候直接返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Visitor)</span></span> scanBlockStatementCtx(tree antlr.ParseTree, value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">context, ok := tree.(*parser.BlockContext)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">if</span> v.blockCtx2Mark == <span class="literal">nil</span> &#123;</span><br><span class="line">v.blockCtx2Mark = <span class="built_in">make</span>(<span class="keyword">map</span>[*parser.BlockContext]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">v.blockCtx2Mark[context] = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> tree.GetParent() != <span class="literal">nil</span> &#123;</span><br><span class="line">v.scanBlockStatementCtx(tree.GetParent().(antlr.ParseTree), value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6kh2esn6jj214m0u0tec.jpg"></p><p>源码地址：<br><a href="https://github.com/crossoverJie/gscript/blob/793d196244416574bd6be641534742e57c54db7a/visitor.go#L182">https://github.com/crossoverJie/gscript/blob/793d196244416574bd6be641534742e57c54db7a/visitor.go#L182</a></p><h1 id="递归的问题"><a href="#递归的问题" class="headerlink" title="递归的问题"></a>递归的问题</h1><p>但同时问题也来了，就是递归的时候也不会执行后续的递归代码了。</p><p>其实解决问题的方法也很简单，就是在判断是否需要直接返回那里新增一个条件，这个 <code>block</code> 中不存在递归调用。</p><p>所以我们就得先知道这个 <code>block</code> 中是否存在递归调用。</p><p>整个过程有以下几步：</p><ul><li>编译期：在函数声明处记录下函数与当前 <code>context</code> 的映射关系。</li><li>编译期：扫描 <code>statement</code> 时，取出该 <code>statement</code> 的 <code>context</code> 所对应的函数。</li><li>编译期：扫描到的 <code>statement</code> 如果是一个函数调用，则判断该函数是否为该 <code>block</code> 中的函数，也就是第二步取出的函数。</li><li>编译期：如果两个函数相等，则将当前 <code>block</code> 标记为递归调用。</li><li>运行期：在刚才判断 <code>return</code> 语句处，额外多出判断当前 <code>block</code> 是否为递归调用，如果是则不能返回。</li></ul><p>部分代码如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6khkphcxtj21660u043f.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6khle6mnvj219a0g2tbj.jpg"></p><p><a href="https://github.com/crossoverJie/gscript/blob/3e179f27cb30ca5c3af57b3fbf2e46075baa266b/resolver/ref_resolver.go#L70">https://github.com/crossoverJie/gscript/blob/3e179f27cb30ca5c3af57b3fbf2e46075baa266b/resolver/ref_resolver.go#L70</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里的递归调用其实卡了我挺长时间的，思路是有的，但是写出来的代码总是和预期不符，当天晚上坐在电脑面前到凌晨两三点，百思不得其解。</p><p>最后受不了上床休息的时候，突然一个灵光乍现让我想到了解决方案，于是第二天起了个早床赶忙实践，还真给解决了。</p><p>所以有些时候碰到棘手问题时给自己放松一下，往往会有出其不意的效果。</p><p>最后是目前的递归在某些情况下性能还有些问题，后续会尽量将这些标记过程都放在编译期，编译慢点没事，但运行时慢那就有问题了。</p><p>之后还会继续优化运行时的异常，目前是直接 <code>panic</code>，堆栈也没有，体感非常不好；欢迎感兴趣的朋友试用反馈bug。</p><p>源码地址：</p><p><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h6k7cg9ushj20ic05kdge.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章主要是记录一下在 &lt;a href=&quot;https://github.com/crossoverJie/gscript&quot;&gt;GScript&lt;/a&gt; 中实现递归调用时所遇到的坑，类似的问题在中文互联网上我几乎没有找到相关的内容，所以还是很有必要记录一下。&lt;/p&gt;
&lt;p&gt;在开始之前还是简单介绍下本次更新的 &lt;code&gt;GScript&lt;/code&gt; v0.0.9 所包含的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持可变参数&lt;/li&gt;
&lt;li&gt;优化 &lt;code&gt;append&lt;/code&gt; 函数语义&lt;/li&gt;
&lt;li&gt;优化编译错误信息&lt;/li&gt;
&lt;li&gt;最后一个就是支持递归调用&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="递归" scheme="http://crossoverjie.top/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="antlr" scheme="http://crossoverjie.top/tags/antlr/"/>
    
  </entry>
  
  <entry>
    <title>手写编程语言-实现运算符重载</title>
    <link href="http://crossoverjie.top/2022/09/18/gscript/gscript06-operator-overloading/"/>
    <id>http://crossoverjie.top/2022/09/18/gscript/gscript06-operator-overloading/</id>
    <published>2022-09-18T00:08:08.000Z</published>
    <updated>2022-09-18T14:04:58.770Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6at95ynkaj21900u07aw.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先带来日常的 <a href="https://github.com/crossoverJie/gscript">GScript</a> 更新：新增了可变参数的特性，语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">add</span>(<span class="params">string s, int ...num</span>)&#123;</span><br><span class="line"><span class="title function_">println</span>(s);</span><br><span class="line">int sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="title function_">len</span>(num);i++)&#123;</span><br><span class="line">int v = num[i];</span><br><span class="line">sum = sum+v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">int x = <span class="title function_">add</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="title function_">println</span>(x);</span><br><span class="line"><span class="title function_">assertEqual</span>(x, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><span id="more"></span><p>得益于可变参数，所以新增了格式化字符串的内置函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//formats according to a format specifier and writes to standard output.</span></span><br><span class="line"><span class="title function_">printf</span>(<span class="params">string format, any ...a</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//formats according to a format specifier and returns the resulting string.</span></span><br><span class="line">string <span class="title function_">sprintf</span>(<span class="params">string format, any ...a</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>下面重点看看 <a href="https://github.com/crossoverJie/gscript#operator-overloading">GScript</a> 所支持的运算符重载是如何实现的。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>运算符重载其实也是多态的一种表现形式，我们可以重写运算符的重载函数，从而改变他们的计算规则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="number">100</span>+<span class="number">2</span>*<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>以这段代码的运算符为例，输出的结果自然是：104.</p><p>但如果我们是对两个对象进行计算呢，举个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">Person(<span class="type">int</span> a)&#123;</span><br><span class="line">age = a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> Person(<span class="number">10</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> Person(<span class="number">20</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> p1+p2;</span><br></pre></td></tr></table></figure><p>这样的写法在 <code>Java/Go</code> 中都会报编译错误，这是因为他们两者都不支持运算符重载；</p><p>但 <code>Python/C#</code> 是支持的，相比之下我觉得 <code>C#</code> 的实现方式更符合 <code>GScript</code> 语法，所以参考 C# 实现了以下的语法规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span> operator + (<span class="title class_">Person</span> p1, <span class="title class_">Person</span> p2)&#123;</span><br><span class="line"><span class="title class_">Person</span> pp = <span class="title class_">Person</span>(p1.<span class="property">age</span>+p2.<span class="property">age</span>);</span><br><span class="line"><span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> p3 = p1+p2;</span><br><span class="line"><span class="title function_">println</span>(<span class="string">&quot;p3.age=&quot;</span>+p3.<span class="property">age</span>);</span><br><span class="line"><span class="title function_">assertEqual</span>(p3.<span class="property">age</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>有几个硬性条件：</p><ul><li>函数名必须是 <code>operator</code> </li><li>名称后跟上运算符即可。</li></ul><blockquote><p>目前支持的运算符有：+-*&#x2F;   &#x3D;&#x3D; !&#x3D; &lt; &lt;&#x3D; &gt; &gt;&#x3D;</p></blockquote><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>以前在使用 <code>Python</code> 运算符重载时就有想过它是如何实现的？但没有深究，这次借着自己实现相关功能从而需要深入理解。</p><p>其中重点就为两步：</p><ol><li>编译期间：记录所有的重载函数和运算符的关系。</li><li>运行期：根据当前的运算找到声明的函数，直接运行即可。</li></ol><p>第一步的重点是扫描所有的重载函数，将重载函数与运算符存放起来，需要关注的是函数的返回值与运算符类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpOverload 重载符</span></span><br><span class="line"><span class="keyword">type</span> OpOverload <span class="keyword">struct</span> &#123;</span><br><span class="line">function  *Func</span><br><span class="line">tokenType <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符重载自定义函数</span></span><br><span class="line">opOverloads []*symbol.OpOverload</span><br></pre></td></tr></table></figure><p>在编译器中使用一个切片存放。</p><p>而在运行期中当两个入参类型相同时，则需要查找重载函数。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6b310mefaj21ky05u3zz.jpg"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetOpFunction 获取运算符重载函数</span></span><br><span class="line"><span class="comment">// 通过返回值以及运算符号(+-*/) 匹配重载函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AnnotatedTree)</span></span> GetOpFunction(returnType symbol.Type, tokenType <span class="type">int</span>) *symbol.Func &#123;</span><br><span class="line"><span class="keyword">for</span> _, overload := <span class="keyword">range</span> a.opOverloads &#123;</span><br><span class="line">isType := overload.GetFunc().GetReturnType().IsType(returnType)</span><br><span class="line"><span class="keyword">if</span> isType &amp;&amp; overload.GetTokenType() == tokenType &#123;</span><br><span class="line"><span class="keyword">return</span> overload.GetFunc()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找方式就是通过编译期存放的数据进行匹配，拿到重载函数后自动调用便实现了重载。</p><p>感兴趣的朋友可以查看相关代码：</p><ul><li><p>编译期：<a href="https://github.com/crossoverJie/gscript/blob/ae729ce7d4cf39fe115121993fcd2222716755e5/resolver/type_scope_resolver.go#L127">https://github.com/crossoverJie/gscript/blob/ae729ce7d4cf39fe115121993fcd2222716755e5/resolver/type_scope_resolver.go#L127</a></p></li><li><p>运行期：<a href="https://github.com/crossoverJie/gscript/blob/499236af549be47ff827c6d55de1fc8e5600b9b3/visitor.go#L387">https://github.com/crossoverJie/gscript/blob/499236af549be47ff827c6d55de1fc8e5600b9b3/visitor.go#L387</a></p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>运算符重载其实并不是一个常用的功能；因为会改变运算符的语义，比如明明是加法却在重载函数中写为减法。</p><p>这会使得代码阅读起来困难，但在某些情况下我们又非常希望语言本身能支持运算符重载。</p><p>比如在 Go 中常用的一个第三方精度库<code>decimal.Decimal</code>，进行运算时只能使用 <code>d1.Add(d2)</code> 这样的函数，当运算复杂时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a5 = (a1.Add(a2).Add(a3)).Mul(a4);</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a5 = (a1+a2+a3)*a4;</span><br></pre></td></tr></table></figure><p>就不如下面这种直观，所以有利有弊吧，多一个选项总不是坏事。</p><p>GScript 源码：<br><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h6at95ynkaj21900u07aw.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;先带来日常的 &lt;a href=&quot;https://github.com/crossoverJie/gscript&quot;&gt;GScript&lt;/a&gt; 更新：新增了可变参数的特性，语法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int &lt;span class=&quot;title function_&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;string s, int ...num&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;title function_&quot;&gt;println&lt;/span&gt;(s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int sum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(int i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;title function_&quot;&gt;len&lt;/span&gt;(num);i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		int v = num[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		sum = sum+v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int x = &lt;span class=&quot;title function_&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title function_&quot;&gt;println&lt;/span&gt;(x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title function_&quot;&gt;assertEqual&lt;/span&gt;(x, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="antlr" scheme="http://crossoverjie.top/tags/antlr/"/>
    
    <category term="运算符重载" scheme="http://crossoverjie.top/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>用自己的编程语言实现了一个网站</title>
    <link href="http://crossoverjie.top/2022/09/14/gscript/gscript05-write-site/"/>
    <id>http://crossoverjie.top/2022/09/14/gscript/gscript05-write-site/</id>
    <published>2022-09-14T00:08:08.000Z</published>
    <updated>2022-09-13T17:38:42.968Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h65ahhmp7uj20h80beweu.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇<a href="https://crossoverjie.top/2022/09/07/gscript/gscript04-preview/">《终于实现了一门属于自己的编程语言》</a> 介绍了自己写的编程语言 <a href="https://github.com/crossoverJie/gscript">GScript</a> ，在文中提到希望最终可以使用 <code>GScript</code> 开发一个网站。</p><p>到目前为止确实是做到了，首页地址：</p><p><a href="https://gscript.crossoverjie.top/index">https://gscript.crossoverjie.top/index</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h65g2ios46j20zk0iyabv.jpg"></p><p>要称为一个网站确实有点勉强，不过也是一个动态网页，因为返回的是 <code>HTML</code>，所以在当前阶段只要不嫌麻烦其实也能写一个“合格”的网站，有点像以前我们学习 <code>Java</code> 时的 <code>servlet</code>。</p><span id="more"></span><p>该页面的源码地址在这里：<br><a href="https://github.com/crossoverjie/gscript-homepage">https://github.com/crossoverjie/gscript-homepage</a></p><p>其实总共也就40来行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GScript</span>&#123;</span><br><span class="line">    string author;</span><br><span class="line">    string[] features;</span><br><span class="line">    string since;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">GScript</span>(string a, string[] f, string s)&#123;</span><br><span class="line">        author = a;</span><br><span class="line">        features = f;</span><br><span class="line">        since = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="title class_">HttpContext</span>) <span class="title function_">index</span>(<span class="params">HttpContext ctx</span>)&#123;</span><br><span class="line">    string[] features = &#123;<span class="string">&quot;statically&quot;</span>, <span class="string">&quot;strongly&quot;</span>&#125;;</span><br><span class="line">    <span class="title class_">GScript</span> gs = <span class="title class_">GScript</span>(<span class="string">&quot;crossoverJie&quot;</span>,features, <span class="string">&quot;2022&quot;</span>);</span><br><span class="line">    string j = <span class="title class_">JSON</span>(gs);</span><br><span class="line">    <span class="title function_">println</span>(j);</span><br><span class="line">    string local = <span class="title function_">getCurrentTime</span>(<span class="string">&quot;Asia/Shanghai&quot;</span>,<span class="string">&quot;2006-01-02 15:04:05&quot;</span>);</span><br><span class="line">    <span class="title function_">println</span>(<span class="string">&quot;local=&quot;</span> + local);</span><br><span class="line">    string html = ^</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>GScript<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                 _     _   </span></span><br><span class="line"><span class="language-xml"> ___ ___ ___ ___|_|___| |_ </span></span><br><span class="line"><span class="language-xml">| . |_ -|  _|  _| | . |  _|</span></span><br><span class="line"><span class="language-xml">|_  |___|___|_| |_|  _|_|  </span></span><br><span class="line"><span class="language-xml">|___|             |_|   v0.0.7   </span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">^+ j +^</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>current ^+ local +^<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com/crossoverjie/gscript-homepage&quot;</span>&gt;</span>GScript-homepace source code<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line">    ^;</span><br><span class="line">    ctx.<span class="title function_">HTML</span>(<span class="number">200</span>, html);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">httpHandle</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/index&quot;</span>, index);</span><br><span class="line">string[] args = <span class="title function_">getOSArgs</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">len</span>(args) ==<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="title function_">httpRun</span>(<span class="string">&quot;:&quot;</span> + args[<span class="number">2</span>]);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">httpRun</span>(<span class="string">&quot;:8000&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全是利用 <code>GScript</code> 所提供的标准库实现的，后文会详细聊聊内置 HTTP 包。</p><h1 id="更新内容"><a href="#更新内容" class="headerlink" title="更新内容"></a>更新内容</h1><p>下面重点来看看 <code>v0.0.8</code> 这个版本相较于上一个更新了哪些地方。</p><p>因为我是把自己当做一个开发者的角度去实现了一个 http 服务，同时还用 <code>GScript</code> 刷了两道简单的 LeetCode；为了让这个过程更流畅，更符合一个现代语言的使用方式，所以本次真的更新不少东西。</p><blockquote><p>刷题源码：<a href="https://github.com/crossoverJie/gscript/tree/main/example/leetcode">https://github.com/crossoverJie/gscript/tree/main/example/leetcode</a></p></blockquote><p>大概如下：</p><ul><li><code>any</code> 类型的支持，简化标准库的实现。</li><li>可以用 <code>^^</code> 来声明多行字符串，方便声明复杂字符串。</li><li>更完善的类型推导，修复了上个版本中某些情况推导不出类型的bug。</li><li>支持运算符重载。</li><li>基本的 http 包，可以开发出 http 服务，目前能响应 <code>JSON</code> 以及 <code>HTML</code>。</li><li>新增内置函数：根据时区获取当前时间、获取应用启动参数等。</li><li><code>JSON</code> 的序列表以及查询，语法级适配了 <a href="https://github.com/crossoverJie/xjson">XJSON</a>。</li><li>修复了在多个 <code>block</code> 嵌套情况下不能正确 <code>return</code> 的 bug。</li></ul><p>其实从这些更新中也能看出，上个版本只是一个简单能用的状态，而现在这个版本已经可以拿来写复杂逻辑了，当然目前还缺乏一些更友好的编译提示以及运行时错误。</p><p>下面仔细聊聊一些更新内容。</p><h2 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h2><p>首先是 <code>any</code> 通用类型，这个类似于 Java 中的 <code>Object</code> 和 Go 中的 <code>interface&#123;&#125;</code>,极大的方便了我们编写一些标准库。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h65gmnjk39j22u20jyjum.jpg"></p><p>以之前内置的 hash 和 len 函数为例，需要对每种类型都实现一遍，非常麻烦而且毫无必要；现在只需要定义一次即可，代码量直接省几倍。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h65go7c0lrj22ui0hqaem.jpg"><br>同理，之前实现的 Map 只支持存放 string 类型，现在便能存放任何类型的数据。</p><blockquote><p>对 any 的实现过程感兴趣的朋友，今后可以单独分享一下。</p></blockquote><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>写 go 或者是 Java 的朋友应该知道，这两门语言都无法对两个对象进行运算，编译器会直接报错。</p><p>但在一些特殊场景下还是蛮好用的，于是我参考了 <code>C#</code> 的语法在 <code>GScript</code> 中也实现了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">int age;</span><br><span class="line"><span class="title class_">Person</span>(int a)&#123;</span><br><span class="line">age = a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> operator + (<span class="title class_">Person</span> p1, <span class="title class_">Person</span> p2)&#123;</span><br><span class="line"><span class="title class_">Person</span> pp = <span class="title class_">Person</span>(p1.<span class="property">age</span>+p2.<span class="property">age</span>);</span><br><span class="line"><span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> operator - (<span class="title class_">Person</span> p1, <span class="title class_">Person</span> p2)&#123;</span><br><span class="line"><span class="title class_">Person</span> pp = <span class="title class_">Person</span>(p1.<span class="property">age</span>-p2.<span class="property">age</span>);</span><br><span class="line"><span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> p1 = <span class="title class_">Person</span>(<span class="number">10</span>);</span><br><span class="line"><span class="title class_">Person</span> p2 = <span class="title class_">Person</span>(<span class="number">20</span>);</span><br><span class="line"><span class="title class_">Person</span> p3 = p1+p2;</span><br><span class="line"><span class="title function_">println</span>(<span class="string">&quot;p3.age=&quot;</span>+p3.<span class="property">age</span>);</span><br><span class="line"><span class="title function_">assertEqual</span>(p3.<span class="property">age</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>声明的函数名称必须为 <code>operator</code>，之后跟上运算符便实现了重载。</p><p>支持的运算符有：<code>+-*/ &lt; &gt;= &lt;= &gt; ==</code>。</p><h2 id="JSON支持"><a href="#JSON支持" class="headerlink" title="JSON支持"></a>JSON支持</h2><p>当前版本中支持将对象、基本类型进行序列化，暂不支持反序列化为对象，但可以根据 <code>JSON</code> 字符串通过一定的语法查询数据。</p><p>内置了两个 JSON 相关函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return JSON string</span></span><br><span class="line">string <span class="title class_">JSON</span>(any a)&#123;&#125;</span><br><span class="line"><span class="comment">// JSON query with path</span></span><br><span class="line">any <span class="title class_">JSON</span>Get(string json, string path)&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">int age;</span><br><span class="line">string name;</span><br><span class="line">float weight;</span><br><span class="line">bool man;</span><br><span class="line"><span class="title class_">Person</span>(string n, int a, float w, bool m)&#123;</span><br><span class="line">name = n;</span><br><span class="line">age = a;</span><br><span class="line">weight = w;</span><br><span class="line">man =m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> p1 = <span class="title class_">Person</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">10</span>,<span class="number">99.99</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="title class_">Person</span> p2 = <span class="title class_">Person</span>(<span class="string">&quot;a&quot;</span>,<span class="number">11</span>,<span class="number">999.99</span>,<span class="literal">false</span>);</span><br><span class="line">string json = <span class="title class_">JSON</span>(p1);</span><br><span class="line"><span class="title function_">println</span>(json);</span><br><span class="line"><span class="comment">// output:&#123;&quot;age&quot;:10,&quot;man&quot;:true,&quot;name&quot;:&quot;abc&quot;,&quot;weight&quot;:99.99&#125;</span></span><br></pre></td></tr></table></figure><p>以这段代码为例，调用 <code>JSON</code> 函数可以将对象序列化为 <code>JSON</code> 字符串。</p><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">int age;</span><br><span class="line">string name;</span><br><span class="line">float weight;</span><br><span class="line">bool man;</span><br><span class="line"><span class="title class_">Person</span>(string n, int a, float w, bool m)&#123;</span><br><span class="line">name = n;</span><br><span class="line">age = a;</span><br><span class="line">weight = w;</span><br><span class="line">man =m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span> p1 = <span class="title class_">Person</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">10</span>,<span class="number">99.99</span>,<span class="literal">true</span>);</span><br><span class="line">string json = <span class="title class_">JSON</span>(p1);</span><br><span class="line"><span class="title function_">println</span>(json);</span><br><span class="line"></span><br><span class="line">int age = <span class="title class_">JSON</span>Get(json, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="title function_">println</span>(age);</span><br><span class="line"><span class="title function_">assertEqual</span>(age,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>JSONGet</code> 函数可以在一个 JSON 字符串中查询任意的数据，这个功能是通过适配 <a href="https://github.com/crossoverJie/xjson">XJSON</a> 实现的，所以 <code>XJSON</code> 支持的查询语法都能实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">string j=^&#123;<span class="string">&quot;age&quot;</span>:<span class="number">10</span>, <span class="string">&quot;abc&quot;</span>:&#123;<span class="string">&quot;def&quot;</span>:<span class="string">&quot;def&quot;</span>&#125;,<span class="string">&quot;list&quot;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;^;</span><br><span class="line"><span class="title class_">String</span> def = <span class="title class_">JSON</span>Get(j, <span class="string">&quot;abc.def&quot;</span>);</span><br><span class="line"><span class="title function_">println</span>(def);</span><br><span class="line"><span class="title function_">assertEqual</span>(def,<span class="string">&quot;def&quot;</span>);</span><br><span class="line">int l1 = <span class="title class_">JSON</span>Get(j, <span class="string">&quot;list[0]&quot;</span>);</span><br><span class="line"><span class="title function_">println</span>(l1);</span><br><span class="line"><span class="title function_">assertEqual</span>(l1,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">string str=^</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bob&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&quot;skill&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;lang&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;go&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;feature&quot;</span>: [</span><br><span class="line">                        <span class="string">&quot;goroutine&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;channel&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;simple&quot;</span>,</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">^;</span><br><span class="line"><span class="title class_">String</span> g = <span class="title class_">JSON</span>Get(str, <span class="string">&quot;skill.lang[0].go.feature[0]&quot;</span>);</span><br><span class="line"><span class="title function_">println</span>(g);</span><br><span class="line"><span class="title function_">assertEqual</span>(g,<span class="string">&quot;goroutine&quot;</span>);</span><br></pre></td></tr></table></figure><p>比如这样复杂的嵌套 <code>JSON</code>，也能通过查询语法获取数据。</p><h2 id="HTTP-包"><a href="#HTTP-包" class="headerlink" title="HTTP 包"></a>HTTP 包</h2><p>HTTP 包是本次升级的重点，标准库中提供了以下函数和类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http lib</span></span><br><span class="line"><span class="comment">// Response json</span></span><br><span class="line"><span class="title class_">FprintfJSON</span>(int code, string path, string json)&#123;&#125;</span><br><span class="line"><span class="comment">// Resonse html</span></span><br><span class="line"><span class="title class_">FprintfHTML</span>(int code, string path, string html)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// path (relative paths may omit leading slash)</span></span><br><span class="line">string <span class="title class_">QueryPath</span>(string path)&#123;&#125;</span><br><span class="line"></span><br><span class="line">string <span class="title class_">FormValue</span>(string path, string key)&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpContext</span>&#123;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="title class_">JSON</span>(int code, any v)&#123;</span><br><span class="line">        string json = <span class="title class_">JSON</span>(v);</span><br><span class="line">        <span class="title class_">FprintfJSON</span>(code, path, json);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">HTML</span>(<span class="params">int code, any v</span>) &#123;</span><br><span class="line">        string html = v;</span><br><span class="line">        <span class="title class_">FprintfHTML</span>(code, path, html);</span><br><span class="line">    &#125;</span><br><span class="line">    string <span class="title function_">queryPath</span>(<span class="params"></span>) &#123;</span><br><span class="line">        string p = <span class="title class_">QueryPath</span>(path);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string <span class="title function_">formValue</span>(<span class="params">string key</span>)&#123;</span><br><span class="line">        string v = <span class="title class_">FormValue</span>(path, key);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bind route</span></span><br><span class="line"><span class="title function_">httpHandle</span>(<span class="params">string method, string path, func (HttpContext) handle</span>)&#123;</span><br><span class="line">    <span class="comment">// println(&quot;path=&quot;+path);</span></span><br><span class="line">    <span class="title class_">HttpContext</span> ctx = <span class="title class_">HttpContext</span>();</span><br><span class="line">    <span class="title function_">handle</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Run http server.</span></span><br><span class="line"><span class="title function_">httpRun</span>(<span class="params">string addr</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>具体的使用流程：</p><ol><li>通过定义一个函数变量实现自己的业务逻辑。</li><li>注册路由。</li><li>启动 HTTP 服务。</li></ol><p>在自己的 <code>handle</code> 中可以通过 <code>HttpContext</code> 对象拿到请求上下文，可以获取请求参数以及响应数据。<br>具体使用示例可以参考这份代码。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h65ha9w1q4j20u00w841m.jpg"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次更新比我预期的要顺利一些，因为语法树和编译器已经基本实现完毕，不会怎么改了，现在新增的特性无非就是运行时实现一些语法糖，大部分都是体力劳动；可能是新鲜感带来的兴奋剂效果，大部分时间都是痛并快乐着。</p><p>比如这两天主要就是在修复多层 <code>block</code> 嵌套时遇到 <code>return</code> 语句无法正确返回的 bug，死活折腾了两夜；终于在无数次分析 AST 找到了解决方案，现在想想确实还是相关经验太少。</p><blockquote><p>对这个 Bug 感兴趣的朋友可以点个赞，后面可以分享一下。</p></blockquote><p>下一阶段重点就是将编译信息好好整理，让开发体验更好。之后抽空再把 <code>SQL</code> 标准库实现了，这样就能愉快的 <code>CURD</code>了。</p><p>最后希望对该项目或者是编译原理感兴趣的朋友可以下载使用，提出宝贵意见，欢迎加我微信交流。</p><p>v0.0.8 下载地址：<br><a href="https://github.com/crossoverJie/gscript/releases/tag/v0.0.8">https://github.com/crossoverJie/gscript/releases/tag/v0.0.8</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h65ahhmp7uj20h80beweu.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇&lt;a href=&quot;https://crossoverjie.top/2022/09/07/gscript/gscript04-preview/&quot;&gt;《终于实现了一门属于自己的编程语言》&lt;/a&gt; 介绍了自己写的编程语言 &lt;a href=&quot;https://github.com/crossoverJie/gscript&quot;&gt;GScript&lt;/a&gt; ，在文中提到希望最终可以使用 &lt;code&gt;GScript&lt;/code&gt; 开发一个网站。&lt;/p&gt;
&lt;p&gt;到目前为止确实是做到了，首页地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gscript.crossoverjie.top/index&quot;&gt;https://gscript.crossoverjie.top/index&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h65g2ios46j20zk0iyabv.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;要称为一个网站确实有点勉强，不过也是一个动态网页，因为返回的是 &lt;code&gt;HTML&lt;/code&gt;，所以在当前阶段只要不嫌麻烦其实也能写一个“合格”的网站，有点像以前我们学习 &lt;code&gt;Java&lt;/code&gt; 时的 &lt;code&gt;servlet&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="antlr" scheme="http://crossoverjie.top/tags/antlr/"/>
    
  </entry>
  
  <entry>
    <title>终于实现了一门属于自己的编程语言</title>
    <link href="http://crossoverjie.top/2022/09/07/gscript/gscript04-preview/"/>
    <id>http://crossoverjie.top/2022/09/07/gscript/gscript04-preview/</id>
    <published>2022-09-07T00:08:08.000Z</published>
    <updated>2022-09-07T09:27:02.794Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5x5v62lgsj21o00u00u2.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>都说程序员的三大浪漫是：操作系统、编译原理、图形学；最后的图形学确实是特定的专业领域，我们几乎接触不到，所以对我来说换成网络更合适一些，最后再加上一个数据库。</p><p>这四项技术如果都能掌握的话那岂不是在 IT 行业横着走了，加上这几年互联网行业越来越不景气，越底层的技术就越不可能被替代；所以为了给自己的 30+ 危机留点出路，从今年上半年开始我就逐渐开始从头学习编译原理。</p><p>功夫不负有心人，经过近一个月的挑灯夜战，每晚都在老婆的催促下才休息，克服了中途好几次想放弃的冲动，终于现在完成了 <a href="https://github.com/crossoverJie/gscript">GScript</a> 一个预览版。</p><blockquote><p>预览版的意思是语法结构与整体设计基本完成，后续更新也不太会改动这部分内容、但还缺少一些易用功能。</p></blockquote><span id="more"></span><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>首先来看看保留环节， <a href="https://github.com/crossoverJie/gscript">GScript</a> 是如何编写 <code>hello world</code> 的。</p><p>hello_world.gs:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ gscript hello_world.gs</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>废话说完了接下来重点聊聊 <code>GScript</code> 所支持的特性了。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5x9767yayj20mi0h6myk.jpg"><br>后文会重点说明每一个特性。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>除了刚才提到的 hello world，再来看一个也是示例代码经常演示的<code>打印斐波那契数列</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">int</span><span class="params">()</span> fib()&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = a+c;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="title function_">int</span><span class="params">()</span> f = fib();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    println(f());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>整体写法与 Go 官方推荐的类似：<a href="https://go.dev/play/p/NeGuDahW2yP">https://go.dev/play/p/NeGuDahW2yP</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib returns a function that returns</span></span><br><span class="line"><span class="comment">// successive Fibonacci numbers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">a, b = b, a+b</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := fib()</span><br><span class="line"><span class="comment">// Function calls are evaluated left-to-right.</span></span><br><span class="line">fmt.Println(f(), f(), f(), f(), f())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都是通过闭包变量实现的，同时也展示了 <code>GScript</code> 对闭包、函数的使用，后文详细介绍闭包的用法。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>GScript</code> 的语法与常见的 <code>Java/Go</code> 类似，所以上手非常简单。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>先来看看基本类型，目前支持 <code>int/string/float/bool</code> 四种基本类型以及 <code>nil</code> 特殊类型。</p><p>变量声明语法和 <code>Java</code> 类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">string b,c;</span><br><span class="line"><span class="type">float</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">10.1</span>;</span><br><span class="line"><span class="type">bool</span> <span class="variable">f</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>个人觉得将类型放在前面，代码阅读起来会更清晰一些，当然这也是个人喜好。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明并初始化</span></span><br><span class="line"><span class="type">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">println(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个空数组并指定大小</span></span><br><span class="line"><span class="type">int</span>[] table = [<span class="number">4</span>]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">println();</span><br><span class="line"><span class="comment">// 向数组 append 数据</span></span><br><span class="line">a = append(a,<span class="number">4</span>);</span><br><span class="line">println(a);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len(a);i++)&#123;</span><br><span class="line">println(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过下标获取数组数据</span></span><br><span class="line"><span class="type">int</span> b=a[<span class="number">2</span>];</span><br><span class="line">println(b);</span><br></pre></td></tr></table></figure><p>其实严格来讲这并不算是数组，因为它的底层是用 <code>Go</code> 切片实现的，所以可以动态扩容。</p><p>以这段代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a=[<span class="number">2</span>]&#123;&#125;;</span><br><span class="line">println(<span class="string">&quot;数组大小:&quot;</span>+len(a));</span><br><span class="line">a = append(a,<span class="number">1</span>);</span><br><span class="line">println(<span class="string">&quot;数组大小:&quot;</span>+len(a));</span><br><span class="line">println(a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">100</span>;</span><br><span class="line">println(a);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组大小:2</span><br><span class="line">数组大小:3</span><br><span class="line">[&lt;nil&gt; &lt;nil&gt; 1]</span><br><span class="line">[100 &lt;nil&gt; 1]</span><br></pre></td></tr></table></figure><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>类的支持非常重要，是实现面向对象的基础，目前还未完全实现面向对象，只实现了数据与函数的封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> v, ListNode n)&#123;</span><br><span class="line">        value =v;</span><br><span class="line">        next = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用构造函数时不需要使用 new 关键字。</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> ListNode(<span class="number">1</span>, nil);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 . 调用对象属性或函数。</span></span><br><span class="line">println(l1.value);</span><br></pre></td></tr></table></figure><p>缺省情况下 <code>class</code> 具有无参构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">int</span> age=<span class="number">10</span>;</span><br><span class="line">string name=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>+age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造函数</span></span><br><span class="line">Person xx= Person();</span><br><span class="line">println(xx.age);</span><br><span class="line">assertEqual(xx.age, <span class="number">10</span>);</span><br><span class="line">println(xx.getAge());</span><br><span class="line">assertEqual(xx.getAge(), <span class="number">110</span>);</span><br></pre></td></tr></table></figure><p>得益于 <code>class</code> 的实现，结合刚才的数组也可以定义出自定义类型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小为 16 的 Person 数组</span></span><br><span class="line">Person[] personList = [<span class="number">16</span>]&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数其实分为两类：</p><ul><li>普通的全局函数。</li><li>类的函数。</li></ul><p>本质上没有任何区别，只是所属范围不同而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断链表是否有环</span></span><br><span class="line">bool <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == nil)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.next == nil)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">bool</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (fast.next != nil)&#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.next == nil)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast.next.next == nil)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slow.next == nil)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow)&#123;</span><br><span class="line">            ret = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> ListNode(<span class="number">1</span>, nil);</span><br><span class="line"><span class="type">bool</span> <span class="variable">b1</span> <span class="operator">=</span>hasCycle(l1);</span><br><span class="line">println(b1);</span><br><span class="line">assertEqual(b1, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">l4</span> <span class="operator">=</span> ListNode(<span class="number">4</span>, nil);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">l3</span> <span class="operator">=</span> ListNode(<span class="number">3</span>, l4);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> ListNode(<span class="number">2</span>, l3);</span><br><span class="line"><span class="type">bool</span> <span class="variable">b2</span> <span class="operator">=</span> hasCycle(l2);</span><br><span class="line">println(b2);</span><br><span class="line">assertEqual(b2, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">l4.next = l2;</span><br><span class="line"><span class="type">bool</span> <span class="variable">b3</span> <span class="operator">=</span> hasCycle(l2);</span><br><span class="line">println(b3);</span><br><span class="line">assertEqual(b3, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>这里演示了链表是否有环的一个函数，只要有其他语言的使用基础，相信阅读起来没有任何问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="type">int</span> a)&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当函数没有返回值时，可以声明为 void 或直接忽略返回类型。</p></blockquote><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包我认为是非常有意思的一个特性，可以实现很灵活的设计，也是函数式编程的基础。</p><p>所以在 <code>GScript</code> 中函数是作为一等公民存在；因此 <code>GScript</code> 也支持函数类型的变量。</p><p>函数变量声明语法如下：<code>func typeTypeOrVoid &#39;(&#39; typeList? &#39;)&#39;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部变量，全局共享。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">varExternal</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f1()&#123;</span><br><span class="line"><span class="comment">// 闭包变量对每个闭包单独可见</span></span><br><span class="line"><span class="type">int</span> <span class="variable">varInner</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">innerFun</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">println(a);</span><br><span class="line"><span class="type">int</span> c=<span class="number">100</span>;</span><br><span class="line">varExternal++;</span><br><span class="line">varInner++;</span><br><span class="line"><span class="keyword">return</span> varInner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回函数</span></span><br><span class="line"><span class="keyword">return</span> innerFun;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f2 作为一个函数类型，接收的是一个返回值和参数都是 int 的函数。</span></span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f2 = f1();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">println(<span class="string">&quot;varInner=&quot;</span> + f2(i) + <span class="string">&quot;, varExternal=&quot;</span> + varExternal);</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;=======&quot;</span>);</span><br><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f3 = f1();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">println(<span class="string">&quot;varInner=&quot;</span> + f3(i) + <span class="string">&quot;, varExternal=&quot;</span> + varExternal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">varInner=21, varExternal=11</span><br><span class="line">1</span><br><span class="line">varInner=22, varExternal=12</span><br><span class="line">=======</span><br><span class="line">0</span><br><span class="line">varInner=21, varExternal=13</span><br><span class="line">1</span><br><span class="line">varInner=22, varExternal=14</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">int</span><span class="params">(<span class="type">int</span>)</span> f2 = f1();</span><br></pre></td></tr></table></figure><p>以这段代码为例：f2 是一个返回值，入参都为 int 的函数类型；所以后续可以直接当做函数调用 <code>f2(i)</code>.</p><p>例子中将闭包分别赋值给 f2 和 f3 变量，这两个变量中的闭包数据也是互相隔离、互不影响的，所有基于这个特性甚至还是实现面向对象。</p><blockquote><p>关于闭包的实现，后续会单独更新一篇。</p></blockquote><p>更多样例请参考：<a href="https://github.com/crossoverJie/gscript/tree/main/example">https://github.com/crossoverJie/gscript/tree/main/example</a></p><h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><p>标准库源码：<a href="https://github.com/crossoverJie/gscript/tree/main/internal">https://github.com/crossoverJie/gscript/tree/main/internal</a></p><p>目前实现的标准库并不多，这完全是一个体力活；基于现有的语法和基础数据类型，几乎可以实现大部分的数据结构了，所以感兴趣的朋友也欢迎来贡献标准库代码；比如 <code>Stack</code>、<code>Set</code> 之类的数据结构。</p><h2 id="MapString"><a href="#MapString" class="headerlink" title="MapString"></a>MapString</h2><p>以这个 <code>MapString</code> 为例：键值对都为 <code>string</code> 的 <code>HashMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">100</span>;</span><br><span class="line"><span class="type">MapString</span> <span class="variable">m1</span> <span class="operator">=</span> MapString();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line"><span class="type">string</span> <span class="variable">key</span> <span class="operator">=</span> i+<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">string</span> <span class="variable">value</span> <span class="operator">=</span> key;</span><br><span class="line">m1.put(key,value);</span><br><span class="line">&#125;</span><br><span class="line">println(m1.getSize());</span><br><span class="line">assertEqual(m1.getSize(),count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line"><span class="type">string</span> <span class="variable">key</span> <span class="operator">=</span> i+<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">string</span> <span class="variable">value</span> <span class="operator">=</span> m1.get(key);</span><br><span class="line">println(<span class="string">&quot;key=&quot;</span>+key+ <span class="string">&quot;:&quot;</span>+ value);</span><br><span class="line">assertEqual(key,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用起来和 <code>Java</code> 的 <code>HashMap</code> 类似，当然他的实现源码也是参考的 jdk1.7 的 <code>HashMap</code>。</p><blockquote><p>由于目前并有一个类似于 Java 的 <code>object</code> 或者是 go 中的 <code>interface&#123;&#125;</code>, 所以如果需要存放 int，那还得实现一个 MapInt，不过这个通用类型很快会实现。</p></blockquote><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// len 返回数组大小</span></span><br><span class="line">println(len(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组追加数据</span></span><br><span class="line">a = append(a,<span class="number">4</span>);</span><br><span class="line">println(a);</span><br><span class="line"><span class="comment">// output: [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言函数，不相等时会抛出运行时异常，并中断程序。</span></span><br><span class="line">assertEqual(len(a),<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 hashcode</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hashcode</span> <span class="operator">=</span> hash(key);</span><br></pre></td></tr></table></figure><p>也内置了一些基本函数，当然也这不是由 <code>GScript</code> 源码实现的，而是编译器实现的，所以新增起来要稍微麻烦一些；后续会逐步完善，比如和 IO 相关的内置函数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>现阶段的 <code>GScript</code> 还有许多功能没有完善，比如 JSON、网络库、更完善的语法检查、编译报错信息等；现在拿来刷刷 <code>LeetCode</code> 还是没有问题的。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5xaige47gj216o0lkq78.jpg"></p><p>从这 65 个 todo 就能看出还有很长的路要走，我对它的终极目标就是可以编写一个网站那就算是一个成熟的语言了。</p><p>目前还有一个问题是没有集成开发环境，现在的开发体验和白板上写代码相差无异，所以后续有时间的话尝试写一个 VS Code 的插件，至少能有语法高亮与提示。</p><p>最后对 <code>GScript</code> 或者是编译原理感兴趣的小伙伴可以加我微信一起交流。</p><p>项目源码：<a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a><br>下载地址：<a href="https://github.com/crossoverJie/gscript/releases/tag/v0.0.6">https://github.com/crossoverJie/gscript/releases/tag/v0.0.6</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h5x5v62lgsj21o00u00u2.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;都说程序员的三大浪漫是：操作系统、编译原理、图形学；最后的图形学确实是特定的专业领域，我们几乎接触不到，所以对我来说换成网络更合适一些，最后再加上一个数据库。&lt;/p&gt;
&lt;p&gt;这四项技术如果都能掌握的话那岂不是在 IT 行业横着走了，加上这几年互联网行业越来越不景气，越底层的技术就越不可能被替代；所以为了给自己的 30+ 危机留点出路，从今年上半年开始我就逐渐开始从头学习编译原理。&lt;/p&gt;
&lt;p&gt;功夫不负有心人，经过近一个月的挑灯夜战，每晚都在老婆的催促下才休息，克服了中途好几次想放弃的冲动，终于现在完成了 &lt;a href=&quot;https://github.com/crossoverJie/gscript&quot;&gt;GScript&lt;/a&gt; 一个预览版。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;预览版的意思是语法结构与整体设计基本完成，后续更新也不太会改动这部分内容、但还缺少一些易用功能。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="antlr" scheme="http://crossoverjie.top/tags/antlr/"/>
    
  </entry>
  
  <entry>
    <title>自己动手写脚本解释器--实现作用域与函数调用</title>
    <link href="http://crossoverjie.top/2022/08/17/gscript/gscript03-scope-func/"/>
    <id>http://crossoverjie.top/2022/08/17/gscript/gscript03-scope-func/</id>
    <published>2022-08-17T00:08:08.000Z</published>
    <updated>2022-08-16T17:38:48.849Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h594ovvpt6j20k00k0jse.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次利用 Antlr 重构一版 <a href="https://crossoverjie.top/2022/08/08/gscript/gscript02-antlr-statement/">用 Antlr 重构脚本解释器</a> 之后便着手新增其他功能，也就是现在看到的支持了作用域以及函数调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b= <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">age++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b+age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> foo(<span class="number">10</span>);</span><br><span class="line">e = e+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> a+b+<span class="number">3</span>+e;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">// Output:65</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>整个语法规则大部分参考了 Java，现阶段支持了：</p><ul><li>函数声明与调用。</li><li>函数调用的入栈和出栈，保证了函数局部变量在函数退出时销毁。</li><li>作用域支持，内部作用域可以访问外部作用域的变量。</li><li>基本的表达式语句，如 <code>i++, !=,==</code></li></ul><p>这次实现的重点与难点则是作用域与函数调用，实现之后也算是满足了我的好奇心，不过在讲作用域与函数调用之前先来看看一个简单的变量声明与访问语句是如何实现的，这样后续的理解会更加容易。</p><h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">a;</span><br></pre></td></tr></table></figure><blockquote><p>由于还没有实现内置函数，比如控制台输出函数 print()，所以这里就直接访问变量也能拿到数据</p></blockquote><p>运行后结果如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5904p530kj20nc0ewdgo.jpg"></p><p>首先看看变量声明语句的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">variableDeclarators</span><br><span class="line">    : typeType variableDeclarator (&#x27;,&#x27; variableDeclarator)*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">variableDeclarator</span><br><span class="line">    : variableDeclaratorId (&#x27;=&#x27; variableInitializer)?</span><br><span class="line">    ;</span><br><span class="line">typeList</span><br><span class="line">    : typeType (&#x27;,&#x27; typeType)*</span><br><span class="line">    ;</span><br><span class="line">typeType</span><br><span class="line">    : (functionType | primitiveType) (&#x27;[&#x27; &#x27;]&#x27;)*</span><br><span class="line">    ;</span><br><span class="line">primitiveType</span><br><span class="line">    : INT</span><br><span class="line">    | STRING</span><br><span class="line">    | FLOAT</span><br><span class="line">    | BOOLEAN</span><br><span class="line">    ;        </span><br></pre></td></tr></table></figure><p> 只看语法不太直观，直接看下生成的 AST 树就明白了：<br> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5907v0pzmj20w80gkmy9.jpg"><br> 编译期<br> 左边这棵 <code>BlockVardeclar</code> 树对应的就是  <code>int a=10;</code>，右边的 <code>blockStm</code> 对应的就是变量访问 <code>a</code>。</p><p> 整个程序的运行过程分为编译期和运行期，对应的流程：</p><ul><li>遍历 AST 树，做语义分析，生成对应的符号表、类型表、引用消解、还有一些语法校验，比如变量名、函数名是否重复、是否能访问私有变量等。</li><li>运行期：从编译期中生成的符号表、类型表中获取数据，执行具体的代码逻辑。</li></ul><h2 id="访问-AST"><a href="#访问-AST" class="headerlink" title="访问 AST"></a>访问 AST</h2><p>对于刚才提到的编译期和运行期其实分别对应两种访问 <code>AST</code> 的方式，这也是 <code>Antlr</code> 所提供两种方式。</p><h3 id="Listener-模式"><a href="#Listener-模式" class="headerlink" title="Listener 模式"></a>Listener 模式</h3><p>第一种是 <code>Listener</code> 模式，就这名字也能猜到是如何运行的；我们需要实现 Antlr 所提供的接口，这些接口分别对应 AST 树中的不同节点。</p><p>接着 Antlr 会自动遍历这棵树，当访问和退出某个节点时变会回调我们自定义的方法，这些接口都是没有返回值的，所以我们需要将遍历过程中的数据自行存放起来。</p><p>这点非常适合上文提到的编译期，遍历过程中产生的数据自然就会存放到符号表、类型表这些容器中。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h591ozeop0j20u00uote1.jpg"><br>以这段代码为例，我们实现了程序根节点、for循环节点的进入和退出 Listener，当 Antlr 运行到这些节点时便会执行其中的逻辑。</p><p><a href="https://github.com/crossoverJie/gscript/blob/main/resolver/type_scope_resolver.go">https://github.com/crossoverJie/gscript/blob/main/resolver/type_scope_resolver.go</a></p><h3 id="Visitor-模式"><a href="#Visitor-模式" class="headerlink" title="Visitor 模式"></a>Visitor 模式</h3><p><code>Visitor</code> 模式正好和 <code>Listener</code> 相反，这是由我们自行控制需要访问哪个 AST 节点，同时需要在每次访问之后返回数据，这点非常适合来做程序运行期。</p><p>配合在编译期中存放的数据，便可以实现各种特性了。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5922ws8o0j21n00tcgsc.jpg"></p><p>以上图为例，在访问 Prog 节点时便可以从编译期中拿到当前节点所对应的作用域 <code>scope</code>，同时我们可以自行控制访问下一个节点 <code>VisitBlockStms</code>，访问其他节点当然也是可以的，不过通常我们还是按照语法中定义的结构进行访问。</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>即便是同一个语法生成的 AST 是相同的，但我们在遍历 AST 时实现不同也就会导致不同的语义，这就是各个语言语义分析的不同之处。</p><blockquote><p>比如 Java 不允许在子作用域中声明和父作用域中相同的变量，但 JavaScript 却是可以的。</p></blockquote><p>有了上面的基础下面我们来看看作用域是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">a;</span><br></pre></td></tr></table></figure><p>还是以这段代码为例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59355xwevj21bw0rsq9k.jpg"></p><p>这里我简单画了下流程：</p><p>在编译期间会会为当前节点写入一个 <code>scope</code>，以及在 <code>scope</code> 中写入变量 <code>“a”</code>。</p><blockquote><p>这里的写入 scope 和写入变量是分为两次 Listener 进行的，具体代码实现在下面查看源码。</p></blockquote><p>第一次：<br><a href="https://github.com/crossoverJie/gscript/blob/main/resolver/type_scope_resolver.go#L21">https://github.com/crossoverJie/gscript/blob/main/resolver/type_scope_resolver.go#L21</a></p><p>第二次：<br><a href="https://github.com/crossoverJie/gscript/blob/main/resolver/type_resolver.go#L59">https://github.com/crossoverJie/gscript/blob/main/resolver/type_resolver.go#L59</a></p><p>接着是运行期，从编译期中生成的数据拿到 <code>scope</code> 以及其中的变量，获取变量时有一个细节：<br>当前 scope 中如果获取不到需要尝试从父级 <code>scope</code> 中获取，比如如下情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b= <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 b 在当前函数作用域中是获取不到的，只能在父级 <code>scope</code> 中获取。</p><blockquote><p>父级 scope 的关系是在创建 scope 的时候维护进去的，默认当前 scope 就是写入时 scope 的父级。</p></blockquote><p>关键代码试下如下图：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h593bq2mrgj211e0lwtby.jpg"></p><p>第四步获取变量的值也是需要访问到 AST 中的字面量节点获取值即可，核心代码如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h593fchoccj20wa0ia3zy.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h593fwqkgmj217p0u078h.jpg"></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数的调用最核心的就是在运行时需要把当前函数中的所有数据入栈，访问完毕后出栈，这样才能实现函数退出后自动释放函数体类的数据。</p><p>核心代码如下：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h593mb2qrqj216y0u0n37.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b= <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> foo();</span><br><span class="line"><span class="keyword">return</span> a+b+<span class="number">3</span>+e;</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">2</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>即便是有上面这类函数类调其他函数情况也不必担心，无非就是在执行函数体的时候再往栈中写入数据而已，函数退出后会依次退出栈帧。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h593r5bgs5j20rs11bq4b.jpg"></p><p>有点类似于匹配括号的算法 <code>&#123;[()]&#125;</code>，本质上就是递归调用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>限于篇幅其中的许多细节没有仔细讨论，感兴趣的朋友可以直接跑跑单测，debug 试试。</p><p><a href="https://github.com/crossoverJie/gscript/blob/main/compiler_test.go">https://github.com/crossoverJie/gscript/blob/main/compiler_test.go</a></p><p>目前的版本还比较初级，比如基本类型还只有 int，也没有一些常用的内置函数。</p><p>后续会逐步完善，比如新增：</p><ul><li>函数多返回值。</li><li>自定义类型</li><li>闭包</li></ul><p>等特性，这个坑会一直填下去，希望在年底可以用 <code>gscript</code> 写一个 <code>web</code> 服务端那就算是里程碑完成了。</p><p>现阶段也实现了一个简易的 <code>REPL</code> 工具，大家可以安装试用：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h594523npmj20bc0de74n.jpg"></p><p>源码地址：<br><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h594ovvpt6j20k00k0jse.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上次利用 Antlr 重构一版 &lt;a href=&quot;https://crossoverjie.top/2022/08/08/gscript/gscript02-antlr-statement/&quot;&gt;用 Antlr 重构脚本解释器&lt;/a&gt; 之后便着手新增其他功能，也就是现在看到的支持了作用域以及函数调用。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; b= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; age)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		age++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; b+age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a,&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; foo(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	e = e+&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a+b+&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;+e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;add(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Output:65&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="antlr" scheme="http://crossoverjie.top/tags/antlr/"/>
    
  </entry>
  
  <entry>
    <title>用 Antlr 重构脚本解释器</title>
    <link href="http://crossoverjie.top/2022/08/08/gscript/gscript02-antlr-statement/"/>
    <id>http://crossoverjie.top/2022/08/08/gscript/gscript02-antlr-statement/</id>
    <published>2022-08-08T00:08:08.000Z</published>
    <updated>2022-08-07T11:08:02.871Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4y7c4s1gbj20z20kd0we.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一个版本实现的脚本解释器 <a href="https://github.com/crossoverJie/gscript">GScript</a> 中实现了基本的四则运算以及 <code>AST</code> 的生成。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4ybcb7x07j20im0hcgne.jpg"></p><p>当我准备再新增一个 <code>%</code> 取模的运算符时，会发现工作很繁琐而且几乎都是重复的；主要是两步：</p><ol><li>需要在词法解析器中新增对 <code>%</code> 符号的支持。</li><li>在语法解析器遍历 AST 时对 <code>%</code> token 实现具体逻辑。</li></ol><p>其中的词法解析和遍历 AST 完全是重复工作，所以我们可否能够简化这两步呢？</p><span id="more"></span><h1 id="Antlr"><a href="#Antlr" class="headerlink" title="Antlr"></a>Antlr</h1><p><code>Antlr</code> 就是做帮我们解决这些问题的常用工具，利用它我们只需要编写词法文件，然后就可以自动生成词法、语法解析器，并且可以生成不同语言的代码。</p><p>下面以 <code>GScript</code> 的示例来看看 antlr 是如何帮我们生成词法分析器的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGScriptVisitor_Visit_Lexer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">expression := <span class="string">&quot;(2+3) * 2&quot;</span></span><br><span class="line">input := antlr.NewInputStream(expression)</span><br><span class="line">lexer := parser.NewGScriptLexer(input)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">t := lexer.NextToken()</span><br><span class="line"><span class="keyword">if</span> t.GetTokenType() == antlr.TokenEOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s (%q) %d\n&quot;</span>,</span><br><span class="line">lexer.SymbolicNames[t.GetTokenType()], t.GetText(),t.GetColumn())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//output:</span><br><span class="line"> (&quot;(&quot;) 0</span><br><span class="line">DECIMAL_LITERAL (&quot;2&quot;) 1</span><br><span class="line">PLUS (&quot;+&quot;) 2</span><br><span class="line">DECIMAL_LITERAL (&quot;3&quot;) 3</span><br><span class="line"> (&quot;)&quot;) 4</span><br><span class="line">MULT (&quot;*&quot;) 6</span><br><span class="line">DECIMAL_LITERAL (&quot;2&quot;) 8</span><br></pre></td></tr></table></figure><p><code>Antlr </code> 会自动将我们的表达式解析为 <code>token</code>，遍历 <code>token</code> 时还能拿到该 <code>token</code> 所在的代码行数、位置等信息，在编译期间做语法检查非常有用。</p><p>要实现这些我们只需要编写词法、语法规则文件即可。</p><p>刚才的示例所对应的词法、语法规则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">expr</span><br><span class="line">    : &#x27;(&#x27; expr &#x27;)&#x27;                        #NestedExpr</span><br><span class="line">    | liter=literal #Liter</span><br><span class="line">    | lhs=expr bop=( MULT | DIV ) rhs=expr #MultDivExpr</span><br><span class="line">    | lhs=expr bop=MOD rhs=expr            #ModExpr</span><br><span class="line">    | lhs=expr bop=( PLUS | SUB ) rhs=expr #PlusSubExpr</span><br><span class="line">    | expr bop=(LE | GE | GT | LT ) expr # GLe</span><br><span class="line">    | expr bop=(EQUAL | NOTEQUAL) expr # EqualOrNot</span><br><span class="line">    ;</span><br><span class="line">DECIMAL_LITERAL:    (&#x27;0&#x27; | [1-9] (Digits? | &#x27;_&#x27;+ Digits)) [lL]?;    </span><br></pre></td></tr></table></figure><blockquote><p>完整规则：<a href="https://github.com/crossoverJie/gscript/blob/main/GScript.g4">https://github.com/crossoverJie/gscript/blob/main/GScript.g4</a></p></blockquote><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antlr -Dlanguage=Go -o parser -visitor -no-listener GScript.g4</span><br></pre></td></tr></table></figure><p>就可以帮我们生成 <code>Go</code> 的代码（默认是 <code>Java</code>），关于 <code>Antlr</code> 的词法、文法规则以及安装步骤请参考<a href="https://www.antlr.org/">官网</a>。</p><p>而我们要实现具体的语法逻辑时只需要实现相关的接口，<code>Antlr</code> 会自动遍历 <code>AST</code>（当然也可以手动控制），同时在访问不同的 <code>AST</code> 节点时会回调我们自己实现的接口，这样我们就能编写自己的语法规则了。</p><p>以这里的新增的取模运算为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *GScriptVisitor)</span></span> VisitModExpr(ctx *parser.ModExprContext) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">lhs := v.Visit(ctx.GetLhs())</span><br><span class="line">rhs := v.Visit(ctx.GetRhs())</span><br><span class="line"><span class="keyword">return</span> lhs.(<span class="type">int</span>) % rhs.(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>Antlr</code> 回调 <code>VisitModExpr</code> 方法时，便能获取到 % 符号左右两侧的数据，这时只需要做相关运算即可。</p><p>基于这个模式这次新增了一个 <code>statement</code>，具体语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGScriptVisitor_VisitIfElse8</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">expression := <span class="string">`</span></span><br><span class="line"><span class="string">if(3!=(1+2))&#123;</span></span><br><span class="line"><span class="string">return 1+3</span></span><br><span class="line"><span class="string">&#125; else &#123;</span></span><br><span class="line"><span class="string">return false</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">input := antlr.NewInputStream(expression)</span><br><span class="line">lexer := parser.NewGScriptLexer(input)</span><br><span class="line">stream := antlr.NewCommonTokenStream(lexer, <span class="number">0</span>)</span><br><span class="line">parser := parser.NewGScriptParser(stream)</span><br><span class="line">parser.BuildParseTrees = <span class="literal">true</span></span><br><span class="line">tree := parser.Prog()</span><br><span class="line">visitor := GScriptVisitor&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> result = visitor.Visit(tree)</span><br><span class="line">fmt.Println(expression, <span class="string">&quot; result:&quot;</span>, result)</span><br><span class="line">assert.Equal(t, result, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Antlr 还有其他各种优势，比如可以解决：</p><ul><li>左递归。</li><li>二义性。</li><li>优先级。</li></ul><p>等问题。</p><p>这里也推荐在 IDE 中安装 Antlr 的插件，这样就可以直观的查看  AST 语法树，可以帮我们更好的调试代码。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4ydh1xkenj22gk0qm43a.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4ydhe0vnpj217s0r277g.jpg"></p><h1 id="升级-xjson"><a href="#升级-xjson" class="headerlink" title="升级 xjson"></a>升级 xjson</h1><p>借助 <code>GScript</code> 提供的 <code>statement</code>，<code>xjson</code> 也提供了有些有意思的写法：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4yekrs5r5j219w0fu0v9.jpg"></p><p>因为 <code>xjson</code> 的四则运算语法没有使用 <code>Antlr</code> 生成，所以为了能支持 <code>GScript</code> 提供的 <code>statement</code> 需要手写许多词法代码。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4ye5optx1j21ji0u0wir.jpg"></p><p>这也体现了 <code>Antlr</code> 这类前端工具的重要性，效率提升是非常明显的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>借助于 <code>Antlr</code> 后续 <code>GScript</code> 会继续支持函数调用、更完善的类型系统、面向对象等特性；感兴趣的朋友请持续关注。</p><p>源码地址：<br><a href="https://github.com/crossoverJie/gscript">https://github.com/crossoverJie/gscript</a><br><a href="https://github.com/crossoverJie/xjson">https://github.com/crossoverJie/xjson</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h4y7c4s1gbj20z20kd0we.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一个版本实现的脚本解释器 &lt;a href=&quot;https://github.com/crossoverJie/gscript&quot;&gt;GScript&lt;/a&gt; 中实现了基本的四则运算以及 &lt;code&gt;AST&lt;/code&gt; 的生成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h4ybcb7x07j20im0hcgne.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;当我准备再新增一个 &lt;code&gt;%&lt;/code&gt; 取模的运算符时，会发现工作很繁琐而且几乎都是重复的；主要是两步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要在词法解析器中新增对 &lt;code&gt;%&lt;/code&gt; 符号的支持。&lt;/li&gt;
&lt;li&gt;在语法解析器遍历 AST 时对 &lt;code&gt;%&lt;/code&gt; token 实现具体逻辑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中的词法解析和遍历 AST 完全是重复工作，所以我们可否能够简化这两步呢？&lt;/p&gt;</summary>
    
    
    
    <category term="gscript" scheme="http://crossoverjie.top/categories/gscript/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/gscript/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="antlr" scheme="http://crossoverjie.top/tags/antlr/"/>
    
  </entry>
  
  <entry>
    <title>用位运算为你的程序加速</title>
    <link href="http://crossoverjie.top/2022/08/01/gjson/xjson04-bitwisee-operation/"/>
    <id>http://crossoverjie.top/2022/08/01/gjson/xjson04-bitwisee-operation/</id>
    <published>2022-08-01T00:14:36.000Z</published>
    <updated>2022-07-31T07:12:35.226Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4p37zeb9aj20xc0go0tv.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在持续优化之前编写的 <code>JSON</code> 解析库 <a href="https://github.com/crossoverJie/xjson">xjson</a>，主要是两个方面的优化。</p><p>第一个是支持将一个 <code>JSONObject</code> 对象输出为 <code>JSON</code> 字符串。</p><p>这点在上个版本中只是利用自带的 <code>Print</code> 函数打印数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJson4</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">str := <span class="string">`&#123;&quot;people&quot;:&#123;&quot;name&quot;:&#123;&quot;first&quot;:&quot;bob&quot;&#125;&#125;&#125;`</span></span><br><span class="line">first := xjson.Get(str, <span class="string">&quot;people.name.first&quot;</span>)</span><br><span class="line">assert.Equal(t, first.String(), <span class="string">&quot;bob&quot;</span>)</span><br><span class="line">get := xjson.Get(str, <span class="string">&quot;people&quot;</span>)</span><br><span class="line">fmt.Println(get.String())</span><br><span class="line"><span class="comment">//assert.Equal(t, get.String(),`&#123;&quot;name&quot;:&#123;&quot;first&quot;:&quot;bob&quot;&#125;&#125;`)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[name:map[first:bob]]</span><br></pre></td></tr></table></figure><span id="more"></span><p>本次优化之后便能直接输出 JSON 字符串了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4p3ihijjgj20ne05s0sw.jpg"></p><p>实现过程也很简单，只需要递归遍历 object 中的数据，然后拼接字符串即可，核心代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> r.Token &#123;</span><br><span class="line"><span class="keyword">case</span> String:</span><br><span class="line"><span class="keyword">return</span> fmt.Sprint(r.object)</span><br><span class="line"><span class="keyword">case</span> Bool:</span><br><span class="line"><span class="keyword">return</span> fmt.Sprint(r.object)</span><br><span class="line"><span class="keyword">case</span> Number:</span><br><span class="line">i, _ := strconv.Atoi(fmt.Sprint(r.object))</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, i)</span><br><span class="line"><span class="keyword">case</span> Float:</span><br><span class="line">i, _ := strconv.ParseFloat(fmt.Sprint(r.object), <span class="number">64</span>)</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, i)</span><br><span class="line"><span class="keyword">case</span> JSONObject:</span><br><span class="line"><span class="keyword">return</span> object2JSONString(r.object)</span><br><span class="line"><span class="keyword">case</span> ArrayObject:</span><br><span class="line"><span class="keyword">return</span> object2JSONString(r.Array())</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4q0yqg8u1j20u00zl0vy.jpg"></p><h1 id="用位运算优化"><a href="#用位运算优化" class="headerlink" title="用位运算优化"></a>用位运算优化</h1><p>第二个优化主要是提高了性能，查询一个复杂 JSON 数据的时候性能提高了大约 ⏫16%.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">优化前</span></span><br><span class="line">BenchmarkDecode-12         90013             66905 ns/op           42512 B/op       1446 allocs/op</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">优化后</span></span><br><span class="line">BenchmarkDecode-12        104746             59766 ns/op           37749 B/op       1141 allocs/op</span><br></pre></td></tr></table></figure><p>这里截取了一些重点改动的部分：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4q29pojhdj223g0u0gsv.jpg"></p><p>在 JSON 解析过程中会有一个有限状态机状态迁移的过程，而迁移的时候可能会出现多个状态。</p><p>比如当前解析到的 token 值为 <code>&#123;</code>，那它接下来的 token 可能会为 <code>ObjectKey:&quot;name&quot;</code>,也可能会是 <code>BeginObject:&#123;</code>,当然也可能会是 <code>EndObject:&#125;</code>，<br>所以在优化之前我是将状态全部存放在一个集合中的，在解析过程中如果发现状态不满足预期的列表时则会抛出语法异常的错误。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4q2ysk89kj22s409omyd.jpg"></p><p>所以优化之前是遍历这个集合来进行判断的，这样的时间复杂度为 <code>O(N)</code>,但当我们换成位运算就不一样了，时间复杂度直接就变为<code>O(1)</code>了，同时还节省了一个切片的存储空间。</p><p>我们简单来分析下这个位运算为什么会达到判断一个数据是否在一个集合中同样的效果。</p><p>首先以这两个状态为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StatusObjectKey   status = <span class="number">0x0002</span></span><br><span class="line">StatusColon       status = <span class="number">0x0004</span></span><br></pre></td></tr></table></figure><p>他们分别对应的二进制数据为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StatusObjectKey   status = <span class="number">0x0002</span> <span class="comment">//0010</span></span><br><span class="line">StatusColon       status = <span class="number">0x0004</span> <span class="comment">//0100</span></span><br></pre></td></tr></table></figure><p>当我们对这两个数据求 <code>|</code> 运算得到的数据是 <code>0110</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A:<span class="number">0010</span></span><br><span class="line">B:<span class="number">0100</span></span><br><span class="line"></span><br><span class="line">C:<span class="number">0110</span></span><br></pre></td></tr></table></figure><p>这时候如何我们如果用这两个原始数据与 <code>C:0110</code> 做 <code>&amp;</code> 运算时就会还原为刚才的两个数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input:</span></span><br><span class="line">A:<span class="number">0010</span></span><br><span class="line">C:<span class="number">0110</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">A:<span class="number">0010</span></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"><span class="comment">// input:</span></span><br><span class="line">B:<span class="number">0100</span></span><br><span class="line">C:<span class="number">0110</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">B:<span class="number">0100</span></span><br></pre></td></tr></table></figure><p>但我们换一个 D 与 C 求 <code>&amp;</code> 时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D: <span class="number">1000</span> <span class="comment">// 0x0008 对应的二进制为 1000</span></span><br><span class="line">C: <span class="number">0110</span></span><br><span class="line">D<span class="string">&#x27;:0000</span></span><br></pre></td></tr></table></figure><p>将会得到一个 0 值，只要得出的数据大于 0 我们就能判断一个数据是否在给定的集合中了。</p><blockquote><p>当然这里有一个前提条件就是，我们输入的数据高位永远都是是 1 才行，也就是2的幂。</p></blockquote><p>同样的优化在解析查询语法时也有使用：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4q45v8q2dj22va0msaf2.jpg"></p><h1 id="其他奇淫巧技"><a href="#其他奇淫巧技" class="headerlink" title="其他奇淫巧技"></a>其他奇淫巧技</h1><p>当然位运算还有一些其他技巧，比如判断奇偶数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偶数</span></span><br><span class="line">a &amp; <span class="number">1</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 奇数</span></span><br><span class="line">a &amp; <span class="number">1</span> == <span class="number">1</span></span><br></pre></td></tr></table></figure><p>乘法和除法，右移1一位是除以2，左移一位是乘以2.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">2</span></span><br><span class="line">fmt.Println(x&gt;&gt;<span class="number">1</span>) <span class="comment">//1</span></span><br><span class="line">fmt.Println(x&lt;&lt;<span class="number">1</span>) <span class="comment">//4</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>位运算在带来程序性能提升的同时也降低代码可读性，所以我们得按需选择是否使用；</p><p>再一些底层库、框架代码对性能有极致追求的场景推荐使用，但在业务代码中对数据做加减乘除就没必要用位运算了，只会让后续的维护者一脸懵逼。</p><p>相关代码：<a href="https://github.com/crossoverJie/xjson">https://github.com/crossoverJie/xjson</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h4p37zeb9aj20xc0go0tv.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在持续优化之前编写的 &lt;code&gt;JSON&lt;/code&gt; 解析库 &lt;a href=&quot;https://github.com/crossoverJie/xjson&quot;&gt;xjson&lt;/a&gt;，主要是两个方面的优化。&lt;/p&gt;
&lt;p&gt;第一个是支持将一个 &lt;code&gt;JSONObject&lt;/code&gt; 对象输出为 &lt;code&gt;JSON&lt;/code&gt; 字符串。&lt;/p&gt;
&lt;p&gt;这点在上个版本中只是利用自带的 &lt;code&gt;Print&lt;/code&gt; 函数打印数据：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestJson4&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	str := &lt;span class=&quot;string&quot;&gt;`&amp;#123;&amp;quot;people&amp;quot;:&amp;#123;&amp;quot;name&amp;quot;:&amp;#123;&amp;quot;first&amp;quot;:&amp;quot;bob&amp;quot;&amp;#125;&amp;#125;&amp;#125;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	first := xjson.Get(str, &lt;span class=&quot;string&quot;&gt;&amp;quot;people.name.first&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	assert.Equal(t, first.String(), &lt;span class=&quot;string&quot;&gt;&amp;quot;bob&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	get := xjson.Get(str, &lt;span class=&quot;string&quot;&gt;&amp;quot;people&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fmt.Println(get.String())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//assert.Equal(t, get.String(),`&amp;#123;&amp;quot;name&amp;quot;:&amp;#123;&amp;quot;first&amp;quot;:&amp;quot;bob&amp;quot;&amp;#125;&amp;#125;`)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Output:&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;map[name:map[first:bob]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="xjson" scheme="http://crossoverjie.top/categories/xjson/"/>
    
    <category term="compiler" scheme="http://crossoverjie.top/categories/xjson/compiler/"/>
    
    
    <category term="go" scheme="http://crossoverjie.top/tags/go/"/>
    
    <category term="Bitwise operation" scheme="http://crossoverjie.top/tags/Bitwise-operation/"/>
    
  </entry>
  
  <entry>
    <title>【译】Goland 中的隐藏宝石</title>
    <link href="http://crossoverjie.top/2022/07/28/translation/hidden-gems-goland/"/>
    <id>http://crossoverjie.top/2022/07/28/translation/hidden-gems-goland/</id>
    <published>2022-07-28T00:03:13.000Z</published>
    <updated>2022-07-27T16:49:13.445Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://blog.jetbrains.com/go/2022/07/21/hidden-gems-in-goland/">原文链接</a></strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4lrsooqqjj212w0k6t9k.jpg"></p><p>在日常使用 <code>Goland</code> 时，团队收集了一些可以帮助我们专注于创造的同时减少重复工作的小技巧。<br>如果你是在 <code>IDEA</code> 中使用的 <code>Go</code> 插件，或者其他 <code>IntelliJ</code> 的产品，同样也有这些特性。</p><span id="more"></span><h1 id="行排序"><a href="#行排序" class="headerlink" title="行排序"></a>行排序</h1><p>当你在查看文本文件时，行排序非常有用；按照字母排序后能够帮我们更好的阅读，同时也容易找到重复的行。</p><p>在菜单栏中使用 <code>Edit | Sort Lines or Edit | Reverse Lines</code>可以帮我们快速的对选中的代码或者是整个文件进行排序；或者也可以使用快速命令执行这个操作。</p><p><img src="https://lh4.googleusercontent.com/G6g_eIinHwfZchGFPW9cBWYqYzrLuDTQYFafJZ0U0XlibbgANGVZwfgu7UM7bdN1Kr5tiPxk1ELV5F6sgQILyJKyDiziwUGqBOZxUWugfxNvZ9kw4KQBbl9zv-Z4oj8Uxru3Y12glEkhvWAqXxy0R-Q"></p><h1 id="打开对比窗口"><a href="#打开对比窗口" class="headerlink" title="打开对比窗口"></a>打开对比窗口</h1><p>打开一个对比窗口可以帮助我们对比任何文件、文件夹、文本；举个例子，将复制的内容粘贴到对比窗口中，IDE 会类似于版本控制系统那样展示两者的差异。</p><p>当然也可以用快速指令打开对比窗口（double shift)。</p><p><img src="https://lh4.googleusercontent.com/2GtGBX33TZw7WEyVgSYwYcRozVp4AYp8xNYUp4fXtjWXiwolR5ikJdf-AoROpJw1A2HKyolrLR5HAdYUYWbIgJydX01FBOlUQ54BMHh7KS9Jda1Slc0QQp_N-uGwYsBBKAr-yhtsiVWTNrSB6PpYeIA"></p><p>此外你也可以在 IDE 编辑器的任何地方右键鼠标选择与当前粘贴板数据进行对比。</p><blockquote><p>这个功能很棒，可以替换掉以前大部分用 BeyondCompare 的场景了。</p></blockquote><h1 id="暂存文件"><a href="#暂存文件" class="headerlink" title="暂存文件"></a>暂存文件</h1><p>有时候你需要一个随意的地方来编写一段文本，与当前工作相关的一些记录，也或是与当前项目上下文无关的草稿代码；这时候就需要用到暂存文件了。</p><p>暂存文件可不只是简单的笔记，它支持语法高亮、代码提示以及所有和这个文件类型相关的特性。</p><p>暂存文件与当前项目无关，你可以在任意项目中访问到这些文件，这样你就不需要离开 IDE 到其他地方来保存这些文件了。</p><p>可以在菜单栏中新建暂存文件<code>File | New | Scratch File or</code>，也可以使用快捷键 <code>⇧ ⌘ N</code>.</p><p><img src="https://lh4.googleusercontent.com/d-HxnmVYaZOJq8mqJzCMagroGVpg6i7E2VF2j44MhGsqluWKRXENxgZI4sy8pLNaYex6hxSD9Yg0hNM06PgKvKjifGNYYfbA21C4mCiQAN0GctH2SK2fW9DFg1boZ3G2gZyradsaGVH08clG96s1KnY"></p><blockquote><p>通常使用这个功能来存放和运行一些测试或者是实例代码。</p></blockquote><h1 id="多行光标"><a href="#多行光标" class="headerlink" title="多行光标"></a>多行光标</h1><p>多行光标可以让你快速在多个地方同时修改代码，同时它也支持代码提示以及实时模板。</p><p>开启多行光标可以双击 <code>⌥/Ctrl</code> 后不要释放，然后点击上下箭头键。使用 <code>Escape</code> 键可以退出多行光标。</p><p><img src="https://lh3.googleusercontent.com/Zb_1_CiZAP0_6rvAKurH-LsP3OOXqUufkLeeOTWtsCj2EtHAgPZ7sJq3_39oLwwT8bL8gH1eLynMLCQoBI73pUi5STUozXcCOBFry4lGLI-XVEAQYSrQ-opyFv1S_HKt56jYwDAimcFWskDbPpp85nQ"></p><blockquote><p>这个在批量修改代码时非常有用。</p></blockquote><h1 id="批量折叠和展开"><a href="#批量折叠和展开" class="headerlink" title="批量折叠和展开"></a>批量折叠和展开</h1><p>在阅读复杂长篇代码的过程中有时候很难弄懂代码结构，即便是代码是我们自己写的。</p><p>这也容易解决，批量折叠和展开可以快速帮我们浏览代码，快捷键是：macOS:<code>⇧⌘- /⇧⌘+</code>,Windows&#x2F;Linux: <code>Ctrl+Shift+NumPad + / Ctrl+Shift+NumPad</code>。</p><p>IDE 可以帮我们折叠&#x2F;展开选中的代码，如果没有选中则是处理整个文件。</p><p>也可以使用 macOS:<code> ⌥⌘- / ⌥⌘+</code>, Windows&#x2F;Linux:<code>Ctrl+Alt+NumPad + / Ctrl+Alt+NumPad</code> 来递归的处理代码，IDE 将会折叠&#x2F;展开当前代码片段或者是他们包含的片段。</p><p><img src="https://lh5.googleusercontent.com/cYtEgj2G98zshGwM-1a91f6_kqP1ZjLdWA_yQOCsXOo_0KQC4O9HL1Lphs-vdN71kiD_XjZ_Rh5oDo8zhuh9u7KuSacMFqfv6U1F0kXd8zJT3uF3f0GkZgu1P-OgAPGrG77ByWn5UmcK-uIdZ0Iahqo"></p><h1 id="最近文件"><a href="#最近文件" class="headerlink" title="最近文件"></a>最近文件</h1><p>最近文件可以帮助我们快速跳转到最近经常打开的文件，当我们使用 macOS:<code>⌘+E</code> Windows&#x2F;Linux:<code>Ctrl + E</code> 打开最近文件对话框的时，再使用<code>⌘+E</code>可以再次过滤只显示已经修改过的文件，这样可以帮我们更精准的查找。</p><p><img src="https://lh5.googleusercontent.com/dfCbbr1RJYJGM12VmuNf7ebgvi01W3yseLvHLELhaMSyTy_MK2N3VmgXxJqcgJ3NVlYzsX9PV3_qiUA9cy_T8_Z5HGY9FDYyn6AwT9Xk6wTieDHl89hKf0JsCeV3XNZEgPcB9TgjbM8CH4o12RyRhfQ"></p><p>这些特性可能有些并不常用，一旦用上一次解决问题后会发现 <code>IntelliJ</code> 的 <code>IDE</code> 功能非常强大，如果你还发现了一些其他有用的特性请在留言区分享。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://blog.jetbrains.com/go/2022/07/21/hidden-gems-in-goland/&quot;&gt;原文链接&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h4lrsooqqjj212w0k6t9k.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在日常使用 &lt;code&gt;Goland&lt;/code&gt; 时，团队收集了一些可以帮助我们专注于创造的同时减少重复工作的小技巧。&lt;br&gt;如果你是在 &lt;code&gt;IDEA&lt;/code&gt; 中使用的 &lt;code&gt;Go&lt;/code&gt; 插件，或者其他 &lt;code&gt;IntelliJ&lt;/code&gt; 的产品，同样也有这些特性。&lt;/p&gt;</summary>
    
    
    
    <category term="翻译" scheme="http://crossoverjie.top/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="IDE" scheme="http://crossoverjie.top/tags/IDE/"/>
    
  </entry>
  
</feed>
